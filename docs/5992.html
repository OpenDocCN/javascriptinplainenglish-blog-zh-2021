<html>
<head>
<title>Advanced Angular Interview Questions You Must Prepare For in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年你必须准备的高级角度面试题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-angular-interview-questions-you-must-prepare-for-in-2022-f79545eaa46d?source=collection_archive---------0-----------------------#2021-12-23">https://javascript.plainenglish.io/advanced-angular-interview-questions-you-must-prepare-for-in-2022-f79545eaa46d?source=collection_archive---------0-----------------------#2021-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8f71" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最新角度面试问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c3b8cab6b1b5754b3feb978d02888d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V2tsVSCQUNd9mQ2P"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Neel</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我试图为即将到来的面试做准备，在谷歌上搜索，打开链接，每次都看到相同的问题，这有点困难。所以，我想到了分享我的发现，以及如果有人在准备面试，最常见的问题是什么。</p><p id="527b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在最近的Angular开发者面试中最常被问到的面试问题。这些Angular面试问题和答案有助于准备从初级到高级的Angular开发者面试。此外，这篇文章涵盖了你在2022年必须准备的基本问题。</p><p id="8dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也更新了我在前端开发工作中经常问的问题。</p><p id="fb2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一些基本问题开始:</p><h1 id="3a2b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.constructor和ngOnInit有什么区别？</h1><p id="f270" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">面试官脑海中出现的一个常见问题是，构造函数和ngOnInit之间有什么区别？我们通常的回答是，我们在构造函数中写依赖关系，而在ngOninit中写逻辑。</p><p id="cb77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，面试官会查我们还知道些什么？为什么不能把服务或者逻辑放在构造函数里？</p><p id="8c58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的答案是，有时，我们需要等到所有的依赖项都加载完毕；或者对于父/子组件，我们可能需要等到组件加载完毕。这就是为什么最好用ngOnInit编写逻辑的原因。</p><p id="631f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下其他的不同之处。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d8be34f46ef31477610b135dd0691039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*IP_j0b-T0n_LUJ_YPeAkOA.png"/></div></figure><p id="fd73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T3】</strong></p><p id="9f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://stackblitz.com/edit/ngoninit-vs-constructor T4】</p><h1 id="6ddf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.组件和指令有什么区别？</h1><p id="8604" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个也很常见。简单的答案是指令没有影子DOM，而组件有HTML。组件用来破坏基于特性的应用程序，而指令只帮助改变某些元素的行为。</p><p id="681c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看其他一些不同之处。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/02f5eb88041157de156e468d5819fc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0pD-F8vgkWSBVC8p5otqg.png"/></div></div></figure><p id="7d56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em>T9】</strong></p><p id="21c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-directive" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-directive</a></p><h1 id="cca4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.ElementRef、TemplateRef和viewContainerRef有什么区别？</h1><p id="a8d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个问题适用于更高级的角度面试，面试官想知道你是如何操作视图的，或者你是否有在角度应用程序中创建动态视图的经验。</p><p id="1e20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用例子来看看ElementRef、TemplateRef和viewContainterRef之间的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/b89c7e3debd1e969e3f887b76f704faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYWF68QmJ1S8wgyWV86oyg.png"/></div></div></figure><blockquote class="mt mu mv"><p id="a473" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ElementRef示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e5710fb9dc7ec51d92133439119e4344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*o6lusRa79uIw2FdTxLqOJQ.png"/></div></figure><blockquote class="mt mu mv"><p id="d3cd" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">TemplateRef示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cf8a556863efd86467eed8284b401356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*p2KoY-L7T3DdvMxM2bJlgQ.png"/></div></figure><blockquote class="mt mu mv"><p id="4e3d" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ViewContainerRef示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/53025aaa0105c4746e12c5662b0b3ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*Ms7AquQVs_oMl7KgvDS2Nw.png"/></div></figure><p id="6e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T3】</strong></p><p id="9421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/elementref-templateref-viewcontainerref" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/element ref-template ref-viewcontainerref</a></p><h2 id="71b9" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">开始写吧！我在4个月内赚了4000多美元</h2><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/i-earned-over-4000-in-4-months-on-medium-6a63c7da60e"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">我在4个月内赚了4000多美元</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我用简单英语写JavaScript的中级旅程，以及我如何在4个月内赚了4000多美元</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><h1 id="ee57" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.ng-content、ng-template、ng-container有什么区别？</h1><p id="bbfe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">看起来不一样吗？是的，当我学习Angular时，这三个关键词对我来说都是一样的，但实际上，它们都有自己的目的。</p><p id="3588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过例子来看看ng-content、ng-template和ng-container之间的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0cb4e1c06588c9f90a32e5bf67276feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*BHbiMywWwwlOA2-9anrm0w.png"/></div></figure><blockquote class="mt mu mv"><p id="4033" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ng-含量示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f241ce87c0183d9964edda96f4b8e868.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*GRi5EnH2LXPlMf4rnh6EpQ.png"/></div></figure><blockquote class="mt mu mv"><p id="78eb" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ng模板示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/12f85f241c2800fa95255abe005e85ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*qMbt8UnQrXzaH-TP8uSpJA.png"/></div></figure><blockquote class="mt mu mv"><p id="687c" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ng容器示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0738945045981ac509e251f7117c527c.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*ekblWYFuTAuvEu8h8cgzwg.png"/></div></figure><p id="e83e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em>T9】</strong></p><p id="3cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-ng-template-ng-content-ng-container-example" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-ng-template-ng-content-ng-container-example</a></p><h1 id="5ac7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.视图子级和内容子级的区别是什么？</h1><p id="8fa1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们确实处理很多父子或子组件。因为Angular不支持动态创建组件，也不支持根据组件的关系访问相关组件，所以采访者希望我们知道视图-子组件和内容-子组件之间的区别。</p><p id="3554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过例子来看看子视图和子内容之间的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b35be99a025777a92d58832294e79d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*DT1Sf8d5XDbfqSRTfaFyow.png"/></div></figure><blockquote class="mt mu mv"><p id="7a9b" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">视图-子示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/68e0b24b33e51d45259af238d2f30478.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*bCc5w8ON5cNenrw_iEgz_g.png"/></div></figure><blockquote class="mt mu mv"><p id="c2ed" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">内容-子示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b6348c4764f64bed21655ef08e617ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*mYJFPv_SFBQXyklj_jh36g.png"/></div></figure><p id="8cbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T15】</strong></p><p id="6c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angulr-view-content-child" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angulr-view-content-child</a></p><h1 id="50d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.组件视图、主体视图和嵌入视图之间有什么区别？</h1><p id="0778" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个高级的Angular面试问题，可以用来了解Angular中不同的视图是如何工作的。</p><p id="d1f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过示例来检查组件视图、主体视图和嵌入视图之间的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/727fc209aa283912d61aecda3484cf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*rVZdXwYj1UMpIxZNyrr5lQ.png"/></div></figure><blockquote class="mt mu mv"><p id="e4d7" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">嵌入式视图示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2fcabdd6af50606650935a8557b23767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*bnImNkqMhahLpqVCfKOLpg.png"/></div></figure><blockquote class="mt mu mv"><p id="be8a" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">主机视图示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ee1a7e1e62b694894c2f610f730783e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*Q1vr6PduhXhb1-aF2dTLgg.png"/></div></figure><p id="614f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="c991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ng-embedded-view" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ng-embedded-view</a></p><p id="8e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">看看我的新文章……</em></strong></p><h2 id="acbe" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">程序员的30种减压方法</h2><div class="no np gp gr nq nr"><a href="https://js.plainenglish.io/30-friday-stress-relievers-for-programmers-fbcfede676f7" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">程序员的30种减压方法</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">程序员为什么没有乐趣？</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">js .平原英语. io</p></div></div><div class="oa l"><div class="op l oc od oe oa of kp nr"/></div></div></a></div><h1 id="c694" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.去抖时间和油门时间有什么区别？</h1><p id="1947" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们处理反应式表单，并希望用户根据输入输入并检查服务时，这两个术语非常方便。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/f20e8e278f90969e8abc31b5c5b6f328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*G_l-AIA2SmpdQqM9ZhAkcQ.png"/></div></div></figure><p id="26b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T3】</strong></p><p id="4fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://stackblitz.com/edit/throttletimevsdebouncetime T4】</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/frontend-interview-question-what-is-the-difference-between-change-vs-ngmodelchange-f6bb3cb26dbc"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">角度面试问题:‘改变’和‘ngModelChange’有什么区别？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">最常见的前端面试问题2021</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="or l oc od oe oa of kp nr"/></div></div></a></div><h1 id="0e45" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.forEach和map有什么区别？</h1><p id="fde3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们来讨论一下基本的JavaScript面试问题。有时面试官会问我们什么时候可以使用forEach和map，它们之间有什么区别。</p><p id="cd34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看forEach和map之间的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/3b86ee501e3425336c3f9ad0627e06b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*9gsKdSSV3UKtR7cE6XhbOA.png"/></div></figure><p id="98c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em>T9】</strong></p><p id="1504" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ken-demo-foreach-vs-map" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ken-demo-foreach-vs-map</a></p><h1 id="3e8f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">9.ng-content和ng-templateoutlet有什么区别？</h1><p id="c895" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们处理多个模板时，最好在模板本身中编写可重用的逻辑。了解这两个术语可以增加你在开发人员面试中获胜的机会。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/fbd92ba9145eca0a8adecb898bae9525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*VTvdee-oaX6l2vX_HsLmUg.png"/></div></figure><blockquote class="mt mu mv"><p id="810d" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ng-含量示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b950e7ca1c1dfe715329a95ff7d99182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*i7959Ze_V9RVZNVJei5tIQ.png"/></div></figure><blockquote class="mt mu mv"><p id="d73c" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">ng-templateoutlet示例:</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/9a7bc54f93b475dc59e5e5bc1eb7f802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHJjWsh4xOSCN4f-Zho-Ig.png"/></div></div></figure><p id="5068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T15】</strong></p><p id="3b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ngtemplateoutlet-and-content-projection" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/ngtemplate outlet-and-content-projection</a></p><p id="9c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ng-content-demo-example" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ng-content-demo-example</a></p><h1 id="b368" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">10.forchild和forroot有什么区别？</h1><p id="4bd7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个有点高级的话题，但基本的区别是通过使用forchild和forroot，我们可以改变应用程序中服务实例的可见性。</p><p id="0c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想更多地了解这个话题。请检查这篇文章。</p><div class="no np gp gr nq nr"><a href="https://medium.com/javascript-in-plain-english/understand-angulars-forroot-and-forchild-f27fbc41cb7b" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">理解根和孩子角度</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">以及为什么我们需要它们来路由</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ov l oc od oe oa of kp nr"/></div></div></a></div><p id="c839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em> </strong></p><p id="c371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/4-forroot-vs-forchild-with-forroot-and-forchild" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/4-for root-vs-for child-with-for root-and-for child</a></p><h1 id="44f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">11.为什么我们在RXJS中使用管道操作符。有什么用？</h1><p id="fc10" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">pipe方法有助于将多个rxjs函数编写在一起，并且它将所有东西结合在一起。</p><p id="a886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="64de" class="nc lt iq ox b gy pb pc l pd pe">of(1,2,3).pipe(<br/> map(x =&gt; x + 1),<br/> filter(x =&gt; x &gt; 2)<br/>);</span></pre><ol class=""><li id="2156" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated"><code class="fe po pp pq ox b">pipe()</code>函数将您想要组合的函数作为其参数，并返回一个新函数，当执行该函数时，将按顺序运行组合的函数。</li><li id="512c" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">我们可以使用。pipe()方法来传入一个或多个操作符函数，这些操作符函数可以处理和转换可观察集合中的每一项。</li></ol><p id="6c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em> </strong></p><p id="a66e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/rxjs-pipe" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/rxjs-pipe</a></p><h1 id="3491" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">12.在Angular应用程序中使用异步管道和订阅函数有什么区别？</h1><p id="fdc1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们确实在应用程序中大量使用了异步管道和订阅函数，但是它们之间的基本区别是什么，为什么我们使用一个而不是另一个？</p><p id="5a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们去看看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/257cff4b945b4d9e48d035bf79ba701e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Gpuy3HhvmHtdQWMxzIw9VQ.png"/></div></figure><p id="3711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em> </strong></p><p id="b6c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/component-vs-async-pipe-subscriptions-angular" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/component-vs-async-pipe-subscriptions-angular</a></p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/a-guide-to-the-20-best-vscode-extensions-for-frontend-developers-f75a5d716091"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">面向前端开发人员的20个最佳VSCode扩展指南</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">面向前端开发的VSCode最有用扩展的综合指南</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="px l oc od oe oa of kp nr"/></div></div></a></div><h1 id="f5c5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">13.承诺和可观察的区别是什么？</h1><p id="0430" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们确实处理了两个关键字lot，但是什么时候我们应该使用promise和observable呢？如果我们知道承诺和可观察到的区别，这将有助于我们理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/aa1478407ec4de5f428d5296e3fd8183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*V61reuRUWe4B6WGt6TlM_A.png"/></div></figure><p id="2f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="4cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/observable-vs-promises" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/observable-vs-promises</a></p><h1 id="276a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">14.事件发射器和主体有什么区别？</h1><p id="9680" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们想要将子组件与父组件进行通信时，我们使用EventEmitter，而当我们想要在非关系组件之间进行通信时，可以使用subjects。</p><p id="8b33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是它们之间的两个区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/a2d84c50b7e320c8a008895ebe73d5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*vuS8lDyY5FFfDLCasz5YlQ.png"/></div></figure><p id="f4d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="92a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-subject-vs-event-emitter" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-subject-vs-event-emitter</a></p><h2 id="ade3" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">在Angular中防止按钮点击时多次服务呼叫的5种方法</h2><div class="no np gp gr nq nr"><a href="https://medium.com/javascript-in-plain-english/4-ways-to-prevent-multiple-service-calls-on-button-click-in-angular-ff7c2797faf8" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">在Angular中防止按钮点击时多次服务呼叫的5种方法</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">在HTTP服务给出响应之前显示加载程序的5种方法</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="qa l oc od oe oa of kp nr"/></div></div></a></div><h1 id="f866" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">15.可观察和主体有什么区别？</h1><p id="b952" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是角面试中常见的问题之一。我们来理解一下可观察和主体的区别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/c06a2327d97cfec6033e5184ab4d7b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*Jbq_DDPeago5UQSW3_z4fQ.png"/></div></figure><p id="a7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T3】</strong></p><p id="3938" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://stackblitz.com/edit/observables-and-subjects T4】</p><h1 id="babb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">16.激活的路由和激活的路由快照有什么区别？</h1><p id="655d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">激活的路线与激活的路线快照之间的主要区别在于，激活的路线我们可以订阅可观察的，而激活的路线快照仅发出一个值。</p><p id="94e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">让我们来看看一些实用的代码，以便更好地理解这个概念。</em>T9】</strong></p><p id="1d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-router-snapshot-and-params-yakov" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-router-snapshot-and-params-Yakov</a></p><h1 id="4e0e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">17.讨论在你的角度应用中使用的一种不同的加载策略</h1><p id="2431" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种问题问的是检查你用了多深的Angular。大多数时候我们会回答懒惰加载和急切加载，但是还有一个我们应该考虑的。</p><h2 id="8274" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">急切装载</h2><p id="ee0b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">急切加载的功能模块将在应用程序启动前加载。这是默认的模块加载策略。</p><p id="e6ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ang-eager-loading-example" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ang-eager-loading-example</a></p><h2 id="45c2" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">惰性装载</h2><p id="d4ea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">延迟加载下的功能模块将在应用程序启动后按需加载。这有助于更快地启动应用程序。</p><p id="ed6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular6-lazy-loading" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular6-lazy-loading</a></p><h2 id="85f3" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">预加载</h2><p id="bb96" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">预加载的功能模块将在应用程序启动后自动加载。</p><p id="a583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-custom-preloading-strategy" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-custom-preload-strategy</a></p><p id="6262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解如何使用，请点击下面的链接</p><div class="no np gp gr nq nr"><a href="https://medium.com/@lifei.8886196/eager-loading-lazy-loading-and-pre-loading-in-angular-2-what-when-and-how-798bd107090c" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Angular 2+中的急切加载、延迟加载和预加载:什么、何时以及如何加载？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">自2016年以来，Angular 2+一直是现代web应用程序非常受欢迎的前端平台。它引入了一种…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="qc l oc od oe oa of kp nr"/></div></div></a></div><blockquote class="qd"><p id="6e9e" class="qe qf iq bd qg qh qi qj qk ql qm lr dk translated">让我们继续回答更多的问题。</p></blockquote><h1 id="41df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw qn jx me jz qo ka mg kc qp kd mi mj bi translated">18.什么是元数据？</h1><p id="a0f0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">听说过这个词吗？我们确实以类装饰器、属性装饰器或其他方式使用这个日常元。</p><p id="457a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来定义元数据。</p><blockquote class="mt mu mv"><p id="d6f9" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">元数据用于修饰一个类，以便它可以被配置为一个类的预期行为。</p></blockquote><p id="e81f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Angular中使用的元数据的例子。</p><ol class=""><li id="321f" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated"><strong class="ky ir"> <em class="mq">类装饰者</em></strong>—@组件</li><li id="e5f8" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> <em class="mq">属性装饰者</em></strong>—@输入</li><li id="43c7" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> <em class="mq">方法装饰者</em></strong>——@ HostListner</li><li id="e790" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> <em class="mq">参数装饰器</em></strong>——@注入</li></ol><h1 id="272f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">19.routerlinkActive有什么用途？</h1><p id="e3eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们在应用程序中使用navbar时，这是最常用的指令。当我们想要基于活动选项卡编写CSS时，routerlinkActive用布尔条件检查。</p><p id="6dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> RouterLinkActive </strong>是一个指令，用于在绑定到RouterLink的HTML元素中添加或删除类。使用这个指令，我们可以根据当前的路由器状态切换活动路由器链接的CSS类。该指令的主要<strong class="ky ir">用途</strong>是突出显示当前激活的路线。</p><p id="0285" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T13】</strong></p><p id="3a19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-routerlinkactive" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-routerlinkactive</a></p><h1 id="f4db" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">20.我们在Angular中使用泛型。</h1><p id="1444" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是Angular最新的面试问题之一。面试官想通过对物体或特定的观察对象或事件进行打字来检查你写得有多干净。</p><p id="e2ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常在不同的地方使用泛型。</p><ol class=""><li id="96c4" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated"><strong class="ky ir"> <em class="mq">定义发射器时</em> </strong></li></ol><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="270b" class="nc lt iq ox b gy pb pc l pd pe">Output() click : EventEmitter&lt;string&gt; = new EventEmitter&lt;string&gt;()</span></pre><p id="622d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir"> <em class="mq">捕捉来自可观察对象的响应</em> </strong></p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="b116" class="nc lt iq ox b gy pb pc l pd pe">data: Observable&lt;IResponse&gt;</span></pre><p id="b5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir"> <em class="mq">定义接口</em> </strong></p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="b21b" class="nc lt iq ox b gy pb pc l pd pe">interface Item {<br/>info:string,<br/>…<br/>}<br/>Input public items: Item[]</span></pre><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/fix-memory-leaks-in-angular-b4f6bdc6e271"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">提高角度应用的性能</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">角度性能和优化清单</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="qq l oc od oe oa of kp nr"/></div></div></a></div><h1 id="0c46" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">21.外卡路线是什么？</h1><p id="5143" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果有人键入了不正确的路径，一个常用的通配符路由将重定向到此路由。</p><p id="d11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果请求的路由URL不属于代码中提到的内容，我们会在控制台中得到一个错误。</p><p id="2af5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，为了避免这种错误，并告诉用户该路由不存在，我们使用<strong class="ky ir">通配符路由。</strong></p><p id="2a4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/59686fb8d24f7ac1c383cd2ba56a2330.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*fxCE1xQ5qrMyQ0g-0C4Fjw.png"/></div></figure><p id="8947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="22c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-feature-modules-final-and-wildcard-route-example" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-feature-modules-final-and-wild card-route-example</a></p><h1 id="d07b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">22.ngIf和hidden有什么区别？</h1><p id="0dd7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">两者不是一样的吗？两者都有隐藏东西的功能。不，但如果你检查ngIf不会加载模板，如果条件得到假，而隐藏将加载模板并隐藏它。</p><p id="4b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> ngIf </strong>如果表达式为假，将对数据进行注释。这种方式甚至不加载数据，导致HTML加载速度更快。</p><p id="b97f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">【隐藏】</strong>将加载数据，并用<em class="mq">隐藏</em> HTML属性对其进行标记。这样，即使数据不可见，也可以加载。</p><p id="daa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以当我们希望显示/隐藏状态经常改变时，最好使用<em class="mq">【隐藏】</em>，例如在一个按钮点击事件中，这样我们就不必在每次点击按钮时都加载数据，只需改变它的<em class="mq">隐藏</em>属性就足够了。</p><h1 id="ee6f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">23.什么是路由器插座？</h1><p id="3307" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们确实在主应用程序组件HTML中看到了这个标签。但这是什么呢？让我们来理解这个术语。</p><p id="b8d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">router-outlet是一个可从<code class="fe po pp pq ox b">@angular/router</code>包中获得的指令，路由器使用它来标记应该在哪里插入模板、匹配的组件。</p><p id="5e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于路由器出口，您的应用程序将有多个视图/页面，应用程序模板充当您的应用程序的外壳。您添加到外壳中的任何元素都将在每个视图中呈现，只有路由器出口标记的部分会在视图之间发生变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/3a02cbb7b845461790f8544a5b35c28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*oIBMmCnNHEhyBQqTDrYdGw.png"/></div></figure><h1 id="7778" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">24.路由器状态是什么？</h1><p id="71de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为术语定义的路由器状态维护路由的状态，并且可以通过订阅特定的路由事件来访问。</p><p id="81d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">我们来详细了解一下。</em></p><p id="1dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RouterState和ActivatedRoute类似于它们的快照副本，除了它们将所有值公开为可观察值，这对于处理随时间变化的值非常有用。</p><p id="da4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">路由器实例化的任何组件都可以注入其ActivatedRoute。</strong></p><p id="6260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们从“/inbox/33/messages/44”导航到“/inbox/33/messages/45”，可观察的数据将发出一组带有新消息对象的新数据，组件将显示消息45。</p><h2 id="ef3d" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">访问快照</h2><p id="965a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">路由器将参数和数据公开为可观察的，这在大多数情况下是方便的，但并不总是如此。有时候，我们想要的是一个可以立刻检查的状态快照。</p><p id="f952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T12】</strong></p><p id="e433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-routerlink-state" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-routerlink-state</a></p><h1 id="135e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">25.什么是活动路由？</h1><p id="7572" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> ActivatedRoute提供对URL、参数、数据、查询参数和片段观察值的访问。</strong></p><p id="633a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> URL更改是路由中任何更改的来源。</strong>必须这样，因为用户有能力直接修改位置。</p><p id="b2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">每当URL改变时，路由器从中导出一组新的参数</strong>:路由器获取匹配的URL段的位置参数(例如‘:id’)和最后匹配的URL段的矩阵参数，并组合这些参数。这个操作很简单:URL必须随着参数的改变而改变。或者换句话说，相同的URL将总是产生相同的参数集。</p><p id="1dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">接下来，路由器调用路由的数据解析器，并将结果与提供的静态数据相结合。</strong></p><p id="fbc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于以下情况:</p><p id="70dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先导航到“/inbox/33/data/44”，然后导航到“/inbox/33/data/45”，我们将看到:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="5e03" class="nc lt iq ox b gy pb pc l pd pe">url [{path: ‘data’, params: {}}, {path: ‘44’, params: {}}]<br/>url [{path: ‘data’, params: {}}, {path: ‘45’, params: {}}]</span></pre><h1 id="b593" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">26.以角度解释不同的注入。</h1><p id="cf04" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Angular面试问题中，一个常见的面试问题是您如何在Angular应用中使用注射？</p><p id="d095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有5种不同的方式来提供依赖注入</p><ol class=""><li id="a010" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated"><strong class="ky ir">使用类</strong></li><li id="d755" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">使用价值</strong></li><li id="70aa" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">使用工厂</strong></li><li id="93c5" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">代币厂</strong></li><li id="d262" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">成分注入</strong></li></ol><p id="3560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多详细的实现，请查看下面的文章。</p><div class="no np gp gr nq nr"><a href="https://medium.com/its-tinkoff/what-can-you-provide-with-dependency-injection-in-angular-d7adcfd42db" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Angular中的依赖注入能提供什么？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Angular有强大的依赖注入基础。我们可以通过我们的应用程序传输任何数据，转换数据并替换…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="qt l oc od oe oa of kp nr"/></div></div></a></div><p id="777f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">详细解释可以查看角度文档。</em>T13】</strong></p><p id="d428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/angular/pmmpqkbmanl" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/angular/pmmpqkbmanl</a></p><h1 id="6fe8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">27.在Angular中实现翻译的最好方法是什么？</h1><p id="7411" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在单页面应用程序中，一个主要特性是动态多语言支持。但是有时候面试官会问你在你的申请中有没有实现翻译？</p><p id="fef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最常用的库是ngx-translate，它通过添加JSON来提供翻译。</p><p id="9d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T19】</strong></p><p id="1d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ngx-translate-example" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ngx-translate-example</a></p><p id="fd10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在您的应用程序中学习和实现翻译，请查看下面的文章。</p><div class="no np gp gr nq nr"><a href="https://atit53.medium.com/how-to-translate-angular-applications-24f5bbe9f1d7" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">如何翻译角度应用</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">请按照以下步骤使用翻译。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">atit53.medium.com</p></div></div></div></a></div><blockquote class="qd"><p id="aacb" class="qe qf iq bd qg qh qi qj qk ql qm lr dk translated">让我们继续回答更多的问题。</p></blockquote><h1 id="f683" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw qn jx me jz qo ka mg kc qp kd mi mj bi translated">28.解释角度的不同布线参数。</h1><p id="1966" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们确实使用路由参数来维护数据，或者有时在从一条路由导航到另一条路由时传递数据。</p><p id="ddfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular支持以下布线参数。</p><ol class=""><li id="5100" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">必需的参数</li><li id="654b" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">可选参数</li><li id="ebc5" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">查询参数</li><li id="b8b2" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">导航附加</li></ol><p id="76c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解有关路由参数的更多细节，请查看以下文章。</p><div class="no np gp gr nq nr"><a href="https://medium.com/javascript-in-plain-english/how-to-send-data-through-routing-paths-in-angular-31ea50cb0256" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">如何在Angular中通过路由路径发送数据</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">如何在Angular中通过路由路径发送数据</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">如何通过Angularmedium.com的路由路径发送数据</p></div></div><div class="oa l"><div class="qu l oc od oe oa of kp nr"/></div></div></a></div><h1 id="61d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">29.什么是Angular中的虚拟卷轴？</h1><p id="5c39" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这里，面试官想检查你是否掌握了最新的角度特征。</p><p id="50b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虚拟渲染背后的核心概念是只渲染可见的项目。</p><p id="ac70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果应用程序中有数千个警报，一种有效的方法是只加载可见的元素，当它们不可见时，通过用新的元素替换它们来卸载它们。</p><p id="3d9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在@angular/cdk中已经有了虚拟滚动的初始实现。(7.0.0版-测试版)</p><p id="41cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em>T15】</strong></p><p id="7821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-virtual-scrolling" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-virtual-scrolling</a></p><h1 id="668b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">30.路由参数和查询参数有什么区别？</h1><p id="467a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">查询参数和<a class="ae kv" href="/routing/routeparams" rel="noopener ugc nofollow" target="_blank">路线参数</a>的主要区别在于路线参数对于确定路线是必不可少的，而查询参数是可选的。</p><p id="e00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们了解Angular中路由的一些基础知识。</p><h2 id="d2b9" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">声明路线参数</h2><p id="a7a8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">显示特定产品详细信息的组件的路由将需要该产品ID的路由参数。我们可以使用下面的<code class="fe po pp pq ox b">Routes</code>来实现它:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="7fe7" class="nc lt iq ox b gy pb pc l pd pe">export const routes: Routes = [</span><span id="15d5" class="nc lt iq ox b gy qv pc l pd pe">{ path: '', redirectTo: 'data', pathMatch: 'full' },</span><span id="76dc" class="nc lt iq ox b gy qv pc l pd pe">{ path: 'data', component: DataList },</span><span id="037d" class="nc lt iq ox b gy qv pc l pd pe">{ path: 'data/:id', component: DataDetails }</span><span id="e41d" class="nc lt iq ox b gy qv pc l pd pe">];</span></pre><p id="36d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe po pp pq ox b">product-details</code>路径中的<code class="fe po pp pq ox b">:id</code>路径，它将参数放置在路径中。例如，要查看ID为5的产品的详细信息页面，您必须使用以下URL: <code class="fe po pp pq ox b">localhost:3000/product-details/5</code></p><h2 id="adfc" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">传递查询参数</h2><p id="0f3f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用<code class="fe po pp pq ox b">[queryParams]</code>指令和<code class="fe po pp pq ox b">[routerLink]</code>来传递查询参数。例如:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="c253" class="nc lt iq ox b gy pb pc l pd pe">&lt;a [routerLink]="['data-list']" [queryParams]="{ page: 99 }"&gt;Go to Page 99&lt;/a&gt;</span></pre><p id="6e3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以使用<code class="fe po pp pq ox b">Router</code>服务以编程方式导航:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="97ff" class="nc lt iq ox b gy pb pc l pd pe">goToPage(pageNum) {</span><span id="fbb7" class="nc lt iq ox b gy qv pc l pd pe">this.router.navigate(['/data-list'], { queryParams: { page: pageNum } });</span><span id="94c5" class="nc lt iq ox b gy qv pc l pd pe">}</span></pre><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/33-javascript-useful-shorthands-cheat-list-2021-e08b46a1a688"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">2021年你应该知道的JavaScript顶级优化技术</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用现代速记技术、技巧和诀窍优化您的JavaScript代码。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="qw l oc od oe oa of kp nr"/></div></div></a></div><h1 id="396c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">31.解释Angular中支持的不同防护装置。</h1><p id="e644" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是角度应用中最常见的问题之一。</p><p id="1f8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Angular有五个主要的守卫。它守卫着道路的入口。</p><ul class=""><li id="459c" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">CanActivate</code>:在路由之前会被调用:<em class="mq">可以用来阻止路由到特定的路径</em></li><li id="7c26" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">CanActivateChild</code>:会在转到子组件之前被调用:<em class="mq">可以用来阻止子路径</em>的加载</li><li id="be77" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">CanDeactivate</code>:销毁组件前调用:<em class="mq">可用于处理浏览器事件</em></li><li id="6191" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">CanLoad</code>:在模块加载前调用:<em class="mq">可以用来阻止模块</em>的加载</li><li id="ca9a" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">Resolve</code>:加载组件前调用:<em class="mq">可用于加载组件前预取数据</em></li></ul><p id="3f8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="e83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/route-guard" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/route-guard</a></p><p id="3c8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解实现，请参阅本文</p><div class="no np gp gr nq nr"><a href="https://medium.com/@ryanchenkie_40935/angular-authentication-using-route-guards-bf7a4ca13ae3" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">角度认证:使用路由保护</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Angular附带了许多内置特性，对处理身份验证非常有帮助。我想我的…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="qy l oc od oe oa of kp nr"/></div></div></a></div><h1 id="8829" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">32.懒得加载组件的最好方法是什么？</h1><p id="c23c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们想要减少包的大小并避免一起加载所有模块时，延迟加载模块是最佳实践之一。</p><p id="c25e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是惰性加载组件呢？这意味着我们加载模块，但不加载组件，直到我们需要它们。它基本上根据需要创建动态组件，并在使用后立即销毁。</p><p id="aaaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="da18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/ivy-lazy-loading-component" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ivy-lazy-loading-component</a></p><p id="6eac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的文章解释了我们如何在Angular中延迟加载组件。</p><div class="no np gp gr nq nr"><a href="https://medium.com/angular-in-depth/lazy-load-components-in-angular-596357ab05d8" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">以角度表示的惰性负载分量</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">用Ivy和Angular 9延迟加载Angular组件</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="qz l oc od oe oa of kp nr"/></div></div></a></div><h1 id="01f4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">33.我们有什么办法可以用Angular显示app版本？</h1><p id="dac9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们处理大量部署时，最好显示应用程序版本，这有助于团队之间就变更进行沟通。</p><p id="6e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过以下步骤实现。</p><ol class=""><li id="3539" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">在您的<code class="fe po pp pq ox b">/tsconfig.json</code>(有时在<code class="fe po pp pq ox b">/src/tsconfig.app.json</code>中也是必要的)中，启用resolveJsonModule选项(之后需要重新启动webpack dev服务器):</li></ol><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="8ade" class="nc lt iq ox b gy pb pc l pd pe">"compilerOptions": {<br/>      ...<br/>      "resolveJsonModule": true<br/>      ...</span></pre><ol class=""><li id="46fd" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">然后在你的组件中，例如<code class="fe po pp pq ox b">/src/app/app.component.ts</code>使用版本信息:</li></ol><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="e480" class="nc lt iq ox b gy pb pc l pd pe">import { version } from '../../package.json';<br/>    ...<br/>    export class AppComponent {<br/>      public version: string = version;<br/>    }</span></pre><p id="c1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以在您的environment.ts文件中执行步骤2，这样就可以从那里访问版本信息。</p><h1 id="37f0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">34.ES6中的发电机有哪些？</h1><p id="ceac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">生成器函数可以暂停并恢复一次或多次，这使得它们很有趣，并且与普通函数非常不同。当函数暂停时，它允许其他函数和代码执行。默认情况下，生成器是异步的。</p><p id="e5e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="bda5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/es6-generators" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/es6-generators</a></p><h1 id="9beb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">35.解释应用程序中的错误机制。</h1><p id="f1a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有应用程序都有其全局错误机制来处理错误并将其记录在Splunk或new relic上。团队的大多数成员都遵循全局错误机制，该机制会记录是否有任何问题出现，以便进行跟踪，并将用户重定向到特定的路线。</p><p id="4e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">为了更好地理解这个概念，我们来看看一些实用的代码。</em> </strong></p><p id="893f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/global-error-handler" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/global-error-handler</a></p><p id="dd8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解我们如何实现全局错误机制，请查看这篇文章。</p><div class="no np gp gr nq nr"><a href="https://medium.com/angular-in-depth/expecting-the-unexpected-best-practices-for-error-handling-in-angular-21c3662ef9e4" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">期待意外Angular中错误处理的最佳实践</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">"期待意想不到的事情显示了完全现代的智慧."——奥斯卡·王尔德</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ra l oc od oe oa of kp nr"/></div></div></a></div><h1 id="e576" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">36.Angular中的自举是什么？</h1><p id="3635" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">大多数时候，当我们想到这个词的时候，我们会想到一个自举库，但自举不是初始化或加载我们的Angular应用程序的技术。</p><p id="6b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候面试官会问角度应用如何加载，或者一开始就解释角度应用加载。让我们检查一下答案。</p><p id="58d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Angular采取以下步骤加载我们的第一个视图。</strong></p><ol class=""><li id="5497" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">Main.ts应用程序入口点</li><li id="ef82" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">Index.html负载</li><li id="3eaa" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">角度、第三方库和应用程序负载</li><li id="b703" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">应用模块</li><li id="262d" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">应用程序组件</li><li id="ecd2" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">app-root将在其中添加组件HTML</li></ol><p id="da1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欲知详情见下文。</p><p id="3d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.tektutorialshub.com/angular/angular-bootstrapping-application/#:~:text=Bootstrapping%20is%20a%20technique%20of,to%20load%20our%20first%20view" rel="noopener ugc nofollow" target="_blank">https://www . tektutorialshub . com/angular/angular-Bootstrapping-application/#:~:text = Bootstrapping % 20 is % 20a % 20 technique % 20 of，to % 20 load % 20 our % 20 first % 20 view</a>。</p><h1 id="ef86" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">37.什么是角元素？我们为什么使用它？</h1><p id="c479" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">随着Angular的成长，它有了非常好的特性。如果你听说过微服务架构使应用程序更加健壮，Angular也在做同样的事情。</p><p id="061e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Angular元素，我们可以将Angular应用程序即插即用到其他前端框架。</p><p id="f499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着Angular 6的发布，新的Angular Elements功能现已完全可用。通过使用Angular元素，您可以将Angular组件打包为自定义元素，这是一种以与框架无关的方式定义新HTML元素的web标准。</p><div class="no np gp gr nq nr"><a href="https://netbasal.com/understanding-the-magic-behind-angular-elements-8e6804f32e9f" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">🎩理解棱角元素背后的魔力</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">角形腹板部件</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">netbasal.com</p></div></div><div class="oa l"><div class="rb l oc od oe oa of kp nr"/></div></div></a></div><blockquote class="qd"><p id="e564" class="qe qf iq bd qg qh qi qj qk ql qm lr dk translated">让我们继续回答更多的问题。</p></blockquote><h1 id="d23a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw qn jx me jz qo ka mg kc qp kd mi mj bi translated">38.箭头函数和常规函数有什么区别？</h1><p id="2420" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我见过面试官开始问一些基本的JavaScript问题来测试应聘者的知识。</p><p id="13e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道箭头函数的语法比较简单，而常规函数的语法比较复杂。</p><p id="0729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">面试官大多了解水有多深:)</p><p id="479b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">回答:</strong></p><p id="969c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq"> 1。参数绑定</em> </strong> <em class="mq"> </em>:</p><p id="24b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">箭头函数不支持参数绑定，而常规函数支持参数绑定(但是我们可以使用spread运算符在箭头函数中添加参数)</p><p id="8f0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">②<em class="mq">。</em>本关键词:</strong></p><p id="24cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">箭头函数不支持该关键字，而常规函数有自己的关键字支持。这个特性使得常规的函数使用工厂方法来创建对象。</p><p id="ce0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq"> 3。新增关键词:</em> </strong></p><p id="76e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用函数声明创建的常规函数是可构造的，并且可以使用new关键字调用。然而，箭头函数只能被调用而不能被构造，也就是说，箭头函数永远不能被用作构造函数。</p><p id="b6ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq"> 4。重复参数:</em> </strong></p><p id="6beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常规函数允许重复参数，而箭头函数不允许重复参数。</p></div><div class="ab cl rc rd hu re" role="separator"><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh"/></div><div class="ij ik il im in"><h1 id="e46d" class="ls lt iq bd lu lv rj lx ly lz rk mb mc jw rl jx me jz rm ka mg kc rn kd mi mj bi translated">39.函数式编程语言和面向对象编程语言的区别是什么？你更喜欢哪一个，为什么？</h1><p id="3cc3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我见过一些面试官开始问这种问题，以获取求职者关于他们目前正在从事的编程语言的知识。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ro"><img src="../Images/03b66457d542a6a23a6c2f862625bb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWb8LXXVXhS-TckktEAaQQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">geeksforgeeks</figcaption></figure><p id="e03f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程的优势和特点是:</p><ul class=""><li id="059c" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir">纯函数</strong></li><li id="755b" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">功能组成</strong></li><li id="94aa" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">避免共享状态</strong></li><li id="4373" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">避免突变状态</strong></li><li id="aaa4" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">提供高阶函数</strong></li></ul></div><div class="ab cl rc rd hu re" role="separator"><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh"/></div><div class="ij ik il im in"><h1 id="7bf7" class="ls lt iq bd lu lv rj lx ly lz rk mb mc jw rl jx me jz rm ka mg kc rn kd mi mj bi translated">40.JavaScript和TypeScript有什么区别？</h1><p id="34db" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">候选人:TypeScript是JavaScript的超集。</p><p id="04a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我看到大多数候选人的答案很简单，因为他们不知道Angular为什么使用TypeScript的许多优点。</p><ul class=""><li id="5def" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">TypeScript是一种面向对象的编程语言，而JavaScript是一种脚本语言。</li><li id="0de5" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">TypeScript有静态类型的特性，而JavaScript没有这个特性。</li><li id="f4fc" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">TypeScript支持模块，而JavaScript不支持模块。</li><li id="4a20" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">TypeScript支持接口，但JavaScript不支持接口。</li><li id="42cb" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">TypeScript支持方法中的可选参数，但JavaScript不支持方法中的可选参数。</li></ul><p id="8845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">使用TypeScript优于JavaScript的优势</strong></p><ul class=""><li id="d093" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">TypeScript总是在运行时给出编译错误，因此在部署之前解决这个问题更容易</li><li id="e506" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">TypeScript支持静态类型，这允许在编译时检查类型正确性。</li></ul><p id="e352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/routereusestrategy-simplified-in-angular-2e358db618d9">https://JavaScript . plain English . io/routereusestrategy-simplified-in-angular-2e 358 db 618d 9</a></p><h1 id="c318" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">41.你对闭包了解多少？</h1><p id="d63a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">闭包是一个函数的组合，该函数被捆绑在一起(被封闭),并引用其周围的状态(词法环境)。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</p><p id="cf58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，如果我们想让任何函数都不能访问的变量成为私有变量，我们可以使用闭包。</p><p id="bfce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我从堆栈溢出中找到的简单例子。</p><p id="f51d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设，您想要<strong class="ky ir">统计用户点击网站上的按钮</strong>的次数。<br/>为此，我们在按钮的<code class="fe po pp pq ox b"><strong class="ky ir">onClick</strong></code>事件上触发一个函数来更新变量的计数</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="b363" class="nc lt iq ox b gy pb pc l pd pe">&lt;button onclick="updateClickCount()"&gt;click&lt;/button&gt;</span></pre><h1 id="a38e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">现在可能有很多方法，比如:</h1><p id="4653" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">1)您可以使用一个<strong class="ky ir">全局变量</strong>和一个函数来增加<strong class="ky ir">计数器</strong>:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="aa0f" class="nc lt iq ox b gy pb pc l pd pe">var counter = 0;</span><span id="7659" class="nc lt iq ox b gy qv pc l pd pe">function updateClickCount() {<br/>    ++counter;<br/>    // do something with counter<br/>}</span></pre><p id="927e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，缺陷在于<strong class="ky ir">页面上的任何脚本都可以改变计数器，而无需调用</strong> <code class="fe po pp pq ox b"><strong class="ky ir">updateClickCount()</strong></code>。</p><p id="2a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2)现在，您可能会考虑在函数中声明变量:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="1797" class="nc lt iq ox b gy pb pc l pd pe">function updateClickCount() {<br/>    var counter = 0;<br/>    ++counter;<br/>    // do something with counter<br/>}</span></pre><p id="090e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，嘿！每次调用<code class="fe po pp pq ox b">updateClickCount()</code>函数时，<strong class="ky ir">计数器再次被设置为1。</strong></p><p id="0ff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3)思考<strong class="ky ir">嵌套函数</strong>？</p><p id="80e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嵌套函数可以访问它们“上面”的作用域。在这个例子中，内部函数<code class="fe po pp pq ox b">updateClickCount()</code>可以访问父函数<code class="fe po pp pq ox b">countWrapper()</code>中的计数器变量</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="5b91" class="nc lt iq ox b gy pb pc l pd pe">function countWrapper() {<br/>    var counter = 0;<br/>    function updateClickCount() {<br/>    ++counter;<br/>    // do something with counter<br/>    }<br/>    updateClickCount();    <br/>    return counter; <br/>}</span></pre><p id="f3de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您可以从外部访问<code class="fe po pp pq ox b">updateClickCount()</code>函数，并且您还需要找到一种只执行一次<code class="fe po pp pq ox b">counter = 0</code>而不是每次都执行的方法，那么这就解决了计数器的难题。</p><p id="d7fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4) <strong class="ky ir">封场救援！(自调用功能)</strong>:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="ccca" class="nc lt iq ox b gy pb pc l pd pe">var updateClickCount=(function(){<br/>    var counter=0;</span><span id="04cf" class="nc lt iq ox b gy qv pc l pd pe">return function(){<br/>     ++counter;<br/>     // do something with counter<br/>    }<br/>})();</span></pre><p id="9d30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自调用函数只运行一次。它将<code class="fe po pp pq ox b">counter</code>设置为零(0)，并返回一个函数表达式。</p><p id="604f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样<code class="fe po pp pq ox b">updateClickCount</code>就变成了函数。“精彩”的地方在于它可以访问父作用域中的计数器。</p><p id="4f27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这叫做<strong class="ky ir"> JavaScript闭包</strong>。这使得函数有可能拥有“<em class="mq">私有</em>变量。</p><p id="971b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">counter</code>受匿名函数的作用域保护，只能使用add函数修改！</p><blockquote class="mt mu mv"><p id="e07d" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><strong class="ky ir">让我们转向角度问题:</strong></p></blockquote><h1 id="469f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">42.模板驱动表单和反应式表单有什么区别？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rp"><img src="../Images/16d0d32657a536154a755309c59c3fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BWD5TibhGOoiJO9dovdqg.png"/></div></div></figure></div><div class="ab cl rc rd hu re" role="separator"><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh ri"/><span class="rf bw bk rg rh"/></div><div class="ij ik il im in"><h1 id="1c86" class="ls lt iq bd lu lv rj lx ly lz rk mb mc jw rl jx me jz rm ka mg kc rn kd mi mj bi translated">43.Angular中有哪些不同类型的绑定？</h1><h2 id="f266" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">单向数据绑定</h2><ol class=""><li id="c109" class="pf pg iq ky b kz mk lc ml lf rq lj rr ln rs lr pk pl pm pn bi translated"><strong class="ky ir">插值绑定:</strong>它是<strong class="ky ir">一个</strong>绑定变量，在HTML元素中通过添加像</li></ol><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="dd2d" class="nc lt iq ox b gy pb pc l pd pe"><em class="mq">{{value}}</em>.</span></pre><p id="d974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。属性绑定:</strong>它是在组件中声明的绑定特定属性。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="8678" class="nc lt iq ox b gy pb pc l pd pe">&lt;button [disabled]= “isDisabled” &gt;</span></pre><p id="5c0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。属性绑定:</strong>属性绑定用于绑定视图元素的属性特性。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="f3ec" class="nc lt iq ox b gy pb pc l pd pe">&lt;td [attr.colspan]= “val”&gt;&lt;/td&gt;</span></pre><p id="6f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。类绑定:</strong>通过使用这个绑定方法，我们可以有条件地将CSS类添加到元素中，从而创建动态样式的元素。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="27bf" class="nc lt iq ox b gy pb pc l pd pe">&lt;td class= “td” [class.red]= “val.age &lt; 40"&gt;{{val.name}}&lt;/td&gt;</span></pre><p id="93b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5。样式绑定:</strong>与提供特定样式绑定的类绑定相同。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="18ed" class="nc lt iq ox b gy pb pc l pd pe">&lt;h1 [style.color]=”red”&gt;Red&lt;/h1&gt;</span></pre><h2 id="5e76" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">双向数据绑定</h2><p id="8c7a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种绑定提供了组件和HTML之间的双向通信。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="67c3" class="nc lt iq ox b gy pb pc l pd pe">&lt;input [(ngModel)] ='val'&gt;</span></pre><h2 id="479f" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">事件绑定</h2><p id="7854" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">此绑定允许绑定到事件。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="b53d" class="nc lt iq ox b gy pb pc l pd pe">(click)=”myClickFunction($event)”</span></pre><blockquote class="qd"><p id="149d" class="qe qf iq bd qg qh qi qj qk ql qm lr dk translated">让我们继续回答更多的问题。</p></blockquote><h1 id="cc47" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw qn jx me jz qo ka mg kc qp kd mi mj bi translated">45.您最常用哪些RXJS操作符来处理HTTP服务？</h1><p id="3168" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面是Angular中处理HTTP服务最常用的RXJS操作符。</p><p id="ac8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> SUBSCRIBE </strong> : subscribe用于从观察对象中获取数据。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="5719" class="nc lt iq ox b gy pb pc l pd pe">const data$ = this.service.getData(id);</span><span id="b805" class="nc lt iq ox b gy qv pc l pd pe">data$.subscribe((response:IResponse) =&gt; console.log(response));</span></pre><p id="920a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">捕捉错误:</strong>捕捉错误操作符用于处理错误，返回可观察到的错误信息如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/a926667d56341cb88d0fcc76efa0a6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ofaedmnkQZPQ1vl-.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="11d1" class="nc lt iq ox b gy pb pc l pd pe">const data$ = this.service.getData(id);</span><span id="11ed" class="nc lt iq ox b gy qv pc l pd pe">data$.pipe(catchError(error =&gt; of (`error occured: ${error}`))).subscribe((response:IResponse) =&gt; console.log(response));</span></pre><p id="3c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">联合收割机最新</strong></p><p id="e852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Combine Latest运算符用于仅从多个可观测源中发出最新值。</p><p id="1aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图进行多个API调用时，就会用到它。注意:在每个可观察值发出至少一个值之前，combinelatest不会发出初始值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ru"><img src="../Images/8659ad8cfc54046ea0bf8d32902e5872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*62cA6I8RiJsQIj1q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="fc26" class="nc lt iq ox b gy pb pc l pd pe">initializeDetails(id: string): void {<br/>    combineLatest([<br/>            this.service.getInitData(),<br/>            this.service.getDetails(id),<br/>        ])<br/>        .pipe(<br/>            catchError((error: HttpErrorResponse) =&gt; {<br/>                return throwError(error);<br/>            }),<br/>            finalize(() =&gt; ),<br/>            takeUntil(this._ngUnsubscribe$),<br/>        )<br/>        .subscribe(() =&gt; {});<br/>}</span></pre><p id="b4bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看运行示例，请查看这个stackblitz</p><p id="dead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-rxjs-combinelatest" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-rxjs-combinelatest</a></p><p id="5dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">去抖时间&amp;不同，直到改变</strong></p><p id="052d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在必须控制用户输入速率的情况下，这些操作符是理想的选择，例如提前键入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/55fe0d05f9d9f12d9202f0a3ba7125e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ou9ATQFdw3XCGLcS.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="2c1a" class="nc lt iq ox b gy pb pc l pd pe">const inputValue = document.querySelector('input');<br/>const dataObservable$ = fromEvent(inputValue, 'input');<br/>dataObservable$.pipe(<br/>        map(event =&gt; event.target.value),<br/>        debounceTime(2000),<br/>        distinctUntilChanged())<br/>    .subscribe((data) =&gt; console.log(data));</span></pre><p id="cbb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到实际的例子。</p><p id="4ff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/rxjs-debouncetime-distinctuntilchanged" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/rxjs-de bounce time-distinctuntilchanged</a></p><p id="c3b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">点击</strong></p><p id="c180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tap操作符更像是一个实用操作符，可以用来执行透明的操作，比如日志记录。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="71a8" class="nc lt iq ox b gy pb pc l pd pe">const dataObservable$ = of (8, 9, 10, 11, 12);<br/>dataObservable$.pipe(<br/>    tap(val =&gt; console.log(`BEFORE MAP DATA: ${val}`)),<br/>    map(val =&gt; val + 20),<br/>    tap(val =&gt; console.log(`AFTER MAP DATA: ${val}`))<br/>).subscribe(data =&gt; console.log(data));</span></pre><p id="f959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里查看实际例子。</p><p id="bcfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/rxjs-tap-take" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/rxjs-tap-take</a></p><p id="5967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">开关图</strong></p><p id="ce05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调或承诺的一个主要问题是，我们很难中途取消请求。</p><p id="e55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果你正在看某个视频，几秒钟后你想换一个新的视频..此时，我们仍在等待以前的视频请求，新的请求出现了。我们如何取消那个请求？这可能吗？</p><p id="531c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，SwitchMap使之成为可能。</p><p id="df09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwitchMap operator提供了一种简单的机制来取消这些网络请求。例如，使用switchMap操作符查看下面的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/bd7f9517f1cd78f52f0eb5ebf3cfda04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MDVpfZHlv3usa9B-.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="9c90" class="nc lt iq ox b gy pb pc l pd pe">const obs$1 = fromEvent(document, 'click');<br/>const obs$2 = interval(1000);<br/>const finalObs$ = obs$1.pipe(<br/>    switchMap(event =&gt; obs$2)<br/>);<br/>const subscription = finalObs$.subscribe((value) =&gt; console.log(value));</span></pre><p id="6780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里查看实际例子。</p><p id="61d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/switchmap-syp5b1" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/switchmap-syp5b1</a></p><p id="ce75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">分叉连接</strong></p><p id="616c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它用于组合多个可观测值，并使它们成为一个流。</p><p id="c2e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将等待所有的观察完成，然后它将发出一个数组，因此等待所有HTTP服务提供响应是有用的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/6c3f2757e9a8b63370ef65627c48c212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qOJJPJ8rZDrX5yxt.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="7db9" class="nc lt iq ox b gy pb pc l pd pe">const service1 = http.get &lt; Data1[] &gt; (this.data1);<br/>const service2 = http.get &lt; Data2[] &gt; (this.data2);</span><span id="886d" class="nc lt iq ox b gy qv pc l pd pe">forkJoin([service1, service2])<br/>    .subscribe(res =&gt; {<br/>        this.data = res;<br/>        console.log('Stream Data', res);<br/>    });<br/>}</span></pre><p id="a062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里玩实际的例子。</p><p id="5d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://stackblitz.com/edit/angular-rxjs-forkjoin-example<a class="ae kv" href="https://stackblitz.com/edit/angular-rxjs-forkjoin-example" rel="noopener ugc nofollow" target="_blank"/></p><p id="194a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重试</strong></p><p id="d982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果服务返回一个错误，该方法将重新订阅源可观察值，达到参数中写入的最大计数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/cf22c1dcc3f2344d4789e000b4812de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W9jvTOJmxrC8JLLM.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="64f9" class="nc lt iq ox b gy pb pc l pd pe">this.authService.getData()<br/>  .pipe(<br/>     retry(3), // you retry 3 times<br/>     delay(1000) // each retry will start after 1 second,<br/>  )<br/>  .subscribe(res =&gt; {<br/>     // success<br/>  })</span></pre><p id="490c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重试可以在拦截器中使用，以便在失败后重试HTTP服务调用。你可以在这里查看重试的实际例子。</p><p id="5a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-dcv7vw" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-dcv7vw</a></p><h1 id="6e20" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">46.哪些RXJS运算符用于转换或操作数据？</h1><p id="958b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面是转换数据最常用的RXJS运算符。</p><p id="a5cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">地图</strong></p><p id="4ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地图的工作方式与JavaScript地图功能相同。它主要用于将响应转换为新的数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/2520686ddccc536893284a0a64604a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZIBO4YmsuE8iAVX.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="ab1c" class="nc lt iq ox b gy pb pc l pd pe">const data = [{<br/> id: 1,<br/> value: ‘one’<br/>}, {<br/> id: 2,<br/> value: ‘two’<br/>}, {<br/> id: 3,<br/> value: ‘three’<br/>}];</span><span id="d7c2" class="nc lt iq ox b gy qv pc l pd pe">const dataObservable$ = from(data).pipe(<br/> map(data =&gt; data.value)<br/>).subscribe(x =&gt; console.log(x));</span></pre><p id="bea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">减少</strong></p><p id="f325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将来自源的可观察值减少为源完成时发出的单个值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/47266a3dac60f0b44bad958557a9aae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ddft8wvSh5qXe2cZ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="a414" class="nc lt iq ox b gy pb pc l pd pe">const data = of(1, 2, 3, 4);</span><span id="0365" class="nc lt iq ox b gy qv pc l pd pe">const sum = data.pipe(reduce((acc, val) =&gt; acc + val));</span><span id="a184" class="nc lt iq ox b gy qv pc l pd pe">//output: Sum: 10</span><span id="7c30" class="nc lt iq ox b gy qv pc l pd pe">const subscribe = sum.subscribe(val =&gt; console.log('Sum:', val));</span></pre><p id="41b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> TOARRAY </strong></p><p id="5661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">收集所有源发射，并在源完成时以阵列形式发射。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/9e1f1e8de608a0f94c7fe247bf5c164b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4J7Z9lw0BkzG3vNE.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="804e" class="nc lt iq ox b gy pb pc l pd pe">interval(100)</span><span id="aea6" class="nc lt iq ox b gy qv pc l pd pe">.pipe(take(10), toArray())</span><span id="f836" class="nc lt iq ox b gy qv pc l pd pe">.subscribe(console.log);</span></pre><p id="4e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">扫描</strong></p><p id="85a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将源上发出的所有值组合起来并连接它们。reduce和scan之间的唯一区别是它发出中间累积。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/cfc206caa55b5c7bcf2d3ebbed4dd3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sYO60_89P_KTqUTk.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="b0b1" class="nc lt iq ox b gy pb pc l pd pe">const clickEvent = fromEvent(document, 'click');<br/>const observableOne = clickEvent.pipe(mapTo(1));<br/>const seed = 0;<br/>const data = observableOne.pipe(scan((acc, one) =&gt; acc + one, seed));<br/>data.subscribe(val =&gt; console.log(val));</span></pre><h1 id="d8f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">46.mergemap/switchmap/concatmap和exhaustmap有什么区别，我们可以在哪里使用它们？</h1><p id="883f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我喜欢来自ZahiC 的StackOverflow的最佳答案之一</p><ul class=""><li id="2e4b" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir"> mergeMap </strong> —立即为任何源项目创建一个可观察项，所有之前的可观察项保持有效</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/11335bf75587279db12e6228efbfa7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JVHjNC3wUgm_Vopx.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><ul class=""><li id="51d3" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir">串联图</strong>——在创建下一个观察对象之前，等待上一个观察对象完成</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/aa883203cd1b74b96c66f277440b6fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zt8J3Z9lIvG7Ks-l.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><ul class=""><li id="c8a8" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir"> switchMap </strong> —对于任何源项目，完成前一个可观察对象并立即创建下一个</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/9150f93f687fd60eeac6355f41cfe2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wrK31-QPR2GZkrRK.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><ul class=""><li id="a1da" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir">穷尽图</strong>——当先前的可观察项未完成时，源项被忽略</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rt"><img src="../Images/699d2997441f8778f3bf9302281c1f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kAfyob3IJSHVybQM.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://rxjs-dev.firebaseapp.com/api/operators" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev.firebaseapp.com/api/operators</a></figcaption></figure><p id="9ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更清楚地理解，让我们看看下面的动画</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="rv rw l"/></div></figure><p id="4496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">如果你观察到了</strong></p><ol class=""><li id="615c" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">只有在用户完成输入后，switchmap才会返回外部的可观察值，因此一旦新字母开始输入，它就会取消所有旧的可观察值。</li><li id="d0b6" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> concatmap </strong>将为我键入的每个字母调用，因此每次用户键入内容时外部可观察到的调用，因此我们可以看到所有键入的字母都有1秒的延迟</li><li id="b643" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> mergemap </strong>将被立即调用，但它将保留旧的可观察对象。</li><li id="39ad" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> exhausmap </strong>将在开始新的观察对象之前等待一个观察对象完成，因此您可以看到外部观察对象可能没有在文本框中键入最新的值。</li></ol><p id="3950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到一些实际的例子。</p><p id="4d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/rxjs-map-diff" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/rxjs-map-diff</a></p><h1 id="8bb1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">47.在Angular中讨论不同的装饰者。</h1><p id="21cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">装饰器的主要目的之一是存储关于类、方法或属性的元数据。正如我们已经探讨过的，装饰器的全部目的是存储关于类、方法或属性的元数据。</p><ul class=""><li id="f582" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir">类装修工:</strong> <code class="fe po pp pq ox b">@Component</code> <code class="fe po pp pq ox b">@NgModule</code> <code class="fe po pp pq ox b">@Pipe</code></li><li id="be28" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">属性装饰者为属性内类:</strong> <code class="fe po pp pq ox b">@Input</code> <code class="fe po pp pq ox b">@Output</code> <code class="fe po pp pq ox b">@ContentChild</code> <code class="fe po pp pq ox b">@ContentChildren</code> <code class="fe po pp pq ox b">@ViewChild</code> <code class="fe po pp pq ox b">@ViewChildren</code></li><li id="50e0" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">类内部方法的方法装饰者:</strong> <code class="fe po pp pq ox b">@HostListener</code> <code class="fe po pp pq ox b">@HostBinding</code></li><li id="7aa5" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">类构造函数内部参数的参数装饰器:</strong> <code class="fe po pp pq ox b">@Inject</code></li></ul><h1 id="f059" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">48.用Angular解释不同的生命周期方法。</h1><ol class=""><li id="690d" class="pf pg iq ky b kz mk lc ml lf rq lj rr ln rs lr pk pl pm pn bi translated"><strong class="ky ir">构造函数</strong>:类实例化时调用的默认方法。</li><li id="fa97" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngOnChanges </strong>:当创建一个新组件时执行，当带有@Input的绑定属性之一改变时，它也是唯一一个在被调用时接受一个参数的钩子，该参数被称为SimpleChanges。</li><li id="eab1" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngOnInit </strong>:组件初始化后调用。这不允许组件在DOM上可见。这在构造函数之后运行。</li><li id="1f4a" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngDoCheck </strong>:变更检测运行时运行。如果没有变化，即使只是发生了一个事件，它也会运行，以防万一，以确定是否有什么发生了变化。(例如:它将在一个按钮点击事件之后运行，而不管它是否正在改变)</li><li id="e850" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngAfterContentInit </strong>:这是在内容(ng-content)被投影到视图中之后调用的。</li><li id="aaca" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngAfterContentChecked </strong>:在检查完每个投影内容后调用。</li><li id="a833" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">ngafterviewit</strong>:在组件视图(和子视图)初始化后调用。</li><li id="ac33" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir"> ngAfterViewChecked </strong>:每次视图(和子视图)被检查时调用。</li></ol><h1 id="7dfd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">49.解释角度生命周期挂钩的层次。</h1><p id="a1c0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Raed Khalaf 给出的这个图表对我检查角度生命周期钩子的流程帮助很大。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi rx"><img src="../Images/d14bd620a4d8fdf83420f21138ca9cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W3EPnOfnGBYPNAFd.png"/></div></div></figure><p id="6ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它实际上是如何工作的。</p><p id="6494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/lifecycle-hooks-angular" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/lifecycle-hooks-angular</a></p><h1 id="fe94" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">50.渲染器2是什么？</h1><p id="5023" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe po pp pq ox b">Renderer2</code>是一个简单的DOM操纵浏览器API的默认包装器。Renderer2主要用于创建自定义指令。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="e3ab" class="nc lt iq ox b gy pb pc l pd pe">constructor(el: ElementRef, renderer: Renderer2) {<br/>    renderer.addClass(el.nativeElement, 'some');<br/>}</span></pre><p id="0e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到实际的例子。</p><p id="348f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/renderer2-example-2" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/renderer2-example-2</a></p><h1 id="05a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">51.渲染器和ElementRef有什么区别？</h1><p id="2ae2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我喜欢StackOverflow的<a class="ae kv" href="https://stackoverflow.com/users/217408/g%c3%bcnter-z%c3%b6chbauer" rel="noopener ugc nofollow" target="_blank">君特·佐奇鲍尔</a>提供的答案。</p><p id="3fd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">Renderer</code>是DOM的部分抽象类。使用<code class="fe po pp pq ox b">Renderer</code>操作DOM不会破坏服务器端呈现或Web Workers(直接访问DOM会破坏它们)。</p><p id="cc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">ElementRef</code>是一个可以保存对DOM元素的引用的类。在浏览器DOM实际上不可用的环境中，这又是一个不能打破的抽象。</p><p id="ad90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe po pp pq ox b">ElementRef</code>被注入到一个组件中，那么注入的实例就是对当前组件的宿主元素的引用。</p><p id="8ae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">Renderer</code>作用于DOM，<code class="fe po pp pq ox b">ElementRef</code>是对<code class="fe po pp pq ox b">Renderer</code>作用的DOM中的元素的引用。</p><h1 id="1dae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">52.Zone.js是什么？</h1><p id="47a5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">来自一个StackOverflow由<a class="ae kv" href="https://stackoverflow.com/users/4305935/arunvalaven" rel="noopener ugc nofollow" target="_blank">阿伦瓦拉文</a>回答</p><p id="6f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Zone为浏览器中的所有异步操作创建了一个包装器，比如用户交互、HTTP、定时器以及任何其他可能导致状态改变的变化。</p><blockquote class="mt mu mv"><p id="caa6" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><em class="iq">区域知道这些操作何时完成。依次，</em> <strong class="ky ir"> <em class="iq">从区域中订阅通知</em> </strong> <em class="iq">，用于这些操作中的任何一个操作完成时。这让Angular知道它可以运行其</em> <strong class="ky ir"> <em class="iq">变化检测</em> </strong> <em class="iq">算法，并重新渲染任何已发生变化的内容。这可以最大限度地减少渲染波动，提高渲染效率。</em></p></blockquote><p id="7cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下，我们可能希望我们的代码在没有区域的情况下执行，那么我们可以使用<strong class="ky ir"> NgZone的<code class="fe po pp pq ox b"><strong class="ky ir">runOutsideAngular</strong></code> <strong class="ky ir"> </strong>方法。</strong></p><p id="80ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在区域外运行时，Angular不会选择任何异步事件，这意味着不会检测到任何变化。这意味着视图将不会更新，直到我们重新进入该区域。</p><p id="ee07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当我们不想一直更新视图，而想在某个时间后更新视图时，这个特性才是有用的。</p><p id="bb12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是stackblitz实际检查。</p><p id="fa0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-zone-psplsu" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">https://stackblitz.com/edit/angular-zone-psplsu</strong>T22】</a></p><h1 id="43f6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">53.Angular中的竞争条件是什么？</h1><p id="defa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">竞态条件大多发生在自动完成功能中，其中用户绑定一个输入单词“test ”, API服务调用恰好获取“test”的数据，在此期间，用户突然开始键入其他字符“test ”, API首先获取“abc”的结果……现在旧的“test”服务调用完成，并给出测试结果，这可能导致“abc”的数据被覆盖。</p><p id="1035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个可观察对象由于某种原因被延迟，而另一个可观察对象先完成时，就会发生这种情况。</p><p id="bfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解决方案:</strong></p><p id="d39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们需要在用户开始输入“abc”时取消旧的“测试”可观察值。RXJS提供了一个使用switchmap的解决方案来实现这一点。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="f13f" class="nc lt iq ox b gy pb pc l pd pe">this.form<br/>    .get('userInput')<br/>    .valueChanges<br/>    .pipe(<br/>        debounceTime(500),<br/>        tap(() =&gt; this.isLoading = true),<br/>        switchMap(value =&gt; this.service.search({<br/>                name: value<br/>            }, 1)<br/>            .pipe(<br/>                finalize(() =&gt; this.isLoading = false),<br/>            )<br/>        )<br/>    )<br/>    .subscribe(response =&gt; this.data = response);</span></pre><p id="def5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看到实际的例子。</p><p id="b54e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-material-autocomplete-async2" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-material-autocomplete-async 2</a></p><h1 id="6fb4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">54.Angular中的回调、承诺和异步/等待是什么？</h1><p id="a7a4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">回调:回调是传递给另一个函数的函数。当第一个函数完成后，它将运行第二个函数。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="0652" class="nc lt iq ox b gy pb pc l pd pe">function(callback){<br/>  //do some tasks <br/>   callback();<br/>}</span></pre><p id="9e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">承诺:</strong>承诺用于处理操作的异步结果。JavaScript被设计成在代码的其他同步部分可以运行之前，不等待异步代码块完全执行。有了承诺，我们可以推迟代码块的执行，直到异步请求完成。这样，其他操作可以不间断地继续运行。(<a class="ae kv" href="https://www.loginradius.com/blog/async/callback-vs-promises-vs-async-await/" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="322f" class="nc lt iq ox b gy pb pc l pd pe">test(function(){<br/>    return test1(function(){<br/>        return test2(function(){<br/>            return test3(function(){<br/>                done()<br/>            })<br/>        })<br/>    })<br/>})</span></pre><p id="7fa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使它更具可读性，像这样:</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="64cd" class="nc lt iq ox b gy pb pc l pd pe">test()<br/>    .then(test1)<br/>    .then(test2)<br/>    .then(test3)<br/>    .then(done)</span></pre><p id="e724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Async/Await:</strong>Async函数用来写异步代码，具体来说就是承诺。在这个函数中，关键字<strong class="ky ir"> await </strong>用于暂停一个承诺的执行，直到它被解决。换句话说，它等待承诺解决，然后恢复异步功能。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="a3e8" class="nc lt iq ox b gy pb pc l pd pe">async function test(){<br/>    let data = await getData() // it waits until we get data<br/>    return data;<br/>}</span></pre><p id="1e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多详细的解释，我建议你看看这篇文章。</p><p id="9295" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/front-end-weekly/callbacks-promises-and-async-await-ad4756e01d90" rel="noopener">https://medium . com/front-end-weekly/callbacks-promises-and-async-await-ad 4756 e01d 90</a></p><h1 id="cec4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">55.Angular中的主机绑定和主机侦听器是什么？</h1><p id="74c6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe po pp pq ox b"><strong class="ky ir">@HostListener</strong></code> -将持续监听用<code class="fe po pp pq ox b">@HostListener</code>声明的主机元素发出的事件。</p><p id="4bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b"><strong class="ky ir">@HostBinding</strong></code> -它将属性绑定到宿主元素，如果绑定发生任何情况，<code class="fe po pp pq ox b">HostBinding</code>将更新宿主元素。</p><p id="229c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，</p><ul class=""><li id="8e51" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">@HostBinding</code>:这个装饰器将一个<strong class="ky ir">类属性</strong>绑定到主机元素的一个属性。</li><li id="f3c3" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><code class="fe po pp pq ox b">@HostListener</code>:这个装饰器将一个<strong class="ky ir">类方法</strong>绑定到主机元素的一个事件。</li></ul><p id="b4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="mq">你可以在这里玩一个实际的例子。</em> </strong></p><p id="f393" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/hostbinding-hostlistener" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/hostbinding-hostlistener</a></p><h1 id="d5eb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">56.Angular中的依赖注入是什么？</h1><p id="6f56" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">依赖注入(DI)是Angular的核心概念，它允许一个类从另一个类接收依赖。在Angular中，大多数时候依赖注入是通过将一个服务类注入到一个组件或模块类中来完成的。</p><p id="0775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，</p><p id="58ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种编码模式，其中一个类从外部来源接收它需要的对象实例(称为依赖关系),而不是自己创建它们。</p><p id="f85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到实际的例子。 </p><p id="5319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackblitz.com/edit/angular-dependency-injection-services-example" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-dependency-injection-services-example</a></p><h1 id="5484" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">57.以角度解释摘要周期/变化检测周期。</h1><p id="0d48" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在使用变化检测周期执行的角度摘要周期的较新版本中。</p><p id="098f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户更改DOM中的任何内容时，会发生以下事件</p><ol class=""><li id="2167" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">用户更新DOM</li><li id="26c7" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">Angular使用zone来跟踪任何异步任务(点击、设置间隔、服务请求)</li><li id="446b" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">角度检测变化</li><li id="c02f" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">变更检测从上到下检查组件树中的每个组件，以查看是否发生了任何模型变更。</li></ol><ul class=""><li id="9ddf" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">应用程序引导过程中创建的角度组件树和变化检测器将被激活</li><li id="7c4d" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">检测器将当前值与先前值进行比较</li><li id="f2b0" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">如果数值改变，它会将<code class="fe po pp pq ox b">isChanged </code>设置为真。</li><li id="7a04" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">注意:这种变化检测不是深度比较。</li></ul><p id="b287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.如果有新值，组件的视图将被更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ry"><img src="../Images/357b27cd8647861417a69028d932e2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*whfLTMKGNK7V_oIC.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.mokkapps.de/blog/the-last-guide-for-angular-change-detection-you-will-ever-need/" rel="noopener ugc nofollow" target="_blank">https://www.mokkapps.de/blog/the-last-guide-for-angular-change-detection-you-will-ever-need/</a></figcaption></figure><h1 id="2e5d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">58.markForCheck和detectchanges有什么区别？</h1><p id="8212" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe po pp pq ox b">cd.detectChanges()</code>将从当前组件一直到它的后代运行变更检测。</p><p id="b5b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">cd.markForCheck()</code>不会运行变更检测，但会将其祖先标记为需要运行变更检测。下一次发生任何更改检测时，它也将为那些被标记的组件运行。</p><ul class=""><li id="471a" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">如果我们想减少变化检测的次数就叫用<code class="fe po pp pq ox b">cd.markForCheck()</code>。通常，变更会影响多个组件，在某个地方会调用变更检测。</li><li id="0fac" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">如果我们在一个祖先多于后代的组件中改变状态，你可以通过使用<code class="fe po pp pq ox b">detectChanges()</code>来提高性能，因为我们没有必要在组件的祖先上运行变化检测。</li></ul><h1 id="399d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">59.克隆对象的方法有哪些？</h1><p id="b75f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有三种方法可以在Angular中克隆对象。</p><p id="e5d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。原生方法(深层复制)</strong></p><p id="4e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好也是最古老的克隆方法之一是使用JSON.stringify进行本地深度克隆</p><p id="858f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">JSON.parse(JSON.stringify(object))</code></p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="f917" class="nc lt iq ox b gy pb pc l pd pe">const a = {<br/>  string: 'string',<br/>  number: 123,<br/>  bool: false,<br/>  nul: null,<br/>  date: new Date(),  // stringified<br/>  undef: undefined,  // lost<br/>  inf: Infinity,  // forced to 'null'<br/>  re: /.*/,  // lost<br/>}<br/>console.log(a);<br/>console.log(typeof a.date);  // Date object<br/>const clone = JSON.parse(JSON.stringify(a));<br/>console.log(clone);<br/>console.log(typeof clone.date);  // result of .toISOString()</span></pre><p id="d046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。使用库的可靠克隆(深层拷贝)</strong></p><p id="a74a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用已经可用的库，例如</p><ul class=""><li id="4505" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">lodash—<code class="fe po pp pq ox b"><a class="ae kv" href="https://lodash.com/docs#cloneDeep" rel="noopener ugc nofollow" target="_blank">cloneDeep</a></code>；可以通过<a class="ae kv" href="https://www.npmjs.com/package/lodash.clonedeep" rel="noopener ugc nofollow" target="_blank"> lodash.clonedeep </a>模块单独导入，如果您还没有使用提供深度克隆功能的库，这可能是您的最佳选择</li></ul><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="e0b6" class="nc lt iq ox b gy pb pc l pd pe">var objects = [{ 'a': 1 }, { 'b': 2 }];var deep = _.cloneDeep(objects);</span></pre><p id="c64e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。ES6(浅层拷贝)</strong></p><p id="45de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES6提供了两种不同的方法来克隆对象，一种是Object.assign，另一种是spread，operator。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="0839" class="nc lt iq ox b gy pb pc l pd pe">var data= {val: "string"};<br/>var newdata= Object.assign({}, data);<br/>var newdata3= {...data};  // Spread Operator</span></pre><h1 id="dccd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">60.解释Angular应用程序如何加载/初始化。</h1><p id="cddc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下是ng服务后将执行的步骤。</p><ol class=""><li id="fb20" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">它从Angular.json开始，那里有Angular项目的所有配置，它将检查所有路径和配置，并搜索main.ts文件。</li><li id="267e" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">main.ts是应用程序的入口点。它调用引导模块并告诉构建器引导应用程序。</li><li id="8ac0" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">Angular中的bootstrap是什么？它将与网页的HTML交互并提供数据。</li><li id="ab3f" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">然后，我们启动一个Angular应用程序，并将app.module.ts作为参数传递。在app.module.ts中我们告诉Angular: <em class="mq">“有一个app组件是你自己尝试启动时应该知道的”。</em></li><li id="0d77" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">Angular现在分析这个应用程序组件，读取我们传递到那里的设置，那里有<em class="mq">选择器应用程序根</em>。</li><li id="28a9" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">现在Angular知道所有的模块、组件和脚本。</li><li id="7465" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">现在，Angular能够处理index.html中的<em class="mq"> app-root </em>，并且知道<em class="mq">选择器</em>的规则。</li><li id="6883" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><em class="mq">应用根选择器</em>应插入应用组件并加载应用component.html</li><li id="26bf" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">这就是角度应用的开始。</li></ol><p id="292c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(来源:<a class="ae kv" href="https://dev.to/casperns/how-angular-trigger-indexhtml-and-start-working-1l46" rel="noopener ugc nofollow" target="_blank">https://dev . to/casperns/how-angular-trigger-index html-and-start-working-1l 46</a>)</p><h1 id="e9c8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">61.一个@Input()值在Angular中变化时如何检测非原语类型数据？</h1><p id="518e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以查看这篇文章，以获得详细的了解。</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-detect-when-an-input-value-changes-in-angular-5872c77517fc"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">如何检测输入()值在角度上的变化</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">检测输入值何时改变角度</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="rz l oc od oe oa of kp nr"/></div></div></a></div><h1 id="9c61" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">62.Angular中有哪些不同的封装策略？</h1><ol class=""><li id="7382" class="pf pg iq ky b kz mk lc ml lf rq lj rr ln rs lr pk pl pm pn bi translated"><strong class="ky ir">视图封装。None: </strong>通过使用这种方法，我们将样式暴露给外部组件。(注意:我们需要确保使用正确的选择器)</li><li id="36d6" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">视图封装。仿真:</strong>这是默认的方法，如果我们覆盖了一些东西，基本上不会暴露样式，我们也可以使用全局样式。</li><li id="87f8" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated"><strong class="ky ir">视图封装。ShadowDom: </strong>这种封装策略利用了ShadowDom，因此它使用自己的shadowRoot来呈现组件。</li></ol><h1 id="05a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">63.Angular中的暗影DOM是什么？</h1><p id="5520" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Shadow DOM基本上允许将一组DOM实现隐藏在单个元素中(这是组件的基本思想)，并将样式封装到元素中。</p><p id="b16d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular不使用<strong class="ky ir">阴影DOM </strong>(默认)也不使用<strong class="ky ir">虚拟DOM </strong>。</p><p id="3908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe po pp pq ox b">encapsulation: ViewEncapsulation.Emulated</code>(默认)时，没有<strong class="ky ir">阴影DOM </strong>，因为样式封装只是模拟的。</p><p id="d1c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe po pp pq ox b">encapsulation: ViewEncapsulation.Native</code>在本地支持的浏览器上启用<strong class="ky ir">阴影DOM </strong>，或者在加载web组件polyfill时再次模拟。</p><p id="9f5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">影子DOM </strong>也不像虚拟DOM那样以性能为目标，而是风格封装。</p><h1 id="da98" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">64.解释Angular中不同类型的指令。</h1><p id="1576" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Angular中有三种指令:</p><ol class=""><li id="2ced" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">组件—带有模板的指令。</li><li id="240c" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">结构化指令—通过添加和删除DOM元素来更改DOM布局。(<strong class="ky ir"> *ngIf </strong>，<strong class="ky ir"> *ngFor </strong>)</li><li id="eb56" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">属性指令—更改元素、组件或其他指令的外观或行为</li></ol><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="c668" class="nc lt iq ox b gy pb pc l pd pe"><a class="ae kv" href="http://twitter.com/Directive" rel="noopener ugc nofollow" target="_blank">@Directive</a>({<br/>    selector: '[appHighlight]'<br/>})<br/>export class HighlightDirective {<br/>    constructor(el: ElementRef) {<br/>        el.nativeElement.style.backgroundColor = 'yellow';<br/>    }<br/>}</span></pre><p id="2893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTML可以是</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="7d52" class="nc lt iq ox b gy pb pc l pd pe">&lt;p appHighlight&gt;Highlight me!&lt;/p&gt;</span></pre><h1 id="cf64" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">65.退订可观察对象的最好方法是什么？</h1><p id="3259" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们不“取消订阅”可观察对象，它会导致Angular应用程序中的内存泄漏。</p><p id="f2f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种方法可以取消订阅observables。</p><ol class=""><li id="ee36" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr pk pl pm pn bi translated">退订方法</li><li id="bed6" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">aync管道</li><li id="910d" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">RXJS接受运算符</li><li id="57ea" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">RXJS第一运算符</li><li id="1bf1" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">npm库，如(全部取消订阅，子接收器)</li></ol><h1 id="4e0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">66.什么是角语服务？</h1><p id="61e1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Angular语言服务为代码编辑器提供了一种在Angular模板中获得完成、错误、提示和导航的方法。它可以在单独的HTML文件中使用外部模板，也可以使用内嵌模板。</p><p id="b349" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语言服务包括:</p><ul class=""><li id="2720" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated">完成列表</li><li id="629e" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">AOT诊断消息</li><li id="91dd" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">快速信息</li><li id="b742" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated">转到定义</li></ul><p id="b8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(来源:<a class="ae kv" href="https://angular.io/guide/language-service" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/language-service</a>)</p><h1 id="8b76" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">67.Angular的canLoad和canActivate的区别？</h1><p id="1909" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> CanLoad </strong>防护装置防止加载惰性加载模块。当我们不想让用户导航到模块的任何路线，甚至不想加载模块时，可以使用这种方法。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="5509" class="nc lt iq ox b gy pb pc l pd pe">{<br/>    path: 'test',<br/>    loadChildren: 'app/test/test.module#TestModule',<br/>    canLoad: [AuthGuardService]<br/>},</span></pre><p id="8095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">可激活</strong>防护装置，防止未经授权的用户进入路线。这种保护不会阻止模块自己加载。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="bf76" class="nc lt iq ox b gy pb pc l pd pe">{ <br/>      path: '',<br/>      component: TestComponent,<br/>      children: [ <br/>        {<br/>          path: 'test-data',<br/>          component: TestListComponent,<br/>          canActivate: [ AuthGuardService ]<br/>        }<br/>      ]<br/>    }</span></pre><h2 id="58a0" class="nc lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">68.如何检查路线角度是否改变？</h2><p id="cf67" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以在组件构造器中订阅路由器事件。NavigationStart和NavigationEnd或任何其他事件可用于检查活动。</p><pre class="kg kh ki kj gt ow ox oy oz aw pa bi"><span id="1c8b" class="nc lt iq ox b gy pb pc l pd pe">constructor(private router: Router) {<br/>router.events.subscribe(<br/>        (event) =&gt; {<br/>            if (event instanceof NavigationStart)<br/>                // startroute<br/>            if (event instanceof NavigationEnd) {<br/>                // end route<br/>            }<br/>        });<br/>}</span></pre><h1 id="8159" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">69.用Angular解释不同的路由器事件</h1><ol class=""><li id="765f" class="pf pg iq ky b kz mk lc ml lf rq lj rr ln rs lr pk pl pm pn bi translated">导航开始:导航开始。</li><li id="e98d" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">RouteConfigLoadStart:在路由器惰性加载路由配置之前。</li><li id="cd48" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">RouteConfigLoadEnd:延迟加载路由后。</li><li id="1344" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">路由被识别:当路由器解析URL并且路由被识别时。</li><li id="089c" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">GuardsCheckStart:当路由器开始路由的<em class="mq">保护</em>阶段时。</li><li id="b3e3" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">ChildActivationStart:当路由器开始激活路由的子项时。</li><li id="2b5e" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">ActivationStart:路由器开始激活路由时。</li><li id="d7f6" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">GuardsCheckEnd:当路由器成功完成路由的<em class="mq">保护</em>阶段时。</li><li id="074c" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">ResolveStart:当路由器开始路由的<em class="mq">解析</em>阶段时。</li><li id="523c" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">ResolveEnd:当路由器成功完成路由的<em class="mq">解析</em>阶段时。</li><li id="8958" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">ChildActivationEnd:当路由器完成激活路由的子项时。</li><li id="56eb" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">激活结束:路由器完成激活路由时。</li><li id="7a21" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">导航结束:导航成功结束时。</li><li id="bbdd" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">NavigationCancel:取消导航时。</li><li id="1ece" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">NavigationError:当导航由于意外错误而失败时。</li><li id="9a0f" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr pk pl pm pn bi translated">Scroll:当用户滚动时。</li></ol><p id="5abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(来源:【https://angular.io/api/router/Event T2】)</p><h1 id="f1f2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">70.触发角度变化检测的手动方式有哪些？</h1><p id="3237" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以使用以下方法在Angular中手动触发变化检测。</p><ul class=""><li id="cfe6" class="pf pg iq ky b kz la lc ld lf ph lj pi ln pj lr qx pl pm pn bi translated"><strong class="ky ir"> NgZone.run(callback) </strong> —它将评估角度区域内的回调函数。NgZone是一个可注入的服务，用于在角度区域内部或外部执行工作。</li><li id="eca1" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir"> ApplicationRef.tick() </strong> —这将检查整个组件树，以检测角度的变化。</li><li id="fdfc" class="pf pg iq ky b kz pr lc ps lf pt lj pu ln pv lr qx pl pm pn bi translated"><strong class="ky ir">changeedetectorref . detect changes()</strong>—这将只检查组件及其子视图的变化检测。</li></ul><p id="c789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">71.从角度讨论不同的管道。</p><p id="6e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">72.你在Angular中遵循的最佳安全实践是什么？</p><p id="cec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">73.提高角度性能的最佳方法是什么？</p><p id="f9e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">74.你处理过检查后表情发生变化的错误吗？</p><p id="95e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">75.如果已经加载了一个模块，该如何处理？</p><p id="03bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">76.你在Angular中创建了自定义库吗？</p><p id="241a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">77.你在应用中分析内存的方法有哪些？</p><p id="6b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">78.用Angular解释不同的路由器事件？</p><p id="5825" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">79.Angular中的数据类型有哪些？</p><p id="c32f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">80.优化异步验证器的最好方法是什么？</p><p id="b318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">81.Angular中的Enums是什么？</p><p id="996a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">82.JavaScript中的find和filter有什么区别？</p><p id="3db3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">83.防止在Angular中点击按钮时出现多个服务呼叫。</p><p id="044e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">84.如何在Angular中的组件之间传递数据？</p><p id="eed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">85.(change)和(ngModelChange)有什么区别？</p><p id="2e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">86.声明、提供者和导入有什么区别？</p><p id="877d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">87.如何在角元件库(比如角材)中覆盖CSS？</p><p id="5a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">88.如何将组件中的字符串动态绑定到HTML？</p><p id="1945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">89.如何在同一个元素上设置ngFor和ngIf？</p><p id="7c5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">90.你能举一个内置验证器的例子吗？</p><p id="00ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">91.什么是入门组件？</p><p id="04f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">92.什么是有角度的可观察和观察者？</p><p id="ea74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">93.Angular里的服务人员是什么？</p><p id="b0b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">94.如何在Angular中用最新版本更新所有库？</p><p id="610e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">95.什么是拦截器？您如何配置您的应用程序/</p><p id="cfa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">96.解释你的Angular应用的架构。</p><p id="ac9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">97.解释一些你最常用的测试角度组件的方法。</p><p id="e090" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">98.你在应用中使用了哪些不同的SCSS函数？</p><p id="d828" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">99.OnPush和默认变更检测有什么区别？</p><p id="482e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">100.如何将数据绑定到模板？</p><p id="b7f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">101.takeWhile和takeUntil RXJS运算符有什么区别？</p><p id="5a00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">102.behavior Subject/Subject/replay Subject和Async Subject有什么区别？</p><p id="18e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">103.解释ng-temple、ng-content、ng-container和ng-templateOutlet的实际用法。</p><p id="3338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">104.为什么我们在route中使用forchild和forroot方法？它的用途是什么？</p><p id="6258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">105.如何将所有角度库更新到最新版本？</p><p id="a857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">106.Angular中的内容投影是什么，它是如何工作的？</p><p id="3ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">107.Angular中的APP _ INITILIZER是什么，是用来做什么的？</p><p id="9cee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">108.解释角度应用中的路由重用策略。</p><p id="ada7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">109.Angular中的服务器端渲染是如何工作的？</p><p id="63a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">110.Angular里的服务人员是什么？如何使用它们？</p><blockquote class="mt mu mv"><p id="29ad" class="kw kx mq ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated">如果您正在寻找其余问题的答案，请回复我。</p></blockquote><h1 id="1bdc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">延伸阅读:</h1><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/frontend-interview-question-what-is-the-difference-between-change-vs-ngmodelchange-f6bb3cb26dbc"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">角度面试问题:‘改变’和‘ngModelChange’有什么区别？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">最常见的前端面试问题2021</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="or l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/what-are-the-different-built-in-pipes-available-in-angular-f59bbae6c949"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Angular有哪些不同的内置管道？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">你必须为下一次面试准备的100个问题。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="sa l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-get-the-current-value-of-an-rxjs-subject-or-observable-b5eb666b20f6"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">如何获得RxJS主题或可观察对象的当前值</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">获取RxJS可观察值的当前值——每日角度提示、技巧和最佳实践</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="sb l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/a-guide-to-the-20-best-vscode-extensions-for-frontend-developers-f75a5d716091"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">面向前端开发人员的20个最佳VSCode扩展指南</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">面向前端开发的VSCode最有用扩展的综合指南</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="px l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/33-javascript-useful-shorthands-cheat-list-2021-e08b46a1a688"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">2021年你应该知道的JavaScript顶级优化技术</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用现代速记技术、技巧和诀窍优化您的JavaScript代码。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="qw l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/routereusestrategy-simplified-in-angular-2e358db618d9"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">路由使用策略在角度上得到简化</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Angular中的路由复用策略是什么？如何实施？</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="sc l oc od oe oa of kp nr"/></div></div></a></div><p id="46d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">说白了. io </em> </strong> </a> <strong class="ky ir"> <em class="mq">。</em> </strong> <em class="mq">报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mq">免费每周简讯点击这里</em> </strong> </a> <strong class="ky ir"> <em class="mq">。</em> </strong></p></div></div>    
</body>
</html>