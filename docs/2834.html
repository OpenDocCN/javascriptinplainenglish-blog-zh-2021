<html>
<head>
<title>LeetCode Algorithm Series: Contains Duplicate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:包含重复项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcodes-series-contains-duplicate-644f3f8a3291?source=collection_archive---------12-----------------------#2021-06-09">https://javascript.plainenglish.io/leetcodes-series-contains-duplicate-644f3f8a3291?source=collection_archive---------12-----------------------#2021-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0357a1c415bc44b74e8648ce780375f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aNK2eCTYa7DcgLS6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9abe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你好，你好！我一边继续找工作，一边在Leetcode上练习我的算法题。所以，我想我会在博客上写一些我解决的Leetcode问题。</p><p id="8f66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名Bootcamp毕业生，我在算法方面没有得到太多的实践，所以在识别模式、优化我的代码以更快(看看你，Big-O)、学习如何分解问题，以及有时实现简洁的数学技巧来解决这些算法问题方面，这是一次非常有趣但有时令人沮丧的反复试验。我一直在用JavaScript练习它们。</p><p id="7652" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我对算法问题相对较新，所以我从他们收集的最容易的面试问题开始。所以在<strong class="kc io">中包含了重复的:</strong></p><p id="764c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个整数数组<code class="fe ky kz la lb b">nums</code>，如果任何值在数组中出现<strong class="kc io">至少两次</strong>，则返回<code class="fe ky kz la lb b">true</code>，如果每个元素都不同，则返回<code class="fe ky kz la lb b">false</code>。</p><p id="f61b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="beff" class="lk ll in lb b gy lm ln l lo lp"><strong class="lb io">Input:</strong> nums = [1,2,3,1]<br/><strong class="lb io">Output:</strong> true</span><span id="10dc" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io">Input:</strong> nums = [1,2,3,4]<br/><strong class="lb io">Output:</strong> false</span><span id="7f1d" class="lk ll in lb b gy lq ln l lo lp"><strong class="lb io">Input:</strong> nums = [1,1,1,3,3,4,3,2,4,2]<br/><strong class="lb io">Output:</strong> true</span></pre><p id="a19b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单来说，如果数组中的任何数字在数组中出现不止一次，我需要返回<code class="fe ky kz la lb b">true</code>。现在，我肯定需要找出一种方法来比较一个数字和其他数字。此外，我很可能需要遍历数组，这样我就可以访问每个数字，然后将其与其他数字进行比较。</p><p id="fd9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我认为我可以遍历数组，在每个实例中，我遍历剩余整数的另一个循环，并比较它们看是否有相等的(===)。然而，根据我对Big-O的初步理解，这将产生O(n)的不利时间复杂度。</p><p id="0072" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我想我可以创建一个对象，并计算一个数字在数组中出现了多少次。通过这样做，我可以检查是否有任何数字的计数大于1。如果是这样，那么我会返回<code class="fe ky kz la lb b">true</code>，否则我会返回<code class="fe ky kz la lb b">false</code>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="ee95" class="lk ll in lb b gy lm ln l lo lp">var containsDuplicate = function(nums) {<br/>    hash = {}<br/>    let i = 0<br/>    while (i &lt; nums.length) {<br/>        if (hash[nums[i]]) {<br/>            hash[nums[i]] += 1<br/>        } else {<br/>            hash[nums[i]] = 1<br/>        }<br/>        i++<br/>    }<br/>    values = Object.values(hash)</span><span id="716e" class="lk ll in lb b gy lq ln l lo lp">    for (let j = 0; j &lt; values.length; j++){<br/>        if (values[j] &gt; 1) {<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>};</span></pre><p id="1f50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很有效！解决了！时间复杂度是O(2n)，比我最初的计划要快。然而，我想知道我能不能彻底解决这个问题，稍微改进一下我的Big-O运行时？</p><p id="7063" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我意识到，当我遍历数组时，我已经创建了一个对象，当我发现任何一个数字出现不止一次时，我可以返回<code class="fe ky kz la lb b">true</code>。因此，我可以同时做这件事，而不是遍历整个数组，然后检查是否重复。当我迭代数组时，如果它不存在于我的对象中，那么我会添加它。如果它确实存在于对象中，那么我可以返回<code class="fe ky kz la lb b">true</code>并结束。最后，如果我在整个循环中没有碰到return <code class="fe ky kz la lb b">true</code>语句，那么我将返回<code class="fe ky kz la lb b">false</code>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="2640" class="lk ll in lb b gy lm ln l lo lp">var containsDuplicate = function(nums) {<br/>    hash = {}<br/>    for (let i = 0; i &lt; nums.length; i++) {<br/>        if (hash[nums[i]]) {<br/>            return true<br/>        } else {<br/>            hash[nums[i]] = 1<br/>        }<br/>    }<br/>    return false<br/>};</span></pre><p id="91fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，看起来好多了！并且它运行的时间复杂度相当低。我想仍然有更好更快的方法来解决这个问题，所以如果我的代码可以改进，请给我留下评论，或者教我一种新的方法来解决这个问题(我很乐意！).</p><p id="fdac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在解决这个问题上有任何困难，我希望这能帮助你，并在未来寻找更多的Leetcode解决方案！</p><p id="214d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Leetcode系列:</p><blockquote class="lr ls lt"><p id="a1b5" class="ka kb lu kc b kd ke kf kg kh ki kj kk lv km kn ko lw kq kr ks lx ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="139b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lu">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lu">plain English . io</em></a></p></div></div>    
</body>
</html>