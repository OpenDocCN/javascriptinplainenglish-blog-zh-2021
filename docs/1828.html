<html>
<head>
<title>React Components as TypeScript Generic Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将组件作为类型脚本通用函数进行反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-components-as-typescript-generic-functions-8aa83afff597?source=collection_archive---------1-----------------------#2021-04-18">https://javascript.plainenglish.io/react-components-as-typescript-generic-functions-8aa83afff597?source=collection_archive---------1-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/70edd7c4140ba4c96168456c5613c1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xfVeb1Zhpr4n5Os8.png"/></div></div></figure><p id="e63d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您想要一个组件来呈现一个事物列表。你希望它是灵活的，能够渲染任何类型的东西，就像这样:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f22d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者这个:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="92d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现可能如下所示:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="37c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，问题是<code class="fe lc ld le lf b">renderItem</code>回调中变量的类型将是<code class="fe lc ld le lf b">any</code>。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/d3963a55f29ade3b0bab8ae1748b6064.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*aAXykDr78Lq7pcZp3QGaiw.png"/></div></figure><p id="cadb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以它没能发现你发现的我的<code class="fe lc ld le lf b">proice</code>错别字，因为你是一个勤奋的代码读者。</p><p id="08f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以<em class="lh">手动</em>告诉TypeScript传递给<code class="fe lc ld le lf b">renderItem</code>的对象是一个产品，并获得正确的类型:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/92abed9563eb222d8e37d67f94a7c82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*negOVbWksNUKBOjFJkY3LA.png"/></div></div></figure><p id="97d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这意味着我们可怜的<code class="fe lc ld le lf b">&lt;List&gt;</code>消费者需要重新定义我们已经知道是真的东西。如果我们想要<code class="fe lc ld le lf b">sortItem</code>或<code class="fe lc ld le lf b">filterItem</code>或<code class="fe lc ld le lf b">validateItem</code>或<code class="fe lc ld le lf b">onItemClick</code>道具，我们会因为额外的打字而磨损键盘。</p><p id="7896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要是有更好的方法就好了…</p><h1 id="db27" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">输入类属</h1><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="5118" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是泛型的新手，那么这篇文章可能是一个不好的开始(<a class="ae mg" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">这里是docs </a>)，但是因为你现在在这里，让你离开似乎很不礼貌，让我告诉你上面的代码的意思是:“嘿，TypeScript，这个组件的消费者将传递一组东西给<code class="fe lc ld le lf b">items</code> prop。我们不知道这些东西的类型是什么，但我们将把其中一个传递回<code class="fe lc ld le lf b">renderItem</code>函数”。</p><p id="2b8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们在回调中得到正确的类型，从我们传入的东西的类型推断出来:</p><div class="kw kx ky kz gt ab cb"><figure class="mh jr mi mj mk ml mm paragraph-image"><img src="../Images/5f889b7a33eff0a9992e7996fdf2318b.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*0bYAcgwNoSvw6AcfIlL1Xg.png"/></figure><figure class="mh jr mn mj mk ml mm paragraph-image"><img src="../Images/853eecb0a6bcc43a1cf774a3e4a1689a.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*2RgN_UJpTWToFMVHLORJVQ.png"/></figure></div><p id="3580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">甚至…</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/2c1e9ebaab2e58382edd6b5bb9ab8357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*NOURHOox2-JldnwdDgwRzA.png"/></div></figure><p id="c25f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">神奇。</p><h1 id="ba6f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">限制提供的类型</h1><p id="eccc" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">这是一个好的开始，但是在我们的<code class="fe lc ld le lf b">&lt;List&gt;</code>中，我们对传入的项目类型一无所知。对于这个组件的消费者来说，这是非常好和灵活的，但是如果我们想要呈现一个实际的列表，并且每个列表项都需要一个键，这将是一个问题:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="132a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在<code class="fe lc ld le lf b">item.id</code>上给我们一个类型错误，因为我们已经说过<code class="fe lc ld le lf b">ItemType</code>可能是<code class="fe lc ld le lf b">any</code>，众所周知，任何人都没有id。</p><p id="5abe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过为传递给这个组件的项目定义所需属性的基本集合来解决这个问题，这个位在<code class="fe lc ld le lf b">extends</code>的右边:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="5008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们说“我不太了解被传入的项目，但我知道它们会有一个<code class="fe lc ld le lf b">id</code>属性”。</p><p id="0d18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简洁起见，我内联了<code class="fe lc ld le lf b">{id: string}</code>，但是如果你有一个<code class="fe lc ld le lf b">BaseEntity</code>或者<code class="fe lc ld le lf b">BaseNode</code>类型，你可以在这里使用它。</p><p id="1de5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，<code class="fe lc ld le lf b">{id: string}</code> <em class="lh">并不意味着</em>是一个具有<code class="fe lc ld le lf b">id</code>属性的普通对象(它可能是一个具有<code class="fe lc ld le lf b">id</code>属性的函数或数组)。同样，<code class="fe lc ld le lf b">{}</code>并不像你想的那样意味着“对象”:<code class="fe lc ld le lf b">123 extends {}</code>是真的。如果这还不够混乱的话:<code class="fe lc ld le lf b">123 extends Object</code>也是真的，而<code class="fe lc ld le lf b">123 extends object</code>是假的。</p><p id="0e28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旁注:再一次，JavaScript缺少一个词来描述你用花括号做的东西，它有键和值，不是数组也不是函数，这是很多混乱的来源。好消息是，在一般函数中，您通常不关心，您只需定义组件工作所需的最低要求。如果上面的<code class="fe lc ld le lf b">&lt;List&gt;</code>的消费者想要传入一个函数数组，并且每个函数都有一个<code class="fe lc ld le lf b">id</code>属性，那么这很奇怪，但是很好，因为TypeScript一直都知道<code class="fe lc ld le lf b">{id: string}</code>可以是一个函数。</p><h1 id="f578" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">推断嵌套类型</h1><p id="35cf" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">到目前为止很简单。但是如果我们不能很容易地推断出被传入的类型呢？在下面的<code class="fe lc ld le lf b">&lt;Select&gt;</code>中，我们聪明的人可以看到这一点，并知道所选id的类型将来自<code class="fe lc ld le lf b">Size</code> enum，但TypeScript没有机会。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ea27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得不可思议，可以使用以下语法显式提供泛型变量类型:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是当涉及到React组件和TypeScript泛型时，如果您放弃DOM并传入一组对象，您的生活将会简单得多。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="bbc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许我们“看到”传入数据中的内容，并确定将调用什么类型的<code class="fe lc ld le lf b">onSelect</code>。</p><p id="5aba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe lc ld le lf b">&lt;Select&gt;</code>的内部看起来像…</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="8a35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe lc ld le lf b">&lt;List&gt;</code>示例，TypeScript从传入的对象类型中计算出了<code class="fe lc ld le lf b">ItemType</code>。有了这个<code class="fe lc ld le lf b">&lt;Select&gt;</code>我们可以更深入一层，从传入数组中对象的属性推断出类型。</p><p id="2122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(我将在这篇文章的其余部分使用这个<code class="fe lc ld le lf b">&lt;Select&gt;</code>例子，但不会通过处理<code class="fe lc ld le lf b">&lt;optgroup&gt;</code>元素来混淆视听。我希望你不介意。)</p><h1 id="3999" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">传递泛型类型变量</h1><p id="1523" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">一般的“类型变量”(比如上面代码片段中的<code class="fe lc ld le lf b">IdType</code>)是奇怪的东西，在普通的JavaScript世界中没有明确的对等物。我认为他们有点像测试框架中的间谍，你可以通过他们来捕捉特定时间点上发生的事情。但是对于类型变量，你不是说“等着看这个方法用什么调用”，而是说“等着看这个槽里放什么样的数据”。</p><p id="5f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使它们在概念上与函数参数有很大的不同，你仍然可以用相似的方式传递它们。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><h1 id="4517" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">具有泛型的条件返回类型</h1><p id="cc6a" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">如果在<code class="fe lc ld le lf b">props.onSelect</code>中返回的值的类型与作为ID传入的类型相同，这就太好了。但也可能不是。</p><p id="98a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果这个<code class="fe lc ld le lf b">&lt;Select&gt;</code>是可选的，并且允许用户不选择任何东西，我们可能希望组件发送<code class="fe lc ld le lf b">null</code>到<code class="fe lc ld le lf b">onSelect</code>。</p><p id="9d92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们想对TypeScript说:“当<code class="fe lc ld le lf b">required</code>是<code class="fe lc ld le lf b">true</code>时，传递给<code class="fe lc ld le lf b">onSelect</code>的值将与在<code class="fe lc ld le lf b">option</code> s中传递的<code class="fe lc ld le lf b">id</code>的类型相同，但是如果<code class="fe lc ld le lf b">required</code>不是<code class="fe lc ld le lf b">true</code>也可能是<code class="fe lc ld le lf b">null</code>”。</p><p id="0fd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个大概的实现。当<code class="fe lc ld le lf b">required</code>为假时，我们添加一个<code class="fe lc ld le lf b">&lt;option&gt;</code>来不选择任何东西。并具有<code class="fe lc ld le lf b">onChange</code>功能，当选择空选项时，该功能将从<code class="fe lc ld le lf b">null</code>传递到<code class="fe lc ld le lf b">onSelect</code>。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ab29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了类型别名<code class="fe lc ld le lf b">Nullable</code>来表示逻辑“返回ID的类型将是传入ID的类型，如果required不为真，它也可以是<code class="fe lc ld le lf b">null</code>”。</p><p id="3f1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，这在三个地方都有应用:定义当前所选内容的属性，传递给<code class="fe lc ld le lf b">onSelect</code>的参数类型，以及恼人的是，在组件中我们实际调用<code class="fe lc ld le lf b">onSelect</code>的地方。</p><p id="bf01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这第三种用法标志着我们普通平稳航行的结束，因为我们绕过了淘气水的海角，毫无选择地漂进了北太平洋的波涛汹涌的地方。</p><h1 id="b403" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">条件泛型:棘手之处</h1><p id="f05f" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">当涉及到一般的React组件时，您可能会遇到两个问题。一个是泛型变量类型的怪癖，另一个是当TypeScript不能意识到某些复杂条件时发生的。</p><p id="e698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先…在一个不使用泛型的函数中，TypeScript非常擅长“缩小”传入值的类型:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="0515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以安全地指定乘法，比如说<code class="fe lc ld le lf b">stringOrNumber * 4</code>，因为TypeScript通过演绎的力量知道<code class="fe lc ld le lf b">stringOrNumber </code>必须是一个数字。</p><p id="4eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而这段功能相同的代码并不工作:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ce4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看，TypeScript不能缩小泛型变量的类型。据我所知，原因是这样的:在第一个例子中，我们处理的是值的<em class="lh">类型，它必须是<code class="fe lc ld le lf b">string</code>或<code class="fe lc ld le lf b">number</code>。如果不是一个，那一定是另一个。在第二个例子中，我们正在处理类型变量</em>的<em class="lh">类型，该类型可以是<code class="fe lc ld le lf b">string</code>或<code class="fe lc ld le lf b">number</code>或<code class="fe lc ld le lf b">string | number</code>。</em></p><p id="10c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不完全明白这是否是设计出来的，或者会在未来的版本中修复，但关键是你不能缩小泛型变量的范围。这是问题一。</p><p id="58bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题二:回到我们的<code class="fe lc ld le lf b">&lt;Select&gt;</code>组件，不能指望TypeScript真正理解当<code class="fe lc ld le lf b">required</code>为falsey时，我们有一些JSX将呈现一个额外的<code class="fe lc ld le lf b">&lt;option&gt;</code> DOM元素，并且<code class="fe lc ld le lf b">&lt;option&gt;</code>元素的<code class="fe lc ld le lf b">value</code>属性将通过React传递给<code class="fe lc ld le lf b">&lt;select&gt;</code>元素上的<code class="fe lc ld le lf b">onChange</code>事件。</p><p id="07a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，TypeScript无法知道我们将<code class="fe lc ld le lf b">null</code>传递给<code class="fe lc ld le lf b">props.onSelect</code>的唯一方式是<code class="fe lc ld le lf b">props.required</code>是否为真。由于这是无法推断的，我们必须向TypeScript保证我们的组件逻辑与我们在prop类型中做出的承诺是一致的。为此，我们使用<code class="fe lc ld le lf b">as</code>:</p><pre class="kw kx ky kz gt mu lf mv mw aw mx bi"><span id="70b1" class="my lj iq lf b gy mz na l nb nc">props.onSelect(selectedId as Nullable&lt;IdType, RequiredType&gt;);</span></pre><h2 id="ebe2" class="my lj iq bd lk nd ne dn lo nf ng dp ls kj nh ni lw kn nj nk ma kr nl nm me nn bi translated">条件泛型的另一种方法</h2><p id="6f4a" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">如果你的组件和上面的一样简单，并且只有两个场景(需要或者不需要)，那么你也可以定义两组道具。换句话说，你是在对TypeScript说“这个组件可以在两种模式中的一种模式下运行…”。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f118" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这消除了<code class="fe lc ld le lf b">Nullable</code>类型别名，但意味着您必须调用类型收缩来允许TypeScript确信您正在将正确的类型传递给<code class="fe lc ld le lf b">props.onSelect</code>。或者用<code class="fe lc ld le lf b">@ts-ignore</code>。</p><p id="2728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一方面，这是一个改变复杂性的例子，所以你走哪条路并不重要。但另一方面，更好的是，请记住，TypeScript在生产中消失了，所以使用这种有区别的联合方法，您会给应用程序在生产中的操作方式增加实际的复杂性，这种复杂性只是为了TypeScript的利益而存在。我认为这是一个禁忌，并建议你也这样做。</p><p id="915f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(您也可以使用函数重载，但是这将面临与props的区别联合相同的问题，并且语法很粗糙。)</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="4486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘿，我们到终点了吗？我想我们到终点了。</p><p id="4590" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不，等等，我想到了一件更复杂的事情，你可能不需要知道…</p><h1 id="807b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">将类型变量混合到现有类型中</h1><p id="b1f8" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">如果不是将<code class="fe lc ld le lf b">id</code>和<code class="fe lc ld le lf b">name</code>传递给你的<code class="fe lc ld le lf b">&lt;Select&gt;</code>，而是镜像底层HTML，允许消费者传递他们悸动的小心脏想要的任何<code class="fe lc ld le lf b">&lt;option&gt;</code>属性，会怎么样？</p><p id="51c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们想要扩展<code class="fe lc ld le lf b">&lt;option&gt;</code>组件/元素的属性，并使用它的<code class="fe lc ld le lf b">value</code>属性来计算出我们将传递给<code class="fe lc ld le lf b">onSelect</code>的是什么类型的东西。我们可以通过扩展<code class="fe lc ld le lf b">React.ComponentProps&lt;'option'&gt;</code>的泛型类型别名来实现:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们传入的选项对象可以直接传播到<code class="fe lc ld le lf b">&lt;option&gt;</code>元素上，我们可以放心，这些类型在当天晚上不会有问题。当使用这个组件时，我们可以向<code class="fe lc ld le lf b">&lt;option&gt;</code>传递任何有效的HTML属性，比如<code class="fe lc ld le lf b">disabled</code>。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="16b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">附注:你可能想使用<code class="fe lc ld le lf b">Omit&lt;&gt;</code>或<code class="fe lc ld le lf b">Pick&lt;&gt;</code>而不是大规模公开所有属性，例如，如果你不打算在组件中遵守<code class="fe lc ld le lf b">selected</code>属性，就不允许传入它。</p><h1 id="8375" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">访问通用道具</h1><p id="23d7" class="pw-post-body-paragraph jy jz iq ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">最后一件事…</p><p id="5e3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一个普通的React组件，如果你想得到它的道具类型，你可以写类似于<code class="fe lc ld le lf b">React.ComponentProps(typeof Select)</code>的东西。但是这不适用于通用组件，因为在很多地方你会得到类型<code class="fe lc ld le lf b">unknown</code>。这是有意义的，因为在不知道你打算传递什么样的数据的情况下，一个“通用”组件没有<em class="lh">有用的类型。</em></p><p id="7dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您需要显式导出您的道具并传递通用变量，可能如下所示:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们可以只将props的类型变量定义为<code class="fe lc ld le lf b">type SelectProps&lt;IdType, RequiredType&gt; = …</code>而没有<code class="fe lc ld le lf b">extends</code>，因为我们实际上并不依赖类型变量在这个类型别名中扩展任何特定的内容。但是因为我们要导出它，并且希望它是正确的，所以我们做了一点重复，定义了<code class="fe lc ld le lf b">extends string</code>和<code class="fe lc ld le lf b">extends boolean</code>。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="2ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们完成了。嘿，谢谢你的阅读，你很棒。这是一张戴眼镜的狗的照片。你知道吗，当狗戴眼镜时，它们会把胳膊放在耳朵下面。我也没有！</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/d93ff7ae718d6b347b4fac51f87dfc0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuEUDAkSJw0qIIAOK4qoiw.jpeg"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">Photo by <a class="ae mg" href="https://unsplash.com/@cookiethepom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Cookie the Pom</a> on <a class="ae mg" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dc4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lh">更多内容尽在</em><a class="ae mg" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="lh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>