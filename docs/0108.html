<html>
<head>
<title>Abstract Syntax Trees by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过例子抽象语法树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/abstract-syntax-trees-by-example-9e581091b24f?source=collection_archive---------11-----------------------#2021-01-06">https://javascript.plainenglish.io/abstract-syntax-trees-by-example-9e581091b24f?source=collection_archive---------11-----------------------#2021-01-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c4e9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Babel是一个非常强大的代码生成器和解析器，但是文档中并没有很多关于如何使用它来解析、生成和操作抽象语法树的例子，我在这里收集了一些我自己使用它的例子。</h2></div><p id="f43e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我目前正在做一个兼职项目，需要大量的JSX/HTML解析、操作和使用抽象语法树(AST)的生成。</p><p id="6601" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ASTs非常强大，你可以用它们来构建自己的<a class="ae ky" href="https://babeljs.io/docs/en/plugins" rel="noopener ugc nofollow" target="_blank">巴别塔插件</a>、<a class="ae ky" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank">宏</a>，或者直接将它们作为你的应用程序的一部分，对你的代码进行定制解析和操作。</p><p id="c380" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里阅读更多关于ASTs的基础知识:</p><ul class=""><li id="624e" class="kz la in ke b kf kg ki kj kl lb kp lc kt ld kx le lf lg lh bi translated"><a class="ae ky" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" rel="noopener ugc nofollow" target="_blank">巴别塔插件手册。</a></li><li id="d766" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated"><a class="ae ky" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">用ASTs升级自己的解析游戏</a></li><li id="de97" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=nlAHtAQlFGk" rel="noopener ugc nofollow" target="_blank"> KCD关于宏的视频</a></li></ul><p id="32d7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在处理ASTs时，您需要经常查阅的一个主要资源是<a class="ae ky" href="https://babeljs.io/docs/en/babel-types" rel="noopener ugc nofollow" target="_blank"> babel types文档</a>，但是我发现它的一个大问题是缺少关于如何使用不同方法以及输出的代码类型的示例。</p><p id="a9b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，作为我自己和他人的资源，我在这里收集了一些我自己使用的例子，并将随着时间的推移更新这个帖子，因为我正在进行这个项目:</p><p id="20b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于所有的例子，假设我正在导入这些库:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">babel imports</figcaption></figure><h1 id="bfe1" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">向JSX元素添加属性:</h1><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Add an attribute to a JSX element</figcaption></figure><blockquote class="mq mr ms"><p id="279c" class="kc kd mt ke b kf kg jo kh ki kj jr kk mu km kn ko mv kq kr ks mw ku kv kw kx ig bi translated"><em class="in">注意:上述条件中的</em> <code class="fe mx my mz na b"><em class="in">visited</em></code> <em class="in"> param名称是为了避免在同一个节点中再次遍历而导致无限循环，因为babel不保证只访问同一个节点一次。可能有更好的方法，但在我搞清楚之前，这就是这种情况的原因。</em></p></blockquote><h1 id="6578" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">将元素包装在新元素中:</h1><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Wrapping an Element in a new one</figcaption></figure><h1 id="21b6" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">获取元素的所有键/值属性</h1><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Get all key/value props of an Element</figcaption></figure><h1 id="dee8" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">将新道具应用于元素</h1><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Apply New Props to an Element</figcaption></figure><p id="ffc9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了渲染生成的JSX输出，我使用了这个库<a class="ae ky" href="https://github.com/TroyAlford/react-jsx-parser" rel="noopener ugc nofollow" target="_blank"> react-jsx-parser </a>，我检查了它的源代码，它似乎使用了<a class="ae ky" href="https://github.com/acornjs/acorn" rel="noopener ugc nofollow" target="_blank"> Acorn </a>，这是另一个AST解析器/生成器(babel实际上是基于Acorn的)。</p><p id="0125" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于如何使用特定方法的示例，我找到了一些其他的好资源:</p><ul class=""><li id="9777" class="kz la in ke b kf kg ki kj kl lb kp lc kt ld kx le lf lg lh bi translated">在GitHub上搜索babel插件，看看它是如何在不同的上下文中使用的。</li><li id="e10d" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">搜索<a class="ae ky" href="https://www.codota.com" rel="noopener ugc nofollow" target="_blank">codata</a>寻找我正在尝试使用的方法，例如<a class="ae ky" href="https://www.codota.com/code/javascript/functions/%2540babel%252Ftypes/stringLiteral" rel="noopener ugc nofollow" target="_blank">https://www . codata . com/code/JavaScript/functions/% 2540 babel % 252 ftypes/stringLiteral</a>(tbh，我发现他们的搜索比Github的好很多)。</li></ul><p id="4301" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我发现<a class="ae ky" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>在快速尝试特定方法并查看它们的输出方面很有用，但是我错过了VS代码给出的每个方法签名的自动完成。(<a class="nb nc ep" href="https://medium.com/u/db72389e89d8?source=post_page-----9e581091b24f--------------------------------" rel="noopener" target="_blank"> Kent C. Dodds </a>在<a class="ae ky" href="https://www.youtube.com/watch?v=1ERAJG9ILhk" rel="noopener ugc nofollow" target="_blank">这个视频</a>展示了如何用它来构建babel宏)。</p><p id="670e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="28dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mt">最初发布于</em><a class="ae ky" href="https://felfel.dev/abstract-syntax-trees-by-example/" rel="noopener ugc nofollow" target="_blank"><em class="mt">https://fel fel . dev</em></a><em class="mt">。</em></p></div></div>    
</body>
</html>