<html>
<head>
<title>Level Up Your MongoDB Query Skills II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升您的MongoDB查询技能II</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/level-up-your-mongodb-query-skills-ii-94997bd15910?source=collection_archive---------19-----------------------#2021-12-22">https://javascript.plainenglish.io/level-up-your-mongodb-query-skills-ii-94997bd15910?source=collection_archive---------19-----------------------#2021-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6f4d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak">主MongoDB聚合</strong></h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8a0732d9f3963fcc8c733c0127b22278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tHo6CGeVFuiKyVFV"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@john_thng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John T</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b9d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文是<em class="lp">提高您的MongoDB查询技能(掌握MongoDB查询)的第二部分。</em></p><div class="lq lr gp gr ls lt"><a rel="noopener  ugc nofollow" target="_blank" href="/level-up-your-mongodb-query-skills-db059432f5f9"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd io gy z fp ly fr fs lz fu fw im bi translated">提升您的MongoDB查询技能</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">主MongoDB查询</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mc l"><div class="md l me mf mg mc mh km lt"/></div></div></a></div><p id="7188" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，为了避免重复，我将重用那篇文章中的一些程序，包括如何创建MongoDB连接、创建用户集合和文档，以及如何执行CRUD操作。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="2792" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">聚合是MongoDB的高级查询语言。它使我们能够组合来自多个文档的数据来生成单个文档，这是我们无法从单个文档生成的。</p><p id="0bd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Aggregation相当于MongoDB的SQL GROUP BY子句。</p><h1 id="3a93" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">聚合框架概述</strong></h1><p id="11d5" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">在聚合管道中，管道操作中每个步骤的输出为下一个步骤提供了输入。在每个步骤中，对输入文档执行单个操作来转换它们并生成输出文档。</p><p id="a8f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将研究以下聚合管道操作:</p><ul class=""><li id="eae9" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$project</code> —指定要放置在输出文档中的字段。</li><li id="b5c2" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$group</code> —按指定的关键字对文档进行分组。</li><li id="aacc" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$match</code> —选择要处理的文档，类似于<code class="fe nv nw nx ny b">find()</code></li><li id="bc5e" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$limit</code> —限制要传递给下一步的文档数量。</li><li id="593c" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$skip </code> —跳过指定数量的文档。</li><li id="7e6c" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$unwind </code> —为每个输入文档数组生成一个输出文档。</li><li id="ed0b" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$sort </code> —对文档进行分类。</li><li id="e535" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated"><code class="fe nv nw nx ny b">$out</code> —将管道的结果写入集合。</li></ul><p id="5a0d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<em class="lp">提高您的MongoDB查询技能</em>(第1部分)中，我只创建了一个集合—<code class="fe nv nw nx ny b">User</code>，但是为了更好地理解聚合，我们需要更多的集合，所以我将创建更多的集合来使它成为一个电子商务数据库。我将创建的集合有:<code class="fe nv nw nx ny b">Products</code>、<code class="fe nv nw nx ny b">Categories</code>、<code class="fe nv nw nx ny b">Orders</code>和<code class="fe nv nw nx ny b">Reviews</code>。</p><h2 id="b00b" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">产品数据</strong></h2><p id="ff9f" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">首先，让我们创建一个文件— <code class="fe nv nw nx ny b">product.js</code>，它将包含产品数据。这个文件将被导入到<code class="fe nv nw nx ny b">connect.js</code>(我们在上一篇文章中创建的文件)中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="af87" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">产品集合</strong></h2><p id="e363" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">在<code class="fe nv nw nx ny b">connect.js</code>中，添加下面的代码，该代码将导入产品数据，创建产品集合，并将产品数据插入产品集合。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="9d28" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">类别数据</strong></h2><p id="2b10" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">让我们创建包含类别数据的<code class="fe nv nw nx ny b">category.js</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="ebdc" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">类别集合</strong></h2><p id="fe04" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">将类别数据导入<code class="fe nv nw nx ny b">connect.js</code> <strong class="kv io"> </strong>创建类别集合。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="706b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们对产品数据做了同样的事情。我们将包含类别数据的文件导入到<code class="fe nv nw nx ny b">connect.js</code>中，创建一个类别集合，并将类别数据插入到类别集合中。</p><h2 id="67fe" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">订单数据</strong></h2><p id="007e" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">一个电商店铺没有订单是没有意义的，所以我们创建一个文件— <code class="fe nv nw nx ny b">orders.js</code>，里面会包含我们的订单数据。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="41b7" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">订单收款</strong></h2><p id="1f3f" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">将<code class="fe nv nw nx ny b">orders.js</code>导入<code class="fe nv nw nx ny b">connect.js</code>获取订单数据，创建订单集合，并将订单数据插入订单集合。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="5319" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">审查数据</strong></h2><p id="90c0" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">用户通常会在网站上留下对商品的评论，所以让我们创建一个包含评论数据的<code class="fe nv nw nx ny b">review.js</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="75db" class="oe mq in bd mr of og dn mv oh oi dp mz lc oj ok nb lg ol om nd lk on oo nf op bi translated"><strong class="ak">回顾收藏</strong></h2><p id="cb7a" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">就像我们对其他集合所做的一样，要创建一个评审集合，将<code class="fe nv nw nx ny b">reviews.js</code>导入到<code class="fe nv nw nx ny b">connect.js</code>中以获取评审数据，创建一个评审集合，并将评审数据插入到评审集合中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="e1a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看如何将不同的聚合管道操作符应用到我们创建的集合和文档中。</p><h1 id="d62e" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$项目</strong></h1><p id="5514" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe nv nw nx ny b">$project</code> <strong class="kv io"> </strong>操作符检索或传递只包含指定字段的文档到管道的下一阶段。</p><p id="d0de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe nv nw nx ny b">$project</code> <strong class="kv io"> </strong>运算符时需要注意的几点:</p><ul class=""><li id="49a3" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">默认情况下，<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段包含在输出文档中。这意味着，除非您显式排除<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段，否则它将在返回或传递到管道中下一个阶段的文档字段中。</li><li id="e266" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated">您可以指定要返回或传递到下一阶段的字段的包含和排除。</li><li id="3fc1" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated">如果您指定包含文档中不存在的字段，<code class="fe nv nw nx ny b">$project</code> <strong class="kv io"> </strong>会忽略该字段。</li></ul><p id="b09d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><p id="9845" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们想要返回所有用户的<code class="fe nv nw nx ny b">_id</code>、<code class="fe nv nw nx ny b">firstname</code>和<code class="fe nv nw nx ny b">age</code>，我们的查询应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="e1e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果用户集合中有用户，将返回包含用户的字段<code class="fe nv nw nx ny b">_id</code>、<code class="fe nv nw nx ny b">firstname</code>和<code class="fe nv nw nx ny b">age</code>的文档。<br/>在我们的查询中，我们指定应该检索<code class="fe nv nw nx ny b">firstname</code> <strong class="kv io"> </strong>和<code class="fe nv nw nx ny b">age</code> <strong class="kv io"> </strong>字段，但是我们没有指定应该排除<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段，但是请记住，如果我们没有显式排除<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段，它将默认包含在内。</p><p id="4363" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经看到了如何指定要返回或传递到管道下一阶段的字段，但是我们如何显式地排除字段呢？</p><p id="fe2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们不关心文档的<code class="fe nv nw nx ny b">_id</code>并希望它被排除，我们的查询应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="0497" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想要排除的字段存在，为其分配零将使其从返回的文档中排除。<br/>以上查询将返回除<code class="fe nv nw nx ny b">_id</code>之外的所有其他现有字段的用户文档。</p><h1 id="6126" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$组</strong></h1><p id="472b" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe nv nw nx ny b">$group</code> <strong class="kv io"> </strong>聚合多个文档的数据。</p><p id="c6ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe nv nw nx ny b">$group</code>运算符时，必须指定<code class="fe nv nw nx ny b">_id</code>字段。通过指定<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段，您可以让<code class="fe nv nw nx ny b">$group</code> <strong class="kv io"> </strong>操作员知道您希望文档如何分组。<br/> <code class="fe nv nw nx ny b">$group</code> <strong class="kv io"> </strong>根据指定的<code class="fe nv nw nx ny b">_id</code>表达式对输入文档进行分组，并返回每个不同组的汇总输出。</p><p id="62d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你熟悉SQL，那么<code class="fe nv nw nx ny b">$group</code> <strong class="kv io"> </strong>函数相当于SQL <code class="fe nv nw nx ny b">GROUP BY</code> <strong class="kv io"> </strong>子句。</p><p id="26c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么它是如何工作的呢？</p><p id="bc4d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们想从<code class="fe nv nw nx ny b">Review</code> <strong class="kv io"> </strong>集合中检索不同的评分值，我们的查询应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="7a8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将对评论集合中的每个不同的评级进行分组，并为每个评级返回一个文档。</p><p id="2756" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果5个客户提交评分1，15个客户提交评分3，20个客户提交评分4，上面的代码将返回代表每个评分(1，3，4)的三个文档，如下所示:</p><pre class="kd ke kf kg gt os ny ot ou aw ov bi"><span id="f2f1" class="oe mq in ny b gy ow ox l oy oz">{ "_id": "1" }<br/>{ "_id": "3" }<br/>{ "_id": "4" }</span></pre><h1 id="53ff" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak"> $match </strong></h1><p id="e3b4" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">就像<code class="fe nv nw nx ny b">find()</code> <strong class="kv io"> </strong>方法只检索符合指定条件的文档一样，<code class="fe nv nw nx ny b">$match</code> <strong class="kv io"> </strong>操作符过滤文档，只将符合指定条件的文档传递到管道中的下一个阶段。</p><p id="ee0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可能希望将这个操作符尽可能早地放在聚合管道中，因为<code class="fe nv nw nx ny b">$match</code> <strong class="kv io"> </strong>减少了聚合管道中的文档总数，这将最小化管道中的处理量。</p><p id="cd83" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="ed20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从产品集合中，<code class="fe nv nw nx ny b">$match</code> <strong class="kv io"> </strong>只检索<code class="fe nv nw nx ny b">name</code> <strong class="kv io"> </strong>字段等于<code class="fe nv nw nx ny b">Sony WH-1000XM4.</code>的文档</p><h1 id="e091" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$限额</strong></h1><p id="7f12" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe nv nw nx ny b">$limit</code> <strong class="kv io"> </strong>操作符限制将传递到聚合管道中下一个阶段的文档数量。</p><p id="e366" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要传递给<code class="fe nv nw nx ny b">$limit</code> <strong class="kv io"> </strong>的值应该是一个正整数，它指定了要检索或传递给下一阶段的最大文档数。</p><p id="f2af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="547d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们的<code class="fe nv nw nx ny b">Product</code>集合中有成百上千的产品，上面的操作将只返回管道传递给它的前五个文档。</p><h1 id="e424" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$跳过</strong></h1><p id="deb6" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe nv nw nx ny b">$skip</code>操作符跳过指定数量的文档，将剩余的文档传递到管道中的下一个阶段。</p><p id="3a90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个正整数作为值传递给<code class="fe nv nw nx ny b">$skip</code> <strong class="kv io"> </strong>以指定要跳过的最大文档数。</p><p id="b0ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="a5a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该操作跳过管道传递给它的前五个产品，并将剩余的文档传递给管道中的下一个阶段。</p><h1 id="6938" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$排序</strong></h1><p id="7198" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">如果希望查询结果按特定顺序返回，可以使用<code class="fe nv nw nx ny b">$sort</code> <strong class="kv io"> </strong>操作符，该操作符对所有输入文档进行排序，并按排序后的顺序将它们返回到管道。<code class="fe nv nw nx ny b">$sort</code> <strong class="kv io"> </strong>需要一个指定排序依据字段和排序顺序的文档。</p><p id="b8fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">文档通常按升序或降序排序。按升序排序时，指定的排序依据字段被赋值为<code class="fe nv nw nx ny b">1</code>，而按降序排序时，指定的排序依据字段被赋值为<code class="fe nv nw nx ny b">-1</code>。</p><p id="68dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">MongoDB集合中的文档没有按照特定的顺序存储，因此，在对包含重复值的文档进行排序时，这些值可以按照任何顺序返回。为了避免这种情况，也就是说，如果您希望排序顺序一致，那么在排序文档中至少要包含一个包含唯一值的字段，最常见的是<code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段。</p><p id="c8a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="f1e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的例子中，产品根据它们的名称以升序排序，但是排序顺序可能不一致。如果<code class="fe nv nw nx ny b">name</code> <strong class="kv io"> </strong>字段包含重复值，则返回的单据不一致。</p><p id="0bce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如前所述，确保排序顺序一致的一种方法是在排序文档中包含一个具有唯一值的字段:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="bbce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nv nw nx ny b">_id</code> <strong class="kv io"> </strong>字段包含唯一值，将其包含在排序操作中可以确保排序操作返回的文档一致。</p><p id="e6ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要按产品名称降序排列产品:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="2ebc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该操作将从<code class="fe nv nw nx ny b">Product</code> <strong class="kv io"> </strong>集合中返回文档，产品名称按降序排列。</p><h1 id="dea6" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated"><strong class="ak">$平仓</strong></h1><p id="9446" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">如果将一个数组字段传递给<code class="fe nv nw nx ny b">$unwind</code> <strong class="kv io"> </strong>操作符，将为数组中的每个条目生成一个输出文档。</p><p id="7821" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">理想情况下，您应该为<code class="fe nv nw nx ny b">$unwind</code> <strong class="kv io"> </strong>提供一个数组字段，但是如果您提供的字段没有解析为数组，并且它不是missing、null或空数组，<code class="fe nv nw nx ny b">$unwind</code> <strong class="kv io"> </strong>会将非数组操作数视为单元素数组。</p><p id="3619" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5fcb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的聚合管道包含两个阶段:<code class="fe nv nw nx ny b">$project</code>和<code class="fe nv nw nx ny b">$unwind</code>。第一阶段— <code class="fe nv nw nx ny b">$project</code>将确保返回的文档只包含<code class="fe nv nw nx ny b">tag</code>字段。在第二阶段— <code class="fe nv nw nx ny b">$unwind</code>，如果tag字段的值是一个数组，那么将为数组中的每一项生成一个文档。</p><p id="5209" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的<code class="fe nv nw nx ny b">Product</code>系列中有一款产品——索尼耳机，它包含以下标签:</p><pre class="kd ke kf kg gt os ny ot ou aw ov bi"><span id="f273" class="oe mq in ny b gy ow ox l oy oz">tags: [ "Headphone", "Sony", "Technology" ]</span></pre><p id="d625" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nv nw nx ny b">$unwind</code>操作结束时，将返回以下内容:</p><pre class="kd ke kf kg gt os ny ot ou aw ov bi"><span id="7ea3" class="oe mq in ny b gy ow ox l oy oz">{ "tags": "Headphone" }<br/>{ "tags": "Sony" }<br/>{ "tags": "Technology" }</span></pre><h1 id="7f81" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">Out</h1><p id="a5ae" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe nv nw nx ny b">$out</code>操作符获取聚合管道生成或返回的文档，并将它们写入指定的集合。如果指定的集合不存在，<code class="fe nv nw nx ny b">$out</code>操作符将创建一个新的集合。如果指定的集合存在，则在聚合操作结束时，现有集合的内容将自动替换为聚合操作的结果。</p><p id="bb8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于out操作符，需要注意一些事情:</p><ul class=""><li id="efe0" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">$out运算符必须是管道中的最后一个运算符。</li><li id="6421" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated">在聚合完成之前，新创建的集合不可见。</li><li id="56c2" class="nm nn in kv b kw nz kz oa lc ob lg oc lk od lo nr ns nt nu bi translated">如果聚合失败，MongoDB不会创建集合。</li></ul><p id="9c43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="fc63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该操作计算每个主要类别的产品数量。如果一个<code class="fe nv nw nx ny b">mainCategorySummary</code>集合不存在，操作的结果将创建一个新的<code class="fe nv nw nx ny b">mainCategorySummary</code>集合，但是如果它已经存在，现有的内容将被操作的结果完全替换。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="4c2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们查看了各种MongoDB聚合管道，包括:<code class="fe nv nw nx ny b">$project</code>、<code class="fe nv nw nx ny b">$group</code>、<code class="fe nv nw nx ny b">$match</code>、<code class="fe nv nw nx ny b">$limit</code>、<code class="fe nv nw nx ny b">$skip</code>、<code class="fe nv nw nx ny b">$sort</code>、<code class="fe nv nw nx ny b">$unwind</code>和<code class="fe nv nw nx ny b">$out</code>。<br/>正如我们从各种操作中看到的，这些聚合操作符使我们能够组合来自多个文档的数据，以生成不可能从单个文档生成的信息。</p><p id="8ff8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意这篇文章中的错误或任何不妥之处，或有任何贡献要补充吗？请在评论区指出来。我很乐意纠正和改进它。</p><p id="7958" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读。</p><p id="e29d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a><em class="lp">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">免费周报在这里</em> </a> <em class="lp">。</em></p></div></div>    
</body>
</html>