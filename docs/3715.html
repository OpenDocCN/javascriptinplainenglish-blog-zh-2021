<html>
<head>
<title>Singleton &amp; Factory Patterns With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript的单例模式和工厂模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/singleton-factory-patterns-with-typescript-59e5a405531e?source=collection_archive---------2-----------------------#2021-07-26">https://javascript.plainenglish.io/singleton-factory-patterns-with-typescript-59e5a405531e?source=collection_archive---------2-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="346d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用TypeScript实现的单例和工厂设计模式。用一个理发师和一个冰淇淋店的例子来解释。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/186c171923395d14d3fafcded3eb8e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0XVEe8Cqa9xFGveX8JLMxA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="http://www.zentrale.ch/" rel="noopener ugc nofollow" target="_blank">Eisvogel</a> — The best ice creams in Zürich</figcaption></figure><p id="d922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我在工程学校学到的所有设计模式中，singleton和factory可能是我在日常编程活动中使用最多的。有时我甚至把两者混合起来，让乐趣倍增😜。</p><p id="7f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我将向你展示如何用<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>实现这些模式。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f7e4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">一个</h1><blockquote class="mr ms mt"><p id="ead6" class="kw kx mu ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">在软件工程中，单例模式是一种软件设计模式，它将类的实例化限制在一个“单个”实例中(<a class="ae kv" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">源</a>)。</p></blockquote><p id="06cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单身者可能就像你的理发师。当你需要理发时，你不想去沙龙找任何新的专业人士，即使她/他和你有同样的技能，但是，你确实想要你的，因为她/他已经知道你最喜欢的设置✂️.</p><p id="5899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式可以通过将一个<code class="fe my mz na nb b">class</code>的<code class="fe my mz na nb b">constructor</code>定义为<code class="fe my mz na nb b">private</code>，使其在类声明之外实际上不可访问，并且只提供一个已经被设为<code class="fe my mz na nb b">static</code>的对象的实例来实现。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="703e" class="ng ma iq nb b gy nh ni l nj nk">export class Hairdresser {<br/>  private static <em class="mu">instance</em>: Hairdresser | undefined = undefined;<br/><br/>  private constructor() {}<br/><br/>  static <em class="mu">getInstance</em>(): Hairdresser {<br/>    if (!Hairdresser.<em class="mu">instance</em>) {<br/>      Hairdresser.<em class="mu">instance </em>= new Hairdresser();<br/>    }<br/><br/>    return Hairdresser.instance;<br/>  }<br/>}</span></pre><p id="5148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上面的片段，我们不能得到任何新的理发师。尝试实例化新对象会导致错误。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ff2f" class="ng ma iq nb b gy nh ni l nj nk">// TS2673: Constructor of class 'Hairdresser' is private and only accessible within the class declaration.<br/>const hairdresser: Hairdresser = new Hairdresser();</span></pre><p id="c2eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，访问实例将总是返回第一个已初始化的对象。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="b75c" class="ng ma iq nb b gy nh ni l nj nk">const hairdresser: Hairdresser = Hairdresser.<em class="mu">getInstance</em>();</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="afcc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">工厂</h1><blockquote class="mr ms mt"><p id="868d" class="kw kx mu ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">在基于类的编程中，工厂方法模式是一种创造性的模式，它使用工厂方法来处理创建对象的问题，而不必指定将要创建的对象的确切类。这是通过调用工厂方法而不是调用构造函数来创建对象来实现的(<a class="ae kv" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank"> source </a>)。</p></blockquote><p id="eaa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">工厂模式就像<a class="ae kv" href="https://www.gaultmillau.ch/zuri-isst/eisvogel-das-beste-glace-zurich" rel="noopener ugc nofollow" target="_blank"> Eisvogel </a>，我最喜欢的，当然也是苏黎世最好的冰淇淋店。他们每天出售手工制作的美味冰淇淋，每天有五种不同的新口味。</p><p id="7f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你到了那里，你知道你要去买冰淇淋，但是你不知道是什么口味的。</p><p id="e085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，您可以使用一个工厂来获得共享一个预期行为的对象，但是可以以不同的方式实现。</p><p id="e39b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，它或者需要一个<code class="fe my mz na nb b">interface</code>或者一个<code class="fe my mz na nb b">abstract</code>类，这个类描述了除了应该由工厂创建的预期对象的有效实现之外的公共行为。</p><p id="df53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同<code class="fe my mz na nb b">interface</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="4c16" class="ng ma iq nb b gy nh ni l nj nk">export interface IceCream {<br/>  yummy(): boolean;<br/>}<br/><br/>export class Strawberry implements IceCream {<br/>  yummy(): boolean {<br/>    return true;<br/>  }<br/>}<br/><br/>export class Chocolate implements IceCream {<br/>  yummy(): boolean {<br/>    return true;<br/>  }<br/>}</span></pre><p id="2d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe my mz na nb b">abstract</code>(注意:使用修饰器<code class="fe my mz na nb b">override</code>，这是在TypeScript 4.3中新引入的，表示一个方法覆盖了父定义):</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8c66" class="ng ma iq nb b gy nh ni l nj nk">export abstract class IceCream {<br/>  abstract yummy(): boolean;<br/>}<br/><br/>export class Strawberry extends IceCream {<br/>  override yummy(): boolean {<br/>    return true;<br/>  }<br/>}<br/><br/>export class Chocolate extends IceCream {<br/>  override yummy(): boolean {<br/>    return true;<br/>  }<br/>}</span></pre><p id="00d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不考虑上面的实现，可以实现一个相关的工厂。它可以是一个<code class="fe my mz na nb b">static</code>方法或者一个无状态<code class="fe my mz na nb b">function</code>的形式。重要的是，根据参数创建并返回所需的实现。</p><p id="4099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用一种<code class="fe my mz na nb b">static</code>方法:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="e80f" class="ng ma iq nb b gy nh ni l nj nk">export class Factory {<br/>  static <em class="mu">getIceCream</em>(): IceCream {<br/>    return Math.random() % 2 === 0 ? <br/>                new Strawberry() : new Chocolate();<br/>  }<br/>}</span></pre><p id="ed5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">带着<code class="fe my mz na nb b">function</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ff8d" class="ng ma iq nb b gy nh ni l nj nk">export const getIceCream = (): IceCream =&gt;<br/>  Math.random() % 2 === 0 ? new Strawberry() : new Chocolate();</span></pre><p id="88b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了一个<code class="fe my mz na nb b">random</code>数字来创建一个或另一个类型的对象。在实际应用中，变量通常是工厂的一个参数或另一个选项。</p><p id="a51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe my mz na nb b">static</code>方法或<code class="fe my mz na nb b">function</code>请求一个对象将返回不同的对象。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8f10" class="ng ma iq nb b gy nh ni l nj nk">// Static method call <br/>console.log(Factory.getIceCream().yummy());</span><span id="cb27" class="ng ma iq nb b gy nl ni l nj nk">// Function call<br/>console.log(getIceCream().yummy());</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f2ad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">联合的；共同的</h1><p id="9ba8" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">正如我在介绍中所说，有时我喜欢将乐趣加倍，并将两种模式结合起来。</p><p id="a288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在<a class="ae kv" href="https://github.com/deckgo/deckdeckgo/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中，我开发了这样一个概念，根据环境(“本地、登台或生产”)获得不同的服务。</p><p id="790c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用到上面的<code class="fe my mz na nb b">IceCream</code>片段，这意味着<code class="fe my mz na nb b">factory</code>需要跟踪用<code class="fe my mz na nb b">singleton</code>创建的对象。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="c9aa" class="ng ma iq nb b gy nh ni l nj nk">export class SingletonFactory {<br/>  private static <em class="mu">instance</em>: IceCream | undefined = undefined;<br/><br/>  static <em class="mu">getInstance</em>(): IceCream {<br/>    if (!this.<em class="mu">instance</em>) {<br/>      this.<em class="mu">instance </em>=<br/>        Math.random() % 2 === 0 ? <br/>             new Strawberry() : new Chocolate();<br/>    }<br/><br/>    return this.<em class="mu">instance</em>;<br/>  }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3821" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="15b2" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">有许多<a class="ae kv" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">模式</a>但是，这些是我最常用的。下次我使用另一种类型时，我应该把它收藏起来，它可能值得我写一篇新文章😉。</p><p id="2ac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与此同时，下次你去苏黎世的时候，请品尝一下美味的雪糕🍦。</p><p id="6d9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到无限和更远的地方！</p><p id="9dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大卫</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="0c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过推特<a class="ae kv" href="https://twitter.com/daviddalbusco" rel="noopener ugc nofollow" target="_blank">或我的</a><a class="ae kv" href="https://daviddalbusco.com/" rel="noopener ugc nofollow" target="_blank">网站</a>联系我。</p><p id="adbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为您的下一个演示，尝试一下<a class="ae kv" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://deckdeckgo.com"><div class="gh gi nr"><img src="../Images/4bba41bd3bc0b4335e2a0e2b3caa967f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IZktBtnL1Hia3le1.png"/></div></a></figure><p id="bdcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mu">更多内容请看</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>