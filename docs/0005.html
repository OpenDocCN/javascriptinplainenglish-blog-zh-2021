<html>
<head>
<title>JavaScript Basics: Objects and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:对象和函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-basics-objects-and-functions-30726efc766d?source=collection_archive---------3-----------------------#2021-01-01">https://javascript.plainenglish.io/javascript-basics-objects-and-functions-30726efc766d?source=collection_archive---------3-----------------------#2021-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ba2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">剧透:函数是对象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/18d2950415592062e240cdd6897f79f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ-Mdns5WCxiDTfJrwrCtw.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="7a86" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我们将介绍JavaScript中对象和函数的概念。</p><h1 id="f22d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">目标</h1><p id="6b05" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">对象是键/值对(属性)的集合。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4491" class="mw lv iq ms b gy mx my l mz na">{<br/>   "key": "value"<br/>}</span></pre><p id="8df6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">属性值可以是基元(字符串、整数、布尔值等。)、另一个对象或函数(如果在对象内部，则称为方法)。一个对象及其属性位于内存中，它可以引用内存中与之相连的其他对象，如另一个对象或函数。</p><h2 id="133d" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">创建对象</h2><p id="dfa6" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">JavaScript对象可以通过两种方式创建:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="b29d" class="mw lv iq ms b gy mx my l mz na">let person = new Object(); // object initialize</span><span id="c822" class="mw lv iq ms b gy nm my l mz na">let animal = {}; // object literal</span></pre><p id="2e2e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">创建对象的两种方式是相同的。简写为object literal，是创建新对象的更简短的方法。当JavaScript引擎解析语法并遇到花括号时，它假设您正在创建一个对象。JavaScript引擎将对象文字视为一行代码。</p><h2 id="df61" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">访问/设置对象属性</h2><p id="d64a" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">可以使用<code class="fe nn no np ms b">bracket notation</code>访问或设置JavaScript对象的属性。使用这种方法，我们可以动态地决定我们试图访问/设置哪个属性。在括号内，我们输入试图在内存中定位的值的名称。例如:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c613" class="mw lv iq ms b gy mx my l mz na">let person = {}<br/>person["name"] = "Pete"<br/>person["age"] = 18<br/>console.log(person["name"]) // "Pete"</span></pre><p id="3ebe" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我们设置“name”和“age”属性时，这将在内存中为每个属性创建一个位置，给它这些名称，并且<code class="fe nn no np ms b">person</code>对象将有一个对内存中该位置的地址的引用。</p><p id="7858" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">访问属性和方法的一个更常见、更容易的操作符是<code class="fe nn no np ms b">dot operator</code>。使用这种方法，不需要用引号来表示值。例如:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="11b2" class="mw lv iq ms b gy mx my l mz na">let person = {};<br/>person.name = "Luka"<br/>person.age = "34"<br/>console.log(person.name) // "Luka"</span></pre><p id="7daf" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在引擎盖下，JavaScript正在读取<code class="fe nn no np ms b">person</code>是一个对象。当JavaScript注意到对象后面的点时，它会将点之后的任何内容作为属性读取。</p><p id="0505" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对象本身及其属性都在内存中。<code class="fe nn no np ms b">dots</code>和<code class="fe nn no np ms b">brackets</code>是访问信息的一种方式。建议使用dot，除非在特殊情况下，例如:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="4f0a" class="mw lv iq ms b gy mx my l mz na">let person = {}<br/>person["Voted-Most-Likely-To-Be-A-CEO-in-HighSchool"] = true<br/>person.Voted-Most-Likely-To-Be-A-CEO-in-HighSchool // will not work</span></pre><p id="68e2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有可能拥有包含符号甚至空格的属性。对于<code class="fe nn no np ms b">dot notation</code>，JavaScript将无法正确解析它并抛出语法错误。在这种情况下，<code class="fe nn no np ms b">dot notation</code>将不适用于<code class="fe nn no np ms b">bracket notation</code>。</p><h1 id="bbec" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">功能</h1><p id="85b1" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">JavaScript中的函数是<code class="fe nn no np ms b">first-class</code>函数。这意味着函数被视为任何其他数据类型。它们可以作为值赋给变量，作为参数传递给其他函数，也可以由另一个函数返回。</p><h2 id="1d1c" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">函数是对象</h2><p id="82a2" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">就像任何对象一样，它驻留在内存中。函数具有普通对象的特征和一些其他特殊属性。属性和方法可以附加到函数上。函数对象有一些隐藏的属性:</p><ul class=""><li id="db52" class="nq nr iq la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">一个函数不需要有名字，它可以是我们所知的<code class="fe nn no np ms b">anonymous</code>函数。《出埃及记》<code class="fe nn no np ms b">function(){ console.log("noName")}</code></li><li id="69a4" class="nq nr iq la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">一个函数有一个<code class="fe nn no np ms b">code</code>属性，写在花括号内的代码行放在这里。该属性的与众不同之处在于它是可调用的，这意味着您可以运行代码。</li></ul><p id="15a9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们看一个例子:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2bac" class="mw lv iq ms b gy mx my l mz na">function sayHello(){<br/>  console.log("Bye")<br/>}</span><span id="8e47" class="mw lv iq ms b gy nm my l mz na">sayHello.test = "Test"</span></pre><p id="aa9f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在内存中创建了一个函数，它有两个属性:<code class="fe nn no np ms b">name</code>，即<code class="fe nn no np ms b">sayHello</code>和<code class="fe nn no np ms b">code</code>，即<code class="fe nn no np ms b">console.log("Bye")</code>。函数本身可以被调用，导致内部代码运行。如前所述，函数是JavaScript中的对象。可以创建属性并为其赋值。</p><h2 id="01b3" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">函数语句和函数表达式</h2><p id="da3c" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">一个<code class="fe nn no np ms b">function statement</code>声明了一个函数。类似于用关键字<code class="fe nn no np ms b">var</code>、<code class="fe nn no np ms b">const</code>或<code class="fe nn no np ms b">let</code>声明变量，用关键字<code class="fe nn no np ms b">function</code>声明<code class="fe nn no np ms b">function statement</code>。让我们看一个例子:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6dca" class="mw lv iq ms b gy mx my l mz na">// function statement<br/>function example(){<br/>   return "sample"<br/>}</span></pre><p id="1eaa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">函数<code class="fe nn no np ms b">example</code>被声明并存放在内存中。直到函数本身被调用和执行，它才返回值。有了<code class="fe nn no np ms b">function statements</code>，他们就是<code class="fe nn no np ms b">hoisted</code>。</p><p id="26da" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe nn no np ms b">function expression</code>是一个动态创建并存储在变量中的函数。让我们看一个例子:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8cd7" class="mw lv iq ms b gy mx my l mz na">// function expression<br/>const example = function(){<br/>   return "sample"<br/>}</span><span id="6a09" class="mw lv iq ms b gy nm my l mz na">// OR arrow function</span><span id="7826" class="mw lv iq ms b gy nm my l mz na">const example = () =&gt; {<br/>   return "sample"<br/>}</span></pre><p id="4a03" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这两种情况下，我们都在内存中创建了一个函数。变量被分配给内存中的地址。但是，使用<code class="fe nn no np ms b">function expressions</code>，数值不是<code class="fe nn no np ms b">hoisted</code>。</p><p id="c00d" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">综上所述，两者的区别在于<code class="fe nn no np ms b">function statements</code>可以在代码到达之前调用，而<code class="fe nn no np ms b">function expressions</code>由于吊装必须首先到达。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="ded1" class="mw lv iq ms b gy mx my l mz na">// function statement</span><span id="cb5e" class="mw lv iq ms b gy nm my l mz na">sample(); // will execute<br/>function sample(){<br/>   console.log('hello!')<br/>}</span><span id="e1d8" class="mw lv iq ms b gy nm my l mz na">// function expression<br/>sample(); // sample will be undefined at this point. Error<br/>const sample = function(){<br/>   console.log('goodbye!')<br/>}</span></pre><p id="fdce" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<code class="fe nn no np ms b">function expressions</code>比<code class="fe nn no np ms b">function statements</code>有好处。它们可以用作<code class="fe nn no np ms b">closures</code>、其他函数的参数以及<code class="fe nn no np ms b">immediately invoked functions</code> (IIFEs)。</p><h1 id="31ef" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">通过值和引用</h1><p id="46d5" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">JavaScript中经常出现的一个话题涉及到<code class="fe nn no np ms b">by-value</code>和<code class="fe nn no np ms b">by-reference</code>。</p><h2 id="d837" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">按价值</h2><p id="8b78" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">在这两种情况下，都涉及到变量。假设我们有一个赋给原始值的变量:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="af69" class="mw lv iq ms b gy mx my l mz na">let a = "hello"</span></pre><p id="aaa1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">变量<code class="fe nn no np ms b">a</code>拥有原始值(在本例中是一个字符串)在内存中的地址位置。比方说我们的另一行代码:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="342f" class="mw lv iq ms b gy mx my l mz na">let b = a;</span></pre><p id="455d" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这种情况下，<code class="fe nn no np ms b">a</code>被声明为字符串，<code class="fe nn no np ms b">hello</code>。在JavaScript中，如果被赋值的值是一个原始值，<code class="fe nn no np ms b">b</code>实际上是指向内存中一个新的地址位置。<code class="fe nn no np ms b">hello</code>的值将存在于两个地址位置。</p><p id="8f68" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种方法被称为<code class="fe nn no np ms b">by-value</code>。我们通过复制值将一个值(<code class="fe nn no np ms b">b</code>)赋给另一个值(<code class="fe nn no np ms b">a</code>)。这两个变量变得相同，但是在内存中的两个不同的位置。让我们来看看，如果我们尝试更改重新赋值，会发生什么情况:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="105e" class="mw lv iq ms b gy mx my l mz na">//by value<br/>let a = 4;<br/>let b;<br/>b = a;</span><span id="c418" class="mw lv iq ms b gy nm my l mz na">a = 2;<br/>console.log(a) // 2<br/>console.log(b) // 4</span></pre><p id="6770" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于是原始类型，设置<code class="fe nn no np ms b">b = a</code>会在内存中为<code class="fe nn no np ms b">b</code>创建一个新位置，从<code class="fe nn no np ms b">a</code>复制值并设置为<code class="fe nn no np ms b">b</code>的值。因此，如果我们后来重新分配<code class="fe nn no np ms b">a</code>的值，它不会影响<code class="fe nn no np ms b">b</code>，因为它们在内存中是两个不同的位置。</p><h2 id="9436" class="mw lv iq bd lw nb nc dn ma nd ne dp me lh nf ng mg ll nh ni mi lp nj nk mk nl bi translated">通过引用</h2><p id="ad8a" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">至此，我们已经关注了原始值。如果我们给一个包含函数和数组的对象赋一个变量，我们在内存中仍然有一个地址位置，这个变量会知道这个对象在哪里。</p><p id="c25d" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是当我们试图将<code class="fe nn no np ms b">b</code>赋值给<code class="fe nn no np ms b">a</code>时，会发生一些不同的事情。让我们看另一个例子，变量相同，但赋值不同。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="52a5" class="mw lv iq ms b gy mx my l mz na">let a = {<br/>  "property1": "sample",<br/>  "property2": "example"<br/>}</span><span id="c50c" class="mw lv iq ms b gy nm my l mz na">let b = a;</span></pre><p id="03fd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个例子中，我们将变量<code class="fe nn no np ms b">a</code>分配给一个对象。类似于前面的例子，我们将<code class="fe nn no np ms b">b</code>赋值给<code class="fe nn no np ms b">a</code>，它指向一个包含值(对象)的地址位置。与原始值不同，<code class="fe nn no np ms b">b</code>不是在内存中获取新的地址位置，而是简单地指向内存中<code class="fe nn no np ms b">a</code>所指向的相同位置。不会创建新对象。这同样适用于函数和数组。</p><p id="c7d2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这样，<code class="fe nn no np ms b">a</code>和<code class="fe nn no np ms b">b</code>都有相同的值。这叫做<code class="fe nn no np ms b">by-reference</code>。当将所有对象设置为彼此相等时，或者作为参数传递给函数时，所有对象都会相互作用<code class="fe nn no np ms b">by-reference</code>。如果我们试图改变变量<code class="fe nn no np ms b">b</code>的属性，最终也会影响变量<code class="fe nn no np ms b">a</code>，因为它们指向相同的地址位置。让我们来看看:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="fc11" class="mw lv iq ms b gy mx my l mz na">// by reference (all objects including functions and arrays)<br/>let c = {"favQuote": "hello"}<br/>let d;</span><span id="ec74" class="mw lv iq ms b gy nm my l mz na">d = c;<br/>c.favQuote = "goodbye"</span><span id="8f3c" class="mw lv iq ms b gy nm my l mz na">console.log(c) // {"favQuote": "goodbye"}<br/>console.log(d) // {"favQuote": "goodbye"}</span></pre><p id="133a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当将<code class="fe nn no np ms b">c</code>设置为对象时，在存储器中创建一个地址位置。当将<code class="fe nn no np ms b">d</code>赋值给<code class="fe nn no np ms b">c</code>时，等号运算符注意到它是一个对象，而不是设置一个新的地址位置，而是指向同一个地址。</p><p id="0a18" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如上所述，如果我们试图改变一个变量的属性，它会对另一个变量产生影响。如果多个变量指向同一个对象，那么所有的变量都会被改变。</p><p id="29b3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">同样的概念也适用于将对象作为参数传递给函数。如果对象在功能代码块中改变，它将改变所有变量。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8946" class="mw lv iq ms b gy mx my l mz na">// by reference (even as parameters)</span><span id="15f9" class="mw lv iq ms b gy nm my l mz na">function changeGreeting(obj){ </span><span id="2fc2" class="mw lv iq ms b gy nm my l mz na">   obj.favQuote = "hi"</span><span id="a6f8" class="mw lv iq ms b gy nm my l mz na">}</span><span id="a83c" class="mw lv iq ms b gy nm my l mz na">changeGreeting(d) //all values change<br/>console.log(c) // {"favQuote": "hi"}<br/>console.log(d) // {"favQuote": "hi"}</span></pre><p id="3aff" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果这是一个问题，那么必须创建一个新的对象来确保在内存中有一个新的位置。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1031" class="mw lv iq ms b gy mx my l mz na">let c = {"favQuote": "hello"}<br/>let d = {"favQuote": "hello"}</span><span id="d60a" class="mw lv iq ms b gy nm my l mz na">d.favQuote = "goodbye"</span><span id="bc73" class="mw lv iq ms b gy nm my l mz na">console.log(c) // {"favQuote": "hello"}<br/>console.log(d) // {"favQuote": "goodbye"}</span></pre><p id="dadd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这样，等号运算符会看到开始的花括号，并意识到该对象不是内存中预先存在的地址位置。这是一个全新的物体创造了飞行。</p><h1 id="1508" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">对象、函数和` this '</h1><p id="cd11" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">在我的博客<a class="ae oe" href="https://medium.com/javascript-in-plain-english/javascript-basics-execution-context-bd79ede1ccdd" rel="noopener"> JavaScript基础:执行上下文</a>中，我讨论了<code class="fe nn no np ms b">execution context</code>的概念，它是在JavaScript中调用函数时创建的。创建时，<code class="fe nn no np ms b">execution context</code>被添加到所谓的<code class="fe nn no np ms b">execution stack</code>之上，后者跟踪并管理多个<code class="fe nn no np ms b">execution contexts</code>。</p><p id="8c62" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">把<code class="fe nn no np ms b">execution context</code>想象成关注特定函数对象的代码。每个<code class="fe nn no np ms b">execution context</code>都有一个<code class="fe nn no np ms b">variable environment</code>，其中在函数内部创建的变量有一个对<code class="fe nn no np ms b">outer environment</code>的引用，这意味着它可以访问在其代码范围之外定义的变量。</p><p id="41b1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">每次创建一个<code class="fe nn no np ms b">execution context</code>时，它都会给我们一个变量<code class="fe nn no np ms b">this</code>，并且它会根据函数的调用方式指向不同的对象。这个概念往往是JavaScript中容易混淆的部分。一旦JavaScript代码开始运行，变量<code class="fe nn no np ms b">this</code>立即可用。</p><p id="83de" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦运行了JavaScript代码，我们就有了<code class="fe nn no np ms b">global execution context</code>。在这一层，<code class="fe nn no np ms b">this</code>变量指向<code class="fe nn no np ms b">window</code>对象(用于浏览器，但<code class="fe nn no np ms b">global</code>在节点上)。当一个函数在全局级别被调用时，代码块内部的<code class="fe nn no np ms b">this</code>变量仍然指向<code class="fe nn no np ms b">window</code>对象。让我们探索一个例子:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9702" class="mw lv iq ms b gy mx my l mz na">let a = 'filler';</span><span id="011d" class="mw lv iq ms b gy nm my l mz na">function callMe(){<br/>   console.log(this); // window object<br/>}</span><span id="77b4" class="mw lv iq ms b gy nm my l mz na">console.log(this); // window object<br/>callMe();</span></pre><p id="8ffb" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">提醒一下，在对象文字中，作为函数的属性值被称为<code class="fe nn no np ms b">methods</code>。在函数是附加到对象的方法的情况下，<code class="fe nn no np ms b">this</code>关键字成为包含该方法的对象。让我们想象一下:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="800f" class="mw lv iq ms b gy mx my l mz na">const obj = {<br/>   name: "Bob"<br/>   sample: function(){ <br/>      console.log(this) // {name: "Bob", sample: f()}  <br/>   }<br/>}</span><span id="a362" class="mw lv iq ms b gy nm my l mz na">obj.sample()</span></pre><p id="fd27" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了有所帮助，<code class="fe nn no np ms b">this</code>指向调用函数的地方或者点符号左边的地方。在这种情况下，<code class="fe nn no np ms b">obj</code>是调用函数的部分，并成为上下文中的<code class="fe nn no np ms b">this</code>关键字。然而，如果这个方法中有另一个函数，事情就会变得棘手和混乱。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="08f1" class="mw lv iq ms b gy mx my l mz na">const obj = {<br/>   name: "Bob",<br/>   sample: function(){ <br/>      let setName = function(newName){<br/>         console.log(this) // this actually points to the window<br/>         this.name = newName; <br/>      } <br/>      setName("Jack");<br/>   }<br/>}</span><span id="43a8" class="mw lv iq ms b gy nm my l mz na">obj.sample()</span></pre><p id="ec4f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe nn no np ms b">setName</code>函数表达式中的<code class="fe nn no np ms b">this</code>实际上引用了<code class="fe nn no np ms b">window</code>对象，但我们期望<code class="fe nn no np ms b">this</code>引用<code class="fe nn no np ms b">obj</code>。这是一个关于对象方法中函数语法的小错误。为了解决这个问题，我们可以使用一个变量来存储引用。让我们添加一行额外的代码:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8720" class="mw lv iq ms b gy mx my l mz na">const obj = {<br/>   name: "Bob",<br/>   sample: function(){ <br/>      let self = this;<br/>      let setName = function(newName){<br/>         console.log(self) // self references the obj<br/>         self.name = newName; <br/>      } <br/>      setName("Jack");<br/>   }<br/>}</span><span id="2930" class="mw lv iq ms b gy nm my l mz na">obj.sample();</span></pre><p id="4dc4" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe nn no np ms b">setName</code>函数表达式内部，没有名为<code class="fe nn no np ms b">self</code>的变量。所以它在上下文之外寻找变量。它发现<code class="fe nn no np ms b">self</code>在上下文中引用的<code class="fe nn no np ms b">this</code>恰好是<code class="fe nn no np ms b">obj</code>。修复和<code class="fe nn no np ms b">this</code>的概念可能需要一点时间来完全掌握和理解。</p><h1 id="ff84" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="2e84" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们已经讨论了JavaScript中对象和函数的一些基本概念。理解这些概念有助于更高级的主题，如类和继承。</p><p id="a85c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>