<html>
<head>
<title>Why You Should Stop using Line-Reader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该停止使用行阅读器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-line-reader-1ad452f68155?source=collection_archive---------11-----------------------#2021-04-20">https://javascript.plainenglish.io/stop-using-line-reader-1ad452f68155?source=collection_archive---------11-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6bec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何仅使用核心Node.js功能异步地逐行读取文件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc666518df28df79bc94034f3f3dbe90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kJoCovtPJuAZUBpi"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="69ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我浪费了几个小时的时间试图用Node.js读取另一个文件的内容。</p><h2 id="76d6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">背景</h2><p id="1ca0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在TripActions，我们使用<a class="ae kv" href="https://lokalise.com/" rel="noopener ugc nofollow" target="_blank">本地化</a>来翻译(也就是本地化)我们的应用。如果您以前从未本地化过应用程序，那么主要的工作是用变量替换所有静态文本，将文本放在基于键值对的文件中。我们在后端使用Java，所以我们使用<code class="fe mq mr ms mt b">.properties</code>文件。</p><p id="f56f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你的应用程序超过300个键值对，这个文件就会变得越来越难以管理，这就为复制或丢失键打开了方便之门。这带来了一个问题，尤其是当你管理多种不同的语言，每种语言都有自己的<code class="fe mq mr ms mt b">.properties</code>文件，并且你继续构建应用程序，添加更多的键并更新现有的键。</p><p id="bd95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我一直在开发工具来使这个过程变得更容易，自动完成寻找重复或丢失钥匙的过程。</p><h2 id="c233" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">问题</h2><p id="6ae2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们最近遇到的一个问题是该工具在检测未使用的键时过于热心，导致它们被删除。调查表明，这是因为这些键是动态生成的，在运行时将一个字符串键与一个变量连接起来。这意味着现有的工具无法将这些动态变量与密钥文件相匹配。</p><h2 id="8328" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">过程</h2><p id="c371" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">借用我在ES-lint中看到的语法，我决定在动态变量之前添加一个注释，表示预期的键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The note before the dynamic variable shows all expected string values for web.email.TRAVEL_RESTRICTIONS_NOTIFICATIONS_EMAIL.common.notifications</figcaption></figure><p id="68ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个挑战更加困难——遍历文件，检查每个文件的注释，然后返回变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ac63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是拿到文件。我使用了与<a class="ae kv" href="https://www.npmjs.com/package/glob" rel="noopener ugc nofollow" target="_blank"> Glob </a>配对的<code class="fe mq mr ms mt b">fs.readFile</code>，允许我创建通配符路径，获取foundation src目录(我的电子邮件模板存储在那里)中的所有HTML文件。</p><p id="00b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的<code class="fe mq mr ms mt b">getDynamicKeys</code>函数被设置为构建并返回一个数组，这就是我使用reduce的原因(我喜欢Reduce)。累加器开始是一个空数组。对于每个文件，我们等待累加器解析并检查文件是否包含(<code class="fe mq mr ms mt b">includes</code>)我们的<code class="fe mq mr ms mt b">@deduper-dynamic-variable</code>字符串。</p><p id="2d68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从文件中取出字符串是我觉得最麻烦的部分。我试了试，但一点也没用。我尝试的另一种方法是使用substring和<code class="fe mq mr ms mt b">indexOf</code>来获取注释的开始和结束，然后返回它。它确实感觉超级笨重，而且对于一个文件中有许多注释的情况来说，伸缩性不好。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我决定稍微旋转一下，一行一行地遍历这些文件。我知道使用Node的<code class="fe mq mr ms mt b">readFileSync</code>方法和使用<code class="fe mq mr ms mt b">file.split(/\r?\n/)</code>分割文件对于大文件来说是非常占用内存的，所以我需要一个替代方法。</p><p id="18d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<a class="ae kv" href="https://www.npmjs.com/package/line-reader" rel="noopener ugc nofollow" target="_blank">行阅读器</a>。这个包允许你一行一行的循环代码。它的问题是，尽管获得了约31，000的周下载量，但自2016年以来(撰写本文时的5年)一直没有更新。它本身不支持承诺，严重依赖回调(你可以连接<a class="ae kv" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>，但这是自节点10 中承诺的<a class="ae kv" href="https://github.com/petkaantonov/bluebird#note" rel="noopener ugc nofollow" target="_blank">优化以来的另一个过时且大部分多余的项目)。</a></p><p id="a3c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我试着按照说明编写自己的承诺实现<a class="ae kv" href="https://github.com/nickewing/line-reader#promises" rel="noopener ugc nofollow" target="_blank">，但是承诺没有解决，并且不能触发——这是一个已知的问题</a>。</p><p id="3713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我在Node.js 的帖子中看到了<a class="mw mx ep" href="https://medium.com/u/833553eed52?source=post_page-----1ad452f68155--------------------------------" rel="noopener" target="_blank"> Atta </a>的<a class="ae kv" href="https://attacomsian.com/blog/reading-a-file-line-by-line-in-nodejs" rel="noopener ugc nofollow" target="_blank">如何逐行读取文件。</a></p><h2 id="6b94" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">读取线FTW</h2><p id="ff81" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Readline 是Node.js中的一个原生模块，专门用于处理像我们这样的问题。我们将文件通过管道传输到读取流中，然后监听事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个行事件，我们检查该行是否包含<code class="fe mq mr ms mt b">@deduper-dynamic-variable</code>字符串。如果是，我们开始记录并将一个空数组推到<code class="fe mq mr ms mt b">deduperStrings</code>数组的末尾。然后我们捕获下一行，直到这一行包含结束注释<code class="fe mq mr ms mt b">--&gt;</code>。我们对整个文件都这样做，在关闭时，我们用<code class="fe mq mr ms mt b">deduperStrings</code>数组解析承诺。</p><p id="cf3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个概念证明，并不是完全可靠的——例如，可能会有缺少结束注释的问题。</p><h2 id="ceaf" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">将这一切结合在一起</h2><p id="d4e8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将<code class="fe mq mr ms mt b">getDynamicKeysStrings</code>插入我们现有的代码简单易懂，主要使用核心Node.js模块(除了glob)，并且易于编写测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这表明您不需要使用行阅读器包。Readline 提供了相同的功能，也是一个核心节点模块，可以很容易地用承诺包装。对我来说，这是显而易见的。</p><p id="17be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读本文。</p><p id="1529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="my">大卫</em> </strong></p><p id="2651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="my">高级前端开发者@</em></strong><a class="ae kv" href="https://tripactions.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="my">trip actions</em></strong></a><strong class="ky ir"><em class="my">(通常是</em> </strong> <a class="ae kv" href="https://grnh.se/cbeb241d1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="my">招聘</em> </strong> </a> <strong class="ky ir"> <em class="my">！)</em> </strong></p><p id="c036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="my">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="my">plain English . io</em></a></p></div></div>    
</body>
</html>