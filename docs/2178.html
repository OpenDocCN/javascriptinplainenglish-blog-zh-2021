<html>
<head>
<title>LeetCode: Sum Deepest Leaves</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode:夏天最深的叶子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-sum-deepest-leaves-c439ee67cac8?source=collection_archive---------15-----------------------#2021-05-07">https://javascript.plainenglish.io/leetcode-sum-deepest-leaves-c439ee67cac8?source=collection_archive---------15-----------------------#2021-05-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8116" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用层次顺序遍历的JavaScript解决方案</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7414e31ecffd5d76dc03bf63c70e57c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pTYylvkmMuGgpoiuwI9Cw.jpeg"/></div></div></figure><p id="63be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">成为算法大师的秘诀是什么？嗯，我不知道，我甚至还没有完成一个LeetCode难题。但是我会告诉你我在这方面做得更好的策略:<strong class="kq io">看到存在的每一个问题</strong>。</p><p id="d985" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，那显然不可能。但是越看越好！此外，你并不真的需要看到每一个问题，而是每一种类型的问题。你听说过“没有原创的想法”这句话吗？显然，马克·吐温说过。我不得不谷歌一下。但这也是算法背后的想法。它们都使用其他算法中的某种概念。从太阳底下没有新东西的想法中得到安慰。一旦你解决了一个问题，你实际上可能已经解决了几个。</p><p id="f6f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是我最近解决的一个Leetcode算法。我以前从未见过这个问题，但我很快就解决了。只需要写一两行新代码。都是因为我之前见过类似的东西。</p><h1 id="9bca" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">问题:最深的叶子和</h1><p id="a356" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这是一个LeetCode中难度的问题。给定二叉树的<code class="fe mh mi mj mk b">root</code>，返回其最深叶子的值的总和<em class="ml">。例如，给定二叉树:<code class="fe mh mi mj mk b">[1,2,3,4,5,null,6,7,null,null,null,null,8]</code>返回的是<code class="fe mh mi mj mk b">15</code></em></p><pre class="kd ke kf kg gt mm mk mn mo aw mp bi"><span id="5002" class="mq ll in mk b gy mr ms l mt mu">      1<br/>     / \<br/>    2   3<br/>   / \   \<br/>  4   5   6<br/> /         \<br/>7           8</span></pre><p id="3a83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面显示了二叉树节点的定义:</p><pre class="kd ke kf kg gt mm mk mn mo aw mp bi"><span id="4d7d" class="mq ll in mk b gy mr ms l mt mu">function TreeNode(val, left, right) {<br/>    this.val = (val===undefined ? 0 : val)<br/>    this.left = (left===undefined ? null : left)<br/>    this.right = (right===undefined ? null : right)<br/>}</span></pre><h2 id="7b03" class="mq ll in bd lm mv mw dn lq mx my dp lu kx mz na lw lb nb nc ly lf nd ne ma nf bi translated">我的思考过程:</h2><p id="fd41" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">于是我开始思考我想怎么解决这个问题。我看着这棵树，意识到，如果这棵树可以按层次分解，我只对树的最底层感兴趣。</p><p id="1c1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我的思绪立刻回到了我已经解决的过去的问题。我记得做过一道题，我必须按层次顺序打印出树的节点。这正是我所需要的。一种逐层遍历树的方法。然后，我可以计算最低层的总和，并返回该值。</p><p id="c3e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我用我的解决方案来解决之前的问题，稍微调整一下，瞧！我不费吹灰之力就找到了解决方案。我在重复利用我已经完成的工作。重用子问题的解决方案。</p><p id="b7e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有一个我写的关于二叉树层次顺序遍历的博客的链接</p><h2 id="e6b4" class="mq ll in bd lm mv mw dn lq mx my dp lu kx mz na lw lb nb nc ly lf nd ne ma nf bi translated">BFS算法:</h2><ol class=""><li id="9dc1" class="nh ni in kq b kr mc ku md kx nj lb nk lf nl lj nm nn no np bi translated">首先，让我们为BFS初始化我们的队列(根节点在里面),并初始化<strong class="kq io"> sum </strong>。</li><li id="875e" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nm nn no np bi translated">在while循环中(一直运行到队列为空)，我们定义了一个<strong class="kq io"> for循环</strong>。for循环将在最后一级末尾对队列中的每个元素运行。这意味着我们将增加“I ”,直到它达到队列长度。</li><li id="9cdd" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nm nn no np bi translated">在for循环之前，一定要将每个级别的总和设置为零，以重新初始化总和。</li><li id="ce2e" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nm nn no np bi translated">在for循环中，从队列顶部删除一个节点，并将其值添加到级别sum中。如果有孩子，将他们添加到队列中。</li><li id="be3c" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nm nn no np bi translated">一旦一个级别的所有节点都被访问过(for循环的结尾)，我们就简单地移动到树的下一个级别(如果有的话)。继续步骤，直到队列为空。</li><li id="7299" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nm nn no np bi translated">在函数结束时，只需返回sum值，因为这是在最低级别计算的。</li></ol><h2 id="318e" class="mq ll in bd lm mv mw dn lq mx my dp lu kx mz na lw lb nb nc ly lf nd ne ma nf bi translated">JavaScript代码解决方案:</h2><pre class="kd ke kf kg gt mm mk mn mo aw mp bi"><span id="962a" class="mq ll in mk b gy mr ms l mt mu">var deepestLeavesSum = function(root) {</span><span id="a393" class="mq ll in mk b gy nv ms l mt mu">   let queue = [root]<br/>   let sum=0<br/>   while (queue.length != 0){<br/>      sum =0<br/>      const n = queue.length<br/>      <br/>      for (let i = 0; i &lt; n; i++){<br/>         let curr = queue.pop()<br/>         sum+=curr.val<br/>         curr.left &amp;&amp; queue.unshift(curr.left)<br/>         curr.right &amp;&amp; queue.unshift(curr.right)<br/>      }<br/>   }<br/>   return sum</span><span id="b556" class="mq ll in mk b gy nv ms l mt mu">};</span></pre><p id="fee1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我在LeetCode上提交这段代码时，我得到了以下结果:</p><ul class=""><li id="5666" class="nh ni in kq b kr ks ku kv kx nw lb nx lf ny lj nz nn no np bi translated">运行时间:112毫秒，比49.46%的JavaScript在线提交速度快</li><li id="97ed" class="nh ni in kq b kr nq ku nr kx ns lb nt lf nu lj nz nn no np bi translated"><strong class="kq io">内存</strong> : 48.6 MB，不到JavaScript在线提交量的54.50%</li></ul><h1 id="8726" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">时空复杂性分析；</h1><p id="9bbd" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">由于每个节点至少被访问一次，时间复杂度为O(n)。空间复杂度也是O(n ),因为在最坏的情况下，队列可以包含所有的叶节点。</p><h1 id="f62a" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">参考资料:</h1><div class="oa ob gp gr oc od"><a href="https://leetcode.com/problems/deepest-leaves-sum/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">最深的叶子夏天- LeetCode</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">leetcode.com</p></div></div><div class="om l"><div class="on l oo op oq om or km od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://medium.com/swlh/binary-tree-level-order-traversal-a12df61a85d0" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">二叉树层次顺序遍历</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">LeetCode问题的Javascript解决方案</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="os l oo op oq om or km od"/></div></div></a></div><p id="8bc8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ml">更多内容尽在</em><a class="ae ng" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="ml">plain English . io</em></strong></a></p></div></div>    
</body>
</html>