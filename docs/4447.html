<html>
<head>
<title>Partial Applications in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的部分应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/partial-applications-in-javascript-4ee3c2a47cfb?source=collection_archive---------14-----------------------#2021-09-04">https://javascript.plainenglish.io/partial-applications-in-javascript-4ee3c2a47cfb?source=collection_archive---------14-----------------------#2021-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/f60fce8820de8dc321d3b943c68cbcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*SK9aPGRVarmGufTg7X99jA.jpeg"/></div></figure><div class=""/><p id="e5f1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">随着Redux JavaScript库、Reason语法和工具链的引入，循环库函数式编程在JavaScript中变得越来越重要。</p><p id="f899" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">函数式编程简单地描述了通过应用和组合函数构建的程序。</p><p id="6a96" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">源于函数式编程的一个重要概念是<em class="kp">部分应用</em>，其中值被固定到函数的一些参数，而函数没有被完全评估。</p><p id="b3c7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">局部应用是由<em class="kp">到</em>一个函数完成的事情；当一个函数被调用时，它的一部分是从外部应用的——这个功能不是内置在函数本身中的。按照这个逻辑，任何接受参数的函数都可以部分应用。</p><h2 id="f6dc" class="kq kr iu bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">部分应用示例</h2><p id="0a04" class="pw-post-body-paragraph jr js iu jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">如同大多数(如果不是全部的话)编程一样，部分应用程序在上下文中更容易理解。下面我们有一个简单的JavaScript函数:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cf49" class="kq kr iu lt b gy lx ly l lz ma">const sumFiveNumbers = (a, b, c, d, e) =&gt; a + b + c + d + e;</span></pre><p id="5d7b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通常，要调用这个函数，我们需要提供五个参数:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2dea" class="kq kr iu lt b gy lx ly l lz ma">const resultOne = sumFiveNumbers(3, 4, 5, 10, 1); </span><span id="6504" class="kq kr iu lt b gy mb ly l lz ma">console.log(resultOne); //23</span></pre><p id="8216" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如上所示，该控制台记录功能的评估结果为<strong class="jt iv"> 23 </strong>。现在，<strong class="jt iv"> sumFiveNumbers </strong>的一个部分应用示例可以是:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e909" class="kq kr iu lt b gy lx ly l lz ma">const partiallyAppliedSumFiveNumbers = sumFiveNumbers.bind(null, 6, 4); </span></pre><p id="4be1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt iv"> sumFiveNumbers </strong>期望五个参数，但是借助<strong class="jt iv">。bind() </strong>我们能够在只提供两个(或者比预期的五个少的任意数量的参数)参数的情况下调用这个相同的函数。这里<strong class="jt iv">。bind() </strong>允许我们传入第一个参数(<strong class="jt iv"> null </strong>)作为返回函数的上下文，然后传入这个返回函数的参数列表的值(<strong class="jt iv"> 6 </strong>和<strong class="jt iv"> 4 </strong>)。</p><p id="90da" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以在这个例子中，<strong class="jt iv"> 6 </strong>是分配给<strong class="jt iv"> a </strong>的值，<strong class="jt iv"> 4 </strong>是分配给<strong class="jt iv"> b </strong>的值(属于<strong class="jt iv"> sumFiveNumbers </strong>函数)。</p><p id="a318" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们正在围绕这些参数创建一个<em class="kp">闭包</em>，并返回一个已经知道这些值的新函数，并且正在等待另外3个参数:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f5cb" class="kq kr iu lt b gy lx ly l lz ma">const resultTwo = partiallyAppliedSumFiveNumbers(2, 4, 1);</span><span id="955c" class="kq kr iu lt b gy mb ly l lz ma">console.log(resultTwo); //17</span></pre><p id="c281" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在第二次调用<strong class="jt iv">partiallyAppliedSumFiveNumbers</strong>时，我们提供剩余的三个参数值，允许<strong class="jt iv"> sumFiveNumbers </strong>计算并返回结果(<strong class="jt iv"> 17 </strong>)。</p><p id="2d3f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要考虑的另一个概念是，部分应用的功能可以部分应用多次。例如，在本例中，我们可以用一个(或两个)参数而不是剩余的三个参数来调用<strong class="jt iv">partiallyAppliedSumFiveNumbers</strong>，在这种情况下，函数在计算之前仍然会等待剩余的参数——</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="53a4" class="kq kr iu lt b gy lx ly l lz ma">const anotherPartiallyAppliedSumFiveNumbers = partiallyAppliedSumFiveNumbers.bind(null, 2); </span></pre><p id="f698" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上面我们再次<em class="kp">将返回函数的上下文</em>绑定到<strong class="jt iv"> null </strong>并提供了<strong class="jt iv"> 2 </strong>的单个参数。现在<strong class="jt iv"> sumFiveNumbers </strong>函数正在等待另外两个参数来评估。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="faec" class="kq kr iu lt b gy lx ly l lz ma">const resultThree = anotherPartiallyAppliedSumFiveNumbers(4, 1); </span><span id="9f9d" class="kq kr iu lt b gy mb ly l lz ma">console.log(resultThree); //17</span></pre><p id="2fa9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们现在已经提供了<strong class="jt iv"> sumFiveNumbers </strong>所需要的所有参数，并且该函数能够进行求值，从而得到<strong class="jt iv"> 17 </strong>的和。</p><h2 id="7630" class="kq kr iu bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">闭包——局部应用的一个基本概念</h2><p id="db67" class="pw-post-body-paragraph jr js iu jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">部分应用程序由于闭包的概念而工作。</p><p id="690d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">内部函数(<strong class="jt iv">partial appliedsumfiftnumbers</strong>和<strong class="jt iv">other partial appliedsumfiftnumbers</strong>)可以访问父函数(<strong class="jt iv">sum fiftnumbers</strong>用于两个局部函数，以及<strong class="jt iv">partial appliedsumfiftnumbers</strong>用于<strong class="jt iv">other partial appliedsumfiftnumbers</strong>)的所有参数值，即使在父函数返回之后也是如此。</p><p id="1547" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是一个<em class="kp">闭包— </em>每当一个函数返回另一个函数时，这个返回的函数就可以访问在父函数范围内初始化的任何变量。</p><h2 id="1635" class="kq kr iu bd ks kt ku dn kv kw kx dp ky kc kz la lb kg lc ld le kk lf lg lh li bi translated">结论</h2><p id="cb96" class="pw-post-body-paragraph jr js iu jt b ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko ig bi translated">部分应用程序允许您修复函数的参数——提供从更一般的函数中派生具有特定行为的新函数的能力。</p></div></div>    
</body>
</html>