<html>
<head>
<title>HTML, CSS Parsing and Web Page Rendering Process in Browser | Critical Rendering Path</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器中的HTML、CSS解析和网页渲染过程|关键渲染路径</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-performance-understanding-critical-rendering-path-72283caefc1f?source=collection_archive---------2-----------------------#2021-12-13">https://javascript.plainenglish.io/web-performance-understanding-critical-rendering-path-72283caefc1f?source=collection_archive---------2-----------------------#2021-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="125d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">关键呈现路径</em>是浏览器为了在屏幕上呈现网页而执行的一系列动作或步骤。</h2></div></div><div class="ab cl kd ke hr kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ig ih ii ij ik"><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/69d7af6bc59dce49ca4a0825633befc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mwu7IEk6YfUznsAMzTnzLg.jpeg"/></div></div></figure></div><div class="ab cl kd ke hr kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ig ih ii ij ik"><p id="7b0a" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls">关键渲染路径</em>是浏览器为了在屏幕上渲染网页而执行的一系列动作或步骤。这些步骤包括从服务器获取资源(HTML、CSS、JavaScript)，解析接收到的HTML以创建<em class="ls"> DOM </em>，解析CSS以创建<em class="ls"> CSSOM </em>，创建由DOM和CSSOM组合而成的渲染树，计算所有元素的位置和尺寸(<em class="ls">布局</em>，最后P <em class="ls">在屏幕上绘制实际的</em>像素。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lt"><img src="../Images/77d7000520cf14d42e1dcb38ec5d8ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejR8TwuRBqTRDKmAJeltig.png"/></div></div></figure><p id="3765" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">我们将使用下面的例子来理解整个过程</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lw"><img src="../Images/ce784f808133efae5ce24cf821d9612d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nv13EEqauZsCBNLOm3v8iA.jpeg"/></div></div></figure><h2 id="a555" class="lx ly in bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">文档对象模型</h2><p id="f924" class="pw-post-body-paragraph kw kx in ky b kz mq jo lb lc mr jr le lf ms lh li lj mt ll lm ln mu lp lq lr ig bi translated">在从服务器获取HTML之后，浏览器开始解析它并创建DOM，这个过程本身被分成需要执行的许多进一步的步骤，以便创建DOM树，这些步骤包括:将接收到的HTML字节转换成令牌，使用这些令牌创建节点，然后连接这些节点以创建DOM树。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mv"><img src="../Images/378ce9046bce74b2d2154ffcf7795714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5LW47Da1EboD1fzq9V8KQ.png"/></div></div></figure><p id="52da" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="ky io">创建令牌</strong></p><p id="52ea" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">浏览器开始逐字符读取获取的HTML，并在遇到HTML标记时创建一个令牌。有两种类型的标记，<em class="ls"> StartTag </em>标记和<em class="ls"> EndDate </em>标记，顾名思义<em class="ls"> StartTag </em>标记是在遇到HTML开始(开始)标记时创建的，而<em class="ls"> EndTag </em>标记是在遇到任何HTML结束(结束)标记时创建的。</p><p id="8a2b" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">解析上面示例中显示的HTML后，将创建以下标记</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mw"><img src="../Images/b12636d5dbfa9cc8bb1470e2f9cee57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vY-a8iR_hS052IYPazyk1A.png"/></div></div></figure><p id="135b" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="ky io">创建节点和DOM树</strong></p><p id="18af" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">第一步中创建的标记用于为每个HTML标记创建节点。节点包含特定标记的完整信息，如属性、类等。</p><p id="46c5" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">令牌的顺序也非常重要，因为它用于识别节点之间的关系，即一个节点是否是另一个节点的子节点。一旦解析了所有的标签并创建了节点，下一步就是通过使用它们的序列识别它们之间的关系来连接这些节点。</p><p id="8529" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">在上一步创建的令牌中，<strong class="ky io"> span </strong>的<em class="ls"> StartTag </em>和<em class="ls"> EndTag </em>位于<em class="ls"> StartTag </em>和<strong class="ky io"> div </strong>的<em class="ls"> EndTag </em>之间，这意味着<em class="ls"> span </em>节点将是DOM树中<em class="ls"> div </em>节点的子节点，如下所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mx"><img src="../Images/7b167f7306a97313a54de38ec6923006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ha-wC-ugBBJzY-ErTLCCQ.png"/></div></div></figure><h2 id="914e" class="lx ly in bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">CSS对象模型</h2><p id="b045" class="pw-post-body-paragraph kw kx in ky b kz mq jo lb lc mr jr le lf ms lh li lj mt ll lm ln mu lp lq lr ig bi translated">解析HTML时，如果浏览器遇到任何引用样式表的样式标签或链接标签，它就开始获取(在外部CSS的情况下)并解析这些样式，然后将它们转换为包含所有页面样式信息的CSS对象模型。</p><p id="e78a" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">CSSOM的创建过程类似于DOM的创建，也就是说，CSS字节首先被转换成字符，然后字符被转换成令牌，然后是节点，最后我们在链接这些节点后得到CSSOM。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi my"><img src="../Images/bf51005649512aa5fc29c561ae07f7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPIErFTDxnYRT5oHC8oH1A.png"/></div></div></figure><p id="ff63" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">父节点中的每个样式也应用于子节点，正如您在上面的示例中看到的，span节点具有从父div节点继承的font-size属性。</p><h2 id="8ed0" class="lx ly in bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">渲染树</h2><p id="9ff2" class="pw-post-body-paragraph kw kx in ky b kz mq jo lb lc mr jr le lf ms lh li lj mt ll lm ln mu lp lq lr ig bi translated">渲染树是DOM和CSSOM的结合。为了创建渲染树，浏览器开始遍历DOM并在CSSOM中寻找匹配的样式，然后将这两者结合起来创建一个包含内容和样式信息的渲染树节点。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mz"><img src="../Images/1539cf42ab71507c29b5e8369acb706b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_RwwV5GmXiTYnBfgd7c2Q.png"/></div></div></figure><p id="c98d" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">渲染树仅包含在屏幕上可见的节点，例如，meta、script、link等标签的节点，或者使用CSS样式隐藏的节点(如display: none)不包括在内。</p><h2 id="1989" class="lx ly in bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">布局</h2><p id="56ab" class="pw-post-body-paragraph kw kx in ky b kz mq jo lb lc mr jr le lf ms lh li lj mt ll lm ln mu lp lq lr ig bi translated">在这一步中，渲染树用于查找视口中每个元素的尺寸和位置。在上面的例子中，如果我们给<em class="ls"> div，</em>加上50%的宽度，那么div的最终计算宽度将是body标签宽度的50%。百分比值根据视口大小转换为像素。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi na"><img src="../Images/7246c5c806fff88c1c4d2202a1c7106c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qH1NprBo4q29jYBPtHGLEQ.png"/></div></div></figure><h2 id="8cb3" class="lx ly in bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">颜料</h2><p id="39a0" class="pw-post-body-paragraph kw kx in ky b kz mq jo lb lc mr jr le lf ms lh li lj mt ll lm ln mu lp lq lr ig bi translated">现在我们有了每个元素的所有内容、样式、尺寸和位置，是时候进行最后的绘制步骤了，该步骤将渲染树中的每个节点渲染到屏幕上。</p><p id="15f9" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">现在你知道了。感谢您的阅读。</p><p id="d267" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><em class="ls">更多内容看</em> <a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky io"> <em class="ls">说白了。报名参加我们的</em> <a class="ae nb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky io"> <em class="ls">免费周报</em> </strong> </a> <em class="ls">。在我们的</em> <a class="ae nb" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky io"> <em class="ls">社区获得独家访问写作机会和建议</em> </strong> </a> <em class="ls">。</em></strong></a></p></div></div>    
</body>
</html>