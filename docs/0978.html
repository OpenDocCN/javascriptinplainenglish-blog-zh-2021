<html>
<head>
<title>The Top 6 Javascript Operators to Code Faster and Cleaner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码更快更干净的6大Javascript操作符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-top-6-javascript-operators-to-code-faster-and-cleaner-3cb13cc8c6f?source=collection_archive---------9-----------------------#2021-03-01">https://javascript.plainenglish.io/the-top-6-javascript-operators-to-code-faster-and-cleaner-3cb13cc8c6f?source=collection_archive---------9-----------------------#2021-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6854" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最新的JS操作符被设计成允许快速、干净的编码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1196a76281dc5fb1eb61ffc41ec25424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ot20AStoUWNa_nf8n93EXw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image courtesy <a class="ae kv" href="https://www.pexels.com/photo/air-craft-during-day-time-40907/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="2383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Javascript在过去几年里发展很快。旧的冗长操作符和做事的技巧正在被短小精悍的操作符所取代，短小精悍的操作符可以用更少的代码完成同样的事情。</p><p id="9cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新的语法不仅仅是糖衣，它使你的代码更少出错，更简洁。这些运算符和语法将成为所有人使用的默认设置。</p><p id="1432" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是能让你的代码大放异彩的6大操作符。</p><h1 id="d131" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.可选链接(？。)</h1><p id="efb3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你只有时间去学一样新东西，那就学这一样。这个操作符将为您节省数千行代码和数小时的错误跟踪时间。</p><p id="362c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能在三元运算符中使用过它，但在2020年，<code class="fe mp mq mr ms b">?</code>被赋予了一个新的表演技巧。</p><p id="9feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可选的链接操作符将检查嵌套属性链中的<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>值。在下面的代码中，<code class="fe mp mq mr ms b">?.</code>操作符将在返回<code class="fe mp mq mr ms b">someNonexistant</code>之前检查对象<code class="fe mp mq mr ms b">noProp</code>是否存在。<strong class="ky ir">如果嵌套对象不存在，它返回</strong> <code class="fe mp mq mr ms b">undefined</code> <strong class="ky ir">而不是在运行时抛出错误<em class="mt"/>。</strong>不执行该检查，您会得到熟悉的<em class="mt">运行时错误</em> : <code class="fe mp mq mr ms b">Uncaught TypeError: Cannot read property 'someNonexistant' of undefined</code></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="6e82" class="my lt iq ms b gy mz na l nb nc">const myObject = {};</span><span id="6c4e" class="my lt iq ms b gy nd na l nb nc">const someNonexistant = myObject.noProp?.someNonexistant;<br/>console.log(someNonexistant); // undefined</span><span id="4634" class="my lt iq ms b gy nd na l nb nc">// Use with methods<br/>console.log(myObject.noMethod?.()); // undefined</span></pre><p id="ff61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">?.</code>操作符节省了时间，因为如果您想要手动执行此检查，您必须使用更多代码，如下所示:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="36c4" class="my lt iq ms b gy mz na l nb nc">if (myObject &amp;&amp; myObject.noProp) {<br/>  const someNonexistant = myObject.noProp.someNonexistant;<br/>}</span></pre><p id="72a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以对数组和表达式使用<code class="fe mp mq mr ms b">?.</code>操作符。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="ae6b" class="my lt iq ms b gy mz na l nb nc">let ob1 = {};</span><span id="83c0" class="my lt iq ms b gy nd na l nb nc">const elem = ob1.myArray?.[5];<br/>const myProperty = o<!-- -->b1.nestedObject<!-- -->?.[<!-- -->`expressionPrefix${suffix}<!-- -->`];<br/>console.log(elem); // undefined<br/>console.log(<!-- -->myProperty<!-- -->); // undefined</span></pre><h1 id="f1f2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.零化合并运算符(<code class="fe mp mq mr ms b">??)</code></h1><p id="7fee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">无效合并运算符<code class="fe mp mq mr ms b">??</code>是当其左侧(LHS)为<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>时返回其右侧(RHS)的运算符(仅<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>=<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish" rel="noopener ugc nofollow" target="_blank">无效</a>)。如果它的LHS不是无效的，它返回LHS。</p><p id="1abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">助记符记住它的作用:“仅当LHS值为</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">null</strong></code> <strong class="ky ir">或</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">undefined</strong></code> <strong class="ky ir">时才分配RHS值。”</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="15d9" class="my lt iq ms b gy mz na l nb nc">const nullNullish = null ?? 'default value';<br/>console.log(nullNullish); // default value</span><span id="d2fc" class="my lt iq ms b gy nd na l nb nc">let undefinedNullish;<br/>const someNullishvalue = undefinedNullish ?? 'default value';<br/>console.log(someNullishvalue); // default value</span><span id="e867" class="my lt iq ms b gy nd na l nb nc">const notNullishZero = 0 ?? "hello";<br/>console.log(notNullishZero); // 0</span><span id="148d" class="my lt iq ms b gy nd na l nb nc">const notNullishEmptyString = "" ?? "hello";<br/>console.log(notNullishEmptyString); // ""</span><span id="7bc2" class="my lt iq ms b gy nd na l nb nc">// COMPARE THE LAST TWO ASSIGNMENTS WHEN USING THE || OPERATOR<br/>const notNullishZero = 0 || "hello";<br/>console.log(notNullishZero); // hello</span><span id="5ffa" class="my lt iq ms b gy nd na l nb nc">const notNullishEmptyString = "" || "hello";<br/>console.log(notNullishEmptyString); // hello</span></pre><p id="f260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个操作符非常类似于<code class="fe mp mq mr ms b">||</code>操作符，有一个主要的优点。<code class="fe mp mq mr ms b">||</code>操作符的缺陷是，如果LHS为<strong class="ky ir">任何</strong>假值，<code class="fe mp mq mr ms b">||</code>操作符将返回RHS。然而，<code class="fe mp mq mr ms b">??</code>操作员仅在LHS为<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code> <strong class="ky ir">时才返回RHS。falsy值列表如下所示。如果您认为除了<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>之外的任何falsy值都有效，那么您必须使用<code class="fe mp mq mr ms b">||</code>。但是，大多数时候你只想检查<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>，这也是<code class="fe mp mq mr ms b">??</code>比<code class="fe mp mq mr ms b">||</code>应用更广泛的地方。这将避免许多错误，因为许多开发人员忘记了<code class="fe mp mq mr ms b">||</code>将捕获<strong class="ky ir">所有的</strong>错误值，例如数字<code class="fe mp mq mr ms b">0</code>和空字符串<code class="fe mp mq mr ms b">“”</code>。</strong></p><p id="364b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你学会了这个运算符，你就会经常用到它！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/4ac28fe0f6e6c92475c6b30a79df6c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ihs-Bk9cPvWV7HSGkB_keA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Falsy values, <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank">MDN Web Docs</a></figcaption></figure><p id="5e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对您来说最好的代码行之一是使用前面描述的可选链接操作符<code class="fe mp mq mr ms b">?</code>和<code class="fe mp mq mr ms b">??</code>操作符，如果在赋值期间没有找到，则给出一个默认值，如下所示:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="d8fe" class="my lt iq ms b gy mz na l nb nc">let myObject = {<br/>  one: 66667,<br/>  two: "hello"<br/>};</span><span id="21a0" class="my lt iq ms b gy nd na l nb nc">// USING NEW SYNTAX - ONE LINE<br/>const <!-- -->someNonexistant<!-- --> = myObject.nested?.three ?? "default value";<br/>console.log(<!-- -->someNonexistant<!-- -->); // "default value"</span><span id="69e7" class="my lt iq ms b gy nd na l nb nc">// USING OLD SYNTAX - FIVE LINES<br/>if (myObject &amp;&amp; myObject.<!-- -->nested <!-- -->&amp;&amp; myObject.<!-- -->nested.three<!-- -->) {<br/>  const someNonexistant = myObject.<!-- -->nested<!-- -->.<!-- -->three<!-- -->;<br/>} else {<br/>  const someNonexistant = <!-- -->"default value"<!-- -->;<br/>}</span></pre><h1 id="67d7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.无效赋值运算符(<code class="fe mp mq mr ms b">??=</code>)</h1><p id="7f27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在表达式<code class="fe mp mq mr ms b">a ??= b;</code>中，只有当<code class="fe mp mq mr ms b">a</code>为空(<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>)时，<code class="fe mp mq mr ms b">a</code>才会被赋予<code class="fe mp mq mr ms b">b</code>的值。换句话说，只有在<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>的情况下，才给<code class="fe mp mq mr ms b">a</code>赋值，否则，就不管它了。</p><p id="b1aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">助记符记住它的作用:“仅当当前自身值为</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">null</strong></code> <strong class="ky ir">或</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">undefined</strong></code> <strong class="ky ir">时，重新分配自身值。”</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="e631" class="my lt iq ms b gy mz na l nb nc">let myObject = {<br/>  one: 66667,<br/>  two: 0,<br/>  three: null,<br/>  four: ""<br/>};</span><span id="4d4b" class="my lt iq ms b gy nd na l nb nc">myObject.one ??= 'reassigned';<br/>console.log(myObject.one); // 66667</span><span id="12b7" class="my lt iq ms b gy nd na l nb nc">myObject.two ??= 'reassigned';<br/>console.log(myObject.two); // 0</span><span id="e798" class="my lt iq ms b gy nd na l nb nc">myObject.three ??= 'reassigned';<br/>console.log(myObject.three); // "reassigned"</span><span id="2f32" class="my lt iq ms b gy nd na l nb nc">myObject.four ??= 'reassigned';<br/>console.log(myObject.four); // ""</span></pre><p id="e93f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与前面描述的无效合并运算符<code class="fe mp mq mr ms b">??</code>的区别在于<code class="fe mp mq mr ms b">??=</code>在重新分配其<strong class="ky ir">自身值</strong>之前检查其<strong class="ky ir">自身值</strong>是否为无效，而<code class="fe mp mq mr ms b">??</code>检查<strong class="ky ir">LHS</strong>上的任何变量值是否为无效，并且可以将RHS值分配给<strong class="ky ir">任何变量</strong>。</p><p id="c28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，变量<code class="fe mp mq mr ms b">a</code> <strong class="ky ir">必须已经声明为</strong>，否则默认为<code class="fe mp mq mr ms b">undefined</code>。该运算符的目的是避免不必要地覆盖已经赋值的有效值。</p><p id="cd4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会说您可以只使用<code class="fe mp mq mr ms b">a = a ?? b;</code>，但这和<code class="fe mp mq mr ms b">a ??= b;</code>不一样。区别在于<code class="fe mp mq mr ms b">a = a ?? b;</code>总是会将<strong class="ky ir">重新分配给<code class="fe mp mq mr ms b">a</code>，不管<code class="fe mp mq mr ms b">a</code>是否有值。另一方面，如果<code class="fe mp mq mr ms b">a</code>不是<code class="fe mp mq mr ms b">null</code>或<code class="fe mp mq mr ms b">undefined</code>，则<code class="fe mp mq mr ms b">a ??= b;</code>将<strong class="ky ir">中止</strong>分配。</strong></p><p id="fa0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该运算符的一个警告是，如果您有一个API或一个值，它返回一个您想要重新分配的空字符串，那么最好使用下面描述的or赋值运算符<code class="fe mp mq mr ms b">||=</code>。如果对空字符串使用<code class="fe mp mq mr ms b">??=</code>，将会<strong class="ky ir">而不是</strong>重新分配空字符串的值，因为空字符串不是will。</p><h1 id="5759" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.OR赋值运算符(<code class="fe mp mq mr ms b">||=</code>)</h1><p id="f9ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在表达式<code class="fe mp mq mr ms b">a ||= b;</code>中，如果<code class="fe mp mq mr ms b">a</code>为假，则<code class="fe mp mq mr ms b">a</code>只被赋予<code class="fe mp mq mr ms b">b</code>的值。换句话说，只有当<code class="fe mp mq mr ms b">a</code>当前是虚假的时候，才赋予它一个值，否则，让它去吧。</p><p id="8bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">记忆它的作用:“只有当当前的自身价值是虚假的时，才重新分配自身价值。”</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="263c" class="my lt iq ms b gy mz na l nb nc">let myObject = {<br/>  one: 66667,<br/>  two: 0,<br/>  three: null,<br/>  four: ""<br/>};</span><span id="6188" class="my lt iq ms b gy nd na l nb nc">myObject.one ||= 'reassigned';<br/>console.log(myObject.one); // 66667</span><span id="b782" class="my lt iq ms b gy nd na l nb nc">myObject.two ||= 'reassigned';<br/>console.log(myObject.two); // "reassigned"</span><span id="8984" class="my lt iq ms b gy nd na l nb nc">myObject.three ||= 'reassigned';<br/>console.log(myObject.three); // "reassigned"</span><span id="c332" class="my lt iq ms b gy nd na l nb nc">myObject.four ||= 'reassigned';<br/>console.log(myObject.four); // "reassigned"</span></pre><p id="e68e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe mp mq mr ms b">??=</code>一样，变量<code class="fe mp mq mr ms b">a</code> <strong class="ky ir">必须已经声明</strong>，否则默认为<code class="fe mp mq mr ms b">undefined</code>。</p><h1 id="feee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.AND赋值运算符(<code class="fe mp mq mr ms b">&amp;&amp;=</code>)</h1><p id="3da5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在表达式<code class="fe mp mq mr ms b">a &amp;&amp;= b;</code>中，如果<code class="fe mp mq mr ms b">a</code>为真(任何不为假的都为真)，则<code class="fe mp mq mr ms b">a</code>仅被赋予<code class="fe mp mq mr ms b">b</code>的值。换句话说，只有当<code class="fe mp mq mr ms b">a</code>当前为真时，才给它赋值，否则，就不要去管它。</p><p id="8223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用于记住其作用的助记符:“仅当当前自身值为真时，才重新分配自身值。”</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="9fc7" class="my lt iq ms b gy mz na l nb nc">let myObject = {<br/>  one: 66667,<br/>  two: 0,<br/>  three: null,<br/>  four: ""<br/>};</span><span id="6ea4" class="my lt iq ms b gy nd na l nb nc">myObject.one &amp;&amp;= 'reassigned';<br/>console.log(myObject.one); // "reassigned"</span><span id="28ca" class="my lt iq ms b gy nd na l nb nc">myObject.two &amp;&amp;= 'reassigned';<br/>console.log(myObject.two); // 0</span><span id="a7f5" class="my lt iq ms b gy nd na l nb nc">myObject.three &amp;&amp;= 'reassigned';<br/>console.log(myObject.three); // null</span><span id="e2ba" class="my lt iq ms b gy nd na l nb nc">myObject.four &amp;&amp;= 'reassigned';<br/>console.log(myObject.four); // ""</span></pre><p id="e7b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会注意到这个操作符有一种让虚假的事情虚假的倾向。</p><h1 id="8f0c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.析构赋值语法</h1><p id="f9b7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">析构允许你通过直接从数组中取出元素或者直接从对象中取出属性来设置局部变量。下面的代码从<code class="fe mp mq mr ms b">myArray</code>创建了三个新的局部变量<code class="fe mp mq mr ms b">one, two, three</code>。这比手动操作要快得多。</p><p id="3d47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">记住它做什么的助记符:“通过直接从数组或对象中取出元素来声明变量。”</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="3d8e" class="my lt iq ms b gy mz na l nb nc">const myArray = [5, 7, 'ten'];<br/>const [one, two, three] = myArray; // square brackets for arrays<br/>console.log(<!-- -->one, two, three<!-- -->); // <!-- -->5, 7, 'ten'</span><span id="40d2" class="my lt iq ms b gy nd na l nb nc">const myObject = {one: 'hello', two: 'there'};<br/>const {one, two} = myObject; // curly brackets for objects<br/>console.log(<!-- -->one, two<!-- -->); // <!-- -->'hello', 'there'</span><span id="e372" class="my lt iq ms b gy nd na l nb nc">// MANUAL SYNTAX<br/>const one = myArray[0];<br/>const two = myArray[1];<br/>const three = myArray[2];</span></pre><p id="b9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">析构语法在下面描述的许多场景中非常有用。</p><p id="eb28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过跳过括号中的析构名称，可以跳过数组的一个元素。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="1602" class="my lt iq ms b gy mz na l nb nc">const myArray = [5, 7, 'ten'];<br/>const [one, , three] = myArray;<br/>console.log(<!-- -->one, three<!-- -->); // <!-- -->5, 'ten'</span></pre><p id="f5ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用rest语法<code class="fe mp mq mr ms b">…</code>将<code class="fe mp mq mr ms b">myArray</code>分成一个局部变量和另一个数组。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="15a3" class="my lt iq ms b gy mz na l nb nc">const myArray = [5, 7, 'ten', 25, 46];<br/>const [one, , ...remainderArray] = myArray;<br/>console.log(<!-- -->one, remainderArray<!-- -->); // <!-- -->5, ['ten', 25, 46]</span></pre><p id="b7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在析构括号中为来自源对象的<code class="fe mp mq mr ms b">undefined</code>元素分配一个默认值。例如<code class="fe mp mq mr ms b"> one = ‘ho’</code></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="1c5a" class="my lt iq ms b gy mz na l nb nc">const myArray = [5, undefined, 'ten'];<br/>const [one = 'ho', two = 'default', three = 'hi'] = myArray;<br/>console.log(<!-- -->one, two, three<!-- -->); // <!-- -->5, 'default', 'ten'</span><span id="0905" class="my lt iq ms b gy nd na l nb nc">const myObject = {one: 'hello', two: undefined};<br/>const {one = 'def1', two = 'def2'} = myObject;<br/>console.log(<!-- -->one, two<!-- -->); // <!-- -->'hello', 'def2'</span></pre><p id="7fc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当析构对象时，你可以使用<code class="fe mp mq mr ms b">:</code>重命名属性，例如<code class="fe mp mq mr ms b">one: newName</code>。请参见下面的代码:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="8faf" class="my lt iq ms b gy mz na l nb nc">const myObject = {one: 'hello', two: undefined};<br/>const {one: newName, two = 'def2'} = myObject;<br/>console.log(<!-- -->newName, two<!-- -->); // <!-- -->'hello', 'def2'</span></pre><p id="1482" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用方括号中的计算运行时名称来访问对象键。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="c8cf" class="my lt iq ms b gy mz na l nb nc">const runTimekey = 'computedKey';</span><span id="4865" class="my lt iq ms b gy nd na l nb nc">const myObject = {[runTimekey]: 'hello', two: undefined};<br/>const {[runTimekey]: newName, two = 'def2'} = myObject;<br/>console.log(<!-- -->newName, two<!-- -->); // <!-- -->'hello', 'def2'</span></pre><p id="90a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">析构作为参数传递给函数的对象，从而避免了用于分配变量的额外代码行:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="9ae5" class="my lt iq ms b gy mz na l nb nc">const myObject = {one: 'hello', two: 'there'};</span><span id="5f8f" class="my lt iq ms b gy nd na l nb nc">function myFunc({one = 'default1', two = 'default2'}) {<br/>  <!-- -->console.log(<!-- -->one, two<!-- -->); // <!-- -->'hello', 'there'<br/>}</span><span id="a388" class="my lt iq ms b gy nd na l nb nc">myFunc(myObject);</span></pre><p id="7179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mp mq mr ms b">for</code>循环中析构对象数组:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="d5db" class="my lt iq ms b gy mz na l nb nc">const myArray = [<br/>  {name: 'Mark'},<br/>  {name: 'Steve'},<br/>  {name: 'Tracy'},<br/>];</span><span id="3430" class="my lt iq ms b gy nd na l nb nc">for (const {name: theName} of myArray) {<br/>  <!-- -->console.log(<!-- -->theName<!-- -->);<br/> // <!-- -->'Mark'<br/> // 'Steve'<br/> // 'Tracy'<br/>}</span></pre><p id="39c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要了解有关循环的更多信息，请参阅本文:</p><div class="nf ng gp gr nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-loops-a-comprehensive-guide-eb7f98b7c455"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">JavaScript循环:综合指南</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">对象、数组和字符串— for、forEach、for…of、for…in、includes、while、do…while、every、some</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><h1 id="b94d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包裹</h1><p id="1df2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">感谢阅读。如果你喜欢这篇文章，可以考虑在这里<a class="ae kv" href="https://craftedwebpages.medium.com/membership" rel="noopener">订阅</a>中级会员，以获得数以千计的其他文章。</p><p id="5b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以后我会贴更多的Javascript内容。你可能也会喜欢我的另一篇文章:</p><div class="nf ng gp gr nh ni"><a href="https://levelup.gitconnected.com/9-early-signs-you-will-be-a-successful-programmer-1a604f04be39" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">你将成为成功程序员的9个早期迹象</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">不要放弃</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/technology-hits/the-best-programming-languages-to-learn-first-a-roadmap-for-the-indecisive-beginner-f242e5ffeac5" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">首先学习的最佳编程语言——犹豫不决的初学者的路线图</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">最省时、最具成本效益的学习方式以及免费和付费课程</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ny l nt nu nv nr nw kp ni"/></div></div></a></div><h1 id="60e4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">学习资源:</h1><p id="7e38" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接(？。)</a> <br/> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank">无效凝聚算子(？？)</a> <br/> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment" rel="noopener ugc nofollow" target="_blank">逻辑无效赋值(？？=) </a> <br/> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment" rel="noopener ugc nofollow" target="_blank">逻辑或赋值(||=) </a> <br/> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment" rel="noopener ugc nofollow" target="_blank">逻辑与赋值(&amp; &amp; =) </a> <br/> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构赋值</a><br/><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank">Falsy</a><br/><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">Truthy</a></p></div></div>    
</body>
</html>