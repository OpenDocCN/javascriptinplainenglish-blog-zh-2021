<html>
<head>
<title>SOLID Principles with Type Script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有脚本类型的坚实原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solid-principles-with-type-script-d0f9a0589ec5?source=collection_archive---------3-----------------------#2021-10-02">https://javascript.plainenglish.io/solid-principles-with-type-script-d0f9a0589ec5?source=collection_archive---------3-----------------------#2021-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="65bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SOLID Principle是一种编码标准，由Robert C Martin提出，并在整个面向对象编程领域得到实践。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ba3ea47cc79c70ad0f6cfbceeb43c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BS6k40w4CZE7-PLnv-qImw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">TypeScript</figcaption></figure><h2 id="b8dd" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">什么是固体原理？</strong></h2><p id="7a9a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在软件设计中，SOLID是五个设计原则的首字母缩略词，所有开发人员都应该对这五个原则有一个清晰的概念，以便正确地开发软件，避免糟糕的设计。当开发人员正确应用坚实的原则时，它会使您的代码更具可扩展性、逻辑性和可读性。</p><p id="5d62" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">五项坚实的原则是:</p><p id="17c1" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">1.<strong class="lt ir">单一责任原则:</strong>每个类应该只有一个责任，或者一个类的改变不应该有一个以上的原因。</p><p id="8cc6" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">2.<strong class="lt ir">开-闭原则:</strong>对象应该对扩展开放，对修改关闭。</p><p id="631d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">3.Liskov替换原则:子类应该可以替换它们的超类。</p><p id="33fb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">4.<strong class="lt ir">接口分离原则:</strong>许多特定于客户端的接口比一个通用接口要好。</p><p id="a310" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">5.<strong class="lt ir">依赖倒置原则:</strong>依赖抽象，不依赖具体化。</p><h2 id="201b" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">单一责任原则</strong></h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="deb0" class="kv kw iq mq b gy mu mv l mw mx">Every class should have only one responsibility or There should not be more than one reason for a class to change.</span></pre><p id="6955" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">假设我们有一个学校管理系统，它有不同的部门，例如，数学，英语，计算工资的文学，报告和教学时间。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2ea7" class="kv kw iq mq b gy mu mv l mw mx">class Department {<br/> public calculatePay (): number {<br/> // implement algorithm for Mathematics, English, Literature<br/> }<br/> public reportHours (): number {<br/> // implement algorithm for  Mathematics, English, Literature<br/> }<br/>public techingHours (): Promise&lt;any&gt; {<br/> // implement algorithm for  Mathematics, English, Literature<br/> }<br/>}</span></pre><p id="46be" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在上面的例子中，如果你看到我们编写了一个类来计算一个类中的工资、报告和教学时间，这显然违反了SRP。</p><p id="1e86" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">请查看下面<strong class="lt ir">单一责任原则的实现。</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fce2" class="kv kw iq mq b gy mu mv l mw mx">abstract class Employee {<br/> // This needs to be implemented<br/> abstract calculatePay (): number;<br/> // This needs to be implemented<br/> abstract reportHours (): number;<br/> // let’s assume THIS is going to be the <br/> // same algorithm for each employee- it can<br/> // be shared here.<br/> protected teachingHours (): Promise&lt;any&gt; {<br/> // common teachingHours algorithm<br/> }<br/>}</span><span id="3adc" class="kv kw iq mq b gy my mv l mw mx">class Math extends Employee {<br/>  calculatePay (): number {<br/>    // implement own algorithm<br/>  }<br/>  reportHours (): number {<br/>    // implement own algorithm<br/>  }<br/>  <br/>  teachingHoursHours (): number {<br/>    // implement own algorithm<br/>  }<br/>}</span><span id="db3b" class="kv kw iq mq b gy my mv l mw mx">class Accounting extends Employee {<br/>  calculatePay (): number {<br/>    // implement own algorithm<br/>  }<br/>  reportHours (): number {<br/>    // implement own algorithm<br/>  }<br/> teachingHoursHours (): number {<br/>    // implement own algorithm<br/>  }</span><span id="3d61" class="kv kw iq mq b gy my mv l mw mx">}</span><span id="23b0" class="kv kw iq mq b gy my mv l mw mx">class IT extends Employee {<br/>  calculatePay (): number {<br/>    // implement own algorithm<br/>  }<br/>  reportHours (): number {<br/>    // implement own algorithm<br/>  }<br/>   teachingHoursHours (): number {<br/>    // implement own algorithm<br/>  }<br/>}</span></pre><h2 id="2b0a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">开闭原理</strong></h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="94e2" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">A Software object should be open for extension but closed for modification</strong></span></pre><p id="ef5b" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">根据这种方法，软件对象应该对扩展开放，但对修改关闭。让我们举一个例子我们要计算矩形和圆形的面积，所以我们编写了下面的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4244" class="kv kw iq mq b gy mu mv l mw mx">class Rectangle {<br/>  public width: number;<br/>  public height: number;<br/>  constructor(width: number, height: number) {<br/>    this.width = width;<br/>    this.height = height;<br/>  }<br/>}<br/>class Circle {<br/>  public radius: number;<br/>  constructor(radius: number) {<br/>    this.radius = radius;<br/>  }<br/>}<br/>function calculateAreasOfMultipleShapes(<br/>  shapes: Array&lt;Rectangle | Circle&gt;<br/>) {<br/>  return shapes.reduce(<br/>    (calculatedArea, shape) =&gt; {<br/>      if (shape instanceof Rectangle) {<br/>        return calculatedArea + shape.width * shape.height;<br/>      }<br/>      if (shape instanceof Circle) {<br/>        return calculatedArea + shape.radius * Math.PI;<br/>      }<br/>    },<br/>    0<br/>  );<br/>}</span></pre><p id="d03d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">如果我们想计算一个新形状的面积，那么我们必须修改上面的代码<strong class="lt ir">calculatareasofmultipleshapes()</strong>来适应这些变化。</p><p id="0a8e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们可以通过遵循SOLID原则来避免上述情况。请查看下面的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5d48" class="kv kw iq mq b gy mu mv l mw mx">interface Shape {<br/>  getArea(): number;<br/>}<br/>class Rectangle implements Shape {<br/>  public width: number;<br/>  public height: number;<br/>  constructor(width: number, height: number) {<br/>    this.width = width;<br/>    this.height = height;<br/>  }<br/>  public getArea() {<br/>    return this.width * this.height;<br/>  }<br/>}<br/>class Circle implements Shape {<br/>  public radius: number;<br/>  constructor(radius: number) {<br/>    this.radius = radius;<br/>  }<br/>  public getArea() {<br/>    return this.radius * Math.PI;<br/>  }<br/>}</span></pre><h2 id="d37b" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">利斯科夫替代原则</strong></h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="db33" class="kv kw iq mq b gy mu mv l mw mx">Sub classes should be substitutable for their super classes.</span></pre><p id="b8e9" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这个原则是芭芭拉·利斯科夫在1980年提出的。如果我们用最简单的方式来解释，那就是我们应该能够用一个物体和另一个物体交换。我们可以通过使用一个<strong class="lt ir">接口</strong>和一个<strong class="lt ir">抽象</strong> <strong class="lt ir">类来实现这个原理。</strong></p><h2 id="4784" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">界面偏析原理</strong></h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="08cb" class="kv kw iq mq b gy mu mv l mw mx"><strong class="mq ir">Many Client specific interfaces are better than one general purpose interface.</strong></span></pre><p id="b809" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">如果我们用最简单的方式来定义这个原则，那就是防止软件对象依赖其他它们不需要的对象，我们可以通过使用<strong class="lt ir">接口</strong>和<strong class="lt ir">抽象类来实现这个原则。</strong></p><p id="d315" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">假设我们有三个不同的<strong class="lt ir">用户</strong>类，它们在同一个操作类上使用三个不同的，每个用户类依赖于两个额外的操作，这是我们不需要的。</p><h2 id="ecc8" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">依存倒置原则</strong></h2><p id="9c0f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><strong class="lt ir">依赖倒置原则</strong>建议在我们的高层和低层对象之间引入一个抽象层，这样高层和低层对象就不应该互相依赖；相反，高级和低级对象都依赖于抽象层。</p><p id="9df5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">让我们讨论下面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5459" class="kv kw iq mq b gy mu mv l mw mx"><br/>interface person {<br/>  introduceSelf(): void;<br/>}</span><span id="9108" class="kv kw iq mq b gy my mv l mw mx">class doctor implements Person {<br/>  public introduceSelf() {<br/>    console.log('I am a Doctor');<br/>  }<br/>}</span><span id="1324" class="kv kw iq mq b gy my mv l mw mx">class itEngineer implements Person {<br/>  public introduceSelf() {<br/>    console.log('I am an IT Engineer');<br/>  }<br/>}</span></pre><p id="33d4" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">上面的例子在理论上和学术上是正确的，但是在介绍的实时实现中可能是复杂的，我们可能需要为它创建一个单独的服务，如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9b88" class="kv kw iq mq b gy mu mv l mw mx">interface introductionService {<br/>  introduce(): void;<br/>}<br/>class introduceShelf implements introductionService {<br/>  public introduce() {<br/>    console.log('I am an engineer');<br/>  }<br/>}<br/>class Engineer implements Person {<br/>  private introductionService = new introduceShelf();<br/>  public introduceSelf() {<br/>    this.introductionService.introduce();<br/>  }<br/>}</span></pre><p id="d9c9" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">不幸的是，上面的代码打破了依赖反转原则，我们应该反转<strong class="lt ir"> Engineer </strong>和<strong class="lt ir">intruse shelf</strong>object之间的依赖，如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0a38" class="kv kw iq mq b gy mu mv l mw mx">class engineer implements person {<br/>  public introductionService: EngineerIntroductionService;<br/> <br/>  constructor(introductionService: IntroductionService) {<br/>    this.introductionService = introductionService;<br/>  }<br/> <br/>  public introduceSelf() {<br/>    this.introductionService.introduce();<br/>  }<br/>}<br/>const engineer = new Engineer(new EngineerIntroductionService());</span></pre><p id="2184" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">有了上面的代码，我们不需要为<strong class="lt ir"> Engineer </strong>和<strong class="lt ir">I Engineer</strong>类创建任何子类。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1829" class="kv kw iq mq b gy mu mv l mw mx">public introductionService: IntroductionService;<br/> <br/>  constructor(introductionService: IntroductionService) {<br/>    this.introductionService = introductionService;<br/>  }<br/>  public introduceSelf() {<br/>    this.introductionService.introduce();<br/>  }<br/>}<br/>const engineer = new Person(new EngineerIntroductionService());<br/>const itEngineer= new Person(new itEngineerIntroductionService());</span></pre><p id="6044" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">上面的代码是一个<strong class="lt ir">合成而不是继承的例子。这使得我们的类更容易进行单元测试，因为我们可以很容易地在构造函数中注入服务。</strong></p><p id="526f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">通过上面的例子，我们已经学会了通过使用TypeScript来实现SOLID原理的不同原理。</p><p id="45ae" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt ir"> <em class="mz">亲爱的读者，感谢您的支持和您宝贵的时间。我希望这是有用的，并有助于发现角度应用的基础。如果你喜欢这篇文章并在评论中留下你的想法，请鼓掌。</em>T19】</strong></p><p id="700f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt ir"> <em class="mz">请关注我并成为会员在</em> </strong> <a class="ae na" href="https://medium.com/@technicadil_001/membership" rel="noopener"> <strong class="lt ir"> <em class="mz">中</em></strong><strong class="lt ir"><em class="mz">获取更多文章。干杯！！</em> </strong></a></p></div></div>    
</body>
</html>