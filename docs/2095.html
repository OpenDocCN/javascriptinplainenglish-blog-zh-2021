<html>
<head>
<title>How to Create Modular Modals in Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vue.js中创建模块化模态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-modular-modals-in-vue-js-ef1289120a08?source=collection_archive---------8-----------------------#2021-05-03">https://javascript.plainenglish.io/how-to-create-modular-modals-in-vue-js-ef1289120a08?source=collection_archive---------8-----------------------#2021-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="95d4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">为什么我们需要模块化组件，如何制造它们？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ec7e53a4aaf6421001dd9ec9de96dd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KI2iHi8N4CyfmotG"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glen Carrie</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e481" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们需要添加公共UI组件(比如模态或通知吐司)时，我们经常从npm导入包。这种方法的模块化本质有助于我们理解一些重要的概念:可维护性、可伸缩性和可重用性。</p><p id="3546" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript生态系统为我们提供了大量可供选择的包，我们可以轻松地将它们插入到我们的项目中，无需任何复杂的设置，而且它们几乎总是<em class="lp">足够好。</em></p><p id="db9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果提供的模块对我们的情况来说有点额外的开销呢？另一方面，如果我们需要显著地扩展它或者完全控制它呢？</p><p id="2977" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好的一面是它足够简单，可以自己实现。本文讲述了我自己从头构建模态组件的经历。最终结果可在<a class="ae ks" href="https://kotosha-real.github.io/vue-modular-modal/" rel="noopener ugc nofollow" target="_blank"> Github页面</a>获得。你也可以在这个<a class="ae ks" href="https://github.com/kotosha-real/vue-modular-modal" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中抓取源代码，使用这个<a class="ae ks" href="https://codesandbox.io/s/modular-vue-modals-dbfoo" rel="noopener ugc nofollow" target="_blank">沙箱</a>，或者自己编码。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="ca25" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">引导项目</h1><p id="b8de" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">让我们用<a class="ae ks" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>创建一个简单的项目:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="b740" class="mz ly in mv b gy na nb l nc nd">vue create my-project</span></pre><p id="1bd6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出现提示时，选择默认Vue 2设置。</p><p id="bdc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">成功安装后，更改到项目目录:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="4e40" class="mz ly in mv b gy na nb l nc nd">cd my-project</span></pre><p id="47c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们可以开始研究我们的项目结构了。让我们删除默认组件并添加新组件，结果应该如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/26c845f4256a102bded62089a04e2019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*jUVScXp1MfC7dTABJziJqQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Basic project structure</figcaption></figure><p id="2f80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看我们有什么:</p><ol class=""><li id="c5af" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">应用组件是我们应用的基础</li><li id="b293" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">模态组件来创建我们的模态</li><li id="fdb9" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">在模式组件中使用的SignInForm和SignUpForm组件</li><li id="0047" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">只是为了对我们的组件有一个很好的单行导入</li></ol><p id="d2b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是应用程序组件最初的样子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boilerplate App component</figcaption></figure><p id="b4ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，每种形式都有两个模态。这是我会使用的方法:一个模式——一个目的。此时，情态动词总是隐藏的。我们稍后将实现打开/关闭逻辑。</p><p id="6348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们来看看模态分量:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boilerplate Modal component</figcaption></figure><p id="f753" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在没有太多要说的，所以让我们继续形成组件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boilerplate Form components</figcaption></figure><p id="886c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">他们几乎是一样的，此刻没有那么有趣。</p><p id="c534" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，确保你的<code class="fe nt nu nv mv b">index.js</code>看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Simple as it is</figcaption></figure><p id="e00a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，你可以添加一些漂亮的字体。为此，只需将带有所需字体的<code class="fe nt nu nv mv b">&lt;link /&gt;</code>标签放入位于<code class="fe nt nu nv mv b">/public</code>目录下的<code class="fe nt nu nv mv b">index.html</code>文件中，并更改应用程序组件<code class="fe nt nu nv mv b">&lt;style /&gt;</code>标签中的<code class="fe nt nu nv mv b">font-family</code>属性。我为这个项目选择了<a class="ae ks" href="https://fonts.google.com/specimen/Open+Sans" rel="noopener ugc nofollow" target="_blank"> Open Sans </a>，但是你可以使用你喜欢的任何东西。</p><p id="3ed6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看我们的应用程序:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="6fc2" class="mz ly in mv b gy na nb l nc nd">npm run serve</span></pre><p id="ddca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您跟着做，您应该会看到类似这样的内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/693c6dca9657a87cc0d75a1f331280bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFw1K3b_fiCJv4NjCX6jow.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Voila!</figcaption></figure><p id="5961" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们有了一个好看的应用程序，我们必须选择一种方法来处理模态。</p><h1 id="500d" class="lx ly in bd lz ma nz mc md me oa mg mh jt ob ju mj jw oc jx ml jz od ka mn mo bi translated">自定义事件方法</h1><p id="d4ca" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">第一种方法是向应用程序组件添加一些数据，以存储模态的可见性状态和更改它的控件。让我们开始吧:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App component with custom event approach</figcaption></figure><p id="b21f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们添加了<code class="fe nt nu nv mv b">isSignInModalOpen</code>和<code class="fe nt nu nv mv b">isSignUpModalOpen</code>标志来控制相应模态的可见性。我们可以通过单击登录/注册按钮来更改它们。此外，我们还向自定义事件添加了一个侦听器，该事件将由模态发出以关闭自身。</p><p id="3a97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对模态组件做了一点小小的补充，使它能够自我关闭:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Modal component with custom events approach</figcaption></figure><p id="22a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，我们在click事件侦听器上使用了<code class="fe nt nu nv mv b">self</code>修饰符，以确保我们只在单击背景时发出close事件。</p><p id="575d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果我们单击其中一个按钮，我们将看到相应的模态显示出来！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/b76b09ba3d065c8fbb2cfc58b0b91385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuDpYT4OP_HZILeJLaeuyw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Here is our sweet modal</figcaption></figure><p id="687b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这看起来是一个好方法:我们添加了一个非常简单的逻辑来控制模态，而且我们做得非常快。什么会出错？</p><p id="0ff6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑这个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">We just added some more components and it got messy</figcaption></figure><p id="6613" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们把控制模态状态的按钮放在另一个组件中会怎么样？如果我们希望表单组件能够关闭它们所在的模态，该怎么办？在这两种情况下，我们都必须添加自定义事件，并且通常在我们想要改变嵌套组件内的模态状态的每种情况下都必须添加自定义事件。</p><p id="976a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然在上面的例子中看起来<em class="lp">相对来说没有那么糟糕</em>，但是当我们有深度嵌套的组件时，情况可能会糟糕得多。有两种方法可以解决这个问题:</p><ol class=""><li id="463c" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">从最深层的子组件发出自定义事件，将模式状态更改为应用程序组件本身</li><li id="30b6" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">在子组件中使用<code class="fe nt nu nv mv b">$root.$emit</code>来发出定制事件，在应用组件中使用<code class="fe nt nu nv mv b">$root.$on</code>来监听它并对它做出反应</li></ol><p id="4f38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe nt nu nv mv b"> $root.$emit</code>和<code class="fe nt nu nv mv b">$root.$on</code>可能是一个好的解决方案，但是有一个更好的方法，它不需要你添加任何定制的状态管理来控制模态。</p><h1 id="b807" class="lx ly in bd lz ma nz mc md me oa mg mh jt ob ju mj jw oc jx ml jz od ka mn mo bi translated">插件方法</h1><p id="624b" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">正如<a class="ae ks" href="https://vuejs.org/v2/guide/plugins.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>所说:</p><blockquote class="oe of og"><p id="6335" class="kt ku lp kv b kw kx jo ky kz la jr lb oh ld le lf oi lh li lj oj ll lm ln lo ig bi translated">插件通常会给Vue.js添加全局级的功能</p></blockquote><p id="23be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们将要做的:写一个插件并把它附加到Vue原型上，这样我们就可以在任何地方使用它。事情是这样的:</p><ol class=""><li id="e56a" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">插件公开打开/关闭方法</li><li id="12d4" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">模态组件有自己的状态来决定是否显示自己</li><li id="e790" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">模态组件监听插件事件来改变它们的状态</li></ol><p id="be2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种方法加强了处理模态的特定模式，也确保了我们应用程序中每个模态的完全独立性——我们引入错误的空间更小，我们不需要自己管理模态的状态。这是一个易于使用的、声明式的、真正模块化的解决方案，我们可以毫不费力地在另一个应用程序中重用。我们写一些吧！</p><p id="aae9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要为插件添加另一个目录:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8377dfe03be4f4a4d83f25795ebc71b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*hx2-pNl6t_qV-Ny4fS9WRw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Add <code class="fe nt nu nv mv b">plugins</code> folder to the src directory and create Modal.js file</figcaption></figure><p id="ebc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">插件应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Modal plugin</figcaption></figure><p id="f571" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看看:我们实现了<a class="ae ks" href="https://refactoring.guru/design-patterns/singleton" rel="noopener ugc nofollow" target="_blank"> Singleton </a>模式，创建了另一个Vue实例作为<a class="ae ks" href="https://github.com/kotosha-real/event-bus-example" rel="noopener ugc nofollow" target="_blank">事件总线</a>，并全局注册了模态组件。</p><p id="06d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一步是在<code class="fe nt nu nv mv b">main.js</code>文件中注册插件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Plugin registration</figcaption></figure><p id="8f8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，重构模态组件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Modal component with plugin approach</figcaption></figure><p id="f3cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，组件本身用<code class="fe nt nu nv mv b">isOpen</code>标志控制自己的状态。每个组件实例监听插件事件，并根据它们决定它们的状态，这就是为什么我们必须为模型提供一个<code class="fe nt nu nv mv b">name</code>道具。</p><p id="52f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们重新连接应用程序组件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App component with plugin approach</figcaption></figure><p id="3a01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们要在App组件中存储的只是模态名。其他的都被插件本身覆盖了。我们所要做的就是使用插件，把模态组件放在一个地方，给它们命名，然后在我们应用的任何部分使用插件方法。你不需要做任何额外的步骤就可以在其他地方使用这个插件，安装过程是一样的。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="abfc" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">结论</h1><p id="9e7f" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">在本文中，我们介绍了在Vue.js中编写模块化模态组件的两种方法。模块化组件有助于我们编写更简洁、更易于维护、易于重用的代码。以模块化的方式思考代码可能需要一些时间来掌握，但从长远来看，这将为您节省大量时间，所以我强烈建议尝试一下。</p><p id="a36c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你喜欢这篇文章，请告诉我！</p><p id="b5d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">祝你今天开心！玩的开心！</p><p id="66c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>