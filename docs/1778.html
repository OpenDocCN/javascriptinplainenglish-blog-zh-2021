<html>
<head>
<title>Face Detection in the Browser using TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow.js在浏览器中进行人脸检测</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/face-detection-in-the-browser-using-tensorflow-js-facb2304ed91?source=collection_archive---------4-----------------------#2021-04-15">https://javascript.plainenglish.io/face-detection-in-the-browser-using-tensorflow-js-facb2304ed91?source=collection_archive---------4-----------------------#2021-04-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9f3f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用TensorFlow.js中的Blazeface模型进行简单的人脸检测。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/27b22ed279c8852e8ade2998727cc789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Ns_3UCePf_NQUmAhxJAdcA.gif"/></div></figure><p id="6683" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">TensorFlow.js是在你的浏览器中运行ML模型的一个很好的工具，并且附带了许多预先训练好的模型供我们使用。今天，我将使用Blazeface模型从浏览器的网络摄像头中检测人脸。</p><p id="f29b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用这个，你可以裁剪图像以只得到人脸，检测人脸以标记图像中的人，或者这可以是人脸识别的第一步。</p><p id="12cb" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以将流程分为3个步骤:</p><ol class=""><li id="3d7a" class="lg lh in km b kn ko kq kr kt li kx lj lb lk lf ll lm ln lo bi translated">访问网络摄像头视频源</li><li id="9380" class="lg lh in km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo bi translated">执行面部检测</li><li id="f1a6" class="lg lh in km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo bi translated">显示结果</li></ol><p id="f6d9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要运行这段代码，最好有一个支持热重装的本地服务器设置。我喜欢在VS代码上使用服务器插件。</p><p id="edaf" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所以让我们开始吧！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">The video version if you prefer that !</figcaption></figure><h2 id="0917" class="ma mb in bd mc md me dn mf mg mh dp mi kt mj mk ml kx mm mn mo lb mp mq mr ms bi translated">访问网络摄像头视频源</h2><p id="7267" class="pw-post-body-paragraph kk kl in km b kn mt jo kp kq mu jr ks kt mv kv kw kx mw kz la lb mx ld le lf ig bi translated">第一步是访问网络摄像头及其视频源。</p><p id="c40f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将使用浏览器的MediaDevices界面，该界面允许您访问连接的媒体设备，如相机、麦克风，甚至屏幕共享。</p><p id="e84d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先用基本的样板代码创建<strong class="km io">index.html</strong>文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my lv l"/></div></figure><p id="9411" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我在主体中添加了一个视频标签，我们可以用它来查看来自网络摄像头的视频输出。</p><p id="9c6f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在让我们创建另一个名为<strong class="km io"> script.js </strong>的文件，我们将在其中编写JavaScript代码并将其包含在index.html中。我把它加在了body标签的后面。脚本可以包含在head标记中，但是将它包含在body标记之后可以确保脚本只在HTML呈现之后运行。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my lv l"/></div></figure><p id="8773" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在这里，我们获取视频标签元素，并将其存储在变量video中。函数setupCamera调用getUserMedia API，我们指定视频尺寸。我还在这里设置了音频为假，因为我们不需要它。</p><p id="44c7" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">getUserMedia函数使用MediaStream对象返回一个承诺，我们将该对象分配给video元素的srcObject属性。最后，在最后，这个函数被调用。</p><p id="96b8" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在运行这个启动你的服务器或在浏览器中打开index.html文件。您的浏览器将请求访问摄像头的许可，允许它，您应该会在屏幕上看到网络摄像头馈送。</p><h2 id="7709" class="ma mb in bd mc md me dn mf mg mh dp mi kt mj mk ml kx mm mn mo lb mp mq mr ms bi translated">执行面部检测</h2><p id="cc0e" class="pw-post-body-paragraph kk kl in km b kn mt jo kp kq mu jr ks kt mv kv kw kx mw kz la lb mx ld le lf ig bi translated">为了检测人脸，我们将使用TensorFlow.js中的<a class="ae mz" href="https://github.com/tensorflow/tfjs-models/tree/master/blazeface" rel="noopener ugc nofollow" target="_blank"> Blazeface </a>模型。这是一个轻量级模型，用于检测图像中的人脸。</p><p id="c17c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先，让我们使用脚本标签将TensorFlow.js库和Blazeface模型导入到我们的<strong class="km io">index.html</strong>文件中。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="d5f3" class="ma mb in nb b gy nf ng l nh ni">&lt;script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"&gt;&lt;/script&gt;<br/>&lt;script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"&gt;&lt;/script&gt;</span></pre><p id="9b39" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">确保在导入<strong class="km io"> script.js </strong>之前添加以上标签。这是为了确保我们的脚本只在加载了所需的依赖项之后才运行。</p><p id="8c36" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来，创建一个变量模型，并在其中加载Blazeface模型。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="a3e9" class="ma mb in nb b gy nf ng l nh ni">let model;<br/>model = blazeface.load();</span></pre><p id="e683" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来，让我们在脚本中创建一个函数detectFaces，它将执行面部检测并给出输出。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="b815" class="ma mb in nb b gy nf ng l nh ni">const detectFaces = async () =&gt; {<br/>  const prediction = await model.estimateFaces(video, false);   <br/>  console.log(prediction);<br/>};</span></pre><p id="3bca" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，如果您调用detectFaces并运行一切，您将得到一个错误。这是因为blazeface.load()是异步的，加载需要一些时间。但是在加载Blazeface之前会调用detectFaces。</p><p id="55b3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，为了解决这个问题，我们将首先等待从网络摄像头加载视频。完成后，我们等待模型加载，然后调用detectFaces函数。在加载视频提要时，我们可以监听一个名为<em class="nj"> loadeddata </em>的事件监听器。</p><p id="b660" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，结合以上所有内容，最终的<strong class="km io"> script.js </strong>文件应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my lv l"/></div></figure><p id="29cb" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，如果您检查您的控制台，您应该能够看到预测对象，看起来像这样:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="0b7e" class="ma mb in nb b gy nf ng l nh ni">[<br/>    {<br/>        "topLeft": [<br/>            186.164306640625,<br/>            229.93507385253906<br/>        ],<br/>        "bottomRight": [<br/>            400.3614807128906,<br/>            372.7312927246094<br/>        ],<br/>        "landmarks": [<br/>            [<br/>                249.68140237033367,<br/>                275.46426653862<br/>            ],<br/>            [<br/>                326.18556171655655,<br/>                271.4667320251465<br/>            ],<br/>            [<br/>                285.10335087776184,<br/>                312.4013841152191<br/>            ],<br/>            [<br/>                290.80926552414894,<br/>                337.9300758242607<br/>            ],<br/>            [<br/>                218.2365596294403,<br/>                286.3128364086151<br/>            ],<br/>            [<br/>                371.4763283729553,<br/>                279.08667623996735<br/>            ]<br/>        ],<br/>        "probability": [<br/>            0.9811193943023682<br/>        ]<br/>    }<br/>]</span></pre><p id="70a2" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">预测变量是对象的列表，其中每个对象对应于检测到的面部。在每个物体内部，你可以找到左上角和右下角的坐标，以及对应眼睛、耳朵、鼻子和嘴巴的6个面部标志。</p><p id="4b35" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来，我们将使用这些坐标来绘制面部周围的矩形。</p><h2 id="f1c1" class="ma mb in bd mc md me dn mf mg mh dp mi kt mj mk ml kx mm mn mo lb mp mq mr ms bi translated">显示结果</h2><p id="885e" class="pw-post-body-paragraph kk kl in km b kn mt jo kp kq mu jr ks kt mv kv kw kx mw kz la lb mx ld le lf ig bi translated">这一步非常简单。简单地遍历预测数组，为面部标志画一个矩形或点。</p><p id="a6b7" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以使用HTML画布来实现这一点。因此，在index.html文件中创建一个新的canvas标记，并赋予它与视频提要的宽度和高度相匹配的宽度和高度。此外，我们不再需要显示视频标记的内容，因此将其CSS显示属性设置为none。</p><p id="0240" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">完成上述操作后，你的index.html应该看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my lv l"/></div></figure><p id="7c5d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来，在script.js文件中，创建另一个变量来保存画布对象，并为画布创建一个2d上下文。接下来，首先需要在画布上绘制当前视频，然后是矩形和面部标志。这可以使用HTML canvas的drawImage和rect函数来完成。</p><p id="7c45" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">此外，detectFaces函数现在只被调用一次。要将输出视为视频，我们需要不断调用它，根据您想要的帧速率，每秒调用24次或30次。所以为了继续调用它，我们可以使用setInterval函数。</p><p id="65cb" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">最后，您的<strong class="km io"> script.js </strong>文件看起来会像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my lv l"/></div></figure></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="430c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">希望这篇文章是有帮助的。在<a class="ae mz" href="https://twitter.com/adarsh_menon_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae mz" href="https://www.linkedin.com/in/adarsh-menon-/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，并查看我的<a class="ae mz" href="https://youtube.com/adarshmenon" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>。</p><p id="78e5" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="nj">更多内容请看</em><a class="ae mz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nj">plain English . io</em></a></p></div></div>    
</body>
</html>