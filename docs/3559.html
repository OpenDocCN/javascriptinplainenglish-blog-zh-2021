<html>
<head>
<title>I Looked At Over 1000 JavaScript Projects and Found The Following Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我查看了1000多个JavaScript项目，发现了以下错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-looked-at-over-1000-javascript-projects-and-found-the-following-errors-1ada93afd1af?source=collection_archive---------1-----------------------#2021-07-17">https://javascript.plainenglish.io/i-looked-at-over-1000-javascript-projects-and-found-the-following-errors-1ada93afd1af?source=collection_archive---------1-----------------------#2021-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6de2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">1000多个项目中JavaScript的异步常见错误</h2></div><p id="e780" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">错误教会我们什么是行不通的，并鼓励我们创造新的思维和行为方式。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d244fd616713bd2abf2609b4be80ad9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Exkn_BJQeCBjKjWCkPntg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Diagram of the promise chain</figcaption></figure><p id="ae21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用JavaScript需要掌握异步代码。如果你不理解异步代码是如何工作的，你将会得到难以维护的不可预测的代码。</p><p id="aeaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以从最佳实践中学习，但是今天，我将只向您介绍来自1000多个项目的异步编程中的错误。</p><h1 id="caf4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">忘记检查请求的返回值</h1><p id="33b4" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们创建一个调用API的函数，当调用不能建立连接时，<code class="fe mo mp mq mr b">Promise</code>拒绝。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="aac8" class="mw ls iq mr b gy mx my l mz na">try {<br/>  await fetch("htp://yoursite.com");<br/>} catch(e) {<br/>  // Failed to fetch<br/>  console.log(e.message); <br/>}</span></pre><p id="1b01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，不能确定一切都好。让我们考虑成功连接的情况，<code class="fe mo mp mq mr b">Promise</code>总是解析。</p><ul class=""><li id="cee1" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">响应状态代码指示一个错误(即<strong class="kh ir"> 404未找到</strong>),但程序仍然正常运行。</li></ul><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="071c" class="mw ls iq mr b gy mx my l mz na">try {<br/>  await fetch("https://httpbin.org/status/404");<br/>  // no error<br/>} catch(e) {<br/>  // Failed to fetch<br/>  console.log(e.message);<br/>}</span></pre><ul class=""><li id="495a" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">前面的代码显示了使用异步调用时的一个错误。在这种情况下，为了避免错误，我们必须检查响应的结果。</li></ul><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="bdd0" class="mw ls iq mr b gy mx my l mz na">try {<br/>  const response = await fetch("https://httpbin.org/status/404");<br/>  <strong class="mr ir">if (!response.ok) {<br/>    throw new Error("Error response");<br/>  }</strong><br/>} catch(e) {<br/>  // Failed to fetch<br/>  console.log(e.message);<br/>}</span></pre><h1 id="0710" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">尝试中缺少等待..捕捉</h1><p id="205a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">当你在一个异步函数中使用<code class="fe mo mp mq mr b">try..catch</code>或<code class="fe mo mp mq mr b">try..finally</code>时，确保你也使用了<code class="fe mo mp mq mr b">await</code>。例如，<code class="fe mo mp mq mr b">try..catch</code>块不会处理下面代码中的异常。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="a401" class="mw ls iq mr b gy mx my l mz na">const fn = async () =&gt; {<br/>  throw new Error("error");<br/>}<br/><br/>const outer = async () =&gt; {<br/>  try {<br/>    return fn(); // <strong class="mr ir">&lt;= missing await!</strong><br/>  } catch(e) {<br/>    console.log(e.message);<br/>  }<br/>}<br/><br/>await outer();<br/>// exception is thrown!</span></pre><h1 id="3232" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">用异步代码读取文件时的错误</h1><p id="f259" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这里有一个常见错误的异步版本，它将打印<code class="fe mo mp mq mr b">File content:</code>。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="02bd" class="mw ls iq mr b gy mx my l mz na">var fs = require("fs");<br/>var content = "";<br/>fs.readFile("/path/to/file", function(err, data) {<br/>  content = data;<br/>});<br/>console.log("File content: ", content);</span></pre><p id="b05c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件的内容没有被写入，因为在最后一行<code class="fe mo mp mq mr b">console.log()</code>之后执行了<code class="fe mo mp mq mr b">callback()</code>。</p><p id="ed86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，要解决这个问题，只需将最后一行<code class="fe mo mp mq mr b">console.log()</code>移到<code class="fe mo mp mq mr b">callback()</code>函数中，这样就可以确保内容变量设置正确。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="7e47" class="mw ls iq mr b gy mx my l mz na">var fs = require("fs");<br/>console.log("About to read the file...");<br/>var content = "";<br/>fs.readFile("/path/to/file", function(err, data) {<br/>   content = data;<br/>   console.log("File content: ", content);<br/>});</span></pre><h1 id="35a9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">忘记用catch()方法来处理被拒绝的案例</h1><p id="e616" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们看一个基于假设的返回承诺的<code class="fe mo mp mq mr b">getPromise()</code>函数的例子，一个异步的<code class="fe mo mp mq mr b">process()</code>函数对承诺的结果做一些事情，一个<code class="fe mo mp mq mr b">handleError()</code>函数用于错误处理。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="dfbe" class="mw ls iq mr b gy mx my l mz na">getPromise()<br/>  .then(process, handleError);</span></pre><p id="b288" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe mo mp mq mr b">handleError()</code>函数只从<code class="fe mo mp mq mr b">getPromise() </code>函数得到错误，如果<code class="fe mo mp mq mr b">process()</code>函数的结果被拒绝，<em class="nk">将不会被处理</em>。</p><p id="f6d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的解决方案是使用<code class="fe mo mp mq mr b">catch()</code>方法返回一个<code class="fe mo mp mq mr b">Promise</code>并只处理错误情况。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="e3cd" class="mw ls iq mr b gy mx my l mz na">getPromise()<br/>  .then(process)<br/>  .catch(handleError);</span></pre><p id="3051" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，这两个步骤都被错误处理程序覆盖是最好的。</p><h1 id="20ac" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">不等待异步forEach</h1><p id="7c8d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated"><code class="fe mo mp mq mr b">forEach()</code>方法为每个数组元素执行一次提供的函数。当没有等待迭代完成时，我们有时会犯错误。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="a4a2" class="mw ls iq mr b gy mx my l mz na">const arr = [5, 6, 7, 8];<br/>arr.forEach(async (e) =&gt; {<br/>  console.log(e);<br/>  return makePromise(e);<br/>});<br/>console.log("finished");</span><span id="966b" class="mw ls iq mr b gy nl my l mz na"><strong class="mr ir">// finished<br/>// 1<br/>// 2<br/>// 3</strong></span></pre><p id="41a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最佳实践是等到整个集合都处理完，这可以通过一个<code class="fe mo mp mq mr b">Promise.all</code>和一个<code class="fe mo mp mq mr b">map</code>来实现。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="751d" class="mw ls iq mr b gy mx my l mz na">await Promise.all(arr.map(async (e) =&gt; {   <br/>  console.log(e);<br/>  return makePromsie(e);<br/>}));<br/>console.log("finished");</span><span id="8a17" class="mw ls iq mr b gy nl my l mz na"><strong class="mr ir">// 1<br/>// 2<br/>// 3<br/>// finished</strong></span></pre><h1 id="7a52" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我们忘记关闭资源以防被拒绝</h1><p id="dd0c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">打开一些资源，然后在不需要时关闭它是很常见的。通过将资源生命周期转移到专门的功能，这是最好的解决方案之一。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="2a70" class="mw ls iq mr b gy mx my l mz na">const withTempDir = async (fn) =&gt; {<br/>  const dir = await fs.mkdtemp(<br/>    await fs.realpath(os.tmpdir()) + path.sep<br/>  );<br/>  try {<br/>    return await fn(dir);<br/>  } finally {<br/>    fs.rmdir(dir, {recursive: true});<br/>  }<br/>};<br/><br/>await withTempDir((dir) =&gt; {<br/>  // use dir to store temporary things<br/>})</span></pre><h1 id="e2db" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">在承诺实现/拒绝后运行一些最终代码</h1><p id="a50a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在某些情况下，您希望在一个承诺完成后运行最后一个代码块，而不管它是实现了还是被拒绝了。</p><h2 id="0002" class="mw ls iq bd lt nm nn dn lx no np dp mb ko nq nr md ks ns nt mf kw nu nv mh nw bi translated">不</h2><p id="ce12" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">例如，你可以在<code class="fe mo mp mq mr b">.then()</code>和<code class="fe mo mp mq mr b">.catch()</code>回调中包含相同的代码。但这是气味代码。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="1a09" class="mw ls iq mr b gy mx my l mz na">myPromise<br/>.then(response =&gt; {<br/>  doSomething(response);<br/>  runFinalCode();<br/>})<br/>.catch(e =&gt; {<br/>  returnError(e);<br/>  runFinalCode();<br/>});</span></pre><h2 id="c543" class="mw ls iq bd lt nm nn dn lx no np dp mb ko nq nr md ks ns nt mf kw nu nv mh nw bi translated">做</h2><p id="232a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在最近的现代浏览器中，<code class="fe mo mp mq mr b">.finally()</code>方法是可用的，它可以链接到你的常规承诺链的末端，允许你减少代码重复，更优雅地做事。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="4c16" class="mw ls iq mr b gy mx my l mz na">myPromise<br/>.then(response =&gt; {<br/>  doSomething(response);<br/>})<br/>.catch(e =&gt; {<br/>  returnError(e);<br/>})<br/>.finally(() =&gt; {<br/>  runFinalCode();<br/>});</span></pre><p id="064c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅此而已！。注意，如果你想避免重蹈覆辙，你必须从这些错误中吸取教训。</p><p id="c838" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单对吗？</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="02e2" class="mw ls iq bd lt nm nn dn lx no np dp mb ko nq nr md ks ns nt mf kw nu nv mh nw bi translated">参考</h2><p id="37bd" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">[1]<a class="ae oe" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise</a></p><p id="38fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae oe" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/async _ function</a></p><p id="f002" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]<a class="ae oe" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Promise/catch</a></p><p id="57e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">更多内容请看</em><a class="ae oe" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="nk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>