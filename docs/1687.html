<html>
<head>
<title>JavaScript Technologies for Asynchronous Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步钩子的JavaScript技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-technologies-for-asynchronous-hooks-e603fce414de?source=collection_archive---------17-----------------------#2021-04-10">https://javascript.plainenglish.io/javascript-technologies-for-asynchronous-hooks-e603fce414de?source=collection_archive---------17-----------------------#2021-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5142062351e210cd32d93aa2a551c92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rsk5nCzyGV9-RaB6K4aPxA.png"/></div></div></figure><p id="fc8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">承诺、async/await语句、生成器是实现改变React组件内部状态的异步挂钩的可能技术。</p><p id="0261" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将使用一个简单的应用程序来说明这三种不同的方法，突出每种方法的优点/缺点。</p><p id="5c85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应用程序UI的组件层次结构将使用样式组件库来构建。它优雅地解决了将CSS集成到JavaScript源文件中的问题，同时保留了CSS规则的全部潜力。</p><h1 id="95ca" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用例</h1><p id="9066" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们正在构建的应用程序将显示一组从字典中随机抽取的个人姓名。</p><p id="a5f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为目的是描述异步活动的同步，所以名称将通过模拟rest调用的<em class="lw">来检索。姓名将根据性别进行过滤。所需的性别也是通过模拟get检索的。</em></p><h1 id="5834" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异步模式</h1><p id="b106" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当app模型是一组简单的状态变量时，我们可以说该模型是通过可以预见异步步骤的活动所产生的副作用来更新的。</p><p id="2d7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些模式描述了组织异步步骤的不同方式。在下文中，我们将只考虑其中的两个:</p><ul class=""><li id="66ec" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">异步步骤序列</li></ul><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6b01f9bf72ab33aaa5994e6b27cb1a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*kz9EV2W01H8Ok3uXDztY4g.png"/></div></figure><ul class=""><li id="fcea" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">具有最终同步点的异步步骤的并行开始</li></ul><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/d5b99ed25c2e07fa03b6b06279f42cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*br_jAb1uxtdxShROT78Vyg.png"/></div></figure><p id="19a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以向每个图案添加额外的步骤。它们也可以通过用模式替换步骤来组成。</p><p id="f3b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其他异步模式也是可能的，比如分叉两个不同的异步步骤。</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/fc41a969392c21c9cad99a82c90918a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*Uav_ce9nVad58DfNGWso8w.png"/></div></figure><h1 id="5635" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">休息得到简单的模拟</h1><p id="d86e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现代JavaScript中的rest get是使用fetch API的Fetch函数执行的。它返回一个承诺，所以为了模拟它，我们只需要返回一个承诺。</p><p id="d80d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们感兴趣的是一个简单的模拟，它总是以解码后的JSON格式检索正确的结果(没有出错的可能),所以我们可以简单地计算结果并将其作为promise result返回。</p><p id="39a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">承诺执行者</em>(承诺构造者的函数参数)在解决<em class="lw">承诺</em>之前暂停执行一秒钟。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ec47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在getNames函数中，我使用了我在另一个故事中描述过的shuffle函数。</p><p id="1c52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据要求的性别选择的这组名字被随机打乱并切片。因此，检索到的名称集随着每个请求而变化。<br/>由于结果变化很大，因此可以直观地验证代码是否正常工作(见下文)。</p><p id="d694" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具有fetch但没有错误处理和取消management⁴的简单实现如下:</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="c5d7" class="mu ku in mq b gy mv mw l mx my">const doGet = (url) =&gt;<br/>  fetch(url).then((response) =&gt; response.json())</span><span id="d177" class="mu ku in mq b gy mz mw l mx my">const server = 'http://localhost:4000'</span><span id="0fd6" class="mu ku in mq b gy mz mw l mx my">export const getGender = () =&gt; doGet(`${server}/gender`)<br/>export const getNames = <br/>  (gender) =&gt; doGet(`${server}/names?${gender}`)</span></pre><h1 id="c8cd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检索应用程序模型的方法</h1><p id="b8c1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">应用程序模型的检索，就像烹饪食谱一样，是一系列的步骤。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="f8e4" class="mu ku in mq b gy mv mw l mx my">Set the app status in loading modality<br/>Retrieve the gender of names<br/>Set the gender inside the app model<br/>Retrieve the set of names<br/>Set the names inside the app model<br/>Set the app status back to normal</span></pre><p id="b0e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像烹饪食谱一样，我们可以用异步步骤和同步的指示来注释这个过程</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="a7f2" class="mu ku in mq b gy mv mw l mx my">Asynchronous procedure:<br/>  Set the app status in loading modality<br/>  wait 'Retrieve the gender of names'<br/>  Set the gender inside the app model<br/>  wait 'Retrieve the set of names'<br/>  Set the names inside the app model<br/>  Set the app status back to normal</span></pre><p id="b174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">声明配方是一个异步过程(带注释的配方的第一行)是很重要的:这样调用者就知道它必须等待响应，如果它对响应感兴趣的话。如果它只对副作用感兴趣，这一声明似乎是无用的。然而，trans piler/interpreter仍然需要理解他们必须处理内部等待语句。</p><h1 id="3d15" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">应用模型</h1><p id="4d2d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">app模型由三个状态变量组成</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="171d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模型检索—异步版本，等待注释</h1><p id="d41d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">由于使用了async和await语句，前面配方的JavaScript实现是每一步的一对一翻译。<br/>这消除了在它们被引入之前就存在的在普通同步过程和具有异步步骤的过程之间的差异。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0fa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从技术上来说，<em class="lw"> await </em>等待承诺的解析，而<em class="lw"> async </em>只是将函数体嵌入到一个承诺中，该承诺通过函数的结果进行解析。</p><p id="7433" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，性别状态变量是在检索姓名之前设置的(第5、6行)，因此在等待姓名时，UI会使用检索到的性别进行更新。</p><h1 id="a4fa" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模型检索—有承诺的版本</h1><p id="85f9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有承诺的版本更难理解，很容易迷失在曲折的过程中。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3f30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，这个版本并不等同于前一个版本:它应该返回一个承诺(然而在这种情况下应该解析为null，因为<em class="lw"> retrieveModel </em>函数只提供副作用)。</p><h1 id="f26d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异步的优势，等待</h1><p id="c2ab" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">除了可读性方面的改进，async/await符号允许我们关注过程的细节。</p><p id="d646" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，很容易为错误处理插入一个清晰的边界。</p><p id="9fcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，现在更清楚的是，如果我们已经在运行这个过程，我们必须避免重新运行它(第3行)。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="0496" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模型检索-带生成器的版本</h1><p id="8268" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">带有生成器的版本与带有async/await的版本非常相似:注释<code class="fe na nb nc mq b">async function</code>被替换为<code class="fe na nb nc mq b">function*</code>，注释<code class="fe na nb nc mq b">await</code>被替换为<code class="fe na nb nc mq b">yield</code>。其余的代码完全相同。</p><p id="2490" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这一次，生成器应该明确地运行(第11行)。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bfbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这似乎是不必要的复杂化。相反，它是对async/await解决方案的真正改进。</p><p id="4750" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">发生器</em>和<em class="lw">发生器执行器</em>可以<strong class="jx io">相互通信</strong>。通信可以是<strong class="jx io">异步的。</strong><strong class="jx io">通信协议</strong>可由开发者自行设计。</p><p id="2b1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当异步场景变得更加复杂时，这些特性使这个选项成为最佳选择。</p><p id="6aec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常一个<em class="lw">生成器执行器</em>提供一组通用服务，可以被<em class="lw">生成器</em>请求。服务实现的所有复杂性都在<em class="lw">生成器执行器</em>内部，而<em class="lw">生成器</em>仍然是简单的顺序过程。</p><h2 id="7785" class="mu ku in bd kv nd ne dn kz nf ng dp ld kg nh ni lh kk nj nk ll ko nl nm lp nn bi translated">生成器和执行器之间的交互</h2><p id="22d5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">下面的顺序图描述了<em class="lw">发生器</em>和<em class="lw">发生器执行器</em>之间的交互。</p><p id="80ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步性仅取决于执行者:</p><ul class=""><li id="248e" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">如果请求的服务需要异步活动，那么生成器和执行器的执行将被挂起，直到检索到响应。</li><li id="d8b0" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">如果服务是同步的，生成器和执行器之间的对话只是调用函数的一种复杂方式(这种情况下的优点是一切都在executor)⁵.内部</li></ul><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/11adcc7164b4020bf9e380c213db04bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52OSlBNAhZk20kFrf2CaBA.png"/></div></div></figure><h2 id="6224" class="mu ku in bd kv nd ne dn kz nf ng dp ld kg nh ni lh kk nj nk ll ko nl nm lp nn bi translated">发电机执行器</h2><p id="1a67" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们定义的执行器非常简单，只提供两种服务:</p><ul class=""><li id="008c" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">等待一个承诺的实现。</li><li id="498b" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">等待一组承诺的解决方案(在这种情况下，承诺被并行执行<em class="lw">。</em></li></ul><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1967" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数是递归的。</p><ul class=""><li id="a886" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">第2行在第一个递归步骤创建生成器实例:第一次未定义executorResult，而随后的递归调用总是指定一个结果(第8行)</li><li id="45d2" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">第3行调用generator <em class="lw"> next </em>函数，传递executor结果并检索新的生成器值</li><li id="6075" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">第4行是递归的guard⁶</li><li id="0323" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">第5、6、7行解码所请求的服务</li><li id="51e5" class="lx ly in jx b jy no kc np kg nq kk nr ko ns ks mc md me mf bi translated">第8行实现了异步递归步骤</li></ul><h1 id="7eca" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">UI组件</h1><p id="471c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">UI hierarchy⁷由REACT元素组成，这些元素使用<em class="lw">样式组件</em>库进行样式化。这用几行代码就给了UI一个漂亮的外观。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e9b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第2-6行定义了一个CSS规则。</p><p id="ae6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">样式化组件只是从它们的非样式化(或者部分/不同样式化)版本中派生出来的。例如，第26–28行相当于</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="8846" class="mu ku in mq b gy mv mw l mx my">const Title = props =&gt;<br/>  &lt;h1 {...{style: {alignSelf: 'center'}, ...props}}&gt;<br/>    {props.children}<br/>  &lt;/h1&gt;</span></pre><p id="285f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第41行的<em class="lw"> div </em>不能被<em class="lw">片段</em>替换:需要正确布局内部<em class="lw"> span </em>元素。</p><p id="51f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第44行是<em class="lw">保护表达式</em> ⁶.的惯用用法</p><p id="5cb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终的用户界面如下所示:</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/aa8a3a738332677ced29450c19b4ad48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sEHjG3IDxuD6Oq9pn-gpw.png"/></div></div></figure><h1 id="ae3a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">异步并行步骤</h1><p id="672f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">生成器执行器能够执行并行REST请求。可以用下面的生成器测试这种能力。显然，两个查询之间的相关性被破坏了…</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="93b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第5行调用执行程序的<em class="lw">并行承诺</em>服务。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="2634" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">参考文献:</strong></p><p id="d3ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[1]如果应用程序状态是单个复杂对象(或它们的集合)，我们不能简单地修改模型。在这种情况下，我们应该生成包含旧零件和新零件的模型的新版本(参见<em class="lw">使用状态</em>文档中的<em class="lw">功能更新</em>部分)。</p><p id="c628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[2]<em class="lw">resolve</em>函数可以被认为是一种对承诺的返回声明。</p><p id="7066" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[3]:吉安卡洛·拉达利。2019年11月27日。<em class="lw"> Vector shuffling —一个JavaScript函数实现<br/></em><a class="ae oc" href="https://medium.com/swlh/vector-shuffling-a-javascript-functional-implementation-70e973c5b58f" rel="noopener">https://medium . com/swlh/Vector-shuffling-A-JavaScript-functional-implementation-70e 973 C5 b58f</a></p><p id="e1a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[4]:当一个REACT组件被卸载时，清理所有仍在进行的活动是很重要的。可以使用<em class="lw"> AbortController API </em>取消待处理的获取请求。</p><p id="6178" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[5]REDUX-saga库是使用生成器来提供异步任务的过程化描述的最好例子。佐贺副作用创造了REDUX商店的新版本。该库还提供了许多同步服务，包括一个从存储中提取信息的服务和一个向存储发送动作的服务。</p><p id="fc4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[6]: JavaScript提供了定义守卫表达式<br/> <code class="fe na nb nc mq b">&lt;guard expression&gt; &amp;&amp; &lt;guarded expression&gt;<br/></code>的可能性，但是我们也可以考虑将<em class="lw">作为<em class="lw">守卫语句<br/> </em> <code class="fe na nb nc mq b">if (&lt;guard expression&gt;) &lt;guarded statements&gt;</code></em></p><p id="83c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[7]在任何语言中，用户界面本质上都是元素的层次结构。</p><p id="ac01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">更多内容看</em> <a class="ae oc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="lw">说白了</em></strong></a></p></div></div>    
</body>
</html>