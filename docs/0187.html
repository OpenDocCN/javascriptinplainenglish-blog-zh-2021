<html>
<head>
<title>The most complete guide to React State you’ll ever read</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你读过的最完整的反应状态指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-the-state-world-59721cbf0521?source=collection_archive---------8-----------------------#2021-01-11">https://javascript.plainenglish.io/react-native-the-state-world-59721cbf0521?source=collection_archive---------8-----------------------#2021-01-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="864e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React + React自然状态的世界🌍</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fd2ded5fffd5b404ef7b20568003167c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnW9L0PjS7_eC4BXF8zPBQ.jpeg"/></div></div></figure><p id="f26a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我第一次了解到<strong class="kq io">状态</strong>的时候，它是如此的友好和简单,“将要改变的数据+使它突变触发一个组件渲染”。人们是这么告诉我的。</p><p id="e50c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在与它共事多年后，我开始意识到自己知识上的差距。我过去所知道的状态，伴随着更多的概念和相关的关注，这是我在经历了艰难困苦和大量的研究工作后才意识到的。我几乎没有找到一个涵盖所有这些内容的帖子。所以在这篇博文里，我们来分解一下！</p><h2 id="e173" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">目录:</h2><ul class=""><li id="2e78" class="md me in kq b kr mf ku mg kx mh lb mi lf mj lj mk ml mm mn bi translated"><strong class="kq io">问题:</strong>状态解决什么问题？</li><li id="f158" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">你大概不需要国家吧？:</strong>决定何时明智地使用状态。</li><li id="8364" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">渲染大图:</strong>状态如何与渲染过程相关，如何成为渲染图的一部分。</li><li id="4830" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">为什么异步？API设计背后的原因:</strong>批处理、内部一致、并发更新？</li><li id="d837" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">副作用:</strong>妥善处理副作用。</li><li id="e8e5" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">有效安排你的状态:</strong>安排状态如何提升你的表现。</li></ul><h1 id="a895" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">问题是</h1><p id="a4a5" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">道具是定制组件的绝佳素材。但是每个人都知道它是<strong class="kq io">不可变的，不能被改变</strong>，这阻止了灵活性，因为在真实世界的例子中，组件有时需要随着时间而改变。</p><p id="9e64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">状态是组件的一部分，用来存储将要改变的数据，组件对这些改变做出反应。</p><p id="2676" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，水在摄氏100度沸腾，在摄氏00度结冰。温度的变化决定了水的状态。这里的温度就像一个状态，水就像一个成分，这个成分对状态的变化做出反应。</p><h1 id="5045" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">你大概不需要状态吧？</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/da30c8b008f944091aa8db49105a4b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*yg-nRleqz12xklll8HLJoA.jpeg"/></div></figure><p id="39c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">突变数据</strong>的情况下，很多人都在纠结决定什么时候使用状态，什么时候不使用。如果您还不知道，状态与触发重新渲染密切相关，将数据存储到状态中会不必要地触发“浪费的渲染”。</p><p id="faad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我把<strong class="kq io">突变数据</strong>的用法分为两类:</p><ul class=""><li id="2b05" class="md me in kq b kr ks ku kv kx ni lb nj lf nk lj mk ml mm mn bi translated">与渲染相关的数据:用于生成UI输出的工作或与之相关。</li><li id="2fad" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">与渲染无关的数据:只是简单地用来存储一些数据，用于以后的计算，…与生成UI输出完全无关。</li></ul><h2 id="8f36" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">规则总是:<strong class="ak">只使用状态来存储与渲染相关的突变数据。</strong></h2><p id="6601" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">因为对于与渲染无关的数据，我们不需要将其显示到UI树中，所以不需要排队重新渲染过程，计算UI树。</p><p id="ac2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">否则，当它涉及到渲染时，改变状态数据队列的重新渲染过程，输出新的树UI，并且React将区分该树以收集变化，然后更新到真正的树。</p><p id="f5ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们来分解一个简单的例子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/4f0e74e8f280e9eea8a110b9733371b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yqHuOC0HhWYpFrPJISZsw.png"/></div></div></figure><p id="dd1d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，假设我有三个按钮，其中两个显示计数，如果<strong class="kq io">是Double </strong>为真，其中一个将显示double。</p><p id="e5fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第三个按钮显示<strong class="kq io">是双</strong>开还是关。</p><p id="047a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每当我按下两个按钮中的任何一个时，<strong class="kq io">计数</strong>值就会增加1，并且<strong class="kq io">b按下的</strong>会记录下刚刚按下的按钮的位置。按下第三个按钮将使<strong class="kq io">在开或关之间切换。</strong></p><p id="245e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">计数</strong>用于显示，所以与渲染→存储到状态有关。</p><p id="102a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> isDouble </strong>不用于显示，但决定显示值:开或关，决定计数是否要加倍，所以与渲染→存储到状态有关。</p><p id="41ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> btnPressed </strong>只是一个正常的数据存储位置，既不显示也不决定任何显示，所以与渲染→不存储到状态无关。</p><p id="3507" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用类似<strong class="kq io"> btnPressed: </strong>的数据</p><p id="a16c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于类组件，可以使用<strong class="kq io">实例变量</strong>来存储它</p><p id="a52c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于函数组件，<strong class="kq io"> </strong>可以使用函数变量外部的<strong class="kq io">或者useRef </strong>来存储。两者的区别可以激励我单独写一篇博文，这里就不赘述了，大家可以去网上搜一下。</p><p id="df51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，再来一次，和我一起</p><blockquote class="nm"><p id="da92" class="nn no in bd np nq nr ns nt nu nv lj dk translated"><strong class="ak">仅使用状态来存储与渲染相关的突变数据。</strong></p></blockquote><figure class="nx ny nz oa ob kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/20db539855d3440605d2771b77ec3cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKdpll3mECJcsSBKXEt8GQ.jpeg"/></div></div></figure><h1 id="dbf8" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">效果图大图(奖金信息，不感兴趣可以跳过)</strong></h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/fe93b7a25cd0fdae0a95ea19e22ca9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfaYxw2J1ysUZlPOZ_ecDA.jpeg"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">This is the current life cycles at the time this post written</figcaption></figure><p id="7915" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React有许多不同的核心概念。合在一起，就形成了渲染的大图。那些概念彼此密切相关。</p><p id="6721" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">今天的帖子是关于状态的，所以让我们通过三个主要阶段来看看状态是如何成为大画面的一部分的:(不是渲染过程的实际阶段，只是我的命名lol)</p><ul class=""><li id="2d30" class="md me in kq b kr ks ku kv kx ni lb nj lf nk lj mk ml mm mn bi translated"><strong class="kq io">初始阶段:</strong>首次创建组件的状态。</li><li id="d49d" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">更新阶段:</strong>当通过<strong class="kq io">设置状态</strong>或<strong class="kq io">设置器使用状态</strong>改变状态时</li><li id="fd20" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated"><strong class="kq io">销毁阶段:</strong>卸载组件时</li></ul><h1 id="a5c1" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">— — —类组件————</h1><h1 id="595a" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">初始阶段:</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/e2f61266896a9124acacd55e72eac329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtNUmAzxHleemv1xbYLYYA.png"/></div></div></figure><p id="49e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">状态是组件的资产，在初始化我们的状态时，我们可以在<strong class="kq io">构造函数</strong>中声明它，也可以使用<strong class="kq io"> getInitialState。</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="819d" class="lk ll in oj b gy on oo l op oq">// ES6</span><span id="2db5" class="lk ll in oj b gy or oo l op oq">class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {count: 0};<br/>  }<br/>  // ...<br/>}</span><span id="d72e" class="lk ll in oj b gy or oo l op oq">// ES5</span><span id="a87c" class="lk ll in oj b gy or oo l op oq">const Counter = createReactClass({<br/>  getInitialState: function() {<br/>    return {count: 0};<br/>  },<br/>  // ...<br/>});</span></pre><p id="5ab9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它们之间唯一的区别是，<strong class="kq io">getInitialState+createractclass</strong>是旧的遗产，而<strong class="kq io">构造函数</strong>是初始状态的新方法。React允许我们这样做:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="0edc" class="lk ll in oj b gy on oo l op oq">class Counter extends React.Component {<br/>  this.state = {<br/>       count: 0<br/>  };<br/>  // ...<br/>}</span></pre><p id="aeee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它最终被放入构造函数中，所以是一样的。</p><p id="125e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在州名缩写后。该过程继续到<strong class="kq io"> getDerivedStateFromProps </strong>。</p><p id="eff8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">getDerivedStateFromProps 的存在只有一个目的。它使一个组件能够根据属性的<strong class="kq io">变化来更新其内部状态。(我将在下一篇关于反模式派生状态的博客中详细描述这个案例)。</strong></p><p id="2ea6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后<strong class="kq io"> render() </strong>开始运行<strong class="kq io"> JSX </strong>来创建<strong class="kq io"> ReactNode/ReactElement </strong>，形成了我们UI树的第一个形状。</p><p id="0fb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而<strong class="kq io">componentidmount</strong>紧随其后，此时，React已经更新了<strong class="kq io"> refs和UI树。</strong>这很重要，因为我们可能在这个生命周期之前错误地使用<strong class="kq io">引用</strong>→导致<strong class="kq io">未定义/空引用。</strong></p><p id="0191" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">关于<strong class="kq io"> componentDidMount </strong>更有趣的一点是，它是我们处理副作用的地方，比如调用API。这是为什么呢？</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="338b" class="lk ll in oj b gy on oo l op oq">async componentWillMount(){<br/> const response = await API.fetchList()<br/> if(response.status == 200){<br/>  this.setState({listData: response.data})<br/> } else {<br/> this.setState({error: response.error})<br/> }<br/>}</span></pre><p id="9071" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原因是为了避免<strong class="kq io">未定义的默认状态</strong>。说我们在那之前获取数据，在旧的<strong class="kq io">组件中。大部分时间都在获取数据，异步运行，所以不能保证它会在<strong class="kq io"> render() </strong>之前完成</strong></p><p id="6771" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并且我们在<strong class="kq io"> render() </strong>内部使用<strong class="kq io"> this.state.listData </strong>。有些时候，我们会忘记状态的初始默认值→崩溃。所以取入<strong class="kq io"> componentDidMount </strong>，就像提醒我们初始默认状态值。</p><h1 id="8611" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">更新阶段:</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/1192524a513763253730146e7edd6fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAGbgPCh-9hUep6iH3pyGA.png"/></div></div></figure><p id="7bff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">setState 对组件的更新/渲染进行排队，这是通知组件开始更新过程的一种方式。<strong class="kq io">设置状态</strong>将触发更新，无论新的状态值是否改变。而使用状态的<strong class="kq io">设置器检查这一点——使用对象的浅相等。</strong></p><p id="3159" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> shouldComponentUpdate </strong>是一个内置的生命周期，如果return <strong class="kq io"> false </strong>则作为优化渲染(跳过渲染)的一种方式提供，对于我们并不总是需要优化的，其默认行为是return <strong class="kq io"> true </strong>。</p><p id="929d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">getsnapshotbefore update</strong>在最近渲染的输出提交到真实树之前被调用。它为任何特殊计算提供了对prevProps和prevState的访问，以在提交到真实树之前捕获渲染节点，返回值被传递给<code class="fe ot ou ov oj b">componentDidUpdate</code>。无论如何，仍然不是一个普遍使用的生命周期</p><p id="c171" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> componentDidUpdate </strong>在更新后立即被调用，而不是在第一次安装组件时发生。利用这个机会来处理与改变新道具&amp;状态相关的副作用。如果您的组件实现了<code class="fe ot ou ov oj b">getSnapshotBeforeUpdate()</code>生命周期(这种情况很少见)，它返回的值将作为第三个“快照”参数传递给<code class="fe ot ou ov oj b">componentDidUpdate()</code>。否则该参数将是未定义的。</p><h1 id="ed31" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">破坏阶段:</h1><p id="df93" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">这个名字已经是显而易见的家伙^^</p><h2 id="2d56" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak"> — — —功能部件————</strong></h2><p id="82aa" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">自<a class="ae ow" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">释放<strong class="kq io">钩子</strong> </a> <strong class="kq io"> </strong>在React 16.8。用钩子<a class="ae ow" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">使用状态</strong> </a>为功能组件提供状态能力。万岁！</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="808e" class="lk ll in oj b gy on oo l op oq">function Counter () {<br/>  const [count, setCount] = useState(0);<br/>...</span><span id="3691" class="lk ll in oj b gy or oo l op oq">}</span></pre><blockquote class="ox oy oz"><p id="2c31" class="ko kp pa kq b kr ks jo kt ku kv jr kw pb ky kz la pc lc ld le pd lg lh li lj ig bi translated">有了Hook的力量，我个人不再关心生命周期，因为减少定义/概念的数量是Hook的原因之一。</p></blockquote><h1 id="f3cc" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">初始阶段</strong></h1><p id="4378" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">与类不同，函数的本质是<strong class="kq io">捕获值</strong>。因此，当渲染发生时，它会重新运行该函数，并使用当前版本的数据重新绘制UI。钩子很可能充当普通对象，对于每个渲染都有自己的版本。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="6a5c" class="lk ll in oj b gy on oo l op oq">const hook: Hook = {   <br/> memoizedState: null,   <br/> baseState: null,   <br/> baseQueue: null,   <br/> queue: null,   <br/> next: null, <br/>};</span></pre><p id="6e95" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> useState </strong>只是内置的挂钩之一。基本上它们共享和上面一样的对象结构。</p><p id="e237" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React将启动<strong class="kq io">安装状态</strong>。基本的想法是通过<strong class="kq io">mountWorkInProgressHook()</strong>安装一个钩子，开始时是这样的</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="df87" class="lk ll in oj b gy on oo l op oq">{   <br/> memoizedState: null,   <br/> baseState: null,  <br/> baseQueue: null,   <br/> queue: null,    <br/> next: null, <br/>}</span></pre><p id="79ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在末尾，钩子变成:(初始状态= 0的例子)</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="86b3" class="lk ll in oj b gy on oo l op oq">{<br/>  memoizedState: 0, // our initial state<br/>  baseState: 0, // our initial state<br/>  queue: {<br/>    last: null,<br/>    dispatch: dispatchAction.bind(null, currentlyRenderingFiber, queue),<br/>    lastRenderedReducer: basicStateReducer(state, action),<br/>    lastRenderedState: 0, // our initial state<br/>  },<br/>  baseUpdate: null,<br/>  next: null,<br/>}</span></pre><p id="7438" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">【hook . memoizedstate，dispatch】</strong>准备返回</p><p id="2e0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">【计数，设置计数】</strong> =使用状态(0)</p><p id="ea33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React向我们展示了作为函数的钩子，但是在幕后，它们被建模为对象。</p><p id="3909" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是<strong class="kq io">挂载状态的详细信息:</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="d0f8" class="lk ll in oj b gy on oo l op oq">function mountState&lt;S&gt;(  initialState: (() =&gt; S) | S,): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] { <br/> const hook = mountWorkInProgressHook();  </span><span id="3831" class="lk ll in oj b gy or oo l op oq"> if (typeof initialState === 'function') {   <br/>  initialState = initialState();  <br/> } <br/> hook.memoizedState = hook.baseState = initialState;  </span><span id="6291" class="lk ll in oj b gy or oo l op oq"> const queue = (hook.queue = {<br/>   pending: null, <br/>   dispatch: null,  <br/>   lastRenderedReducer: basicStateReducer,  <br/>   lastRenderedState: (initialState: any), <br/> }); </span><span id="92c8" class="lk ll in oj b gy or oo l op oq">const dispatch: Dispatch&lt;BasicStateAction&lt;S&gt;,  &gt; = (<br/>queue.dispatch = (dispatchAction.bind(null,currentlyRenderingFiber,queue): any)<br/>);  </span><span id="212e" class="lk ll in oj b gy or oo l op oq">return [hook.memoizedState, dispatch];<br/>}<br/></span></pre><h1 id="1400" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">更新阶段</h1><p id="aded" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">每次<strong class="kq io"> setCount </strong>(上面的例子)触发我们的组件重新渲染时，钩子都会记忆新的状态，这就是用新钩子值更新新渲染的方式。</p><p id="18b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，再看一下我们当前的挂钩价值:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="de0a" class="lk ll in oj b gy on oo l op oq">{<br/>  memoizedState: 0, // our initial state<br/>  baseState: 0, // our initial state<br/>  queue: {<br/>    last: null,<br/>    dispatch: dispatchAction.bind(null, currentlyRenderingFiber, queue),<br/>    lastRenderedReducer: basicStateReducer(state, action),<br/>    lastRenderedState: 0, // our initial state<br/>  },<br/>  baseUpdate: null,<br/>  next: null,<br/>}</span></pre><p id="7a28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> dispatchAction.bind(null，currentlyRenderingFiber，queue) → currentlyRenderingFiber。</strong></p><p id="efe1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">纤程是一个可变的对象，保存组件状态并表示树。React生成这些对象的树，这就是它如何建模整个组件树。我称之为一个组件的代表。<strong class="kq io">每种成分都有自己的纤维。纤维用于识别成分。</strong></p><p id="6a56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">纤程有一个属性叫做<a class="ae ow" href="https://github.com/facebook/react/blob/b53ea6ca05d2ccb9950b40b33f74dfee0421d872/packages/react-reconciler/src/ReactFiber.js#L125" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> memoizedState </strong> </a>。它存储我们的<strong class="kq io">计数器</strong>组件的状态。它的值是我们在上面的<strong class="kq io"> mountState </strong>创建的钩子对象，其中<strong class="kq io"> next </strong>和<strong class="kq io"> baseUpdate </strong>属性为空。</p><p id="f901" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，如果我们的组件有更多的钩子:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="84f1" class="lk ll in oj b gy on oo l op oq">function Counter () {<br/>  const [count, setCount] = useState(0);<br/>  const [check, setIsCheck] = useState(true);</span><span id="189e" class="lk ll in oj b gy or oo l op oq">...<br/>}</span></pre><p id="1c07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们对<strong class="kq io">纤程</strong>的<strong class="kq io">记忆状态</strong>将是:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="b9d1" class="lk ll in oj b gy on oo l op oq">{<br/>  memoizedState: 0, // the setCount hook<br/>  baseState: 0,<br/>  queue: { /* ... */},<br/>  baseUpdate: null,<br/>  next: { // the setIsCheck hook<br/>    memoizedState: true, <br/>    baseState: true,<br/>    queue: { /* ... */},<br/>    baseUpdate: null,<br/>    next: null<br/>  }<br/>}</span></pre><p id="7c13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">组件的钩子是LinkedList的实现。</p><p id="61b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在安装时，创建了一个<strong class="kq io">钩型开发</strong>阵列。用来标识钩子的顺序。顺序很重要，所以有<a class="ae ow" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">规则的钩子</strong> </a>防止你破坏它的实现。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="f99d" class="lk ll in oj b gy on oo l op oq">['useState', 'useState',...] // array of order hook types</span></pre><p id="0484" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="e7fb" class="lk ll in oj b gy on oo l op oq">function Counter () {<br/>  const [count, setCount] = useState(0);<br/>  const [anotherCount, setAnotherCount] = useState(0);<br/>  const [check, setIsCheck] = useState(true);<br/>  useEffect(()=&gt;{<br/>   console.log("hello world")<br/>  },[])<br/>...</span><span id="a41f" class="lk ll in oj b gy or oo l op oq">}</span><span id="9dd0" class="lk ll in oj b gy or oo l op oq">hooktypes will be<br/>==&gt; ['useState', 'useState', 'useState', 'useEffect']</span></pre><p id="df45" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个想法<strong class="kq io"> mountHookTypesDev(): </strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="e3b2" class="lk ll in oj b gy on oo l op oq">const hookName = ((currentHookNameInDev: any): HookType);    <br/>if (hookTypesDev === null) {   <br/>  hookTypesDev = [hookName];<br/>} else { <br/> hookTypesDev.push(hookName);  <br/>}</span></pre><p id="a5f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">HookTypes存储在<strong class="kq io">纤程内的<strong class="kq io"> _debugHookTypes </strong>属性中。</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2119" class="lk ll in oj b gy on oo l op oq">// Used to verify that the order of hooks does not change between renders.  <br/>_debugHookTypes?: Array&lt;HookType&gt; | null,</span></pre><p id="beb9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当运行<strong class="kq io"> setCount </strong>触发更新时，<strong class="kq io"> updateHookTypesDev() </strong>被<strong class="kq io"> </strong>调用，它使用index检查<strong class="kq io"> HookTypesDev </strong>的值<strong class="kq io"> "hookName" </strong>是否等于<strong class="kq io"> currentHookNameInDev </strong>。保证LinkedList钩子的顺序，所以<strong class="kq io">这种方法有助于更新正确的钩子。</strong></p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="24ed" class="lk ll in oj b gy on oo l op oq">const hookName = ((currentHookNameInDev: any): HookType); <br/>if (hookTypesDev !== null) {      <br/> hookTypesUpdateIndexDev++;      <br/> if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {  <br/>   warnOnHookMismatchInDev(hookName);      <br/> }<br/>}</span></pre><p id="d5d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<strong class="kq io">将Count </strong>设置为1后，最终结果将是</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="bc19" class="lk ll in oj b gy on oo l op oq">{<br/>  memoizedState: 1, // our new state<br/>  baseState: 1, // our new state<br/>  queue: {<br/>    last: {<br/>      expirationTime: 1073741823,<br/>      suspenseConfig: null,<br/>      action: 1,<br/>      eagerReducer: basicStateReducer(state, action),<br/>      eagerState: 1, // our new state<br/>      next: { /* ... */},<br/>      priority: 98<br/>    },<br/>    dispatch: dispatchAction.bind(null, currentlyRenderingFiber, queue),<br/>    lastRenderedReducer: basicStateReducer(state, action),<br/>    lastRenderedState: 1, // our new state<br/>  },<br/>  baseUpdate: {<br/>    expirationTime: 1073741823,<br/>    suspenseConfig: null,<br/>    action: 1,<br/>    eagerReducer: basicStateReducer(state, action),<br/>    eagerState: 1, // our new state<br/>    next: { /* ... */},<br/>    priority: 98<br/>  },<br/>  next: null,<br/>}</span></pre><p id="cd78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很多都变了。最重要的是<code class="fe ot ou ov oj b">queue.last</code>和<code class="fe ot ou ov oj b">baseUpdate</code>。它们包含关于刚刚更新的动作的信息。</p><p id="ad22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我就不深究了，就此打住。我的任务是向你介绍hook是如何实现的。更多信息，你可以在这里找到<a class="ae ow" href="https://github.com/facebook/react/blob/27659559ebfd6b7119bfc0ff02ecb851c135020c/packages/react-reconciler/src/ReactFiberHooks.new.js" rel="noopener ugc nofollow" target="_blank">。现在我们继续。</a></p><h1 id="2307" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">为什么异步？</strong></h1><p id="b351" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">您可能知道更新状态是异步进行的，这意味着更新后的值不会立即显示出来。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/11edf0eb1fbd7d6fc670222c18356ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBboHeM2mFtDTHiGSQkYJw.png"/></div></div></figure><p id="4aac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在setCount调用之后记录计数值，返回旧值0，这不是我们所期望的。有时我发现新手在群组上发布问题，问为什么他们的价值还是一样。</p><p id="0f83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为<strong class="kq io">异步。</strong></p><p id="c001" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看他们为什么这样设计。</p><h2 id="00fe" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak"> 1。配料更新</strong></h2><p id="509b" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">当他们设计API时，React团队知道，在现实工作中，有些情况需要我们一次触发多个更新。想象一下连续运行多个更新过程会导致多么糟糕的性能问题。渲染批处理是指对<code class="fe ot ou ov oj b">setState()/useState setter</code>的多次调用导致单个渲染过程被排队并执行。</p><p id="3061" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我按下按钮，它增加<strong class="kq io">计数</strong>三次，我们期望最终计数值= 3。不幸的是，因为更新状态是异步工作的，所以计数值等于0，并且在整个函数中保持不变，所以不管setCount 执行多少次，执行总是0 + 1。这就是为什么count = 1。这是当你根据以前的状态计算时发生的情况，要小心！</p><p id="3cb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<strong class="kq io"> <em class="pa"> setIsCheck </em> </strong> <em class="pa">，它不是基于prevState计算的，所以它像我们预期的那样工作，最终值为</em> <strong class="kq io"> <em class="pa"> true。</em> </strong></p><p id="e976" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尽管如此，它只对<strong class="kq io">一个渲染过程进行排队=== &gt; </strong>批处理更新。您可以通过在<strong class="kq io"> useEffect </strong>中记录来测试它</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2bd7" class="lk ll in oj b gy on oo l op oq">const<em class="pa"> </em>[<em class="pa">count</em>,<em class="pa"> setCount</em>]<em class="pa"> </em>=<em class="pa"> useState</em>(0)<br/>const<em class="pa"> </em>[<em class="pa">isCheck</em>,<em class="pa"> setIsCheck</em>]<em class="pa"> </em>=<em class="pa"> useState</em>(false)</span><span id="2716" class="lk ll in oj b gy or oo l op oq">const<em class="pa"> onPress </em>=<em class="pa"> </em>()<em class="pa"> </em>=&gt;<em class="pa"> </em>{<br/> <em class="pa">setCount</em>(count<em class="pa"> </em>+<em class="pa"> </em>1) // 0+1<br/> <em class="pa">setCount</em>(count<em class="pa"> </em>+<em class="pa"> </em>1) // 0+1<br/> <em class="pa">setCount</em>(count<em class="pa"> </em>+<em class="pa"> </em>1) // 0+1</span><span id="bed3" class="lk ll in oj b gy or oo l op oq"><em class="pa">setIsCheck(true)<br/>setIsCheck(false)<br/>setIsCheck(true)</em></span><span id="ac3b" class="lk ll in oj b gy or oo l op oq">//evaluate to <br/>this.setState({count: this.state.count +1})<br/>this.setState({count: this.state.count +1})<br/>this.setState({count: this.state.count +1})</span><span id="3ce2" class="lk ll in oj b gy or oo l op oq">//<em class="pa"> the final result: count = 1, isCheck = true<br/></em>}</span></pre><p id="18d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">API允许我们访问状态的先前值，因此我们可以基于旧值计算新值。这种方法在渲染过程之前暴露状态的值，并且使用该值进行计算是非常好的。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="7b7e" class="lk ll in oj b gy on oo l op oq">const<em class="pa"> </em>[<em class="pa">count</em>,<em class="pa"> setCount</em>]<em class="pa"> </em>=<em class="pa"> useState</em>(0)<br/>const<em class="pa"> </em>[<em class="pa">isCheck</em>,<em class="pa"> setIsCheck</em>]<em class="pa"> </em>=<em class="pa"> useState</em>(false)</span><span id="803c" class="lk ll in oj b gy or oo l op oq">const<em class="pa"> onPress </em>=<em class="pa"> </em>()<em class="pa"> </em>=&gt;<em class="pa"> </em>{<br/> <em class="pa">setCount</em>(prevCount =&gt; prevCount<em class="pa"> </em>+<em class="pa"> </em>1) // 0+1<br/> <em class="pa">setCount</em>(prevCount =&gt; prevCount<em class="pa"> </em>+<em class="pa"> </em>1) // 1+1<br/> <em class="pa">setCount</em>(prevCount =&gt; prevCount<em class="pa"> </em>+<em class="pa"> </em>1) // 2+1</span><span id="2487" class="lk ll in oj b gy or oo l op oq"><em class="pa">setIsCheck(true)<br/>setIsCheck(false)<br/>setIsCheck(true)</em></span><span id="43a5" class="lk ll in oj b gy or oo l op oq">//evaluate to <br/>this.setState(prevState =&gt; {count: prevState.count +1})<br/>this.setState(prevState =&gt; {count: prevState.count +1})<br/>this.setState(prevState =&gt; {count: prevState.count +1})</span><span id="572d" class="lk ll in oj b gy or oo l op oq">//<em class="pa"> the final result: count = 3, isCheck = true<br/></em>}</span></pre><h2 id="b86e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">不中断批量更新</h2><p id="7f35" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">需要注意的是，React只会对事件处理程序中发生的更新进行批处理。这意味着<strong class="kq io">任何在实际立即调用堆栈外排队<em class="pa">的状态更新将<em class="pa">而不是</em>被一起</em></strong>批处理。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="2d5a" class="lk ll in oj b gy on oo l op oq">const [counter, setCounter] = useState(0)<br/><br/>const onPress = async () =&gt; {<br/>  setCount(0) <br/>  setCount(1) // 1st render pass<br/>  <br/>  const data = await fetchSomeData()<br/>  <br/>  setCount(2) // 2nd render pass<br/>  setCount(3) // 3rd render pass<br/>}</span></pre><p id="8db0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将是3个渲染过程。</p><p id="dde8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个渲染过程是对<strong class="kq io"> setCount(0) </strong>和<strong class="kq io"> setCount(1) </strong>的批处理，因为它们在同一个事件处理程序中被调用</p><p id="445b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二遍渲染发生在<strong class="kq io"> setCount(2) </strong>，因为原始事件的同步已经完成，在<strong class="kq io">等待fetchData </strong>之后，React开始新的调用。</p><p id="4b09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，第三个渲染过程对<strong class="kq io"> setCount(3) </strong>发生同样的事情，因为它也在原始事件之外运行，所以输出批处理</p><p id="c6fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种情况经常发生，而且不完全是坏事。此外，我见过很多人做类似于<strong class="kq io">的事情，等待this.setState() </strong>来等待状态更新并获取当前值，这也破坏了批处理特性。换句话说，它们由于等待状态值而无意中中断了批量更新，并将其用于下一次计算。这可以考虑<strong class="kq io">处理副作用</strong>(我们在下一节学习)。</p><h2 id="a53d" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">2.保证内部一致性</h2><p id="f076" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">即使<code class="fe ot ou ov oj b">state</code>同步更新，<code class="fe ot ou ov oj b">props</code>也不是。在你重新渲染父组件之前，你无法知道<code class="fe ot ou ov oj b">props</code>，如果你同步做这件事，批处理没有任何用处。</p><p id="c025" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">==&gt; <code class="fe ot ou ov oj b">state</code>、<code class="fe ot ou ov oj b">props</code>、<code class="fe ot ou ov oj b">refs</code>在React内部是内部一致的，通过React核心概念中的用法很容易看出这一点。</p><p id="ecdb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们允许同步更新<code class="fe ot ou ov oj b">state</code>。这个管用！</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="5b4d" class="lk ll in oj b gy on oo l op oq">console.log(count) // 0<br/>setCount(count + 1)<br/>console.log(count) // 1<br/>setCount(count + 1)<br/>console.log(count) // 2</span></pre><p id="3aa8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，假设有一天其他子组件需要使用<code class="fe ot ou ov oj b">count</code>，那么你必须重构<strong class="kq io">并将</strong>提升到你的父组件，以共享你的<code class="fe ot ou ov oj b">state</code>。这很常见。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="bbdf" class="lk ll in oj b gy on oo l op oq">props.onIncrement() // does the same thing - increase count + 1</span></pre><p id="8ab2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这打破了</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="3f0b" class="lk ll in oj b gy on oo l op oq">console.log(props.count) // 0<br/>props.onIncrement();<br/>console.log(props.count) // 0<br/>props.onIncrement();<br/>console.log(props.count) // 0</span></pre><p id="b6ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为如果<code class="fe ot ou ov oj b">state</code>同步工作的话，<code class="fe ot ou ov oj b">state</code>会立即刷新，而<code class="fe ot ou ov oj b">props.count</code>不会。我们不能在不重新渲染父组件的情况下立即刷新<code class="fe ot ou ov oj b">props</code>，如果我们这样做，就会破坏批处理。</p><h1 id="6d55" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated"><strong class="ak">副作用</strong></h1><p id="96c7" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated"><strong class="kq io">副作用</strong>是在我们改变了某样东西或者它不是纯粹的功能之后发生的影响/作用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/bebcce1d1062cfd49cf4358da5c75a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pisDB4pcghiyrkfMNHKthA.jpeg"/></div></div></figure><p id="ecb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与<code class="fe ot ou ov oj b">state</code>一起工作很可能总会想到<strong class="kq io">的副作用。</strong></p><p id="6acc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">问自己这个问题:</p><blockquote class="ox oy oz"><p id="952a" class="ko kp pa kq b kr ks jo kt ku kv jr kw pb ky kz la pc lc ld le pd lg lh li lj ig bi translated">这种状态改变后，接下来会发生什么？</p></blockquote><p id="96e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你的文字从黑色变成红色了吗？</p><p id="f6c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你的名字会从库什变成艾尔莎吗？</p><p id="902e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您是否必须根据新状态获取另一个数据？</p><p id="cb23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">兄弟，接下来会发生什么？</p><blockquote class="nm"><p id="57f5" class="nn no in bd np nq nr ns nt nu nv lj dk translated">一种状态的变化会导致其他一些变化</p></blockquote><p id="64da" class="pw-post-body-paragraph ko kp in kq b kr pf jo kt ku pg jr kw kx ph kz la lb pi ld le lf pj lh li lj ig bi translated">如果您的状态发生了变化，而没有任何事情发生，您可能不需要使用状态。相反，您可以使用其他类型的变量来存储数据，因为它不需要触发渲染过程。</p><p id="eded" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我有一个<code class="fe ot ou ov oj b">state</code>存储城市名称，一个<code class="fe ot ou ov oj b">Text</code>显示它。有了这个城市名，我就可以获取该城市街道的数据。所以我的城市<code class="fe ot ou ov oj b">state</code>是用来显示和取数据的。我不想把它分解成普通变量来获取街道数据，因为我想要<strong class="kq io">单值的</strong>。在这种情况下，获取数据是一个副作用，每次我换城市时都会发生。</p><p id="3c20" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React提供了一些方法来处理根据<code class="fe ot ou ov oj b">state</code>变化发生的副作用，允许您访问新的状态值。</p><h2 id="d895" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">类别组件</h2><ol class=""><li id="481c" class="md me in kq b kr mf ku mg kx mh lb mi lf mj lj pk ml mm mn bi translated"><code class="fe ot ou ov oj b">setState</code>的回调:</li></ol><p id="b8b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ot ou ov oj b">setState</code>带有回调作为第二个参数。这是一个我们知道我们的<code class="fe ot ou ov oj b">state</code>已经完成更新的地方。所以我们可以访问新的<code class="fe ot ou ov oj b">state</code>值，而不会犯任何不好的错误，比如<code class="fe ot ou ov oj b">await</code>中断批量更新(如上所述)。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="6184" class="lk ll in oj b gy on oo l op oq">this.setState(<br/> { city: newCity },<br/> ()=&gt; this.fetchStreets(this.state.city)<br/>)</span></pre><p id="f0ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.<code class="fe ot ou ov oj b"><a class="ae ow" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank">componentDidUpdate()</a></code>T18:</p><p id="ea2f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个生命周期也可以处理副作用。但是要小心无限更新。一般都要用比较级。</p><h2 id="2a28" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">功能组件</h2><ol class=""><li id="f366" class="md me in kq b kr mf ku mg kx mh lb mi lf mj lj pk ml mm mn bi translated"><code class="fe ot ou ov oj b">useEffect</code>:</li></ol><p id="5c71" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个参数用于数组依赖的useEffect非常适合处理各种副作用。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="6b6c" class="lk ll in oj b gy on oo l op oq">const [city, setCity] = useState("")</span><span id="9054" class="lk ll in oj b gy or oo l op oq">useEffect(()=&gt;(<br/>fetchStreets(city)<br/>), [city])</span></pre><p id="b36a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每次<code class="fe ot ou ov oj b">city</code>改变时都会产生效果，包括空的第一个初始值。比起类的方法，我更喜欢这个钩子，因为我可以不用担心每次改变城市时忘记运行<code class="fe ot ou ov oj b">fetchStreets()</code>而类的方法必须在<code class="fe ot ou ov oj b">componentDidMount()</code>的第一次渲染中调用它，并在以后改变<code class="fe ot ou ov oj b">city</code>时管理它。而且它把我的逻辑分成孤立的块，便于阅读，每一个效果都与<code class="fe ot ou ov oj b">city</code>有关，集中在一个地方。</p><p id="aa6c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">挂钩和功能组件，实现更好的^^</p><p id="d2eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.<code class="fe ot ou ov oj b">useLayoutEffect:</code></p><p id="1044" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这与<code class="fe ot ou ov oj b">useEffect</code>相同，但它在所有DOM/ShadowNodes突变后同步触发。使用它从DOM/ShadowNodes中读取布局并同步重新渲染。</p><p id="7cee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ot ou ov oj b">useEffect</code>是推荐的方式。</p><h1 id="ddf2" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">放置您的状态</h1><p id="8664" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">有时候决定把<code class="fe ot ou ov oj b">state</code>放在哪里对提升我们的表现至关重要。在一个屏幕布局中，充满了父组件和子组件。决定你的<code class="fe ot ou ov oj b">state</code>的位置并不容易</p><p id="48a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以问题是:</p><blockquote class="nm"><p id="159b" class="nn no in bd np nq nr ns nt nu nv lj dk translated">什么因素决定国家地位？</p></blockquote><figure class="nx ny nz oa ob kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pl"><img src="../Images/45cab548ac33f6cff59195d7394affa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBYVJuA1aP7U5Vr3BSu65A.png"/></div></div></figure><p id="4458" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">唯一的答案是国家的目的。</p><p id="3a9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的意思是，国家将被用来做什么？</p><p id="aa75" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它仅用于此组件吗？是，<strong class="kq io">共存状态</strong></p><p id="1b9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它是否用于许多组件(兄弟/父母)？是，<strong class="kq io">解除状态</strong></p><ul class=""><li id="dc47" class="md me in kq b kr ks ku kv kx ni lb nj lf nk lj mk ml mm mn bi translated">共存状态:将状态转移到特定组件，不再需要传递状态。<code class="fe ot ou ov oj b">count</code>仅由<code class="fe ot ou ov oj b">CounterComponent</code>使用时的示例</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/ae0a0809bed98933695ad664d51946bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9Lk673Fg9Ght-HvSHikHA.png"/></div></div></figure><ul class=""><li id="6a93" class="md me in kq b kr ks ku kv kx ni lb nj lf nk lj mk ml mm mn bi translated">提升状态:移动状态到<strong class="kq io">最近的父</strong>。然后状态可以用于父组件和/或通过props传递给子组件。例:我添加了<code class="fe ot ou ov oj b">SlowComponent</code>，<code class="fe ot ou ov oj b">SlowComponent</code>和<code class="fe ot ou ov oj b">CounterComponent</code>都使用相同的<code class="fe ot ou ov oj b">time</code>状态，所以我们把状态提升到<strong class="kq io">它们最近的父</strong>，这里是<code class="fe ot ou ov oj b">App</code></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pm"><img src="../Images/a7f2fda504a207f3abfbb13057501e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxpU5KxehI7zt8GzmvVUGw.png"/></div></div></figure><h1 id="33d4" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">共存状态如何提升性能</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pn"><img src="../Images/e48b362a01fd19cfa1c3fc6df8b957e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gX__zqmdvqF_1ZEklqKwQ.png"/></div></div></figure><p id="868b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们举个例子，我在<code class="fe ot ou ov oj b">SlowComponent</code>中通过<code class="fe ot ou ov oj b">sleep()</code>使用<code class="fe ot ou ov oj b">props.time</code>作为毫秒级延迟(不要介意我的风格lol！只是为了快速)</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="c503" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我将默认的<code class="fe ot ou ov oj b">time</code>延迟设置为1000毫秒时。改变受延迟影响的<code class="fe ot ou ov oj b">count</code>状态。渲染因<code class="fe ot ou ov oj b">time</code>而延迟。</p><h2 id="e8f0" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">为什么会这样？</h2><p id="8d1d" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">在我之前的<a class="ae ow" href="https://medium.com/javascript-in-plain-english/react-native-why-props-references-break-optimizations-79c463ca0723" rel="noopener">帖子</a>中，我描述了渲染过程。简而言之，如果您没有阅读组件内部的更改状态，这将组件标记为需要更新，将渲染过程排队，并从该组件开始，向下循环到其子组件以计算更改。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pq"><img src="../Images/dfe96497a6001f2a95b56e67cdbc4d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGVhUOMAjSHNsiNWR2A63w.png"/></div></div></figure><p id="5141" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们改变<code class="fe ot ou ov oj b">count</code>时，它发生在<code class="fe ot ou ov oj b">App</code>组件层，然后它触发子组件的渲染(<code class="fe ot ou ov oj b">CounterComponent</code>、<code class="fe ot ou ov oj b">SlowComponent</code>)。因为<code class="fe ot ou ov oj b">sleep()</code>函数延迟了<strong class="kq io">渲染阶段</strong>的工作，减慢了React →的计算，导致<strong class="kq io">提交阶段</strong>也变慢了，它减慢了向真实UI树提交更改的速度，即使<code class="fe ot ou ov oj b">CounterComponent</code>已经完成了对其树的diffing，它仍然要等待<code class="fe ot ou ov oj b">SlowComponent</code>，因为它们是同时提交的。</p><h2 id="d7ad" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">让州政府来拯救我们</h2><p id="dba4" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">您可以使用<strong class="kq io"> React.useMemo </strong>，跳过<code class="fe ot ou ov oj b">SlowComponent</code>的渲染，这样当增加<code class="fe ot ou ov oj b">count</code>时，就不必等待<code class="fe ot ou ov oj b">SlowComponent</code></p><p id="4128" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们不希望我们的代码到处都变成丑陋的怪物。更优雅的方法是将<code class="fe ot ou ov oj b">count</code>状态移到<code class="fe ot ou ov oj b">CounterComponent</code>内部，因为<code class="fe ot ou ov oj b">SlowComponent</code>不使用它。而且在<code class="fe ot ou ov oj b">CounterComponent</code>里面换<code class="fe ot ou ov oj b">count</code>的时候，React也不会在意<code class="fe ot ou ov oj b">SlowComponent</code>，更不会去管它有没有差别。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pr"><img src="../Images/a1d6078e89747f09584d2214c63b3c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M7yLKStDuhiGOZ1sSwfXg.png"/></div></div></figure><p id="3012" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">结果是我们现在可以非常快地数数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="po pp l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ps"><img src="../Images/6fbb077b57b3c5a420d64058cf5d0282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUs58reRF4SVVABhUJwPDg.png"/></div></div></figure><p id="9b61" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在实际工作中，这样的情况时有发生。明智地放置状态将有助于避免多余的繁重计算。这就是为什么这很重要！</p><p id="4d5c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">应用程序屏幕通常带有不同UI部分/容器。我们不希望渲染一个小容器触发整个屏幕的渲染，注意你的状态的目的，并正确放置它以获得更好的性能。</p><h1 id="a55b" class="mt ll in bd lm mu mv mw lp mx my mz ls jt na ju lv jw nb jx ly jz nc ka mb nd bi translated">摘要</h1><p id="e9d7" class="pw-post-body-paragraph ko kp in kq b kr mf jo kt ku mg jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">在这篇文章中，总结一下，我们学会了如何利用好状态:</p><ul class=""><li id="fb90" class="md me in kq b kr ks ku kv kx ni lb nj lf nk lj mk ml mm mn bi translated">我们需要它的原因</li><li id="4a4d" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">状态在大渲染图中有什么作用？</li><li id="4220" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">批处理更新、异步，</li><li id="1912" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">写状态时的心理模型:对副作用的思考</li><li id="8e0f" class="md me in kq b kr mo ku mp kx mq lb mr lf ms lj mk ml mm mn bi translated">把我们的状态调整好。</li></ul><p id="e965" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">祝你们愉快！</p></div></div>    
</body>
</html>