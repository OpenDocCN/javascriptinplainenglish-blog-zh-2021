<html>
<head>
<title>Use Proxy for Local State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用代理进行本地状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-proxy-for-local-state-management-b775718eb5b0?source=collection_archive---------3-----------------------#2021-11-06">https://javascript.plainenglish.io/use-proxy-for-local-state-management-b775718eb5b0?source=collection_archive---------3-----------------------#2021-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e4e816c6992c8b8b59b64f4c34478f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4naheE_QC2vV7EkR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f08e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您使用过Redux、Overmind或任何支持全局状态管理需求的工具，您可能非常了解工作流的状态/缩减类型。这篇文章是<strong class="kc io">而不是</strong>讨论如何使用这些软件包。相反，我想探索一些基本需求，比如管理以下状态单元:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="acbc" class="lh li in ld b gy lj lk l ll lm">const counter = {<br/>  count: 1,<br/>  inc: (state, payload) =&gt; {<br/>    state.count += payload<br/>  }<br/>}</span></pre><p id="97be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于一个<code class="fe ln lo lp ld b">counter</code>单元，它支持一个状态，比如<code class="fe ln lo lp ld b">count</code>以及一个改变它的<code class="fe ln lo lp ld b">inc </code>函数。JavaScript最近给了我们一种新的管理对象的方法，叫做代理。它的作用是让您管理对象下的任何属性何时被访问，无论是<code class="fe ln lo lp ld b">get</code>还是<code class="fe ln lo lp ld b">set</code>:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f8f5" class="lh li in ld b gy lj lk l ll lm">const handler  = {<br/>  get: function(target, prop, receiver) { ... },<br/>  set: function(obj, prop, value) {<br/><strong class="ld io">    obj[prop] = value<br/></strong>    return true<br/>  }<br/>}</span><span id="dd70" class="lh li in ld b gy lq lk l ll lm">const p = new Proxy(counter, handler)</span></pre><p id="b785" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前面的代码管理<code class="fe ln lo lp ld b">counter</code>到<code class="fe ln lo lp ld b">p</code>的get/set。这个控制逻辑在一个<code class="fe ln lo lp ld b">handler</code>回调中被捕获。让我们用一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4d02" class="lh li in ld b gy lj lk l ll lm">p.count = 0  // counter[count] = 0<br/>p.count++    // counter[count] = 1</span></pre><p id="5de3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，它只做一个简单的对象<code class="fe ln lo lp ld b">counter</code>。我们需要给它添加一些控制。</p><p id="1ac8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">设定</strong></p><p id="4eda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以对<code class="fe ln lo lp ld b">set</code>有更多的控制。假设我们有一个<code class="fe ln lo lp ld b">options</code>对象，允许我们使用<code class="fe ln lo lp ld b">canSet</code>来决定它是否可以设置一个属性。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cb00" class="lh li in ld b gy lj lk l ll lm">set: function (obj, prop, value) {<br/>  let canSet = true<br/>  if (options.canSet) {<br/>    canSet = options.canSet(obj, prop, value)<br/>  }<br/>  if (canSet) {<br/><strong class="ld io">    obj[prop] = value<br/></strong>  }</span><span id="c9b0" class="lh li in ld b gy lq lk l ll lm">  options.afterSet &amp;&amp; options.afterSet(obj)</span><span id="9521" class="lh li in ld b gy lq lk l ll lm">  return true<br/>}</span></pre><p id="b7ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果<code class="fe ln lo lp ld b">options.canSet</code>返回<code class="fe ln lo lp ld b">false</code>，可以跳过<code class="fe ln lo lp ld b">set</code>。而且在<code class="fe ln lo lp ld b">set</code>之后，我们可以调用一个<code class="fe ln lo lp ld b">options.afterSet</code>回调函数。基本上，我们所做的是用自定义规则来保护一些属性，如果任何属性发生变化，我们也会得到通知。听起来很熟悉？一种国家管理系统。</p><p id="2cf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">得到</strong></p><p id="e4ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们使用下面的代码设计<code class="fe ln lo lp ld b">counter</code>，它将开箱即用。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8845" class="lh li in ld b gy lj lk l ll lm">const counter = { <br/>  count: 1, <br/>  inc: function() { this.count++ } <br/>}</span></pre><p id="f2ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，关键字<code class="fe ln lo lp ld b">this</code>有点复杂，没有人知道它在运行时到底是什么。此外，我们希望<code class="fe ln lo lp ld b">inc</code>在改变到下一个状态之前获得当前状态，就像在状态机中一样。为此，我们可以通过<code class="fe ln lo lp ld b">get</code>将其弯曲:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4813" class="lh li in ld b gy lj lk l ll lm">get: function (target, prop, receiver) {<br/>  const value = target[prop]<br/>  if (typeof value === 'function') {<br/>    return function () { <br/>      value.apply(receiver, [<br/>        receiver, ...arguments<br/>      ]) <br/>    }<br/>  }<br/>  return value<br/>}</span></pre><p id="9233" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前面的代码基本上重写了函数方法的<code class="fe ln lo lp ld b">get</code>，比如<code class="fe ln lo lp ld b">counter.inc</code>。它的行为和以前完全一样，除了当它使用函数方法时，它绑定代理对象并注入代理对象作为它的第一个输入参数，并附加输入参数的其余部分。换句话说，你现在可以这样做:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="06d2" class="lh li in ld b gy lj lk l ll lm">const counter = {<br/>  count: 1,<br/>  inc: (state, payload) =&gt; {<br/>    state.count += payload<br/>  }<br/>}</span><span id="8ed9" class="lh li in ld b gy lq lk l ll lm">const p = new Proxy(counter, handler)<br/>p.inc(2)    // count = 3</span></pre><p id="2a6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">调度</strong></p><p id="ca0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这个<code class="fe ln lo lp ld b">get</code>和<code class="fe ln lo lp ld b">set</code>都被调整到一个状态管理系统，我们可以插入调度，例如，在屏幕上呈现一些东西。</p><p id="1403" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以任何一个支持<code class="fe ln lo lp ld b">dispatch</code>功能的<em class="lr"> UI </em>框架为例，这里用<code class="fe ln lo lp ld b">react</code>作为例子。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8c5f" class="lh li in ld b gy lj lk l ll lm">const useProxy = (counter) =&gt; {<br/>  const [, dispatch] = useState(0)</span><span id="3eec" class="lh li in ld b gy lq lk l ll lm">  const [p] = useState(proxy(counter, {<br/>    canSet: (obj, prop, value) =&gt; obj[prop] !== value,<br/>    afterSet: () =&gt; { dispatch(v =&gt; v + 1) }<br/>  }))</span><span id="2b3f" class="lh li in ld b gy lq lk l ll lm">  return p<br/>}</span></pre><p id="f440" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们使用<code class="fe ln lo lp ld b">useState</code>作为我们的主要调度机制，除了我们并不真正关心我们渲染什么，我们只是想在我们决定的时候触发一个渲染。我们从<code class="fe ln lo lp ld b">counter</code>中插入<code class="fe ln lo lp ld b">proxy</code>对象。我们在这里做两件有趣的事情。</p><p id="0096" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一，通过<code class="fe ln lo lp ld b">canSet</code>，我们确保如果<code class="fe ln lo lp ld b">value</code>没有从当前的<code class="fe ln lo lp ld b">obj[prop]</code>改变，那么<code class="fe ln lo lp ld b">set</code>不会起作用。那曾经是<code class="fe ln lo lp ld b">useState</code>的工作:)</p><p id="1ae3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二、如果事情确实是<code class="fe ln lo lp ld b">set</code>，通过<code class="fe ln lo lp ld b">afterSet</code>，我们对屏幕进行调度。这里的<code class="fe ln lo lp ld b">v =&gt; v + 1</code>是一个伪计数器，它只是触发渲染。</p><p id="1035" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ln lo lp ld b">dispatch</code>是一个本地分派，它只尝试从使用这个<code class="fe ln lo lp ld b">useProxy</code>的组件开始更新屏幕。好了，有了这个，让我们把它插入我们的前端代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d6b9" class="lh li in ld b gy lj lk l ll lm">const App = () =&gt; {<br/>  const p = useProxy(counter)<br/>  return &lt;h1&gt;{p.count}&lt;/h1&gt;<br/>}</span></pre><p id="771b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一开始没什么特别的，上面的代码确保我们可以显示当前的计数。但是，如果我们想递增计数器，我们可以这样做</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="df17" class="lh li in ld b gy lj lk l ll lm">&lt;button onClick={() =&gt; { <strong class="ld io">p.count++</strong> }&gt; + &lt;button&gt;</span></pre><p id="d611" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者我们可以</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c9cc" class="lh li in ld b gy lj lk l ll lm">&lt;button onClick={() =&gt; { <strong class="ld io">p.inc(1)</strong> }&gt; + &lt;button&gt;</span></pre><p id="5572" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇哦。也许你没有被打动。也许你是。这是整个练习。请注意我们在哪里定义了所有的状态和动作。是的，他们坐在一个单元里。</p><p id="115b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上是一个简单的例子，如果您对实现感兴趣，您可以看到我在包<code class="fe ln lo lp ld b">proxy-states</code>中发布的一个生产就绪解决方案:</p><p id="f49b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【https://github.com/windmaomao/proxy-state】</p><p id="7372" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">字幕</strong></p><p id="7f65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在一个更复杂的业余爱好项目中使用过这个包。在不讨论它的作用的情况下，我将分享这个独立的单元文件。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f872" class="lh li in ld b gy lj lk l ll lm">const E = require('../shared/events')</span><span id="837b" class="lh li in ld b gy lq lk l ll lm">const DURATION_NORMAL = 1<br/>const DURATION_QUICK = 0.5<br/>const DURATION_PLAY = 2</span><span id="7c14" class="lh li in ld b gy lq lk l ll lm">const _defaultLines = s =&gt; s.split("\n")</span><span id="07f7" class="lh li in ld b gy lq lk l ll lm">const marquee = api =&gt; ({<br/>  // lines of text<br/>  lines: _defaultLines(api.text),<br/>  // line number<br/>  line: 0,<br/>  // font size,<br/>  size: 30,<br/>  // roll speed<br/>  duration: DURATION_NORMAL,<br/>  // text color<br/>  color: '#000',<br/>  // line height<br/>  height: 36,<br/>  // if in editing mode<br/>  editing: false,<br/>  // editing text<br/>  text: '',<br/>  // internal ref<br/>  ref: {<br/>    // auto play tracker<br/>    interval: null,<br/>    // input ref<br/>    input: null<br/>  },</span><span id="8631" class="lh li in ld b gy lq lk l ll lm">  // methods<br/>  initialize: function (m, ipc) {<br/>    ipc.on(E.incSize, () =&gt; { m.increment() })<br/>    ipc.on(E.decSize, () =&gt; { m.decrement() })<br/>    ipc.on(E.rewind, () =&gt; { m.rewind() })<br/>    ipc.on(E.save, () =&gt; { ipc.send(E.text, m.lines.join('\n')) })<br/>    ipc.on(E.next, () =&gt; { m.next() })<br/>    ipc.on(E.prev, () =&gt; { m.prev() })<br/>    ipc.on(E.play, () =&gt; { m.play() })<br/>    ipc.on(E.edit, () =&gt; { !m.editing ? m.edit() : m.display() })<br/>  },<br/>  teardown: function () {<br/>    const { interval } = m.ref<br/>    interval &amp;&amp; clearInterval(interval)<br/>  },<br/>  decrement: function (m) { m.size-- },<br/>  increment: function (m) { m.size++ },<br/>  prev: function (m) { m.line-- },<br/>  next: function (m) { m.line++ },<br/>  rewind: function (m) {<br/>    m.line = 0<br/>    m.duration = DURATION_QUICK<br/>    setTimeout(() =&gt; { m.duration = DURATION_NORMAL }, 500)<br/>  },<br/>  play: function (m) {<br/>    if (m.ref.interval) {<br/>      clearInterval(m.ref.interval)<br/>      m.ref.interval = null<br/>    } else {<br/>      m.ref.interval = setInterval(<br/>        () =&gt; { m.next() },<br/>        DURATION_PLAY * 1000<br/>      )<br/>    }<br/>  },<br/>  edit: function (m) {<br/>    m.text = m.lines[m.line]<br/>    setTimeout(() =&gt; {<br/>      m.ref.input.focus()<br/>    }, 0)<br/>    m.editing = true<br/>  },<br/>  display: function (m) {<br/>    m.lines[m.line] = m.text<br/>    setTimeout(() =&gt; {<br/>      m.ref.input.blur()<br/>    }, 0)<br/>    m.editing = false<br/>  }<br/>})</span><span id="5278" class="lh li in ld b gy lq lk l ll lm">module.exports = marquee</span></pre><p id="5d58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，令人惊讶的部分是该单元是独立的，它还可以与渲染系统集成在一起工作(或者在这种情况下<em class="lr">反应</em>和<em class="lr">电子</em>)。当然，这种力量源于拥有一个redux-kind系统。这一点也不奇怪。然而，如果我们看看这样做的成本，你可能会发现它便宜得多。</p><p id="b7e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lr">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>