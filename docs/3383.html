<html>
<head>
<title>Understanding the New Finalizers and Weak References in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中新的终结器和弱引用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-finalizer-2859f0832f07?source=collection_archive---------7-----------------------#2021-07-09">https://javascript.plainenglish.io/javascript-finalizer-2859f0832f07?source=collection_archive---------7-----------------------#2021-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="180e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES2021将使查找和避免内存泄漏变得更加容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a19d47b06a8817b6acd402a9027c3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG56bPUe_EcmWgoUkkxJ6w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="bcf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript正在发展。所有这些<em class="lr">新的JavaScript特性2021 </em>文章都很好，但还不是很完整。在我看来，尤其是那些相当新的所谓的<em class="lr">终结者</em>没有得到应有的关注。ECMAScript 2021中引入了终结器。</p><p id="575e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最酷的是，如果我们已经理解了终结器，它会直接帮助我们理解其他新特性:WeakMap、WeakSet和一般的弱引用。</p><p id="3d4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但首先:理解这个的动机是什么？<br/>这是关于内存泄漏和性能的。</p><p id="fdd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您已经知道什么是内存泄漏，请随意跳到下一个标题。</p><p id="8991" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当内存被使用但没有被释放时，就会发生内存泄漏。整个事情没有听起来那么复杂。当您在代码中创建数组时，它需要内存。然而，由于V8引擎，浏览器&amp; Node.js中的JavaScript有一个垃圾收集器。</p><p id="6b74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着，例如，不再需要的变量将被清除，从而释放内存。</p><h1 id="99a7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">典型的内存泄漏，以及我们如何检测它</h1><p id="db60" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">毕竟，如果V8垃圾收集清理了所有不必要的东西，那么一切都很好，不是吗？是的，事实上，它是。但问题是垃圾收集器并不总是正确地识别出什么是不必要的。</p><p id="e9b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个典型的内存泄漏:全局范围内所有初始化的变量都不会被清除。例如，以下代码会导致内存泄漏:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="90a1" class="mu lt iq mq b gy mv mw l mx my">let bigArray;</span><span id="8e7c" class="mu lt iq mq b gy mz mw l mx my">setTimeout(function() { <br/>  bigArray = new Array(9999999)<br/>}, 5000)</span></pre><p id="5079" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于<em class="lr">大数组</em>是在全局范围内声明的，所以永远不会被清理。<br/>想看证明？好吧，这就是终结器最终发挥作用的地方。</p><h1 id="8f99" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">了解FinalizationRegistry类</h1><p id="882c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我觉得这个名字有点令人困惑。所谓的终结器的工作非常简单:它们观察一个传递的对象，并在垃圾收集器移除该对象时通知我们。</p><p id="0a4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们为垃圾收集器将要移除的对象初始化一个终结器。<br/>提示:这段代码可以在浏览器或Node.js中运行，但是我建议您在Node.js中运行它进行实验。(在那里手动调用垃圾收集器更容易)。</p><p id="02cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">终结器本身是下面的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="54f5" class="mu lt iq mq b gy mv mw l mx my">const registerFinalizer = new FinalizationRegistry(message =&gt; {<br/>  console.log(message)<br/>});</span></pre><p id="2d38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它将一些数据作为参数，我用它来记录哪些对象已经被GC移除(我暂时称之为垃圾收集器GC)。</p><p id="75b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们想要观看一个对象时，我们需要注册它。因为全局范围内的变量没有被清除，所以我创建了一个自调用函数。在这个上下文中声明的每个变量如果不再被使用，都将被GC清除。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="050e" class="mu lt iq mq b gy mv mw l mx my">(function() {<br/>  let arr = new Array(100000).fill("A")<br/>  registerFinalizer.register(arr, "Huge array is now cleaned up")<br/>} () )</span></pre><p id="6e28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让这段代码永远运行，我们在末尾添加了一个<em class="lr"> setInterval </em>，所以程序永远不会终止。以下是完整的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="68cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您现在运行它，并等待几秒钟，您应该在控制台中看到“巨大的数组现在被清理”。酷吧。</p><p id="d35e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个简单的问题使我们的实验有点难看:我们永远不知道GC什么时候开始清理——因此，证明某些东西在某个点被清理是很麻烦的。</p><p id="93c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢上帝，我们可以在我们的one上调用GC——正如我所说的，这在Node.js中效果最好。</p><p id="97d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们证明GC从不删除全局变量:</p><p id="117e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe nc nd ne mq b">global.gc()</code>我们可以手动调用垃圾收集器。重要:你需要像这样运行你的代码:<code class="fe nc nd ne mq b">node --expose-gc index.js</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4884" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您运行代码时，即使我们多次调用GC，消息“巨大的数组现在被清理”也不会出现。</p><p id="046e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，registerFinalizers帮助我们检查GC是否移除了一个对象。这对于优化和测试你的应用非常有价值。<br/>但我们还没有完成——我现在将向您介绍另一个新概念。</p><p id="b8d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多亏了终结器，我们现在可以更好地检测内存泄漏。但是如何避免它们呢？JavaScript为此提供了新的武器。此外，较老的WeakSet和WeakMap使用相同的概念。对于示例，我将坚持使用WeakMap。首先，理解概念很重要。</p><h1 id="c054" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">了解WeakMap</h1><p id="432d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我相信你知道JavaScript中的Map-object。它允许我们在其中保存一个键值对——不要与map函数混淆！像所有事情一样，很容易导致内存泄漏。</p><p id="e345" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">提醒:</strong>如果有东西引用了这个对象，GC会认为它仍然是需要的。这里有一个例子。</p><p id="5f45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，我们有一个数组，这次我们称它为<em class="lr"> arr </em>，在一个函数的范围内。不使用时，应由GC将其移除。感谢我们的终结器，我们可以跟踪数组是否被移除以及何时被移除。不幸的是，在全局范围内创建的Map保存了我们的<em class="lr">arr</em>——因此，GC认为仍然需要这个数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9476" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您在浏览器或节点中复制并运行此代码时，应该会看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/7803269036b1b8a6d0793cb0e971a8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WU2LRE29geD6o-GuVu_KfA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="6810" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的arr继续存在，永远不会被GC删除。为什么？因为它被地图“利用”了——典型的内存泄露，也是我们地图相当嚣张的行为。感谢上帝，还有一种选择WeakMap。</p><p id="1873" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakMap只保存一个作为键接收的对象的弱引用。<strong class="kx ir">重要:</strong>键必须是对象。但是弱引用是什么意思呢？</p><p id="d9eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakMap不会让GC认为它持有的对象仍然被使用。因此，WeakMap可以为了释放内存而删除一个键。这很谦虚，不是吗？</p><p id="48c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们所需要改变的就是把<code class="fe nc nd ne mq b">let arrCollection = new Map()</code>变成<code class="fe nc nd ne mq b">let arrCollection = new WeakMap()</code>。我还在自调用函数之后添加了一个<code class="fe nc nd ne mq b">console.log(arrCollection)</code>,以检查WeakMap是否持有它应该持有的东西。</p><p id="4d21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我建议您在浏览器中运行更改后的代码(如果不使用<a class="ae ng" href="https://nodejs.org/api/util.html#util_util_inspect_object_showhidden_depth_colors" rel="noopener ugc nofollow" target="_blank"> util.inspect </a>，Node不知何故无法向我们显示WeakMap的内容)。</p><p id="e0fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您在浏览器中运行此代码时，您可以看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2e3f6a12dcda97cbf9db97efb6b3439c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*vB33RfoCjuCHqlh1rCCMCg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="3216" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您没有立即看到这一点，请不要担心。</p><p id="188f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有时总检察长开始工作需要时间。您可以使用以下命令在浏览器中手动启动GC:</p><ol class=""><li id="a7ef" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated">打开chrome开发工具。</li><li id="1360" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">点击右上角的三个点。选择“运行命令”</li><li id="d998" class="ni nj iq kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated">搜索并点击“收集垃圾”</li></ol><p id="0d72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦GC完成，我们的WeakMap就是空的(正如你在上面的截图中看到的)。是的，因为WeakMap只保存一个弱引用，所以删除了数组。</p><p id="7188" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakSet和WeakRef在引擎盖下使用了相同的概念。它们帮助我们避免内存泄漏和不必要的内存使用。<br/>一般用例？在我看来，<a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">developer.mozilla.org</a>总结得很好:</p><blockquote class="nw nx ny"><p id="807a" class="kv kw lr kx b ky kz jr la lb lc ju ld nz lf lg lh oa lj lk ll ob ln lo lp lq ij bi translated"><em class="iq">“[…]只有在<em class="iq">键没有被垃圾收集的情况下，将键映射到关于有价值的键的信息时</em>”</em></p></blockquote><p id="5349" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！如果您想了解更多关于GC的信息，请访问:</p><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/if-your-code-is-garbage-nodes-garbage-collector-won-t-help-f48d32d3bc9a"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">如果你的代码是垃圾，Node的垃圾收集器就没用了</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">以下是你需要知道的</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><h2 id="b306" class="mu lt iq bd lu ou ov dn ly ow ox dp mc le oy oz me li pa pb mg lm pc pd mi pe bi translated"><a class="ae ng" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的时事通讯，了解最新消息</a></h2></div><div class="ab cl pf pg hu ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="ij ik il im in"><p id="eb9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">更多内容请看</em><a class="ae ng" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="lr">plain English . io</em></strong></a></p></div></div>    
</body>
</html>