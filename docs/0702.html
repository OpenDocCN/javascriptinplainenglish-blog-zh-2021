<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一个MERN堆栈电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-444082ae81bd?source=collection_archive---------2-----------------------#2021-02-13">https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-444082ae81bd?source=collection_archive---------2-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a55" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第5部分:设置客户机和Redux</h2></div><p id="e434" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第五部分中，我们将使用React为我们的应用程序设置客户端，并将使用Redux进行应用程序中的状态管理。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/8ce17b54b76c94bbe0e4f40f965ca908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B14hYVW232ghlnPz"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ef75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">朋友们好！这是MERN堆栈系列的第五部分。在前四部分中，我们详细讨论了应用程序的后端部分——从设置路线到通过stripe接受支付；我们在这四个部分做了所有的后台工作。</p><p id="1503" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有阅读前四部分，我把它们链接在这里给你</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第1部分:设置项目</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第2部分:设计模型</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第3部分:构建身份验证和项目路由和控制器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ml l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第4部分:构建购物车并订购路线和控制器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mm l mg mh mi me mj ll lv"/></div></div></a></div><p id="49bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，从第五部分开始，我们将开始关注前端部分。在这一部分中，我们将开始用React设置项目的客户端，还将利用Redux库来管理React应用程序中的所有状态。</p><p id="7ae9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，首先，我们需要在我们的根文件夹中创建一个新的文件夹(这里有我们所有的后端文件)。我们将这个文件夹命名为<em class="mn">‘客户端’，</em>，我们将所有与客户端相关的文件都放在这个文件夹中。</p><p id="59b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<em class="mn"> create-react-app </em>为我们建立一个react项目，这样我们就不需要处理各种复杂的东西，比如babel和webpack。使用这个命令将使这个过程变得容易得多，并且我们将能够把注意力集中在重要的事情上。</p><p id="5bcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在创建名为<em class="mn"> client、</em>的文件夹后，我们将移动到该文件夹中，并运行以下命令在该文件夹中创建一个新的react应用程序。</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="f459" class="mt mu iq mp b be mv mw l mx my">npx create-react-app .</span></pre><p id="bfbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果您还没有创建<em class="mn"> client </em>文件夹，您可以输入这个命令在名为<em class="mn"> client </em>的文件夹中建立一个新的React项目，然后移动到<em class="mn"> client </em>文件夹中。</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="e956" class="mt mu iq mp b be mv mw l mx my">npx create-react-app client</span></pre><p id="a339" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在我们的应用程序中建立一个新的React项目。我们可以同时运行服务器和客户机，正如我们在本系列的第1部分中同时安装了<em class="mn">和</em>并为此定义了节点脚本。我们需要运行<code class="fe mz na nb mp b">npm run dev</code>来同时运行它们。</p><p id="2543" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，打开客户端文件夹中的<em class="mn"> package.json </em>文件。我们将看到它包含安装的各种依赖项。我们还将安装更多我们将在项目中使用的依赖项。</p><p id="c599" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是客户端的<em class="mn"> package.json </em>文件。看，这里提到了很多依赖。我们将在我们的项目中需要所有这些。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c9bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您已经看到了依赖项，让我们一个接一个地检查一下，看看我们安装了什么，它为我们提供了什么功能。</p><ol class=""><li id="4d85" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> Axios </strong> — Axios将用于与REST APIs交互，并从服务器获取数据。</li><li id="a6ea" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> Bootstrap </strong> — Bootstrap将是我们用来设计前端的前端CSS库。</li><li id="ac02" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> redux — </strong>这是我们将用来管理状态的状态管理库。</li><li id="8420" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> react-redux — </strong>这是redux的react版本，将用于管理我们的应用程序的状态。(由于Redux可以与各种框架和库一起使用。这个是用来反应的。)</li><li id="7edb" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> react-router-dom — </strong>这将管理我们的应用程序的路由。它将帮助我们定义路线，并允许它们从一条路线到另一条路线。</li><li id="3b58" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> redux-thunk </strong> —这是我们将在应用程序中使用的中间件，它将帮助我们管理应用程序的状态。</li><li id="ab73" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> reactstrap </strong> —它是用于引导样式的React版本，允许我们使用引导类作为React组件。</li><li id="c771" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> react-stripe-checkout — </strong>它用于在我们的应用程序中使用stripe来接受支付。</li></ol><p id="1970" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们将设置一个代理，允许我们将请求传输到<em class="mn"> localhost:4000 </em>。因为我们在端口号3000上运行我们的应用程序，并且我们不想编写一个完整的URL来与API交互，所以我们将定义一个代理来将请求从3000传输到4000。</p><p id="e1b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将查看客户端文件夹中的文件。因此，我们将查看<em class="mn"> src </em>文件夹。我们有一个<em class="mn"> index.js </em>文件，在其中我们不需要做任何修改。这里是<em class="mn"> index.js </em>文件:-</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="c8fd" class="mt mu iq mp b be mv mw l mx my">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from './App';<br/><br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="c62b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们来看看<em class="mn"> App.js </em>文件:-</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="0e01" class="mt mu iq mp b be mv mw l mx my">import { Component } from 'react';<br/>import 'bootstrap/dist/css/bootstrap.min.css';<br/><br/>class App extends Component {<br/>  render(){<br/>    return ( <br/>        &lt;div className="App"&gt;<br/>          &lt;h1&gt;Hello everyone!&lt;/h1&gt;<br/>        &lt;/div&gt; <br/>    );<br/>  }<br/>}<br/><br/>export default App;</span></pre><p id="0afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经将<em class="mn">引导程序</em>导入到这个文件中。此外，我们将清除所有预先编写的代码。</p><p id="6632" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，我们将对该文件进行一些修改，以合并Redux状态管理和路由。</p><p id="be0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将开始设置Redux状态管理。我们将在<em class="mn"> src </em>文件夹中创建一个名为<em class="mn"> store.js </em>的新文件。</p><p id="7608" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这是我们的<em class="mn"> store.js </em>文件。它将作为我们州的仓库。要了解这是怎么回事，强烈建议对Redux有一些了解。</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="2115" class="mt mu iq mp b be mv mw l mx my">import { createStore, applyMiddleware, compose } from 'redux';<br/>import thunk from 'redux-thunk';<br/>import rootReducer from './reducers';<br/><br/>const initialState = {};<br/><br/>const middleWare = [thunk];<br/><br/>const store = createStore(rootReducer, initialState, compose(<br/>    applyMiddleware(...middleWare),<br/>    window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()<br/>));<br/><br/>export default store;</span></pre><p id="f7d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你仔细观察，我们已经从reducers文件夹中导入了一些我们到现在还没有创建的东西，即<em class="mn"> rootReducer </em>文件。我们一会儿会做的。</p><p id="5ed8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不明白这是怎么回事，我建议你先学习Redux如何工作，以便更好地理解它。我也相信Redux具有挑战性。</p><p id="9ce4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这里的好消息是我们不需要为了任何目的再次访问这个文件。这是建立Redux商店的标准方式。我们对此无能为力，因为这就是Redux的工作方式。</p><p id="0077" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将开始在<em class="mn"> src </em>文件夹中构建<em class="mn"> actions </em>文件夹。这是标准的Redux方式，有<em class="mn">存储，动作</em>和<em class="mn">减速器。</em></p><p id="0260" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，首先，我们从<em class="mn"> actions </em>文件夹内的<em class="mn"> types.js </em>文件开始。这里我们将定义所有的动作类型。这是重复的做事方式。</p><pre class="lc ld le lf gt mo mp mq bn mr ms bi"><span id="c93d" class="mt mu iq mp b be mv mw l mx my">export const GET_ITEMS = 'GET_ITEMS';<br/>export const ADD_ITEM = 'ADD_ITEM';<br/>export const DELETE_ITEM = 'DELETE_ITEM';<br/>export const UPDATE_ITEM = 'UPDATE_ITEM';<br/>export const ITEMS_LOADING = 'ITEMS_LOADING';<br/><br/>export const CART_LOADING = 'CART_LOADING';<br/>export const GET_CART = 'GET_CART';<br/>export const ADD_TO_CART = 'ADD_TO_CART';<br/>export const DELETE_FROM_CART = 'DELETE_FROM_CART';<br/><br/>export const ORDERS_LOADING = 'ORDERS_LOADING';<br/>export const GET_ORDERS = 'GET_ORDERS';<br/>export const CHECKOUT = 'CHECKOUT';<br/><br/>export const USER_LOADING = 'USER_LOADING';<br/>export const USER_LOADED = 'USER_LOADED';<br/>export const AUTH_ERROR = 'AUTH_ERROR';<br/>export const LOGIN_SUCCESS = 'LOGIN_SUCCESS';<br/>export const LOGIN_FAIL = 'LOGIN_FAIL';<br/>export const LOGOUT_SUCCESS = 'LOGOUT_SUCCESS';<br/>export const REGISTER_SUCCESS = 'REGISTER_SUCCESS';<br/>export const REGISTER_FAIL = 'REGISTER_FAIL';<br/><br/>export const GET_ERRORS = 'GET_ERRORS';<br/>export const CLEAR_ERRORS = 'CLEAR_ERRORS';</span></pre><p id="c52e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们拥有与项目相关的所有类型；接下来，我们有购物车、订单，然后是用户，最后是错误。</p><p id="9048" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这个<em class="mn"> actions </em>文件夹中，我们将有另外五个文件，分别是— <em class="mn"> itemActions、authActions、cartActions、orderActions </em>和<em class="mn"> errorActions </em>。</p><p id="ec12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将在这里逐一处理它们。因此，我们将从errorActions开始，因为这非常简单，不需要与服务器交互。</p><h2 id="f86a" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated">错误操作</h2><p id="24e9" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">这个动作文件中有两个函数。我们有一个用于返回应用程序中的任何错误，另一个用于在不需要显示错误时清除这些错误。</p><p id="93f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个函数将在函数中接收消息、状态和id，并将它们作为GET_ERRORS类型的有效负载返回。</p><p id="29f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个函数是通过将类型作为CLEAR_ERRORS发送来清除错误。</p><p id="8e45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些将在我们将在下一部分构建的错误减少器文件中处理，该文件将处理这些函数指定的状态。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="a8c6" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated">authActions.js</h2><p id="5890" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">这是动作文件中最复杂的部分，因为它将处理所有的认证部分。这部分我们有四个功能——<em class="mn">加载用户，注册，登录</em>和<em class="mn">注销</em>。</p><p id="2c9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还有一个助手函数<em class="mn"> tokenconfig </em>，它将从本地存储中获取令牌，并设置配置以使用loadUser发送请求，从而获取当前登录的用户详细信息。</p><p id="8a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以详细了解这四个函数了</p><ol class=""><li id="1022" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> loadUser </strong> —首先将类型设置为USER_LOADING，表示用户当前正在加载。然后，我们使用Axios向api端点<em class="mn"> '/api/user' </em>以及从<em class="mn"> tokenconfig、</em>获得的令牌发出一个请求，该请求将获得结果并将有效负载设置为从API端点获取的数据。类型将被设置为USER_LOADED，因为我们已经成功加载了用户。如果出现任何错误，我们将调用returnErrors函数，并将类型设置为AUTH_ERROR。</li><li id="b4b8" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> register </strong> —它从前端获取用户名、电子邮件和密码，然后将它们变成一个JSON对象。然后，我们点击API端点来注册并传入数据。然后，我们接收一个响应，并将接收到的数据设置为有效载荷，类型设置为REGISTER_SUCCESS。我们处理错误的方式与前面的函数相同，并将错误类型设置为REFGISTER_FAIL。</li><li id="c878" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">登录</strong> —其工作方式类似于注册功能。不同之处在于，登录函数只获取电子邮件和密码，然后点击API端点进行登录。我们得到一个响应，并将有效负载设置为从响应接收的数据，并将类型设置为LOGIN_SUCCESS。我们以类似的方式处理错误，并将错误类型设置为LOGIN_FAIL。</li><li id="6f4e" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">注销</strong> —我们只需将类型设置为LOGOUT_SUCCESS，这就是我们注销所需要做的一切。</li></ol><p id="bf2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在下一部分描述的reducers文件中处理所有这些响应类型及其有效负载。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="6ccd" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated">项目操作</h2><p id="09b5" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">在这里，我们将处理与项目相关的所有操作，即我们将在网站上显示的产品。</p><p id="c05f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有五个功能来管理获取项目，添加一个新的项目，删除一个项目，更新一个项目和设置项目状态为加载。</p><p id="cb7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然在本系列中我们不会在应用程序组件中使用删除和更新项目，但是做好一切准备是一个不错的选择，以防我们以后需要添加这些内容。</p><blockquote class="op oq or"><p id="f297" class="kf kg mn kh b ki kj jr kk kl km ju kn os kp kq kr ot kt ku kv ou kx ky kz la ij bi translated">注意:您可以添加一个单独的门户来管理所有项目，如添加、删除和更新项目。虽然我们已经为所有这些任务准备好了API、actions和reducers，但是我们只涉及添加项目和获取组件中的所有项目。</p></blockquote><ol class=""><li id="90f9" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> getItems </strong> —这个函数用于使用一个为获取项目而设计的API端点从后端获取所有项目。我们首先将项目设置为loading，然后到达API端点来获取所有项目。然后，我们将类型设置为GET_ITEMS，将有效负载设置为作为响应接收的数据。</li><li id="d95d" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> addItem </strong> —该函数用于向数据库添加一个新项目。为此，我们通过前端表单接收item对象，并将这些数据发送给负责添加项目的API端点。然后，我们将类型设置为ADD_ITEM，将有效负载设置为从响应接收的数据。</li><li id="f1e6" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> deleteItem — </strong>该函数用于从数据库中删除一个现有项目。它接收我们想要删除的项目的id，并使用删除请求将其发送到用于此目的的API端点。然后，我们将类型设置为DELETE_ITEM，将有效负载设置为已删除项的id。</li><li id="2985" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> updateItem — </strong>此功能用于更新我们库存中的现有项目。它在id的帮助下向API端点发出put请求，并发送新的item对象。然后，我们将类型设置为UPDATE_ITEM，将有效负载设置为id，将从服务器接收的数据设置为响应。</li><li id="b881" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> setItemsLoading </strong> —该函数将类型设置为ITEMS_LOADING。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="5d57" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated">行动</h2><p id="8bab" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">它处理与任何用户的购物车相关的所有操作。它有四个功能，分别是获取购物车、向购物车添加商品、从购物车中删除商品以及将购物车状态设置为正在装载。</p><ol class=""><li id="414f" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> getCart </strong> —该函数用于为任何用户获取购物车。首先，我们将购物车设置为loading。这个函数将id作为一个参数传递给API端点，并接收一个包含用户购物车的响应。我们将类型设置为GET_CART。</li><li id="9da3" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">添加购物车</strong> —该功能用于向购物车添加商品。它接受用户的id作为参数，并传递productId和quantity作为请求体。然后，我们接收一个响应，并将其分配给有效负载，并将类型设置为ADD_TO_CART。</li><li id="6847" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">deletefromcarth</strong>—该功能用于从购物车中删除商品。它接收userId和itemId，并将它们作为参数传递给API端点。然后，我们将类型设置为DELETE_FROM_CART，并将有效负载设置为响应的数据。</li><li id="791b" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> setCartLoading </strong> —将类型设置为CART_LOADING。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="91ec" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated"><strong class="ak">订单操作</strong></h2><p id="e22e" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">这个操作文件处理与我们的应用程序中的订单相关的所有操作。它有三个功能，用于获取用户的所有订单，下一个新订单(结帐)和设置订单为加载。</p><ol class=""><li id="723d" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><strong class="kh ir"> getOrders </strong> —该功能首先将订单设置为加载。接下来，它使用接收到的用户id作为发出GET请求的参数。然后，我们将类型设置为GET_ORDERS，将有效负载设置为作为响应接收的数据。</li><li id="562c" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir">结账</strong> —该功能用于下订单。它从组件接收两个参数，即用户的id和源。源代码是从条带检出函数中生成的，我们将在后面的部分创建它们时详细处理这些函数。然后，我们使用id作为参数，使用source作为请求体，并发出POST请求。然后，我们将类型设置为CHECKOUT，将有效负载设置为响应的数据。</li><li id="b8bb" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><strong class="kh ir"> setOrdersLoading </strong> —该功能将订单类型设置为ORDERS_LOADING。</li></ol><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="6349" class="ns mu iq bd nt nu nv dn nw nx ny dp nz ko oa ob oc ks od oe of kw og oh oi oj bi translated">结论</h2><p id="bd0d" class="pw-post-body-paragraph kf kg iq kh b ki ok jr kk kl ol ju kn ko om kq kr ks on ku kv kw oo ky kz la ij bi translated">这就是我们在这部分要处理的。在下一部分中，我们将处理减速器，并开始处理一些组件，然后在最后一部分中，我们将在处理剩余的组件部分后结束该系列。</p><p id="c7e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">教程的下一部分可以在这里找到:-</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-f26613a344e1"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第6部分:构建Redux Reducers并处理组件</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="ov l mg mh mi me mj ll lv"/></div></div></a></div><p id="4c08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想访问这个项目的完整代码，请访问这个项目的<a class="ae lr" href="https://github.com/shubham1710/MERN-E-Commerce" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="0ef9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢教程系列的这一部分，也希望你对即将到来的部分感到兴奋。</p><p id="962b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看完这个系列后，还有更多故事要读:</p><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，以了解DRF和REST APIs是如何工作的，以及我们如何添加…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="ow l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Django构建一个社交媒体网站——设置项目(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在第一部分中，我们通过设置密码来集中设置我们的项目和安装所需的组件…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="ox l mg mh mi me mj ll lv"/></div></div></a></div></div></div>    
</body>
</html>