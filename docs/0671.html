<html>
<head>
<title>3 Testing Strategies to Level Up your Angular Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个测试策略来提升你的角度发展</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-testing-strategies-to-level-up-your-angular-development-d70bc43d88a6?source=collection_archive---------4-----------------------#2021-02-11">https://javascript.plainenglish.io/3-testing-strategies-to-level-up-your-angular-development-d70bc43d88a6?source=collection_archive---------4-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c8a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试用户界面，窥探对象等等！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/66feeae5eb128898e1807ec8514cc1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SC22mnrwt4htvNR3.jpg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Made with <a class="ae kv" href="https://deepdreamgenerator.com/" rel="noopener ugc nofollow" target="_blank">DeepDreamGenerator</a>, feel free to share!</figcaption></figure><p id="a51d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一套健壮的单元测试对于创建可维护和可扩展的软件仓库至关重要。全面的测试套件确保工程师所做的任何更改都不会破坏任何先前的功能。您的测试覆盖的行为案例越多，您就越有信心创建出行为符合预期的软件。</p><p id="098d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍使用Jasmine和Karma为Angular web应用程序编写有效测试的多种方法。这些测试策略将允许您创建更多的适应性测试套件，文章的结构如下:</p><ol class=""><li id="2b42" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">项目设置</strong></li><li id="86f5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">测试HTML元素</strong></li><li id="374d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">添加用于测试的假登录组件</strong></li><li id="dd3c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">如何测试间谍</strong></li><li id="b11b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">如何进行模拟测试</strong></li></ol><p id="292b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您只是对测试感兴趣，粗体显示的步骤是为您准备的！</p><p id="ef5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong>本教程假设您对Jasmine和Karma的打字稿和角度测试有基本的了解。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3757" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">1.项目设置</h1><p id="5aa5" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们将从头开始一个新的项目来测试。这一部分值得一读，因为我们也将回顾测试配置。首先，我们需要创建一个新的角度应用程序。然后我们将创建一个名为<code class="fe nk nl nm nn b">dashboard</code>的新组件。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="60aa" class="ns mo iq nn b gy nt nu l nv nw">$ ng new testing-demo<br/>? Strict type checking ? yes<br/>? Angular routing ? no<br/>? Which stylesheet ? Less<br/>$ ng generate component dashboard</span></pre><p id="1cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您喜欢的代码编辑器中打开<code class="fe nk nl nm nn b">testing-demo</code> Angular项目。删除<code class="fe nk nl nm nn b">app.component.html</code>中的所有代码，替换为<code class="fe nk nl nm nn b">&lt;app-dashboard&gt;&lt;/app-dashboard&gt;</code>标签。</p><p id="5280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除<code class="fe nk nl nm nn b">app.component.spec.ts</code>中的<code class="fe nk nl nm nn b">'should render title'</code>测试。</p><p id="297c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以移动到组件本身了！</p><h2 id="8b7f" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">仪表板.组件. ts</h2><p id="5f72" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们的组件类只有一些简单的逻辑来基于一些按钮更新文本。我们将有两个变量<code class="fe nk nl nm nn b">title</code>和<code class="fe nk nl nm nn b">userFeedback</code>来验证我们的测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="3c5e" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">dashboard.component.html</h2><p id="8f5e" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们组件的视图将只有几个<code class="fe nk nl nm nn b">div</code>元素。这将代表一个用户仪表板，它包含了我们需要的基本UI测试的所有细节，比如类和ID标志中包含的信息。我们还将<code class="fe nk nl nm nn b">sayYes()</code>和<code class="fe nk nl nm nn b">sayNo()</code>功能附加到它们各自的按钮上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="d6b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您单击其中一个按钮，该网站将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/270f4a989e198398962c004b0a846cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEaj6JhdYllT62LVLh_2kA.png"/></div></div></figure><h2 id="45d4" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">仪表板.组件.规格</h2><p id="d04a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在我们已经有了组件的视图和类，我将给出一个简短但重要的关于我们相应的测试类的概述。这些代码应该都是自动生成的，但是知道为什么我们有两个<code class="fe nk nl nm nn b">beforeEach()</code>调用是很有用的。</p><p id="3959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有两个原因与Jasmine测试的异步特性有关。第8行的第一个<code class="fe nk nl nm nn b">beforeEach()</code>负责编译一个组件。它通过<code class="fe nk nl nm nn b">.compileComponents()</code>函数来实现，这是异步的。</p><p id="a215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们确定组件已经编译之后，我们可以在第15行开始的第二个<code class="fe nk nl nm nn b">beforeEach()</code>中创建组件的一个实例。然后我们在<code class="fe nk nl nm nn b">fixture</code>上调用<code class="fe nk nl nm nn b">detectChanges()</code>来验证任何异步更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们有了基本的应用程序，我们可以继续我们的测试策略了！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b05d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">2.测试HTML元素</h1><p id="c95b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">首先，我们需要更新导入的库。我们将使用<code class="fe nk nl nm nn b">fakeAsync</code>和<code class="fe nk nl nm nn b">tick</code>来使我们的异步代码看起来同步。我们还将使用<code class="fe nk nl nm nn b">By</code>库来访问组件的HTML属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="395e" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">定义测试和组件之间的契约</h2><p id="14c6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">接下来，我们需要定义测试套件和视图之间的契约。一个简单的方法是定义常量，我们将使用这些常量来验证组件中的值。在这样做的时候，我们可以把我们的测试看作是我们的应用程序应该如何出现和表现的真实来源。如果你有一个更有效的方法来定义你的测试和代码之间的契约，请在文章的最后评论你的反馈！</p><p id="1de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续，在<code class="fe nk nl nm nn b">'DashboardComponent'</code>测试套件的<code class="fe nk nl nm nn b">dashboard.component.spec.ts</code>中添加以下常量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="8cab" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">我们的第一个HTML验证测试</h2><p id="2e22" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">从这里，我们可以根据显示的HTML创建我们的第一个测试。第一行只是验证我们的组件与我们的测试套件具有相同的<code class="fe nk nl nm nn b">title</code>值。在第3行，我们使用<code class="fe nk nl nm nn b">By</code>库来访问视图中的<code class="fe nk nl nm nn b">h1</code>标签。然后，我们可以在测试中验证视图的<code class="fe nk nl nm nn b">title</code>与契约的<code class="fe nk nl nm nn b">componentTitle</code>是否相同！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="8ff6" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">根据HTML类和id值进行测试</h2><p id="6334" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们显然希望比标准的HTML标签更具体。为了访问特定的<code class="fe nk nl nm nn b">class</code>或<code class="fe nk nl nm nn b">id</code>中的值，我们必须使用一些有趣的TypeScript一行程序。我们可以通过访问<code class="fe nk nl nm nn b">fixture.debugElement.nativeElement.querySelector('&lt;id&gt;')</code>来引用HTML id值。</p><p id="2d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以通过上面定义的合同常量值来验证<code class="fe nk nl nm nn b">yes-btn</code>和<code class="fe nk nl nm nn b">no-btn</code>是否具有预期的文本。此外，我们可以在第11行使用<code class="fe nk nl nm nn b">By</code>库引用整个类来进行仪表板内容测试。在第14行，我们验证了该类的HTML不为空，然后我们可以在第15行验证该类中有0个以上的元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="1317" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">使用fakeAsync &amp; tick验证按钮单击事件行为</h2><p id="8ebc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Jasmine测试的当前最佳实践是使用<code class="fe nk nl nm nn b">fakeAsync()</code>和<code class="fe nk nl nm nn b">tick()</code>使异步代码看起来同步。我们不需要嵌套<code class="fe nk nl nm nn b">fixture.whenStable()</code>调用，而是可以在一个异步事件(比如<code class="fe nk nl nm nn b">button.click()</code>)之后调用<code class="fe nk nl nm nn b">tick()</code>来等待任何逻辑完成，然后再移动到下一行代码。</p><p id="a502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个测试中，我们还验证了单击我们的一个按钮会导致id <code class="fe nk nl nm nn b">#user-feedback</code>中的HTML不为空。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="51ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您应该有5个通过测试，验证了大部分UI逻辑。不错！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="dbc9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">3.添加假登录组件</h1><p id="0ec0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">为了继续我们的最后一节，使用间谍和模拟进行测试，我们需要在我们的应用程序中有更多的逻辑来测试。我们将创建一个剥离下来的角度形式，伪造用户登录。本文的重点不是向您展示如何在Angular中创建服务，所以我们将尽可能保持事情的简单性。</p><p id="2e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个名为login的新组件。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="1dcb" class="ns mo iq nn b gy nt nu l nv nw">$ ng generate component login</span></pre><p id="ed20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要在<code class="fe nk nl nm nn b">app.module.ts</code>中包含正确的表单库，应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在开始定制我们的组件。</p><h2 id="c7f4" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">login.component.html</h2><p id="f2d2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们将使用一个简单的表单，它有两个字段，<code class="fe nk nl nm nn b">name</code>和<code class="fe nk nl nm nn b">address</code>。当我们点击<code class="fe nk nl nm nn b">Login</code>时，我们将调用<code class="fe nk nl nm nn b">(ngSubmit)</code>，它将引用<code class="fe nk nl nm nn b">login.component.ts</code>中的<code class="fe nk nl nm nn b">onSubmit()</code>方法。我们在末尾还有一个<code class="fe nk nl nm nn b">div</code>,显示用户是否登录的布尔值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="0249" class="ns mo iq bd mp nx ny dn mt nz oa dp mx lf ob oc mz lj od oe nb ln of og nd oh bi translated">登录.组件. ts</h2><p id="1777" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">保持事情超级简单，我们只是在组件中有一些东西。我们在类构造函数中使用传入的<code class="fe nk nl nm nn b">_formBuilder</code>创建<code class="fe nk nl nm nn b">checkoutForm</code>。然后我们用<code class="fe nk nl nm nn b">onSubmit()</code>方法伪造登录逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="961c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你点击通过网站，它现在应该看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/02fa6134be534d9fdfae6aa8cc3fd6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsLQXSb0BNVxMYSHaTfiFg.png"/></div></div></figure><p id="51bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们有了一点逻辑，回到测试！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="84a3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">4.如何用间谍测试</h1><p id="d410" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">对于一个简单的任务——检查代码的某些部分是否被调用，间谍是一个有趣的名字。在<code class="fe nk nl nm nn b">login.component.spec.ts</code>文件中，我们添加了以下代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5c58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的测试从第31行开始。我们在Angular中使用了<code class="fe nk nl nm nn b">spyOn</code>关键字，这样我们就可以“观察”组件中的<code class="fe nk nl nm nn b">onSubmit</code>方法。然后我们创建一个登录按钮的测试实例。再次使用<code class="fe nk nl nm nn b">fakeAsync()</code>和<code class="fe nk nl nm nn b">tick()</code>，我们异步调用登录按钮上的<code class="fe nk nl nm nn b">click()</code>事件。最后，我们可以验证是否调用了<code class="fe nk nl nm nn b">onSubmit()</code>组件方法，并利用spy实现我们的第一个测试！</p><p id="f729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个有限的例子，但有角的间谍非常简单灵活。通过利用Angular中的<code class="fe nk nl nm nn b">spyOn</code>关键字，您可以覆盖非常广泛的测试用例。例如，您可以监视<code class="fe nk nl nm nn b">console</code>来查看日志或错误字段。</p><p id="9dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你甚至可以窥探<code class="fe nk nl nm nn b">window</code>房产！假设你有某种方法，如果历史长度大于1，它会把你送回上一页。您可以监视<code class="fe nk nl nm nn b">window.history</code>的<code class="fe nk nl nm nn b">'back'</code>方法。然后，您可以监视属性<code class="fe nk nl nm nn b">window.history</code>并将值设置为2。在调用您的方法之后，您可以验证<code class="fe nk nl nm nn b">window.history.back</code>确实被调用了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><blockquote class="om on oo"><p id="7ef3" class="kw kx op ky b kz la jr lb lc ld ju le oq lg lh li or lk ll lm os lo lp lq lr ij bi translated">通过利用间谍，你可以确保你的代码逻辑按照你期望的方向和顺序流动。这是一个非常强大的工具，所有工程师都应该在需要时使用。</p></blockquote></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7a73" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">5.如何用模拟测试</h1><p id="7754" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">共同目标的另一个有趣的名字。比方说，我们的登录组件实际上调用一些API作为依赖来验证用户是否有帐户。如果您想要编写一个针对<code class="fe nk nl nm nn b">onSubmit()</code>方法的测试，您不会想要引用任何外部依赖。如果服务中断了怎么办？服务的延迟是什么？如果API调用是有成本的呢？</p><p id="cf19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您希望您的测试完全独立于这种逻辑。让我们修改我们的<code class="fe nk nl nm nn b">login.component.ts</code>类，使之包含一个助手类，我们将把它看作一个依赖项来验证用户是否创建了一个帐户。</p><p id="eb09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个助手类<code class="fe nk nl nm nn b">FakeLoginVerificationService</code>，它有一个方法<code class="fe nk nl nm nn b">verifyLogin</code>，以名字和地址作为参数。显然，这里验证用户帐户的逻辑要多得多，但是我们的例子可以很简单。注意我们如何使用类的<code class="fe nk nl nm nn b">Injectable()</code>包装器，通过使用依赖注入作为框架，Angular非常强大。</p><p id="6127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong>使用依赖注入允许模拟轻松替换测试套件的依赖。如果你需要关于依赖注入的回顾，这里有一个很棒的视频:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot oj l"/></div></figure><p id="6e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最终的结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ca38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe nk nl nm nn b">onSubmit()</code>将引用这个助手类作为依赖项。我们现在可以制作一个模拟来代替测试中的<code class="fe nk nl nm nn b">FakeLoginVerification</code>类！</p><p id="9eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们需要将<code class="fe nk nl nm nn b">FakeLoginVerificationService</code>导入到我们的<code class="fe nk nl nm nn b">login.component.spec.ts</code>测试文件中。然后我们创建一个新的类<code class="fe nk nl nm nn b">MockLoginVerificationService</code>，它拥有我们在登录组件<code class="fe nk nl nm nn b">verifyLogin()</code>中使用的方法。记住，<code class="fe nk nl nm nn b">verifyLogin()</code>通常是对一些外部API依赖的调用。我们希望我们的测试是独立的。</p><p id="7169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在<code class="fe nk nl nm nn b">MockLoginVerificationService</code>中，我们定义<code class="fe nk nl nm nn b">verifyLogin()</code>来返回我们想要的任何布尔值。就是这样！这样做，我们可以创建测试来验证我们自己的代码逻辑，而不必依赖于我们是否可以访问外部依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="96d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在我们的测试设置中，我们需要告诉测试使用我们的<code class="fe nk nl nm nn b">MockLoginVerificationService</code>而不是<code class="fe nk nl nm nn b">FakeLoginVerificationService</code>。我们首先在第4行实例化服务，然后使用<code class="fe nk nl nm nn b">providers</code>声明我们想要使用模拟服务来代替第15–17行的假服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="3d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备在测试中使用模拟！这里我们添加了两个测试，通过声明<code class="fe nk nl nm nn b">authenticated</code>值为真或假来模拟<code class="fe nk nl nm nn b">FakeLoginVerificationService</code>。然后，当我们调用<code class="fe nk nl nm nn b">component.onSubmit()</code>时，它有一个测试服务可以调用，我们可以验证一个经过身份验证的用户是否应该将<code class="fe nk nl nm nn b">isUserLoggedIn</code>设置为true，反之亦然。</p><p id="45e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我们也可以模拟出<code class="fe nk nl nm nn b">component.checkoutForm.value.name</code>，但是对于有角度的内置表单通常不需要，因为我们可以覆盖这个值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="319d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这似乎是一个有限的例子，但是就像spied一样，只要遵循Angular中使用的依赖注入模式，就可以很容易地使用模拟来替换依赖。通过这种方式，您总是可以用您自己的方法替换您自己的模拟，以便您可以控制您的测试的确切行为。只需在您的模拟类中包含与函数依赖项相同的签名，并带有您可以指定的返回值！</p><p id="411b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在已经学习了三种在Angular中测试的新方法，使用HTML的<code class="fe nk nl nm nn b">By</code>库、函数调用的spies和替换外部依赖的mocks。干得好，走了这么远！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="27be" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">最后的想法</h1><p id="7e78" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">以下是这篇文章中关于如何提高Angular测试技巧的重点！回顾一下，您希望在未来确保使用的要点和最佳实践包括:</p><ul class=""><li id="4ca8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ou ly lz ma bi translated">应该总是使用Jasmine框架中的间谍来测试服务。</li><li id="3d60" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ou ly lz ma bi translated">针对具有服务依赖关系的组件的测试应该总是使用模拟服务来代替真正的服务。</li><li id="9912" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ou ly lz ma bi translated">两次调用<code class="fe nk nl nm nn b">beforeEach()</code>方法很重要。确保异步组件编译逻辑在第一次调用中，同步组件初始化逻辑在第二次调用中。</li><li id="0b82" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ou ly lz ma bi translated">总是通过<code class="fe nk nl nm nn b">debugElement</code>而不是<code class="fe nk nl nm nn b">nativeElement</code>访问DOM。这将防止不必要的错误，因为<code class="fe nk nl nm nn b">debugElement</code>也将提供来自底层运行时环境的抽象。</li><li id="6882" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ou ly lz ma bi translated">知道<code class="fe nk nl nm nn b">By.css</code>和<code class="fe nk nl nm nn b">.queryselector</code>的区别，<code class="fe nk nl nm nn b">By.css</code>是首选方法，因为<code class="fe nk nl nm nn b">.queryselector</code>只在浏览器中起作用。如果应用程序在服务器上运行，测试可能会失败。</li></ul><p id="6ec4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章值得你花时间，并且你能够学到一些新的东西。这篇文章涉及了大量的设置，所以如果你想知道更多关于这些测试策略的细节，请告诉我！我在这些教程上花了很多时间，所以如果你有任何建设性的批评或者你想让我涵盖的新话题，请在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>