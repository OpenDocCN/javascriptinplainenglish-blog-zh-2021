<html>
<head>
<title>Reusability Patterns in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的重用模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reusability-patterns-in-react-9c8ff2e29ef6?source=collection_archive---------2-----------------------#2021-07-04">https://javascript.plainenglish.io/reusability-patterns-in-react-9c8ff2e29ef6?source=collection_archive---------2-----------------------#2021-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/e01d96701838f74aea42be4ae0a632f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Ofq8598zjL7tTH5QSNAoWA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Avengers gonna hate this !</figcaption></figure><p id="60b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简短开场白:是的，我们将一起深入探讨可重用性！</p><p id="35e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">长文开篇:有一次，我的MacBook被可口可乐淋透了，键盘粘得要命。我几乎不会打字。我真的讨厌一遍又一遍地输入一个函数的不同版本。可悲的是，我的键盘承受不了</p><p id="3159" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道一定有更好的方法。</p><p id="e626" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编程就像婴儿；作为父母，我们必须为它的成长、进化和扩展做好准备。没有完美的代码，你知道的！还是那句话，就是那一个宝贝，不同的“版本”。“借尸还魂”似乎总是一个糟糕的解决方案。</p><p id="d43c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谈努力！我们还没讨论维护问题呢。我们不想要难以处理的东西，就像复仇者联盟不想同时对抗9个版本的灭霸😊。我们想要易于维护的代码。</p><blockquote class="kt"><p id="6326" class="ku kv in bd kw kx ky kz la lb lc ks dk translated">这篇长文讨论了解决React中组件逻辑重复的不同方法。下面的例子和实现有时可能是荒谬和怪异的。但是坚持就好！我们只是利用它来指出上述模式的弱点。因此，这将是更多的学习方面。谢谢！</p></blockquote><p id="a1b5" class="pw-post-body-paragraph jv jw in jx b jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko lh kq kr ks ig bi translated"><strong class="jx io">目录:</strong></p><ul class=""><li id="daf0" class="li lj in jx b jy jz kc kd kg lk kk ll ko lm ks ln lo lp lq bi translated"><strong class="jx io">问题</strong>:了解元件中重复逻辑的问题。</li><li id="89f3" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated"><strong class="jx io">高阶组件</strong>:我们用HOC来处理问题，知道缺点。</li><li id="b563" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated">渲染道具:我们使用渲染道具来处理问题、道具和缺点</li><li id="7ad3" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated"><strong class="jx io">定制钩子</strong>:我目前解决问题的最佳选择，看看我为什么爱它。</li><li id="3f2a" class="li lj in jx b jy lr kc ls kg lt kk lu ko lv ks ln lo lp lq bi translated"><strong class="jx io">重述！</strong></li></ul><h1 id="4abd" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">问题！我们为什么要关心？</h1><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/aa051f54e3f4bf6941384ec3ca171cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*i5bgtli0V6jlm_U57_yvHA.jpeg"/></div></figure><p id="cde1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React提供了很好的可重用性，由于组件模型和组合，我们可以很容易地在应用程序/web的不同位置重用UI部件。他们还关心重用组件内部的逻辑。如你所知，并不是每个组件都是愚蠢的，我们可以利用像State(大部分)这样的强大特性来使我们的组件变得更智能，拥有逻辑。通常，智能组件拥有相似的逻辑，复制。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/84a330d08601bc89ac824fa1ed47772c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*TxnTcepIkuGvCgFiIJPVPw.png"/></div></figure><p id="897a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个开关按钮，一个下拉菜单，另一个显示模态的按钮。它们可以在同一个屏幕上，也可以在不同的屏幕上，让我们假设总是有键盘显示的文本输入。对于每个按钮，我们都有一个切换功能来打开/关闭开关，显示/隐藏下拉菜单和打开/关闭模式。对于伟大的UX，我们希望每次我们用按钮做动作时，键盘必须关闭，我们需要将我们的引用转发到组件(按钮)以利用它的一些功能。</p><p id="8cf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，我们的按钮有3个主要特征。<strong class="jx io">切换，键盘关闭，前进参考。</strong></p><p id="2f3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们按钮的基本实现:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0eae3fa687e6198a8230da07a980e83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*TT7_g4oGXs7Ry1vSwmRzzg.png"/></div></figure><p id="b781" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到在三个实现中有一个重复的部分。这些按钮并不相同，甚至初始状态来自不同的道具来源，一个来自<code class="fe nb nc nd ne b"> props.value</code>一个来自<code class="fe nb nc nd ne b">props.visible</code>，但它们共享相似的逻辑。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0a6429956343ac2c343b1abc91a2b72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*qvA8Jby-xXcDxhISqyZxsQ.png"/></div></figure><p id="020a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些函数太基本、太简短，不值得关注。</p><p id="05f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是想象一下，一旦这些函数变得庞大，计算复杂，版本更长。哪一个需要花很多精力去写，你将如何用新的变化来更新它？你会对其中一个进行修改，然后复制/粘贴到另一个吗？这将是很大的努力跟踪位置，更糟糕的是在复制过程中可能会有一些错误，产生错误的代码。当新开发人员开始这个项目时，他们不是这些代码行的作者，他们不知道在其他地方还有其他版本。说到保养，那是一种痛苦，很明显！</p><p id="41e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我实现这些简短功能的原因是为了提高意识。短逻辑总有一天会变大。通常我们不会认为一个逻辑会在很多地方出现或者成为一个怪物。一旦发生，不要犹豫重构它，增加可重用性！建议看编程中的<a class="ae ng" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干原理</a>。现在让我们回来作出反应。</p><p id="9ca1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">经过多年的发展，React已经有了许多处理复制逻辑的方法。众所周知的有<strong class="jx io">高阶组件(HOC)、渲染道具和自定义钩子。</strong>为什么这么多？旧方法有什么问题？为什么采用新方法？让我们来了解一下！</p><h1 id="df16" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated"><strong class="ak">高阶分量(HOC) </strong></h1><p id="c887" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">Component把props转换成UI，而HOC把一个组件转换成另一个组件，有增强！</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/31d641f3041ce13a288bd14675dac814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmTnlyYz1wOdC6_AvIWDkQ.png"/></div></div></figure><p id="d0e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">话虽如此，HOC并不修改你的输入组件。HOC的任务是包装你的输入组件，就像一个容器，而HOC不关心数据是如何/为什么被使用的，component不关心数据来自哪里。这一点很重要，因为它服务于<strong class="jx io">组合</strong>的目的，意味着容易在组件之间进行&amp;修改。</p><p id="546f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到我们的例子，让我们写一个<code class="fe nb nc nd ne b">withToggle</code> HOC:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nr"><img src="../Images/cc5b4336295cbb372c7ab639c8003b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sr4qUSaEaG1oreFK7RdcNg.png"/></div></div></figure><p id="db46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">withToggle</code>处理切换逻辑并提供给<code class="fe nb nc nd ne b">WrappedComponent</code>。它需要通过<code class="fe nb nc nd ne b">toggle</code>和<code class="fe nb nc nd ne b">onToggle</code>向下到达<code class="fe nb nc nd ne b">WrappedComponent.</code></p><blockquote class="ns nt nu"><p id="40dc" class="jv jw nv jx b jy jz ka kb kc kd ke kf nw kh ki kj nx kl km kn ny kp kq kr ks ig bi translated">我在这里不写<code class="fe nb nc nd ne b">onToggle</code>，让我们只集中讨论1道具——<code class="fe nb nc nd ne b">toggle</code>——因为对两者的解释最终是一样的。</p></blockquote><p id="dab2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，HOC只是一个具有组件输出的函数，所以实现它的方式可以是各种各样的方式，这取决于我们在编程中的创造力，我们实际上可以有无数个参数。可以看看Redux的<strong class="jx io"> connect() </strong>，一个真正有名的HOC。</p><p id="6401" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每一部分都是故意写出来指出不好的地方，大家一探究竟吧！</p><h2 id="03cd" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">#1问题:包装器<strong class="ak">地狱</strong></h2><p id="521c" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">想象一下，有一天，我们的组件变成了多功能的，并且被10个HOC包裹着，那会有多难看？</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f3bac208cc49a346cde3527fe2ff0f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*BOO7aKNhAlyIdSdv99GTyg.png"/></div></figure><p id="c8db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道，这是个怪物。</p><p id="f90a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谈到可读性，它伤害了我的眼睛，每天阅读这些代码，我可能会很快退休。努力读书意味着努力维持，我们终将承受痛苦。</p><p id="ccb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谈到调试和编写测试，我们需要深入每个HOC来查看实现，并将它们想象成节点。为了确切地知道组件的行为，我们需要将这些节点连接在一起，这很复杂，对吗？</p><p id="560a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以这是一个非常糟糕的经历，这导致了接下来的问题。</p><h2 id="9fd6" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated"><strong class="ak"> #2问题:固定和重叠道具</strong></h2><p id="e3fd" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">说到固定道具，当<code class="fe nb nc nd ne b">withToggle</code>在它的实现中使用<code class="fe nb nc nd ne b">props.value</code>时，我们必须将<code class="fe nb nc nd ne b">initialState</code>传递给<code class="fe nb nc nd ne b">EnhanceButton</code>作为<code class="fe nb nc nd ne b">value</code>道具。如果我们传递任何与值不同的东西，它就会失败，这是固定的</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="0a93" class="nz lx in ne b gy oq or l os ot">const EnhanceButton = withToggle(SwitchButton)</span><span id="3bd9" class="nz lx in ne b gy ou or l os ot">&lt;EnhanceButton value={initialState}/&gt;</span><span id="d9dc" class="nz lx in ne b gy ou or l os ot">// inside withToggle</span><span id="8930" class="nz lx in ne b gy ou or l os ot">const withToggle = (component) =&gt; (props) =&gt; {<br/>  const [toggle, setToggle] = useState(props.value)<br/> .....</span><span id="5263" class="nz lx in ne b gy ou or l os ot">}</span></pre><p id="4454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法是将initialState作为函数参数传递给<code class="fe nb nc nd ne b">withToggle</code>，我将在下面讨论。但是现在，让我们保留它，因为像<code class="fe nb nc nd ne b">value</code>这样的固定道具经常发生，更糟糕的是，对于嵌套的hoc，它是重叠道具的主要原因。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ov"><img src="../Images/876a47ddf4d514fbdddd9920770e5f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s15BcnC4ZYz1_I2LDmKSQg.png"/></div></div></figure><p id="e37b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的MacBook用户伙伴们，我打赌你们已经看到这个警告很多次了！</p><p id="6d80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对，复制！</p><p id="1e7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们的嵌套hoc正在构建一个包装器地狱，其中一些使用相同的道具<code class="fe nb nc nd ne b">name</code>，会发生什么？显然，它们会互相替换/重叠，而不会警告我们。我们的电脑很好，它能给我们警告并提供许多选项，但是React却不能这样工作。</p><p id="ce2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">命名已经成为编程中的一个难题，这使得它变得更加复杂，我们不仅要考虑如何命名它，还要避免重复，就像在重复中解决重复一样有趣lol:)</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ow"><img src="../Images/4649171c0fcb7c7b51f686897333c129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvpAGzjfjI1un20SWWBntQ.jpeg"/></div></div></figure><p id="c588" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有人喜欢代码中出现意外。😂</p><h2 id="921f" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">#3问题:外部引用屏蔽内部引用</h2><p id="c203" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">如果你注意到，我在我们的<code class="fe nb nc nd ne b">withToggle</code> HOC中使用<code class="fe nb nc nd ne b"> React.forwardRef </code>。因为HOC只是一个容器，一个被社区称赞的常见问题，他们给了组件ref，但是它不工作！</p><p id="5a77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，我们的WrappedComponent就像是HOC的一个孩子，所以给ref的方式是:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="65d6" class="nz lx in ne b gy oq or l os ot">const btnRef = useRef(null)</span><span id="0a27" class="nz lx in ne b gy ou or l os ot">&lt;EnhanceSwitchBtn ref={btnRef}/&gt;</span></pre><p id="ece9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的<code class="fe nb nc nd ne b">SwitchButton</code>没有收到ref，我们需要将其转发给<code class="fe nb nc nd ne b">SwitchButton</code>。这实际上不是一个问题，更多的是一个提醒！</p><h2 id="3392" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">#4问题:动态数据</h2><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ox"><img src="../Images/8736542e68cf1df7782690dcac7de8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_V00t-A9QJw58ClIcccSA.png"/></div></div></figure><p id="183c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想知道为什么我会有这些评论吗？</p><p id="5a9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe nb nc nd ne b">SwitchButton</code>内部:我们有这样的东西:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="900d" class="nz lx in ne b gy oq or l os ot">&lt;Switch value = {toggle}/&gt;</span></pre><p id="2e18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们转而使用HOC，toggle从<code class="fe nb nc nd ne b">withToggle</code>传递到<code class="fe nb nc nd ne b">SwitchButton</code>(部分<code class="fe nb nc nd ne b">toggle = {toggle}</code>)=<code class="fe nb nc nd ne b">SwitchButton</code>内的&gt;将变成</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="730d" class="nz lx in ne b gy oq or l os ot">const SwitchButton = () =&gt; {<br/>   return &lt;Switch value = {props.toggle}/&gt;<br/>}</span><span id="4f7a" class="nz lx in ne b gy ou or l os ot">//similar to inside ModalButton</span><span id="4640" class="nz lx in ne b gy ou or l os ot">const ModalButton = () =&gt; {<br/>   return &lt;...&gt;<br/>      &lt;Modal visible = {props.toggle} /&gt;</span><span id="7283" class="nz lx in ne b gy ou or l os ot">     &lt;/...&gt;</span><span id="38e4" class="nz lx in ne b gy ou or l os ot">}</span></pre><p id="7c31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，<code class="fe nb nc nd ne b">ModalButton</code>的行为也是如此。</p><p id="2caf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我想要更透明的东西，比如:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="4b66" class="nz lx in ne b gy oq or l os ot">const SwitchButton = () =&gt; {<br/>   return &lt;Switch value = {props.value}/&gt;<br/>}</span><span id="cade" class="nz lx in ne b gy ou or l os ot">//similarly inside ModalButton</span><span id="9832" class="nz lx in ne b gy ou or l os ot">const ModalButton = () =&gt; {<br/>   return <br/>       &lt;...&gt;<br/>         &lt;Modal visible = {props.visible} /&gt;</span><span id="5c44" class="nz lx in ne b gy ou or l os ot">       &lt;/...&gt;</span><span id="8e54" class="nz lx in ne b gy ou or l os ot">}</span></pre><p id="76b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">WrappedComponent</code> ( <code class="fe nb nc nd ne b">SwitchButton</code>，<code class="fe nb nc nd ne b">ModalButton</code>)是作为道具通过<code class="fe nb nc nd ne b">toggle</code>的，我们不可能同时通过<code class="fe nb nc nd ne b">value</code>，<code class="fe nb nc nd ne b">visible</code>，如果像这种情况需要更多的道具，我们的HOC就难看了。我们能做到！但是不建议！</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/69752195978cfb72423e22ec7436ecae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*FTwrSmH5ccRnfVW20VOpcA.png"/></div></figure><p id="0a99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们创建了像HOC这样的抽象，它迫使我们定义一个通用规则，我们必须修改我们的组件来接收<code class="fe nb nc nd ne b">props.toggle</code>。</p><p id="c192" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">WrappedComponent就像是一个地方，我们将在其中放置许多组件。因此，我们不能只服务于一个组成部分而放弃其他部分。显然，HOC对输出数据不够灵活。</p><p id="7b52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是下一个<strong class="jx io">渲染道具</strong>方法解决的原因之一，但是让我们等到下面发现它。</p><p id="bbf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，HOC可以很好地处理动态输入数据。假设我们有两个列表组件，以同样的方式利用数据，同样的逻辑，我们想要一个<code class="fe nb nc nd ne b">withData</code> HOC来处理它的逻辑，并给我们选择输入数据的权利。我们可以将数据作为参数传递，也可以从props中获取数据。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="4bd4" class="nz lx in ne b gy oq or l os ot">const withData = (component, inputData) =&gt; (props) =&gt; {<br/>   const [data, setData] = useState(inputData)</span><span id="0594" class="nz lx in ne b gy ou or l os ot">}</span><span id="430f" class="nz lx in ne b gy ou or l os ot">const EnhanceHourList = withData(ListComponent, DataStore.getHour())</span><span id="2e16" class="nz lx in ne b gy ou or l os ot">- or</span><span id="c96c" class="nz lx in ne b gy ou or l os ot">const withData = (component, selectData) =&gt; (props) =&gt; {<br/>   const [data, setData] = useState(selectData(props))</span><span id="6df8" class="nz lx in ne b gy ou or l os ot">}</span><span id="27cf" class="nz lx in ne b gy ou or l os ot">// get different hours by country ID</span><span id="3af5" class="nz lx in ne b gy ou or l os ot">const EnhanceUSHourList = withData(ListComponent,<br/> (props) =&gt; DataStore.getHour(props.countryID))</span><span id="280e" class="nz lx in ne b gy ou or l os ot">const EnhanceJapanHourList = withData(ListComponent,<br/> (props) =&gt; DataStore.getHour(props.countryID))</span></pre><p id="bf6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很适合定制，不是吗？</p><p id="f891" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总的来说，像任何概念一样，HOC有优点也有缺点，没有什么是完美的。它在开发过程中为我们提供了很好的服务，所以无论如何，HOC ❤️❤️做得很好。我必须承认，在React的最初几年，在其他主流方法出现之前，HOC是一个很好的解决方案。不浪费你的任何时间，让我们看看下一步如何渲染道具解决我们的情况！</p><h1 id="0eb3" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">渲染道具</h1><p id="533d" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">Render Prop是另一种像HOC一样重用逻辑的技术。顾名思义，这是一种利用渲染部分的技术。这种技术让你决定如何渲染这个“道具”——无论输出什么数据，意味着它不关心渲染什么，你才是决定者！</p><blockquote class="ns nt nu"><p id="32e9" class="jv jw nv jx b jy jz ka kb kc kd ke kf nw kh ki kj nx kl km kn ny kp kq kr ks ig bi translated">具有呈现属性的组件采用返回React元素并调用它的函数，而不是实现自己的呈现逻辑。</p></blockquote><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="a9c7" class="nz lx in ne b gy oq or l os ot">&lt;DataProvider render={data =&gt; (<br/>  &lt;Text&gt;Hello {data.name}&lt;/Text&gt;<br/>)}/&gt;</span></pre><p id="8d60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">DataProvider</code>是一个渲染道具，它为我们提供了<code class="fe nb nc nd ne b">data</code>，我们可以用它来渲染任何我们想要的东西。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oz"><img src="../Images/139433aa9d38ab292b33b9589b1bbdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yugeZESpm3Wa1CHGwE8tdA.png"/></div></div></figure><p id="ded8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到我们的例子！在问题#4中(滚动到上面)，我们讨论了在处理输出数据时，HOC是如何的不灵活。显然，我们要求随心所欲地使用我们的数据，而不拘泥于任何通用规则。<strong class="jx io">渲染道具</strong>来帮忙了。</p><p id="8690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以渲染道具的方式重写我们的<code class="fe nb nc nd ne b">withToggle</code> HOC:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi pa"><img src="../Images/f241238b590ef8210352e9226b30a987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvjEHyWpGgbri0qyVIWEHw.png"/></div></div></figure><p id="ed4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">姑且称之为<code class="fe nb nc nd ne b">ToggleProvider</code>，因为它为孩子们提供了<code class="fe nb nc nd ne b">toggle</code>。与参与塑造我们的孩子(渲染部分)的HOC不同，Render Prop不在乎。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="547f" class="nz lx in ne b gy oq or l os ot">&lt;ToggleProvider&gt;<br/>  {({toggle, onToggle}) =&gt;<br/>         &lt;SwitchButton <br/>           onValueChange={onToggle}<br/>           value={toggle}/&gt;<br/>  }<br/>&lt;/ToggleProvider&gt;</span><span id="9627" class="nz lx in ne b gy ou or l os ot">&lt;ToggleProvider&gt;<br/>  {({toggle, onToggle}) =&gt; <br/>        &lt;ModalButton <br/>          onPress={onToggle} <br/>          visible={toggle}/&gt;<br/>  }<br/>&lt;/ToggleProvider&gt;</span></pre><p id="fd5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个<code class="fe nb nc nd ne b">ToggleProvide</code>的孩子都可以使用<code class="fe nb nc nd ne b">toggle, onToggle </code>来渲染任何需要的东西。我们不需要像在第4期中那样制定一个通用规则，我们的<code class="fe nb nc nd ne b">SwitchButton</code>和<code class="fe nb nc nd ne b">ModalButton</code>现在可以直接使用<code class="fe nb nc nd ne b">value</code>、<code class="fe nb nc nd ne b">visible</code>道具，而无需设置另一个<code class="fe nb nc nd ne b">toggle</code>道具。</p><p id="be8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">Provide</code>让我想起<a class="ae ng" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">上下文API </strong> </a>。如果您还不知道，它正在解决我们应用程序中的深层更新。我们可以看到<strong class="jx io">的背景</strong>是基于<strong class="jx io">渲染道具</strong>设计的。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi pb"><img src="../Images/255ce3c36e31f235435f4fabb6f84f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5syj7n7Gd0RooA_l_Dykew.png"/></div></div></figure><p id="0b04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以清楚地看到这一点，特别是在他们的<strong class="jx io">消费者</strong>身上。我认为这很有趣，因为知道其他熟悉的技术是如何实现的很酷，对吗？另一个事实是，Render Prop不仅擅长重用逻辑，还擅长传递数据。</p><h2 id="ca89" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">作文能力</h2><p id="7065" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">我们知道React非常擅长组合，这有助于将大问题分解成小部分。渲染道具增强了这个能力，为我们提供了更强大的工具。我们一直在谈论重用逻辑，这可以很好地呈现Prop句柄，但另一个优势是通过让我们将UI部分传递到另一个组件来使我们的组件更加灵活。</p><p id="06d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这是有益的？让我们看一个例子:</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi pc"><img src="../Images/7c2cfc2e78213b06850efbeeefdcd996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1uAd-z_99bR2w9D2gIvVQ.png"/></div></div></figure><p id="ab9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们的应用程序中有3种不同风格的标题，在我们的代码中，应该是这样的:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="eb11" class="nz lx in ne b gy oq or l os ot">const NavHeader = (props) =&gt; {</span><span id="ae93" class="nz lx in ne b gy ou or l os ot"> return(<br/>  &lt;View&gt;<br/>   &lt;Left/&gt;<br/>   &lt;Title/&gt;<br/>   &lt;Right/&gt;<br/>  &lt;/View&gt;</span><span id="10f3" class="nz lx in ne b gy ou or l os ot">)}</span></pre><p id="0196" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编写3合1右组件可能是:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="d247" class="nz lx in ne b gy oq or l os ot">const Right = (props) =&gt; {<br/> switch(props.type): {<br/> case 'icon': return &lt;Icon/&gt;<br/> case 'text': return &lt;Text/&gt;<br/> default: return null</span><span id="227f" class="nz lx in ne b gy ou or l os ot"> }}</span></pre><p id="0e12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这在一开始可以很好地工作，但是我们不知道将来什么样的更新会影响我们的组件。这种方法似乎过于固定，难以推广。理想情况下，我希望<code class="fe nb nc nd ne b">NavHeader</code>呈现我告诉它的内容。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="e1ce" class="nz lx in ne b gy oq or l os ot">const NavHeader = (props) =&gt; {<br/>return(<br/>  &lt;View&gt;<br/>   {props.renderLeft()}<br/>   &lt;Title/&gt;<br/>   {props.renderRight()}<br/>  &lt;/View&gt;<br/>)}</span><span id="0bae" class="nz lx in ne b gy ou or l os ot">&lt;NavHeader<br/>renderLeft={...}<br/>renderRight={&lt;Icon/&gt; or &lt;Text/&gt; or null}<br/>/&gt;</span></pre><p id="beaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过从<strong class="jx io">渲染道具</strong>中学习这种方法，我们对未来的变化更加开放，并且能够避免编写类似上面<code class="fe nb nc nd ne b">Right</code>的复杂组件。</p><h2 id="e4a4" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">深传球道具</h2><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi pd"><img src="../Images/83f5e06b4d295e6796f1eec9fb75dd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuB17rnT_mK6mbeDJgxTwQ.png"/></div></div></figure><p id="793b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有这个<code class="fe nb nc nd ne b">ProfileScreen</code></p><p id="586d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">ProfileScreen</code>包含关于我自己的不同信息。</p><p id="8e3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可能有不同的内容，如<code class="fe nb nc nd ne b">Header</code>、<code class="fe nb nc nd ne b">Body</code>、<code class="fe nb nc nd ne b">Footer</code>。但是在这个例子中，我们只关注名为<code class="fe nb nc nd ne b">ProfileBody</code>的<code class="fe nb nc nd ne b">Body</code></p><p id="5b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe nb nc nd ne b">ProfileBody</code>里面，我们有我的头像，我的名字和我的身体状态。<code class="fe nb nc nd ne b">BodyStats</code>描述一下我的身体状况。</p><p id="6a19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">BodyStats</code>将接收我的<code class="fe nb nc nd ne b">user</code>数据，并使用它来渲染布局。</p><p id="f637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，完成了！现在让我们做一些代码。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="7f3c" class="nz lx in ne b gy oq or l os ot">const ProfileScreen = (props) =&gt; {<br/> return &lt;View&gt;<br/>         ...<br/>         &lt;ProfileBody user={props.user}/&gt;<br/>         ...<br/>      &lt;/View&gt;<br/>}</span><span id="6997" class="nz lx in ne b gy ou or l os ot">const ProfileBody = (props) =&gt; {<br/> return &lt;View&gt;<br/>         ...<br/>         &lt;BodyStats user={props.user}/&gt;<br/>         ...<br/>      &lt;/View&gt;<br/>}</span><span id="d763" class="nz lx in ne b gy ou or l os ot">const BodyStats = (props) =&gt; {<br/> return ...<br/>}</span></pre><p id="0814" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，我们有这样的结构。实现显示了<strong class="jx io">支柱钻孔</strong>问题，我们通过许多层将<code class="fe nb nc nd ne b">user</code>数据向下传递到<code class="fe nb nc nd ne b">BodyStats</code>。</p><p id="46d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">个人资料屏幕—&gt;个人资料正文—→正文统计</p><p id="d66a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了处理<strong class="jx io"> prop drilling </strong>，我们可以利用<strong class="jx io">上下文API </strong>或者像<strong class="jx io"> Redux </strong>这样的状态管理来访问<code class="fe nb nc nd ne b">user</code>到任何我们想要的地方，而不用深入传递它。但是让我们把它用于复杂的情况，假设这只是为了渲染身体状态，让我们用一种简单的方法通过使用<strong class="jx io">渲染道具。</strong></p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="fada" class="nz lx in ne b gy oq or l os ot">const ProfileScreen = (props) =&gt; {<br/> return &lt;View&gt;<br/>         ...<br/>         &lt;ProfileBody bodyStats={&lt;BodyStats user={props.user}/&gt;}/&gt;<br/>         ...<br/>      &lt;/View&gt;<br/>}</span><span id="8ca6" class="nz lx in ne b gy ou or l os ot">const ProfileBody = (props) =&gt; {<br/> return &lt;View&gt;<br/>         ...<br/>         {props.bodyStats()}<br/>         ...<br/>      &lt;/View&gt;<br/>}</span></pre><p id="a4b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做，我们不再需要将<code class="fe nb nc nd ne b">user</code>传递给子组件。正如我们所做的，很明显<strong class="jx io">渲染道具</strong>是一个很棒的合成和传递道具的技术。作文是创造力的主导，让我们在编程中进一步拓展能力，正如你所看到的，无论是提升还是传承都相当容易，并且非常善于适应变化！而且在我看来，<strong class="jx io">渲染道具</strong>在<strong class="jx io">定制方面能力最好。</strong></p><p id="2ccd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，选择正确的结构取决于我们的需求和行为。例如，假设我们为body stats添加了编辑功能，我们只希望对<code class="fe nb nc nd ne b">BodyStats</code>组件进行更新，而不需要计算/重新渲染<code class="fe nb nc nd ne b">ProfileBody &amp; ProfileScreen</code>的布局树来提高性能(可能是因为重新渲染过程成本很高)。这是另一个需要解决的问题，在我看来，使用<strong class="jx io">渲染道具</strong>并不理想。好吧，让我们把这个问题抛在脑后，回到我们的例子。我们现在能讨论一下缺点吗？</p><h2 id="2314" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated"><strong class="ak"> #1问题:锁定数据</strong></h2><p id="08e8" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">Render Prop的最大问题是传递的数据被锁定在渲染中。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="865b" class="nz lx in ne b gy oq or l os ot">const ParentComp = () =&gt; {</span><span id="4bd6" class="nz lx in ne b gy ou or l os ot">// outside field</span><span id="dcef" class="nz lx in ne b gy ou or l os ot">return (<br/> &lt;ToggleProvider&gt;<br/>  {({toggle, onToggle}) =&gt; {<br/>  //...usage scope</span><span id="479a" class="nz lx in ne b gy ou or l os ot">return &lt;SwitchButton onValueChange={onToggle} value={toggle}/&gt;</span><span id="2dd8" class="nz lx in ne b gy ou or l os ot"> }}<br/> &lt;/ToggleProvider&gt;</span><span id="e112" class="nz lx in ne b gy ou or l os ot"> // or custom prop</span><span id="aaf3" class="nz lx in ne b gy ou or l os ot"> &lt;ToggleProvider</span><span id="910e" class="nz lx in ne b gy ou or l os ot"> renderContent={({toggle, onToggle}) =&gt; {<br/>    //...usage scope</span><span id="e9d2" class="nz lx in ne b gy ou or l os ot">   return &lt;SwitchButton onValueChange={onToggle} value={toggle}/&gt;</span><span id="dfb9" class="nz lx in ne b gy ou or l os ot"> }}/&gt;</span><span id="cace" class="nz lx in ne b gy ou or l os ot">)}<br/></span></pre><p id="ccec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使你使用子对象或任何自定义道具(如<code class="fe nb nc nd ne b">renderContent</code>，或<code class="fe nb nc nd ne b">anyPropYouLike</code>，传递的数据<code class="fe nb nc nd ne b">toggle, onToggle </code>也可以在<code class="fe nb nc nd ne b">usage scope</code>和内部组件实现中使用。这限制了我们使用<code class="fe nb nc nd ne b">outside field</code>的数据</p><p id="b67f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需求是真实的，有时我们想要使用数据作为状态或基于它计算一些东西。话虽如此，我们仍然可以设法做到这一点，而不需要像将它传递给回调或任何你觉得它工作的方式这样的修复；这是你自己的创造力，总的来说，这可能很难做到。</p><h2 id="c29a" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">#2问题:嵌套渲染属性——包装器地狱</h2><p id="4906" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">我们已经看到嵌套的HOC发生了包装地狱。我们在渲染道具上也有类似的问题。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="6295" class="nz lx in ne b gy oq or l os ot">&lt;ToggleProvider&gt;<br/>  {({toggle, onToggle}) =&gt; {</span><span id="cf1e" class="nz lx in ne b gy ou or l os ot">   return &lt;DataProvider&gt;</span><span id="caac" class="nz lx in ne b gy ou or l os ot">        {({data}) =&gt; {<br/>  <br/>          return &lt;AccessProvider&gt;</span><span id="8f1c" class="nz lx in ne b gy ou or l os ot">           {({access}) =&gt; {<br/>            return &lt;OurComponent/&gt;</span><span id="62a0" class="nz lx in ne b gy ou or l os ot">           }}   <br/>          &lt;/AccessProvider&gt;</span><span id="3625" class="nz lx in ne b gy ou or l os ot">        }}   <br/>    &lt;/DataProvider&gt;</span><span id="2e91" class="nz lx in ne b gy ou or l os ot">  }}<br/> &lt;/ToggleProvider&gt;</span></pre><p id="5c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有3个渲染道具嵌套，可读性肯定很差。我喜欢<strong class="jx io"> JSX </strong>和<strong class="jx io"> React Native </strong>的一点是，它们提供了一种声明式的方式来编写布局。我喜欢我们写得干净利落。如果你曾经使用<strong class="jx io">样式表</strong>来避免<strong class="jx io">内联样式</strong>，或者将大UI分解成小容器，你知道我在说什么。除了技术上的好处之外，我们的眼睛也得到了休息。</p><p id="a296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这让我想起了<code class="fe nb nc nd ne b">then</code>的用法在编程中的<code class="fe nb nc nd ne b">asynchronous</code>。在<code class="fe nb nc nd ne b">await</code>和异步<code class="fe nb nc nd ne b">keyword</code>出现之前。这种回调我们见得多了。下面让我们看看如何用一个<strong class="jx io">定制钩子</strong>来处理这个问题。</p><h2 id="edd4" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">#3问题:中断渲染优化</h2><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/7176b69960c0e2529724253796b6903b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*QSCEdHtOtn34JIfLOvlsFg.jpeg"/></div></figure><p id="3758" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在使用React的过程中，浪费的渲染经常发生。说到优化，我们要么让它跑得更快，要么少做点工作。关于React，我们通常做的工作较少，对于浪费的渲染，主要是跳过渲染。如果你想了解更多关于它是如何发生的以及解决方法，你可以阅读我的<a class="ae ng" rel="noopener ugc nofollow" target="_blank" href="/react-native-why-props-references-break-optimizations-79c463ca0723">文章</a>。</p><p id="9fa2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简言之，React提供了3种优化方式:<code class="fe nb nc nd ne b">shouldComponentUpdate</code>生命周期、<code class="fe nb nc nd ne b">React.memo</code>和<code class="fe nb nc nd ne b">PureComponent</code>。虽然它们是不同的技术，但是它们有相同的基本原理，使用<code class="fe nb nc nd ne b">shallow compare</code>。所以对象引用在这里起着重要的作用。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="c20f" class="nz lx in ne b gy oq or l os ot">&lt;ToggleProvider&gt;<br/>  {({toggle, onToggle}) =&gt; {<br/>  return &lt;SwitchButton onValueChange={onToggle} value={toggle}/&gt;</span><span id="9af2" class="nz lx in ne b gy ou or l os ot">  }}<br/>&lt;/ToggleProvider</span></pre><p id="37d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据<strong class="jx io"> Javascript </strong>的性质，使用<strong class="jx io">渲染道具</strong>的任何一种方式在渲染过程中每次出现差异都会产生新的引用，从而破坏我们的渲染优化。</p><p id="636c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们并不总是需要优化我们的组件，但请注意，一旦你不得不这样做，并处理小心这些对象引用，因为<strong class="jx io">过早优化</strong>是一个魔鬼的根源。</p><p id="ed9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管有缺点，我相信<strong class="jx io">渲染道具</strong>在React world中还是有它自己的价值的，直到现在我都认为它是最适合定制的！—阅读下文，我们将讨论它，在此之前，先和我一起浏览一下<strong class="jx io">自定义挂钩</strong>部分。</p><h1 id="6ad1" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">自定义挂钩</h1><p id="b27b" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">钩子是2018年公布的，如果没记错的话。这是React的年度热门影片。显然，这种热情是由于它如何帮助编码反应得更愉快和满意。除了React team提供的默认钩子之外，它们还允许我们创建自己的钩子，定制钩子，这成为了它最强的特性。就像创造一个市场，让人们在上面生产和销售他们的产品，非常社区驱动！<a class="ae ng" href="https://usehooks.com" rel="noopener ugc nofollow" target="_blank">usehooks.com</a>是一个很好的定制钩子的网站，看看吧！</p><p id="0055" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">给我看看代码！</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi pf"><img src="../Images/e72754cc3a3da2e89d047e929a45d75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZktwL3Fr8n_N0opQVK9vug.png"/></div></div></figure><p id="0050" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nb nc nd ne b">useToggle</code>是我们的自定义钩子，它为我们处理初始化&amp;更新toggle的逻辑，按照惯例，我们应该以<code class="fe nb nc nd ne b">use</code>开头来命名它。而且很容易使用:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="3c79" class="nz lx in ne b gy oq or l os ot">const Screen = () =&gt; {<br/>  const [toggle, onToggle] = useToggle(false)</span><span id="e520" class="nz lx in ne b gy ou or l os ot">  return(<br/>   ....<br/>   &lt;SwitchButton onValueChange={onToggle} value={toggle}/&gt;<br/>   ....<br/>  )<br/>}</span></pre><p id="65dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义钩子可以返回一些值或者只是一个纯函数，这取决于我们如何实现它，并且严格遵循任何返回结构，我们可以返回任何我们喜欢的结构。</p><h1 id="d838" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">不再有包装地狱</h1><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/e4dd967f6cf4abf6b16885d516f2692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*e6zgn1JnsFz1VyLH27pOzw.jpeg"/></div></figure><p id="6687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经在HOC和Render Prop中看到了包装器地狱，当它们处理嵌套问题时。自定义钩子不是这样工作的，因为它不包装任何东西，它就像一个无渲染组件，用<code class="fe nb nc nd ne b">return null</code>进行渲染。就像我们只需要内容，我们不关心其他的。没错。买东西不带盒子:)</p><p id="0827" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而自定义钩子的用法看起来就像写一行代码，更像是多行连续的代码，而不是互相包装。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="dbdd" class="nz lx in ne b gy oq or l os ot">const [toggle, onToggle] = useToggle(false)<br/>const data = useFetchData(params)<br/>useClickAway()<br/>useHandleKeyboard()</span></pre><h1 id="189f" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">灵活的数据使用</h1><p id="de83" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">一个使定制钩子比其他钩子占优势的优势是灵活性。正如我们从上面的技术中了解到的，它们有时在数据使用上过于固定，Hook则不然！hook的数据流极其灵活。</p><h2 id="fbb2" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated"><strong class="ak"> 1/无固定道具</strong>:</h2><p id="13ee" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">还记得我们的<code class="fe nb nc nd ne b">withToggle</code> HOC和第2期吗？它使用props.value作为初始状态。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="8974" class="nz lx in ne b gy oq or l os ot">const EnhanceButton = withToggle(SwitchButton)</span><span id="3667" class="nz lx in ne b gy ou or l os ot">&lt;EnhanceButton value={initialState}/&gt;</span><span id="6eac" class="nz lx in ne b gy ou or l os ot">// inside withToggle</span><span id="44bc" class="nz lx in ne b gy ou or l os ot">const withToggle = (component) =&gt; (props) =&gt; {<br/>  const [toggle, setToggle] = useState(props.value)<br/> .....</span><span id="ec04" class="nz lx in ne b gy ou or l os ot">}</span></pre><p id="29d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单提醒你一下，在<code class="fe nb nc nd ne b">withToggle</code>的实现中，它使用<code class="fe nb nc nd ne b">props.value</code>作为初始状态。所以当编写增强按钮的JSX时，我们必须将initialState作为<code class="fe nb nc nd ne b">value</code> prop传递，如果我们传递任何与<code class="fe nb nc nd ne b">value</code>不同的东西，它都会失败，这是固定的。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="6f32" class="nz lx in ne b gy oq or l os ot">const Screen = () =&gt; {<br/>  const [toggle, onToggle] = useToggle(false)</span><span id="a6b7" class="nz lx in ne b gy ou or l os ot">return(<br/>   ....<br/>   &lt;SwitchButton onValueChange={onToggle} value={toggle}/&gt;<br/>   ....<br/>  )<br/>}</span></pre><p id="15f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用自定义钩子，当初始状态作为函数arg传递时，我们可以更开放地定义初始状态，我们不再需要将初始状态作为prop传递给组件。</p><h2 id="e989" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">2/无重叠道具:</h2><p id="8fc5" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">上面我们也讲过<strong class="jx io">固定道具</strong>和<strong class="jx io">嵌套的</strong>如何导致<strong class="jx io">重叠道具</strong>。因为<strong class="jx io">包装器地狱</strong>不会发生在自定义钩子中，而且<strong class="jx io">固定道具</strong> - &gt;也不会发生，我们不必再注意这一点了！</p><h2 id="7a10" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated"><strong class="ak"> 3/对数据使用范围没有限制</strong></h2><p id="7ee8" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">渲染道具所发生的是我们在<strong class="jx io">问题1:锁定数据中讨论过的传递道具的使用范围。</strong></p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="abf4" class="nz lx in ne b gy oq or l os ot">const [toggle, onToggle] = useToggle(false)<br/>const data = useFetchData(params)<br/>useClickAway()<br/>useHandleKeyboard()</span></pre><p id="d422" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看这些自定义钩子，<code class="fe nb nc nd ne b">useFetchData</code>和<code class="fe nb nc nd ne b">useToggle</code>是为我们提供渲染或计算数据的钩子，具体取决于。它将数据从它的实现中暴露出来并交给我们，因此我们可以在任何需要的地方自由使用数据，而不再像<strong class="jx io"> render Prop那样被限制在Render中。</strong></p><h2 id="0e00" class="nz lx in bd ly oa ob dn mc oc od dp mg kg oe of mk kk og oh mo ko oi oj ms ok bi translated">4/没有输出数据的一般规则:</h2><p id="5930" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">我们上面提到的HOC的第4期展示了我们如何需要一个通用的规则来将数据向下传递给<code class="fe nb nc nd ne b">WrappedComponent</code>，因为我们的HOC将包装许多种类的组件。我还展示了Render Prop如何解决这个问题</p><p id="e25f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上所述，hook将数据暴露在实现之外的方式赋予了将数据作为道具传递给子组件的自由。我们可以把数据传递给任何我们想要的道具，只要它是合适的。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="495e" class="nz lx in ne b gy oq or l os ot">const [toggle, onToggle] = useToggle(false)</span><span id="41d3" class="nz lx in ne b gy ou or l os ot">&lt;SwitchButton <br/> onValueChange={onToggle}<br/> value={toggle}/&gt;</span><span id="dd3b" class="nz lx in ne b gy ou or l os ot">&lt;ModalButton <br/> onPress={onToggle} <br/> visible={toggle}/&gt;</span></pre><h1 id="f0a6" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">定制能力</h1><p id="8150" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">Component是一个创造性的游乐场，我们利用React概念作为素材，custom hook就是其中之一。</p><p id="6394" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义钩子的用法并不总是一样的，有时我们需要添加逻辑来看是否需要使用它，就像一个条件。作为钩子的规则，我们不能在条件、循环或嵌套函数中调用钩子，以确保每次组件渲染时，钩子都以<strong class="jx io"/><strong class="jx io">相同的顺序</strong>被调用。为什么这很重要？</p><p id="9229" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于React Hook的内部实现，顺序很重要，就像我在我的博文中提到的那样。有一个数组存储钩子的名字，这个数组用来做一些事情，比如更新。因此，制定了一些规则来确保数组的顺序在渲染时保持不变。</p><p id="e84d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">条件、循环或嵌套函数会导致不同的顺序，所以它们会阻止这种情况。</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="5e93" class="nz lx in ne b gy oq or l os ot">const Component = (props) =&gt; {</span><span id="28a0" class="nz lx in ne b gy ou or l os ot"> const [toggle, onToggle] = useToggle(false)<br/> const data = useFetchData(params)</span><span id="4360" class="nz lx in ne b gy ou or l os ot"> if(props.enableKeyboard){<br/>  useKeyboardHandler()<br/> }<br/>}</span></pre><p id="89e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说我们有一个使用3个钩子的组件<code class="fe nb nc nd ne b">useToggle</code>、<code class="fe nb nc nd ne b">useFetchData</code>和<code class="fe nb nc nd ne b">useKeyboardHandler</code>。<code class="fe nb nc nd ne b">useKeyboardHandler</code>是可选的，我们不需要键盘处理程序，以防禁用键盘，这是浪费，我们通过<code class="fe nb nc nd ne b">enableKeyboard</code>道具来决定。这违反了钩子规则。因为在<code class="fe nb nc nd ne b">enableKeyboard</code> = <code class="fe nb nc nd ne b">true</code>的情况下，顺序数组将是['useToggle '，' useFetchData '，' useKeyboardHandler']，而<code class="fe nb nc nd ne b">enableKeyboard</code> = <code class="fe nb nc nd ne b">false</code>形成['useToggle '，' useFetchData '，]。顺序不同，就像我说的，顺序必须始终相同。</p><p id="2e1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这条规则使得定制钩子在定制时不如<strong class="jx io">渲染道具</strong>灵活。</p><p id="1a66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以无条件地将<code class="fe nb nc nd ne b">useKeyboardHandler</code>留在那里，显然，如果键盘被禁用，它将什么也不会做(不像键盘暂时关闭，就像从未出现过键盘)。奏效了。</p><p id="3a2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论哪种方式，我们都可以将其转换为无渲染组件，并将其用作JSX附带条件:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="0f2e" class="nz lx in ne b gy oq or l os ot">// custom hook<br/>const useKeyboardHandler = () =&gt; {<br/>  useEffect(()=&gt;{<br/>   // listen some keyboard events</span><span id="b11e" class="nz lx in ne b gy ou or l os ot">   return () =&gt; {<br/>   // clear out listeners</span><span id="b43d" class="nz lx in ne b gy ou or l os ot">    }<br/>  }, [])<br/>}</span><span id="89f1" class="nz lx in ne b gy ou or l os ot">// render less component<br/>const KeyboardHandler = () =&gt; {  <br/> useKeyboardHandler()<br/> <br/> return null</span><span id="626b" class="nz lx in ne b gy ou or l os ot">}</span><span id="6538" class="nz lx in ne b gy ou or l os ot">// in JSX </span><span id="b073" class="nz lx in ne b gy ou or l os ot">{props.<!-- -->enableKeyboard &amp;&amp; &lt;<!-- -->KeyboardHandler/&gt;</span></pre><p id="da7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具体来说，<code class="fe nb nc nd ne b">useKeyboardHandler</code>是一个自定义钩子，表示我们监听键盘事件(打开、关闭)并做一些逻辑处理，在卸载时，我们想清除监听程序。我们编写了一个无渲染组件，这个组件不输出/渲染UI布局，它只调用我们的自定义钩子。这样就免去了调用<code class="fe nb nc nd ne b">useKeyboardHandler</code>时对条件的需要。最后，使用条件来决定是否渲染<code class="fe nb nc nd ne b">KeyboardHandler</code>组件。</p><p id="820f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，<code class="fe nb nc nd ne b">useKeyboardHandler</code>是一个没有提供任何数据的钩子，所以我们可以使用无渲染组件来处理它。但是在像<code class="fe nb nc nd ne b">useFetchData</code>这样的钩子的情况下，它提供数据，我们将不得不使用渲染道具来解决它:</p><pre class="mv mw mx my gt om ne on oo aw op bi"><span id="effe" class="nz lx in ne b gy oq or l os ot">// render less component<br/>const FetchData = (props) =&gt; {  <br/> const data = useFetchData()<br/> <br/> return props.children({data})</span><span id="ed0d" class="nz lx in ne b gy ou or l os ot">}</span><span id="f761" class="nz lx in ne b gy ou or l os ot">// in JSX<br/>{props.<!-- -->enableFetchData &amp;&amp; <br/>    &lt;<!-- -->FetchData&gt; <br/>     {({data}) =&gt; do some thing }<br/>    &lt;/FetchData&gt;<br/>}</span></pre><p id="d2f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧。我知道这是非常罕见的情况下处理条件挂钩，即使在我的实际工作中，我并没有看到它很多。但是如果它发生了，我很高兴知道如何解决它。不确定是否还有其他方法可以解决这个问题，但这是我学到的两种方法。</p><h1 id="a866" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">概述</h1><p id="3102" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">很高兴你和我一起结束了这篇长文章，我相信我们通过这次讨论学到了很多。</p><p id="4b4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每种技术都有其优点和缺点，这取决于我们的选择。我没有偏见，但定制挂钩是我目前最喜欢的。还有更多要讨论的，比如讨论可测试性，编写测试，自定义钩子似乎不像as HOC，Render Prop那么简单。那是另一次了！下一篇文章见。</p></div></div>    
</body>
</html>