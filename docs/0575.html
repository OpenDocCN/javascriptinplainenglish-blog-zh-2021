<html>
<head>
<title>Understand Code Splitting in Next.js by Solving a Common Error</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过解决一个常见错误来理解Next.js中的代码拆分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-code-splitting-in-next-js-by-solving-a-common-error-db61a9b1b1a1?source=collection_archive---------3-----------------------#2021-02-04">https://javascript.plainenglish.io/understand-code-splitting-in-next-js-by-solving-a-common-error-db61a9b1b1a1?source=collection_archive---------3-----------------------#2021-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bc8c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个小小的错误如何让我学到了很多关于前端开发的知识</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/14c1c727d31fae4e17ab2bf17cb4c32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6-Hq6oSoEk6ORmy8"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@unstable_affliction?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ivan Bandura</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>, portraying a mine. Illustrating the fact that it sometimes better to dig deeper.</figcaption></figure><p id="c8aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在为Next.js项目定制站点地图功能时，我遇到了以下错误:<code class="fe lp lq lr ls b">Module not found: Can't resolve 'fs'</code>。虽然这看起来是一个明显的错误，但对解决方案的探索让我获得了许多真知灼见。</p><p id="1548" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Next.js越来越受欢迎。有一个很好的理由，它使得用React开发服务器端呈现的应用程序变得轻而易举。它拥有令人印象深刻的功能，并且开箱即用。</p><p id="8939" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我的<a class="ae ks" href="https://maikelveen.com/" rel="noopener ugc nofollow" target="_blank">个人网站</a>利用了Next.js，Next.js缺少的一个功能是sitemaps，这是可以理解的，因为它的形成很大程度上取决于具体的数据源和其他变量。</p><p id="149b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我认为花时间为我的网站创建一个网站地图是值得的；这肯定不会伤害搜索引擎优化。实现网站地图功能需要经历重重困难。您可以利用由Next.js的构建过程创建的清单。我在开发过程中遇到了一个奇特的错误:<code class="fe lp lq lr ls b">The Module not found: Can't resolve 'fs'</code>。</p><p id="fe0d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个错误似乎很简单:没有找到文件系统模块。可能是没有安装之类的。然而，使这个错误更加有趣的是它发生在浏览器中。文件系统模块不可用的环境，当然也不应该作为依赖项。</p><p id="c21e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当时解决这个错误对我来说是一个不小的任务，但这个过程让我更好地理解了Next.js是如何工作的。更具体地说，它教会了我更多关于代码捆绑和拆分的知识。本文解释了如何解决这个错误，并强调了错误上下文，希望您在学习的同时了解更多关于Next.js的知识。</p><p id="cc51" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该错误描述找不到模块。究竟什么是模块？首先，让我们回顾一下模块、代码捆绑和拆分是怎么回事。</p><h1 id="ddc3" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">模块和代码捆绑</h1><p id="3732" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在Next.js甚至React出现之前，通常的做法是在一个JavaScript文件中编写整个网站的所有代码。依赖项，比如jQuery，是在这个主脚本加载之前加载到脚本标记中的。然而，随着复杂性和依赖关系的不断增加，跟踪和加载依赖关系的麻烦变得太沉重了。</p><p id="12cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解决方案是将代码库分成模块，这些模块是JavaScript的封装单元。在很长一段时间里，模块系统被类似于<a class="ae ks" href="https://en.wikipedia.org/wiki/CommonJS" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>的项目所模仿。然而，由于ES6模块是带有<code class="fe lp lq lr ls b">import</code>和<code class="fe lp lq lr ls b">export</code>语句的JavaScipt的原生模块。大多数现代浏览器都支持本机模块。更多信息请点击<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank">这里</a>阅读。</p><p id="180c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2021年，我们将我们的代码库分割成模块，并获得许多好处:可维护性和可重用性。最有可能的是，我们所有的模块都在单独的文件中。我们是否在<code class="fe lp lq lr ls b">script</code>标签中单独加载这些内容？不，当然不是！然后，我们将回到起点，并在浏览器中受到相当大的性能打击。</p><p id="7c24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在<em class="mq">代码捆绑</em>开始发挥作用。所有的模块都被打包成一个(或多个)文件，以减少浏览器在加载页面时的请求数量。在前端开发中，当有人提到<em class="mq">构建</em>时，他们通常指的是捆绑。这一步通常包括缩小:从源代码中删除不必要的字符以减小包的大小。</p><p id="e318" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">捆绑包括各种其他任务，可能会变得非常复杂。如今，大多数React应用程序都通过工具捆绑文件，如<a class="ae ks" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae ks" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>或<a class="ae ks" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank">brower versify</a>。</p><h1 id="9f18" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">代码分割</h1><p id="af3c" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">随着代码库的增长，这个包的大小也会增长。现在我们再次面临一个问题。增加包的大小会导致装载时间增加。如果有一件事我们想避免的是缓慢的网页；我们不想考验客人的耐心。</p><p id="2d54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免大的包，我们可以将代码分成多个包。代码分割是大多数捆绑器都支持的一个特性。这是这些捆扎机最引人注目的特点之一。你可以在React <a class="ae ks" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于代码拆分的信息。Next.js是一个构建在React之上的框架。当我们使用Next.js时，我们有一个现成的Webpack设置来捆绑我们的应用程序。</p><h1 id="ce7a" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">下一步捆绑和拆分</h1><p id="4160" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">本质上，Next.js是一个运行在<a class="ae ks" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>运行时环境中的web服务器。它提供特定路径上的页面，这由Next.js项目的<code class="fe lp lq lr ls b">pages</code>文件夹中的文件决定。</p><p id="f423" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用React，JavaScript包由浏览器加载。然后，渲染也由浏览器完成。使用Next.js，这种渲染由web服务器完成。它在服务器端呈现页面并提供输出:HTML。</p><p id="5747" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您构建交互式页面时，这个HTML仍然包含对JavaScript包的多个引用。正如你可能想象的那样，并不是你为一个特定页面编写的所有代码都需要在<em class="mq">所有其他页面上使用。加载这些代码是一种浪费。这就是Next.js的代码分割发挥作用的地方:它从一个代码库创建多个包。</em></p><p id="4d8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着每个页面只加载特定页面所需的JavaScript。这是使用Next.js的好处之一。如果一个特定的页面不使用导入的库，它就不会包含在该页面的JavaScript包中。客户机代码被Next.js自动分解到几个不同的资源中，而不是生成一个包含所有代码的文件。</p><p id="f84b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Next.js中，特定的包被称为块。如何创建块是由一个复杂的代码分割策略决定的，这个策略<a class="ae ks" href="https://nextjs.org/blog/next-9-2#improved-code-splitting-strategy" rel="noopener ugc nofollow" target="_blank">一直在改进</a>。</p><h1 id="90cb" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">解决错误</h1><p id="76a9" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">现在我们明白了什么是代码捆绑和拆分。让我们回顾一下最初导致这项调查的问题。</p><p id="3384" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">The Module not found: Can't resolve 'fs'</code>当您试图导入一个在服务器端可用但在浏览器中不可用的模块时，很可能会出现错误和类似问题。文件系统模块就是一个很好的例子。</p><p id="6ec7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您在服务器端工作时，需要文件系统模块是完全合理的。例如，从磁盘上的文件中提取数据时。但是，该模块在浏览器中不可用，也不应该包含在浏览器包中。</p><p id="fdee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是否意味着您根本不能使用这样的节点模块？不，幸运的是，在Next.js的现代版本(9.4+)上，你可以安全地在<code class="fe lp lq lr ls b">getStaticProps</code>或<code class="fe lp lq lr ls b">getServerSideProps</code>中使用<code class="fe lp lq lr ls b">fs</code>，分别用于<a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" rel="noopener ugc nofollow" target="_blank">静态生成</a>和<a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" rel="noopener ugc nofollow" target="_blank">服务器端渲染</a>。不需要额外的配置。</p><p id="63c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你在那些函数中只引用一个服务器端模块时，依赖关系会被Next.js团队创建的一个定制的Babel插件正确地树摇掉。</p><p id="4ca0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树抖动</a>通过从入口点开始，只包含可能被执行的函数，从包中删除未使用的函数。在Next.js的情况下，通过删除在<code class="fe lp lq lr ls b">getStaticProps</code>或getServerSideProps文件中使用的依赖项和函数来扩展它。</p><p id="5e9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你遇到这个问题时，遵守上面的规则就有可能解决问题。</p><h1 id="8afb" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">代码消除</h1><p id="892f" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">Next.js背后的团队Vercel提供了一个手动工具<a class="ae ks" href="https://next-code-elimination.vercel.app/" rel="noopener ugc nofollow" target="_blank"> y tool </a>来检查浏览器捆绑包中删除了哪些代码。你可以看到，当一个函数只在<code class="fe lp lq lr ls b">getStaticProps</code>或<code class="fe lp lq lr ls b">getServerSideProps</code>中被引用时，它就被删除了。</p><p id="86c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">成交了，对吧？没那么快。即使只从<code class="fe lp lq lr ls b">getStaticProps</code>函数中调用使用文件系统模块的函数，我仍然会得到错误。然后，经过一段时间的困惑，我才明白，这个方法也叫<em class="mq">本身</em>。</p><p id="a57d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个抛出错误的函数是一个递归函数。我发现这样的函数也会导致这个问题的出现。在这种情况下，初始函数调用是在<code class="fe lp lq lr ls b">getServerSideProps</code>中完成的。然而，它也递归地调用自己，这导致它被包含在浏览器包中。</p><p id="425b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，需要将以下代码添加到next.config.js中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b88e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您使用较旧的Next.js版本时，这也是一个解决方案。该配置实际上告诉Webpack为fs创建一个空模块，这有效地抑制了错误。</p><h1 id="ec00" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">运行代码服务器端</h1><p id="6279" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">可以利用其他选项仅在服务器端运行某些代码。您可以在代码中检查window属性，以便在浏览器或服务器上执行一段代码。</p><p id="7096" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以使用以下条件来检查您的代码是否在服务器端执行:<code class="fe lp lq lr ls b">if(typeof window === 'undefined')</code>。该条件范围内的任何内容都只在服务器上执行。</p><p id="8a60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是惯用的检查。如果JavaScript在节点环境中运行，那么几个内部对象，比如<code class="fe lp lq lr ls b">window</code>对象，是不可用的。当我们检查对象的存在时，我们可以有效地确定我们是否在服务器端。</p><p id="7bc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更令人惊讶的是，Next.js还从浏览器捆绑包中删除了使用这些检查的代码，作为一种构建时优化的形式。浏览器捆绑包将不包括条件范围内的内容。</p><h1 id="3017" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><blockquote class="mt mu mv"><p id="0938" class="kt ku mq kv b kw kx jo ky kz la jr lb mw ld le lf mx lh li lj my ll lm ln lo ig bi translated"><em class="in">这是一件痛苦的事情</em></p><p id="4c37" class="kt ku mq kv b kw kx jo ky kz la jr lb mw ld le lf mx lh li lj my ll lm ln lo ig bi translated"><em class="in">看看自己的烦恼就知道了</em></p><p id="8251" class="kt ku mq kv b kw kx jo ky kz la jr lb mw ld le lf mx lh li lj my ll lm ln lo ig bi translated">你自己而不是其他人成功了</p><p id="4864" class="kt ku mq kv b kw kx jo ky kz la jr lb mw ld le lf mx lh li lj my ll lm ln lo ig bi translated"><em class="in"> -索福克勒斯，阿贾克斯</em></p></blockquote><p id="853e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么主要外卖是什么呢？如果您以前不熟悉这些概念，那么希望您已经学习了一些关于代码捆绑和拆分的知识。</p><p id="8f82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，这里还有一个更重要的教训。我通过简单的谷歌搜索找到了问题的解决方案。然而，我并不完全理解问题的解决方案和确切原因。我可以应用这个补丁，继续做其他的事情。</p><p id="f1cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在谷歌上搜索解决方案，应用它，然后继续前进，却不了解错误的微妙之处或原因，这是软件开发人员比他们愿意承认的更经常做的事情，包括我自己。有时我们时间紧迫，没有时间深入挖掘，这是可以理解的。但是如果情况允许，我们应该后退一步，认识到每个错误的背后都是潜在的知识宝库。</p><p id="d30f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个有经验的前端开发人员很可能会对这个错误毫不在意。然而，我用它来识别知识缺口，并成功地采取了行动。如果你正面临类似的情况，我建议你尝试同样的方法。感谢您的阅读！</p><h1 id="86b3" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">进一步阅读</h1><div class="mz na gp gr nb nc"><a href="https://www.simplethread.com/javascript-modules-and-code-bundling-explained/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">用JavaScript模块解开代码捆绑之谜——简单线程</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">什么是JavaScript捆绑？什么是ECMAScript模块？这篇文章解释了我们如何来到这里，并删除了一些…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.simplethread.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">JavaScript模块</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">本指南为您提供了开始使用JavaScript模块语法所需的一切。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">developer.mozilla.org</p></div></div><div class="nl l"><div class="nr l nn no np nl nq km nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://reactjs.org/docs/code-splitting.html" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd io gy z fp nh fr fs ni fu fw im bi translated">代码分解-反应</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">大多数React应用程序会使用Webpack、Rollup或Browserify等工具“捆绑”文件。捆绑是一个过程…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">reactjs.org</p></div></div><div class="nl l"><div class="ns l nn no np nl nq km nc"/></div></div></a></div></div></div>    
</body>
</html>