# 算法练习:检查有效的子序列

> 原文：<https://javascript.plainenglish.io/algorithm-practice-checking-for-a-valid-subsequence-9753fe28caad?source=collection_archive---------10----------------------->

![](img/a390719596a845b7d1c3c3d94acdc9e0.png)

Photo by [Laura Ockel](https://unsplash.com/@viazavier?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/algorithm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

提高算法水平的唯一方法是通过一致性和实践——所以让我们回到另一个算法实践。本周，我们将看看*验证子序列*算法。这是一个非常常见且相对简单的算法，所以如果你刚开始学习算法，这是一个很好的练习方法。

让我们来看看这个问题:

## **给定两个非空的整数数组，判断第二个数组是否是第一个数组的有效子序列。**

请注意，数组中的单个数字以及数组本身都是数组的有效子序列。

在我们深入这个问题之前，让我们首先确定我们知道什么是子序列。**子序列**是可以通过移除一些(或不移除)元素而不改变任何剩余元素的顺序从原始序列中获得的序列。

我们将通过几个例子来说明这个概念:

```
array = [7, 10, 5, 3, -1, -8, 11]
sequence = [7, 5, 11]
```

在上面的例子中，序列*是数组的有效子序列*。我们可以通过从原始数组中移除 10，3， *-* 1 和-8 来获得序列，而无需重新排列剩余的元素。

```
array = [72, 0, 1, 3, 3, 10, -13, 22]
sequence = [72, 0, -13, 10, 22]
```

上述序列*不是*数组的有效子序列。我们可以从数组中删除整数 1、3 和 3，得到[72，0，10，-13，22]，但是-13 和 10 必须重新排列才能匹配。

## **概念演练**

在我们开始编写解决方案之前，让我们先来看一下如何找到这个问题的解决方案。想想你是如何完成上面的例子的。浏览例子并清楚地说明你在每一步都做了什么，这对于找出解决方案非常有帮助。

我们可以设置两个指针，一个用于数组，一个用于序列，从每一个的开头开始。在每次迭代中，我们希望将数组中的当前数字与潜在子序列中的当前数字进行比较。如果数组中的数字等于潜在子序列中的数字，我们将把两个指针都向右移动一位，继续比较下一个元素。如果它们不相等，我们将只移动主数组指针，并将这个新的当前数组元素与序列元素进行比较。我们将继续这个过程，直到到达数组的末尾或序列的末尾。

我们如何知道序列是否确实是数组的子序列？当我们在数组中找到匹配时，我们只移动序列指针。因此，如果我们能够在到达主数组末尾之前遍历整个序列，我们就知道它是一个子序列。如果不是，它不是一个子序列。

## **代码演练**

现在我们已经理解了解决方案的概念，我们可以开始编码了。先自己试一试。

在上面的解决方案中，我为序列设置了一个指针(sequenceIndex)，并将其初始化为 0。使用 for 循环，我为数组设置了一个指针(arrayIndex)，它也从 0 开始。只要 arrayIndex 小于数组的长度，for 循环就会运行，并且 arrayIndex 在 for 循环的每次迭代中都会增加。在循环内部，我们检查当前数组元素是否与当前序列元素深度相等，如果是，我们将 sequenceIndex 增加 1。请记住，无论这两个元素是否相等，arrayIndex 都会增加 1。退出 for 循环后，我们将根据 sequenceIndex 是否等于序列的长度返回一个布尔值。这让我们知道我们是否能够完成整个序列——如果我们完成了序列，我们知道它是一个子序列。

## **空间/时间复杂度**

这个解在线性(O(n))时间和常数(O(1))空间中运行。相当高效！