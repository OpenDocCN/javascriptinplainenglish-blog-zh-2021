<html>
<head>
<title>Connecting React with LocalStorage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接React和LocalStorage</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/connecting-react-with-localstorage-ad590d4e4fa1?source=collection_archive---------1-----------------------#2021-02-09">https://javascript.plainenglish.io/connecting-react-with-localstorage-ad590d4e4fa1?source=collection_archive---------1-----------------------#2021-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e910" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建LocalStorage React挂钩的指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cdc4efcf103f82236f22fbe26f15bfb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jasUTv3tx1RQXB5_"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="bfa4" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">我的旅程</h2><p id="b8d3" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">当localStorage更改时，React不会重新呈现。为了在UI上更新localStorage值，我需要通过更新一个未使用的状态来强制组件重新呈现。这感觉像是让这个简单的概念工作的不必要的修改。如何让localStorage与React更紧密地集成在一起？</p><h2 id="b1c8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">本地存储挂钩</h2><p id="bf44" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">利用React的<code class="fe mi mj mk ml b">useState</code>钩子，我们可以创建一个<code class="fe mi mj mk ml b">useLocalStorage</code>钩子来解决我们的问题。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="6d01" class="kt ku in ml b gy mq mr l ms mt">function useLocalStorage(key, initialState) {<br/>  const [value, setValue] = useState(localStorage.getItem(key) ?? initialState);<br/>  const updatedSetValue = useCallback(<br/>    newValue =&gt; {<br/>      if (newValue === initialState || typeof newValue === 'undefined') {<br/>        localStorage.removeItem(key);<br/>      } else {<br/>        localStorage.setItem(key, newValue);<br/>      }<br/>      setValue(newValue ?? initialState);<br/>    },<br/>    [initialState, key]<br/>  );<br/>  return [value, updatedSetValue];<br/>}</span></pre><p id="a91d" class="pw-post-body-paragraph lp lq in lr b ls mu jo lu lv mv jr lx lc mw lz ma lg mx mc md lk my mf mg mh ig bi translated">这将把数据保存到localStorage并触发组件重新呈现，从而在UI上反映新的localStorage值。它接受一个用作本地存储键的字符串<code class="fe mi mj mk ml b">key</code>和一个用于初始化<code class="fe mi mj mk ml b">useState</code>的字符串<code class="fe mi mj mk ml b">initialState</code>，如果<code class="fe mi mj mk ml b">key</code>的值不存在的话。然后，它使用更新的setter函数返回该值，该函数将更新localStorage和state。</p><p id="3d15" class="pw-post-body-paragraph lp lq in lr b ls mu jo lu lv mv jr lx lc mw lz ma lg mx mc md lk my mf mg mh ig bi translated">要使用，让用户与之交互的任何UI元素调用setter函数。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="db43" class="kt ku in ml b gy mq mr l ms mt">const Component = () =&gt; {<br/>  const [value, setValue] = useLocalStorage('key', 'initial'); <br/>  return (<br/>    &lt;input<br/>      onChange={e =&gt; setValue(e.target.value)}<br/>      value={value ?? ''}<br/>    /&gt;<br/>  );<br/>};</span></pre><p id="854b" class="pw-post-body-paragraph lp lq in lr b ls mu jo lu lv mv jr lx lc mw lz ma lg mx mc md lk my mf mg mh ig bi translated">重要的是使用setter函数，而不是直接使用<code class="fe mi mj mk ml b">localStorage.setItem</code>。如果您使用这个setter函数来更新localStorage，React只会重新渲染。</p><h2 id="d925" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">非字符串值</h2><p id="aa29" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">上面的实现只支持字符串值，因为这是localStorage官方支持的。然而，通过使用<code class="fe mi mj mk ml b">JSON.stringify</code>和<code class="fe mi mj mk ml b">JSON.parse</code>将布尔值、数字和对象转换为字符串，仍然可以支持它们。使用这个概念，<code class="fe mi mj mk ml b">useLocalStorage</code>可以扩展到支持非字符串值。</p><pre class="kd ke kf kg gt mm ml mn mo aw mp bi"><span id="c0eb" class="kt ku in ml b gy mq mr l ms mt">function useLocalStorageNonString(key, initialState) {<br/>  const serializedInitialState = JSON.stringify(initialState);<br/>  let storageValue = initialState;<br/>  try {<br/>    storageValue = JSON.parse(localStorage.getItem(key)) ?? initialState;<br/>  } catch {<br/>    localStorage.setItem(key, serializedInitialState);<br/>  }<br/>  const [value, setValue] = useState(storageValue);<br/>  const updatedSetValue = useCallback(<br/>    newValue =&gt; {<br/>      const serializedNewValue = JSON.stringify(newValue);<br/>      if (<br/>        serializedNewValue === serializedInitialState ||<br/>        typeof newValue === 'undefined'<br/>      ) {<br/>        localStorage.removeItem(key);<br/>      } else {<br/>        localStorage.setItem(key, serializedNewValue);<br/>      }<br/>      setValue(newValue ?? initialState);<br/>    },<br/>    [initialState, serializedInitialState, key]<br/>  );<br/>  return [value, updatedSetValue];<br/>}</span></pre><p id="17e2" class="pw-post-body-paragraph lp lq in lr b ls mu jo lu lv mv jr lx lc mw lz ma lg mx mc md lk my mf mg mh ig bi translated">在将值保存到localStorage之前，它被转换为字符串，在从localStorage读取值之后，它被转换为对象(或布尔或数字)。因为我们永远不能保证localStorage中的值是有效的JSON，所以我们还必须处理任何解析错误。</p><h2 id="9f9d" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">警告</h2><p id="eb6e" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">如果用户手动更改localStorage值，或者应用程序的某个其他部分在不使用<code class="fe mi mj mk ml b">useLocalStorage</code>更新程序的情况下更改该值，<code class="fe mi mj mk ml b">useLocalStorage</code>将不会更新到该新值。不幸的是，没有解决这个问题的办法，因为这是浏览器的限制。它们确实提供了一个您可以监听的存储事件<code class="fe mi mj mk ml b">window.addEventListener('storage', &lt;handler&gt;)</code>，但是只有当存储事件从另一个选项卡或窗口被触发时，这个处理程序才会被触发。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="8e71" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最后的想法</h2><p id="2bc9" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我真的希望有一种本地的方式来对本地存储的变化做出反应。但是即使没有本地实现，您也可以使用自己的<code class="fe mi mj mk ml b">useLocalStorage</code>钩子来实现该功能。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="b4c9" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">资源</h2><ul class=""><li id="1e96" class="ng nh in lr b ls lt lv lw lc ni lg nj lk nk mh nl nm nn no bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/use-local-storage" rel="noopener ugc nofollow" target="_blank">本文Github回购</a></li><li id="affe" class="ng nh in lr b ls np lv nq lc nr lg ns lk nt mh nl nm nn no bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/use-local-storage" rel="noopener ugc nofollow" target="_blank">本文的CodeSandbox】</a></li></ul></div></div>    
</body>
</html>