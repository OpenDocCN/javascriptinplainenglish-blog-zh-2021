<html>
<head>
<title>How to create RxJS Custom Operators Chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建RxJS自定义运算符链</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-custom-chain-operators-b0c45e3be298?source=collection_archive---------7-----------------------#2021-02-22">https://javascript.plainenglish.io/rxjs-custom-chain-operators-b0c45e3be298?source=collection_archive---------7-----------------------#2021-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fcab7a7c5e79c45eb631e3bd492598b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJQLH9QE0J42zJ605dwLOw.png"/></div></div></figure><p id="659d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">先决条件:Javascript，Typescript，RxJs操作符，RxJs管道，可观察，订阅。</em></p><p id="f7f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">RxJs提供了强大的功能和简单的javascript反应式编程方法。它有很多内置的操作符，但是有时候，你只需要创建自己的操作符。</p><p id="158f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用一些内置的操作符，比如filter，很容易创建一个简单的操作符。我们将从简单的开始，然后我们将创建一个更复杂的，不使用内置的操作符，只是从零开始。</p><p id="9ca5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用内置运算符创建运算符</strong></p><p id="ba19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从一个流中创建一个乘2操作符。这很简单，因为我们可以使用现有的map操作符并返回一个新的可观察值。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="81d3" class="ld le in kz b gy lf lg l lh li">function doubleTheValues() {</span><span id="9c37" class="ld le in kz b gy lj lg l lh li">    return function&lt;T&gt;(source: Observable&lt;T&gt;) {</span><span id="d338" class="ld le in kz b gy lj lg l lh li">    return source.pipe(map(value =&gt; value * 2));</span><span id="c593" class="ld le in kz b gy lj lg l lh li">}</span></pre><p id="8b92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用它，我们将遵循与使用内置操作符相同的原则。考虑一个可观察的:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="5ffa" class="ld le in kz b gy lf lg l lh li">import { interval } from 'rxjs';</span><span id="cb83" class="ld le in kz b gy lj lg l lh li">import { map } from 'rxjs/operators';</span><span id="fc21" class="ld le in kz b gy lj lg l lh li">const myIntervalObservable = interval(200);</span></pre><p id="9336" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要使用我们的新运算符，只需:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9e71" class="ld le in kz b gy lf lg l lh li">myIntervalObservable.pipe(</span><span id="0964" class="ld le in kz b gy lj lg l lh li">    doubleTheValues()</span><span id="f153" class="ld le in kz b gy lj lg l lh li">).subscribe();</span></pre><p id="9415" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，正如您所看到的，如果我们需要更复杂的逻辑或不同的条件，仅仅使用现有的操作符会变得非常困难。</p><p id="eab2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比方说，我们需要两个操作符，根据流中的对象返回不同的值。</p><p id="7ebc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以用户流为例。用户对象有一个属性，表明用户是否是管理员，我们称之为<code class="fe lk ll lm kz b">isAdmin</code>。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="3373" class="ld le in kz b gy lf lg l lh li">class User {<br/>    name: string;<br/>    email: string;<br/>    isAdmin: boolean;<br/>}</span></pre><p id="9b19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于<code class="fe lk ll lm kz b">isAdmin</code>属性，我们要做出不同的逻辑。如果没有自定义操作符，我们可以通过以下方式实现:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="dfb3" class="ld le in kz b gy lf lg l lh li">myUserObservable: Observable&lt;User&gt;;<br/>constructor() {<br/>    this.myUserObservable.subscribe((user) =&gt; {<br/>        if (user.isAdmin) {<br/><em class="kt">            // do some admin logic<br/></em>        } else {<br/><em class="kt">            // do some non admin logic<br/></em>        }<br/><em class="kt">        // do logic regardless user is admin or not<br/></em>   })<br/>}</span></pre><p id="8f43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，正如你所看到的，这很烦人，因为我们必须使用if / else表达式，如果将来<code class="fe lk ll lm kz b">isAdmin</code>必须改变，我们将需要在每个使用该属性的文件中改变。</p><p id="2281" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，我们可以创建两个自定义操作符并使用它们。让我们看看怎么做。</p><p id="f7b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于管理员用户，我们会这样做:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="c8ad" class="ld le in kz b gy lf lg l lh li">export function <em class="kt">userIsAdmin</em>(callback: (user: User) =&gt; void) {</span><span id="dbb1" class="ld le in kz b gy lj lg l lh li">    return (source) =&gt; {<br/>        return new Observable((subscriber: Subscriber&lt;User&gt;) =&gt; {<br/>          return source.subscribe({<br/>            next(user: User) {<br/>              if (user.isAdmin) {<br/>                 try {<br/>                    callback(user);<br/>                 } catch (e) {<br/>                    console.error(e);<br/>                 }<br/>              }<br/>              subscriber.next(user);<br/>           },<br/>           error(err) {<br/>             subscriber.error(err);<br/>           },<br/>           complete() {<br/>             subscriber.complete();<br/>          }<br/>       })<br/>    })<br/>  }<br/>}</span></pre><p id="6cc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们可以看到我们的函数正在接收一个回调函数，它接收一个用户并返回void。我们的函数只需要接收观察对象，订阅它，检查用户是否是管理员，调用回调函数并返回与接收到的观察对象相同的观察对象。</p><p id="86c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要返回接收到的可观察值，因为在我们的链管道中，如果用户不是管理员，我们希望移动到下一个操作符。</p><p id="6f2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于非管理员用户:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="2eaa" class="ld le in kz b gy lf lg l lh li">export function <em class="kt">userIsNotAdmin</em>(callback: (user: User) =&gt; void) {</span><span id="febe" class="ld le in kz b gy lj lg l lh li">return (source) =&gt; {<br/>        return new Observable((subscriber: Subscriber&lt;User&gt;) =&gt; {<br/>          return source.subscribe({<br/>            next(user: User) {<br/>              if (!user.isAdmin) {<br/>                 try {<br/>                    callback(user);<br/>                 } catch (e) {<br/>                    console.error(e);<br/>                 }<br/>              }<br/>              subscriber.next(user);<br/>           },<br/>           error(err) {<br/>             subscriber.error(err);<br/>           },<br/>           complete() {<br/>             subscriber.complete();<br/>          }<br/>       })<br/>    })<br/>  }<br/>}</span></pre><p id="4d38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们的逻辑看起来更清晰，也更容易理解和扩展。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="85e6" class="ld le in kz b gy lf lg l lh li">this.myUserObservable.pipe(<br/><em class="kt">    userIsAdmin</em>((user: User) =&gt; {<br/><em class="kt">      // do admin user logic<br/></em>    }),<br/><em class="kt">    userIsNotAdmin</em>((user: User) =&gt; {<br/><em class="kt">      // do non admin user logic<br/></em>    })<br/>  ).subscribe((user: User) =&gt; {<br/><em class="kt">    // do logic regardless user is admin or not<br/></em>})</span></pre><p id="7cfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们如何创建自定义操作符，并在我们的项目中使用它们，以使代码更加简洁和易于扩展。</p><p id="7ce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> PS: </strong>如果你需要一个正常运行时间监控工具，只需检查<a class="ae ln" href="https://robomiri.com" rel="noopener ugc nofollow" target="_blank"> RoboMiri </a>。最好的免费正常运行时间监测服务。</p></div></div>    
</body>
</html>