<html>
<head>
<title>Learn Sequelize in 7 Minutes: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7分钟学会序列:第一部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/save-time-learn-sequelize-in-7-mins-part-1-3e4fde67d037?source=collection_archive---------3-----------------------#2021-05-06">https://javascript.plainenglish.io/save-time-learn-sequelize-in-7-mins-part-1-3e4fde67d037?source=collection_archive---------3-----------------------#2021-05-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ed141c576d3dcaeac3e46d3504b0168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bMcQcLAE-fPjVEhnY5xsQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Sequelize: Node.js ORM</figcaption></figure><p id="eb85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">ORM或“对象关系映射”是一种使用面向对象编程语言在不兼容类型系统之间转换数据的编程技术。这意味着它旨在简化数据库管理。顾名思义，它们在关系数据库中自动映射出我们代码中的对象(实体)。</p><p id="a781" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">开发人员可以轻松地与数据进行交互，并使用本机类而不是编写查询来执行创建、读取、更新和删除等常见操作。由于查询是由Sequelize生成的，我们作为开发人员在数据库上有一个抽象层，我们可以在技术上交换整个数据库，并在项目生命周期的后期进行最小的代码更改。Sequelize是mongoose、Prisma、TypeORM等等中最流行的node.js ORM之一。Sequelize比waterline功能丰富得多，water line是Sails.JS的默认表单。</p><blockquote class="kx ky kz"><p id="75f6" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">“Sequelize是一个基于promise的Node.js ORM，适用于Postgres、MySQL、MariaDB、SQLite和Microsoft SQL Server。它具有可靠的事务支持、关系、急切加载和延迟加载、读取复制等特性。”—来自https://sequelize.org/<a class="ae le" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank">的定义</a></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/737a6ffd6858c8a85a060b74f3885afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aw9BWOxl6h2JnDcQBJQ2fA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">ORM Logic</figcaption></figure><p id="f3d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在今天的帖子中，我们将学习如何在Node.js中安装Sequelize，什么是模型，什么是模型实例&amp;如何查询它们。我们将在Express Node.js框架中使用Sequelize。让我们开始吧。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="05c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">步骤1: </strong>使用NPM安装Sequelize和Sequelize CLI。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="4822" class="lw lx in ls b gy ly lz l ma mb">npm install --save sequelize<br/>npm install --save sequelize-cli<br/>npm install --save mysql2</span></pre><p id="00a8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第二步:</strong>用下面的命令初始化Sequelize。该命令将创建基本配置文件&amp;数据库连接。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="8aa0" class="lw lx in ls b gy ly lz l ma mb">node_modules/.bin/sequelize init</span></pre><p id="708d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将创建:<br/> <strong class="kb io"> a. </strong>带有config.json文件的config文件夹，其中包含三种环境的数据库连接参数。<br/> <strong class="kb io"> b. </strong>用于迁移数据的迁移文件夹。<br/> <strong class="kb io"> c. </strong>包含index.js文件的models文件夹，该文件包含用于连接到数据库的Sequelize实例。<br/> <strong class="kb io"> d. </strong> seeders文件夹，包含seeders数据文件。</p><p id="6642" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第三步:</strong>模型定义。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="2adb" class="lw lx in ls b gy ly lz l ma mb">module.exports = (sequelize, DataTypes) =&gt; {<br/> const User = sequelize.define('User', {<br/>  email: {<br/>   type: DataTypes.STRING,<br/>   primaryKey: true,<br/>   unique: true,<br/>  },<br/>  uuid: {<br/>   type: DataTypes.UUID,<br/>   defaultValue: DataTypes.UUIDV4,<br/>  },<br/>  phoneNo: {<br/>   type: DataTypes.STRING,<br/>  },<br/>  countryCode: {<br/>   type: DataTypes.STRING,<br/>  },<br/>  firstName: {<br/>   type: DataTypes.STRING,<br/>   allowNull: false,<br/>  },<br/>  lastName: {<br/>   type: DataTypes.STRING,<br/>  },<br/>  password: {<br/>   type: DataTypes.STRING,<br/>  },<br/>  age: {<br/>   type: DataTypes.STRING,<br/>  },<br/>  gender: {<br/>   type: DataTypes.STRING,<br/>   validate: {<br/>    isIn: [[<br/>     'FEMALE'<br/>     'MALE',<br/>     'OTHER'<br/>    ]],<br/>   }<br/>  },<br/> }, {<br/> indexes: [{<br/>  fields: ['gender'],<br/> }],<br/> defaultScope: {<br/>  attributes: {<br/>   exclude: [<br/>    'password',<br/>   ]},<br/>  },<br/> })</span><span id="6fd6" class="lw lx in ls b gy mc lz l ma mb">User.associate = function (models) {<br/> models.User.hasMany(models.Posts, {<br/>  foreignKey: 'email',<br/>  sourceKey: 'email',<br/> })<br/> models.User.hasOne(models.UserSubscription, {<br/>  foreignKey: 'email',<br/>  sourceKey: 'email',<br/> })<br/>}<br/>return User<br/>}</span></pre><p id="8481" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Sequelize中的模型只不过是数据库中的表。模型告诉Sequelize它所代表的实体，例如数据库中表的名称以及它包含哪些列(以及它们的数据类型)。模型的每个实例都是数据库中的一行。在Sequelize中，可以用两种等效的方式定义模型:</p><ul class=""><li id="91a4" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated">调用<strong class="kb io"> sequelize.define(型号名称，属性，选项)</strong></li><li id="3708" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">扩展<a class="ae le" href="https://sequelize.org/master/class/lib/model.js~Model.html" rel="noopener ugc nofollow" target="_blank">模型</a>并调用<strong class="kb io"> init(属性，选项)</strong></li></ul><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="ce19" class="lw lx in ls b gy ly lz l ma mb">module.exports = (sequelize, DataTypes, Model) =&gt; {<br/>class User extends Model { }<br/>return User.init({<br/>  firstName: {<br/>   type: DataTypes.STRING,<br/>   allowNull: false<br/>  },<br/>  lastName: {<br/>   type: DataTypes.STRING<br/>  }<br/> }, {<br/>  sequelize,<br/>  modelName: 'User'<br/> });<br/>}</span></pre><p id="8756" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在内部sequelize.define调用Model.init方法，所以两者给出相同的结果。让我们来了解一下每个参数:<br/> <strong class="kb io">一、</strong> email指定了一个列的名称，这个列是一个对象，包含了每个列的属性，像<br/><strong class="kb io"><em class="la"/></strong>。type定义列的数据类型。例如，字符串、浮点、布尔等。点击了解更多关于数据类型<a class="ae le" href="https://sequelize.org/master/manual/model-basics.html#data-types" rel="noopener ugc nofollow" target="_blank">的信息。<br/><strong class="kb io"><em class="la">b .</em></strong>unique包含一个布尔值，指定一列是否有唯一约束。如果插入重复值，sequelize将抛出错误“sequelizeuniqueconstrainerror”<br/><strong class="kb io"><em class="la">c .</em></strong>主键包含一个布尔值，该值指定某列是否为主键。<br/><strong class="kb io"><em class="la">d .</em></strong>default value指定在插入行时如果传递了null，则插入的默认值。<br/><em class="la"/><strong class="kb io"><em class="la">e .</em></strong>允许空指定一列是否允许接受空值。如果试图将null设置为不允许null的字段，将抛出“ValidationError”而不执行任何SQL查询。<br/><em class="la"/><strong class="kb io"><em class="la">f .</em></strong>validate用于验证列，就像是email的值匹配email格式或者isIn validates传入的值必须是指定的值之一。例如，性别必须是“女性”、“男性”或“其他”。如果验证失败，Sequelize将抛出一个错误。点击</a>了解更多关于验证的信息。</p><p id="2a13" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">二。</strong>索引指定要索引的字段数组<br/> <strong class="kb io"> iii </strong>。默认范围指定用于帮助您重用代码的对象。在上面的例子中，我们想要排除密码属性。这意味着它不应该被任何人看到。<br/> <strong class="kb io">四世。</strong> ModelName.associate函数用于指定两个模型之间的关联。你可以在下一个帖子中了解更多关于该协会的信息。</p><p id="1870" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第四步:</strong>模型实例</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="3bad" class="lw lx in ls b gy ly lz l ma mb">router.post('/create_user', (req, res) =&gt; {<br/> if (!req.body.email) {<br/>  throw new Error('Email is required')<br/> }<br/> return models.User.create(req.body).then((user) =&gt; {<br/>   res.send(user)<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span></pre><p id="e43c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">即使模型是一个类，它的实例也不是使用new()创建的。相反，Sequelize使用build &amp; save方法来插入记录。build方法创建模型的一个实例，save方法用于插入记录。Sequelize使用ModelName.create方法在内部调用build和save方法的表中插入记录。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="2ead" class="lw lx in ls b gy ly lz l ma mb">const users = await User.bulkCreate([   <br/> { email: 'Johndoe@example.com' },   <br/> { email: 'willsmitch@domain.in' } <br/>]);</span></pre><p id="4821" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Sequelize提供了Model.bulkCreate方法，允许只使用一个查询一次创建多个记录。Model.bulkCreate的用法与Model.create非常相似，都是接收一个对象数组而不是单个对象。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="eb75" class="lw lx in ls b gy ly lz l ma mb">// using update method<br/>router.put('/update_user', (req, res) =&gt; {<br/> return models.User.update({<br/>   firstName: 'John',<br/>   age: ' 45 Years'<br/>  },{<br/>   where: {<br/>    email: "testuser@example.com",<br/>   }<br/> }).then((user) =&gt; {<br/>   res.send(user)<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span><span id="7137" class="lw lx in ls b gy mc lz l ma mb">// using save method<br/>router.put('/update_user', (req, res) =&gt; {<br/> return models.User.findByPk("testuser@example.com").then(async  (user) =&gt; {<br/>   if (!user) {<br/>    throw an Error ('User not found')<br/>   }<br/>   user.firstName = 'John'<br/>   user.age = ' 45 Years'<br/>   await user.save()<br/>   res.send(user)<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span></pre><p id="5aed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Sequelize使用update方法更新实例列值。“where”参数是必需的，否则Sequelize将抛出一个错误。您可以通过首先调用findByPk或findOne方法来更新该行。这将获取模型实例&amp;使用instance.save方法来更新行。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="7c51" class="lw lx in ls b gy ly lz l ma mb">router.delete('/delete_user', (req, res) =&gt; {<br/> return models.User.findByPk("testuser@example.com").then(async  (user) =&gt; {<br/>   if (!user) {<br/>    throw an Error ('User not found')<br/>   }<br/>   await user.destroy()<br/>   res.send("user deleted")<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span><span id="698a" class="lw lx in ls b gy mc lz l ma mb">router.delete('/delete_user', (req, res) =&gt; {<br/>  return models.User.destroy({<br/>   where: {<br/>    email: "testuser@example.com",<br/>   }<br/> }).then(() =&gt; {<br/>   res.send("user deleted")<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span></pre><p id="0f20" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Sequelize使用destroy方法从表中删除行。Destroy方法也接受“where”选项，就像上面显示的read查询一样。</p><p id="2c1d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第五步:</strong>模型查询。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="d165" class="lw lx in ls b gy ly lz l ma mb">router.get('/all_users', (req, res) =&gt; {<br/> if (!req.query.limit) {<br/>  req.query.limit = 10<br/> }<br/> if (!req.query.offset) {<br/>  req.query.offset = 10<br/> }<br/> return models.User.findAll({<br/>   order: [['createdAt', 'DESC']],<br/>   limit: parseInt(req.query.limit, 10),<br/>   attributes: ['firstName', 'email', 'lastName'],<br/>   offset: parseInt(req.query.offset, 10),<br/> }).then((users) =&gt; {<br/>   res.send(users)<br/> }).catch((err) =&gt; {<br/>  res.status(501).send(err.message)<br/> })<br/>})</span></pre><p id="828e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Sequelize提供了4种查询数据库的查找器方法，可以生成“选择”查询。默认情况下，所有finder方法的结果都是model类的实例。这意味着在数据库返回结果后，Sequelize会自动将所有内容包装在适当的实例对象中。在少数情况下，当有太多结果时，这种包装可能是低效的。要禁用这种包装并接收普通响应，将<em class="la"> </em> <code class="fe mr ms mt ls b">{ raw: true }</code> <em class="la"> </em>作为选项传递给finder方法。<br/> <strong class="kb io">我</strong>。FindAll生成一个标准的SELECT查询，从表中检索所有条目，它受到类似where子句的限制。<br/> <strong class="kb io">二</strong>。FindByPk方法使用提供的主键从表中只获取一个条目。<br/> <strong class="kb io">三</strong>。FindOne方法获取它找到的满足可选查询选项的第一个条目。一般来说，它带有一个where子句，而不是主键。<br/> <strong class="kb io">四</strong>。findOrCreate将检查一个表是否包含任何符合条件的记录，如果没有找到，将在表中创建一个条目。在这两种情况下，它都将返回一个实例(找到的实例或创建的实例)和一个布尔值，该值指示该实例是创建的还是已经存在。where选项用于查找记录，defaults选项用于定义在没有找到记录的情况下必须创建的内容。Sequelize将采用给定的值，其中默认值不包含每一列的值。<br/> <strong class="kb io">五、</strong>findandcountal方法是一种结合了findAll和count的便捷方法。这在处理与分页相关的查询时很有用，在这种情况下，您希望检索带有限制和偏移量的数据，但还需要知道与查询匹配的记录总数。findAndCountAll方法返回一个具有两个属性的对象:1。count——一个整数——与查询匹配的记录总数。2.rows -对象的数组-获得的记录。</p><p id="9e2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的例子中，我们可以传递选项来查找像<br/> <strong class="kb io"> a. </strong>这样的记录，属性包含一个要写入的列名数组。当用户只需要特定的列而不是所有的列时，这很有用。<br/> <strong class="kb io"> b. </strong>其中一个对象包含一个列名和要应用于它的条件。例如，您想要查找印度的所有用户。</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="57f4" class="lw lx in ls b gy ly lz l ma mb">where: {<br/> country: 'India'<br/>}</span></pre><p id="a744" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> c. </strong> order包含带有‘ASC’&amp;‘desc’选项的列数组。例如，您想要一个按创建日期降序排列的用户列表。<br/> <strong class="kb io"> d. </strong>限制&amp;偏移用于限制和分页。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="9aaa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将在接下来的文章中讨论高级主题，如序列关联、关系、急切加载、懒惰加载、事务等等。</p><p id="61e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="la">感谢阅读。</em> </strong></p><p id="adea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="la">更多内容请看</em><a class="ae le" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="la">plain English . io</em></a></p></div></div>    
</body>
</html>