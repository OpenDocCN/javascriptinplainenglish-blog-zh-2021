<html>
<head>
<title>Querying and Transforming JSON Using JSON-fx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON-fx查询和转换JSON</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/querying-and-transforming-json-using-json-fx-6ac099a37c3?source=collection_archive---------17-----------------------#2021-03-16">https://javascript.plainenglish.io/querying-and-transforming-json-using-json-fx-6ac099a37c3?source=collection_archive---------17-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0ae8a0b25b3c2631282a127b830dc372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GN_6WtYMUJczbXFY.jpeg"/></div></div></figure><p id="e866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> JSON-fx </strong>是JavaScript的对象查询和转换引擎。它定义了一种直观的声明性语法，用于将输出值表示为一个或多个输入值的函数。</p><p id="1867" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用例可以包括任何场景，其中JSON数据的值查询或整个JSON对象的转换最好通过运行时配置实现，而不是硬编码到应用程序逻辑中。</p><p id="2c64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JSON-fx表达式嵌入在称为模板的JSON对象中，模板在运行时被解析和编译成表达式树。这些是它们执行的本地JavaScript代码的高效轻量级包装器。该库包括大量内置函数和操作符，并且易于扩展。</p><p id="829e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JSON-fx核心库包括解析器/编译器和一组内置函数，没有外部运行时依赖性，占用空间非常小。</p><h1 id="237e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">装置</h1><p id="a003" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">像许多现代JavaScript库一样，JSON-fx是作为NPM包分发的。将JSON-fx安装到Node.js项目或使用NPM的现代浏览器客户端项目(如Angular或React项目)中:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="370a" class="mf ku in mb b gy mg mh l mi mj">npm install @mindsung/json-fx</span></pre><h1 id="425e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">简单的例子</h1><p id="14c0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这将在后面解释，但是让我们从一个非常简单的例子开始，这个例子演示了这个库的基本用法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ffc2" class="mf ku in mb b gy mg mh l mi mj">import { JsonFx } from "@mindsung/json-fx";</span><span id="a41b" class="mf ku in mb b gy mk mh l mi mj">const myInput = { n1: 10, n2: 5, s: "world!" };</span><span id="8de9" class="mf ku in mb b gy mk mh l mi mj">const myTemplate = {<br/>  mySum: "$.n1 + $.n2",<br/>  myText: "'Hello, ' + $.s"<br/>};</span><span id="6fab" class="mf ku in mb b gy mk mh l mi mj">const fx = new JsonFx();<br/>const compiled = fx.compile(myTemplate);<br/>const output = compiled.evaluate({ name: "$", value: myInput });</span></pre><p id="7709" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">产生输出:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5167" class="mf ku in mb b gy mg mh l mi mj">{<br/>  mySum: 15,<br/>  myText: "Hello, world!"<br/>}</span></pre><h1 id="30d8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模板输入</h1><p id="5ad8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">模板评估通常包括一个或多个输入值。通常，只有一个输入，通常命名为<code class="fe ml mm mn mb b">"$"</code>，如上面的基本用法示例所示。但是，可以提供任意数量的指定输入值。这些输入变量名必须以<code class="fe ml mm mn mb b">"$"</code>开头，可以是任何类型。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8ed9" class="mf ku in mb b gy mg mh l mi mj">const inputs = [{<br/>  name: "$myInput",<br/>  value: 1000<br/>}, {<br/>  name: "$myOtherInput",<br/>  value: {<br/>    someProp: {<br/>      anEvenDeeperProp: "some value"<br/>    }<br/>  }<br/>}];<br/>const output = compiled.evaluate(...inputs);</span></pre><p id="fd48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，所有输入都可以通过它们在模板中的变量名来引用:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c53e" class="mf ku in mb b gy mg mh l mi mj">{<br/>  anOutputProp: "$myInput / 2",<br/>  anotherOutputProp: "$myOtherInput.someProp.anEvenDeeperProp + ' was input'"<br/>}</span></pre><p id="9937" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将产生以下输出:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bb21" class="mf ku in mb b gy mg mh l mi mj">{<br/>  anOutputProp: 500,<br/>  anotherOutputProp: "some value was input"<br/>}</span></pre><h1 id="31cb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模板表达式语法</h1><p id="aa02" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">模板可以由任何有效的JavaScript值或对象组成。模板可以是简单的单个常量值(当然，这是没有用的，因为不会发生任何类型的转换或计算)，或者单个JSON-fx字符串表达式，或者复杂的JSON-fx对象表达式。</p><h1 id="3f0b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">字符串表达式</h1><p id="15da" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">顾名思义，JSON-fx字符串表达式是一个字符串值，它包含一个或多个函数调用和/或操作符，结果只产生一个输出值或对象。在编译模板时，JSON-fx运行时将对其进行解析，从而创建一个高效的表达式树，可以根据任意数量的不同输入值对其进行评估。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1975" class="mf ku in mb b gy mg mh l mi mj">const template = "math~floor($.someNumber / 10) % 10";<br/>const compiled = fx.compile(template);<br/>const input = {<br/>  name: "$",<br/>  value: { someNumber: 1234 }<br/>};<br/>const output1 = compiled.evaluate(input);<br/>// output1 = 3<br/>input.value = { someNumber: 2468 };<br/>const output2 = compiled.evaluate(input);<br/>// output2 = 6</span></pre><p id="d520" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，输入<code class="fe ml mm mn mb b">$</code>是包含单个属性<code class="fe ml mm mn mb b">someNumber</code>的对象。模板字符串定义了一个JSON-fx表达式<code class="fe ml mm mn mb b">math~floor($.someNumber / 10) % 10</code>，它使用整数除法和模数运算符有效地输出了<code class="fe ml mm mn mb b">$.someNumber</code>的十位数。模板被传递给<code class="fe ml mm mn mb b">fx.compile(...)</code>，后者将字符串转换成编译后的表达式。接下来，<code class="fe ml mm mn mb b">compiled.evaluate(input)</code>对提供的输入执行表达式并返回结果，在本例中是数字<code class="fe ml mm mn mb b">3</code>。然后，输入的值被改变，表达式被再次计算，这次结果是数字<code class="fe ml mm mn mb b">6</code>。</p><h1 id="cf5f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">函数和运算符</h1><p id="76d7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函数调用是任何JSON-fx字符串表达式的核心组件。所有字符串表达式本质上都是一个或多个函数求值的组合。偶数运算符是一种语法快捷方式，表示对关联函数的调用。例如，表达式<code class="fe ml mm mn mb b">$a + $b</code>只是函数调用<code class="fe ml mm mn mb b">add($a, $b)</code>的简写表示。</p><p id="9bcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JSON-fx表达式中，可以使用标准JavaScript函数调用语法调用函数，即函数名、左括号、逗号分隔的参数和右括号。</p><p id="fbf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mb b">add($a, $b)</code></p><p id="b9ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以使用中缀<code class="fe ml mm mn mb b">:</code>运算符将函数链接到其他值、函数或表达式:</p><p id="3aac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mb b">$a:add($b)</code>相当于<code class="fe ml mm mn mb b">add($a, $b)</code></p><p id="e1c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">左边的值<code class="fe ml mm mn mb b">$a</code>被隐式传递给<code class="fe ml mm mn mb b">add($b)</code>作为第一个参数，取代其他参数。当将函数调用链接在一起时，中缀运算符在许多情况下可以提供更好的清晰度:</p><p id="8bf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mb b">toString(add($a, $b))</code>最好表述为<code class="fe ml mm mn mb b">add($a, $b):toString()</code>，甚至<code class="fe ml mm mn mb b">$a:add($b):toString()</code></p><p id="5f9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果右边的函数只需要一个参数(由左边的操作数隐式提供)，则可以省略括号:</p><p id="9347" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mb b">$a:add($b):toString</code></p><p id="6f3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一组全面的内置JSON-fx函数提供了核心功能，公开并扩展了许多最有用的JavaScript函数。此外，通过向<code class="fe ml mm mn mb b">JsonFx</code>类构造函数传递一组定义，可以注入扩展函数和操作符来扩展模板语言。</p><p id="3a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mo" href="https://github.com/mindsung/json-fx/tree/develop/json-fx/src/fx/functions" rel="noopener ugc nofollow" target="_blank">点击这里查看所有JSON-fx内置函数和操作符</a></p><h1 id="8dbc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">扩展功能</h1><p id="b1e2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函数定义是一个具有两个属性的对象，<code class="fe ml mm mn mb b">name</code>和<code class="fe ml mm mn mb b">evaluate</code>。<code class="fe ml mm mn mb b">name</code>属性是将在表达式中使用的函数名，<code class="fe ml mm mn mb b">evaluate</code>属性是JavaScript函数定义。(JSON-fx函数定义也可能包含一个<code class="fe ml mm mn mb b">operator</code>属性，参见JSON-fx源代码中的示例。自定义扩展函数通常不包含运算符定义，因为大多数常用的运算符符号已经被内置函数使用。)</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8bab" class="mf ku in mb b gy mg mh l mi mj">const fx = new JsonFx([<br/>  {<br/>    name: "addFive",<br/>    evaluate: n =&gt; n + 5<br/>  }<br/>]);</span></pre><h1 id="5136" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">值文字</h1><p id="a8f4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">字符串表达式可能包含值文字，包括数值、字符串和布尔值。数字文字不需要任何特殊的符号。字符串文字必须包含在单引号<code class="fe ml mm mn mb b">'</code>中。布尔值可以是<code class="fe ml mm mn mb b">true</code>或<code class="fe ml mm mn mb b">false</code>。此外，可以使用特殊值<code class="fe ml mm mn mb b">null</code>和<code class="fe ml mm mn mb b">undefined</code>。</p><p id="0760" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用开/闭方括号<code class="fe ml mm mn mb b">[]</code>，数组文字也可以嵌入到字符串表达式中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c450" class="mf ku in mb b gy mg mh l mi mj">const template = "(1.5 + 3):toString + ['hello', 2, true, null]:first";</span></pre><p id="d819" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在对任何输入进行评估时产生值<code class="fe ml mm mn mb b">"4.5hello"</code>(该表达式不包含输入变量)。</p><h1 id="3306" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">属性访问器点标记法</h1><p id="e804" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">与JavaScript和许多其他编程语言一样，在字符串表达式中使用点符号来访问对象属性。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f6e7" class="mf ku in mb b gy mg mh l mi mj">const compiled = fx.compile("$.someProp.someDeeperProp");<br/>const output = compiled.evaluate({<br/>  name: "$",<br/>  value: {<br/>    someProp: {<br/>      someDeeperProp: "hello"<br/>    }<br/>  }<br/>});</span></pre><p id="fbeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">产生输出<code class="fe ml mm mn mb b">"hello"</code></p><h1 id="d373" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">空条件运算符</h1><p id="209b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">JSON-fx定义了一个内置的空条件操作符，该操作符允许许多模板看起来更清晰、更易读，并避免使用频繁、冗长的条件逻辑来检查和处理空值。空条件运算符<code class="fe ml mm mn mb b">?</code>可以在任何属性点访问器或函数调用之前内联使用。如果紧接在<code class="fe ml mm mn mb b">?</code>符号之前的表达式的值为空或未定义，表达式将返回空。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="def9" class="mf ku in mb b gy mg mh l mi mj">const template = "$.someProp?.someMissingProp?:substr(0, 3)?:toUpperCase";</span></pre><p id="48be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当针对任何输入<code class="fe ml mm mn mb b">$</code>进行评估时，如果输入值不包括属性<code class="fe ml mm mn mb b">someProp</code>或属性<code class="fe ml mm mn mb b">someProp.someMissingProp</code>，则表达式将愉快地返回null值，而不是抛出运行时错误。当输入对象可能具有不同的结构或可选属性时，这种行为特别有用。</p><h1 id="40e1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">匿名(λ)函数</h1><p id="d9b6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有些函数需要的参数本身就是函数，例如array <code class="fe ml mm mn mb b">find</code>函数，它需要一个谓词函数的参数，并查找数组中与指定函数检查的条件相匹配的第一个成员。当调用这样的函数时，函数类型参数可以使用匿名函数或lambda语法来表达。</p><p id="3558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与许多编程语言一致，JSON-fx lambda语法由一个或多个函数参数变量组成，这些变量必须以<code class="fe ml mm mn mb b">"$"</code>开头，后面是<code class="fe ml mm mn mb b">=&gt;</code>，再后面是一个表达式。如果声明了多个参数，逗号分隔的参数列表必须用括号括起来。当只声明一个参数时，括号是可选的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b701" class="mf ku in mb b gy mg mh l mi mj">const template = "[2, 4, 6, 8]:find(($n) =&gt; $n &gt; 5)"</span></pre><p id="d13b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当对任何输入进行评估时，产生值<code class="fe ml mm mn mb b">6</code>。</p><h1 id="f95a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">对象表达式</h1><p id="b4ff" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">JSON-fx对象表达式提供了一种强大的方法，通过它可以转换和查询几乎任何复杂性的对象。对象表达式是一个JavaScript对象，包括表示JSON-fx变量声明、JSON-fx运行时用户定义函数声明和输出的某种组合的属性。对象的每个属性值可以是常量(单值、对象或数组)、JSON-fx字符串表达式或另一个JSON-fx对象表达式。</p><p id="6ebd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了下面讨论的带有特殊符号的属性，对象的所有属性也将出现在结果输出值中。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5e81" class="mf ku in mb b gy mg mh l mi mj">const compiled = fx.compile({<br/>  someProp: "$ + 1",<br/>  anotherProp: {<br/>    deeperProp: "$ * 2"<br/>  }<br/>});<br/>const output = compiled.evaluate({ name: "$", value: 5 });</span></pre><p id="d2a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">产出产值<code class="fe ml mm mn mb b">{ someProp: 6, anotherProp: { deeperProp: 10 } }</code></p><h1 id="603b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">变量</h1><p id="383e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">除了传递到模板评估中的命名输入变量之外，还可以声明局部变量。对象表达式中的变量是以符号<code class="fe ml mm mn mb b">"$"</code>开头的属性，可以在后续表达式中的任何地方使用。分配给变量属性的值可以是任何常量或表达式值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4333" class="mf ku in mb b gy mg mh l mi mj">const template = {<br/>  "$pi": 3.14159,<br/>  "$radiusSquared": "$radius * $radius",</span><span id="68b6" class="mf ku in mb b gy mk mh l mi mj">  radius: "$radius",<br/>  area: "($pi * $radiusSquared * 100):math~round / 100"<br/>};</span></pre><p id="7a2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用值为<code class="fe ml mm mn mb b">3</code>的输入<code class="fe ml mm mn mb b">$radius</code>进行评估时，将产生<code class="fe ml mm mn mb b">{ radius: 3, area: 28.27 }</code></p><h1 id="5e91" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">运行时用户定义的函数</h1><p id="f35e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">虽然在行为上类似于扩展和内置函数，但运行时用户定义函数是在表达式模板中声明和实现的。这允许您的模板的功能被进一步扩展，而无需重新构建和重新部署您的应用程序，并且还提供了一种在您的模板中重用表达式逻辑的更紧凑和有效的方法。</p><p id="a983" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对象表达式中的运行时用户定义函数是以符号<code class="fe ml mm mn mb b">"@"</code>开头的属性，可以在后续表达式中的任何地方使用。从技术上讲，分配给属性的值可以是任何常量或表达式值，尽管只有表达式值才能使函数比变量更有用。类似地，虽然函数参数不是严格必需的，但是没有参数的函数并不比简单地声明一个变量更有优势。与所有JSON-fx变量一样，函数参数必须以<code class="fe ml mm mn mb b">"$"</code>开头。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2ee7" class="mf ku in mb b gy mg mh l mi mj">const template = {<br/>  "@rectArea($length, $width)": "$length * $width",<br/>  area: "@rectArea($.length, $.width)"<br/>};</span></pre><p id="6334" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用值为<code class="fe ml mm mn mb b">{ length: 3, width: 4 }</code>的输入<code class="fe ml mm mn mb b">$</code>进行评估时，将产生<code class="fe ml mm mn mb b">{ area: 12 }</code>。</p><p id="f15a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，如上例所示，当调用运行时用户定义的函数时，函数名必须包含开头的<code class="fe ml mm mn mb b">@</code>符号。</p><p id="6663" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以使用用户定义的函数代替lambda函数，作为需要函数类型参数的其他函数(内置函数、扩展函数或运行时用户定义的函数)的参数。在这种情况下，函数名，包括<code class="fe ml mm mn mb b">@</code>，作为参数值传递。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8831" class="mf ku in mb b gy mg mh l mi mj">const template = {<br/>  "@isBigNumber($n)": "$n &gt;= 100",<br/>  "$numbers": [50, 75, 100, 200],<br/>  firstBigNumber: "$numbers:find(@isBigNumber)"<br/>};</span></pre><p id="1013" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当对任何输入进行评估时，产生值<code class="fe ml mm mn mb b">{ firstBigNumber: 100 }</code>。</p><h1 id="a85b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">变量和用户定义的函数范围</h1><p id="6d31" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对象表达式中任何变量或用户定义函数的作用域是声明它的对象，包括任意级别的内部嵌套对象。因为模板是在计算之前编译的，所以对象上属性的实际声明顺序并不重要。换句话说，只要在相同(或嵌套)的对象范围内，声明变量或用户定义函数的属性就不必在使用之前出现(尽管这通常会提高可读性)。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e978" class="mf ku in mb b gy mg mh l mi mj">const template = {<br/>  rectInfo: {<br/>    // @rectArea is in scope here because it was declared in<br/>    // the parent object.<br/>    area: "@rectArea($.length, $.width)"<br/>  },<br/>  // Valid to declare @rectArea here, even though it is used<br/>  // above this in the logical property order.<br/>  "@rectArea($length, $width)": "$length * $width"<br/>};</span></pre><h1 id="6b58" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">目标价值提升</h1><p id="ec22" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">除了变量<code class="fe ml mm mn mb b">"$"</code>和用户定义的函数<code class="fe ml mm mn mb b">"@"</code>符号，属性名<code class="fe ml mm mn mb b">"()"</code>(空括号)将该属性的单个值提升为其父属性的值。当需要单个值而不是对象值时，值提升很有用，但通过使用更复杂的对象表达式来获得该值是必要的或有帮助的，因此可以使用变量和/或用户定义的函数。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6a1c" class="mf ku in mb b gy mg mh l mi mj">const template = {<br/>  "$pi": 3.14159,<br/>  "@area($radius)": "$pi * $radius:pow(2)",<br/>  "()": "@area($)"<br/>};</span></pre><p id="f495" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用输入值<code class="fe ml mm mn mb b">3</code>对上述模板进行评估时，结果只是数字<code class="fe ml mm mn mb b">28.27431</code>(不是对象)。值提升可用于对象表达式的任何嵌套级别，而不仅仅是模板对象的顶级。</p><p id="43c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，当使用值提升表示法时，除了变量和用户定义的函数声明之外，<code class="fe ml mm mn mb b">"()"</code>属性必须是对象上唯一的属性。如果在特殊值提升属性旁边的对象表达式中存在其他普通对象属性，将导致编译时错误。</p><h1 id="75cc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="11dd" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">JavaScript空间中有几个工具和库可用于查询和转换JSON数据。JSON-fx旨在提供其他产品所不具备的性能、全面的功能和可扩展性。本文中展示的例子将帮助您入门，但仅仅代表了可能的一小部分。我希望你能够使用这个工具，并从你的工作中获得和我一样多的价值！</p><p id="332f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">披露:我是</em> <a class="ae mo" href="https://github.com/mindsung/json-fx" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> JSON-fx项目</em> </a> <em class="mp">的撰稿人。</em></p></div></div>    
</body>
</html>