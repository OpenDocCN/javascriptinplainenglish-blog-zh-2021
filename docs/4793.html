<html>
<head>
<title>How Writing Pure Functions Can Change Your JavaScript Bundle for the Good</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写纯函数如何让您的JavaScript包变得更好</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pure-functions-9d07c3f88067?source=collection_archive---------10-----------------------#2021-09-24">https://javascript.plainenglish.io/pure-functions-9d07c3f88067?source=collection_archive---------10-----------------------#2021-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f1d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这可能会使您的代码更加高效</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c31cca6ef9533895304d5d1dbea4df58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TRZLjPBPQE7-vnoazOtzA.png"/></div></div></figure><p id="6ef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你应该写纯函数。是的，你已经知道了。<br/>但是到底是为什么呢？</p><p id="042b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，因为可读性？因为可重用性和错误跟踪？<br/>还有一个原因:性能原因。</p><p id="4e80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了看到它的作用，让我们举个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9502" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有两个函数——“g”和“f”。函数“g”返回传递给它的内容——还会产生副作用:记录到控制台。<br/>提醒:当一个函数依赖或修改其参数之外的东西时，就会产生副作用。</p><p id="0edf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，函数“f”依赖于“g”。我们现在不关心实际运行这个。如果我们捆绑这段代码(我用<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/parceljs-48a35df8b41a">包</a>做的)，这将是捆绑的JavaScript:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7d23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，这几乎是相同的代码，只是一点语法上的小技巧，比如只使用一个const-keyword——总而言之，没有什么新的。</p><p id="6b6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了了解纯函数如何积极地改变我们的包，让我们将函数“g”设为纯函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8d68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们只删除了console . log——现在，“g”没有副作用了。我们再用<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/parceljs-48a35df8b41a">包</a>捆绑一下，看看如何捆绑JavaScript的变化。哦，别担心，我是为你做的。下面是生成的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8acb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">惊喜！我们的函数“g”根本没有被调用bundler用参数值替换了函数调用。因为“g”只返回传入的内容，所以这是有意义的。</p><p id="2202" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于这个例子，我们可以看到，当我们的函数是纯函数时，bundler有更多的优化自由。当然，只返回参数值的函数并不常见。然而，这是纯函数如何改变捆绑过程的一个很好的例子。</p><p id="2b06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了完全删除函数调用，捆绑器还可以对这个纯函数进行其他优化。</p><p id="09d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，捆绑器可以针对n=1的情况优化纯函数。在这种情况下，不管x，我们都会得到0作为结果(因为<code class="fe lq lr ls lt b">n * x — x</code>总是0，当n = 1时。请记住，乘法首先发生)。</p><p id="8342" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，优化看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="c647" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种优化可能是更现实的场景。因为“g”仍然被调用，但是捆绑器最小化了调用这个函数的场景数量。如果“g”做了一个非常昂贵的计算，我们会为每一个避免的函数调用而高兴。</p><p id="e955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这显然取决于捆绑器——我尝试了多个，所有的捆绑方式都不同。</p><p id="7446" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了捆绑之外，为这种优化编写纯函数总是一个好主意。由于纯函数是可忽略的和独立的，开发人员可以像上面那样手动找出这样的优化。</p><p id="d823" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">暂时就这样吧！如果你想在网上阅读更多关于函数式编程的内容:</p><div class="lu lv gp gr lw lx"><a rel="noopener  ugc nofollow" target="_blank" href="/purescript-3ee759ce05aa"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">用PureScript为Web带来强大的函数式编程</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">就像JavaScript的Haskell</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml kp lx"/></div></div></a></div><p id="9b53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让我意识到这一点，我读了查尔斯·斯卡法尼的《T2》、《T3》、《T4》和《T5》、《T6》、《T7》。我与他的产品无关。</p><p id="6e45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mm">更多内容请看</em><a class="ae lp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>