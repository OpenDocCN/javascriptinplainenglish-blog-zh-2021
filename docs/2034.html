<html>
<head>
<title>Building a Sudoku Puzzle Generator Using Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用普通JavaScript构建数独谜题生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-sudoku-puzzle-generator-d55cead9656d?source=collection_archive---------4-----------------------#2021-04-29">https://javascript.plainenglish.io/building-a-sudoku-puzzle-generator-d55cead9656d?source=collection_archive---------4-----------------------#2021-04-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1640" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写一个生成器可能需要大量的工作。你需要考虑很多因素。下面是我如何使用普通JavaScript实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/fdab8ce7542d19798df0653a1657648d.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*ci8-1MfWa2bDYXXYeYiYCQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Sudoku Board</figcaption></figure><h2 id="6cab" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">数独是什么？</h2><p id="5ed0" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在我开始解释如何生成独特的<a class="ae ls" href="https://en.wikipedia.org/wiki/Sudoku" rel="noopener ugc nofollow" target="_blank">数独</a>谜题之前，回顾一下数独的规则是很重要的。</p><p id="af8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数独游戏是在一个9x9的网格上进行的，网格由行、列和3x3的“盒子”分隔开。每行、每列和每个框中的“单元格”需要用数字1-9填写，不能有重复的数字。为了使数独游戏有效，它必须只有一个唯一的解决方案。换句话说，棋盘上的每个格子都有一个预定的值，这个值会随着谜题的解开而显示出来。如果一个单元格有两个或两个以上的值，将导致解决方案，这个难题是无效的。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="4b8b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">背景</strong></h2><p id="13cf" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">编写一个生成器可能需要大量的工作。你需要考虑很多因素，例如<a class="ae ls" href="https://www.sudokuessentials.com/grading-sudoku-puzzles.html" rel="noopener ugc nofollow" target="_blank">给你生成的谜题评分</a>(指定难度)并确保生成的谜题有唯一的答案。</p><p id="4662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给谜题评分是一个异常困难的问题，因为人类在解决问题时使用了各种各样的技术。虽然这肯定是对计算机科学和人类心理学的一次有趣尝试，但我发现对于大多数用例来说，从头构建一个生成器是特别不必要的。相反，我决定通过操纵现有矩阵(拼图)来“作弊”，而不影响拼图的完整性，如上所述。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="4f35" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">发电机编码</h2><p id="a539" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我首先整理了一个已经评分的现有谜题列表，并将它们作为二维数组(矩阵)复制到一个javascript文件中用作种子，空值映射为0。您可以将空值表示为<code class="fe ma mb mc md b">null</code>或<code class="fe ma mb mc md b">undefined</code>，我只是更喜欢0，因为测试时更容易读取输出。然后，您可以将代表矩阵的变量保存在标记为“easy”、“medium”、“hard”等的数组中。你最终会得到类似于<code class="fe ma mb mc md b">const easy = [easySeed1, easySeed2, ...]</code>的东西。接下来，每当我需要生成一个谜题时，我就对一个随机种子执行一系列随机转换。您可以对任何有效的谜题进行的变换有:</p><ol class=""><li id="f68a" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">将矩阵旋转0到3次</li><li id="90bd" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">将所有数字映射到其他数字</li><li id="f363" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">洗牌任何2-3行或列跨越相同的3个方块。</li></ol><h2 id="737c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">旋转矩阵</h2><p id="74a4" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">想象你拿着一张纸，上面有一个数独游戏。现在将这张纸旋转90度，并调整数字的方向，使它们不会向侧面倾斜。这个谜题看起来会有所不同，但它显然仍然有效。事实上，如果你在网上或应用程序上玩数独，你得到的是同样的数独，只是旋转了90度，你可能不会注意到。这正是问题的关键。你不需要生成完全‘独一无二’的谜题，只要‘独一无二’的<em class="ms">足够让</em><em class="ms"/>他们神不知鬼不觉。不管怎样，实现这一点的代码如下:</p><pre class="kj kk kl km gt mt md mu mv aw mw bi"><span id="6ea9" class="ku kv in md b gy mx my l mz na">const rotateMatrix = (array) =&gt; {<br/>  const n = array.length  <br/>  <br/>  // Create a temporary matrix of size n x n<br/>  let t = Array.from(Array(n), () =&gt; Array.from(Array(n)))<br/>  <br/>  for (let i = 0; i &lt; n; i++) {<br/>    for (let j = 0; j &lt; n; j++) {<br/>      <br/>      // basically array[i][j] gets moved to [j][n - (i + 1)]<br/>      // e.g. array[0][0] =&gt; array[0][8] assuming 9x9 matrix<br/>      let ele = array[i][j];<br/>      let idx = n - (i + 1)<br/>      <br/>      t[j][idx] = ele<br/>    }<br/>  }<br/>  return t<br/>}</span></pre><h2 id="a149" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">地图编号</h2><p id="a4f1" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">您也可以将任何数字组映射到任何其他数字组，谜题保持不变。例如，您可以映射数字，使“1”变成“3”，“3”变成“9”，以此类推。我们可以这样做，首先使用<a class="ae ls" href="https://medium.com/@oldwestaction/randomness-is-hard-e085decbcbb2" rel="noopener"> Fisher-Yates </a>方法混洗数字1-9的数组，并设置一个转换对象，使得:</p><pre class="kj kk kl km gt mt md mu mv aw mw bi"><span id="69c1" class="ku kv in md b gy mx my l mz na">const conversion = {}<br/>// i + 1 bc we want 1-9 as keys and arrays start at index 0 <br/>shuffled.forEach((e, i) =&gt; conversion[i + 1] = e)</span></pre><p id="b4d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦有了转换对象，就可以简单地遍历矩阵，将每个数字映射到转换的值，确保考虑到了空值:</p><pre class="kj kk kl km gt mt md mu mv aw mw bi"><span id="5461" class="ku kv in md b gy mx my l mz na">arr[i][j] = conversion[[arr[i][j]] || 0</span></pre><h2 id="a760" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">无序排列行和列</h2><p id="e573" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这是目前为止转换seed谜题最酷的方法，我相信这是真正改变谜题的方法。参考一下本文顶部的图片。如果你把第一行(绿色突出显示的那一行)换成第二或第三行，谜题仍然有效。概括地说，行在组(1，2，3)，(4，5，6)和(7，8，9)中的顺序并不重要，但是您不能在组之间交换行。柱子也是一样。如果你不相信我，请查看<a class="ae ls" href="https://www.sudoku-solutions.com/" rel="noopener ugc nofollow" target="_blank">数独解决方案</a>，并简单地将页面顶部的图片中的谜题复制到他们的界面中。点击“检查拼图”。现在只需交换第一行和第二行，并继续这样做的行和列，直到你确信。假设您已经有了一个shuffle函数，您可以非常容易地对行进行洗牌:</p><pre class="kj kk kl km gt mt md mu mv aw mw bi"><span id="197c" class="ku kv in md b gy mx my l mz na">const shuffleRows = (array) =&gt; {<br/>  return [<br/>   shuffle(array.slice(0, 3)),<br/>   shuffle(array.slice(3, 6)),<br/>   shuffle(array.slice(6)<br/>  ].flat() // flat by default flattens array by one level</span></pre><p id="4b6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了混洗列，首先旋转矩阵一次，然后使用相同的shuffleRows函数，然后旋转矩阵3次以上，回到其原始方向。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h2 id="d70c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">结论</h2><p id="351e" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我有了制作拼图生成器的灵感，因为我试图用来生成拼图的<a class="ae ls" href="https://yarnpkg.com/?q=sudoku&amp;p=1" rel="noopener ugc nofollow" target="_blank">包</a>不能生成有效的拼图，而且我不想依赖外部API来获取拼图。</p><p id="3123" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然从技术上讲，这不是一个“真正的”字谜生成器，但我发现这种方法对于我自己的个人项目来说已经足够好了。当然，你提供给生成器的谜题种子越多，它就越能欺骗人们相信他们正在解决真正独特的谜题。</p><p id="6083" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我试图在我的室友身上测试，但在我有任何确凿的数据之前，他们就厌倦了。希望你喜欢这篇文章，感谢阅读！</p><p id="bae0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ls" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>