<html>
<head>
<title>The Secret to the ES6 Spread Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6扩展语法的秘密</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-secret-to-es6-spread-syntax-4066140678e0?source=collection_archive---------14-----------------------#2021-09-10">https://javascript.plainenglish.io/the-secret-to-es6-spread-syntax-4066140678e0?source=collection_archive---------14-----------------------#2021-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5e82" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用ES6的spread操作符编写更优雅的JavaScript应用程序。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a0cb6bb2ca5955fc32df4b628a6b1c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCsZmUnIO4bU6yd9jQKImQ.png"/></div></div></figure><p id="b2eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在编写简洁优雅的JavaScript应用程序时，spread语法变得越来越流行。通过使我们能够将一个对象的主体<em class="lk">扩展</em>到另一个，我们可以更无缝地编写纯粹的、不可变的函数。和往常一样，例子是最好的学习方法，所以让我们来看一个例子。假设我们正在编写一些包含基于TypeScript接口的preferences对象的社交媒体应用程序:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="8be5" class="lq lr in lm b gy ls lt l lu lv">interface Preferences { <br/>  theme: "dark" | "light";<br/>  language: string; <br/>  shareLocation: boolean; <br/>}</span></pre><p id="f920" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们有以下默认偏好:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="7e78" class="lq lr in lm b gy ls lt l lu lv">const defaultPreferences = {<br/>  theme: "light",<br/>  language: "English",<br/>  shareLocation: false<br/>}</span></pre><p id="e9a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在考虑从API中提取登录的用户数据后，它缺少了一些首选项。假设我们从API收到了以下对象:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="8287" class="lq lr in lm b gy ls lt l lu lv">const apiResult = { language: "English" }</span></pre><p id="5e04" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这可能是因为任何原因，比如它没有在帐户创建期间发布，它没有在后端初始化，或者它可能是一个新功能。在任何情况下，我们都希望避免错误，并从此使用我们的<em class="lk"> defaultPreferences </em>对象来填充丢失的值。我们如何做到这一点？毕竟，在某些时候，我们需要知道这个用户是否想要分享他们的位置！让我们探索几种方法。</p><h2 id="58f9" class="lq lr in bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml mm bi translated">使用三元运算符</h2><p id="c00d" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">我们可以使用三元运算符来检查属性是否未定义，如下所示:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="feac" class="lq lr in lm b gy ls lt l lu lv">const userPreferences = {<br/>  theme: apiResult.theme === undefined ? apiResult.theme : defaultPreferences.theme,<br/>  language: apiResult.language === undefined ? apiResult.language : defaultPreferences.language,<br/>  shareLocation: apiResult.shareLocation === undefined ? apiResult.shareLocation : defaultPreferences.shareLocation<br/>}</span></pre><p id="a88d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那会有用…如果你讨厌你的同事！在我看来，虽然这种解决方案确实有效，但它很难阅读，而且具有重复性。让我们探索另一种选择。</p><h2 id="e0a7" class="lq lr in bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml mm bi translated">使用<a class="ae ms" href="https://lodash.com/docs/4.17.15#get" rel="noopener ugc nofollow" target="_blank">lodash</a>“get”</h2><p id="d91b" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">Lodash是一个非常棒的函数式JavaScript库，我强烈推荐它。我经常使用那里的方法，比如curry、isNil、get、h as等等。Lodash的<em class="lk"> get </em>函数接受3个参数:一个对象、一个属性的字符串路径和一个可选的替代值，如果路径返回undefined，则提供该值。让我们看看如何在这个场景中实现<em class="lk"> get </em>。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="b176" class="lq lr in lm b gy ls lt l lu lv">const userPreferences = {<br/>  theme: get(apiResult, "theme", defaultPreferences.theme), <br/>  language: get(apiResult, "language", defaultPreferences.language),<br/>  shareLocation: get(apiResult, "shareLocation", defaultPreferences.shareLocation)<br/>}</span></pre><p id="1d07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然这种方法比第一种要干净一点，而且确实能防止错误，但这不是我最喜欢的。那是因为我们基本上写了三遍同样的东西，只有很小的变化。了解我这个开发者的人都知道我遵循的是干原则。如果您打算编写可读的代码，我建议您也这样做。</p><h2 id="c376" class="lq lr in bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml mm bi translated">使用扩展语法</h2><p id="a0ee" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx mp kz la lb mq ld le lf mr lh li lj ig bi translated">根据<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>，</p><blockquote class="mt mu mv"><p id="41b5" class="ko kp lk kq b kr ks jo kt ku kv jr kw mw ky kz la mx lc ld le my lg lh li lj ig bi translated"><strong class="kq io"> Spread语法</strong> ( <code class="fe mz na nb lm b">...</code>)允许在需要零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展可迭代对象，例如数组表达式或字符串，或者在需要零个或多个键值对(用于对象文字)的地方扩展对象表达式。</p></blockquote><p id="c16c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">换句话说，你可以在另一个对象中展开这个对象，然后继续定义你正在定义的东西。在实现它作为我们最终的首选项解决方案之前，让我们看一些例子。</p><p id="cae4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以添加、组合和创建新对象:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="2204" class="lq lr in lm b gy ls lt l lu lv">//Given arrays<br/>const abc = ['a', 'b', 'c']<br/>const def = ['d', 'e', 'f']<br/>//we can create<br/>const abcdef = [...abc, ...def] <br/>/* returns ['a', 'b', 'c', 'd', 'e', 'f'] */</span><span id="441a" class="lq lr in lm b gy nc lt l lu lv">//Given objects<br/>const name = { first: 'josh', last: 'tal' }<br/>const skillLevels = { javascript: 10, sports: 1, skateboarding: 5 }<br/>//we can combine and contrive<br/>const bio = { ...name, ...skillLevels } <br/>/* returns { first: 'josh', last: 'tal', javascript: 10, sports: 1, skateboarding: 5 } */</span></pre><p id="ff1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还可以覆盖属性:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="c5fc" class="lq lr in lm b gy ls lt l lu lv">//Given objects<br/>const lowerPriority = { moneyInBank: 5, collegeMajor: 'economics', favoriteFood: 'pizza' }<br/>const higherPriority = { moneyInBank: 20, favoriteFood: 'hummus', favoriteAnime: 'one piece' } <br/>const interests = ['keyboard', 'design', 'languages']</span><span id="d387" class="lq lr in lm b gy nc lt l lu lv">//we can combine and overwrite to create<br/>const result = { ...lowerPriority, ...higherPriority, otherInterests: ['art', 'culture', 'scary pockets', ...interests] } </span><span id="a52c" class="lq lr in lm b gy nc lt l lu lv">/* result returns...<br/>{ <br/>  moneyInBank: 20, <br/>  collegeMajor: 'economics', <br/>  favoriteFood: 'hummus', <br/>  favoriteAnime: 'one piece', <br/>  otherInterests: ['art', 'culture', 'scary pockets', 'keyboard', 'design', 'languages'] <br/>} <br/>*/</span></pre><p id="4d36" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<em class="lk">下级</em>的<em class="lk">美食</em>和<em class="lk">钱柜</em>被覆盖。这是因为在列表中，优先级较高的<em class="lk">优先于它，因为它被写在第二位。另外，请注意由于使用了spread语法，如何将<em class="lk">兴趣</em>附加到<em class="lk">其他兴趣</em>上。您可以使用spread操作符执行许多像这样的酷操作。</em></p><p id="9b67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们看看如何用它来解决我们的问题:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="1fbc" class="lq lr in lm b gy ls lt l lu lv">const userPreferences = {<br/>  ...defaultPreferences,<br/>  ...apiResult<br/>}</span></pre><p id="b8bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就是这样！我们甚至不用再写属性名了。事实上，我的策略是尽量避免多次编写属性名，除非绝对必要。这就是ES6的强大之处。</p><p id="9cc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容看</em> <a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="lk">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>