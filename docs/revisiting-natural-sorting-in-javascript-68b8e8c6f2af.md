# 让我们重温一下 JavaScript 中的自然排序

> 原文：<https://javascript.plainenglish.io/revisiting-natural-sorting-in-javascript-68b8e8c6f2af?source=collection_archive---------9----------------------->

![](img/50ebdb03bff0d221d77347ab93312bd1.png)

在这个故事中，我重温了我的自然排序旧算法，将其与原生 JavaScript 实现进行了比较，并发现了有趣的差异。

# 自然分类

我在这里引用维基百科的定义:

> 在计算中，**自然排序顺序**(或**自然排序**)是按照[字母顺序](https://en.wikipedia.org/wiki/Alphabetical_order)对字符串进行的[排序，除了多位数被自动处理，即，就像它们是单个字符一样。](https://en.wikipedia.org/wiki/Collation)

# Webpack 版本

有很多使用自然排序的用例，但是作为开发人员，一个有趣的用例是列出产品的版本。

在您的 JS 项目中尝试这个命令:`npm view webpack versions`(您可以将 *webpack* 更改为您感兴趣的任何库)。

它返回一个巨大的按自然顺序排序的字符串列表。下面是输出中的两个片段(连接在一起):

```
‘4.9.1’, ‘4.9.2’, ‘4.10.0’, ‘4.10.1’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’
```

嗯，这个列表是自然顺序的！具体来说， *4.9.2* 显示在 *4.10.0* 之前，即使`'4.9.2' < '4.10.0'`为假。对于 5 . 0 . 0-α9 和 5 . 0 . 0-α10 也发生同样的情况

很明显，在这个用例中，字母顺序是完全不够的。在浏览器控制台中尝试以下操作:

```
[‘4.9.1’, ‘4.9.2’, ‘4.10.0’, ‘4.10.1’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’].sort()
```

结果是:

```
[‘4.10.0’, ‘4.10.1’, ‘4.9.1’, ‘4.9.2’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’]
```

# 整理

每个排序都是两个因素的结果:排序算法和比较函数(比较器)。

有大量关于排序算法的文献，JavaScript 的 *sort* 方法选择最适合被排序的数组类型的方法。

该算法定义了如何构造排序后的数组，但是它不知道数组元素之间的顺序关系。

顺序完全由比较函数定义:给定两个数组元素，比如说 *a* 和 *b，*决定 *a* 是大于、等于还是小于 *b* 的函数(对于每种情况，它分别返回 1、0 或-1)。

# JavaScript 中的自然排序

在 JavaScript 中，支持自然排序比较作为*区域设置*比较的一个选项。

例如，区域比较处理这样一个事实，即在德语字母表中*的*紧跟在 *a、*之后，而在瑞典语字母表中，它在 *z* 之后。

比较器的行为由两个参数决定:地区代码和选项的*集合*。

在可用选项中，例如有*区分大小写*(*A*等于或不同于 *A* )或*忽略标点符号*(T10)b？等于或不同于 *b)。*

我们通过指定*数字*选项得到一个自然排序比较器。我们不关心任何特殊的字母顺序，所以我们将使用*未定义的*本地代码。

使用区域设置比较有两种方式:

*   字符串方法 *localeCompare。*比较函数是在每次调用时构建的，因此这个选项对于排序大型集合来说效率很低。
*   国际机场。允许定义比较函数引用的排序器构造函数:

```
natOrdCmp = new Intl.Collator(undefined, {numeric: true}).compare
```

这个比较函数允许我们取回*自然的*版本列表:

```
[‘4.10.0’, ‘4.10.1’, ‘4.9.1’, ‘4.9.2’, ‘5.0.0-alpha.10’, ‘5.0.0-alpha.11’, ‘5.0.0-alpha.8’, ‘5.0.0-alpha.9’].sort(natOrdCmp)
```

# 微笑比哭泣少

显然微笑比悲伤更有价值。然而，natOrdCmp('😃','😢)给出-1。

表情符号(只有*基本*表情符号)是字符(或者更好的 Unicode *代码点*)，在 UTF16 中由两个 16 位*代码单元编码。*对应的两个*码位*属于 Unicode 特殊*码位*的范围，称为*代理*(它们不代表任何可见的 char)。

表情符号属于一个*补充 Unicode 平面*。在 UTF16 中，所有辅助平面由两个 16 位*代码单元*编码，而*基本多语言平面(* BMP)的*代码点*也包括代理，使用单个*代码单元*编码。

代理的行为类似于 BMP 的其他 16 位*字符*:它们由 chartAt 方法(或者现代语法<字符串>【index】)返回，并且它们有一个相应的数字字符代码。所以后面将要描述的算法也适用于 BMP 范围之外的字符。

'😃[0] = '\uD83D' …'😃[1] = '\uDE03' …'😃[2] =未定义

# 自然排序比较的基本算法

为了介绍自然排序的实现，我从字母比较函数开始，并添加了*数字*特异性。

前缀的测试基于这样的事实，例如`'abc'[3]`是`undefined`

## 单词中的比较算法

算法来源于开头提到的明确定义:

1.  只要给定位置的两个字符都不是数字，就遵循字母顺序。
2.  当有两个数且位数不相等时，位数最少的数最小。
3.  如果数字的位数相同，则按字母顺序排列。

第 2 点)仅当我们排除了*前导零的可能性时才有效。我将在专门的部分讨论这一点。*

## 测试是否为数字

测试一个字符是否是一个数字非常简单，它是一个*单表达式*函数:

`const isDigit = c => c>='0' && c<='9'`

因为太简单了，底层的性能问题就更明显了:我们在比较字符串。这将在下面几行中更好地讨论。

## 位数

计算从给定位置开始的位数的简单函数:

## 组装算法

在下面的代码中，上面给出的 *alphaCmp* 算法已经被修改，增加了第 6 到 18 行。它们实现了上述算法的第 2 点和第 3 点。

第 6 行区分数字和字母的比较。

第 7–10 行实现了第 2 点。

第 12–15 行实现了第 3 点。

第 17 行跳过数字(减一防止*为*递增)

# 性能性能性能

首先要考虑的是，比较算法不太可能成为我们应用程序的瓶颈，但是尝试改进它可以细化在类似情况下要实现的策略。

首先，我们减少求和的次数:我们用计算第一个非数字字符的索引的 *skipDigit，*函数替换 *numDigit* 函数。

v

使用此功能，可以删除第 13、14 行的总和并简化第 17 行。

一个更大的改进是用相应的整数字符代码(代码单元的值)替换方括号访问操作符产生的所有*一个字符长的*字符串:`'abc'.charCodeAt(0) instead of 'abc'[0]`:使用数字 97 比使用字符串‘a’更有效。

显然，我们还需要重新定义 isDigit:

`const isDigit = c => c>=48 && c<=57`

那么算法变成:

现在前缀测试(第 6 行和第 28 行)起作用了，因为例如`'abc'.charCodeAt(3)`是`NaN`

# 处理前导零

一组字符串中包含的数字组可以以一个或多个零开始。

通常添加零是为了使数字部分具有相同的长度。

例如，包含日期的字符串的月份和日期部分总是 2 位数长:`‘picture2021-03-02', ‘picture2021-04-02', 'picture2021-04-12’`

使用字母比较可以正确地对这类字符串进行排序。

如果字符串还包含可变长度的数字部分，则上述比较算法会给出正确的顺序。

如果包含前导零的数字部分可以有不同的长度，事情就有点复杂了。这个案子会在另一个故事里报道。

# 算法比较

## 效率

为了比较这些算法，我们取了 webpack 版本的整个列表(在故事写完的时候大约有 800 个),并把它分配给一个向量 *v* 。然后用[这个故事](https://medium.com/swlh/vector-shuffling-a-javascript-functional-implementation-70e973c5b58f)中描述的算法对向量进行洗牌。

`v = shuffle(v)`

然后我们可以对向量进行 10000 次排序(这需要超过 3200 万次比较):

```
for (z=0;z<10000;z++) v1[z] = [...v]
console.time();
for (z=0;z<10000;z++) v1[z].sort(natOrdCmp)
console.timeEnd()`
```

用向量 v 的不同洗牌测试比较算法，获得的平均时间如下:

```
natOrdCmp  17400 ms
natOrdCmp1 19040 ms
**natOrdCmp2  5150 ms**
```

## 石墨烯簇

字素簇是定义单个字符的一组码点。一些表情符号是可以包含多达 8 个代码单元的集群。

```
['ä'.length, 'ä'.length]
```

结果在`[2,1]`中(您可以在浏览器控制台中复制并粘贴前面的文字来验证结果)。

关键是第一个*是一个由字符 *a* 和音调符号修饰符组成的簇:它有两个代码单元长。*

字符可以用不同的方式编码。***natOrdCmp*函数** **识别不同的编码是同一个字符**:

```
*natOrdCmp*(String.fromCharCode(228), ‘a’ + String.fromCharCode(776))
```

评估为 0，**而 *natOrdCmp1* 和 *natOrdCmp2* 将不同的编码作为不同的字符**进行管理。

## 前导零

尽管如前所述，这个主题将在另一个故事中讨论，但在这里强调一下带有*等于*数字段(即表示相同的整数)并包含前导零的字符串是如何不被 JavaScript 本地比较器排序的是很重要的:

```
['2-alfa','002-alfa','002-beta','2-beta'].sort(natOrdCmp)
```

保持向量**不变**，而**期望结果**为:

```
['2-alfa','2-beta','002-alfa','002-beta']
```

*更多内容请看*[***plain English . io***](http://plainenglish.io/)