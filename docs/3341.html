<html>
<head>
<title>Let’s Make a REST API with Deno!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们用Deno做个REST API吧！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-make-a-rest-api-with-deno-375c3243c1a?source=collection_archive---------8-----------------------#2021-07-07">https://javascript.plainenglish.io/lets-make-a-rest-api-with-deno-375c3243c1a?source=collection_archive---------8-----------------------#2021-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a165" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">近距离观察Node的替代方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c49f52bd476a3c21909b02d6ff5d0ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T2QbHKBlMFty3Djp.png"/></div></div></figure><p id="26ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的几个月里，Deno无疑是JavaScript和Node社区中的热门话题。安全的环境，没有节点模块，内置对TypeScript的支持——这些只是这个运行时的一些好处。但是它准备好用于REST APIs的开发了吗？或许，编写一个简单的基于Deno的应用程序将有助于回答这个问题。</p><p id="871f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我准备用Deno写一个简单的用户管理的app。该应用程序将包括登录、注册和使用原生Deno库生成令牌等功能。如果你不熟悉Deno是什么，可以从阅读这个Deno <a class="ae ln" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank">文档</a>开始。</p><p id="a826" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你准备好了，让我们开始吧！</p><h1 id="685a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Deno应用程序的HTTP服务器</h1><p id="a231" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我将使用Oak中间件作为我的HTTP服务器，但是为了给它一个更现代的感觉，我还将利用基于Oak的Dactyl框架。我需要创建我的第一个控制器。它叫做<em class="ml">用户控制器. ts </em>，位于<em class="ml">控制器</em>目录中。它返回用户列表。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="3ff1" class="mr lp iq mn b gy ms mt l mu mv">import {<br/>  Controller,<br/>  Get,<br/>  HttpStatus,<br/>} from "https://deno.land/x/dactyl/mod.ts";<br/><br/>@Controller("/users")<br/>export default class User {<br/>  @Get("/")<br/>  getUsers() {<br/>    return [<br/>      { email: "<em class="ml">bilal</em>@gmail.com" },<br/>    ];<br/>  }<br/>}</span></pre><p id="551f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我使用了Dactyl中可用的装饰器:</p><p id="46e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">@ Controller("/users ")-路由前缀在参数中设置</p><p id="dcf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">@Get("/") —通过它，我为方法配置了路由</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="c0c4" class="mr lp iq mn b gy ms mt l mu mv">import { Application } from "https://deno.land/x/dactyl/mod.ts";<br/>import UserController from "./controllers/UserControllers.ts";<br/><br/>const app: Application = new Application({<br/>  controllers: [UserController],<br/>});</span></pre><p id="34ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我需要导入控制器，将其添加到Dactyl生成的应用程序中，并设置端口8000。</p><p id="8da5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我几乎准备好启动REST API了。留给我的就是添加一个带有TypeScript配置的文件，因为我正在使用实验性的装饰器。</p><p id="69bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是<em class="ml"> tsconfig.json </em>文件的样子:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="dc10" class="mr lp iq mn b gy ms mt l mu mv">{ <br/>  "compilerOptions": { <br/>    "strict": true,<br/>    "esModuleInterop": true,<br/>    "experimentalDecorators": true, <br/>  }<br/>}</span></pre><p id="907e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了启动应用程序，我使用以下命令:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="f964" class="mr lp iq mn b gy ms mt l mu mv"><em class="ml">deno run –allow-net -c tsconfig.json index.ts</em></span></pre><p id="31fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于我在这里使用的标志的一点解释。默认情况下，Deno不提供对网络、文件等的访问。出于安全考虑。为了能够在端口8000上启动我们的应用程序，我必须显式地启用它，使用<em class="ml">–allow-net</em>标志，然后用<em class="ml"> -c tsconfig.json </em>提供我的TypeScript配置(以及装饰器)的路径。</p><p id="d526" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以获得用户列表:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="1236" class="mr lp iq mn b gy ms mt l mu mv"><em class="ml">curl </em><a class="ae ln" href="http://localhost:8000/users/" rel="noopener ugc nofollow" target="_blank"><em class="ml">http://localhost:8000/users/</em></a></span></pre><p id="d3ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案应该是:</p><p id="a3d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml"> [ </em></p><p id="1e3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml"> { </em></p><p id="5536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">“电子邮件”:“Bilal @ Gmail . com”</em></p><p id="e2d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml"> } </em></p><p id="3c1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">】</em></p><p id="d5d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有用！</p><h1 id="429e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">我的Deno应用程序的数据库</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/2b663172085d3edef2faee8c51e4e618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OayO7sSUAmBPM0BZ"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5568" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我刚刚创建了我的第一个带有用户列表的控制器。但是用户现在是代码中的静态数据。使用某种数据库是个好主意。我将在PostgreSQL中创建新的，并将其命名为<em class="ml"> denoapp </em>。用户和密码将被简化为<em class="ml"> deno </em>。现在我需要创建一个名为<em class="ml"> users </em>的新表。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="7765" class="mr lp iq mn b gy ms mt l mu mv">CREATE TABLE IF NOT EXISTS users(<br/>  id serial PRIMARY KEY,<br/>  password VARCHAR (60) NOT NULL,<br/>  email VARCHAR (355) UNIQUE NOT NULL<br/>);</span></pre><p id="feee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了登录用户，我将利用电子邮件地址。我可以将数据库中的数据存储在环境变量或文件中。这里的一个好主意是使用<em class="ml"> dotenv </em>包(使用Node.js的人都知道)。</p><p id="2dab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我正在添加<em class="ml">。env </em>文件，其中包括:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d984" class="mr lp iq mn b gy ms mt l mu mv">DATABASE_HOST=localhost<br/>DATABASE_NAME=denoapp<br/>DATABASE_USER=deno<br/>DATABASE_PASSWORD=deno<br/>DATABASE_PORT=5432</span></pre><p id="81fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以从<em class="ml">获得配置。env </em>文件。我还将添加<em class="ml"> config.ts </em>文件，稍后我可以轻松导入该文件:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="e343" class="mr lp iq mn b gy ms mt l mu mv">import { config } from "https://deno.land/x/dotenv/mod.ts";<br/><br/>export const {<br/>  DATABASE_NAME,<br/>  DATABASE_USER,<br/>  DATABASE_PASSWORD,<br/>  DATABASE_HOST<br/>} = config();<br/><br/>export const DATABASE_PORT: number = parseInt(config().DATABASE_PORT, 10);</span></pre><p id="d462" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，dotenv包以字符串形式返回所有变量。数据库端口应该存储为一个数字。所以我准备单独导入，拆分。</p><p id="7499" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据库需要一个客户端。我将对<em class="ml"> repositories/pg.ts </em>文件进行更改:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="87ef" class="mr lp iq mn b gy ms mt l mu mv">import { Client } from "https://deno.land/x/postgres/mod.ts";<br/>import { DATABASE_NAME, DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_PORT } from "../config.ts";<br/><br/>const pgClient = new Client({<br/>  user: DATABASE_USER,<br/>  password: DATABASE_PASSWORD,<br/>  database: DATABASE_NAME,<br/>  hostname: DATABASE_HOST,<br/>  port: DATABASE_PORT<br/>});<br/><br/>await pgClient.connect();<br/><br/>export default pgClient;</span></pre><p id="6aa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我正在从config.ts文件中获取配置并连接到数据库。</p><p id="c9db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">客户来了！现在，我可以用它从数据库中返回用户列表。我将添加<em class="ml"> UserRepository.ts </em>文件。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="925d" class="mr lp iq mn b gy ms mt l mu mv">import pgClient from "./pg.ts";<br/><br/>export default {<br/>  findAll: async () =&gt; {<br/>    const result = await pgClient.query("SELECT id, email FROM users;");<br/>    return result.rowsOfObjects();<br/>  },<br/>};</span></pre><p id="b116" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以修改控制器方法了:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="3069" class="mr lp iq mn b gy ms mt l mu mv">@Controller("/users")<br/>export default class User {<br/>  @Get("/")<br/>  @HttpStatus(200)<br/>  async getUsers() {<br/>    const users = await userRepository.findAll();<br/>    return users;<br/>  }<br/>}</span></pre><p id="3a51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将启动应用程序，但我还需要添加另一个标志:<em class="ml">–allow-read =。/ </em>以便应用程序可以读取文件(<em class="ml">)。env </em>。</p><p id="6b5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd mn b">deno run --allow-net --allow-read./ -c tsconfig.json index.ts</code></p><p id="f7ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户需要能够注册。在添加这个特性之前，我需要检查在这个过程中会发送什么样的数据。valideno库是这项工作的好工具。我将添加<em class="ml">validators/user scheme . ts</em>文件，它包含:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="722b" class="mr lp iq mn b gy ms mt l mu mv">import {<br/>  isString,<br/>  isEmail,<br/>  isRequired<br/>} from "https://deno.land/x/valideno/mod.ts";<br/><br/>export const userScheme = {<br/>  email: [isEmail(), isRequired()],<br/>  password: [isString(), isRequired()],<br/>};</span></pre><p id="68ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我将向UserRepository.ts添加一个新方法。它向数据库添加一个新用户:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="5913" class="mr lp iq mn b gy ms mt l mu mv">import pgClient from "./pg.ts";<br/><br/>export default {<br/>  add: async (email: string, password: string) =&gt; {<br/>    await pgClient.query(<br/>      "INSERT INTO users (email, password) VALUES (lower($1), $2);",<br/>      email,<br/>      password,<br/>    );<br/>  },<br/>}</span></pre><p id="707a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还需要一种新的控制器方法:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="738e" class="mr lp iq mn b gy ms mt l mu mv">import {<br/>  Controller,<br/>  Body,<br/>  Get,<br/>  HttpStatus,<br/>  Post,<br/>  BadRequestException,<br/>  InternalServerErrorException,<br/>} from "https://deno.land/x/dactyl/mod.ts";<br/>import * as bcrypt from "https://deno.land/x/bcrypt/mod.ts";<br/>import { validate } from "https://deno.land/x/valideno/mod.ts";<br/>import { userScheme } from "../validators/UserScheme.ts";<br/>import userRepository from "../repositories/UserRepository.ts";<br/><br/>@Controller("/users")<br/>export default class User {<br/><br/>  ...<br/><br/>  @Post("/register")<br/>  @HttpStatus(201)<br/>  async register(<br/>    @Body("email") email: string,<br/>    @Body("password") password: string,<br/>  ) {<br/>    const errors = await validate({ email, password }, userScheme);<br/>    if (errors.length &gt; 0) {<br/>      throw new BadRequestException(errors.map((i) =&gt; i.message).join(", "));<br/>    }<br/>    const passwordHash = await bcrypt.hash(password);<br/><br/>    try {<br/>      await userRepository.add(email, passwordHash);<br/>      return {};<br/>    } catch (error) {<br/>      throw new InternalServerErrorException(error);<br/>    }<br/>}<br/><br/>}</span></pre><p id="74f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这需要一点解释。新用户注册时，我得到的唯一数据是JSON中的邮箱地址和密码。接下来，我需要验证数据。如果不是，将返回一个错误列表。如果是的话，密码散列将由bcrypt 库生成。然后，用户被添加到数据库中。</p><p id="e9ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还缺少一些东西——检查用户是否已经在数据库中的方法。我应该把它添加到验证器中。</p><p id="9ea2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我需要在<em class="ml">用户存储库</em>文件中添加一个新方法。它将返回给定的用户。我还可以在以后将它用于登录功能:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="cfb3" class="mr lp iq mn b gy ms mt l mu mv">import pgClient from "./pg.ts";<br/><br/>export default {<br/>  ...<br/>  findUserByEmail: async (email: string) =&gt; {<br/>    const result = await pgClient.query(<br/>      "SELECT email, password FROM users WHERE email = lower($1) LIMIT 1",<br/>      email,<br/>    );<br/>    if (result.rowCount === 1) {<br/>      const data = result.rowsOfObjects();<br/>      return data[0];<br/>    }<br/>    return null;<br/>  },<br/>}</span></pre><p id="896c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以添加一个新的验证器，包括新创建的方法:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="139b" class="mr lp iq mn b gy ms mt l mu mv">import {<br/>  isString,<br/>  isEmail,<br/>  isRequired,<br/>  Validator,<br/>  Args,<br/>} from "https://deno.land/x/valideno/mod.ts";<br/>import userRepository from "../repositories/UserRepository.ts";<br/><br/>export const emailExists = (): Validator =&gt; {<br/>  return {<br/>    type: "emailExists",<br/>    check: async (value: any) =&gt; {<br/>      const user = await userRepository.findUserByEmail(value);<br/>      return (user === null) ? undefined : {};<br/>    },<br/>    message: (value: any, args?: Args) =&gt; {<br/>      return `User with email [${value}] already exists.`;<br/>    },<br/>  };<br/>};</span></pre><p id="71f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将它添加到电子邮件地址验证方法中:</p><p id="e95a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd mn b">email: [isEmail(), isRequired(), emailExists()],</code></p><p id="b485" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧啊。现在，当一个新用户试图注册，但他们的电子邮件地址已经在数据库中，一个提供信息的消息被返回。</p><h1 id="a9d4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">登录到应用程序</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/b9a6d6a41454cfe32b9cf834f960c780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vTsCwSTbuO9j7dcb"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@erwanhesry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Erwan Hesry</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f193" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候添加日志功能了。从数据库中获取用户的方法已经存在。剩下我要做的就是在控制器中编写一个新的端点。它的工作是检查用户并为他们生成一个JWT令牌。</p><p id="489f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建令牌，我将利用<a class="ae ln" href="https://deno.land/x/djwt" rel="noopener ugc nofollow" target="_blank"> djwt库</a>。我还需要一把钥匙。我准备把它保存在<em class="ml">里。env </em>文件。</p><p id="9696" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd mn b">JWT_KEY=secret</code></p><p id="3365" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将修改<em class="ml"> config.ts </em>文件:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="06d3" class="mr lp iq mn b gy ms mt l mu mv">export const {<br/>  DATABASE_NAME,<br/>  DATABASE_USER,<br/>  DATABASE_PASSWORD,<br/>  DATABASE_HOST,<br/>  JWT_KEY,<br/>} = config();</span></pre><p id="9859" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我有了密钥，我可以生成令牌。我将添加<em class="ml"> jwt/jwt.ts </em>文件:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="8ebe" class="mr lp iq mn b gy ms mt l mu mv">import { makeJwt, setExpiration, Jose, Payload } from "https://deno.land/x/djwt/create.ts";<br/>import { JWT_KEY } from "../config.ts";<br/><br/>export const createUserJWToken = (email: string) =&gt; {<br/>  const payload = {<br/>    iss: email,<br/>    exp: setExpiration(new Date().getTime() + 3600),<br/>  } as Payload;<br/>  const header: Jose = {<br/>    alg: "HS256",<br/>    typ: "JWT",<br/>  };<br/>  return makeJwt({ header, payload, key: JWT_KEY });<br/>}</span></pre><p id="2659" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于每个新的电子邮件地址，我将生成一个新的令牌，该令牌将在一小时后过期。我现在将在我的控制器中使用该功能。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="bd15" class="mr lp iq mn b gy ms mt l mu mv">@Post("/login")<br/>@HttpStatus(200)<br/>async login(<br/>  @Body("email") email: string,<br/>  @Body("password") password: string,<br/>) {<br/>  const user = await userRepository.findUserByEmail(email);<br/>  if (user !== null) {<br/>    const comparePasswords = await bcrypt.compare(<br/>      password,<br/>      user.password,<br/>    );<br/>    if (comparePasswords) {<br/>      return { token: createUserJWToken(email) };<br/>    }<br/>    throw new BadRequestException("Given password is incorrect.");<br/>  }<br/>  throw new BadRequestException("Given email does not exists.");<br/>}</span></pre><p id="ba9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我要寻找一个有特定电子邮件地址的用户。一旦找到，我会检查他们的密码是否正确，并返回令牌。如果找不到用户，我就服务<em class="ml"> BadRequestException </em>。然后它被Dactyl获取并作为JSON返回。</p><p id="f992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还应该能够管理数据库结构。为此，我将使用<em class="ml"> Deno Nessie </em>包。</p><p id="7f5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我需要为Nessie添加一个适当的配置。它包含在<em class="ml"> nessie.config.ts </em>文件中:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="be8f" class="mr lp iq mn b gy ms mt l mu mv">import { ClientPostgreSQL } from "https://deno.land/x/nessie/clients/ClientPostgreSQL.ts";<br/>import { DATABASE_NAME, DATABASE_USER, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_PORT } from "./config.ts";<br/><br/>const nessieOptions = {<br/>  migrationFolder: "./migrations"<br/>};<br/><br/>const connectionOptions = {<br/>  database: DATABASE_NAME,<br/>  hostname: DATABASE_HOST,<br/>  port: DATABASE_PORT,<br/>  user: DATABASE_USER,<br/>  password: DATABASE_PASSWORD,<br/>};<br/><br/><br/>export default {<br/>  client: new ClientPostgreSQL(nessieOptions, connectionOptions),<br/>  exposeQueryBuilder: false,<br/>};</span></pre><p id="78f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在可以开始第一次迁移，目的是创建用户。</p><p id="8c2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">deno run–allow-net–allow-read。/–allow-write</em><a class="ae ln" href="https://deno.land/x/nessie/cli.ts" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://deno.land/x/nessie/cli.ts</em></a><em class="ml">make create _ users</em></p><p id="0a6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在在目录中有1592465715781-create_users.ts文件。它提供了两种方法:</p><ul class=""><li id="e60f" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated">up(迁移)、</li><li id="c44a" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">向下(回滚)。</li></ul><p id="0f49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在迁移方法中，我将添加在数据库中创建和删除用户表的功能。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="b306" class="mr lp iq mn b gy ms mt l mu mv">import { Migration } from "https://deno.land/x/nessie/mod.ts";<br/><br/>export const up: Migration = () =&gt; {<br/>  return `CREATE TABLE IF NOT EXISTS users(<br/>    id serial PRIMARY KEY,<br/>    password VARCHAR (60) NOT NULL,<br/>    email VARCHAR (355) UNIQUE NOT NULL<br/>  );`;<br/>};<br/><br/>export const down: Migration = () =&gt; {<br/>  return "DROP TABLE users";<br/>};</span></pre><p id="070a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将使用一个命令启动迁移:</p><p id="b491" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">deno run–allow-net–allow-read。/–allow-write</em>【https://deno.land/x/nessie/cli.ts】<em class="ml"/><em class="ml">迁移</em></p><p id="7118" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">已迁移1592465715781-create _ users . ts</em></p><p id="f958" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">迁移完成</em></p><h1 id="1274" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">添加Docker</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/5f1750693155db9d8553e2fd663de66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tPZM9m17pPjTAkUV"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@janesky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antonio Janeski</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cddf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应用程序已经准备好，迁移正在进行。是时候让我的应用程序具备启动能力了，不管它在什么操作系统上。为此，我将使用Docker。</p><p id="981a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Deno还没有一个官方的Docker形象，但是社区准备了<a class="ae ln" href="http://hayd/alpine-deno:1.1.0" rel="noopener ugc nofollow" target="_blank">一个</a>。我要去docker file(docker/docker file)。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="2be8" class="mr lp iq mn b gy ms mt l mu mv">FROM hayd/alpine-deno:1.1.0<br/>EXPOSE 8000<br/><br/>WORKDIR /app<br/>USER deno<br/><br/>ADD . .</span></pre><p id="7c0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还将使用docker-compose，这样我的数据库也可以在docker中启动(<em class="ml"> docker-compose.yml </em>文件)。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="8574" class="mr lp iq mn b gy ms mt l mu mv">version: "3.4"<br/>services:<br/>  db:<br/>    image: postgres:12-alpine<br/>    environment:<br/>      POSTGRES_PASSWORD: denopassword<br/>      POSTGRES_USER: deno<br/>      POSTGRES_DB: denoapp<br/>    volumes:<br/>      - postgres:/var/lib/postgresql/data<br/>    ports:<br/>      - 5432:5432<br/>    networks:<br/>      - app<br/><br/>  app:<br/>    build:<br/>      context: .<br/>      dockerfile: ./docker/Dockerfile<br/>    command: ["run", "--allow-read=./", "--allow-net", "--unstable", "-c", "tsconfig.json", "index.ts"]<br/>    working_dir: /app<br/>    ports:<br/>      - 8000:8000<br/>    depends_on:<br/>      - db<br/>    networks:<br/>      - app<br/><br/>networks:<br/>  app:<br/><br/>volumes:<br/>  postgres:</span></pre><p id="fb19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我要建立一个图像:</p><p id="4154" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml"> docker-compose构建</em></p><p id="04fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将启动数据库迁移流程:</p><p id="ddb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">docker-compose run app run–allow-net–allow-read。/–允许-写</em><a class="ae ln" href="https://deno.land/x/nessie/cli.ts" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://deno.land/x/nessie/cli.ts</em></a>T43】迁移</p><p id="654e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了它，我可以在Docker中启动应用程序:</p><p id="79fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml"> docker-compose up </em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1b4a50c4a04148e7ebaa6db3c3a4a012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*E3PzAuTrRCOU_Rq6.png"/></div></figure><p id="66d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与Node非常相似，Deno提供了一个内置的调试器(它与GoogleChrome的DevTools一起工作，并支持V8检查器协议)。因此，我可以在VisualStudio代码中轻松启动它。配置示例——launch . JSON:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="84c1" class="mr lp iq mn b gy ms mt l mu mv">{<br/>  "version": "0.2.0",<br/>  "configurations": [<br/>    {<br/>      "name": "Deno debugger",<br/>      "type": "node",<br/>      "request": "launch",<br/>      "cwd": "${workspaceFolder}",<br/>      "runtimeExecutable": "deno",<br/>      "runtimeArgs": [<br/>        "run",<br/>        "--inspect",<br/>        "--allow-net",<br/>        "--allow-read=./",<br/>        "--allow-write",<br/>        "--config",<br/>        "tsconfig.json",<br/>        "index.ts"<br/>      ],<br/>      "port": 9229<br/>    }<br/>  ]<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7222e76b0774d4494351f28732599060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*HraxnDP7gdiKBavb.png"/></div></figure><h1 id="dc1f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">总结- Deno REST原料药</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/bbc775d6ef159a24141686102522ee96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*raEe2ilU_4GOcgef"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@brookecagle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Cagle</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1c53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">来自Node，每天使用TypeScript，对我来说很容易开始使用Deno。在成为Node的真正竞争对手之前，这项技术还有很长的路要走，但它似乎确实走在了正确的方向上。然而，我们不要忘记，Node也在变得越来越好。在节点开发人员之前，肯定有一些有趣的时期。</p><h1 id="417d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Deno的最大优势包括:</h1><ul class=""><li id="72ca" class="nf ng iq kt b ku mg kx mh la nx le ny li nz lm nk nl nm nn bi translated">伟大的开发时间-不需要安装任何依赖。只需导入一个包并使用它，</li><li id="7832" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">从一开始就完全支持TypeScript，</li><li id="0495" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">默认文件格式机制(deno fmt)来自Go语言，</li><li id="b496" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">默认情况下阻止对资源和网络的访问。</li></ul><h1 id="ca53" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Deno的主要缺点:</h1><ul class=""><li id="3e01" class="nf ng iq kt b ku mg kx mh la nx le ny li nz lm nk nl nm nn bi translated">包的导入路径相当长。在节点中，您只需要名称。Deno需要整个路径，包括https://deno……(可以使用<em class="ml"> import_map.json </em>文件，这缩短了导入时间，但在启动时需要增加一个标志)，</li><li id="febd" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated">当您在VSCode中使用“转到定义”选项时，无法找到当前文件的位置。只能看到文件哈希:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/30c755921d27e9a523f65ba08a84867d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7XRP6Rruo70Lq2BI.png"/></div></div></figure><ul class=""><li id="d7cc" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated">编辑器中没有软件包的语法建议，这些软件包不是由Deno导入和缓存的。它迫使用户在真正开始使用它之前启动具有导入的应用程序。</li></ul><h1 id="c560" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">对Deno的集成开发环境支持</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/637d6646e09b8dcddcce47ce122f2216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TDjlOL7JPRcrShhW"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae ln" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Mossholder</a> on <a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我一直在使用带有合适的<a class="ae ln" href="https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno" rel="noopener ugc nofollow" target="_blank"> Deno插件</a>的Visual Studio代码。实际的支持并不一致，在我说您可以舒服地使用它之前，它还需要成熟一点。网络风暴还通过插件为Deno <a class="ae ln" href="https://blog.jetbrains.com/webstorm/2020/06/deno-support-in-jetbrains-ides/" rel="noopener ugc nofollow" target="_blank">提供支持。</a></p><p id="a65c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文中使用的库:</p><ul class=""><li id="522a" class="nf ng iq kt b ku kv kx ky la nh le ni li nj lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/dactyl" rel="noopener ugc nofollow" target="_blank">趾</a></li><li id="15ba" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/oak" rel="noopener ugc nofollow" target="_blank">橡木</a></li><li id="d80e" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a></li><li id="0fdf" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/djwt" rel="noopener ugc nofollow" target="_blank"> DJWT </a></li><li id="d7f6" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/valideno" rel="noopener ugc nofollow" target="_blank"> Valideno </a></li><li id="611b" class="nf ng iq kt b ku no kx np la nq le nr li ns lm nk nl nm nn bi translated"><a class="ae ln" href="https://deno.land/x/nessie" rel="noopener ugc nofollow" target="_blank">尼斯</a></li></ul><p id="23ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">多内容于</em> <a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ml">浅显易懂</em></strong></a></p></div></div>    
</body>
</html>