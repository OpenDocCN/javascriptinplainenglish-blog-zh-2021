# 6 对我看到的初级开发人员犯的错误做出反应(以及如何避免它们)

> 原文：<https://javascript.plainenglish.io/6-react-mistakes-i-saw-a-junior-developer-make-and-how-to-avoid-them-ed137b148f5a?source=collection_archive---------7----------------------->

## 我开始觉得我一定是个糟糕的老师

![](img/84aa1e9540df90b63742db7be85ca2d8.png)

Photo by [Kat Love](https://unsplash.com/@katlove?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/despair?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

作为一名有几年开发经验的经理，我经常有初级开发人员或实习生来找我，试图理解为什么他们的代码没有像他们期望的那样运行。在 React 中编码时，这通常源于对 useState 的行为方式缺乏理解。这里是我在开发人员理解`useState`如何工作的过程中看到的六个错误。

# 状态不够

这是一个(非常)初级开发人员犯的第一个错误，他还不明白什么时候调用 React 组件函数。他在一个`onClick`回调中改变了一个变量，然后想知道为什么这个改变没有在屏幕上显示出来。通常，应用程序外部的任何东西*都应该存储在某个地方，无论是用户点击的内容还是 API 调用的返回结果。“你需要在状态中存储这个”，我告诉他“否则它不会在帧之间被记住”。*

# 太多的状态

下一个错误是上一个错误的升级(由同一个人犯的),钟摆向另一个方向摆动。他如此专注于确保所有的数据都被安全地存储，以至于他还包括了其他状态的计算值。当然，如果只是代码混乱的问题，他可能不会寻求帮助。但是他每点击一次，显示屏就会更新一次。浏览代码时，我看到他在做这样的事情:

```
if (condition) setScore(score +1);if (score > 0) setButtonActive(true);
```

在上面的代码中，`score`在两行之间没有改变(因为我们在同一个渲染帧中)，此外，第二行存储了一些可以简单地从状态变量中推断出来的东西，这就是为什么显示没有被更新。“你不需要存储所有的东西”，我告诉他，“你可以从其他状态变量推断出的逻辑不需要存储”。

# 多次更新相同的状态

在他的代码中的另一个地方，我的朋友写了类似这样的东西:

```
if (condition) setScore(score +1);
// and then a few lines later
if (condition2) setScore(score +1);
```

现在，同样的问题正在发生，两者之间的状态没有更新，这导致了其他问题。解决这个问题的一种方法可能是创建一个代理变量，我们只在最后更新它，但是，状态更新函数允许我们传递一个函数，这个函数允许我们用它的未来值来操作状态(因为状态更新是异步批处理的)。

```
if (condition) setScore((previous) => previous +1);
// and then a few lines later
if (condition2) setScore((previous) => previous +1);
```

有一点我没有向他提出，因为他还没有完全明白，那就是当状态有需要以协调或重要的方式更新的相互依赖的变量时，最好是调用`useReducer`。但是他不在那里。还没有。

# 在渲染中重新定义太多

几天后，他回来了。他有一个表单，他确信自己做的一切都是正确的，但是每次他在 HTML 表单中输入数据时，状态都会被重新初始化。现在，在这一点上，我想说清楚，这是一个既非常聪明又非常好的人。然而，他刚刚开始学习 React，所以他几乎犯了所有可能犯的错误，我开始怀疑让他使用 React 开发是否明智。但那是实习，他是来学习的。经验通常只是过去错误的总和，所以按照这个标准……一切都进行得很好*。*

*他认真考虑了我关于重新计算不需要存储的数据的建议。但是他对这一切有点太热情了。对话大概是这样的:*

*—等等，这个组件从哪里开始？*

*––就在文件的顶部，这里。*

*––它在哪里结束？我找不到尽头。*

*—在文件的底部。*

*—这中间是什么？*

*—它是我定义的函数和常量，以及 HTML 表单的组件。因为我需要这个组件中的状态与主组件共享。*

*但愿他没有看到我脸上绝望的表情，我很确定那一定是我的表情。*

*“所有的常量和函数，只要提供逻辑而不操纵状态，都可以从组件中移出，放到一个单独的文件中。您可以导入您的入口点并使用它们。”我告诉他了。“在主组件中重新定义了表单组件……你在每一帧中都完全重新定义了它，所以你实际上在每次更新时都显示了一个新组件。”*

*我们最终对那段代码做了大量的重构。*

# *仅仅依靠初始道具来定义状态*

*这一次，我必须承认，我个人犯了罪。我创建了一个组件，它基本上显示了一个基于我传递给它的道具的圆形进度条。所以它像这样存储它的状态:*

```
*const [progress, setProgress] = useState(props.init);*
```

*当然，这样做的问题是，一旦第一次初始化完成，道具的任何改变都不会影响状态。*

*这里有两种可能的解决方案，这取决于组件中到底在做什么。如果组件没有任何更新状态的内部逻辑，您实际上不需要存储状态。但是在我的具体例子中，我确实需要状态，所以我使用了`useEffect`:*

```
*const [progress, setProgress] = useState(props.init);useEffect(()=> { 
  setProgress(props.init);
}, [props.init]);* 
```

# *用变异的对象更新状态*

*这是一个典型的错误，源于对对象在 JavaScript 中如何工作缺乏理解，更具体地说，是对对象进行变异不会触发 React 的变化检测。这是因为对象的赋值是通过引用的，也就是说，当你把一个对象赋给一个变量时，你实际上只是把指向这个对象的指针存储在你的变量中，所以两个变量可以指向同一个对象。*

```
*let a = {name:"Bob"};
let b = a;
b.name = "Alice";
// here a==b and a.name == "Alice";*
```

*用 React 术语来说，这意味着这样做不会更新显示，因为状态变量的值不会改变，它总是指向同一个对象:*

```
*const [state, setState]=useState({score:0});
const onClick =() => {
  state.score += 1;
  setState(state);
}*
```

*当然，解决方案(除了在上面的例子中使用标量，但是请原谅我)是创建状态的副本，例如使用 spread 操作符或者通过声明一个新的对象:*

```
*const [state, setState]=useState({score:0});
const onClick =() => {
   setState({..state, score: state.score+1});
}*
```

# *不要评判*

*虽然这是一条崎岖不平的道路，但我的同事在学习 React 的过程中获得了乐趣。我很确定我犯的错误至少和他一样多，当我看到我的旧代码时，我有时会退缩。老实说，我从这次经历中获益良多。解释事物是如何工作的是一种保持学习的好方法，也是一种令人满意的经历。*

**更多内容看*[***plain English . io***](http://plainenglish.io/)*