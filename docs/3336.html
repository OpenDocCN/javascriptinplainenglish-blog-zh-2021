<html>
<head>
<title>Why Redux Doesn’t Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux为什么不行</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-redux-doesnt-work-and-how-i-made-it-better-fbbd83f36a21?source=collection_archive---------3-----------------------#2021-07-07">https://javascript.plainenglish.io/why-redux-doesnt-work-and-how-i-made-it-better-fbbd83f36a21?source=collection_archive---------3-----------------------#2021-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b84" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及我如何让它变得更好</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ba214fdf357ee3850ebcac01272ea272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbY6qWshfI_4ofhSDiKzNA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Redux official logo</figcaption></figure><p id="3af0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">众所周知，Redux和React一样，是高度非个人化的——并以此为荣。这实际上是他们的工作方式，许多开发人员喜欢它带来的灵活性。但不是我。</p><p id="49f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我承认一个专横的库甚至比一个非专横的库更难共事，但是两者都太多会带来混乱和头痛。Redux是一个好的开始，但是，根据我的经验，它对大多数React应用程序来说还不够好。</p><p id="4703" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">刚开始用Redux的时候，喜欢它的简洁，更重要的是，它就是好用。但是当我建立了越来越多的商店时，我发现自己正在从旧项目中复制和粘贴冗余的、样板式的代码。我花了更多的时间重新输入旧代码，花更少的时间实际设计商店。甚至在使用Redux toolkit时也是如此，我发现它很有帮助，但仍然不能令人满意。</p><p id="a13d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，几周前，我决定对此做些什么:我设计了一个基于Redux的高度自以为是的状态管理库，我可以将它用于我自己的React项目。</p><p id="22a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中——献给所有和我一样沮丧的开发人员——我分享了我的想法。</p><p id="f6b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但首先，我觉得有必要阐述一下我对Redux的不满，正是这种不满驱使我编写了自己的库。</p><h2 id="4345" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">它没有建筑</h2><p id="f071" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">架构是将脚本和应用程序分开的东西。十年前，当我们还在HTML页面中注入JS脚本时，构建Javascript代码没有什么意义。但是在Typescript和SPA框架的世界中，这不仅是明智的，而且是负责任的做法。</p><p id="dfe1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">架构为软件设计提供了几个重要的好处。首先，它不仅在应用程序内部，而且在整个组织甚至整个行业中引入了一致性，这取决于它的采用程度。同样重要的是，好的架构使代码更具可读性和可消化性:你知道在哪里可以找到什么，以及它们是如何组合在一起的。这提高了生产率，并增进了对代码库的理解。</p><p id="141c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Redux让架构对开发者完全开放。它的设计模式提供了一个坚实的基础，但是基础就是基础。就像你不会仅仅生活在一个混凝土的基础上，你也不应该仅仅用Redux来为你的React应用建立一个中心商店。</p><h2 id="a2f5" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">很难扩大规模</h2><p id="b781" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">假设您需要将您的状态分成不同的部分。当然，您可以使用Redux toolkit的切片模式，但是您最终会得到许多没有清晰层次的移动部件。这将Redux存储的缩放限制在一个维度。</p><p id="19b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些都意味着，随着应用的增长，仅用Redux来管理中央状态变得越来越不方便。它<em class="mp">起作用</em>，但是我们可以做得更好。</p><h2 id="b8a4" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">它模糊了实现和接口之间的界限</h2><p id="a221" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这是软件设计的大罪。存储是用归约器和初始状态实现的；它通过动作创建器和选择器进行接口。如果没有一个清晰划分界限的架构，这种区别就会变得模糊不清。</p><p id="b03d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">画出这种区别不仅引入了关注点的分离，而且有助于减少商店内的名称冲突。我们都讨厌那种输入要导入的函数名，却只能看到三个不同的文件的感觉。</p><h2 id="0202" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">缺乏类型安全</h2><p id="65c4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这显然是一个Typescript问题，但是(如果您没有看过我在Medium上发表的其他文章)，我认为Typescript是设计良好的Node.js应用程序不可或缺的一部分。我的理智依赖于类型安全，而Redux几乎不能提供任何东西。如果我改变了一个动作的有效负载类型，但没有修改它的reducer，我应该会立即得到一个错误，阻止编译。如果我删除了一个reducer，但是没有删除它的action creator，我会得到一个错误，阻止编译。你明白了。</p><p id="c844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管Redux toolkit试图解决这个问题，但它没有提供既优雅又完全类型安全的解决方案。幸运的是，扣篮做到了。</p><h1 id="fb22" class="mq ls iq bd lt mr ms mt lw mu mv mw lz jw mx jx mc jz my ka mf kc mz kd mi na bi translated">更干净的状态管理方法</h1><p id="1f05" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我写了Dunk来解决所有这些缺点，我怀疑有类似需求的其他人也会觉得它很方便。</p><p id="de66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Dunk是一个可伸缩的、积极的类型安全状态管理框架，旨在最小化代码重复和最大化模块化。它构建在Redux之上，并公开了基本相同的API，因此您可以在已经使用Redux的任何地方使用它。</p><p id="6ccc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，它包含对thunks的一流支持，使异步操作变得轻而易举。</p><p id="04a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，它是如何工作的呢？</p><h2 id="3f28" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">模块，而不是切片</h2><p id="8eb8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">切片的最大限制是它们的单维度。你可以想要多少就有多少，但是中央政府没有明确的层级。这抑制了可伸缩性。相反，像任何好的架构一样，我们想要的是模块化——而这正是Dunk所提供的。</p><p id="adb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Dunk store中，基本元素是可组合的模块，每个模块都有自己的状态、动作、reducers和子模块。Dunk提供了实用程序类和函数，使得定义动作创建器和选择器以及嵌套模块变得毫不费力。而且它完全是类型安全的，降低了运行时错误的风险。</p><h2 id="46bf" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">扣篮界面</h2><p id="378b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Dunk还在商店的界面和它的实现之间画出了急需的区别。</p><p id="d5dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在内部，模块定义了三件事:状态、动作和归约器。理想情况下，这些都不应该被商店的客户访问(比如React组件)。</p><p id="9f26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从外部来看，模块定义了两件事:修改状态的动作创建器和读取状态的选择器。我们将很快看到两者的一些例子。</p><h1 id="4178" class="mq ls iq bd lt mr ms mt lw mu mv mw lz jw mx jx mc jz my ka mf kc mz kd mi na bi translated">创建扣篮模块</h1><p id="8e2b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先，您需要安装软件包:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f42c" class="lr ls iq nc b gy ng nh l ni nj">npm i @bswohlers/dunk</span></pre><p id="4ed5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个模块应该包含三个文件:<code class="fe nk nl nm nc b">types.ts</code>、<code class="fe nk nl nm nc b">reducer.ts</code>和<code class="fe nk nl nm nc b">index.ts</code>。</p><p id="1945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从类型开始。首先，我们为我们的状态定义一个类型:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f7a8" class="lr ls iq nc b gy ng nh l ni nj">type RootState = {<br/>  counter: number;<br/>}</span></pre><p id="e7b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们列举模块可以处理的动作:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f2b0" class="lr ls iq nc b gy ng nh l ni nj">export enum RootActions {<br/>  SET_COUNTER = "set-counter",<br/>  INC_COUNTER = "inc-counter",<br/>  RESET_COUNTER = "reset-counter"<br/>}</span></pre><p id="6226" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，这必须是唯一字符串的<code class="fe nk nl nm nc b">enum</code>。</p><p id="3847" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后——这也是Dunk获得其神奇的类型安全性的主要原因——我们将定义一个类型来指定每个动作的有效载荷类型。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3797" class="lr ls iq nc b gy ng nh l ni nj">type RootActionPayloads = DunkActionPayloads&lt;RootActions, {<br/>  [RootActions.SET_COUNTER]: number;<br/>  [RootActions.INC_COUNTER]: undefined;<br/>  [RootActions.RESET_COUNTER]: undefined;<br/>}&gt;</span></pre><p id="29b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，我们的<code class="fe nk nl nm nc b">SET_COUNTER</code>动作将把一个<code class="fe nk nl nm nc b">number</code>作为它的有效载荷。我们马上会看到这如何帮助防止粗心的错误。</p><p id="0e33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一需要创建的类型是<code class="fe nk nl nm nc b">DunkModule</code>，它将这三种类型捆绑在一起，以便于以后参考:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="024a" class="lr ls iq nc b gy ng nh l ni nj">export type RootModule = DunkModule&lt;RootState, RootActions, RootActionPayloads&gt;;</span></pre><p id="9f87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，让我们创建我们的减速器。Dunk提供了<code class="fe nk nl nm nc b">composeReducers</code>函数来帮助我们轻松地创建一个类型安全的缩减器。我们需要做的就是为每个动作传入初始状态和reducers。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5862" class="lr ls iq nc b gy ng nh l ni nj">export const rootReducer = composeReducers&lt;RootModule&gt;({<br/>  counter: 0<br/>}, {<br/>  [RootActions.SET_COUNTER]: (state, payload) =&gt; {<br/>    return { ...state, counter: payload };<br/>  },<br/>  [RootActions.INC_COUNTER]: (state) =&gt; {<br/>    return { ...state, counter: state.counter + 1 };<br/>  },<br/>  [RootActions.RESET_COUNTER]: (state) =&gt; {<br/>    return { ...state, counter: 0 };<br/>  }<br/>});</span></pre><p id="4286" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们将<code class="fe nk nl nm nc b">RootModule</code>作为类型参数传递给<code class="fe nk nl nm nc b">composeReducers</code>，所以<code class="fe nk nl nm nc b">payload</code>和<code class="fe nk nl nm nc b">state</code>是为每个减速器自动类型化的。这也确保了我们每个动作都有一个缩减器。</p><p id="c2f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们将在<code class="fe nk nl nm nc b">index.ts</code>中定义模块的接口。我们可以使用<code class="fe nk nl nm nc b">DunkInterfaceCreator</code>类，它没有状态，公开了一些方法来帮助我们定义模块的动作创建者和选择器。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7f18" class="lr ls iq nc b gy ng nh l ni nj">const creator = new DunkInterfaceCreator&lt;RootModule, RootState&gt;();</span></pre><p id="fd3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从创建一个选择器开始。选择器是将存储的状态作为参数并返回对状态的一些操作的函数，允许接口的客户端读取存储中的数据。我们需要做的就是向<code class="fe nk nl nm nc b">defineSelector</code>方法传递一个简单的函数:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="aa17" class="lr ls iq nc b gy ng nh l ni nj">const getCounter = creator.defineSelector(state =&gt; state.counter);</span></pre><p id="1061" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将定义动作创建者。动作创建器是返回动作或thunk动作的函数(关于thunk的更多信息，见此处的<a class="ae nn" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank">。多亏了thunk中间件，<code class="fe nk nl nm nc b">store.dispatch</code>可以处理这两种类型。</a></p><p id="c929" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个返回<code class="fe nk nl nm nc b">SET_COUNTER</code>动作的动作创建器:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="dcba" class="lr ls iq nc b gy ng nh l ni nj">const setCounter = creator.defineActionCreator((value: number) =&gt; ({<br/>  type: RootActions.SET_COUNTER,<br/>  payload: value<br/>}));</span></pre><p id="3ac5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个动作创建器，它返回一个thunk，该thunk按时间间隔递增计数器:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="a687" class="lr ls iq nc b gy ng nh l ni nj">countInterval = creator.defineActionCreator((interval: number) =&gt; {<br/>  return (dispatch, getState) =&gt; {<br/>    setInterval(() =&gt; {<br/>      const oldCounterValue = getState().counter;<br/>        dispatch(setCounter(oldCounterValue + 1));<br/>    }, interval);<br/>  }<br/>});</span></pre><p id="767c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们将选择器和动作创建器结合起来，形成这个模块的接口部分:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="9878" class="lr ls iq nc b gy ng nh l ni nj">export const RootInterface = creator.createInterfacePiece({<br/>  selectors: {<br/>    getCounter<br/>  },<br/>  actionCreators: {<br/>    setCounter,<br/>    countInterval<br/>  }<br/>})</span></pre><p id="760c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还不能直接使用这个接口——我们首先需要通过将它传递给<code class="fe nk nl nm nc b">createDunkInterface</code>来完成它，我们很快就会看到。</p><h1 id="0610" class="mq ls iq bd lt mr ms mt lw mu mv mw lz jw mx jx mc jz my ka mf kc mz kd mi na bi translated">创建一个扣篮商店</h1><p id="b746" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要创建一个商店，我们可以将根缩减器传递给<code class="fe nk nl nm nc b">createDunkStore</code>:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="54ee" class="lr ls iq nc b gy ng nh l ni nj">const store = createDunkStore(rootReducer);</span></pre><p id="d11a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nk nl nm nc b">store</code>本质上将拥有与Redux store相同的接口，因此您可以在任何可以使用Redux store的地方使用它。</p><p id="c4ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将创建商店的界面。我们通过将根接口传递给<code class="fe nk nl nm nc b">createDunkInterface</code>来实现这一点:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2c9a" class="lr ls iq nc b gy ng nh l ni nj">const Store = createDunkInterface(RootInterface);</span></pre><p id="64f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以调度操作:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="c1b1" class="lr ls iq nc b gy ng nh l ni nj">store.dispatch(Store.actionCreators.countInterval(1000));</span></pre><p id="b630" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者使用选择器:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8259" class="lr ls iq nc b gy ng nh l ni nj">const counter = Store.selectors.getCounter(store.getState());</span></pre><h1 id="57be" class="mq ls iq bd lt mr ms mt lw mu mv mw lz jw mx jx mc jz my ka mf kc mz kd mi na bi translated">嵌套模块</h1><p id="84b9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Dunk store卓越的可伸缩性在于其模块的可组合性。通过嵌套模块，您可以完全按照您想要的方式组织您的数据存储，确保关注点的分离和干净的目录结构。</p><p id="da6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们创建一个名为Settings的子模块。在商店的根目录下创建一个名为<code class="fe nk nl nm nc b">settings</code>的目录。就像我们的根模块一样，创建<code class="fe nk nl nm nc b">types.ts</code>、<code class="fe nk nl nm nc b">reducer.ts</code>和<code class="fe nk nl nm nc b">index.ts</code>。</p><p id="bee6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类型:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="125e" class="lr ls iq nc b gy ng nh l ni nj">type SettingsState = {<br/>  incrementStep: number;<br/>}<br/><br/>export enum SettingsActions {<br/>  SET_INC_STEP = "settings/set-inc-step",<br/>}<br/><br/>type SettingsActionPayloads = DunkActionPayloads&lt;SettingsActions, {<br/>  [SettingsActions.SET_INC_STEP]: number<br/>}&gt;<br/><br/>export type SettingsModule = DunkModule&lt;SettingsState, SettingsActions, SettingsActionPayloads&gt;;</span></pre><p id="2c6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">减速器:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7d53" class="lr ls iq nc b gy ng nh l ni nj">export const settingsReducer = composeReducers&lt;SettingsModule&gt;({<br/>  incrementStep: 1,<br/>}, {<br/>  [SettingsActions.SET_INC_STEP]: (state, payload) =&gt; {<br/>    return { ...state, incrementStep: payload };<br/>  }<br/>});</span></pre><p id="c9bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">索引:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="dad9" class="lr ls iq nc b gy ng nh l ni nj">const creator = new DunkInterfaceCreator&lt;SettingsModule, RootState&gt;();<br/><br/>const setIncStep = creator.defineActionCreator((value: number) =&gt; ({<br/>  type: SettingsActions.SET_INC_STEP,<br/>  payload: value<br/>}));<br/><br/>export const SettingsInterface = creator.createInterfacePiece({<br/>  actionCreators: {<br/>    setIncStep<br/>  }<br/>});</span></pre><p id="0214" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经完成了我们的子模块，我们只需要通过添加它作为<code class="fe nk nl nm nc b">RootModule</code>的子模块来将其集成到商店中。</p><p id="a824" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一步是更新<code class="fe nk nl nm nc b">RootState</code>:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="cce5" class="lr ls iq nc b gy ng nh l ni nj">type RootState = {<br/>  counter: number;<br/>  Settings: SettingsModule;<br/>}</span></pre><p id="afd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们更新传递给<code class="fe nk nl nm nc b">rootReducer</code>的初始状态:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2e7b" class="lr ls iq nc b gy ng nh l ni nj">export const rootReducer = composeReducers&lt;RootModule&gt;({<br/>  counter: 0,<br/>  Settings: settingsReducer<br/>}, {<br/>  [RootActions.SET_COUNTER]: (state, payload) =&gt; {<br/>    return { ...state, counter: payload };<br/>  },<br/>});</span></pre><p id="68a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为了将设置接口集成到商店的接口中，我们需要将其指定为根接口的子接口:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ecaf" class="lr ls iq nc b gy ng nh l ni nj">export const RootInterface = creator.createInterfacePiece({<br/>  selectors: {<br/>    getCounter<br/>  },<br/>  actionCreators: {<br/>    setCounter,<br/>    countInterval<br/>  }<br/>}, {<br/>  Settings: SettingsInterface<br/>})</span></pre><p id="11ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。我们现在可以通过界面轻松访问设置模块的动作、选择器和thunks。例如，如果我们要设置<code class="fe nk nl nm nc b">incrementStep</code>:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e5ed" class="lr ls iq nc b gy ng nh l ni nj">store.dispatch(Store.Settings.actions.setIncStep(5));</span></pre><h1 id="5137" class="mq ls iq bd lt mr ms mt lw mu mv mw lz jw mx jx mc jz my ka mf kc mz kd mi na bi translated">就这么简单</h1><p id="d09d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Redux是一个很棒的库，但是在生产中使用它就像试图用棍子盖房子一样。尽管有对非个人化库的大肆宣传，状态管理是前端开发的一部分，清晰的架构和严格的设计模式将改善开发人员的体验并提高生产率。</p><p id="980c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个官方文档的链接，可以更深入地了解API以及如何充分利用Dunk。这里的<a class="ae nn" href="https://github.com/wwohlers/dunk-js" rel="noopener ugc nofollow" target="_blank">是一个到GitHub repo的链接。</a></p><p id="50dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mp">更多内容请看</em><a class="ae nn" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>