<html>
<head>
<title>Creating Spotify from Scratch using Redux — An Explanation of Playback Capability in React Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux从头开始创建Spotify——React Redux中回放功能的解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-spotify-from-scratch-using-redux-an-explanation-of-playback-capability-in-react-redux-7f6653ea2ce8?source=collection_archive---------10-----------------------#2021-04-23">https://javascript.plainenglish.io/creating-spotify-from-scratch-using-redux-an-explanation-of-playback-capability-in-react-redux-7f6653ea2ce8?source=collection_archive---------10-----------------------#2021-04-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6110c0f3a834651cc96d80f7dcde86a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bhj_wGuD8_gMyKL-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alexbemore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Shatov</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3c22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为程序员，我们的核心本能之一是渴望实际创建我们最喜欢的网站，了解它们是如何创建的，并自己构建它们——揭开我们每天使用的这些程序的神秘面纱。</p><p id="c2ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就我个人而言，我花时间最多的网站是Spotify。作为一名音频工程师和程序员，我经常使用该网站收听客户音乐，创建激发我工作的播放列表，并且在日常活动中享受音乐。</p><p id="bc0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Spotify是一个复杂的网站，所以我挑战自己用Redux做了一个类似的程序。虽然它不是一个精确的复制品；我模仿了Spotify的许多核心功能，创建了一个非常友好的用户界面。我对此感到有点兴奋，因此这方面的代码量太多，无法在一篇单独的博客文章中解释，所以我想谈谈我认为大多数开发人员在尝试创建Spotify应用程序时遇到的问题:实际上播放应用程序中的音乐。</p><p id="622e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，实现歌曲播放技术的一个巨大资源是在Spotify文档中找到的信息。我强烈建议任何打算在应用程序中播放音乐的开发人员通读web API和SDK上的文档，它们是从应用程序中播放音乐所必需的。我选择使用Spotify播放器和他们的API来播放歌曲，这样我就可以在我的应用程序中播放任何歌曲，而不仅仅是存储在我本地机器上的歌曲，我希望我的用户能够访问他们想要的任何歌曲，并在React应用程序中播放。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/075af39cc4fd66694567accfa9808a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MttdrexO3iGo0J6r0Hb3w.png"/></div></div></figure><h1 id="f937" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">证明</h1><p id="c4ae" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">使用Spotify SDK或网络播放器的第一步是认证。每个个人用户都需要有一个来自Spotify的令牌，允许他们访问SDK和Spotify API。我没有指示我的用户去获取一个令牌并用它创建一个环境变量，而是决定通过Spotify使用一个身份验证端点来创建一个登录页面。这样，用户可以使用他们的Spotify凭据登录，而不必在网站上寻找认证令牌，令牌将在用户使用应用程序时存储。</p><p id="f5be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果应用程序呈现时Redux存储中没有存储有效的令牌，那么它将呈现组件SpotifyAuthButton。点击Spotify Auth按钮时，将呈现以下URI:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="0c97" class="ml le in mh b gy mm mn l mo mp">const hrefURI = `${authEndpoint}?client_id=${clientId}&amp;redirect_uri=${redirectUri}&amp;scope=${scopes.join(<br/>            "%20"<br/>          )}&amp;response_type=token&amp;show_dialog=true`</span></pre><p id="4770" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的config.js文件和spotifyAuthButton文件中，我配置了一个值为“https://accounts . Spotify . com/authorize”的authEndpoint，以及一些可以在Spotify开发人员门户中配置的个性化信息，这些信息需要clientId、redirectURI和我在此应用程序中试图从Spotify使用的信息的范围。关于示波器的进一步阅读可以在这里找到:<a class="ae jz" href="https://developer.spotify.com/documentation/general/guides/scopes/" rel="noopener ugc nofollow" target="_blank"> Spotify示波器文档</a>。这包括适当的授权端点，用户可以登录到他们的Spotify帐户，并允许我的应用程序访问生成令牌的信息。令牌会立即从Spotify生成令牌的窗口位置保存下来，然后以Redux状态存储，以便可以在调用Spotify API和配置Web播放器时使用令牌。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="2269" class="ml le in mh b gy mm mn l mo mp">componentDidMount() {<br/>    const hash = window.location.hash<br/>    .substring(1)<br/>    .split("&amp;")<br/>    .reduce(function(initial, item) {<br/>      if (item) {<br/>        var parts = item.split("=");<br/>        initial[parts[0]] = decodeURIComponent(parts[1]);<br/>      }<br/>      return initial;<br/>    }, {});    <br/>    let foundToken = hash.access_token;<br/>    if (foundToken) {<br/>      this.props.setToken(foundToken)<br/>      <br/>			<br/>			<br/>  }}<br/>	<br/>	const mapDispatchToProps = dispatch =&gt; {<br/>  return {<br/>    setToken: tokenText =&gt; dispatch({type: 'SET_TOKEN', payload: tokenText })<br/>  }<br/>}</span></pre><p id="3d2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当应用程序在状态中找到一个有效的令牌后，将从应用程序类中呈现MusicPlayerContainer。</p><h1 id="db6a" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">构建播放器容器</h1><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="34cb" class="ml le in mh b gy mm mn l mo mp">class App extends Component {<br/>  <br/></span><span id="b289" class="ml le in mh b gy mq mn l mo mp">  componentDidMount() {<br/>    const hash = window.location.hash<br/>    .substring(1)<br/>    .split("&amp;")<br/>    .reduce(function(initial, item) {<br/>      if (item) {<br/>        var parts = item.split("=");<br/>        initial[parts[0]] = decodeURIComponent(parts[1]);<br/>      }<br/>      return initial;<br/>    }, {});    <br/>    let foundToken = hash.access_token;<br/>    if (foundToken) {<br/>      this.props.setToken(foundToken)<br/>      <br/>  }}<br/></span><span id="2c8e" class="ml le in mh b gy mq mn l mo mp">  isValidToken = () =&gt; {<br/>    if (this.props.state.token){<br/>      return true<br/>    }<br/>  }<br/></span><span id="63a2" class="ml le in mh b gy mq mn l mo mp">  render() <br/></span><span id="d38f" class="ml le in mh b gy mq mn l mo mp">  {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>      {this.isValidToken() ? (<br/>      &lt;MusicPlayerContainer token={this.props.token}/&gt;<br/>      ) : ( &lt;SpotifyAuthButton/&gt;)}<br/>      &lt;/div&gt;  <br/>    );<br/>  }<br/>}<br/></span><span id="d980" class="ml le in mh b gy mq mn l mo mp">const mapStateToProps = state =&gt; {<br/>  return {<br/>    state<br/>  }<br/>}<br/></span><span id="b901" class="ml le in mh b gy mq mn l mo mp">const mapDispatchToProps = dispatch =&gt; {<br/>  return {<br/>    setToken: tokenText =&gt; dispatch({type: 'SET_TOKEN', payload: tokenText })<br/>  }<br/>}</span><span id="b3ca" class="ml le in mh b gy mq mn l mo mp">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></pre><p id="ff97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在MusicPlayerContainer中，第一步是从Spotify播放器资源加载脚本。在关于SDK的文档中，Spotify给出了这个将播放器资源加载到项目中的例子。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="5586" class="ml le in mh b gy mm mn l mo mp">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Spotify Web Playback SDK Quick Start Tutorial&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Spotify Web Playback SDK Quick Start Tutorial&lt;/h1&gt;<br/>  &lt;h2&gt;Open your console log: &lt;code&gt;View &gt; Developer &gt; JavaScript Console&lt;/code&gt;&lt;/h2&gt;</span><span id="0e2a" class="ml le in mh b gy mq mn l mo mp">  &lt;script src="https://sdk.scdn.co/spotify-player.js"&gt;&lt;/script&gt;<br/>  &lt;!-- We will insert our code here. --&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1373" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这对于某些类型的应用程序来说非常有效，但是这在Redux应用程序中引入了问题，在Redux应用程序中，我希望加载脚本源，然后使用该脚本并在我的应用程序中操纵它。我的解决方案是创建一个函数，加载Spotify Web Player脚本，将其附加到应用程序的主体，然后调用一个回调函数来创建一个Player对象，我可以将它存储在Redux store中，并通过我的应用程序进行访问。我用来做这件事的函数如下:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="47cd" class="ml le in mh b gy mm mn l mo mp">export const loadSpotifyScript = (callback) =&gt; {<br/>          const existingScript = document.getElementById('spotify');<br/>          if (!existingScript) {<br/>            const script = document.createElement('script');<br/>            script.src = 'https://sdk.scdn.co/spotify-player.js';<br/>            script.id = 'spotify';<br/>            document.body.appendChild(script);<br/>            script.onload = () =&gt; { <br/>              if (callback) callback();<br/>            };<br/>          }<br/>          if (existingScript &amp;&amp; callback) callback();<br/>        };</span></pre><p id="d71b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当MusicPlayerContainer组件挂载时，它会如此调用loadSpotifyScript，为其提供this.spotifySDKcallback的回调函数:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="f64d" class="ml le in mh b gy mm mn l mo mp">componentDidMount() {<br/>        loadSpotifyScript(this.spotifySDKCallback)<br/>            }</span></pre><p id="1232" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Spotify SDK文档中，它描述了使用如下代码创建播放器对象:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="b1fb" class="ml le in mh b gy mm mn l mo mp">window.onSpotifyWebPlaybackSDKReady = () =&gt; {<br/>  const token = '[My Spotify Web API access token]';<br/>  const player = new Spotify.Player({<br/>    name: 'Web Playback SDK Quick Start Player',<br/>    getOAuthToken: cb =&gt; { cb(token); }<br/>  });</span></pre><p id="ed57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我为redux/react设置改编的代码如下:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="ceff" class="ml le in mh b gy mm mn l mo mp">spotifySDKCallback = () =&gt; {<br/>             window.onSpotifyWebPlaybackSDKReady = () =&gt; {</span><span id="dd41" class="ml le in mh b gy mq mn l mo mp">             let { Player } = window.Spotify;        <br/>                const spotifyPlayer = new Player({<br/>                    name: 'React Spotify Player',<br/>                    getOAuthToken: cb =&gt; {<br/>                        cb(this.props.state..token);<br/>                    }<br/>                });<br/>                spotifyPlayer.addListener('player_state_changed', ({<br/>                    position,<br/>                    duration,<br/>                    track_window: { current_track }<br/>                  }) =&gt; {<br/>                    console.log('Currently Playing', current_track);<br/>                    console.log('Position in Song', position);<br/>                    console.log('Duration of Song', duration);<br/>                  });<br/>                this.setState({<br/>                    loadingState: "Loaded",<br/>                    spotifyPlayer<br/>                }, () =&gt; {<br/>                    this.connectToPlayer();<br/>                });<br/>            }<br/>         }</span></pre><p id="9f61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这个组件连接到Redux存储，所以我使用了存储的令牌并将其提供给播放器创建函数。我还添加了一些事件侦听器来帮助我稍后进行播放跟踪，最后调用我的函数connectToPlayer。在connectToPlayer中，我对存储的播放器实例进行操作，并从播放器实例中寻找deviceID。我没有给它一个特定的设备来连接，允许播放器链接到每个用户的默认播放设备。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="314b" class="ml le in mh b gy mm mn l mo mp">connectToPlayer = () =&gt; {<br/>            if (this.state.spotifyPlayer) {<br/>                this.state.spotifyPlayer.addListener('ready', ({device_id}) =&gt; {<br/>                    console.log('Ready with Device ID', device_id);<br/>                    this.setState({<br/>                        loadingState: "Player Ready",<br/>                        spotifyDeviceId: device_id,<br/>                        spotifyPlayerReady: true<br/>                    }, () =&gt; {<br/>                      this.notifyConnected()<br/>                          <br/>                    });<br/>                });<br/>                this.state.spotifyPlayer.connect().then(success =&gt; {<br/>                    if (success) {<br/>                      console.log('The Web Playback SDK successfully connected to Spotify!');<br/>                    }})}}</span></pre><p id="800b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用播放器文档中的方法，我在设备准备好之后连接上了。然后，我们正式设置开始播放。播放器和设备ID也存储在Redux存储中:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="ba08" class="ml le in mh b gy mm mn l mo mp">addPlayer: (player) =&gt; dispatch(addPlayer(player)),<br/>    addDeviceID: (deviceid) =&gt; dispatch(addDevice(deviceid))</span></pre><p id="2201" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个可以播放一些歌曲的设备Spotify SDK网络播放器的一个实例，这是我们完成的MusicPlayerContainer。在存在有效的deviceID和spotifyPlayer之前，仪表板不会呈现。这是为了防止点击播放按钮等。当播放器仍在加载时，所有组件在渲染时都在处理一个活动的播放器。在所有这些过程发生并安装播放器之前，会呈现一个美观的加载屏幕。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="65de" class="ml le in mh b gy mm mn l mo mp">class MusicPlayerContainer extends Component {<br/>    constructor(props){<br/>        super(props);<br/>    this.state = {<br/>        loadingState: "Loading",<br/>        spotifyAccessToken: this.props.token,<br/>        spotifyDeviceId: "",<br/>        spotifyPlayerConnected: false,<br/>        spotifyPlayerReady: false,<br/>        spotifyPlayer: undefined<br/>    };<br/>    }<br/></span><span id="2b62" class="ml le in mh b gy mq mn l mo mp">    componentDidMount() {<br/>        loadSpotifyScript(this.spotifySDKCallback)<br/>            }<br/></span><span id="054e" class="ml le in mh b gy mq mn l mo mp">       spotifySDKCallback = () =&gt; {<br/>             window.onSpotifyWebPlaybackSDKReady = () =&gt; {<br/></span><span id="9f64" class="ml le in mh b gy mq mn l mo mp">             let { Player } = window.Spotify;        <br/>                const spotifyPlayer = new Player({<br/>                    name: 'React Spotify Player',<br/>                    getOAuthToken: cb =&gt; {<br/>                        cb(this.props.state.token);<br/>                    }<br/>                });<br/>                spotifyPlayer.addListener('player_state_changed', ({<br/>                    position,<br/>                    duration,<br/>                    track_window: { current_track }<br/>                  }) =&gt; {<br/>                    console.log('Currently Playing', current_track);<br/>                    console.log('Position in Song', position);<br/>                    console.log('Duration of Song', duration);<br/>                    this.props.changeTrackerSong(current_track)<br/>                  });<br/>                this.setState({<br/>                    loadingState: "Loaded",<br/>                    spotifyPlayer<br/>                }, () =&gt; {<br/>                    this.connectToPlayer();<br/>                });<br/>            }<br/>         }<br/>         <br/>         connectToPlayer = () =&gt; {<br/>            if (this.state.spotifyPlayer) {<br/>                this.state.spotifyPlayer.addListener('ready', ({device_id}) =&gt; {<br/>                    console.log('Ready with Device ID', device_id);<br/>                    this.setState({<br/>                        loadingState: "Player Ready",<br/>                        spotifyDeviceId: device_id,<br/>                        spotifyPlayerReady: true<br/>                    }, () =&gt; {<br/>                      this.notifyConnected()<br/>                          <br/>                    });<br/>                });<br/>                this.state.spotifyPlayer.connect().then(success =&gt; {<br/>                    if (success) {<br/>                      console.log('The Web Playback SDK successfully connected to Spotify!');<br/>                    }})}}<br/></span><span id="2d61" class="ml le in mh b gy mq mn l mo mp">        notifyConnected = () =&gt; {<br/>            this.props.addPlayer(this.state.spotifyPlayer)<br/>            this.props.addDeviceID(this.state.spotifyDeviceId)<br/>        }<br/></span><span id="9b86" class="ml le in mh b gy mq mn l mo mp">    render(<br/>    ){<br/>        return(  <br/>        &lt;div&gt;    <br/>            {this.state.spotifyDeviceId &amp;&amp; this.state.spotifyPlayer ? (    &lt;div&gt;&lt;Router&gt;  &lt;Redirect to="/dashboard" /&gt;<br/>&lt;Route exact path='/dashboard' render={routerProps =&gt; &lt;Dashboard/&gt; } /&gt;&lt;/Router&gt;&lt;/div&gt;  <br/>      ) : (&lt;LoadingScreen/&gt;)}&lt;/div&gt; )}}</span><span id="a181" class="ml le in mh b gy mq mn l mo mp">const mapStateToProps = state =&gt; {<br/>    return {state} <br/>  }<br/></span><span id="1627" class="ml le in mh b gy mq mn l mo mp">const mapDispatchToProps = dispatch =&gt; ({<br/>    addPlayer: (player) =&gt; dispatch(addPlayer(player)),<br/>    addDeviceID: (deviceid) =&gt; dispatch(addDevice(deviceid)),<br/>    changeTrackerSong: (song) =&gt; dispatch(changeTrackerSong(song))<br/></span><span id="ead8" class="ml le in mh b gy mq mn l mo mp"> })<br/>  <br/> export default connect(mapStateToProps, mapDispatchToProps)(MusicPlayerContainer)</span></pre><h1 id="b1f3" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">播放特定的歌曲</h1><p id="71e5" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">然而，单独的网络播放器并不能让你做任何事情，只能从一个网页而不是Spotify网页上播放，只能播放你已经在Spotify网站上单独播放的内容，只是在不同的页面上播放。我想让它让你可以选择任何歌曲，并使用播放器来听这首歌，所以我也利用了Spotify API。我在应用程序的几个不同地方使用了回放功能，但我们将讨论最基本的功能。如果你使用搜索页面查找碧昂斯，你会得到她的一些歌曲列表。你可以点击这些歌曲的播放按钮，它会在应用程序中播放。</p><p id="1c34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是Song类中播放/暂停图像的代码，它将更改onClick，并调用从父组件SongResult作为道具传递下来的函数。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="de89" class="ml le in mh b gy mm mn l mo mp">&lt;img className="SongAlbumImagePlay" id={this.props.index} name={this.props.song.uri} src={imagesPath[imageName]} onClick ​={this.props.callPlayback} alt="new"/&gt;</span></pre><p id="5b16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将callPlayback方法放在所有song组件的父组件中，因为我希望将每个Song对象的播放/暂停图像作为一个整体来管理，这样，如果有人单击所有按钮(一次只单击一个),就不会在播放时标记所有的图像，并且我希望以一次只发送一个的方式来管理发送给播放器的请求。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="cad4" class="ml le in mh b gy mm mn l mo mp">callPlayback = (event) =&gt; {<br/>      let savedInfo = event<br/>        if (savedInfo.target.id !== this.state.currentSong){<br/>          this.callPlaybackOnNewSong(savedInfo)<br/>        }<br/>        else if (savedInfo.target.id === this.state.currentSong){<br/>         this.callPlaybackOnSameSong(savedInfo)<br/>    }<br/>   }</span></pre><p id="b966" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你点击其中一个按钮时，调用callPlayback函数。首先，它会检查您调用的是正在听的歌曲的回放(从而恢复歌曲)还是一首全新的歌曲。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="eb4e" class="ml le in mh b gy mm mn l mo mp">state = {<br/>        selectedElement: "empty",<br/>        songs: this.props.songs,<br/>        currentSong: "empty"}</span></pre><p id="abd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在SongResult类的状态下，currentSong被初始化为空，所以如果我们第一次调用这个函数，this.callPlaybackOnNewSong将被调用。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="0036" class="ml le in mh b gy mm mn l mo mp">callPlaybackOnNewSong = (savedInfo) =&gt; {<br/>    if(!this.props.state.playbackOn){<br/>      let selectedElement = this.props.songs.splice(savedInfo.target.id, 1)[0]<br/></span><span id="fde3" class="ml le in mh b gy mq mn l mo mp">      this.props.startPlayback(savedInfo.target.name, this.props.state.deviceID, this.props.state.token)<br/>        this.props.songs.forEach(function (song) {<br/>          song.open = false;<br/>        })<br/>      selectedElement.open = true;<br/>     this.props.songs.splice(savedInfo.target.id, 0, selectedElement)   <br/>     this.setState({songs: this.props.songs, selectedElement: selectedElement})<br/>      }<br/>      else if (this.props.state.playbackOn){<br/>        let selectedElement = this.props.songs.splice(savedInfo.target.id, 1)[0]<br/></span><span id="00b8" class="ml le in mh b gy mq mn l mo mp">        this.props.startPlayback(savedInfo.target.name, this.props.state.deviceID, this.props.state.token)<br/>          this.props.songs.forEach(function (song) {<br/>            song.open = false;<br/>          })<br/>        selectedElement.open = true;<br/>       this.props.songs.splice(savedInfo.target.id, 0, selectedElement)   <br/>       this.setState({songs: this.props.songs, selectedElement: selectedElement})<br/>        }<br/></span><span id="756c" class="ml le in mh b gy mq mn l mo mp">      else if(!this.props.state.playbackPaused){<br/>         this.props.pauseTrack(this.props.state.deviceID, this.props.state.token)<br/>         this.props.songs.forEach(function (song) {<br/>          song.open = false;<br/>        })<br/>    }<br/>    this.setState({songs: this.props.songs, currentSong: savedInfo.target.id})  <br/></span><span id="23d4" class="ml le in mh b gy mq mn l mo mp">   }</span></pre><p id="4536" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数有一点内容，它不仅负责发送开始播放的请求，而且还调整歌曲的状态——如果open为false，它将显示播放图片，如果open为true，它将显示暂停图片，以直观地显示一次播放哪首歌曲。startPlayback函数在我的actions文件夹中，它用于发送一个请求，使用我们已经加载的播放器播放一首歌曲，该播放器链接到我们的deviceID。每首歌曲都使用存储的uri呈现，如下所示:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="0c2f" class="ml le in mh b gy mm mn l mo mp">name={this.props.song.uri}</span></pre><p id="acb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这允许event.target.name在我们的请求中将曲目的单个uri发送到Spotify API。startPlayback、resumePlayback和pauseTrack都使用Thunk中间件，它在该中间件中接收一个分派方法，并返回一个函数。一旦异步动作已经完成，dispatch用于将同步动作分派给reducer。Redux商店中的playbackOn和playbackPaused的状态将影响我们的显示和歌曲跟踪栏。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="02b0" class="ml le in mh b gy mm mn l mo mp">const STARTPLAYBACKURL = "https://api.spotify.com/v1/me/player/play?"<br/>const PAUSEURL = "https://api.spotify.com/v1/me/player/pause?"</span><span id="0051" class="ml le in mh b gy mq mn l mo mp">export const startPlayback = (spotify_uri, deviceID, token) =&gt; {<br/>    console.log(spotify_uri)<br/>    console.log(deviceID)<br/>    return (dispatch) =&gt; {<br/>    return fetch(STARTPLAYBACKURL +<br/>          "device_id=" + deviceID, {<br/>          method: 'PUT',<br/>          body: JSON.stringify({uris: [spotify_uri]}),<br/>          headers: {<br/>              'Content-Type': 'application/json',<br/>              'Authorization': `Bearer ${token}`<br/>          }}).then((<br/>            dispatch({type: 'PLAYBACK_ON', playbackOn: true}),<br/>            dispatch({type: 'TURN_OFF_PAUSE', playbackPaused: false})<br/>          ))}}<br/></span><span id="ab5c" class="ml le in mh b gy mq mn l mo mp">  export const resumePlayback = (deviceID, token) =&gt; {<br/>    return (dispatch) =&gt; {<br/>    return fetch(STARTPLAYBACKURL +<br/>          "device_id=" + deviceID, {<br/>          method: 'PUT',<br/>          headers: {<br/>              'Content-Type': 'application/json',<br/>              'Authorization': `Bearer ${token}`<br/>          }}).then((<br/>            dispatch({type: 'PLAYBACK_ON', playbackOn: true}),<br/>            dispatch({type: 'TURN_OFF_PAUSE', playbackPaused: false})<br/>            ))}}</span><span id="f651" class="ml le in mh b gy mq mn l mo mp">            <br/>           <br/>  <br/>    					<br/>   export const pauseTrack = ( deviceID, token) =&gt; {<br/>    return (dispatch) =&gt; {<br/>    return fetch(PAUSEURL +<br/>          "device_id=" + deviceID, {<br/>          method: 'PUT',<br/>          headers: {<br/>              'Content-Type': 'application/json',<br/>              'Authorization': `Bearer ${token}`<br/>          }}).then((<br/>            dispatch({type: 'PLAYBACK_OFF', playbackOn: false}),<br/>            dispatch({type: 'TURN_ON_PAUSE', playbackPaused: true})<br/>            ))}}</span></pre><p id="6974" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个使用存储在Redux状态中的deviceID和token的请求允许安装的播放器开始播放任何呈现的歌曲，因为歌曲将总是使用它们的track uri来呈现，这是API加载歌曲的回放信息所需要的。</p><p id="93db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个歌曲跟踪器使用Redux存储状态，每半秒钟通过检查playbackOn的状态来检查播放是否开启。如果我们发送了一个fetch来开始回放，我们也通过Thunk中附加的调度函数在我们的reducer中将playbackOn更新为true。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="7c5e" class="ml le in mh b gy mm mn l mo mp">getCurrentlyPlayingS = (token) =&gt; {<br/>          getCurrentlyPlaying(token).then((data) =&gt; {<br/>                    this.setState({<br/>                        data: data,<br/>                      item: data.item,<br/>                      duration_ms: data.item.duration_ms,<br/>                      is_playing: data.is_playing,<br/>                      width: ((data.progress_ms * 100 / data.item.duration_ms)*6),<br/>                      progress_ms: data.progress_ms<br/>                    })})<br/>componentDidMount() {<br/>       this.interval = setInterval(() =&gt; this.tick(), 500)}<br/></span><span id="eb22" class="ml le in mh b gy mq mn l mo mp">      tick = () =&gt; {<br/>         if(this.props.state.playbackOn === true){<br/>        this.getCurrentlyPlayingS(this.props.state.token);  <br/>         <br/>}</span></pre><p id="a54c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当playback为true时，它向这个fetch发送一个请求，这个fetch使用我们存储的令牌和挂载的Web播放器来获取关于当前播放的歌曲的信息。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="0d0c" class="ml le in mh b gy mm mn l mo mp">const PLAYERURL = `https://api.spotify.com/v1/me/player`</span><span id="7e78" class="ml le in mh b gy mq mn l mo mp">export const getCurrentlyPlaying = (token) =&gt; {<br/>    return fetch(PLAYERURL, {<br/>          method: 'GET',<br/>          headers: {<br/>              'Accept': 'application/json',<br/>              'Content-Type': 'application/json',<br/>              'Authorization': `Bearer ${token}`<br/>          }}).then(parseJSON)}</span></pre><p id="dfd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每半秒钟这个tick被调用一次，tick将返回信息——最重要的是用户正在收听的确切位置。然后将用户收听歌曲的进度值添加到状态中，其中该值用于计算进度条相对于歌曲整体的宽度(以像素为单位),以给出用户收听歌曲的进度的可视表示。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="631e" class="ml le in mh b gy mm mn l mo mp">const progressBarStyles =  {<br/>            width: (this.state.width) + 'px'<br/>            <br/>          };</span><span id="d5b7" class="ml le in mh b gy mq mn l mo mp">          const progressBarStyles2 = {<br/>            width: 600 + 'px'<br/>          };<br/>					<br/>					   &lt;div className="progress__bar2" style={progressBarStyles2} /&gt;<br/>            &lt;div className="progress__bar" style={progressBarStyles} /&gt;</span></pre><p id="732f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些结合起来允许回放，以及回放的一些视觉元素。到目前为止，弄清楚如何调整SDK和Spotify API的文档，使其在React Redux格式中易于工作是项目中最困难的部分，但最困难的部分总是产生最好的部分——到目前为止，我认为这个项目最好的部分是在与它交互时听音乐的能力。如果你们中的任何人对完整教程感兴趣或者有任何其他要求/建议，请留下评论或者通过我的链接树联系我！</p><p id="cf51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/hopegipson/Spotify_Clone" rel="noopener ugc nofollow" target="_blank">完整代码</a></p><h1 id="c116" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">演示</h1><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="df25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mt">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>