<html>
<head>
<title>An Introduction to Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-and-algorithms-linked-lists-4f098130d820?source=collection_archive---------17-----------------------#2021-04-12">https://javascript.plainenglish.io/data-structures-and-algorithms-linked-lists-4f098130d820?source=collection_archive---------17-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/acd7cd51ca79223f313b72a15f2b71a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hqv3l9NvOPvaNIEh"/></div></div></figure><h2 id="06c7" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是链表？</h2><p id="fe23" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">链表是数据元素的集合，这些数据元素被称为节点。这些节点具有连续的顺序，但与数组不同，这些元素不存储在连续的内存位置中。相反，每个节点都有一个对序列中下一个节点的引用。每个节点还将包含一段数据。</p><p id="bd49" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">链表中的第一个节点被称为头，链表中的最后一个元素被称为尾。尾部没有指向节点的引用，而是指向null。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/9b0d66fe7ef276fc8922a235e0155796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuiaumuIiVM-EKebiWiCaA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Linked list</figcaption></figure><h2 id="30d2" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">双向链表</h2><p id="3d69" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">除了引用序列中的下一个节点，链表还可以引用序列中的上一个节点。链表中的节点引用了前一个和后一个节点，这种链表称为双向链表。在双向链表中，头部的前一个引用为空，尾部的后一个引用为空。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/e84dcd8ad2ed1838db0a3a9411a21972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNE3Ap6wZo1Pafp7BV-F9A.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Doubly linked list</figcaption></figure><h2 id="282b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">循环链表</h2><p id="56ee" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在循环链表中，列表中的每个节点都有下一个引用。没有尾部或对null的引用。相反，节点的下一个引用是头节点，否则它将是序列中的最后一个节点。循环链表中的节点形成一个闭环，故名循环链表。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/2467b238cb61a744ece99a7370924a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSID9VoIl5ThusrB2E_SrA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Circular linked list</figcaption></figure><h2 id="25bd" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">操纵链表</h2><p id="412c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">要将节点添加到链表中，请在序列中的节点之间重新分配引用。前一个节点的下一个引用将被分配给新节点，在双向链表的情况下，序列中后一个节点的前一个引用也将被分配给新节点。新节点的下一个和前一个引用也必须分配给序列中新节点前后的节点。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/d74c7e93d66faef8eb5ed053ffac19fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DkX2R8IMQ9YmMFEjTa-gXQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Adding a node to a linked list</figcaption></figure><p id="ef57" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要创建一个链表，可以创建一个类并实例化一个新的链表。这个列表实例的头为null，没有任何节点。还可以创建一个节点类来将节点添加到链表中。该节点需要用数据和下一个引用进行实例化。</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="dc74" class="jy jz iq mh b gy ml mm l mn mo">class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>  }<br/>}</span><span id="5d0e" class="jy jz iq mh b gy mp mm l mn mo">class Node {<br/>  constructor(data, next = null) {<br/>    this.data = data;<br/>    this.next = next;<br/>  }<br/>}</span><span id="3dd2" class="jy jz iq mh b gy mp mm l mn mo">const list = new LinkedList();</span></pre><p id="0670" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">当被调用时，下面的函数实例化一个新的节点并将它分配给head节点。它还将前一个头节点指定给其下一个引用。</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="0db6" class="jy jz iq mh b gy ml mm l mn mo">insertNodeAtStart(data) {<br/>  this.head = new Node(data, this.head);<br/>}</span></pre><p id="51c6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要将一个节点添加到列表的末尾，可以使用以下函数。这个函数首先创建一个新节点。如果列表中没有头节点，这个新节点将被分配给头节点。否则，该函数将遍历列表中的每个节点，直到找到没有下一个引用的节点。该节点是列表中当前的最后一个节点。新节点将被分配给列表中最后一个节点的下一个引用。</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="29d6" class="jy jz iq mh b gy ml mm l mn mo">insertNodeAtEnd(data) {<br/>  let node = new Node(data);<br/>  let current;<br/>  if (!this.head) {<br/>    this.head = node;<br/>  } else {<br/>    current = this.head;<br/>    while (current.next) {<br/>      current = current.next;<br/>    }<br/>    current.next = node;<br/>  }<br/>}</span></pre><p id="aa34" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要从链表中移除节点，必须更改序列中的引用，以绕过将被移除的节点。被移除节点之前的节点现在将具有指向被移除节点之后的节点的下一个引用。如果列表是双向链接的，那么被移除节点之后的节点的先前引用现在将指向被移除节点之前的节点。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/6c0155de848610a229701a1270775d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUNkDZadvr1E8mE9WV3Jhw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk">Removing node from linked list</figcaption></figure><p id="f797" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要删除特定索引处的节点，必须遍历列表中的所有节点，直到到达具有所需索引的节点。当到达该节点时，序列中前面节点的下一个引用被分配给要删除的节点的下一个引用。这将绕过要删除的节点，将其从列表中删除。</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="8bfd" class="jy jz iq mh b gy ml mm l mn mo">deleteAtIndex(index) {<br/>  let current = this.head;<br/>  let previous;<br/>  let count = 0;<br/>  if (index === 0) {<br/>    this.head = current.next;<br/>  } else {<br/>    while (count &lt; index) {<br/>      count++;<br/>      previous = current;<br/>      current = current.next;<br/>    }<br/>    previous.next = current.next;<br/>  }<br/>}</span></pre><p id="2d71" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">类似的功能可以用于基于其他标准来改变列表。例如，该功能可以适用于从列表中删除具有特定数据值的节点。</p><h2 id="9971" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">遍历链表</h2><p id="ca2e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">要访问特定节点保存的信息，必须遍历链表，直到到达该节点。搜索将从头或尾开始，并且每个节点的下一个或前一个属性将用于从一个节点前进到另一个节点，直到到达期望的节点。</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="703e" class="jy jz iq mh b gy ml mm l mn mo">getAtIndex(index) {<br/>  let current = this.head;<br/>  let count = 0;<br/>  while (current) {<br/>    if (count === index) {<br/>      //When this is true the desired node has been accessed.    <br/>      //Information about the node can be viewed or changed now.<br/>      console.log(current.data);<br/>    }<br/>    current = current.next;<br/>    count++;<br/>  }<br/>}</span><span id="e5f8" class="jy jz iq mh b gy mp mm l mn mo">      console.log(current.data);<br/>    }<br/>    current = current.next;<br/>    count++;<br/>  }<br/>}</span></pre><p id="44a8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><em class="mr">更多内容尽在</em><a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mr">plain English . io</em></a></p></div></div>    
</body>
</html>