<html>
<head>
<title>How to Interchange Promises with Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中用Async/Await交换承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promises-are-interchangeable-with-async-await-cc03434c0b29?source=collection_archive---------5-----------------------#2021-03-12">https://javascript.plainenglish.io/promises-are-interchangeable-with-async-await-cc03434c0b29?source=collection_archive---------5-----------------------#2021-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0bbae9534ecb2e4d4e835c0a675fdead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2R3sptN4SEFBlpi"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Robin Ebbinghaus</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="ac70" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自我的<a class="ae jd" href="https://fek.io/blog/promises-are-interchangeable-with-async-await" rel="noopener ugc nofollow" target="_blank">博客</a>。</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1409" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript如此强大的原因之一是它处理异步行为的方式。从一开始，JavaScript就使用回调作为处理可能需要一段时间才能完成的响应的方式，而不会阻止程序继续处理其他逻辑。</p><p id="4155" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向数据库、文件系统或网络中检索或写入内容都是可能阻塞程序的例子。以下示例是对文件系统的读取请求，其结果通过回调进行处理:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><h1 id="6fd9" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺</h1><p id="4c62" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">ECMAScript 2015中引入了承诺，作为能够使用更结构化的模式处理异步行为的另一种方式。回调的基本问题是，如果您必须一次处理多个回调，您的代码可能看起来像一棵回调树。Promises有<code class="fe ml mm mn mo b">then</code>和<code class="fe ml mm mn mo b">catch</code>函数，可以调用它们来处理异步请求。如果你的承诺解决了另一个承诺，你可以接着再做一个<code class="fe ml mm mn mo b">then</code>。</p><p id="e861" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Chrome中的<code class="fe ml mm mn mo b">fetch</code> API是一个承诺库的例子，它可以在一个请求中返回多个承诺。下面是一个用JSON响应处理Rest API的fetch请求示例:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><h1 id="7aba" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步和等待</h1><p id="541f" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Promise API比传统的错误优先回调更优雅，但语法仍然很简洁，因为<code class="fe ml mm mn mo b">then</code>和<code class="fe ml mm mn mo b">catch</code>函数都是高阶函数，需要向它们传递另一个函数来处理Promise的完成。</p><p id="432d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过采用<code class="fe ml mm mn mo b">async</code>和<code class="fe ml mm mn mo b">await</code>关键字，我们可以编写看起来同步的代码，但是我们可以继续使用承诺:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><p id="aa55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面的例子中看到的，我们已经用关键字<code class="fe ml mm mn mo b">await</code>替换了<code class="fe ml mm mn mo b">then</code>高阶函数。<code class="fe ml mm mn mo b">await</code>关键字必须在用<code class="fe ml mm mn mo b">async</code>关键字注释的函数内部使用。如果您使用Deno或Node.js 15或更高版本，您可以在程序的顶层使用<code class="fe ml mm mn mo b">await</code>关键字，而不必在<code class="fe ml mm mn mo b">async</code>函数中运行它。</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><h1 id="5235" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">定义新的承诺</h1><p id="1723" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们可以通过创建新的承诺来定义一个承诺。Promise的构造函数只需要一个高阶函数，带有两个参数，分别用于解析和拒绝。以下是延迟1000毫秒后返回字符串的承诺示例:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><p id="4495" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以重写这个来使用<code class="fe ml mm mn mo b">async</code>和<code class="fe ml mm mn mo b">await</code>，并承诺处理<code class="fe ml mm mn mo b">setTimeout</code>。</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lh lg l"/></div></figure><h1 id="c8ea" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">摘要</h1><p id="2e63" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">从前面的例子中我们可以看出，承诺和<code class="fe ml mm mn mo b">async</code>和<code class="fe ml mm mn mo b">await</code>是可以互换的。</p></div></div>    
</body>
</html>