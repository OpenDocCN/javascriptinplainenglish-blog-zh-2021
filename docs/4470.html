<html>
<head>
<title>Nest.js Cookie-Based JWT Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Cookie的JWT认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nest-js-cookie-based-jwt-authentication-615be1f907a9?source=collection_archive---------10-----------------------#2021-09-06">https://javascript.plainenglish.io/nest-js-cookie-based-jwt-authentication-615be1f907a9?source=collection_archive---------10-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/07d7f25f8be8b4f4d98980f3d1397eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lU01eNzKQtyxXsUzLyWXYg.png"/></div></div></figure><p id="03af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始使用Nest.js作为我们的Node + TypeScript服务开发的主要框架，主要是因为它具有内置的配置，并且可以随时使用与TypeScript集成在一起的项目结构。最重要的是，它包含了构建和林挺脚本，这是很难从零开始，它只是开箱即用。</p><p id="8bbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://blockpulsar.com/" rel="noopener ugc nofollow" target="_blank">https://blockpulsar.com</a>我们一直专注于灵活的服务开发方式，这样每项服务都将是独立的原子，以获得更好的可扩展性和易于维护性。这就是为什么从一开始我们就实现了基于JWT令牌的身份验证，这样我们就可以嵌入关于个人HTTP请求的最常用信息，而其他服务可以使用我们的JWT密钥提取这些信息。这听起来像是一种非常标准的做事方式，但我仍然想指出我们这样做的方式，以及当我们将所有内容移入Cookies而不是保存在本地存储中时，结构变得多么简单，这样我们的UI现在就不会通过<code class="fe kx ky kz la b">Authorization</code>头发送它。一切都是通过浏览器cookie执行所有对API的请求来实现的，顺便说一下，这比本地存储更安全。</p><h1 id="07e9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为Nest.js设置Passport JWT</h1><p id="3fdc" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Nest.js由所谓的原子模块组成，这些原子模块通过可注入类原则连接到主应用程序模块。嗯，这只是一种奇特的说法，有一个主模块调用所有其他模块来初始化它们，共享相同的上下文，并为Express.js设置中间件，这是实际的HTTP处理程序。理解这一点很重要，最终Express.js是处理请求的人，Nest.js只是一个包装器，这意味着所有的Express.js库都可以与Nest.js一起使用，包括Passport.js和<code class="fe kx ky kz la b">passport-jwt</code>库，这是我们这里的基础。</p><p id="4882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为认证的核心入口点，我们有一个名为<code class="fe kx ky kz la b">auth</code>的模块，如下所示</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="75d0" class="mm lc iq la b gy mn mo l mp mq">// Auth Module<br/>import { PassportModule } from '@nestjs/passport';<br/>import { JwtModule } from '@nestjs/jwt';<br/>import { JwtStrategy } from './jwt.strategy';<br/>import { AuthService } from './auth.service';</span><span id="1443" class="mm lc iq la b gy mr mo l mp mq">@Module({<br/>  imports: [<br/>    ...<br/>    PassportModule.register({<br/>      session: false,<br/>    }),<br/>    JwtModule.register({<br/>      secret: AppConfig().jwtSecret,<br/>      signOptions: { expiresIn: '7d' },<br/>    }),<br/>    ...<br/>  ],<br/>  providers: [<br/>    ...<br/>    AuthService,<br/>    JwtStrategy<br/>    ...<br/>  ],<br/>  controllers: [AuthController],<br/>})<br/>export class AuthModule {}</span></pre><p id="cf79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个初始化结构，其中我们有来自<code class="fe kx ky kz la b">@nestjs/passportlibrary</code>的主PassportModule，它制作所有的中间件附件和核心passport.js逻辑，类似于我们用<code class="fe kx ky kz la b">passport.use</code>函数对Express.js所做的，它只是变得更像这里的类型脚本。</p><p id="7255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">JwtStrategy</code>另一方面，我们为Nest.js添加了一个定制的可注入策略，它实际解析JWT并注册认证用户来请求上下文，类似于所有其他passport.js策略，但作为一个Nest.js模块来保留可注入模块的概念。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="4616" class="mm lc iq la b gy mn mo l mp mq">// JwtStrategy for handling Passport JWT</span><span id="4657" class="mm lc iq la b gy mr mo l mp mq">import { ExtractJwt, Strategy } from 'passport-jwt';<br/>import { PassportStrategy } from '@nestjs/passport';<br/>import { Injectable } from '@nestjs/common';<br/>import { ConfigService } from '@nestjs/config';</span><span id="25e0" class="mm lc iq la b gy mr mo l mp mq">@Injectable()<br/>export class JwtStrategy extends PassportStrategy(Strategy) {<br/>  constructor(private readonly configService: ConfigService) {<br/>    super({<br/>      jwtFromRequest: ExtractJwt.fromExtractors([<br/>        ExtractJwt.fromAuthHeaderAsBearerToken(),<br/>      ]),<br/>      ignoreExpiration: false,<br/>      secretOrKey: &lt;providing secrets from configService here&gt;,<br/>    });<br/>  }</span><span id="d456" class="mm lc iq la b gy mr mo l mp mq">async validate(payload: any) {<br/>    // validating payload here<br/>		if (&lt;user is authenticated&gt;) {<br/>			return &lt;user data here&gt;<br/>		}</span><span id="c297" class="mm lc iq la b gy mr mo l mp mq">// return 401 Unauthorized error<br/>    return null;<br/>  }<br/>}</span></pre><p id="dcdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Nest.js的基本JWT策略，但它是为了让JWT令牌来自<code class="fe kx ky kz la b">Authorization: Bearer</code>头，这对于大多数应用程序来说是可以的，特别是如果你有多个客户端使用移动应用程序，但对我们来说，拥有基于cookie的授权也更灵活，这意味着我们只是通过Cookie传递令牌，而不期望有授权头。这就给我们带来了像这样的自定义JWT提取器函数</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="1d5a" class="mm lc iq la b gy mn mo l mp mq">// JwtStrategy for handling Passport JWT</span><span id="0c6a" class="mm lc iq la b gy mr mo l mp mq">...<br/>...<br/>import { Request as RequestType } from 'express';</span><span id="21d2" class="mm lc iq la b gy mr mo l mp mq">@Injectable()<br/>export class JwtStrategy extends PassportStrategy(Strategy) {<br/>  constructor(private readonly configService: ConfigService) {<br/>    super({<br/>      jwtFromRequest: ExtractJwt.fromExtractors([<br/>        JwtStrategy.extractJWT,<br/>        ExtractJwt.fromAuthHeaderAsBearerToken(),<br/>      ]),<br/>      ignoreExpiration: false,<br/>      secretOrKey: &lt;providing secrets from configService here&gt;,<br/>    });<br/>  }</span><span id="861c" class="mm lc iq la b gy mr mo l mp mq">private static extractJWT(req: RequestType): string | null {<br/>    if (<br/>      req.cookies &amp;&amp;<br/>      'token' in req.cookies &amp;&amp;<br/>      req.cookies.user_token.length &gt; 0<br/>    ) {<br/>      return req.cookies.token;<br/>    }<br/>    return null;<br/>  }<br/>  ...<br/>  ...<br/>}</span></pre><p id="971f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到我们有一个由<code class="fe kx ky kz la b">JwtStrategy.extractJWT</code>和<code class="fe kx ky kz la b">ExtractJwt.fromAuthHeaderAsBearerToken()</code> JWT令牌提取器组成的数组，这意味着它也支持拥有一个授权头，因为<code class="fe kx ky kz la b">ExtractJwt.fromExtractors</code>的工作方式是检查所有的处理程序，并从第一个成功执行的处理程序中提取JWT令牌。</p><p id="58a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其余的逻辑与常规的JWT Passport策略相同，我们只需检查用户权限和<code class="fe kx ky kz la b">JwtStrategy.validate</code>函数中的令牌有效性，如果成功或者我们想要抛出<code class="fe kx ky kz la b">401 Unauthorized</code>错误，则返回<code class="fe kx ky kz la b">User | null</code>。请注意，validate函数是从Passport模块内部调用的，每个Nest.js Passport策略实现都必须有那个<code class="fe kx ky kz la b">validate</code>函数，类似于我们以前对Express.js使用的<code class="fe kx ky kz la b">done</code>回调。</p><h1 id="78b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">多域和基于Cookie的JWT令牌</h1><p id="c424" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如果您有像我们这样的多域结构，基于Cookie的身份验证系统有时会很有挑战性。例如，我们的主要web应用程序托管在<a class="ae kw" href="https://app.blockpulsar.com/" rel="noopener ugc nofollow" target="_blank">https://app.blockpulsar.com</a>下，API在这里<a class="ae kw" href="https://api.blockpulsar.com/" rel="noopener ugc nofollow" target="_blank">https://api.blockpulsar.com</a>下，最初，还不清楚如何使cookie设置/获取过程灵活，以便以后使用，特别是如果我们知道一些浏览器不支持通配符基于域的访问。很快我们就发现，我们只需要修正一些严格的规则，比如</p><ul class=""><li id="e559" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">UI React应用程序不应该读取委托给API的Cookies，它只需要发送一个API请求并获取所需的信息，如用户身份验证状态或用户数据</li><li id="4e38" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">为了让注销API完全控制它的cookie，UI必须发送一个API请求来删除cookie，以便让用户从浏览器中注销</li></ul><p id="ce13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有助于将事情安排到位，因此现在只有我们的API负责读写与身份验证相关的cookies，UI只与API进行通信，否则，它可能会变得非常混乱。通常，当您进行双向读写访问时，很容易出现过时的数据甚至损坏的数据，这是因为可能出错的情况越来越多。</p><h1 id="af50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从API端注销用户，而不是从UI</h1><p id="a69c" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">修正了让唯一的API负责管理认证cookie的规则，这就很容易理解，即使注销UI也不应该通过删除cookie来接触Cookie，这显然是可以做到的，但是因为API总是希望有一个即将到来的Cookie，所以它也必须验证是时候删除认证Cookie了。</p><p id="aa54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注销用户的端点非常简单，如下所示</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="e561" class="mm lc iq la b gy mn mo l mp mq">@Get('signout')<br/>async logout(@Res({ passthrough: true }) res: ResponseType) {<br/>  // Some internal checks<br/>  ...<br/>  ...<br/>  res.cookie('token', '', { expires: new Date() });<br/>  ...<br/>}</span></pre><p id="1c56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它删除了<code class="fe kx ky kz la b">token</code> cookie，并认为用户被分配出去了。这非常简单，但是它也有助于跟踪用户何时退出，或者cookie何时过期。正如你所想象的，它拥有强大的分析能力，比如平均用户会话时间等。</p><h1 id="d2c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0133" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">由于这种直观的结构和可读的代码库，Nest.js帮助我们更容易、更快地完成工作。拥有原子模块的方式我们已经能够支持许多认证类型，而不像在Nest.js之前那样使Passport.js回调复杂化。</p><p id="c52b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们的用户界面只是发送一个简单的Axios请求，而没有考虑添加自定义标题或决定如何注入用户凭据，所以JWT + Cookie对我们来说工作得更好，浏览器只是将Cookie发送到相关的https://blockpulsar.com域名，如果用户通过身份验证，它就准备好了。否则它只会拒绝有<code class="fe kx ky kz la b">401 Unauthorized</code>错误的东西，UI会轻松处理。</p><p id="6bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，如果你有一个移动应用程序，你的项目的结构会有所不同，因为你没有Cookie，所以你仍然需要通过标准的授权头发送JWT令牌，但即使这样，这个JwtStrategy Nest.js可注入类也能顺利地处理事情。</p><p id="b063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">更多内容尽在</em><a class="ae kw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ng">plain English . io</em></strong></a></p></div></div>    
</body>
</html>