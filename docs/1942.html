<html>
<head>
<title>Functional JavaScript: Classes without the ‘class’ Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript:没有“class”关键字的类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-classes-without-the-class-keyword-6e2de50a3698?source=collection_archive---------5-----------------------#2021-04-23">https://javascript.plainenglish.io/functional-javascript-classes-without-the-class-keyword-6e2de50a3698?source=collection_archive---------5-----------------------#2021-04-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/80c7cf0ac62aadc51b61c07cb411e755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8j33fQEKFweznc6EzpSKZA.png"/></div></div></figure><p id="2f60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">几年前，我开始使用迈克·博斯托克的D3 . js(<a class="ae kt" href="https://d3js.org" rel="noopener ugc nofollow" target="_blank">https://d3js.org</a>)作为一些内部图表应用程序的基础。让我印象深刻的不是令人惊叹的图形质量，而是代码风格。代码没有使用传统意义上的类。D3返回一个JavaScript对象，该对象由一组跨越实例私有数据的闭包组成。我这么说是什么意思？</p><p id="57e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们定义一个返回空地图的函数。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="b98e" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    return {}; <br/>}</span></pre><p id="504d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面看起来不怎么像，但却是最核心的积木。在我的代码中，我可以创建这个空地图的“实例”。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="76a4" class="ld le in kz b gy lf lg l lh li">const obj = MyObject();</span></pre><p id="7fd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个“对象”没有做太多，但是我们可以添加一个方法。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e946" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    function hello(){<br/>        return “Hello World”;<br/>    }<br/>    return { hello };<br/> }</span></pre><p id="1701" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在有一个只有一个方法的对象，用法如下。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="44cc" class="ld le in kz b gy lf lg l lh li">const obj = MyObject();<br/>let msg = obj.hello();</span></pre><p id="1b28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用其他方法继续扩展它。有两种方法可以给这个对象添加状态。第一，我发现最有帮助的是支持一个私有国家。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="ec7c" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    let msg = “World”;<br/>    function hello(){<br/>        return “Hello “ + msg;<br/>    }<br/>    return { hello };<br/> }</span></pre><p id="b645" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，除了返回“Hello World”之外，这没有什么作用，而且没有办法改变msg的状态。为此，我们添加了一个方法。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="4318" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    let msg = “World”;<br/>    function hello(){<br/>        return “Hello “ + msg;<br/>    }<br/>    function setMessgage( m ) {<br/>        msg = m;<br/>    }<br/>    return { hello, setMessage };<br/>}</span></pre><p id="59d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我可以通过调用对象实例上的setMessage方法来更改消息。这里发生了什么？每个函数都不是简单的函数；它是在构造函数的作用域中定义的闭包。每个闭包共享同一个“msg”变量实例。我可以根据需要向构造函数范围添加任意数量的变量，并将其作为闭包引用。</p><p id="b6c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个私有国家有一个核心财产:外部观察者看不到该状态；这是真正的隐私。允许状态的访问或突变需要一个显式的方法。对状态使用闭包意味着我可以安全地更改我的实现或者添加和删除状态，同时保留我的对象的公共接口。</p><p id="b202" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二种方法仍然使用闭包，但是闭包作用于返回的map。为此，我们首先重写我们的构造函数来定义实例对象。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f329" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    var obj = {}<br/>    obj.state = “World”;<br/>    function hello() {<br/>        return “Hello “ + obj.state;<br/>    }<br/>    obj.hello = hello;<br/>    return obj;<br/>}</span></pre><p id="405d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，我们显式地将函数hello分配给地图obj。我们也可以在使用匿名函数定义hello()函数的过程中这样做。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="1e88" class="ld le in kz b gy lf lg l lh li">function MyObject(){<br/>    var obj = {}<br/>    obj.state = “World”;<br/>    obj.hello = function() {<br/>        return “Hello “ + obj.state;<br/>    }<br/>    return obj;<br/>}</span></pre><p id="b15e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以直接改变状态，而不是在对象上使用方法。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="c6e3" class="ld le in kz b gy lf lg l lh li">const obj = MyObject();<br/>let msg1 = obj.hello(); // Returns Hello World<br/>obj.state = “Mars”;<br/>let msg2 = obj.hello(); // Returns Hello Mars</span></pre><p id="d840" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的总体偏好是私有国家形式，但也有第二种感觉更好的时候。</p><p id="8750" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照惯例，定义setters和getters很简单。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="2c8c" class="ld le in kz b gy lf lg l lh li">function MyX(){<br/>    let _x = 0;<br/>    function setX(){<br/>        _x = x;<br/>    }<br/>    function getX(){<br/>        return _x;<br/>    }<br/>    return { setX, getX }<br/>}</span></pre><p id="da1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种模式的一个好的副作用是不需要“新”关键字；这只是函数调用。</p><p id="9321" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数对象都有带参数的构造函数。我们可以在代码中添加一个简单的构造函数。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="165c" class="ld le in kz b gy lf lg l lh li">function MyX( x ){<br/>    let _x = x;<br/>    function setX(){<br/>        _x = x;<br/>    }<br/>    function getX(){<br/>        return _x;<br/>    }<br/>    return { setX, getX }<br/>}</span></pre><p id="8e0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可以按如下方式使用:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="b8fe" class="ld le in kz b gy lf lg l lh li">const obj = MyX( 1 );<br/>const x = obj.getX(); // returns the number 1</span></pre><p id="80eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设我们接受这比使用ES6类语法定义类更好。有问题；我们缺少任何形式的继承或功能组合。</p><p id="27fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面的“基本对象”,它只在构造时保存一个秘密集合。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="3cde" class="ld le in kz b gy lf lg l lh li">function MyBase( secretValue ) {<br/>    const _v = secretValue;<br/>    function getSecret(){<br/>        return _v;<br/>    }<br/>    return { getSecret }<br/>}</span></pre><p id="b47e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以定义一个组成这个秘密功能的对象。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="3241" class="ld le in kz b gy lf lg l lh li">function MyObject( x ) {<br/>    const base = MyBase( 1234 );<br/>    let _x = x;<br/>    function setX(){<br/>        _x = x;<br/>    }<br/>    function getX(){<br/>        return _x;<br/>    }<br/>    function useBase(){<br/>        return base.getSecret() * _x;<br/>    }<br/>    return {getX,setX,useBase, ...base}<br/> }</span></pre><p id="dc93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">MyObject导出方法“setX”、“getX”和“getSecret”。我们也根本不需要导出基方法。我们可以去掉…底座</p><p id="93dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也没有只拥有一个基本对象的限制！</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="ec48" class="ld le in kz b gy lf lg l lh li">return {getX,SetX,…base1, …base2, …base3 }</span></pre><p id="3e9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要注意方法屏蔽；最后一个赢了。您可能需要反转return语句。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e1ab" class="ld le in kz b gy lf lg l lh li">return {,…base1, …base2, …base3, getX,SetX }</span></pre><p id="6bc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们可以切换到使用ES6箭头功能。我们不需要一个“这个”来支持这些对象。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e3d1" class="ld le in kz b gy lf lg l lh li">const arrowObject = (x) =&gt; {<br/>    let _x = x;<br/>    const getX = () =&gt; _x;<br/>    const setX = (x) =&gt; _x = x;<br/>    return { getX, setX }; <br/> }</span></pre><p id="8fbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种策略有一些限制；例如，要在对象上重载“toString”方法，仍然需要重写原型。</p><p id="08aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过对核心语言进行一些小的添加，您可以按照下面的方式定义一个对象。不幸的是，这似乎不是JavaScript的发展方向。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="3868" class="ld le in kz b gy lf lg l lh li">// THIS CODE DOES NOT WORK ON CURRENT JAVASCRIPT<br/>const FutureObject = () =&gt; {<br/>    ... methods <br/>    const toString = () =&gt; {<br/>        return “Future Objects Rock”;<br/>    }<br/>    return { method1, method2, [[toString]] : toString }<br/>}</span></pre><p id="cb3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑到这种表达能力和现有的简洁语法，我不禁要问为什么JavaScript需要“类”语法？</p></div></div>    
</body>
</html>