<html>
<head>
<title>Functional JavaScript: Writing a Simple Command-line Game (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript:编写简单的命令行游戏(第3部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-writing-a-simple-comand-line-game-part-3-1aca1178e5b8?source=collection_archive---------7-----------------------#2021-04-28">https://javascript.plainenglish.io/functional-javascript-writing-a-simple-comand-line-game-part-3-1aca1178e5b8?source=collection_archive---------7-----------------------#2021-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2708ff0684b33a57b7d4e91b26608676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghYmj5fUUtMU18N9iEPtCg.png"/></div></div></figure><p id="4150" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的第一部分中，我开玩笑说如果这是生产代码，我将如何编写测试。嗯，测试是我所需要的；漏掉的代码中有几个错误。我们跳回第2部分的代码，为游戏中的物品添加测试。</p><p id="8b21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了执行测试，我将使用Jest测试框架(<a class="ae kt" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank">https://Jest js . io</a>)；它易于安装，有助于构建一个干净的节点环境。还有许多其他的测试框架，但是我发现Jest使用起来又快又简单。</p><p id="9955" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是将代码分解成单独的文件。</p><p id="8491" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先是物品。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="c77a" class="ld le in kz b gy lf lg l lh li">// item.js<br/>const item = function( n ) {<br/>    const _name = n;<br/>    function name() {<br/>        return _name;<br/>    }<br/>    return { name, isItem : true };<br/>}<br/><br/>module.exports = item;</span></pre><p id="ba97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来是武器。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0bac" class="ld le in kz b gy lf lg l lh li">// weapon.js<br/>const item = require( "./item");<br/>const weapon = function( n, s ) {<br/>    const _item = item( n );<br/>    const _strength = s || 1;<br/><br/>    function strength() {<br/>        return _strength;<br/>    }<br/>    return { ..._item, strength, isWeapon : true }<br/>}<br/>module.exports = weapon;</span></pre><p id="6553" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，包。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="da46" class="ld le in kz b gy lf lg l lh li">// bag.js<br/>const item = require( "./item");<br/><br/>const bag = function( n, capacity ) {<br/>    const _item = item( n );<br/>    const _size = capacity || 5; // 1 is the minimum size<br/>    const _items = {};<br/>    function stash( item ) {<br/>        if ( size() &gt;=  _size ) {<br/>            return "Your bag is full, you have to drop an item first";<br/>        }<br/>        if ( !item.isItem ) {<br/>            return "A bag can only be filled with items not " + typeof item + "'s";<br/>        }<br/>        _items[item.name()] = item;<br/>        return null;<br/>    }<br/>    function drop( itemName ) {<br/>        return fetch( itemName)<br/>    }<br/>    function fetch( itemName ) {<br/>        let item = _items[itemName]<br/>        if (item == null ) {<br/>            return null;         }<br/>        delete _items[itemName];<br/>        return item;<br/>    }<br/>    function items( ) {<br/>        return <strong class="kz io"><em class="lj">Object</em></strong>.keys( _items );<br/>    }<br/>    function size() {<br/>        return <strong class="kz io"><em class="lj">Object</em></strong>.keys( _items ).length<br/>    }<br/>   <br/>    return { ..._item, stash, drop, fetch, items, size, isBag : true}<br/>}<br/><br/>module.exports = bag;</span></pre><p id="866c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">分割成文件不是测试的要求；将测试分开有利于将来代码的可维护性。</p><p id="b686" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们为item.js编写最简单的测试</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e9e7" class="ld le in kz b gy lf lg l lh li">// item.test.js<br/>const item = require( "./item");<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "Create a weapon and assert behavior", ()=&gt;{<br/>    const myItem = item( "MyItem");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( myItem.name()).toBe("MyItem");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( myItem.isItem).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( myItem.isWeapon).toBeUndefined();<br/>});</span></pre><p id="6058" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试代码应该非常明显；一件物品做不了多少事。我们可以在这里添加一些更多的防御测试；例如，当我们不为项目指定名称时会发生什么？我们能添加一个随机的名字吗？此外，对于稍后会被捕获的不同名称的项目，没有测试。</p><p id="45bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们为武器添加一个测试。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="04eb" class="ld le in kz b gy lf lg l lh li">// weapon.test.js<br/>const weapon = require("./weapon");<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "Create a weapon and assert behavior", ()=&gt;{<br/>    const obj = weapon( "MyWeapon");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.name()).toBe("MyWeapon");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isWeapon).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isItem).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.strength()).toBe( 1 );<br/>});<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "Create a powerful weapon", ()=&gt;{<br/>    const obj = weapon( "LongSword", 5);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.name()).toBe("LongSword");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isWeapon).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isItem).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.strength()).toBe( 5 );<br/>});</span></pre><p id="64f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，这是一个相当清晰的测试用例。我们增加了一个武器强度的测试，以及当没有力量提供给建造者时会发生什么。如果您将本文中的代码与上一篇文章中的代码进行比较，您会注意到在以前的版本中没有检查默认值。这是编写测试的价值之一。</p><p id="81d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们为这个包添加一个测试。这就复杂多了。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="30f1" class="ld le in kz b gy lf lg l lh li">// bag.test.js<br/>const bag = require("./bag");<br/>const weapon = require("./weapon");<br/>const item = require("./item");<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "Create a bag and assert behavior", ()=&gt;{<br/>    const obj = bag( "MyBag");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.name()).toBe("MyBag");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isBag).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isItem).toBe( true );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.isWeapon).toBeUndefined();<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.items()).toStrictEqual( [] );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 0 );<br/>});<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "test stash", ()=&gt;{<br/>    const obj = bag( "Bag of Holding", 2);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.name()).toBe("Bag of Holding");<br/>    const paper = item( "paper");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 0 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.stash( paper )).toBeNull(); // Returns null on success, error message on fail<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.items()).toStrictEqual( ["paper"]);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( typeof obj.stash( "unknown")).toBe( "string" );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>    // Same item just succeeds<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.stash( paper )).toBeNull();<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>    const rock = item( "rock");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.stash( rock )).toBeNull();<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 2 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.items()).toStrictEqual( ["paper", "rock"]);<br/>});<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "test fetch", ()=&gt;{<br/>    const obj = bag( "Bag of Holding", 2);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.name()).toBe("Bag of Holding");<br/>    const paper = item( "paper");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 0 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.stash( paper )).toBeNull(); // Returns null on success, error message on fail<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.items()).toStrictEqual( ["paper"]);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.fetch( "paper")).toBe( paper );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 0 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.items()).toStrictEqual( []);<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.fetch( "item")).toBeNull();<br/>});<br/><br/><strong class="kz io"><em class="lj">test</em></strong>( "capacity", ()=&gt;{<br/>    const obj = bag( "Bag of little Holding", 1 );<br/>    const paper = item( "paper");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 0 );<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.stash( paper )).toBeNull();<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>    const rock = item( "rock");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( typeof obj.stash( paper )).toBe( "string");<br/>    <strong class="kz io"><em class="lj">expect</em></strong>( obj.size()).toBe( 1 );<br/>});</span></pre><p id="8c67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须检查几个箱包尺寸的边缘情况，以及当我们两次添加相同的物品时会发生什么。最初，当我们对袋子做一些事情时，我们在控制台上打印出一条消息。打印使得测试更加困难，所以我们切换到为每个调用返回已知的错误值。</p><p id="9009" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段文字比较短，但是希望有助于展示测试的价值，并使代码变得更好。</p><div class="lk ll gp gr lm ln"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-javascript-writing-a-simple-command-line-game-335ab9fcc005"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">函数式JavaScript:编写简单的命令行游戏(第1部分)</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">使用JavaScript和功能对象模型，我们为Node.js创建了一个简单命令行游戏的第一部分。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jt ln"/></div></div></a></div><div class="lk ll gp gr lm ln"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-javascript-classes-without-the-class-keyword-6e2de50a3698"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">函数式JavaScript:没有“class”关键字的类</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">了解如何在不使用class关键字的情况下使用函数式JavaScript来定义类。根据…中使用的样式</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lw l"><div class="mc l ly lz ma lw mb jt ln"/></div></div></a></div><p id="da43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lj">更多内容看plainenglish.io </em> </a></p></div></div>    
</body>
</html>