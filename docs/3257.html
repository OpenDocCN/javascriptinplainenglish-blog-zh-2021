<html>
<head>
<title>Angular Custom Form Controls With Control Value Accessor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有控件值访问器的角度自定义窗体控件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-custom-form-controls-with-control-value-accessor-90869cdf100c?source=collection_archive---------0-----------------------#2021-07-03">https://javascript.plainenglish.io/angular-custom-form-controls-with-control-value-accessor-90869cdf100c?source=collection_archive---------0-----------------------#2021-07-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ea2f454ce8b8bcfbd68784b12eccea63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ScQi1M4Hj66xbiMgA-L6w.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><blockquote class="kc kd ke"><p id="8d4b" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">在开发复杂的角度应用程序时，开发人员倾向于构建包含整个表单的大型组件，这使得高效重用变得非常困难。在这种情况下，可重用/定制组件的概念应运而生。自定义窗体控件是复杂角度应用程序中的典型模式。通常希望在输入组件中封装HTML、CSS和可访问性，以便在整个应用程序的表单中更容易使用。</p></blockquote><p id="6e3e" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在本文中，我们将探讨反应式表单的角度自定义组件的用法。为此，我们将观察内置的角度指令“<strong class="ki io"> <em class="kh">控制值访问器</em> </strong>”。</p><p id="0d50" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">控制值存取器指令</em> </strong></p><p id="cf22" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><em class="kh">控制值存取器是Angular中的内置指令，负责跟踪子字段的值，并将其反馈给父表单。</em></p><p id="9bc4" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在下面的例子中，我们将构建一个自定义的数值计数器，它包含两个增加或减少数值的按钮。此外，我们为这个计数器提供了有效的<code class="fe lh li lj lk b">min </code>和<code class="fe lh li lj lk b">max</code>值范围。</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/b3aaa206311fe64ad8c178cb6c84dca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/1*9laRzc1lvtOS77okkUie-g.gif"/></div></figure><p id="42dd" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">首先，我们创建一个名为“自定义计数器”的新角度自定义组件，作为本练习的父组件。下面是实现的定制组件。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1271" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在上面的代码片段中，你可以看到我们已经实现了<strong class="ki io"> <em class="kh"> onAdd </em> </strong>和<strong class="ki io"> <em class="kh"> onRemove </em> </strong>方法来递增和递减计数器值。此外，自定义计数器组件的模板如下所示。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7338" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">下一步是实现利用自定义计数器组件的子组件。我们将子组件命名为quantity form，并添加了内置验证器来添加<code class="fe lh li lj lk b">min </code>和<code class="fe lh li lj lk b">max</code>范围值。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1065" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">数量表单组件的模板如下，</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c415" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">理解控制值存取器</em> I <em class="kh">接口</em> </strong></p><p id="a90e" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">尽管如此，我们还没有利用<strong class="ki io"> </strong> <em class="kh">控制值访问器</em> <em class="kh">接口</em>的实际用法。因此，下一步是理解控件值访问器接口的适用性。</p><p id="97cd" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">控件值访问器接口提供了很少的方法，所有这些方法都只能在运行时由窗体模块调用，它们旨在促进窗体控件和父窗体之间的通信。</p><ul class=""><li id="f90b" class="ls lt in ki b kj kk kn ko le lu lf lv lg lw ld lx ly lz ma bi translated"><strong class="ki io"> <em class="kh"> writeValue </em> </strong>:表单模块使用此方法将值写入表单控件。</li><li id="8e7a" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld lx ly lz ma bi translated"><strong class="ki io"> <em class="kh"> registerOnChange </em> </strong>:如果一个表单的值由于用户输入而改变，我们需要将这个值报告回父表单。这是通过调用回调来完成的，该回调最初是使用registerOnChange方法向控件注册的。</li><li id="a40b" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld lx ly lz ma bi translated"><strong class="ki io"><em class="kh">register ontouched</em></strong>:当用户第一次与表单控件交互时，该控件被认为具有被触摸的状态，这对于样式化很有用。为了向父窗体报告控件被触摸，我们需要使用一个通过registerOnToched方法注册的回调。</li><li id="a396" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld lx ly lz ma bi translated"><strong class="ki io"><em class="kh">setDisabledState</em></strong>:可以使用表单API来启用和禁用表单控件。此状态可以通过setDisabledState方法传输到表单控件。</li></ul><p id="3539" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">作为下一步，让我们逐一讨论这些方法及其适用性。</p><p id="baa6" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">实现writeValue </em> </strong></p><p id="d108" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">每当父组件需要为子控件设置值时，都会在Angular forms模块中使用此方法。我们可以如下图所示。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="ace6" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">实现</em> </strong></p><p id="fb20" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">使用<strong class="ki io"> <em class="kh"> writeValue </em> </strong>方法，父组件可以将值设置给子控件。但是关键的情况是，当计数器值通过增加或减少而改变时，父组件需要知道它以获取改变的值。</p><p id="1fd1" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在那里，子组件可以使用<em class="kh">回调</em>函数通知父组件这个新值。为此，父组件需要使用<strong class="ki io"><em class="kh">registerOnChange</em></strong><em class="kh">方法</em>注册<em class="kh">回调</em>函数，如下图<em class="kh">。</em></p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="42c1" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">当调用<strong class="ki io"><em class="kh">register onChange</em></strong>方法时，改变后的值将保存到<strong class="ki io"> onChange </strong>变量中。在这个实现中，我们将<strong class="ki io"> onChange </strong>变量声明为一个函数，最初，它有一个空体。这样，如果程序由于某种原因在<strong class="ki io"><em class="kh">register onchange</em></strong>调用之前调用该函数，它将不会遇到任何错误。</p><p id="49c8" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">当我们增加或减少计数器值时，我们可以通过调用下面的<em class="kh">回调</em>函数来通知父组件。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5b1d" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">实现了</em> </strong></p><p id="1590" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">当窗体初始化时，窗体控件被认为处于未接触状态，CSS类被应用到窗体组和它的每个子控件。</p><p id="c41b" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在前面的主题中，我们设置并获取父组件的值更改。此外，我们需要通知表单控件已经被用户触摸到父组件。因此，我们使用了<strong class="ki io"> <em class="kh">套印</em> </strong>的方法。</p><p id="8294" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">如果用户确实与表单控件交互，那么这意味着<code class="fe lh li lj lk b">ng-untouched</code> CSS类将被应用于表单控件。</p><p id="ae13" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">首先我们需要注册回调函数为前面的函数如下。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="8835" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">接下来，我们需要在用户增加或减少计数器值的情况下调用这个回调。在那里，窗体控件的状态将随着被触摸而改变。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="8aa0" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">实现setDisabledState </em> </strong></p><p id="5c9b" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">我们可以使用<strong class="ki io"><em class="kh">setDisabledState</em></strong>方法来禁用或启用子窗体控件。在这里，我们将禁用变量初始化为false，并通过调用<strong class="ki io"><em class="kh">setDisabledState</em></strong><em class="kh"/>方法来更改它的值。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="5c84" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">配置ControlValueAccessor接口</em> </strong></p><p id="346b" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">这是本次实现的主要步骤，即使用<strong class="ki io"> <em class="kh"> ControlValueAccessor接口</em> </strong>将自定义计数器组件注册为依赖注入系统中的已知值访问器。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c938" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">作为配置，我们提供了<em class="kh"> NG_VALUE_ACCESSOR </em>，通过添加到已知值访问器列表来注册这个组件。注意<code class="fe lh li lj lk b">multi</code>标志设置为true，这意味着这个依赖关系提供了一个值列表，而不仅仅是一个值。现在，我们的自定义组件能够在表单中设置属性值。此外，我们的组件现在能够通过内置的<code class="fe lh li lj lk b">required </code>和<code class="fe lh li lj lk b">min</code>、<code class="fe lh li lj lk b">max </code>验证器参与表单验证过程。</p><p id="b59b" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><strong class="ki io"> <em class="kh">此外，如果我们需要为控件设置自定义验证怎么办？</em> </strong></p><p id="ca93" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">如果组件需要有自己的内置验证规则，那么我们需要使用<strong class="ki io"> <em class="kh">验证器接口</em> </strong>实现自定义计数器类。这个接口包含两个方法，</p><ul class=""><li id="5576" class="ls lt in ki b kj kk kn ko le lu lf lv lg lw ld lx ly lz ma bi translated"><strong class="ki io"> validate : </strong>该方法用于验证表单控件的当前值。每当向父窗体报告新值时，都会调用此方法。如果没有发现错误，此方法返回null。</li><li id="0fc4" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld lx ly lz ma bi translated"><strong class="ki io">registernvalidatorchange:</strong>这将注册一个回调，允许我们按需触发自定义控件<strong class="ki io">的验证</strong>。每当新的值输入到控件时，我们不需要触发这个方法，但是如果表单决定调用验证(外部的一些改变，表单初始化，等等),就需要这个方法。)</li></ul><p id="50da" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">为了便于解释，让我们假设我们已经从控件中移除了内置的<code class="fe lh li lj lk b">min </code>验证器，而不是实现一个自定义的验证器来检查计数器值是否小于零。我们可以这样做:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="9140" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">在这个代码片段中，如果计数器值有效，我们返回null，否则我们返回error对象。为此，我们不需要<strong class="ki io"><em class="kh">registernvalidatorchange</em></strong>方法，因为我们只使用控件的当前值。</p><p id="a416" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">为了完成这个实现，我们需要将我们的组件注册为<em class="kh"> NG_VALIDATORS </em>注入。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="f3b5" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">现在，我们已经构建了功能齐全的自定义控件，既能设置表单属性值，又能参与表单验证过程。最终代码如下。</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="9cff" class="mg mh in bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">摘要</h1><ol class=""><li id="9b4b" class="ls lt in ki b kj ne kn nf le ng lf nh lg ni ld nj ly lz ma bi translated">我们用<strong class="ki io"> <em class="kh">控件值访问器</em>接口实现了一个定制组件。</strong></li><li id="a07d" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld nj ly lz ma bi translated"><em class="kh">控制值取值器</em>接口包括<strong class="ki io"> <em class="kh"> writeValue </em>、<em class="kh">registernchange</em>、<em class="kh">registernoctouched</em>、<strong class="ki io"> <em class="kh"> setDisabledState </em>三种方法。</strong></strong></li><li id="c6f6" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld nj ly lz ma bi translated">其中，<strong class="ki io"> <em class="kh"> writeValue </em> </strong>方法用于父组件给子控件设置值。<strong class="ki io"><em class="kh">registerOnChange</em></strong>方法用于当输入值改变时，父子组件之间的通信。<strong class="ki io"><em class="kh">register ontouched</em></strong>方法用于在认为子窗体控件被触摸时通知父组件。</li><li id="d82d" class="ls lt in ki b kj mb kn mc le md lf me lg mf ld nj ly lz ma bi translated">然后我们通过使用<strong class="ki io"> <em class="kh">验证器接口实现了自定义验证。</em>T44】</strong></li></ol><p id="ed19" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated">感谢您的阅读！希望你会用这篇文章来消除你对角定制组件的疑虑。</p><p id="1e85" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ig bi translated"><em class="kh">更多内容请看</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kh">plain English . io</em></a></p></div></div>    
</body>
</html>