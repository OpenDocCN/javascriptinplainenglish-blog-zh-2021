<html>
<head>
<title>5 Great but Lesser-Known JavaScript Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个伟大但鲜为人知的JavaScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-great-little-javascript-features-8bc2bec6dcb6?source=collection_archive---------4-----------------------#2021-04-22">https://javascript.plainenglish.io/5-great-little-javascript-features-8bc2bec6dcb6?source=collection_archive---------4-----------------------#2021-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f80a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript中有一些并不是每个人都知道的很棒的小特性。当我第一次开始使用它们时，我惊讶于它们是如此的酷和简单。我仍然很惊讶有多少前端开发者没有意识到这些的存在！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72e0cf38fdeccbdffb17f046da3803e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7TbdYkO-pxrRP3oTlPhVg.jpeg"/></div></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="5bee" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1 —数字分隔符</h1><p id="c9eb" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">数字分隔符可用于提高可读性。考虑下面的代码行，当扫描过去时，你能很快看到它实际上是10，000吗？</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="18db" class="mj lc in mf b gy mk ml l mm mn">let duration = 10000;</span></pre><p id="7ac6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以向数字添加数字分隔符，如下所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d1ce" class="mj lc in mf b gy mk ml l mm mn">let duration = 10_000;</span></pre><p id="5e04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值不变，只是更容易阅读。</p><p id="d8db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="20c6" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2 —零化合并运算符(？？)和逻辑或(||)</h1><p id="6c2e" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">多年来，我们已经习惯于在C#等编程语言中这样做，但我们也可以在Javascript中这样做。</p><h2 id="9cd7" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">那个？？操作员</h2><p id="0bc7" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated"><a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank">？？当左边的<strong class="jm io">为空或未定义时，运算符</strong></a>返回右边的操作数。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="018d" class="mj lc in mf b gy mk ml l mm mn">leftExpr ?? rightExpr</span></pre><p id="31ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="f633" class="mj lc in mf b gy mk ml l mm mn">console.log(null ?? 'some default value');</span><span id="dff0" class="mj lc in mf b gy nc ml l mm mn">// expected output:<br/>// 'some default value'</span><span id="429f" class="mj lc in mf b gy nc ml l mm mn">let xx; // leave this undefined<br/>console.log(xx ?? 'some default value');</span><span id="8af4" class="mj lc in mf b gy nc ml l mm mn">// expected output: <br/>// 'some default value'</span></pre><p id="3897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="df41" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">||运算符</h2><p id="67c9" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated"><a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR" rel="noopener ugc nofollow" target="_blank">逻辑OR运算符</a>几乎与？？接线员。这里真正的区别是左边可以是<strong class="jm io"> null，undefined，NaN，0或者空字符串。人们倾向于用这个来设置默认值。</strong></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="b20a" class="mj lc in mf b gy mk ml l mm mn">leftExpr || rightExpr</span></pre><p id="8579" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="87bc" class="mj lc in mf b gy mk ml l mm mn">console.log(null || 'some default value');<br/>// expected output : 'some default value'</span><span id="5f3d" class="mj lc in mf b gy nc ml l mm mn">let xx; // leave this undefined<br/>console.log(xx || 'some default value');<br/>// expected output : 'some default value'</span><span id="531e" class="mj lc in mf b gy nc ml l mm mn">console.log(0 || 'some default value');<br/>// expected output : 'some default value'</span><span id="1cbf" class="mj lc in mf b gy nc ml l mm mn">console.log('' || 'some default value');<br/>// expected output : 'some default value'</span><span id="e89c" class="mj lc in mf b gy nc ml l mm mn">console.log(-1 || 'some default value');<br/>// expected output : -1</span><span id="7ff5" class="mj lc in mf b gy nc ml l mm mn">console.log('real' || 'some default value');<br/>// expected output : 'real'</span></pre><p id="0efc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="bcb5" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3-扩展语法(…) {…}</h1><p id="3b24" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">spread语法是一个强大的工具，有助于编写简洁的代码。如果你用过React，那么你可能已经遇到过这种情况。</p><h2 id="df55" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">将对象的特性提取到新特性中</h2><p id="a4e7" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">假设你有一个复杂的对象，你只对这个对象的两个属性感兴趣。您可以通过以下方式根据您想要的属性声明新的变量</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="0d3c" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">从数组中提取项目</h2><p id="a6ef" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">同样，你可以用上面的方法来析构一个对象，你也可以用数组来这样做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="ac80" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">合并对象</h2><p id="ffd3" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">您可以使用spread语法来组合对象。在jQuery中，我们通常使用$。extend()但是随着jQuery的逐渐消亡，我们可以在浏览器中直接使用这个方法。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3841" class="mj lc in mf b gy mk ml l mm mn">const destinationObject = {...baseObject, ...sourceObject};</span></pre><p id="d73a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，查看输出如何显示cat被新值“meeeeeeow”覆盖的所有默认值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="9bf2" class="mj lc in bd ld mq mr dn lh ms mt dp ll jv mu mv lp jz mw mx lt kd my mz lx na bi translated">克隆对象</h2><p id="0747" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">Javascript中的对象是引用类型。如果你设置object2 = object1，你将拥有同一个对象两次。这意味着如果您更新对象2上的属性，它也会更新对象1上的属性。</p><p id="73e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码将object2设置为object1，然后更新object2的属性并输出每个对象的值。您将看到每个对象的输出是相同的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fecf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，你想克隆这个物体？。我见过很多这样的方法，包括序列化为JSON，然后反序列化回一个对象。</p><p id="63a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用扩展语法，您现在可以像这样克隆一个对象:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="00ee" class="mj lc in mf b gy mk ml l mm mn">const object2 = {...object1};</span></pre><p id="7f3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如下所示，每个对象的输出是不同的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="b9f2" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4-可选链接(？。)</h1><p id="4361" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">我们可以用？。如果某个值为空或未定义，则停止求值并将其短路。</p><p id="bdac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，下面的代码引发一个错误(无法读取undefined的属性“sound”):</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="84b2" class="mj lc in mf b gy mk ml l mm mn">const someObject = {<br/>  cat: {<br/>    sound: 'meow'<br/>  },<br/>  dog: {<br/>    sound: 'woof'<br/>  },<br/>  duck: {<br/>    sound: 'quack'<br/>  }<br/>};</span><span id="ec78" class="mj lc in mf b gy nc ml l mm mn">console.log(someObject.duck.sound);<br/>// expected : 'quack'</span><span id="9575" class="mj lc in mf b gy nc ml l mm mn">console.log(someObject.elephant.sound);<br/>// expected : Uncaught TypeError: Cannot read property 'sound' of undefined</span></pre><p id="36a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过添加？。操作员:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="50d6" class="mj lc in mf b gy mk ml l mm mn">const someObject = {<br/>  cat: {<br/>    sound: 'meow'<br/>  },<br/>  dog: {<br/>    sound: 'woof'<br/>  },<br/>  duck: {<br/>    sound: 'quack'<br/>  }<br/>};</span><span id="9db4" class="mj lc in mf b gy nc ml l mm mn">console.log(someObject.duck?.sound);<br/>// expected : 'quack'</span><span id="7d7e" class="mj lc in mf b gy nc ml l mm mn">console.log(someObject.elephant?.sound);<br/>// expected : undefined</span></pre><p id="795d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也可以用于对象上的函数，而不仅仅是属性。为此，您需要添加。。在()之前，如下图所示</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="345b" class="mj lc in mf b gy mk ml l mm mn">myobject.someMethod?.()</span></pre><p id="c924" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我检查属性是否存在，函数调用是否存在。只有第一个会执行。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d767" class="mj lc in mf b gy mk ml l mm mn">const someObject = {<br/>  cat: {<br/>    sound: 'meow',<br/>    doSomething:() =&gt; console.log(true)<br/>  },<br/>  dog: {<br/>    sound: 'woof',<br/>  },<br/>  duck: {<br/>    sound: 'quack',<br/>    doSomething:() =&gt; console.log(true)<br/>  }<br/>};</span><span id="09bf" class="mj lc in mf b gy nc ml l mm mn">someObject.duck?.doSomething?.();<br/>// expected : true</span><span id="337f" class="mj lc in mf b gy nc ml l mm mn">someObject.dog?.doSomething?.();<br/>// expected : NOTHING</span><span id="2710" class="mj lc in mf b gy nc ml l mm mn">someObject.elephant?.doSomething?.();<br/>// expected : NOTHING</span></pre><p id="8ff9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="231a" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5-通过[括号]符号访问对象属性(和方法)</h1><p id="8302" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这已经存在很长时间了，但是我仍然和那些没有意识到他们可以使用这种技术的开发者交谈。</p><p id="3145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以通过属性名来访问属性，但是有时我们需要将正在访问的属性存储在配置中，并动态地访问它。这就是括号符号的由来。</p><p id="1580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码使用传统访问器访问对象的cat属性，然后使用括号符号访问器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1701" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以使用Object.keys获得对象的属性列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5576" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们可以用for迭代属性...在:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="b0c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你在这里学到了一些新东西，或者用不同的方式思考了一些事情。或者你已经知道这些事情了。JavaScript中有很多很酷的东西，在过去的几个版本中，它已经真正成长为一门语言。我不认为已经使用了几十年的开发者意识到了JavaScript现在所有的新特性。</p><p id="18eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nd">更多内容尽在</em><a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nd">plain English . io</em></a></p></div></div>    
</body>
</html>