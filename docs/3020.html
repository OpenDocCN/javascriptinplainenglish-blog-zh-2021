<html>
<head>
<title>Building a Simple Live Chat in React with Action Cable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React with Action Cable中建立简单的实时聊天</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-simple-live-chat-in-react-with-action-cable-8c2abf7a25b5?source=collection_archive---------6-----------------------#2021-06-19">https://javascript.plainenglish.io/building-a-simple-live-chat-in-react-with-action-cable-8c2abf7a25b5?source=collection_archive---------6-----------------------#2021-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d64b1cf10a6ec0d88cc9de5162c90614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5wPTfzddbbGh2D6h"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lunarts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Volodymyr Hryshchenko</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a57e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有什么比“来自后端的实时客户端更新”这句话更让像我这样的web开发新手心惊肉跳的了作为该领域的新手，他仍然只是刚刚涉足React state的浅水区，将另一层复杂性倒入其中的想法让我有点想吐。</p><p id="26b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但在规划我最近的一个项目，作为一种社交媒体风格的应用程序时，我知道我需要一样东西，才能让它看起来接近合法:用户之间的实时DMs。这意味着是时候直面恐惧了。</p><p id="4850" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几天后，经过几个头痛的问题和一次功能性的实时聊天，我在这里向你报告我的发现，并希望为像我一样想在应用程序中实现类似功能的初学者提供一个简单易行的路线图。让我们开始吧。</p><h1 id="c79c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">序文</h1><p id="9333" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将在前面提到的React中用Ruby on Rails后端构建这个聊天功能。在这篇博客中，我们将重点介绍如何设置Action Cable，并通过WebSockets将您的前端连接到广播，所以我假设到目前为止您已经设置好了，这样对话中的任何一个用户都可以将消息保存到后端，但是接收者需要刷新他们的页面才能看到它。作为参考，下面是我们将使用的领域模型:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/7abe558d3404c06f561a9c003269f7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAPPBzV5n4fxfjaMwjY-4A.png"/></div></div></figure><h1 id="b904" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让它发生</h1><p id="2587" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们从后端开始。我们将利用Action Cable从我们的数据库中广播一个现场直播，我们的前端可以连接并集成到state中。Action Cable预先打包了Rails，所以既然我们已经设置好了项目，我们就可以立即投入运行了。</p><p id="ac4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们要做的第一件事是在<code class="fe mg mh mi mj b">routes.rb</code>中设置一条自定义路线:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2a6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们需要为Action Cable编写的唯一路线，也是允许我们在前端和后端之间建立实时连接的特殊调料。</p><p id="3b90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步，我们将为我们的资源创建一个通道。通道类似于处理典型RESTful动作的控制器，它允许用户订阅我们的直播。让我们在终端中运行以下代码:</p><p id="0ffd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">rails g channel conversation</code></p><p id="e9af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将为我们生成一些新项目，即<code class="fe mg mh mi mj b">app</code>中的<code class="fe mg mh mi mj b">channels</code>目录，其中包含一个名为<code class="fe mg mh mi mj b">conversation_channel.rb</code>的文件。该文件包含一小段样板代码，这些代码与用户订阅或取消订阅频道时发生的事情有关。让我们给<code class="fe mg mh mi mj b">subscribed</code>方法添加几行代码:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a42c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里所做的是通过从会话的<code class="fe mg mh mi mj b">show</code>页面获取参数(想想http://www.yoursite.com/conversations/<strong class="kc io">36</strong>——在这种情况下，我们将找到ID为36的会话)，找到用户订阅的特定会话(记住:一个用户有许多会话)，然后为该会话创建一个流。接下来，我们将切换到我们的前端，并努力构建一些代码来桥接该连接。</p><p id="dde0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React项目中，我们需要做的第一件事是安装Rails Action Cable包，它将为我们提供建立实时链接所需的工具:</p><p id="b6af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">npm i @rails/actioncable</code></p><p id="0001" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在我们的对话的<code class="fe mg mh mi mj b">show</code>动作指向的组件(这里称为<code class="fe mg mh mi mj b">ConversationPage.js</code>)内部，我们将设置一个副作用，以挂钩到我们刚刚在后端创建的流中。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/ab84fa6bf71b84f25b496f53e1ccb22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_N6kQ3vtlSy1MN_PYlOZFw.png"/></div></div></figure><p id="d50c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇，这里发生了很多事！让我们一点一点地分解它。</p><p id="40b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在副作用中，我们将首先声明一个变量，该变量创建一个到我们在后端编写的Action Cable route的连接。</p><p id="f71b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将创建一个参数包，在订阅时传递给该连接。这个包包含了我们想要连接的特定频道，以及我们可能需要的任何额外的识别数据——在这个例子中是我们从特定对话的显示页面中捕获的参数(同样，想想http://www.yoursite.com/conversations/<strong class="kc io">36)。</strong></p><p id="c2f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们将编写一组三个独立的回调函数，也传递给订阅- <code class="fe mg mh mi mj b">received</code>、<code class="fe mg mh mi mj b">connected</code>和<code class="fe mg mh mi mj b">disconnected</code>。这些函数决定了当同名事件发生时会发生什么。仔细看看<code class="fe mg mh mi mj b">received</code>，你会看到我们正在获取后端通过订阅连接发送给我们的数据(即:发布到聊天中的新消息),并将其传播到state。</p><p id="9577" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在处理程序之后，我们将创建实际的订阅，并将params包和那些处理程序作为参数传入。</p><p id="0a3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们将返回一个清理函数来指示当我们的<code class="fe mg mh mi mj b">ConversationPage</code>卸载时会发生什么。基本上，我们现在所做的就是退订这个频道。</p><p id="4910" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">咻！这绝对是很多，但我们还没有完全完成。让我们再次切换到后端，增加我们的<code class="fe mg mh mi mj b">messages_controller</code>文件来处理实时连接:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e26a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将像往常一样创建一条新消息。然后，我们将通过调用我们的<code class="fe mg mh mi mj b">Conversation</code>类上的<code class="fe mg mh mi mj b">.find</code>方法并从新创建的消息中传入<code class="fe mg mh mi mj b">conversation_id</code>来找到关联的会话(记住——一条消息属于一个会话)。最后，我们将向我们的<code class="fe mg mh mi mj b">ConversationChannel</code>广播对话实例和新消息，并以传统方式呈现消息的JSON。</p><p id="14e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！我们现在已经在后端设置了广播频道，使用Action Cable和WebSockets将其连接到我们的前端，并将从feed收到的新消息传播到React中的state，以便我们可以实时看到它们。如果我们切换到我们的浏览器，在一个单独的窗口中打开第二个帐户，我们可以测试一下。如果我们从两个用户中的任何一个发送一条新消息，我们将会看到它…几乎可以工作了？不过，您可能会遇到一些奇怪的错误。来自任一用户的新消息应该立即出现在两个屏幕上的聊天中，但是您可能会注意到，其中一些消息会重叠在一起，而其他消息会导致旧消息消失或失序。</p><p id="be37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在一个屏幕上看到重复的消息，很可能是因为你更新了两次状态——一次是当新消息从<code class="fe mg mh mi mj b">received</code>回调函数返回时，另一次可能是在你的<code class="fe mg mh mi mj b">POST</code>请求向服务器发送新消息后。那也行！这只是因为您之前已经构建了通过HTTP协议与状态交互的特性。让我们清理一下我们的<code class="fe mg mh mi mj b">POST</code>请求，这样我们甚至不需要从服务器获取响应，让我们的Action Cable连接处理所有的state工作:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5e3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个bug更令人困惑——发送或接收消息的用户有时会发现存储在他们本地状态中的其他消息的顺序和可见性。为了理解这里发生了什么，让我们再来看看我们用来连接到后端广播的副作用。</p><p id="0703" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，在最后一行的依赖数组中，<code class="fe mg mh mi mj b">useEffect</code>同时监视着<code class="fe mg mh mi mj b">params.id</code>变量<em class="mn">和</em>我们的<code class="fe mg mh mi mj b">messages</code>状态数组。这是有意义的——我们希望每当我们导航到一个新的对话时，以及每当一个新消息被添加到state时，这个副作用都被触发。但是现在考虑一下这个<code class="fe mg mh mi mj b">useEffect</code>为我们处理的一切:当然，它最明显的功能是从服务器接收新数据，并把它放入状态，但是这个钩子<em class="mn">也</em>首先负责创建我们对频道的订阅。这意味着每次一个新的消息被添加到<code class="fe mg mh mi mj b">messages</code>数组中，效果会再次激发并创建一个全新的订阅！这解释了不可靠的排序问题和消失的数据——我们的应用程序基本上被对依赖数组的不断更新所创建的所有新订阅搞糊涂了。</p><p id="a313" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过使用另一个React钩子来解决这个问题:<code class="fe mg mh mi mj b">useRef</code>。简而言之，我们可以将信息传递到<code class="fe mg mh mi mj b">useRef</code>中，存储到一个在渲染之间不会改变的状态中。但是如果信息<em class="mn">由于某种原因</em>改变了，<code class="fe mg mh mi mj b">useRef</code>也会阻止重新渲染到其他组件。我们可以在变量上调用<code class="fe mg mh mi mj b">.current</code>来检查它的当前状态。利用这个工具，我们可以在每次效果触发时创建新的连接之前，先检查连接是否已经存在。让我们在组件范围内用<code class="fe mg mh mi mj b">useRef</code>声明我们的电缆，然后重构一些东西:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/e42d2814d7f4b3eb70dcc20eca9b20e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdJU-xnUdcqVj-Mx4yy77A.png"/></div></div></figure><p id="55af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该可以了！有了这些改变，新消息应该在对话中为两个用户实时有序地呈现！</p><h1 id="604d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="180c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Action Cable、WebSockets、channels……这些术语对于新手来说可能听起来很可怕，但是一旦你理解了在引擎盖下发生了什么，它们就可以用来构建令人印象深刻的交互功能，这些功能可以真正将你的应用程序提升到一个新的水平。上述指南实际上只涵盖了该技术最基本的方面和实现。因此，如果您有兴趣了解更多，我强烈建议您深入研究文档，看看到底有什么可能！这些都是强大的工具，是对任何web开发人员工具包的巨大补充。</p><p id="c9e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>