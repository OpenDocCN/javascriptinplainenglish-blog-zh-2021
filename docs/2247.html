<html>
<head>
<title>Stop Writing Ugly JavaScript Fetch Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止编写难看的JavaScript获取函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-your-js-fetch-not-look-so-ugly-f45c89f8bc3a?source=collection_archive---------0-----------------------#2021-05-11">https://javascript.plainenglish.io/how-to-make-your-js-fetch-not-look-so-ugly-f45c89f8bc3a?source=collection_archive---------0-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ec2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是典型的JavaScript <code class="fe ki kj kk kl b">fetch()</code>函数调用的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="cd92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们大幅改进它之前，让我们先来分析一下是什么让它变得如此丑陋。</p><p id="56b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许最令人震惊的是第一个<code class="fe ki kj kk kl b">.then()</code>声明。我们有一个匿名的内部函数，它只执行一个动作，从初始的<code class="fe ki kj kk kl b">fetch()</code>调用中获取响应，并转换成一个更容易使用的JSON对象。</p><p id="7fa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以立即看到可读性方面的所有问题。第一，没干。每当从服务器获取数据时，您几乎总是需要执行这个操作，那么为什么我们在这个<code class="fe ki kj kk kl b">fetch()</code>块的中间编写代码，而不是用一个可重用的方法呢？</p><p id="3892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然匿名内部函数在JavaScript和其他语言中很常见，但确实应该谨慎使用。“匿名”或“内部”这两个词没有任何可读性。匿名？为什么不想告诉我这是什么功能？内心？你为什么要隐藏功能？另外，我们已经在代码中加入了这个动作的核心部分。</p><p id="118f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的<code class="fe ki kj kk kl b">.then()</code>通常是你实际想要对从数据库中获取的数据做的事情。也就是说，这是您想要对数据执行的<em class="kt">操作</em>。等等，函数不就是我们要对数据执行的操作吗？是的。</p><p id="6446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，关于<code class="fe ki kj kk kl b">fetch()</code>电话通常是如何写的已经说得够多了，让我们开始用更好的方式来写吧。</p><p id="8926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以做的第一个改进是将第一个<code class="fe ki kj kk kl b">then()</code>的样板动作放入一个可重用的函数中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="b3af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数需要知道的主要事情是一个<code class="fe ki kj kk kl b">fetch()</code>调用总是会从某种类型的服务器返回一个响应。您可以将这个响应作为参数传递给函数(这就是我们代码中的“response”变量)。</p><p id="c77a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从那里，我们简单地在响应上调用<code class="fe ki kj kk kl b">.json()</code>函数，并返回该函数调用的结果，以JSON格式给出我们可以根据需要使用的服务器响应。</p><p id="5886" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>我们没有在<code class="fe ki kj kk kl b">.then()</code>中包含<code class="fe ki kj kk kl b">()</code>，因为我们没有<em class="kt">调用</em> <code class="fe ki kj kk kl b">getResponse()</code>，我们仅仅是<em class="kt">告诉</em> JavaScript当它准备好的时候要去哪个函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="f7e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了数据，我们可以根据需要在另一个函数中处理它。</p><p id="e0c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数应该通过它的名字清楚地表明它在做什么。出于举例的目的，我们称之为<code class="fe ki kj kk kl b">processJSON()</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="9265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在<code class="fe ki kj kk kl b">getResponse()</code>之后的<code class="fe ki kj kk kl b">.then()</code>中调用这个函数时，我们将被传递这个函数返回的JSON对象。所以我将<code class="fe ki kj kk kl b">processJSON()</code>的参数变量命名为“json ”,以提醒我们所拥有的数据。当然，您可以随意命名所有参数，并且可能希望将其命名为与您的应用程序或您正在处理的数据更相关的名称。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="e6eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇，我们的<code class="fe ki kj kk kl b">fetch()</code>现在看起来好多了！我们不仅没有在代码中间展开函数，而且更加枯燥，因为我们可以在任何需要的时候调用<code class="fe ki kj kk kl b">fetch()</code>块中的<code class="fe ki kj kk kl b">getResponse()</code>和<code class="fe ki kj kk kl b">processJSON()</code>。我们还对可读性做了很大的改进。我们现在拥有的实际上是伪代码；它读起来和实际发生的事情非常相似。"获取数据，然后得到响应，然后处理JSON . "</p><p id="ecd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有人可以确切地知道我们的程序是如何工作的，而根本不需要看到实现细节。这才是真正的可读性。</p><p id="fd59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然我们的<code class="fe ki kj kk kl b">fetch()</code>语句看起来确实更好，但是我们仍然传递了硬编码的URL。它不仅看起来很糟糕，而且如果我们对后端进行更改，它可能会崩溃，我们必须找到它的每个实例来修复它。我想你知道这是怎么回事。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="25ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将获取路径保存在一个名为following RESTful conventions的常量中。我们使代码更新变得更加容易，并使我们的获取更加干净:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="3077" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谈谈从零到英雄！我们最初的代码是杂乱的，不干燥的，可读性不是很好。我们在这三个方面都有了很大的改进。那，就是你怎么写一个<code class="fe ki kj kk kl b">fetch()</code>。</p><h2 id="c688" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">但是发帖打补丁呢？</h2><p id="3822" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">你说得对，用<code class="fe ki kj kk kl b">fetch()</code>调用写入数据库会变得相当混乱，主要是因为需要用<code class="fe ki kj kk kl b">fetch()</code>请求传递一个http对象(下面代码片段中的第3–8行)。</p><p id="040e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一扫而光。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="18b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将编写一个名为<code class="fe ki kj kk kl b">writeServer()</code>的可重用函数，它将为fetch调用生成并返回http请求。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="1d24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">writeServer()</code>的两个参数action和data允许我们对POST、PATCH和DELETE请求使用相同的函数。当我们调用函数(动作)时，我们简单地指定http动词，并包括我们正在发布或修补的数据。</p><p id="85d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果没有，例如删除请求，“数据”默认设置为空对象。作为一个重要的提醒，您需要在fetch调用中包含括号()(下面的第2行)。</p><p id="a41d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们<em class="kt">调用</em>的<code class="fe ki kj kk kl b">writeServer()</code>函数来获取它的返回值，并将其作为参数传递给我们的<code class="fe ki kj kk kl b">fetch()</code>调用。如果你将变量传递给<code class="fe ki kj kk kl b">writeServer()</code>，这就更容易记住了。</p><p id="b824" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在数据库中创建新电影的fetch调用可能如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Yeeeaah.</figcaption></figure><p id="a4f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是枯燥的，可读的，灵活的。比我们开始的地方有了巨大的进步。</p><p id="1a6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kt">更多内容请看</em><a class="ae lw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>