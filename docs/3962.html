<html>
<head>
<title>LeetCode Algorithm Challenges: Single Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:单一数字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenges-single-number-302e14e08a66?source=collection_archive---------2-----------------------#2021-08-09">https://javascript.plainenglish.io/leetcode-algorithm-challenges-single-number-302e14e08a66?source=collection_archive---------2-----------------------#2021-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="45d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题:</strong> <em class="ki">给定一个</em> <strong class="jm io"> <em class="ki">非空</em> </strong> <em class="ki">整数数组</em> <code class="fe kj kk kl km b"><em class="ki">nums</em></code> <em class="ki">，每个元素除一个外都出现两次。找到那个单身的。</em></p><p id="3642" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您必须实现一个具有线性运行时复杂性的解决方案，并且只使用恒定的额外空间。</p><p id="4872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例1: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="f1cf" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> nums = [2,2,1]<br/><strong class="km io">Output:</strong> 1</span></pre><p id="6a22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例2: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="0466" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> nums = [4,1,2,1,2]<br/><strong class="km io">Output:</strong> 4</span></pre><p id="5917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例3: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="867f" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> nums = [1]<br/><strong class="km io">Output:</strong> 1</span></pre></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="3467" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">线性运行时间复杂度</h1><p id="2023" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">理解一个任务很重要，所以我们需要理解什么是线性运行时复杂度。</p><p id="2445" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先来看看时间复杂度的定义。</p><blockquote class="mk ml mm"><p id="6e5d" class="jk jl ki jm b jn jo jp jq jr js jt ju mn jw jx jy mo ka kb kc mp ke kf kg kh ig bi translated">在<a class="ae mq" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中，<strong class="jm io">时间复杂度</strong>是<a class="ae mq" href="https://en.wikipedia.org/wiki/Computational_complexity" rel="noopener ugc nofollow" target="_blank">计算复杂度</a>，它描述了运行一个<a class="ae mq" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>所需的计算机时间量。时间复杂度通常通过计算算法执行的基本操作的数量来估计，假设每个基本操作花费固定的时间来执行。因此，所花费的时间量和算法执行的基本运算的数量最多相差一个<a class="ae mq" href="https://en.wikipedia.org/wiki/Constant_factor" rel="noopener ugc nofollow" target="_blank">常数因子</a>。<a class="ae mq" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Time_complexity</a></p></blockquote><p id="f917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从短期来看，这是运行一个函数所需要的时间。因此，线性可能意味着以线性方式遍历数据的每个元素。先说<a class="ae mq" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank">维基百科的定义</a>。</p><blockquote class="mk ml mm"><p id="0e2f" class="jk jl ki jm b jn jo jp jq jr js jt ju mn jw jx jy mo ka kb kc mp ke kf kg kh ig bi translated">如果一个算法的时间复杂度为<em class="in"> O </em> ( <em class="in"> n </em>)，则称该算法花费<strong class="jm io">线性时间</strong>，或<em class="in"> O </em> ( <em class="in"> n </em>)时间。通俗地说，这意味着运行时间最多随着输入的大小线性增加。更准确地说，这意味着存在一个常数<em class="in"> c </em>，使得对于大小为<em class="in"> n </em>的每个输入，运行时间最多为<em class="in"> cn </em>。例如，如果添加时间是常数，或者至少是由常数限定的，那么将列表的所有元素相加的过程需要与列表长度成比例的时间。在算法必须顺序读取其整个输入的情况下，线性时间是可能的最佳时间复杂度。</p></blockquote><p id="102b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kj kk kl km b">For loop</code>将是，其中检查数组的每个元素将是线性查询的一个例子。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="dad3" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">解决办法</h1><p id="d963" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">正如我上面提到的，我们将使用for循环来解决这个问题，因为我们需要找到一个不重复的数组元素。但是首先，让我们通过检查我们的数组是否只有一个元素来简化我们的生活。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="2968" class="kv kw in km b gy kx ky l kz la">if (nums.length===1) {</span><span id="33f4" class="kv kw in km b gy mr ky l kz la">    return nums[0]</span><span id="9bd8" class="kv kw in km b gy mr ky l kz la">}</span></pre><p id="62ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将需要创建<code class="fe kj kk kl km b">result</code>变量。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="c801" class="kv kw in km b gy kx ky l kz la">let result = 0;</span></pre><p id="12d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将使用<code class="fe kj kk kl km b">forEach</code>循环，因为我们知道我们需要检查数组的每个元素。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="90e2" class="kv kw in km b gy kx ky l kz la">nums.forEach(element =&gt; {</span><span id="db92" class="kv kw in km b gy mr ky l kz la">   result = result ^ element</span><span id="6e53" class="kv kw in km b gy mr ky l kz la">});</span></pre><p id="13e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决这一挑战的循环部分是<code class="fe kj kk kl km b">result = result ^ element</code>，因此我们将更深入地研究它。<code class="fe kj kk kl km b">^</code>代表异或。</p><blockquote class="mk ml mm"><p id="8ca6" class="jk jl ki jm b jn jo jp jq jr js jt ju mn jw jx jy mo ka kb kc mp ke kf kg kh ig bi translated"><a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR" rel="noopener ugc nofollow" target="_blank">按位XOR运算符(^)在每个位位置返回1，其中任一操作数(但不是两个操作数)的对应位为1。</a></p></blockquote><figure class="kn ko kp kq gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/3ed79ca528059416609afb4349f9457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/format:webp/1*AMSlFJbv_GF5s-pV2ha61A.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk"><a class="ae mq" href="https://en.wikipedia.org/wiki/Exclusive_or#Truth_table" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Exclusive_or#Truth_table</a></figcaption></figure><p id="e234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">XOR对其整数参数的每一位执行布尔异或运算，并通过查看上面的XOR真值表:其中一个或另一个为真，但不是两个都为真。因此，如果数组中除了一个值之外的所有值都是唯一的，最终，每个重复的值将在按位运算期间相互抵消，我们将得到一个唯一的非重复值。</p><p id="1296" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以直接返回<code class="fe kj kk kl km b">result</code>。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="3d03" class="kv kw in km b gy kx ky l kz la">return result;</span></pre></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="0f67" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">密码</h1><figure class="kn ko kp kq gt mt"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><p id="9bc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请在以下社交网络上查看我，我很乐意收到您的来信！——<a class="ae mq" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="ki">LinkedIn</em></a><em class="ki">，</em> <a class="ae mq" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> GitHub </em> </a>，<a class="ae mq" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="ki">脸书</em> </a> <em class="ki">。</em></p><p id="5b8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容看</em><a class="ae mq" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>