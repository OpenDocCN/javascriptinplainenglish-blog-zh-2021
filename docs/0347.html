<html>
<head>
<title>Zero to Hero: Chrome Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到英雄:Chrome扩展</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/zero-to-hero-chrome-extensions-4060520daf59?source=collection_archive---------8-----------------------#2021-01-20">https://javascript.plainenglish.io/zero-to-hero-chrome-extensions-4060520daf59?source=collection_archive---------8-----------------------#2021-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cb55" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以编程方式挖掘浏览器的全部功能！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e4c9ec127490a90ea194b4dfb3aefa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*enWWDa1ktUBcRt-2"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@christianw" rel="noopener ugc nofollow" target="_blank">Christian Wiediger</a> on <a class="ae ks" href="https://unsplash.com/photos/zhZydTyNMPg" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e138" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">介绍</h1><p id="82cd" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在我的编码之旅中，我尝试了各种技术，并致力于移动应用程序和web应用程序。直到最近，我才开始学习Chrome扩展，我必须说，它们被低估了。它们允许开发人员深入利用浏览器的功能。在本文中，我将首先简要介绍Chrome扩展的背景信息，然后我们将一起构建一个扩展。</p><h1 id="2941" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">议程</h1><ul class=""><li id="51d4" class="mh mi in ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">背景概念</li><li id="dc47" class="mh mi in ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">扩建部分</li><li id="f482" class="mh mi in ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">下载扩展</li></ul><h1 id="4080" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">背景概念</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ff765ed6e5c528158322714ce97ad21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IlWR_t-zV1r0L6Jm"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@charlesdeluvio" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae ks" href="https://unsplash.com/photos/leqrylJNYUQ" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b0e" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">Chrome扩展提供了一种简单的方法来直接访问Google Chrome中的各种功能。在本节中，我们将浏览组成扩展的不同部分:弹出窗口、内容脚本和后台脚本。之后，我们将介绍消息传递，这是不同部分之间的一种通信方式。</p><p id="bec2" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">弹出</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d9d9ea075508e45c45a38aa57ee7850f.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*lTfXUnI4v05AQF-IltDY9g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of Grammarly Chrome Extension Popup</figcaption></figure><p id="838f" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">简单来说，Chrome扩展的弹出窗口就是在工具栏中点击扩展图标时呈现的HTML。比如上图，点击语法图标后，语法弹出下拉可见。</p><p id="9eb2" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">此外，Chrome扩展可以分为浏览器动作扩展或页面动作扩展。在页面操作扩展中，该扩展仅在用户访问特定页面时可用:工具栏中的扩展图标仅在特定页面上启用。但是，在浏览器操作扩展中，无论网页如何，该扩展都是可用的:默认情况下，工具栏中的扩展图标将对所有网页启用。</p><p id="fc93" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">内容脚本</strong></p><p id="da35" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">根据谷歌Chrome开发者文档，内容脚本是可以在网页环境中运行的文件(<a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/content_scripts/" rel="noopener ugc nofollow" target="_blank">内容脚本</a>)。内容脚本可以访问和操作它们被注入的网页的HTML。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by Author</figcaption></figure><p id="cfa3" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">请注意，在使用Gyazo扩展截图后，屏幕右侧会出现一个通知。本质上，内容脚本是将通知的HTML插入到用户当前所在的网页中。</p><p id="0102" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">后台脚本</strong></p><p id="0633" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">它们是用户在与Chrome交互时可以创建的许多事件和动作。例如，用户可以创建新的书签，或者导航到新的标签。后台脚本可以监听从用户交互中创建的事件。后台脚本功能强大，因为开发人员可以运行自定义回调来响应浏览器事件。</p><p id="9496" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">消息传递</strong></p><p id="05b4" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">Chrome扩展的全部功能通过消息传递得以释放。提供一点背景知识，Chrome扩展的每个组件都有其局限性。例如，内容脚本不能监听和响应用户与浏览器的交互，后台脚本不能访问用户导航到的网页的内容。消息传递允许Chrome扩展的不同组件相互通信。</p><p id="6c9f" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">考虑下面的用例。假设我们的Chrome扩展在用户每次创建新书签时都会显示一个祝酒词。</p><p id="6441" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">由于它们的局限性，如果我们仅仅局限于背景脚本或内容脚本的范围，就不可能创建这个流。然而，通过消息传递，我们可以在用户创建书签时从后台脚本向内容脚本发送消息。从那里，内容脚本可以通过在网页中插入一段祝酒词来对消息做出反应。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/07960293d6809443047c544afe61e623.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5jlCXREABzhCBVLINZAnEg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><p id="a214" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在本文中，我将进一步向您展示如何利用消息传递的力量。</p><h1 id="0568" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">扩建部分</h1><p id="72e8" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">既然我们已经获得了关于Chrome扩展的高级背景信息，是时候实现我们所学的了。查看我们将构建的演示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by Author</figcaption></figure><p id="3028" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">最终产品将是一个简单的Chrome扩展，在用户单击上下文菜单选项后，它将在页面上显示一个toast。用户还将能够更改toast消息。</p><p id="247c" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">我们开始吧！</strong></p><p id="0087" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">让我们从创建文件夹结构开始</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="d2ad" class="nk ku in ng b gy nl nm l nn no">- popup/</span><span id="12b5" class="nk ku in ng b gy np nm l nn no">    - popup.js</span><span id="0cd0" class="nk ku in ng b gy np nm l nn no">    - popup.html</span><span id="141b" class="nk ku in ng b gy np nm l nn no">- background.js</span><span id="2f33" class="nk ku in ng b gy np nm l nn no">- content.js</span><span id="7e24" class="nk ku in ng b gy np nm l nn no">- content.css</span><span id="3c6b" class="nk ku in ng b gy np nm l nn no">- manifest.json</span></pre><p id="4a94" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">考虑一下<code class="fe nq nr ns ng b">manifest.json</code>。<code class="fe nq nr ns ng b">manifest.json</code>文件是您的扩展的配置文件。它定义了你的扩展。它可以详细说明后台脚本和内容脚本的位置，并提供基本信息，如扩展的名称和描述。如果你以前用过Node.js，它相当于<code class="fe nq nr ns ng b">package.json</code>。</p><p id="b070" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">以下是我们的Show Toast扩展的配置:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nc l"/></div></figure><p id="4659" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">让我们从<code class="fe nq nr ns ng b">browser_action</code>开始一步步走过去。</p><p id="cae2" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">如果<code class="fe nq nr ns ng b">manifest.json</code>中存在<code class="fe nq nr ns ng b">browser_action</code>字段。这意味着Chrome扩展是可用的，不管用户在哪个URL或网页上。扩展工具栏中的扩展图标将始终启用，以便用户与之交互。而且，通过<code class="fe nq nr ns ng b">default_popup</code> <em class="nu"> </em>字段，我们可以为弹出框指定HTML文件的位置。</p><p id="06a3" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">转到<code class="fe nq nr ns ng b">background</code>，我们注意到有一个<code class="fe nq nr ns ng b">scripts</code>字段。这是我们指明后台脚本位置的地方。我们还通过将<code class="fe nq nr ns ng b">persistent</code>设置为false来表明我们的后台脚本不是持久的。根据Google Chrome开发者文档，在大多数情况下，保持后台脚本的非持久性可能是有益的，因为这样消耗的资源更少(<a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/background_pages/#persistentWarning" rel="noopener ugc nofollow" target="_blank">事件管理</a>)。</p><p id="42b0" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">放到内容脚本上。内容脚本直接注入网页。请记住，<code class="fe nq nr ns ng b">matches</code> <em class="nu"> </em>字段是一个URL数组，表示内容脚本可以插入的有效网页。<code class="fe nq nr ns ng b">run_at</code>字段决定何时注入内容脚本。根据Google Chrome开发者文档，最好将<code class="fe nq nr ns ng b">run_at</code>的值设置为<code class="fe nq nr ns ng b">document_idle</code> ( <a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/content_scripts/" rel="noopener ugc nofollow" target="_blank">内容脚本</a>)。<code class="fe nq nr ns ng b">js</code> <em class="nu"> </em>和<em class="nu"> </em> <code class="fe nq nr ns ng b">css</code> <em class="nu"> </em>字段对应于内容脚本的路径和内容脚本引用的样式表。</p><p id="0541" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">最后，我们到了<code class="fe nq nr ns ng b">permissions</code>部分。<code class="fe nq nr ns ng b">permissions</code> <em class="nu"> </em>字段是<em class="nu"> </em>，我们在这里声明我们将在Chrome扩展中使用的各种API。首先，我们需要利用Chrome存储API来存储用户想要在toast上显示的消息。此外，我们还需要使用上下文菜单API。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/84ee792e02326bf401c180353a2aa83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*7EAEO4MSfAmSJQjKfN3Wew.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by author</figcaption></figure><p id="8268" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">正如你在上面的图片中看到的，要获得我们的扩展项，<strong class="ln io">显示Toast！</strong>，在右键菜单中，我们必须通过上下文菜单API将我们的项目添加到菜单中。</p><p id="9b57" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">现在让我们码出</strong> <code class="fe nq nr ns ng b">background.js</code></p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="3acd" class="nk ku in ng b gy nl nm l nn no">chrome.runtime.onInstalled.addListener(() =&gt; {<br/>    chrome.contextMenus.create({<br/>        id: "show-toast",<br/>        title: "Show Toast!",<br/>        contexts: ["all"]<br/>    });</span><span id="2190" class="nk ku in ng b gy np nm l nn no">// default message when chrome extension is installed for the first time<br/>    chrome.storage.sync.set({message: "Hello! This is the default greeting!"});<br/>});</span></pre><p id="62b0" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在上面的代码片段中，我们为安装扩展添加了一个事件处理程序。在事件处理程序的回调中，我们首先将扩展项添加到右键菜单中。然后，我们与Chrome存储API交互，为<code class="fe nq nr ns ng b">message</code> <em class="nu"> </em>字段设置默认值。澄清一下，这个字段的值是将要显示的实际toast消息。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="8b12" class="nk ku in ng b gy nl nm l nn no">chrome.contextMenus.onClicked.addListener(({menuItemId}) =&gt; {<br/>    if (menuItemId === "show-toast") {<br/>        chrome.storage.sync.get(["message"], ({message}) =&gt; {<br/>            sendMessage(message);<br/>        });<br/>    }<br/>});</span></pre><p id="9204" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">现在，每当单击一个菜单项时，我们就为它注册一个事件处理程序。实际上，每次打开右键菜单并选择菜单项时，都会触发该事件处理程序。在事件处理程序中，我们断言被点击的项是我们的扩展项(<code class="fe nq nr ns ng b">menuItemId</code>看起来很熟悉，不是吗)。如果断言为真，我们从Chrome存储器中加载<code class="fe nq nr ns ng b">message</code>键的值，并将其传递给一个名为<code class="fe nq nr ns ng b">sendMessage</code>的神秘函数。让我们创建这个函数！</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="5c2a" class="nk ku in ng b gy nl nm l nn no">const sendMessage = (toastMessage) =&gt; {<br/>    chrome.tabs.query({currentWindow:true, active:true}, (tabs) =&gt; {<br/>        const tab = tabs[0];<br/>        chrome.tabs.sendMessage(tab.id, {<br/>            toastMessage: toastMessage<br/>        });<br/>    });<br/>}</span></pre><p id="49b6" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在这个函数中，我们将使用消息传递将<code class="fe nq nr ns ng b">toastMessage</code>发送到内容脚本，以便它可以显示toast。请记住，后台脚本是独立于网页的上下文运行的，这意味着它不能直接操纵网页来显示吐司。</p><p id="a9e7" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">我们首先通过<code class="fe nq nr ns ng b">chrome.tabs.query</code>找到活动标签，即用户所在的标签。然后，我们可以通过<code class="fe nq nr ns ng b">chrome.tabs.sendMessage</code>向该选项卡发送消息。因此，通过这个函数，我们可以向用户当前选项卡上的内容脚本发送消息。在这种情况下，消息的内容存储toast消息。</p><p id="a9f2" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">我所经历的可能听起来令人不知所措，但一旦我们建立了内容脚本，它就会变得更加清晰。</p><p id="eee8" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">总的来说，<code class="fe nq nr ns ng b">background.js</code>应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code for the background script</figcaption></figure><p id="79fc" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">让我们编写内容脚本或</strong> <code class="fe nq nr ns ng b">content.js</code></p><p id="bf19" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">让我们从停止的地方开始，创建一个消息监听器，这样我们就可以捕获后台脚本将发送给我们的消息。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="623b" class="nk ku in ng b gy nl nm l nn no">chrome.runtime.onMessage.addListener((request, _, sendResponse) =&gt; {<br/>        if("toastMessage" in request){<br/>          showToast(request.toastMessage); <br/>           sendResponse({status: "OK"});<br/>        }<br/>    else{<br/>           sendResponse({status: "FAIL", <br/>            message: "toastMessage not provided"});           <br/>        }<br/>});</span></pre><p id="858d" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在上面这段代码中，我们添加了一个每当消息被发送到内容脚本时的处理程序。函数参数<code class="fe nq nr ns ng b">request</code> <em class="nu"> </em>对应的是我们发送消息时在后台脚本中提供的消息内容。总之，通过发送和侦听消息，我们可以在后台脚本和内容脚本之间进行通信。但是，我们不要忘记制作<code class="fe nq nr ns ng b">showToast</code>函数。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="1e16" class="nk ku in ng b gy nl nm l nn no">const showToast = (message) =&gt; {<br/>  <br/>   //append html element to webpage<br/>    let toastContainer = document.createElement("div");<br/>    toastContainer.innerText = message;<br/>    toastContainer.className = "toast";<br/>    document.body.appendChild(toastContainer);<br/>  <br/>   //remove element after 2 seconds<br/>    setTimeout(()=&gt;{<br/>        document.body.removeChild(toastContainer);<br/>    }, 2000);<br/>};</span></pre><p id="fa3c" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">这里是<code class="fe nq nr ns ng b">content.css</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The stylesheet referenced in the content script</figcaption></figure><p id="4a6b" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">在上面的函数中，我们将简单地创建一个toast div，并将该div附加到网页的正文中。两秒钟后，我们将从网页中删除该元素。制作吐司就这么简单。</p><p id="7a2f" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">这是<code class="fe nq nr ns ng b">content.js</code>最后的样子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Code for the content script</figcaption></figure><p id="0bf4" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">我们现在有了一个事件流，从用户单击菜单中的扩展项开始，到网页上显示的toast结束。唯一剩下的事情是，我们必须允许用户定制他们的祝酒词。</p><p id="f518" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">让我们通过创建弹出窗口来完成这个扩展！</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The HTML of the popup</figcaption></figure><p id="56d3" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">上面的HTML将代表弹出窗口的用户界面。它将被放入弹出文件夹下的popup.html文件中。我们有输入，用户可以编辑toast消息的地方，和提交按钮，它将用于更新Chrome存储中的消息。</p><p id="7403" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">让我们进入<code class="fe nq nr ns ng b">popup.js</code>来制作功能。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="7c8f" class="nk ku in ng b gy nl nm l nn no">const onHandleSubmit = () =&gt; {<br/>    const newMessage = document.getElementById("message").value;<br/>    chrome.storage.sync.set({message: newMessage}, () =&gt; {<br/>        console.log("Finished Setting!");<br/>    });<br/>}</span></pre><p id="fc00" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">这是提交按钮的<code class="fe nq nr ns ng b">onclick</code>处理程序。我们首先检索输入的值，然后将Chrome存储器中的<code class="fe nq nr ns ng b">message</code>字段更新为该值。我们可以在弹出窗口中使用Chrome存储API，这很酷。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="8728" class="nk ku in ng b gy nl nm l nn no">const setupHandlers = () =&gt; {<br/>    const submitButton = document.getElementById("submit");<br/>    submitButton.onclick = onHandleSubmit;<br/>}</span></pre><p id="9ecd" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">我们可以使用上面的函数设置提交按钮的<code class="fe nq nr ns ng b">ondlick</code>处理程序。</p><p id="7cdb" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">最后，我们不能忘记将输入元素的值填充到Chrome存储器中存储的初始消息值中。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="3e9d" class="nk ku in ng b gy nl nm l nn no">chrome.storage.sync.get(["message"], ({message}) =&gt; {<br/>    const messageInput = document.getElementById("message");<br/>    messageInput.value = message;<br/>    setupHandlers();<br/>});</span></pre><p id="7d83" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">一旦我们填充了这个值，我们将通过<code class="fe nq nr ns ng b">setupHandlers</code>函数注册提交按钮的<code class="fe nq nr ns ng b">onclick</code>处理程序。</p><p id="f439" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">添加这些内容后，<code class="fe nq nr ns ng b">popup.js</code>文件应该如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The code for the popup</figcaption></figure><p id="4663" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">维奥拉。扩展现在完成了！</p><p id="a8fb" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">最后一件事，让我们在浏览器上安装扩展，这样我们就可以使用它了。</p><h1 id="dd17" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">下载扩展</h1><p id="466b" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">首先，通过在搜索栏中键入chrome://extensions导航到以下网页。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/85b3b1d53b940750d1ffd3a35c9d34c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKcp8W6SgJZcRTL5SFzutw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><p id="2edd" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">然后，点击“加载解压缩”按钮。导航到manifest.json文件所在的文件夹，并选择该文件夹。如果没有出现错误，现在应该会弹出扩展。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/2d0c42181e31860a2335403a402c030d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nLdmErCzogZ_sOeyARKBg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz nc l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Gif by <a class="ae ks" href="https://giphy.com/channel/runnerspace" rel="noopener ugc nofollow" target="_blank"><strong class="ak">@runnerspace</strong></a></figcaption></figure><p id="cd7b" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">那是一场马拉松！</p><h1 id="c2fd" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结论</h1><p id="db04" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在本文中，我们探索了构成Chrome扩展的各种组件，并通过创建我们的Chrome扩展来应用我们的知识。虽然这是一个基本的扩展，但我的目标是展示我们如何实现这些重要的概念，以便我们在未来构建更复杂的扩展。如果你喜欢这种类型的文章，并且还有更多的剩余资源，我推荐你看看<a class="ae ks" href="https://medium.com/swlh/build-a-dynamic-portfolio-with-the-github-api-6d74081e5164" rel="noopener">用Github API </a>构建动态投资组合。</p><p id="0bab" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">请让我知道你是否喜欢或不喜欢这篇文章的某些部分，以及我如何改进。感谢您的阅读！</p><h1 id="583a" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">资源</h1><p id="fa93" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><strong class="ln io">后台脚本:</strong><a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/background_pages/" rel="noopener ugc nofollow" target="_blank">https://developer . chrome . com/docs/extensions/mv2/Background _ pages/</a></p><p id="c0c8" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">内容脚本:</strong><a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/content_scripts/" rel="noopener ugc nofollow" target="_blank">https://developer . chrome . com/docs/extensions/mv2/Content _ Scripts/</a></p><p id="b05c" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">舱单文件:</strong>【https://developer.chrome.com/docs/extensions/mv2/manifest/ T2】</p><p id="de84" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><strong class="ln io">消息传递:</strong><a class="ae ks" href="https://developer.chrome.com/docs/extensions/mv2/messaging/" rel="noopener ugc nofollow" target="_blank">https://developer.chrome.com/docs/extensions/mv2/messaging/</a></p></div></div>    
</body>
</html>