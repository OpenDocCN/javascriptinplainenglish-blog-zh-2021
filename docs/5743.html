<html>
<head>
<title>TypeScript Essentials: Conditionally Filter Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript要点:有条件地筛选类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-essentials-conditionally-filter-types-488705bfbf56?source=collection_archive---------1-----------------------#2021-12-05">https://javascript.plainenglish.io/typescript-essentials-conditionally-filter-types-488705bfbf56?source=collection_archive---------1-----------------------#2021-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c6254a32556fa1c485cf00a8c89e4c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKmTqTYtMFRrlq0LARJVMg.jpeg"/></div></div></figure><p id="0d44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解如何在TypeScript中有条件地筛选类型，并揭开常用模式的神秘面纱。</p><blockquote class="kt ku kv"><p id="0e3f" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">🚧这篇文章要求中级理解类型脚本、<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/objects.html" rel="noopener ugc nofollow" target="_blank">接口</a> &amp; <a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>。请查看<a class="ae la" href="https://www.typescriptlang.org/docs" rel="noopener ugc nofollow" target="_blank"> TypeScript文档</a>以了解理解这篇博文所需的更多基础知识。</p></blockquote><p id="d3b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用TypeScript库时，您经常会遇到一种类型/模式，乍一看会让您感到害怕。</p><p id="4225" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会在React或NestJs等流行的库中遇到这种类型。</p><p id="1fcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种类型的目的是有条件地筛选基于对象的类型。</p><p id="aab3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我将为你揭开这种类型的神秘面纱，到这篇博文结束时，你将已经学会了一些关键的类型脚本概念。</p><p id="f1a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们先看看最终结果(我们将在本文中创建的类型):</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a77d" class="lk ll in lg b gy lm ln l lo lp">type FilterConditionally&lt;Source, Condition&gt; = Pick&lt;Source, {[K in keyof Source]: Source[K] extends Condition ? K : never}[keyof Source]&gt;;</span></pre><p id="a38c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们看看这个类型实际上是做什么的。</p><p id="0b20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个例子，我们过滤掉每一个不是<code class="fe lq lr ls lg b">string</code>的接口属性。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ce16" class="lk ll in lg b gy lm ln l lo lp">interface Sample {<br/>    property1: string; // ✅  NOT filtered out<br/>    property2: string; // ✅  NOT filtered out<br/>    property3: number; // ❌ filtered out<br/>    property4: boolean; // ❌ filtered out<br/>}</span><span id="10ab" class="lk ll in lg b gy lt ln l lo lp">type NewType = <strong class="lg io">FilterConditionally</strong>&lt;Sample, string&gt;</span></pre><p id="63e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果是一个新类型，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="748b" class="lk ll in lg b gy lm ln l lo lp">type NewType = {<br/>    property1: string;<br/>    property2: string;<br/>}</span></pre><p id="32ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来分析一下这是如何工作的。</p><h1 id="8202" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">三个转变</h1><p id="d4a7" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">为了做到这一点，我们对我们的类型应用了三个转换:</p><p id="e50d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。</strong>转换我们不想转换的属性<code class="fe lq lr ls lg b">never</code></p><p id="3161" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。</strong>创建我们想要的联合类型的键(在我们的例子中是<code class="fe lq lr ls lg b">"property1" | "property2"</code>)</p><p id="2640" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。</strong>通过从原始类型中挑选我们想要的属性来构造一个新的基于对象的类型(在步骤2中我们的联合类型的帮助下)。</p><h1 id="05dc" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.我们不想“永远”改变的属性</h1><p id="ea4d" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">这是最难的部分，所以我们会慢慢来。Typescript有一个<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener ugc nofollow" target="_blank">映射类型</a>的概念。我们可以使用映射类型在旧类型的基础上创建新类型。您可以将它想象成逐个遍历所有属性，并对每个条目应用一些逻辑。</p><p id="4704" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">听起来很抽象。让我们孤立地来看这个问题。</p><blockquote class="kt ku kv"><p id="c75b" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">下面的“MarkUnwantedTypesAsNever”类型是上面的“FilterConditionally”类型的一部分。我们刚刚分离出一个部分，并将其重命名。</p></blockquote><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f7d3" class="lk ll in lg b gy lm ln l lo lp">type MarkUnwantedTypesAsNever&lt;Source, Condition&gt; =<br/>   {[K in keyof Source]: Source[K] extends Condition ? K : never}</span></pre><p id="0316" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用这个类型将一个基于对象类型的每个属性标记为<code class="fe lq lr ls lg b">never</code>不符合我们的过滤条件。</p><p id="9a1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">🚧重要提示:</strong>如果一处房产符合我们的条件，我们不会听之任之。我们获取属性的名称，并将其设置为该属性的基于字符串的类型。这是一个在步骤2中有用的技巧。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6083" class="lk ll in lg b gy lm ln l lo lp">interface Sample {<br/>   property1: string; // string extends string ? ✅  set "property1"<br/>   property2: string; // string extends string ? ✅ set "property2"<br/>   property3: number; // number extends string ? ❌ set never<br/>   property4: boolean; // boolean extends string ? ❌ set never<br/>}</span></pre><p id="a819" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果类型为:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="90c3" class="lk ll in lg b gy lm ln l lo lp">type Result = {<br/>    property1: <strong class="lg io">"property1"</strong>;<br/>    property2: <strong class="lg io">"property2"</strong>;<br/>    property3: <strong class="lg io">never</strong>;<br/>    property4: <strong class="lg io">never</strong>;<br/>}</span></pre><p id="0b1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要复习一下条件类型(<code class="fe lq lr ls lg b">A extends B ? &lt;something&gt; : &lt;else&gt;</code>)，可以查看<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a>。</p><h1 id="e258" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">2.创建我们想要的联合类型的键</h1><p id="efbf" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">既然我们已经对我们的类型应用了第一个转换，那么现在是第二个转换的时候了。我们的目标是为所有匹配我们条件的键创建一个联合类型。</p><p id="075c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们正在寻找一种方法将<code class="fe lq lr ls lg b">Result</code>转化为<code class="fe lq lr ls lg b">Type ResultAfterSecondTransformation = "property1" | "property2"</code>。</p><p id="4e1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过添加一个<a class="ae la" href="https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html" rel="noopener ugc nofollow" target="_blank">索引访问类型</a>来做到这一点。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d6e1" class="lk ll in lg b gy lm ln l lo lp">type MarkUnwantedTypesAsNever&lt;Source, Condition&gt; =<br/>   {[K in keyof Source]: Source[K] extends Condition ? K : never}<strong class="lg io">[keyof Source]</strong></span></pre><p id="3d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如果我们把我们的<code class="fe lq lr ls lg b">Sample</code>类型传递给它:<code class="fe lq lr ls lg b">MarkUnwantedTypesAsNever&lt;Sample, string&gt;</code>，这个类型会做什么。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c410" class="lk ll in lg b gy lm ln l lo lp">type Result = {<br/>   property1: "property1";<br/>   property2: "property2";<br/>   property3: never; // ❌ we want this gone<br/>   property4: never; // ❌ we want this gone<br/>}["property1" | "property2" | "property3" | "property4"]</span></pre><p id="a352" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住！当我们通过一个索引访问一个接口的属性时，我们接收那个属性的类型:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="37ea" class="lk ll in lg b gy lm ln l lo lp">type Access = {property1: "foo"}["property1"] // -&gt; "foo";</span></pre><p id="d9eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们对两个属性进行同样的操作，我们将构建一个联合类型:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a987" class="lk ll in lg b gy lm ln l lo lp">type Access = {property1: "foo"; property2: "bar"}["property1" | "property2"]</span><span id="80ef" class="lk ll in lg b gy lt ln l lo lp">// Result: <strong class="lg io">type Deepdive = "foo" | "bar"</strong></span></pre><p id="0a20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们试图访问带有<code class="fe lq lr ls lg b">never</code>类型的属性的类型，那么<code class="fe lq lr ls lg b">never</code>类型将不会包含在结果并集中。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0901" class="lk ll in lg b gy lm ln l lo lp">type Access = {property1: "foo"; property2: never}["property1" | "property2"]</span><span id="145c" class="lk ll in lg b gy lt ln l lo lp">// Result: <strong class="lg io">type Deepdive = "foo"</strong></span></pre><p id="6506" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理解为什么<code class="fe lq lr ls lg b">never</code>类型会被过滤掉通常很难，因为这需要一些集合知识。如果您有兴趣了解更多信息，请阅读下面的免责声明。</p><blockquote class="kt ku kv"><p id="1e40" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">🚧免责声明:从来没有类型被过滤掉，因为它们在TypeScript(集合论)中定义了一个空集。当用空集和任何其他值构建并集时，可以省略空集。和写2 + 0 = 2或者2 = 2是一样的。可以省略空的东西。同样的事情。真的。</p></blockquote><p id="7797" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快速回顾:</p><p id="0eb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本节的最后，我们现在将原始类型转换为以下形状:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2ec4" class="lk ll in lg b gy lm ln l lo lp">interface Sample {<br/>   property1: string;<br/>   property2: string;<br/>   property3: number;<br/>   property4: boolean;<br/>}</span></pre><p id="dbea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">…形成一个具有以下形状的联合:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5b6e" class="lk ll in lg b gy lm ln l lo lp">"property1" | "property2"</span></pre><p id="f7d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了实现这一点，我们使用了两个转换。</p><p id="c284" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们为应用这两种变换而创建的类型具有以下形状:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7a34" class="lk ll in lg b gy lm ln l lo lp">type CreateUnionOfWantedPropertyKeys&lt;Source, Condition&gt; =<br/>   {[K in keyof Source]: Source[K] extends Condition ? K : never}[keyof Source]</span></pre><h1 id="60a9" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">3.挑选我们想要的类型</h1><p id="6091" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">我们的最后一步简单明了。现在我们有了一个通过过滤条件的键的联合，我们可以使用内置的<code class="fe lq lr ls lg b">Pick</code>类型。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8702" class="lk ll in lg b gy lm ln l lo lp">type FinalType&lt;Source, Condition&gt; = <strong class="lg io">Pick</strong>&lt;Source, CreateUnionOfWantedPropertyKeys&lt;Source, Condition&gt;&gt;;</span></pre><p id="299c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是了。我们完了。这是我们的最终类型！如果我们用它的定义替换<code class="fe lq lr ls lg b">CreateUnionOfWantedPropertyKeys</code>(为了精简我们的代码)，我们从这篇文章的最开始就得到<code class="fe lq lr ls lg b">FilterConditionally</code>类型:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="027b" class="lk ll in lg b gy lm ln l lo lp">type FilterConditionally&lt;Source, Condition&gt; = Pick&lt;Source, {[K in keyof Source]: Source[K] extends Condition ? K : never}[keyof Source]&gt;;</span></pre><h1 id="5e29" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我们在“野外”哪里看到这种类型？</h1><p id="7732" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">理解这种类型可以让您在使用ReactJS类型时更加得心应手，因为React中一个非常基础的类型依赖于这种模式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8c3b" class="lk ll in lg b gy lm ln l lo lp">type ElementType&lt;P = any&gt; = {[K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never}[keyof JSX.IntrinsicElements] | ComponentType&lt;P&gt;;</span></pre><p id="cf67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在流行的前端和后端应用程序库中可以找到更多的例子。</p><h1 id="9b07" class="lu ll in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="a9a5" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">恭喜你走到这一步。我希望您已经学到了一些重要的TypeScript概念。考虑为这篇文章鼓掌(或关注我)，因为它会帮助其他人找到它。</p><p id="7c70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">祝你有愉快的一天。继续编码。</p><blockquote class="kt ku kv"><p id="7101" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">🚧快速了解一下术语:在本文中，我指的是接口和属性。谈论接口条件就好像它们是JavaScript对象的属性一样会阻碍你形成正确的心智模型。类型定义了一组值，而接口不像对象那样具有属性。然而，调用接口条件“属性”简化了我们用来解释类型脚本概念的语言。</p></blockquote><p id="091a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">如果你有兴趣增加你在所有社交渠道的有机接触，请查看</em><a class="ae la" href="https://gosquad.cc" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kw">https://gosquad . cc</em></strong></a></p></div></div>    
</body>
</html>