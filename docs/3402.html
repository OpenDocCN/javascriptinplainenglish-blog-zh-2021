<html>
<head>
<title>RouteReuseStrategy Simplified in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">路由使用策略在角度上得到简化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/routereusestrategy-simplified-in-angular-2e358db618d9?source=collection_archive---------2-----------------------#2021-07-10">https://javascript.plainenglish.io/routereusestrategy-simplified-in-angular-2e358db618d9?source=collection_archive---------2-----------------------#2021-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3e1c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">角度基础2021</h2><div class=""/><div class=""><h2 id="3399" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Angular中的路由复用策略是什么？如何实施？</h2></div><p id="0684" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最近，我在寻找最好的技术来写干净和优化我的angular代码。我看了很多文章，我们知道，是无限的。然后我想到用不同的基本角度的主题来巩固清单，这些主题对我有帮助，将来也可能对别人有帮助。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/5a3be90fd06f2f0f70c93879b69ef592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vX7TEX5dhnEobMGn"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Photo by <a class="ae ma" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b374" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些小文章不仅能帮助你写出更好更干净的Angular代码，还能让你清楚前端技术的概念。这将有助于你建立强大的基础，并能在即将到来的前端面试中帮助你。</p><p id="103b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在开始Angular中的RouteReuse策略之前，让我们先讨论一下这个问题。</p><h2 id="5775" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">问题</h2><p id="f117" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">在Angular中使用路由从一个URL导航到另一个URL。当我们导航到另一个页面时，它不会存储上一个页面的值。当我们回到上一页时，它会重新加载整个页面。到此，我们以<code class="fe my mz na nb b"><strong class="kq ja">performance</strong> </code>问题结束。</p><p id="67b7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们来理解这个动画的问题。</p><h2 id="f8ff" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">说明</h2><p id="6fc7" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">当我们从路线<code class="fe my mz na nb b"> /parent/child</code>导航到<code class="fe my mz na nb b">/siblings</code>时，Child1Component被销毁，SiblingComponent将被加载。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/029f286a831692c037feff326f083e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*VZNzGYNUmJ00I6CEejgwuQ.png"/></div></figure><p id="0576" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，当我们突然从<code class="fe my mz na nb b">/sibling</code>导航到<code class="fe my mz na nb b">/parent/child</code>时，SiblingComponent被销毁，Child1Component将被加载。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2598df0d1a28dd97d06dd85b10a96eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*Cd_wkzIatgg3yVwf-vm9eg.png"/></div></figure><p id="1a9f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们继续导航到相同的组件，这基本上会导致性能问题。</p><h2 id="c33b" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">解决方案</h2><p id="1169" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">当你知道你很快就会再次需要一个组件时，我们应该避免破坏它。与往常一样，Angular提供了一个解决方案，并让您通过实现<a class="ae ma" href="https://angular.io/api/router/RouteReuseStrategy" rel="noopener ugc nofollow" target="_blank">routereustrategy</a>类来定义自己的重用策略。</p><p id="9f31" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">routerusestrategy</strong>接口包含五个方法:</p><p id="35c3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe my mz na nb b"><em class="ne">shouldReuseRoute:</em></code> <em class="ne"> </em>每次在路线间导航时都会被调用。有两种类型，未来和现在。未来是我们离开的路线，当前是我们着陆的路线。</p><p id="7dc6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe my mz na nb b"><em class="ne">shouldAttach</em></code>:当我们在这条航线的组件上着陆时，为刚刚打开的航线调用。</p><p id="b709" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果<em class="ne"> shouldAttach </em>返回TRUE，则<code class="fe my mz na nb b"><em class="ne">retrieve</em>:</code>被调用。</p><p id="34d6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe my mz na nb b"><em class="ne">shouldDetach</em>:</code>当我们<strong class="kq ja">离开当前</strong> <em class="ne">路线</em>时调用。</p><p id="30de" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">只有当<em class="ne"> shouldDetach </em>返回true时，才会调用该方法。</p><h2 id="b0b0" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">例子</h2><p id="ced3" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">让我们来看一下动画，以了解我们可以用自定义RouteReuseStrategy实现什么。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="db95" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">说明</h2><p id="b525" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">当我们启动应用程序时，我们注意到以下情况:</p><ul class=""><li id="bbdf" class="nh ni iq kq b kr ks ku kv kx nj lb nk lf nl lj nm nn no np bi translated">正如您在控制台中看到的，当我们第一次加载我们的路线时，下面是我们在控制台中看到的内容。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1490c84659c417148bb6dfcedf288308.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*nw2yPCD5MeqEeRcwiZtu8g.png"/></div></figure><p id="239f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，正如我们看到的，<strong class="kq ja"> shouldReuseRoute </strong>被调用为true，因为它与代码中写的条件相匹配。</p><ul class=""><li id="b443" class="nh ni iq kq b kr ks ku kv kx nj lb nk lf nl lj nm nn no np bi translated">另一个值得注意的事情是检索<strong class="kq ja">T5和<strong class="kq ja"> shouldAttach </strong>是后来被调用的，因为它们第一次都是假的，因为我们没有做任何导航</strong></li><li id="63bc" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated"><code class="fe my mz na nb b">child 1</code>组件已加载。</li></ul><p id="ebfa" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当我们开始从父路由导航到同级路由时:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d280e4f5d24fda1f194df8138bffca53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*wO8OBb2DXHbZFitH8CX3DQ.png"/></div></figure><ul class=""><li id="2e1a" class="nh ni iq kq b kr ks ku kv kx nj lb nk lf nl lj nm nn no np bi translated">正如您在控制台中看到的，shouldDetach方法为true，因为我们有了包含<code class="fe my mz na nb b">data: { reuse: true },</code>的父组件，并且我们现在存储了以前的路由。</li><li id="d194" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated">这里的<strong class="kq ja">应该附加</strong>方法<strong class="kq ja"> </strong>是假的作为我们第一次来时的弟妹成分。</li><li id="2310" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated">在最后一个兄弟节点，组件被加载。</li></ul><p id="694c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当我们开始从同级路由导航到父路由时:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b19fdf3069308f834ded874477d1826d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*N0zXtp0VmvLTrWRPwskDSw.png"/></div></figure><ul class=""><li id="3a63" class="nh ni iq kq b kr ks ku kv kx nj lb nk lf nl lj nm nn no np bi translated">这里<strong class="kq ja"> retrieve </strong>方法使用重用技术作为父组件</li><li id="626f" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated"><strong class="kq ja"> shouldDetach </strong>未定义，因为同级组件在路由模块中没有定义的重用技术。</li><li id="daff" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated">shouldAttach越来越真实，我们基本上再次重用相同的组件。</li><li id="140e" class="nh ni iq kq b kr nr ku ns kx nt lb nu lf nv lj nm nn no np bi translated">耶！我们已经重复使用了它…参见控制台…父组件这次没有被加载，它被重复使用。</li></ul><h2 id="2108" class="mb mc iq bd md me mf dn mg mh mi dp mj kx mk ml mm lb mn mo mp lf mq mr ms iw bi translated">让我们检查一下代码</h2><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ny ng l"/></div></figure><p id="4316" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> app.module.ts </strong></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4b5fed62a6d6710ab7a150ae67e847af.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*Z6muQrPs--xVahV-fhgQ5A.png"/></div></figure><h1 id="4c66" class="oa mc iq bd md ob oc od mg oe of og mj kf oh kg mm ki oi kj mp kl oj km ms ok bi translated">结论</h1><p id="f681" class="pw-post-body-paragraph ko kp iq kq b kr mt ka kt ku mu kd kw kx mv kz la lb mw ld le lf mx lh li lj ij bi translated">使用路由重用策略，我们可以避免频繁加载组件，这对于构建更高性能的Angular应用程序有很大帮助。</p><p id="68ce" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">可以在这里玩stack blitz:<a class="ae ma" href="https://stackblitz.com/edit/angular-route-reuse-strategy-test-project-hbycnv" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/angular-route-reuse-strategy-test-project-hbycnv</a></p><p id="5157" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="ne">来源:非常感谢https://stackblitz.com/@pcurrivan</em><em class="ne">的</em> <a class="ae ma" href="https://stackblitz.com/@pcurrivan" rel="noopener ugc nofollow" target="_blank"> <em class="ne">提供了这个简化的例子。</em></a></p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ol ng l"/></div></figure><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ol ng l"/></div></figure><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ol ng l"/></div></figure><p id="5b1a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="ne">更多内容请看</em><a class="ae ma" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq ja"><em class="ne">plain English . io</em></strong></a></p></div></div>    
</body>
</html>