<html>
<head>
<title>Interface Forge: A TypeScript/JavaScript Library to Generate Test Data and Fixtures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Interface Forge:一个生成测试数据和夹具的TypeScript/JavaScript库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generating-test-data-and-fixtures-with-interface-forge-5a5548233aa5?source=collection_archive---------5-----------------------#2021-08-06">https://javascript.plainenglish.io/generating-test-data-and-fixtures-with-interface-forge-5a5548233aa5?source=collection_archive---------5-----------------------#2021-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b39a8ead59e0f07ca9882633fbe84fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wJKVAqAGc5LhoA59eFA1w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Source: <a class="ae jz" href="https://www.pxfuel.com/" rel="noopener ugc nofollow" target="_blank">https://www.pxfuel.com/</a></figcaption></figure><p id="ee8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我介绍了<a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank"> Interface Forge </a>，并讨论了它的一些用例，我喜欢把它称为“模拟驱动开发”。</p><p id="9c3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">关于TypeScript的注意事项</em> : <a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank">接口伪造</a>是用TypeScript编写的，它提供了强大的TS支持。因此，下面所有的例子都使用TS作为基础，但是这并不意味着你不能使用普通的JS来使用这个库，你当然可以这样做。</p><h2 id="8903" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">生成动态测试数据</h2><p id="e18a" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">这让我想到了编写这个库的必要性——我在工作中开始了一个新项目，并使用TypeORM +附带的NestJS API开发了一个数据模型。我需要用一些测试数据播种数据库，为API和定制的TypeORM存储库编写集成测试。</p><p id="e8a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，假设我们有一些实体:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="de48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当运行大多数后端测试时，我需要用至少一个用户播种数据库。一种选择是使用硬编码的测试数据，就像这样:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="74bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法对于单个测试套件来说是不错的，但是如果我想要重用这个逻辑，或者如果我想要能够创建多个用户，这将是不可伸缩的。此外，如果我想在后端服务和前端服务之间共享数据，这也是不可能的。</p><p id="0e84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是动态数据生成发挥作用的地方，即进入<a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank">界面伪造</a>:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ff90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们从Forge接口库导入了<code class="fe md me mf mg b">TypeFactory</code>,并使用它创建了两个工厂——一个用于UserProfile，另一个用于User。</p><p id="0afa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为字段“id”、“createdDate”、“updatedDate”和“user”将由TypeORM自动设置，所以我们需要将它们从传递给TypeFactory的泛型中删除。为此，我们使用内置的TypeScript函数Omit。</p><p id="3995" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还使用<a class="ae jz" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> Faker.js </a>为我们生成模拟值——这是一个非常好的库。这里需要注意的是，我们作为默认值传递给TypeFactory构造函数的是一个函数——这确保了每次我们使用工厂来构建Faker.js方法的嵌套调用时都会被求值。</p><p id="bdc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们还使用了一个内置的<a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank">接口Forge </a> helper方法<code class="fe md me mf mg b">.iterate</code>，它生成一个无限生成器，通过每个工厂调用为职业生成一个值。你可以在文档中读到更多关于这个<a class="ae jz" href="https://goldziher.github.io/interfaceForge/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="806a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这些工厂，我们现在可以像这样重写我们的测试:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="96d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者如果我们需要很多用户:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="44c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们产生了10个用户。干净利落。</p><h2 id="b89c" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">使用复杂类作为接口的技巧</h2><p id="61b4" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">例如，如果您的实体扩展了另一个类，如TypeORM内置的<code class="fe md me mf mg b">BaseEntity</code>类，那么在TypeScript中使用一个类作为接口可能比上面的例子更困难。在这种情况下，正在讨论的类将包含来自基类的许多我们不想包含在工厂结果中的属性和方法。以这个抽象基类为例:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="476a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们可以创建一个TypeScript helper类型，它采用两个泛型参数——实体类和它扩展的基类——然后从结果实体中省略所有“base”键:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="1922" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以这样使用这个类型:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="8c29" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">创建装置</h2><p id="24c3" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在我前面提到的新项目范围内，我和我的同事创建了一个TypeScript monorepo，它允许我们在新应用程序的各个组件之间共享代码。</p><p id="98db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这当然是在应用程序的各个组件中使用相同语言的独特优势的一部分，NestJS推荐的模式是创建dto——或数据传输对象——定义后端和前端之间的接口。</p><p id="baac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们的UserDTO类包含了由扁平对象中的User和UserProfile实体表示的大部分数据:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e5cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以为这个类创建一个工厂，我们可以在后端API测试和前端测试中使用它。然而，对于前端测试，我们也将使用<a class="ae jz" href="https://jestjs.io/docs/snapshot-testing" rel="noopener ugc nofollow" target="_blank">快照测试</a>，这要求我们有确定性的测试数据，否则我们的快照将在每次运行时失败。为此，<a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank"> Interface Forge </a>允许你将生成的测试数据保存为fixture文件。为此，我们只需使用<code class="fe md me mf mg b">FixtureFactory</code>而不是<code class="fe md me mf mg b">TypeFactory</code>来创建UserDTOFactory:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7e09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，如果我们想重用以前的工厂并减少代码重复:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="fa1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以像使用以前的工厂一样使用这个工厂，因为<code class="fe md me mf mg b">FixtureFactory</code>扩展了<code class="fe md me mf mg b">TypeFactory</code>，但是我们也可以用它来创建夹具:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b97f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当上面的测试第一次运行时，一个模拟用户DTO对象将被创建并写入一个文件。在这个测试的后续运行中，这个文件将被读取，它的内容将在测试中使用。除非工厂的数据结构改变，否则不会改变。</p><p id="cbbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是通过对保存到磁盘的数据的对象键和工厂输出的对象进行深入比较来确定的。这种方法确保工厂中的更改反映在保存到磁盘的数据的更改中，并随后反映在失败/更新的快照中。</p><h2 id="8d41" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">使用模拟数据进行快速原型开发</h2><p id="ad36" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我想在这里讨论的最后一个用例是使用模拟数据，以便更快地在代码库的不同组件之间移动——例如前端和后端，或者需要通信的不同微服务。</p><p id="405c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之:模拟数据允许开发人员在不同的组件上工作，以就他们各自的组件或模块之间的接口达成一致，即数据的“形状”，然后彼此独立地进行——至少在一定程度上。</p><p id="37c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们同意后端在给定的API端点向前端提供一个用户对象。此端点尚未实现，但这不应该成为前端开发人员原型化用户配置文件页面的障碍。</p><p id="f45c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，添加一个占位符API客户端方法是一个很好的起点。假设我们最终的方法看起来像这样:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="efb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以从这个开始:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="85a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有一个接受<code class="fe md me mf mg b">id</code>的异步方法，它使用工厂的异步<code class="fe md me mf mg b">.build</code>返回一个符合预期接口的用户对象。</p><p id="e37d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们可以在开发环境中使用这个逻辑来构建给定页面的原型。或者，我们可以使用像<a class="ae jz" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a>这样的工具，在这种情况下，我们可以这样做:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6276" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的UserProfile页面加载在storybook中，带有一个使用工厂生成的“用户”属性。这允许我们完全独立于后端API的开发来创建<code class="fe md me mf mg b">UserProfile</code>页面以检索数据。</p><h2 id="fced" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">摘要</h2><p id="0ca6" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在本文中，我介绍了<a class="ae jz" href="https://github.com/Goldziher/interfaceForge" rel="noopener ugc nofollow" target="_blank">Interface Forge</a>——一个用于生成模拟数据和装置的TypeScript/JavaScript库。为此，我给出了一些用例及测试示例，并讨论了一些“模拟驱动开发”的示例。也就是说，使用模拟数据进行开发，促进更快的原型开发和更好的测试。</p><p id="6c09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">说白了. io </em> </a> <em class="ky">。在这里注册我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">免费周报</em> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>