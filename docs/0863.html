<html>
<head>
<title>How to Handle Routing in Your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在反应应用程序中处理路由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-routing-in-your-react-application-b46d8b13b83a?source=collection_archive---------13-----------------------#2021-02-22">https://javascript.plainenglish.io/how-to-handle-routing-in-your-react-application-b46d8b13b83a?source=collection_archive---------13-----------------------#2021-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f7b8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">您需要了解的关于反应路由的所有信息-</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7ce735eed1ea7f456679c1ff6d353e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HU4G8VSraXL2jf5y5GdDmA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@nate_dumlao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nathan Dumlao</a> on <a class="ae ks" href="https://unsplash.com/s/photos/route?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2704" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组织正在转向单页应用程序(SPAs)，以满足客户和内置应用程序用户不断增长的需求。单页应用程序很大程度上依赖于JavaScript，当用户与应用程序交互时，他们并不要求整个页面重新加载。相反，对于每一个用户请求，单个页面都是动态更新的，在整个用户旅程中提供了更有效的界面。因此，spa已经成为软件开发行业的新常态。</p><p id="b1cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">SPA有许多视图，你需要一个路由器来处理URL，而不是传统的多应用程序，来浏览这些视图。反应路由器处理这个问题，使用户界面和应用程序的网址同步。</p><blockquote class="lp"><p id="a603" class="lq lr in bd ls lt lu lv lw lx ly lo dk translated">反应路由器允许您以声明方式处理路由。声明性路由策略使您能够操纵应用程序中的数据流，并以增强的可读性构建直观的路由，试图使其方便地处理您的应用程序体系结构。</p></blockquote><p id="9a73" class="pw-post-body-paragraph kt ku in kv b kw lz jo ky kz ma jr lb lc mb le lf lg mc li lj lk md lm ln lo ig bi translated">所以，让我们通过本文来看看如何在您的反应应用程序中使用路由。</p><h1 id="40b2" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">安装和设置反应路由器</h1><p id="c486" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">使用<code class="fe nb nc nd ne b">create-react-app</code>创建新的反应应用程序后，您需要安装反应路由器包。有两种版本，网络版本和本地版本。我们需要在这里安装网络版。</p><p id="6b20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在终端中使用以下命令安装软件包:</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="3264" class="nj mf in ne b gy nk nl l nm nn">npm install react-router-dom</span></pre><p id="b77f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦安装了软件包，就必须为每个软件包创建一组具有不同路由的组件。在这里，我创建了一个简单的ToDo应用程序，因此我们将有计划任务、已完成任务和未完成任务的单独组件。</p><p id="5630" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的三个组件<code class="fe nb nc nd ne b">Scheduled Tasks</code>组件、<code class="fe nb nc nd ne b">Completed Tasks</code>组件、<code class="fe nb nc nd ne b">Missed Tasks</code>组件如下。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="a03b" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;</span><span id="77a4" class="nj mf in ne b gy no nl l nm nn">export default function ScheduledTasks() {</span><span id="2c85" class="nj mf in ne b gy no nl l nm nn"> return &lt;<strong class="ne io">h2</strong>&gt;Scheduled Tasks&lt;/<strong class="ne io">h2</strong>&gt;;</span><span id="daec" class="nj mf in ne b gy no nl l nm nn">}</span></pre></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><pre class="nf ne ng nh aw ni bi"><span id="f0aa" class="nj mf in ne b gy nw nx ny nz oa nl l nm nn">import React from ‘react’;</span><span id="c62a" class="nj mf in ne b gy no nl l nm nn">export default function CompletedTasks() {</span><span id="afaf" class="nj mf in ne b gy no nl l nm nn"> return &lt;<strong class="ne io">h2</strong>&gt;Completed Tasks&lt;/<strong class="ne io">h2</strong>&gt;;<br/>}</span></pre></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><pre class="nf ne ng nh aw ni bi"><span id="6d43" class="nj mf in ne b gy nw nx ny nz oa nl l nm nn">import React from ‘react’;</span><span id="eb0a" class="nj mf in ne b gy no nl l nm nn">export default function MissedTasks() {</span><span id="0b8d" class="nj mf in ne b gy no nl l nm nn"> return &lt;<strong class="ne io">h2</strong>&gt;Missed Tasks&lt;/<strong class="ne io">h2</strong>&gt;;</span><span id="2f06" class="nj mf in ne b gy no nl l nm nn">}</span></pre></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="79a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为下一步，您必须连接路由，但是首先，您需要在应用程序中呈现基本组件。</p><p id="a2f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">打开<code class="fe nb nc nd ne b">App.js</code>并在带有类名“todo”的<code class="fe nb nc nd ne b">&lt;div&gt;</code>标签中附上一个带有网站名称(My ToDos)的<code class="fe nb nc nd ne b">&lt;h1&gt;</code>标签。这将作为一个模板。在任何页面上，toDos和<code class="fe nb nc nd ne b">&lt;h1&gt;</code>标记将被渲染。这将是显示其他组件的根组件。您可以在每个页面上为完整的应用程序插入您想要的导航栏或标题组件。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="c5f7" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import ‘./App.css’;</span><span id="5cf6" class="nj mf in ne b gy no nl l nm nn">function App() {<br/> return (<br/> &lt;div className=”toDos”&gt;<br/> &lt;h1&gt;My ToDos&lt;/h1&gt;<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="a8ff" class="nj mf in ne b gy no nl l nm nn">export default App;</span></pre><p id="9e84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当您拥有所有组件时，为了给应用程序提供空间，请应用一些填充。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="6d33" class="nj mf in ne b gy nk nl l nm nn">.toDos {<br/> padding: 20px;<br/>}</span></pre><h1 id="e9d8" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">添加路由</h1><p id="8567" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">在这一部分中，我们将为每个页面构建一个具有独立路由的基本路由器。为了保证组件被正确呈现，您将使用<code class="fe nb nc nd ne b">&lt;Link&gt;</code>组件来安排您的路线，以插入不会导致页面刷新的到项目的超链接。</p><p id="588e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">打开<code class="fe nb nc nd ne b">App.js</code>开始创建路线。<code class="fe nb nc nd ne b">&lt;h1&gt;</code>标签应该作为全球页面的标题。因为我们希望它显示在每个页面上，就在标签“配置路由器”之后。接下来，<code class="fe nb nc nd ne b">import ScheduledTasks</code>和<code class="fe nb nc nd ne b">&lt;div&gt;</code>内部进行渲染。</p><p id="6592" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从react-router-dom导入<code class="fe nb nc nd ne b">BrowserRouter</code>、<code class="fe nb nc nd ne b">Route</code>和<code class="fe nb nc nd ne b">Switch</code>。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="073e" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { BrowserRouter, Route, Switch } from ‘react-router-dom’;<br/>import ‘./App.css’;</span><span id="6312" class="nj mf in ne b gy no nl l nm nn">import ScheduledTasks from ‘../ScheduledTasks /ScheduledTasks’;</span><span id="7b6c" class="nj mf in ne b gy no nl l nm nn">function App() {<br/> return (<br/> &lt;div className=”wrapper”&gt;<br/> &lt;h1&gt;My ToDos&lt;/h1&gt;<br/> &lt;ScheduledTasks /&gt;<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="2bda" class="nj mf in ne b gy no nl l nm nn">export default App;</span></pre><h1 id="f2a9" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">路由器组件</h1><p id="0790" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我们要做的下一件事是将我们的<code class="fe nb nc nd ne b">&lt;App&gt;</code>组件放在<code class="fe nb nc nd ne b">&lt;Router&gt;</code>组件中。在我们创建基于浏览器的应用程序时，您可以选择React Router API的两种类型的路由器:</p><ul class=""><li id="9da8" class="ob oc in kv b kw kx kz la lc od lg oe lk of lo og oh oi oj bi translated">浏览器路由器</li><li id="2d81" class="ob oc in kv b kw ok kz ol lc om lg on lk oo lo og oh oi oj bi translated">哈希鲁特</li></ul><p id="1e38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它们背后的关键区别在它们生成的URL中是显而易见的。<code class="fe nb nc nd ne b">&lt;BrowserRouter&gt;</code>是两者中最常见的，因为它利用HTML5历史API使您的UI与URL同步，而URL的散列段由<code class="fe nb nc nd ne b">&lt;HashRouter&gt;</code> (window.location.hash)使用。如果您需要提升不使用历史API的遗留浏览器，您可以使用<code class="fe nb nc nd ne b">&lt;HashRouter&gt;</code>。相反，对于大多数用例来说，<code class="fe nb nc nd ne b">&lt;BrowserRouter&gt;</code>是最好的选择。</p><h1 id="89f1" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">链接和布线组件</h1><p id="5366" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">React路由器最重要的特性是<code class="fe nb nc nd ne b">&lt;Route&gt;</code>组件。如果实际位置对应于路线的路径，这将呈现任何UI。最好是，<code class="fe nb nc nd ne b">&lt;Route&gt;</code>组件应该有一个称为路径的属性，如果路径与实际位置一致，它就会被渲染。</p><p id="2fad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">否则，<code class="fe nb nc nd ne b">&lt;Link&gt;</code>组件用于跨页面导航。它类似于HTML的锚元素。使用锚链接将导致整个页面刷新，这是我们不希望的。然后我们可以使用<code class="fe nb nc nd ne b">&lt;Link&gt;</code>或者重定向到一个特定的URL，让视图重新呈现而不刷新。</p><p id="40db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，要构建一个基本路由器，插入BrowserRouter组件。在每一页上，该组件之外的所有内容都将被呈现，因此将其插入到您的<code class="fe nb nc nd ne b">&lt;h1&gt;</code>标签之后。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="7d74" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { BrowserRouter, Route, Switch } from ‘react-router-dom’;<br/>import ‘./App.css’;</span><span id="f1b8" class="nj mf in ne b gy no nl l nm nn">import ScheduledTasks from ‘../ScheduledTasks /ScheduledTasks‘;</span><span id="2779" class="nj mf in ne b gy no nl l nm nn">function App() {<br/> return (<br/> &lt;div className=”toDos”&gt;<br/>     &lt;h1&gt;My ToDos&lt;/h1&gt;<br/>       &lt;BrowserRouter&gt;<br/>         &lt;ScheduledTasks /&gt;<br/>       &lt;/BrowserRouter&gt;<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="0305" class="nj mf in ne b gy no nl l nm nn">export default App;</span></pre><p id="5f11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，在BrowserRouter中插入交换机组件。这个组件就像JavaScript switch语句一样，将触发适当的路由。对于每条路线，在<code class="fe nb nc nd ne b">Switch</code>中附加一个路线组件。在这个图中，您需要以下路线:<code class="fe nb nc nd ne b">/scheduledtasks</code>、<code class="fe nb nc nd ne b">/completedtasks</code>和<code class="fe nb nc nd ne b">/missingtasks</code>。路径将被路由组件作为参数，并将包围一个子组件。每当路由被激活时，子组件就会出现。</p><p id="74d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你尝试一个路由，比如<a class="ae ks" href="http://localhost:3000/scheduledtasks," rel="noopener ugc nofollow" target="_blank">http://localhost:3000/scheduled tasks，</a>你会发现<code class="fe nb nc nd ne b">ScheduledTasks</code>组件。符合模式的第一条路线由<code class="fe nb nc nd ne b">Switch</code>组件呈现。</p><blockquote class="op oq or"><p id="d9bc" class="kt ku os kv b kw kx jo ky kz la jr lb ot ld le lf ou lh li lj ov ll lm ln lo ig bi translated">每条路线都将与/兼容，因此每个页面都将呈现它，这也意味着排序很重要。因为路由器一旦发现匹配就会退出，所以通常会将更精确的路由放在不太精确的路由之前。</p></blockquote><p id="e600" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您希望路线仅匹配指定的路线，而不匹配任何子路线，则可以应用精确属性。对于eg，它会匹配<code class="fe nb nc nd ne b">/scheduledtasks</code>而不是<code class="fe nb nc nd ne b">/scheduledtasks</code> <code class="fe nb nc nd ne b">/scheduledtasksdate</code>，带有<code class="fe nb nc nd ne b">&lt;Route exact path=”/scheduledtasks “&gt;</code>。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="eb9b" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { BrowserRouter, Route, Switch } from ‘react-router-dom’;<br/>import ‘./App.css’;</span><span id="56db" class="nj mf in ne b gy no nl l nm nn">import ScheduledTasks from ‘../ScheduledTasks /ScheduledTasks ‘;<br/>import CompletedTasks from ‘../CompletedTasks /CompletedTasks ‘;<br/>import MissedTasks from ‘../MissedTasks /MissedTasks ;</span><span id="0135" class="nj mf in ne b gy no nl l nm nn">function App() {<br/> return (<br/> &lt;div className=”toDos”&gt;<br/>   &lt;h1&gt;My ToDos&lt;/h1&gt;<br/>     &lt;BrowserRouter&gt;<br/>       &lt;Switch&gt;<br/>         &lt;Route path=”/scheduledtasks”&gt;<br/>            &lt;ScheduledTasks /&gt;<br/>         &lt;/Route&gt;<br/>         &lt;Route path=”/completedtasks”&gt;<br/>             &lt;CompletedTasks /&gt;<br/>         &lt;/Route&gt;<br/>         &lt;Route path=”/missedtasks”&gt;<br/>            &lt;MissedTasks /&gt;<br/>         &lt;/Route&gt;<br/>       &lt;/Switch&gt;<br/>     &lt;/BrowserRouter&gt;<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="4aa9" class="nj mf in ne b gy no nl l nm nn">export default App;</span></pre><p id="154a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在已经有了许多组件，可以为用户构建导航来切换页面了。</p><p id="58ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了表明我们正在设计主页的导航部分，使用<code class="fe nb nc nd ne b">&lt;nav&gt;</code>元素。然后用一个列表项(<code class="fe nb nc nd ne b">&lt;li&gt;</code>)和一个<code class="fe nb nc nd ne b">Link</code>为每个ToDo附加一个无序列表(<code class="fe nb nc nd ne b">&lt;ul&gt;</code>)。最后，将<code class="fe nb nc nd ne b">&lt;nav&gt;</code>段转移到浏览器路由器内。这确保了反应路由器操纵链路组件。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="aca6" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { BrowserRouter, Link, Route, Switch } from ‘react-router-dom’;<br/>import ‘./App.css’;</span><span id="ee2a" class="nj mf in ne b gy no nl l nm nn">import ScheduledTasks from ‘../ScheduledTasks /ScheduledTasks ‘;<br/>import CompletedTasks from ‘../CompletedTasks /CompletedTasks ‘;<br/>import MissedTasks from ‘../MissedTasks /MissedTasks ‘;</span><span id="a480" class="nj mf in ne b gy no nl l nm nn">function App() {<br/> return (<br/> &lt;div className=”toDos”&gt;<br/>    &lt;h1&gt;My ToDos&lt;/h1&gt;<br/>      &lt;BrowserRouter&gt;<br/>       &lt;nav&gt;<br/>         &lt;ul&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to=”/scheduledtasks”&gt;Scheduled Tasks &lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to=”/completedtasks”&gt;Completed Tasks&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to=”/missedtasks”&gt;Missed Tasks&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>         &lt;/ul&gt;<br/>       &lt;/nav&gt;<br/>       &lt;Switch&gt;<br/>          &lt;Route path=”/scheduledtasks”&gt;<br/>             &lt;ScheduledTasks /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path=”/completedtasks”&gt;<br/>             &lt;CompletedTasks /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path=”/missedtasks”&gt;<br/>             &lt;MissedTasks /&gt;<br/>          &lt;/Route&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/BrowserRouter&gt;<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="287e" class="nj mf in ne b gy no nl l nm nn">export default App;</span></pre><p id="cf56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们已经为每个组件构建了一条路线，并引入了导航，无需使用Link组件刷新页面就可以在路线间移动。</p><h1 id="f145" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">嵌套路由</h1><p id="e965" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">路线会扩大，显得更复杂。React Router使用嵌套路由在子组件中呈现更精确的路由细节。最后一步，在<code class="fe nb nc nd ne b">App.js</code>中，我们添加了路线。</p><p id="08bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它有很多好处:它在一个位置保存所有的路线，本质上为我们的应用程序提供了一个站点地图。但它可能会迅速发展，难以阅读和管理。</p><blockquote class="lp"><p id="bdcf" class="lq lr in bd ls lt lu lv lw lx ly lo dk translated">嵌套路由明确地将路由数据组织到呈现其他组件的组件中，允许您在应用程序中构建小型模板。</p></blockquote><p id="0917" class="pw-post-body-paragraph kt ku in kv b kw lz jo ky kz ma jr lb lc mb le lf lg mc li lj lk md lm ln lo ig bi translated">假设您需要对ToDos应用程序应用另一个级别。待办事项有很多种，如关键、非关键，并且可以显示每种待办事项的详细信息。您有两个选择:您可以使用当前路线，并附加一个带有搜索参数的特定类型的to do，比如？类型=关键。您还可以在包含特殊名称(如<code class="fe nb nc nd ne b">/scheduledtasks/critical</code>)的基本URL之后构建一个新的路由。</p><p id="6b14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，为不同的ToDos类型制作新组件。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="8410" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;</span><span id="84cd" class="nj mf in ne b gy no nl l nm nn">export default function Critical() {<br/> <br/>return(<br/> &lt;h3&gt;Critical&lt;/h3&gt;<br/> );<br/>}</span></pre><p id="a208" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来打开<code class="fe nb nc nd ne b">ScheduledTasks.js </code>。这是您要连接嵌套路径的地方。</p><p id="f78d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你必须做两件事。最初，用UseRouteMatch钩子，抓取当前方向。然后，为了显示相关的组件，制作当前的<code class="fe nb nc nd ne b">&lt;Switch&gt;</code>和<code class="fe nb nc nd ne b">&lt;Route&gt;</code>组件。</p><p id="b274" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nb nc nd ne b">UseRouteMatch</code>导入将返回一个包含URL和路径的对象。析构对象以打开路径。这将作为您新路线的基础:</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="b0c9" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { useRouteMatch } from ‘react-router-dom’;<br/>import Critical from ‘./Critical’;</span><span id="eec6" class="nj mf in ne b gy no nl l nm nn">export default function ScheduledTasks() {<br/> const { path } = useRouteMatch();</span><span id="9872" class="nj mf in ne b gy no nl l nm nn">return (<br/> &lt;&gt;<br/> &lt;<strong class="ne io">h2</strong>&gt;Scheduled Tasks&lt;/<strong class="ne io">h2</strong>&gt;<br/> {type === critical &amp;&amp; &lt;<strong class="ne io">Critical</strong> /&gt;}<br/> &lt;/&gt;<br/> );<br/>}</span></pre><p id="8ae6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，你必须导入<code class="fe nb nc nd ne b">Switch</code>和<code class="fe nb nc nd ne b">Route</code>来引入新的路线。新的路线将与您在<code class="fe nb nc nd ne b">App.js</code>中所做的相同，所以您不需要使用<code class="fe nb nc nd ne b">BrowserRouter </code>来捆绑它们。添加新路径，但在路由前添加路径前缀。新组件将精确地显示在您放置它的地方，所以在<code class="fe nb nc nd ne b">&lt;h2&gt;</code>之后添加新的路线。</p><pre class="kd ke kf kg gt nf ne ng nh aw ni bi"><span id="54d9" class="nj mf in ne b gy nk nl l nm nn">import React from ‘react’;<br/>import { Switch, Route, useRouteMatch } from ‘react-router-dom’;<br/>import Critical from ‘./Critical;</span><span id="1462" class="nj mf in ne b gy no nl l nm nn">export default function ScheduledTasks() {<br/> const { path } = useRouteMatch();<br/> return (<br/> &lt;&gt;<br/> &lt;h2&gt;Scheduled Tasks&lt;/h2&gt;<br/>   &lt;Switch&gt;<br/>     &lt;Route path={`${path}/critical`}&gt;<br/>      &lt;Critical /&gt;<br/>     &lt;/Route&gt;<br/>   &lt;/Switch&gt;<br/>&lt;/&gt;<br/> );<br/>}</span></pre><p id="3856" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它保存了孩子们和他们父母的路线。并非所有项目都使用嵌套路由:有些项目考虑提供一个显式列表。这是球队选择和延续的问题。为您的项目选择最佳的解决方案，然后您总是可以在以后对其进行改进。</p><h1 id="a2cc" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">摘要</h1><p id="99a3" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">正如我们在整篇文章中讨论的，React路由器是每个React应用程序的主要部分。当您创建用户可以无缝导航的单页应用程序时，您将需要路径来将应用程序分成可访问的部分。</p><p id="b5bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="os">在</em> <a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="os">查找更多内容</em></strong></a></p></div></div>    
</body>
</html>