<html>
<head>
<title>10 Best Practices for Node.js Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js应用程序的10个最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-best-practices-for-node-js-apps-5c8d1ee33a02?source=collection_archive---------4-----------------------#2021-03-17">https://javascript.plainenglish.io/10-best-practices-for-node-js-apps-5c8d1ee33a02?source=collection_archive---------4-----------------------#2021-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e2e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于我自己经验的Node.js最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8db8e9d89b63aa3394c1b0a2cf737ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D8g9XhNDgboRJD9Y.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Credit: <a class="ae kv" href="https://en.wikipedia.org/wiki/Node.js" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Node.js</a></figcaption></figure><p id="4e74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我总结了Node.js应用程序的10个技巧。这篇文章是基于我自己的经验，并不声称是完整的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e679" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.安装npm模块(正确)</h1><p id="eb01" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在某些项目中，必须始终安装某个版本的npm模块。然而，通常npm模块只是用命令<code class="fe mw mx my mz b">npm install ... --save</code>而不是<code class="fe mw mx my mz b">npm install ... --save --save-exact</code>安装。</p><p id="946b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令<code class="fe mw mx my mz b">npm install ... --save</code>导致npm模块...在package.json前接收一个版本号<code class="fe mw mx my mz b">^</code>。如果其他人为项目安装了这个npm模块，他可能会收到一个与最初安装的版本不同的版本。</p><p id="7d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe mw mx my mz b">npm install ... --save --save-exact</code>命令会将package.json中的版本设置为当前版本。</p><h1 id="ae51" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">2.应用程序监控非常重要</h1><p id="e151" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Node.js应用程序在服务器上作为单独的进程运行。例如，如果这个过程由于编程错误而崩溃，你应该是第一个知道的人，而不是你的访问者。</p><p id="a73f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node.js应用程序有许多监控工具，可以确保在出现错误时，通过电子邮件或其他方式发送相应的消息。在这里，每个人都必须找到他们应用所需的监控软件。对于Node.js应用程序，我更喜欢monit，因为它已经包含在大多数服务器中。然而，与monit提供的工具相比，其他工具提供了更广泛的监控选项。</p><h1 id="7a6c" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">3.始终使用Node.js的最新LTS版本</h1><p id="76e9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我总是建议使用Node.js的最新LTS(长期支持)版本，一方面是为了获得稳定性，另一方面是为了不失去最新的特性。在撰写本文时，当前版本是node . js 15 . 11 . 0。</p><h1 id="13e6" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">4.总是使用npm init启动新的Node.js项目</h1><p id="7c06" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">npm init</code>命令在当前目录下创建一个有效的空package.json文件。package.json文件对每个项目都很重要，因为npm模块及其版本就存储在这里。</p><p id="5f1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用不同的Node.js版本，想在它们之间来回切换，我推荐使用<a class="ae kv" href="https://github.com/creationix/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>(节点版本管理器)。</p><h1 id="87bf" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">5.总是用小写字母写文件名</h1><p id="27fa" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">不要创建这样的文件名:“MyFile.js”原因很简单。Node.js可用于各种平台(Windows、OSX、Linux)。例如，命令<code class="fe mw mx my mz b">var MyFile = require('MyFile');</code>可以在Windows开发系统上工作，但是在Linux生产服务器上会导致“找不到文件”。原因是有些操作系统，比如Windows，不区分“MyFile.js”和“myfile.js”。然而，其他操作系统，如Linux，却可以。</p><p id="b845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，Node.js项目中文件名的连字符符号被证明是实用的。对于上面的例子，这应该是“my-file.js”。</p><h1 id="597a" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">6.不要通过Node.js传递静态文件。</h1><p id="6f84" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">静态文件，如图像或类似文件，不应通过Node.js，而应通过web服务器交付。理想情况下，Node.js应用程序不直接在端口80上运行，而是通过不同的端口和web服务器(我推荐Nginx)将请求转发给Node.js进程。</p><p id="04f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为web服务器可以比Node.js应用程序更有效地交付静态文件，所以静态文件应该直接通过web服务器在单独的目录中交付。这意味着Node.js应用程序有更多的资源可用于处理动态请求。</p><h1 id="ddad" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">7.避免同步功能</h1><p id="7465" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">例如，Node.js总是为文件操作提供同步和异步版本的命令。例如，当用命令<code class="fe mw mx my mz b">fs.readFileSync(path[, options])</code>读取一个文件时，会阻塞整个进程，直到文件被完全读取，<code class="fe mw mx my mz b">fs.readFile(path[, options], callback)</code>程序继续执行该命令。一旦文件被读取，回调函数就会被调用。在大量使用的应用程序中，许多同步函数调用会降低性能。因此，应该避免使用同步函数调用。</p><p id="3dd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为Node.js是单线程的，所以建议使用异步函数，比如读取文件或数据库。特殊的npm模块可以控制最终的回调层次结构。</p><h1 id="ea68" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">8.正确设置NODE_ENV变量</h1><p id="bc2c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个<code class="fe mw mx my mz b">NODE_ENV</code>是一个环境变量，由于Express框架，它变得特别流行。NODE_ENV变量定义Node.js / Express应用程序运行的环境(开发或生产)。</p><p id="6cb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，该变量可以由<code class="fe mw mx my mz b">export NODE_ENV=production</code>在Linux &amp; OSX下设置，或者由<code class="fe mw mx my mz b">set NODE_ENV=production</code>在Windows下设置。通过将环境变量设置为production，Express会被提示将视图模板保存在内存中，而不是从硬盘中重新加载它们并生成不太详细的错误消息。因此，express应用程序被调整为具有更高的应用程序性能。</p><h1 id="3c3a" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">9.删除console.log语句</h1><p id="4b91" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Node.js应用程序中的每一点都可以生成输出<code class="fe mw mx my mz b">console.log();</code>。这对于开发系统来说是一个优势，因为开发人员可以在代码的不同点查看单个对象的状态。</p><p id="2058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果这些console.log语句被遗忘并进入生产系统，它们会消耗大量不必要的CPU时间并浪费宝贵的资源，尤其是在输出很大的情况下。console.log命令还会阻塞整个进程，因为它是同步执行的。因此，在生产系统中使用之前，应该删除所有console.log指令，例如Gulp或类似指令。</p><h1 id="b214" class="lz ma iq bd mb mc na me mf mg nb mi mj jw nc jx ml jz nd ka mn kc ne kd mp mq bi translated">10.通过自动测试检查代码</h1><p id="9966" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后，Node.js应用程序的客户端JavaScript代码应该始终受到测试的保护。Node.js有大量不同的测试框架。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6e82" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fbcf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我希望这些简单的技巧可以帮助您实现Node.js的最佳实践。</p><p id="e5c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nf">更多内容尽在</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nf">plain English . io</em></strong></a></p></div></div>    
</body>
</html>