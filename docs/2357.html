<html>
<head>
<title>Give an Upgrade to Your useReducer Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你的用户升级钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/give-an-upgrade-to-your-usereducer-hook-de8b46d3bde3?source=collection_archive---------11-----------------------#2021-05-16">https://javascript.plainenglish.io/give-an-upgrade-to-your-usereducer-hook-de8b46d3bde3?source=collection_archive---------11-----------------------#2021-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="075e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何升级React中的useReducer钩子，使其功能类似Redux reducers？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b9f08e66377a88b99ae3d46c9b89984f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J7DSy3fXeEERb33W"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@oskaryil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oskar Yildiz</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d542" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你必须问一个React开发人员——React中最重要的知识是什么，最可能的答案是了解“状态”以及它在幕后如何工作，这是React中最重要的原则。</p><p id="b57c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在现代React设置中，有几种方法可以管理您的状态。最常见的方法是简单的useState挂钩，它让您可以轻松地跟踪和更改您的状态模式。</p><p id="7a23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是有时您想要管理更复杂的状态。为此，您有几个状态管理工具，比如Redux。Redux不仅仅是拥有一个“全局”状态。Redux还以一种特殊的方式应用状态管理工具，这种方式被称为dispatch(action)—reducer—store cycle。</p><p id="dd1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将简要解释Redux状态循环是如何工作的，但本文的主题不是Redux。</p><p id="5cf1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将向您展示如何升级您的useReducer钩子，它是React团队发布的一个钩子，并使它具有类似Redux的Reducer的功能。我们将深入研究这个名为useEnhancedReducer的升级版的源代码，这将会非常有趣，所以让我们不要浪费任何时间，开始吧！</p><h1 id="62c1" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">Redux中的状态循环</h1><p id="940e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在Redux中，如果您想要对状态执行更改，您必须经历一些负责更新状态的函数的循环。让我们来看看它是如何工作的。</p><p id="1d97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一站——Dispatch:Dispatch是一个基本负责启动整个调整状态过程的功能。可以在应用程序的任何地方使用useDispatch钩子调用它，并向它传递想要触发的操作。</p><p id="caa1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二站——动作:如上所述，动作由调度触发。这个动作有一个“动作类型”,它告诉reducer我们想要返回到商店的状态有什么样的变化。除了动作类型之外，一个动作通常还有一个“有效负载”,它只是我们可以传递给reducer的参数。</p><p id="1e43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第三站——减速器:减速器功能是负责对状态进行实际更改的部分。我们决定当一个动作类型被触发时会发生什么变化，然后reducer将它返回到最后一站——商店。</p><p id="faaf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一站——商店:商店就是保存你状态的地方。为了对商店进行更改，您将Reducer作为一个参数传递给商店，然后您用一个提供者来包装整个应用程序，该提供者负责将您的应用程序与商店连接起来，因此您可以从所有组件访问它。</p><p id="423a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我非常喜欢Redux团队在官方文件中提出的寓言:</p><blockquote class="mm mn mo"><p id="c231" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">您可以将调度操作视为应用程序中的“触发事件”。发生了一些事情，我们想让商店知道。Reducers的行为类似于事件监听器，当它们听到感兴趣的动作时，就会更新状态作为响应。</p></blockquote><h1 id="dea9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">减速器并不是Redux所独有的</h1><p id="f2c8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">2019年2月，随着React 16.8的发布，React团队提出了钩子的概念。其中一个介绍给我们的钩子是useReducer钩子。useRudcer挂钩允许您以与Redux允许您管理状态几乎相同的方式管理状态，但是没有Redux设置。</p><p id="b0ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在必须全局管理状态的情况下，比如在React上下文中，或者当您想要在单个组件中管理更复杂的状态时，通常使用useReducer钩子。</p><p id="d005" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尽管useReducer钩子的设置与Reduxs的设置几乎相同，但还是有一些不同。</p><h1 id="7f6d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">Redux中的中间件和getState</h1><p id="c6dc" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在大多数Redux设置中，您通常将中间件应用于您的商店。你可以把中间件看作是在你的行为到达reducers然后到达store之前的一个过滤器。根据定义，一个动作函数必须返回一个对象，以便操作缩减器和状态。</p><p id="1e09" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">问题是，有时你确实想在你的行为中产生副作用，这就是中间件出现的地方。它允许您覆盖Reduxs操作的“规则”,并在您的操作函数中使用更复杂的操作。</p><p id="e8fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，使用thunk中间件，您可以将动作作为thunk而不是普通对象使用。Thunk是一个返回另一个函数的函数。这样，我们就能够做出像HTTP请求之类的异步动作，然后将一个“常规”动作分派给我们的reducer。</p><p id="3694" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它看起来像这样:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="5820" class="my lq in mu b gy mz na l nb nc">export const onDeletedItem = itemId =&gt; {<br/>  return (dispatch) =&gt; {<br/>    <br/>    axios<br/>      .post('http://localhost:3003/deletedItem', {<br/>        id: itemId,<br/>      })<br/>      .then(response =&gt; {<br/>        dispatch(deletedSuccess(itemId));<br/>      })<br/>      .catch(err =&gt; console.log(err));<br/>  };<br/>};</span></pre><p id="a0bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，我们有一个函数(onDeletedItem)返回另一个函数(匿名函数),它是一个thunk，多亏了Redux-thunk中间件，这才成为可能。</p><p id="e48f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">useReducer钩子中缺少的另一个东西是以一种方便的方式获得当前状态的能力。在Redux设置中，我们有一个名为getState的内置函数。使用getState，我们能够获得商店的当前状态。让我们更新最后一个片段，看看它是如何工作的:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="5e77" class="my lq in mu b gy mz na l nb nc">export const onDeletedItem = itemId =&gt; {<br/>  return (dispatch, getState) =&gt; {</span><span id="7f2f" class="my lq in mu b gy nd na l nb nc">    const userId = getState().auth.userId</span><span id="d222" class="my lq in mu b gy nd na l nb nc">    axios<br/>      .post('http://localhost:3003/deletedItem', {<br/>        itemId,<br/>        userId<br/>      })<br/>      .then(response =&gt; {<br/>        dispatch(deletedSuccess(itemId));<br/>      })<br/>      .catch(err =&gt; console.log(err));<br/>  };</span><span id="545c" class="my lq in mu b gy nd na l nb nc">};</span></pre><p id="d05b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们能够通过请求传递我们的存储中的用户id。</p><p id="ccca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">useReducer钩子没有为我们提供一种方法来应用一个中间件，并使用它的默认行为来获取状态，但是我们现在就要实现它！</p><h1 id="37e5" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">在useReducer中实现中间件和getState</h1><p id="2ef4" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了实现中间件和getState函数，我们必须对useReducer钩子进行升级。以下示例的源代码取自此处的<a class="ae ks" href="https://transang.me/get-state-callback-with-usereducer/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="40bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先让我们看看如何实现getState函数。看起来是这样的:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="6d7d" class="my lq in mu b gy mz na l nb nc">export const useEnhancedReducer = (reducer, initState, initializer) =&gt; {<br/>  const lastState = useRef(initState)<br/>  const getState = useCallback(() =&gt; lastState.current, [])<br/>  return [<br/>    ...useReducer(<br/>      (state, action) =&gt; lastState.current = reducer(state, action),<br/>      initState,<br/>      initializer<br/>    ),<br/>    getState<br/>  ]<br/>}</span></pre><p id="fe18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以让我们来打破这里发生的一切。我们初始化了一个新函数，它接收3个参数，这3个参数与我们的useReducer函数通常接收的参数相同:一个Reducer函数、初始状态和初始值设定项，如果您希望初始状态根据具体情况而有所不同，这是很有帮助的。</p><p id="702f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将创建getState函数。首先，我们创建一个名为lastState的常量，它有一个对initState的引用。这样，我们就能够跟踪状态的任何变化。然后我们创建getState函数本身:该函数用useCallback钩子包装。这样做是为了确保getState函数在每次渲染时都是不变的，所以您可以将它传递给一些钩子，而不用将它们添加到依赖列表中，或者将它们存储在其他地方以便从外部调用它们。</p><p id="8d59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后我们用。属性来获取我们状态的最新快照。</p><p id="b3ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们返回一个数组，其中包含:</p><ul class=""><li id="082a" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">我们最初的useReducer钩子及其所有属性(使用spread操作符)。我们将从useEnhancedRudcer钩子接收到的reducer、initState和initializer传递给它，这样它就可以处理它们了。</li><li id="09c0" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">我们的getState函数。</li></ul><p id="b806" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们可以运行我们新改进的钩子了:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="dc96" class="my lq in mu b gy mz na l nb nc">const [state, dispatch, getState] = useEnahancedReducer(reducer, initState)</span></pre><p id="8b5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">恭喜你。现在，我们可以使用getState函数来接收状态的最新快照。</p><p id="0964" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们实现中间件，这将更具挑战性。它的实现看起来像这样:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="6852" class="my lq in mu b gy mz na l nb nc">const useEnhancedReducer = (reducer, initState, initializer, middlewares = []) =&gt; {<br/>  const lastState = useRef(initState)<br/>  const getState = useCallback(() =&gt; lastState.current, [])<br/>  const enhancedReducer = useRef((state, action) =&gt; lastState.current = reducer(<br/>    state,<br/>    action<br/>  )).current <br/>  const [state, dispatch] = useReducer(<br/>      enhancedReducer,<br/>      initState,<br/>      initializer<br/>    )<br/>  const middlewaresRef = useRef(middlewares)<br/>  const enhancedDispatch = useMemo(()=&gt;middlewaresRef.current.reduceRight(<br/>    (acc, mdw) =&gt; action  =&gt; mdw(state)(getState)(acc)(action),<br/>    dispatch<br/>  ), []) // value of middlewares is memoized in the first time of calling useEnhancedReducer(...)<br/>  return [state, enhancedDispatch, getState]<br/>}</span></pre><p id="97d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如我们所看到的，我们为我们的useEnhancedReducer钩子添加了另一个参数——中间件。它允许我们添加一组中间件，我们希望将它们应用到useEnhancedReducer钩子上。</p><p id="3dec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用useEnhancedRuducer钩子作为Reducer的参数运行useReducer钩子，这样我们就可以访问状态和调度。</p><p id="2f49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在是时候创建我们的enhancedDispatch函数了，它将作为我们操作的中间件，这样我们就可以将Dispatch用于更复杂的函数(而不仅仅是简单的对象)。</p><p id="8ef0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们为我们的中间件数组保留了一个ref，并使用内置的javascript数组函数reduceRight。这将让我们在中间件之间“跳跃”我们的动作。然后我们也传递dispatch函数，这样我们也可以从我们的中间件中触发“常规”的分派。</p><p id="f795" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们给我们的函数的中间件签名是state =&gt; getState =&gt; next =&gt; action。</p><p id="7871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们检查一个简单的中间件功能，我们可以更好地理解它:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="1fa8" class="my lq in mu b gy mz na l nb nc">const logMiddleware = state =&gt; getState =&gt; next =&gt; action  =&gt; {</span><span id="7ad9" class="my lq in mu b gy nd na l nb nc">  console.log('before action', action, getState())<br/></span><span id="092f" class="my lq in mu b gy nd na l nb nc">  next(action)<br/> </span><span id="c063" class="my lq in mu b gy nd na l nb nc"> console.log('after action', action, getState())</span></pre><p id="6125" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们可以清楚地看到模式。当被触发时，中间件将在“动作前”运行。我们将用getState函数将我们的操作和当前状态记录到屏幕上。然后我们调用next并传递动作给它。</p><p id="6c82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还记得上一段中next在哪里吗？你说得对，它在ACC(ACC代表accumulator)的位置。这是什么意思？每个中间件现在将“在动作之前”运行，然后它将调用下一个传递给它的动作。这将导致第一个中间件(在索引0中)在“操作前”轮中首先应用，在“操作后”轮中最后应用(由于调用堆栈在js中的工作方式)。</p><p id="bb50" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在中间件取next()调度函数，返回一个调度函数，这个调度函数又作为左边中间件的next()，以此类推。访问state对象和getState()函数仍然很有用，所以我们将它们放在顶级参数中。</p><h1 id="d150" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">继续教育</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/9e79c30da305667ef7d2abeae9907b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XeYGaoBSPz3gQdGldT-0Q.png"/></div></div></figure><p id="9cd4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一些深入的分析。我希望你玩得开心。如果你很难跟进，或者你只是想更深入地了解，我建议你参考以下资源:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/9e79c30da305667ef7d2abeae9907b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XeYGaoBSPz3gQdGldT-0Q.png"/></div></div></figure><ul class=""><li id="d5b5" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><a class="ae ks" href="https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers" rel="noopener ugc nofollow" target="_blank"> Redux基础</a>。</li><li id="2b3d" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><a class="ae ks" href="https://redux.js.org/understanding/history-and-design/middleware" rel="noopener ugc nofollow" target="_blank"> Redux中间件</a>。</li><li id="8482" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer钩</a>。</li><li id="67ce" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><a class="ae ks" href="https://daveceddia.com/what-is-a-thunk/" rel="noopener ugc nofollow" target="_blank"> Redux thunk </a>。</li><li id="dbb4" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><a class="ae ks" href="https://transang.me/get-state-callback-with-usereducer/" rel="noopener ugc nofollow" target="_blank">使用增强型变径钩</a>。</li></ul><p id="d4a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>