# 虚拟 DOM 为什么这么快？

> 原文：<https://javascript.plainenglish.io/why-is-the-virtual-dom-so-fast-cf7630643349?source=collection_archive---------11----------------------->

## 当您开始了解前端世界时，您几乎会立即发现“虚拟 DOM”这个术语。但是是什么让它这么快呢？

![](img/4a59ec75983782a51a60f15e268f549c.png)

Photo by [Marc Sendra Martorell](https://unsplash.com/@marcsm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/speed?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

当您开始了解前端世界时，您几乎会立即发现“虚拟 DOM”这个术语。

大多数流行的前端框架都使用它，并希望用它来证明自己的速度。

但是是什么让它这么快呢？

是什么让真正的 DOM 如此缓慢和低效？

# 了解浏览器呈现

这个主题相当复杂，但是您需要了解一些基础知识来理解 DOM。

让我们假设我们从服务器请求一个简单的 HTML/CSS 页面；这里不需要 JS。

在我们收到 HTML/CSS 形式的响应后，会发生这样的情况:

## 1.解析 HTML

浏览器解析 HTML 文件，并将其作为高效的树结构存储在内存中。

这种表示被称为 DOM——文档对象模型。您可以通过打开 DevTools 并选择“Elements”选项卡来查看它。

明确一下，DOM 不是 HTML！它只是一个 HTML 和 XML 文件的接口。

## 2.解析 CSS

这一步包括解析 CSS——并将其存储为树形结构。它被称为 CSSOM。

## 3.创建渲染树

当你结合 DOM 和 CSSOM，你得到一个渲染树。它是由 HTML 节点和它们的样式组成的，它代表了在浏览器中呈现的内容。

这不会包括每一个 HTML 节点——例如`<head>`，但也包括带有`display: none;`的元素。只有那些在屏幕上看得见的。

## 4.布局阶段

这个阶段的目的是计算渲染树中每个节点的位置。浏览器将从根开始遍历树。

可以想象，这个过程可能会很昂贵，因为它必须对树中的每个节点进行大量的计算。

在这个阶段的最后，浏览器知道每个元素的确切位置和大小。

## 5.油漆阶段

最后，我们可以填充布局阶段后得到的空骨架。

浏览器不得不遍历视口中每个需要填充的像素。听起来很贵，对吧？

嗯，确实是。这绝对是计算量最大的一步。

您可以在 DevTools 的“Performance”选项卡下检查布局和绘画阶段。

# 让我们算一下

你可能已经知道，树形结构非常有效。我们拥有的算法可以毫不费力地遍历巨大的树。

**这样做真的很便宜。**这就是第 1-3 步的全部内容。

另一方面，第 4 步和第 5 步可能会非常昂贵，因为我们有额外的步骤来操作屏幕上的每个像素。这些算法是有效的，但与树形结构相比仍然很慢。

显然，我们最初的页面渲染会花费更长的时间，虚拟 DOM 也帮不了我们太多。我们在屏幕上还没有任何东西，对吗？

但是后来，当我们进行更新时，虚拟 DOM 将经历步骤 1-3。它会将新的渲染树与之前的渲染树进行比较，并仅对修改后的节点执行步骤 4–5。

这就是为什么它这么快！

它不需要从头开始做一整个过程。它将只重新渲染(步骤 4 和 5)修改过的节点！

最棒的是——你不需要管它。你神奇的 FE 工具会帮你做到。

如果你在 React 的官方文档中读到关于[优化性能的内容，你会发现:](https://reactjs.org/docs/optimizing-performance.html)

> “在内部，React 使用了几种巧妙的技术来最小化更新 UI 所需的代价高昂的 DOM 操作的数量。对于许多应用程序来说，使用 React 将会产生一个快速的用户界面，而不需要做很多工作来专门优化性能。”

所以不要做不必要的优化。大多数时候，这些优化背后的复杂性会导致代码运行速度变慢。

热爱并赞美 VDOM。

*更多内容尽在*[*plain English . io*](http://plainenglish.io/)