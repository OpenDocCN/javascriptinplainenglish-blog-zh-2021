# 如何开始使用 JavaScript 中的地图

> 原文：<https://javascript.plainenglish.io/getting-started-with-maps-in-javascript-f940d0083454?source=collection_archive---------18----------------------->

![](img/fa4a373d699176a3fdad45c9ff96dd6d.png)

Photo by [Brett Zeck](https://unsplash.com/@iambrettzeck?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

什么是 JavaScript 中的地图？映射是一个键值存储，其中保存了由键引用的值。当我们想要检索一个值时，我们引用该键，然后我们收到返回的值。如果你花了任何时间写 JavaScript，你可能会立即意识到地图的描述和物体非常相似，如果不是完全相同的话(至少到目前为止我已经揭示了)。根据 MDN 文档，地图的定义如下:

> Map 对象保存键值对，并记住键的原始插入顺序。任何值(对象和基元值)都可以用作键或值。

这给我们带来了两个我们可以从这个描述中收集到的区别。第一，地图记得插入顺序，物体没有这种能力。要获取一个对象的所有键，我们将调用`Object.Keys`。`Object.Keys`和`Map.Keys`之间有一个微妙的区别，那就是秩序。让我们看看在使用`Object.keys`时，我们是如何被骗相信维持了订单的。

这是令人困惑的，因为实际上如果你做了相当多的例子，它看起来保持了键插入时的顺序。实际上，如下所述，这是不正确的。

我们可以从 MDN 文档中进一步了解到`Object.keys`以同样的顺序遍历键，就像它们被循环一样。这里的参考是一个`for in`循环，它允许我们在一个物体的按键上循环。如果我们为此查看 MDN 上的文档，我们会发现以下内容:

> `for...in`循环以任意顺序迭代对象的属性

如果您想了解更多信息，可以继续讨论查看关于`delete`运算符的文档。我不认为这需要任何进一步的讨论，因为根据文档，为了适当地支持删除，返回的键的顺序可能会受到影响。任何更深入的解释都不在本文的讨论范围之内。否则，这应该是足够的知识来证明，当试图迭代键时，我们不能依赖于我们将键添加到对象中的顺序。

我们从地图描述中获得的第二个认识是，我们不再仅仅需要原始值作为关键字。在一个对象中，除了使用字符串之外，实际上没有其他方法来分配键(我们也可以选择使用符号，但是这些也被认为是基元值)。有了地图，我们也可以使用对象、数组和函数作为键。让我们开始深入探讨特定的 API。

# 在地图中设置值

在我们能够在地图中设置值之前，我们必须知道如何创建一个值。这非常简单，因此它不值得拥有自己的部分。我们可以简单地使用 Map 构造函数来创建一个新的 Map。

为了开始向我们的地图添加值，我们提供了方便的`set`方法。设置值很简单，提供一个键作为第一个参数，一个值作为第二个参数。

我们能够用两个参数调用`set`，正如您在控制台日志中看到的，第一个参数成为我们映射中的键，第二个参数成为我们映射中的值。值得注意的是，`set`方法返回当前的`this`上下文，这也允许将多个 set 调用链接在一起。此外，我们可以在最后一个例子中看到，我们不再使用原始值作为键。事实上，我们正在使用一个对象，您在第 16 行看到的控制台日志向我们显示了这是添加到我们的地图中的内容。

![](img/657dab9f39aa5f252fa77790de6e9110.png)

Shows What It Looks Like To Use A Non-Primitive Value Key On A Map, Screenshot By Author.

当然，在这里我们可以看到我们使用了一个对象作为键，这是一个简洁的概念，如果不先将它转换成字符串，就无法用对象来实现。最后要注意的是，正如我们在第 26 行看到的，我们可以通过传入一个数组的数组来初始化一个带有起始值的 map。每个内部数组表示一个键-值对，第一个位置是键，第二个位置是值。

# 获取地图中的值

获取地图中的值也非常方便和容易。我们已经向我们展示了`get`方法，它接受一个键作为它的唯一参数，如果它存在就返回存储在那个键上的值，如果不存在就返回未定义的值。下面我们来看一些例子。

在上面的代码中需要注意一些非常重要的事情。请注意，在地图中，字符串为“1”的键和数字为 1 的键是有区别的。此外，看看当试图获取 userId 为 1 的对象的值时的结果，但是当我们在`get`方法中直接使用对象而不是引用变量时。这是一个需要注意的重要区别，因为对于传统的哈希表，关键字通过哈希算法处理，该哈希算法的结果会影响值的放置。在这种情况下，使用这种技术，我们将能够以上图所示的方式查找值。

对于非原始值，映射使用内存中对非原始值的引用来查找并返回值。您可能会得到一些奇怪的行为，像这样做，而没有注意到引用中的一些东西已经改变。

我们需要确保当使用非原始值作为键时，我们不会改变那些引用，并期望仍然能够使用那些引用从我们的地图中获取项目。为了纠正上面的问题，您可以修改`updateEmail`来做如下的事情。

这里微妙的变化是我们更新了用户对象，而不是创建一个新的引用。要知道`Array.Map`返回一个新的引用，但只针对外部数组，内部对象本身实际上是同一个引用，所以这无论如何都没有影响。如果不希望改变原始引用，那么在不使用原始值作为键的情况下，需要同时更新地图中的引用。

# 在地图中查找值

在地图中查找值非常简单，因为我们提供了`has`方法。该方法接收一个键，并根据该键是否存储在映射中返回 true 或 false。

我认为这非常简单，但也非常有用。我们已经详细讨论过这个问题，所以我不会在这个问题上纠缠太久，但是对于检索键不是原始值的值，这里也存在同样的警告。如果您用一个匹配的对象调用`has`方法，但是它有一个不同的引用，它将返回 false。我们需要应用相同的模式，将引用存储到变量中，并在不改变引用的情况下更新引用，否则`has`方法也会出现意外的结果。

# 删除地图中的值

删除映射中的值与检索映射中的值是相同的 API。我们公开了`delete`方法，它接受一个参数，这个参数是您希望删除的键。

调用`delete`方法并传入一个有效的键会导致返回 true 并修改地图。正如您在示例中看到的，当我们传入一个不在 Map 中的键时，将返回 false，Map 保持不变。因为我们返回了该项是否被移除的指示，所以我们不能像处理`set`调用一样将`delete`调用链接在一起。这表明要删除一个值列表，我们需要反复调用`delete`方法来遍历它们。如果我们要从一个映射中移除所有的条目，我们就公开了`clear`方法，它从一个映射中移除所有的键和值。

这是清除任何键值对映射的简单方法。

# 遍历地图

我们基本上有 4 种不同的方法来遍历地图。我想把它们分成两类。在迭代器类别中，我们有`Map.Values`、`Map.Entries`和`Map.Keys`。这三个方法虽然返回不同的数据，但都返回迭代器，并且以相同的方式使用。接下来，我们将探索`Map.ForEach`方法，这是一种更传统的循环方式来迭代地图。让我们开始吧。

这看起来像很多代码，但是每个例子实际上是完全一样的，不同的是你从迭代器得到什么。让我们以一种简单的方式来分解它。迭代器允许我们调用`next`方法。我们接收回一个带有 value 属性的对象，该属性包含一个基于您调用的迭代方法的值，还有一个 done 属性，让您知道是否有其他项要迭代。您还可以看到带有 while 循环的模式，它允许我们使用循环来遍历项目。这要有用得多，当`done`变为真时跳出循环，使用 value 键执行一些逻辑。

对于`Map.Values`方法，我们只获得值本身作为值属性。对于`Map.Keys`，我们将只获取迭代器对象的 value 属性中的键。最后，对于`Map.Entries`，我们为 value 属性获取一个数组，其中第一个位置是键，第二个位置是值。每种方法都有不同的用例，但是关键的因素是理解迭代器的模式，然后决定是否需要键、值或者两者都需要。如果我们想使用更类似于 for 循环的东西呢？这就是`Map.ForEach`发挥作用的地方。

在这种情况下，我们能够调用`forEach`并传递一个回调函数，该函数作为第一个参数传递，即来自映射的值，第二个参数将是来自映射的键，最后一个参数是映射本身。如果您对`Array.ForEach`很熟悉，那么当您需要访问键和值，或者出于某种原因需要访问映射本身时，这将是一种很好的遍历映射的方式。

# 最后一个方法

没有一个好的地方来放置这个，它是所有方法中最简单的一个，但也是非常重要的。这是`size`方法。当我们调用这个方法时，它返回 Map 中条目的长度。

# 结论

与使用对象相比，在 JavaScript 中使用地图是一种奇妙的体验。当您处于需要维护排序的场景中时，这尤其有用，就像传统的数组一样，但是您需要在恒定的时间内提高查找的性能。如果您发现自己需要使用一个对象，但又想使用非原始键，那么地图是有意义的。

根据这篇[中的文章](https://medium.com/@bretcameron/how-javascript-maps-can-make-your-code-faster-90f56bf61d9d)(该文章试图提供一些关于地图与对象的性能测试)，在地图中查找项目要快 2.6 倍，添加条目要快 45.8 倍，删除一个项目要快 31 倍。根据这篇文章，它失败的地方是用一个慢了 5 倍的 for 循环向 Map 添加项目。当您考虑使用 Map 是否适合您的用例时，需要考虑一些有趣的结果。

*更内容于*[T5](http://plainenglish.io/)