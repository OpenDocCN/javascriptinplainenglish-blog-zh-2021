<html>
<head>
<title>Are generics a thing in Typescript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">泛型是Typescript中的东西吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-generics-a-thing-in-typescript-6f57b1c274fd?source=collection_archive---------10-----------------------#2021-02-16">https://javascript.plainenglish.io/are-generics-a-thing-in-typescript-6f57b1c274fd?source=collection_archive---------10-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eced" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用泛型意味着知道意想不到的事情！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0970581459c005e99c1dcafd441e4f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0BWMxLV2HXqHsAQK56Hag.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://unsplash.com/@the_roaming_platypus" rel="noopener ugc nofollow" target="_blank">timJ</a> via <a class="ae kv" href="https://unsplash.com/photos/ots0EOYuGtU" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (CC0)</figcaption></figure><p id="4009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Typescript中创建堆栈需要完成什么任务？很少。我们只需要一个类作为数组的包装。出于简单的原因，我们将忽略错误处理。下面是堆栈的基本结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个功能良好的常见堆栈。但是作为一个聪明人，你马上会发现Typescript中的这个堆栈根本不是类型安全的。这不是一个普通的。我打赌你通过发现<em class="lu"> any </em>的用法猜到了这一点。[1]要想出一个快速而肮脏的解决方案，我们可以切换到未知的<em class="lu"/>类型。但是这能让事情变得更好吗？不完全是。只是避免不负责任地访问堆栈元素的任何属性。</p><p id="2f6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更常见的需求是数字堆栈。为了满足这个要求，我们只需将<em class="lu">的类型任意</em>改为<em class="lu">号</em>。但是如果你需要一个文本类型的堆栈呢？当然只是复制粘贴代码，用<em class="lu">字符串</em>替换每次出现的<em class="lu">数字</em>。那么，其他类型甚至阶层呢？作为一个好的程序员意味着，你能够发现这是一个简单的违反<a class="ae kv" href="https://medium.com/unity-hub/unity-solid-s-single-responsibility-6707d9569e73" rel="noopener">单一责任原则</a>和<a class="ae kv" href="https://medium.com/next-level-source-code/do-you-follow-these-10-principles-for-good-programmers-1445727af447" rel="noopener">干</a>的法律(不要重复自己)。[2]</p><p id="4b99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对另一种类型采取相同的行动？这难道不是仿制药的一个例子吗？对我来说，是的！</p><h1 id="f678" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">仿制药拯救你</h1><p id="6d48" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">泛型人进入现场，让你意识到泛型的存在！</p><p id="8f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">泛型是可参数化的数据类型。在某种程度上类似于正常变量，但能够收集不同类型的值。但是泛型有所谓的<em class="lu">类型变量</em>来保存它们现在服务的类型。知道了这一点，我们就可以用一种通用的方法来重新定义我们的堆栈。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">T代表该类应该处理的具体数据类型。尽管约定描述泛型类型应该有T21，但这不是最好的选择。从另一个角度看实现揭示了真相。堆栈通过它保存的项目来定义自己。一个更好的名字应该是:<em class="lu"> TItem </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f048" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论你按什么键，你都会得到和你弹出的键相同的类型。这导致了泛型类型的定义。但是像生活中的一切一样:</p><blockquote class="ms mt mu"><p id="0bbb" class="kw kx lu ky b kz la jr lb lc ld ju le mv lg lh li mw lk ll lm mx lo lp lq lr ij bi translated">每个故事都有两面性[…]——乔纳森·爱德华兹</p></blockquote><p id="0c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段引文让我们得出结论，我们需要为<em class="lu"> TItem </em>传递一个类型。它只不过是一个变量。为数字创建一个堆栈意味着这样调用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lu">标题</em>替换为<em class="lu">号</em>。实例的每个泛型方法也将拥有类型<em class="lu">号</em>。你还需要一个字符串堆栈吗？然后，您可以使用与创建数字堆栈相同的方式来完成此操作，但使用另一种类型，为创建传递:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="893c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不能选择两个筹码吗？您也可以使用联合堆栈来实现，两者都接受:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关闭门，我们也可以做一个<em class="lu">任何</em>堆栈:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ae96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样，我们又在跑圈了！但是现在我们已经从文章的开头获得了一个可配置的原始堆栈变体。</p><p id="a6cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能需要一个默认的堆栈类型，因此也可以配置它。在这里，您可以创建它并根据您的需要定义<em class="lu"> TItem </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="abcc" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">在函数中键入参数</h1><p id="48c2" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">Typescript允许我们对其他类型使用泛型。当然，您首先想到的是接口！这没什么不同。相反，它几乎是相同的，因此非常直观:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，泛型和函数一起使用，而不是任何类或接口的一部分。如果这是您的愿望，您必须在泛型函数中定义类型参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="415f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子描述了传递的值的返回，没有改变，但是类型安全的。像这样调用函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为能够从构造函数中读取函数的泛型类型，所以没有必要明确提及类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="90a3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Typescript中的默认泛型</h1><p id="a18e" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">而不是使用您自己定义的泛型类型。Typescript附带了一些现成的泛型。最常见的一种:<em class="lu">偏&lt;T&gt;T11】。我打赌你这辈子已经见过一个了。如果没有，没时间担心，最好继续读下去。</em></p><p id="d948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简短的词将传递的类型的所有属性标记为可选，并允许您只初始化属性的子集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a0df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常数只描述整个对象的一些属性，而不是整个属性列表。可以访问未定义的属性，但是正如我提到的，当用<em class="lu">Partial&lt;T&gt;T13】创建一个对象时，没有必要定义它们。</em></p><p id="4768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lu">挑&lt;T&gt;T15】和<em class="lu">省略&lt;T&gt;T17】是两个有趣的家伙。它们允许您构建必须定义了某些属性的类型，或者分配一些属性。</em></em></p><p id="ed5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样非常重要的是要知道<em class="lu">记录&lt; Tkey，t value&gt;T19】。这定义了一个具有两种泛型类型的字典。例如:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="571f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过添加新的属性来扩展这个字典，只要它们遵循的排版是一对&lt;<em class="lu">字符串，数字&gt; </em>。</p><p id="4861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你现在很好奇，想要更深入地了解泛型类型的完整列表，你可以通过阅读关于实用程序类型的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank"> Typescript文档来实现你的愿望。[1]</a></p><h1 id="aa6c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="ef2f" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">通过使用泛型，您可以保持代码干净，避免冗余和重复。此外，您的代码是类型安全的。也包括单一责任原则和DRY法的保留。</p><p id="3fe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说出你的泛型类型，而不仅仅是<em class="lu"> T </em>，让它们变得容易理解，就像我用<em class="lu"> TItem </em>例子向你展示的那样。如果您的代码充满了<em class="lu"> T </em>，您将无法再识别差异。</p><p id="f6b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<a class="ae kv" href="https://medium.com/next-level-source-code/naming-variables-and-methods-write-better-code-part-2-5707e54250f1" rel="noopener">变量命名</a>相同的规则对于泛型类型的创建是有效的。</p><h2 id="2a18" class="my lw iq bd lx mz na dn mb nb nc dp mf lf nd ne mh lj nf ng mj ln nh ni ml nj bi translated">进一步阅读</h2><div class="nk nl gp gr nm nn"><a href="https://medium.com/next-level-source-code/naming-variables-and-methods-write-better-code-part-2-5707e54250f1" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">命名变量和方法-编写更好的代码第2部分</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">如何编写表达自己的代码，以便更好地使用命名进行编码</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kp nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://arnoldcode.medium.com/increase-annual-salary-with-these-3-simple-tactics-145f8bc03c60" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">用这三个简单的策略增加年薪</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">做他们梦想和噩梦的汽车！</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">arnoldcode.medium.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob kp nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://medium.com/agileinsider/comparison-of-scrum-vs-scrumban-vs-kanban-1d1d2b9a9fd5" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">Scrum与Scrumban、看板的比较</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">正确选择的快速指南！</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob kp nn"/></div></div></a></div><h2 id="106d" class="my lw iq bd lx mz na dn mb nb nc dp mf lf nd ne mh lj nf ng mj ln nh ni ml nj bi translated">参考</h2><p id="abeb" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">[1]泛型:<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/docs/handbook/generics.html</a><br/>[2]如何在类型脚本中使用泛型https://www . digital ocean . com/community/tutories/type script-泛型-in-typescript  <br/> [3]实用程序类型:<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">https://www . typescripttlang . org/docs/manual/Utility-type . html</a></p></div></div>    
</body>
</html>