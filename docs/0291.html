<html>
<head>
<title>Cleaner JavaScript with Destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有析构的更干净的JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cleaner-javascript-with-destructuring-98450192c2df?source=collection_archive---------7-----------------------#2021-01-17">https://javascript.plainenglish.io/cleaner-javascript-with-destructuring-98450192c2df?source=collection_archive---------7-----------------------#2021-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1e469bb4065278774b2df10969662041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kW7FGKsJVQ3e0_lI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@iurte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iker Urteaga</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我有点不高兴我花了这么长时间才意识到析构是如此的棒！我发现自己越来越多地将它用于数组和对象的基本任务，如解包，不必要的冗长任务，如分配默认值，或通过分配新的变量名赋予数据语义。每一种方法都有显而易见的方法，但我真的爱上了在保持代码整洁的同时，析构语法允许我表达的程度。它可以将一些非常棘手的操作变成一个命令行程序。</p><p id="d2ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在生产中使用析构语法之前，确保<a class="ae jz" href="https://caniuse.com/mdn-javascript_operators_destructuring" rel="noopener ugc nofollow" target="_blank">检查兼容性</a>并在必要时安装<a class="ae jz" href="https://babeljs.io/docs/en/babel-plugin-transform-destructuring" rel="noopener ugc nofollow" target="_blank">合适的工具</a>。</p><h1 id="bd1a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基本阵列解包</h1><p id="2511" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对于阵列</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2391" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const foo = ['zero', 'one', 'two', 'three'];</strong></span></pre><p id="63de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用析构来实现<strong class="kc io">变量赋值</strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4cde" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const [a, b, c, d] = foo;</strong></span><span id="1797" class="mk kz in mg b gy mp mm l mn mo">// is equivalent to<br/><strong class="mg io">const a = foo[0];<br/>const b = foo[1];<br/>const c = foo[2];<br/>const d = foo[3];</strong></span><span id="7bed" class="mk kz in mg b gy mp mm l mn mo">// in both cases<br/><strong class="mg io">a</strong> // 'zero'<br/><strong class="mg io">b</strong> // 'one'<br/><strong class="mg io">c</strong> // 'two'<br/><strong class="mg io">d</strong> // 'three</span></pre><p id="3a2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以通过让索引为空来忽略值</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="047d" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const [a, , , b] = foo;</strong></span><span id="14e2" class="mk kz in mg b gy mp mm l mn mo">// is equivalent to<br/><strong class="mg io">const a = foo[0];<br/>const b = foo[3];</strong></span><span id="d9a5" class="mk kz in mg b gy mp mm l mn mo">// in both cases<br/><strong class="mg io">a</strong> // 'zero'<br/><strong class="mg io">b</strong> // 'three'</span></pre><p id="686a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者<strong class="kc io">使用扩展语法将剩余值分配给变量</strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7443" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const [a, ...b] = foo;</strong></span><span id="1dc2" class="mk kz in mg b gy mp mm l mn mo">// is equivalent to<br/><strong class="mg io">const a = foo[0];<br/>const b = foo.slice(1);</strong></span><span id="a210" class="mk kz in mg b gy mp mm l mn mo">// in both cases<br/><strong class="mg io">a</strong> // 'zero'<br/><strong class="mg io">b</strong> // ['one', 'two', 'three']</span></pre><h1 id="1f3f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基本对象解包</h1><p id="f930" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对于该对象</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2437" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const bar = {<br/>  id: 11,<br/>  hidden: false,<br/>};</strong></span></pre><p id="9a2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用析构来实现<strong class="kc io">变量赋值</strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2e83" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const { id, hidden } = bar;</strong></span><span id="3c1d" class="mk kz in mg b gy mp mm l mn mo">// is equivalent to<br/><strong class="mg io">const id = bar.id;<br/>const hidden = bar.hidden;</strong></span><span id="5740" class="mk kz in mg b gy mp mm l mn mo">// in both cases<br/><strong class="mg io">id</strong> // 11<br/><strong class="mg io">hidden</strong> // false</span></pre><p id="8b66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以<strong class="kc io">将对象属性重命名为新变量</strong>。</p><p id="c89a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于该对象</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a1bf" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const user = {<br/>  id: 8164,<br/>  name: 'Tom',<br/>  active: true,<br/>};</strong></span></pre><p id="e6c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将对象属性重命名为</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6456" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const {<br/>  id: userId,<br/>  name: userName,<br/>  active: userIsActive,<br/>} = user;</strong></span><span id="9526" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">userId</strong> // 8164<br/><strong class="mg io">userName</strong> // 'Tom'<br/><strong class="mg io">userIsActive</strong> // true</span></pre><p id="aa0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">避免与其他变量冲突或赋予数据语义。</p><h1 id="4ac8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">分配默认值</h1><p id="bbfb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">默认值在数组和对象中是一样的。默认值适用于返回值为<code class="fe mq mr ms mg b">undefined</code>的情况。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8e15" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const skills = [];<br/>const [firstSkill = 'Still learning!'] = skills;<br/></strong></span><span id="8775" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">const projects = {};<br/>const { firstProject = 'Still working!' } = projects;<br/></strong></span><span id="056c" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">firstSkill</strong> // 'Still learning!'<br/><strong class="mg io">firstProject</strong> // 'Still working!'</span></pre><h1 id="d5cf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一些使用案例</h1><h2 id="5099" class="mk kz in bd la mt mu dn le mv mw dp li kl mx my lm kp mz na lq kt nb nc lu nd bi translated">解包、重命名和分配默认值</h2><p id="4191" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们能做到这三点吗？为什么？是的，我们可以。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d5a4" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const obj = {<br/>  foo: 1,<br/>  bar: 0,<br/>  baz: undefined,<br/>};</strong></span><span id="c7fe" class="mk kz in mg b gy mp mm l mn mo">// unpack, rename, and assign defaults<strong class="mg io"><br/>const {<br/>  foo: apple = 500,<br/>  bar: banana = 501,<br/>  baz: orange = 502,<br/>  qux: mango = 503,<br/>} = obj;</strong></span><span id="1514" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">apple</strong> // 1<br/><strong class="mg io">banana</strong> // 0<br/><strong class="mg io">orange</strong> // 502<br/><strong class="mg io">mango</strong> // 503</span></pre><p id="de50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个接一个:别名<code class="fe mq mr ms mg b">apple</code>按照预期从<code class="fe mq mr ms mg b">foo</code>解析出值<code class="fe mq mr ms mg b">1</code>。<code class="fe mq mr ms mg b">banana</code>也解析<code class="fe mq mr ms mg b">bar</code>的值，但值为零。<code class="fe mq mr ms mg b">0</code>的falsy值不是应该降回默认值吗？嗯，不……请记住“默认值应用于返回值为<code class="fe mq mr ms mg b">undefined</code>的情况”，不一定是falsy。这就把我们带到了<code class="fe mq mr ms mg b">orange</code>，它实际上解析了一个值<code class="fe mq mr ms mg b">undefined</code>，并返回到默认值<code class="fe mq mr ms mg b">502</code>。</p><p id="6637" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于<code class="fe mq mr ms mg b">mango</code>，如何解包一个不存在的对象属性？如果我们回到JavaScript 101，我们会回忆起未声明和未初始化的变量返回一个值<code class="fe mq mr ms mg b">undefined</code>，所以在这种情况下，我们实际上可以查询<code class="fe mq mr ms mg b">qux</code>，并依靠我们设置的默认值来捕捉任何不存在它的实例。没有<code class="fe mq mr ms mg b">if</code>语句、三元、布尔或逻辑运算符；纯粹的JS魔法！</p><h2 id="2f90" class="mk kz in bd la mt mu dn le mv mw dp li kl mx my lm kp mz na lq kt nb nc lu nd bi translated">解包作为函数参数传递的对象</h2><p id="60e5" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">析构传递给函数参数的参数可以避免在函数中使用任意参数名。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8b0d" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const book = {<br/>  title: 'Some Great Book',<br/>  author: {<br/>    firstName: 'Seymour',<br/>    lastName: 'Penman',<br/>  },<br/>};</strong></span><span id="5895" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">function getAuthorName({ author: { firstName, lastName }) {<br/>  return `The author is ${firstName} ${lastName}`;<br/>};</strong></span><span id="2d0b" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">getAuthorName(book);</strong> // 'The author is Seymour Penman'</span></pre><p id="adf3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我发现这在处理运行在对象数组上的<strong class="kc io">数组方法时特别有用。对于阵列</strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ace8" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const arrOfObjs = [<br/>  { name: 'foo' },<br/>  { name: 'bar' },<br/>  { name: 'baz' },<br/>];</strong></span></pre><p id="d776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以析构回调的参数</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9d47" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">arrOfObjs.forEach(({ name }) =&gt; console.log(name));</strong></span></pre><p id="3193" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而不是</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="eaac" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">arrOfObjs.forEach((i) =&gt; console.log(i.name));</strong></span></pre><p id="785e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，在这样一个简单的例子中，这没什么大不了的，我选择<code class="fe mq mr ms mg b">i</code>只是为了唱反调。<code class="fe mq mr ms mg b">i</code>可能表示项目，可能是索引，可能是整数；看看周围的代码就不难发现，但是我真的很喜欢这种析构让我们不必考虑选择一个全新的(但是希望是语义上的)参数名。</p><h2 id="33bf" class="mk kz in bd la mt mu dn le mv mw dp li kl mx my lm kp mz na lq kt nb nc lu nd bi translated">组合数组和对象析构</h2><p id="912b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对于(不寻常的)阵列</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="88e4" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const favoriteColors = [<br/>  { possibilities: ['lilac', 'aqua', 'coral', 'gold'] },<br/>  { rank: 1, color: 'aqua' },<br/>  { rank: 2, color: 'gold' },<br/>  { rank: 3, color: 'coral' },<br/>];</strong></span></pre><p id="7dd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比方说，在代码的其他地方，我们需要引用颜色aqua，这是一个嵌套的可能性数组，但如果没有指定，则只返回黑色和白色，以及rank 1后面的每个对象。在一个奇怪的阵列上完成一项奇怪的任务，但我们可以轻松地完成它。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e931" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const [<br/>  { possibilities = ['black', 'white']: palette },<br/>  { color: favoriteColor},<br/>  ...rest<br/>] = favoriteColors;</strong></span><span id="cd13" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">palette</strong> // ['lilac', 'aqua', 'coral', 'gold']<br/><strong class="mg io">favoriteColor</strong> // 'aqua'<br/><strong class="mg io">rest</strong> // [{ rank: 2, color: 'gold' }, { rank: 3, color: 'coral' }]</span></pre><p id="6b0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分解一下，我们的析构赋值中的第一项在第一个索引位置获取对象，并寻找一个名为<code class="fe mq mr ms mg b">possibilities</code>的属性。然后，我们为它分配一个包含两个项目<code class="fe mq mr ms mg b">black</code>和<code class="fe mq mr ms mg b">white</code>的数组的默认值，然后为了语义的原因，将其重命名为<code class="fe mq mr ms mg b">palette</code>。</p><p id="862e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二项从对象中解包<code class="fe mq mr ms mg b">color</code>属性，然后将其重命名为<code class="fe mq mr ms mg b">favoriteColor</code>。</p><p id="7a5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一项将数组中剩余的对象分配给一个名为<code class="fe mq mr ms mg b">rest</code>的变量。</p><p id="8f5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，这不是组织或排列某人最喜欢的颜色的理想方式，但我想说明，无论原始数据有多古怪，组合数组和对象析构都可以保持整洁。</p><h2 id="b1c9" class="mk kz in bd la mt mu dn le mv mw dp li kl mx my lm kp mz na lq kt nb nc lu nd bi translated">深度嵌套的值</h2><p id="f297" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">假设我们需要深入到一个对象中寻找一个值。</p><p id="cff4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于该对象</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2c00" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const data = {<br/>  post: {<br/>    fields: {<br/>      slug: 'a-blog-post',<br/>    },<br/>    type: 'technology',<br/>    metadata: {<br/>      title: 'A Blog Post',<br/>      date: 2021-01-01,<br/>      credits: [<br/>        { name: 'Generic Namesake', role: 'author' },<br/>        { name: 'Universal Surname', role: 'editor' },<br/>      ],<br/>      keywords: ['javascript', 'destructuring'],<br/>    },<br/>  },<br/>};</strong></span></pre><p id="15fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们需要访问这段代码，我们可以如下进行析构。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b8ba" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const { post: { fields: slug } } = data;</strong></span><span id="5526" class="mk kz in mg b gy mp mm l mn mo">// is equivalent to<br/><strong class="mg io">const slug = data.post.fields.slug;</strong></span><span id="07d9" class="mk kz in mg b gy mp mm l mn mo">// in both cases<br/><strong class="mg io">slug</strong> // 'a-blog-post'</span></pre><p id="c897" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，我们可以提取多个参数，并添加一些换行符以提高可读性。让我们先析构一次，对信用执行一个数组方法，然后在回调中再次析构信用。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="96fc" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">const {<br/>  post: {<br/>    fileds: { slug },<br/>    metadata: {<br/>      title: postTitle, </strong>// rename<strong class="mg io"><br/>      date: publishDate, </strong>// rename<strong class="mg io"><br/>      credits: postCredits, </strong>// rename<strong class="mg io"><br/>    },<br/>  },<br/>} = data;</strong></span><span id="121d" class="mk kz in mg b gy mp mm l mn mo">// check for role of `editor` and that name exists<br/><strong class="mg io">const hasEditor = postCredits.some(<br/>  ({ name, role }) =&gt; role === 'editor' &amp;&amp; name<br/>);</strong></span></pre><h2 id="9535" class="mk kz in bd la mt mu dn le mv mw dp li kl mx my lm kp mz na lq kt nb nc lu nd bi translated">解析从函数返回的数组</h2><p id="e6e3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对于那些使用过React的“使用状态”钩子的人来说，这个可能看起来很熟悉。简单地说，从函数返回的数组可以在一行中解析。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="177e" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">function foo() {<br/>  return [1, 2];<br/>};</strong></span><span id="d7bb" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">const [a, b] = foo();</strong></span></pre></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h1 id="6c15" class="ky kz in bd la lb nm ld le lf nn lh li lj no ll lm ln np lp lq lr nq lt lu lv bi translated">包扎</h1><p id="5798" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">希望此时你也同意解构JavaScript是很棒的。它总是正确的答案吗？取决于项目和团队。难道只是句法糖。可能吧，但对我来说，任何维护代码可读性的解决方案都值得长期研究和投资。将来调试你代码的人会感谢你……可能是你。</p></div></div>    
</body>
</html>