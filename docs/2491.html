<html>
<head>
<title>Primitive and Reference Data Types in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原始和引用数据类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/primitive-and-reference-data-types-in-javascript-2b3916cae1ef?source=collection_archive---------12-----------------------#2021-05-22">https://javascript.plainenglish.io/primitive-and-reference-data-types-in-javascript-2b3916cae1ef?source=collection_archive---------12-----------------------#2021-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d1f5349b3c0f4da3f7db48651f861fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEaqAYtmDdA-Mn8GQk_gjg.jpeg"/></div></div></figure><p id="472b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的概述中，您会看到一个基本数据类型和引用数据类型的列表，每个类型都有一个示例。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/2a7000196c3976b1026826694fe7e104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1Cacf_OSbsQ1rYYaQsXYA.png"/></div></div></figure><p id="5a88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们指出记忆行为的区别之前，让我们仔细看看这些类型。</p><p id="fd06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用检查的<em class="ky">类型检查任何变量的数据类型。</em></p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="551b" class="le lf in la b gy lg lh l li lj">let example = "hello";</span><span id="991b" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "string"</span></pre><h2 id="64d1" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">原始数据类型</h2><p id="1c43" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">数据类型<strong class="jx io"> null </strong>表示有对象缺失或无效。</p><blockquote class="mh mi mj"><p id="9a8e" class="jv jw ky jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">特殊的<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原语</a>类型对其值有额外的用法:如果对象没有被继承，那么<code class="fe mo mp mq la b">null</code>被显示；</p></blockquote><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="4c54" class="le lf in la b gy lg lh l li lj">let example = null;</span><span id="e211" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "object"</span></pre><p id="5e0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">未定义</strong>顾名思义，值尚未定义。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="1fac" class="le lf in la b gy lg lh l li lj">let example;<br/>let count = 6;</span><span id="b8a6" class="le lf in la b gy lk lh l li lj">if (count &gt; 7) {<br/>    example = "gets a value";<br/>}</span><span id="9d5c" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "undefined"</span></pre><p id="71dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">布尔</strong>只能有两个值<em class="ky">真</em>或<em class="ky">假</em>。它经常被用来写条件来控制程序的流程。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="d3a1" class="le lf in la b gy lg lh l li lj">let example = true;<br/>if (example) {<br/>    example = false;<br/>}</span><span id="9124" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "boolean"</span></pre><p id="fc34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">数字</strong>表示一个介于(2⁵1)和2⁵1)之间的浮点数。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="9633" class="le lf in la b gy lg lh l li lj">let example = 33; // or something more precise 33.33</span><span id="fb3d" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "number"</span></pre><p id="c3e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">字符串</strong>是用于表示文本的字符序列，例如字母、数字、特殊字符和控制字符。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="f0f0" class="le lf in la b gy lg lh l li lj">let example = "hello";</span><span id="03b0" class="le lf in la b gy lk lh l li lj">console.log(typeof example);<br/>// outputs: &gt; "string"</span></pre><p id="915b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io"> BigInt </strong>保存数值，如果您需要处理超过数据类型Number的安全整数限制的非常大的数字，这种数据类型是相关的。您可以查看带有<em class="ky">数字的最大安全整数。MAX_SAFE_INTEGER </em></p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="5886" class="le lf in la b gy lg lh l li lj">console.log(Number.MAX_SAFE_INTEGER);<br/>// outputs: 9007199254740991</span><span id="0121" class="le lf in la b gy lk lh l li lj"><strong class="la io">let example</strong><strong class="la io"> = 33n ** 33n;</strong></span><span id="c5a5" class="le lf in la b gy lk lh l li lj"><strong class="la io">console.log(typeof example);<br/>// outputs: &gt; "bigint"</strong></span><span id="0d02" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>// outputs: &gt; 129110040087761027839616029934664535539337183380513n</span><span id="4050" class="le lf in la b gy lk lh l li lj">let example2 = 33 ** 33; // number data type</span><span id="98c0" class="le lf in la b gy lk lh l li lj">console.log(example2);<br/>// outputs: &gt; 1.2911004008776101e+50</span><span id="c275" class="le lf in la b gy lk lh l li lj">let example3 = 33 ** 33n; // number and bigint is not mixable</span><span id="9e52" class="le lf in la b gy lk lh l li lj">console.log(example3);<br/>// outputs: "Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions"</span></pre><p id="7d87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">符号</strong>是一种有保证的方式，以确保该值是唯一且不可变的。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="6d6c" class="le lf in la b gy lg lh l li lj"><strong class="la io">let example = Symbol("hello");</strong></span><span id="2923" class="le lf in la b gy lk lh l li lj"><strong class="la io">console.log(typeof example);<br/>// outputs: &gt; "symbol"</strong></span><span id="61a8" class="le lf in la b gy lk lh l li lj">let example2 = Symbol("hello");</span><span id="92ad" class="le lf in la b gy lk lh l li lj">console.log(example === example2);<br/>// outputs: &gt; false</span></pre><h2 id="44c4" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">参考数据类型</h2><p id="e7f3" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">数据类型<strong class="jx io">对象</strong>保存了一组无序的数据和指令的键值对。可以用<code class="fe mo mp mq la b">new Object()</code>或字面语法<code class="fe mo mp mq la b">{}</code>创建</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="84b8" class="le lf in la b gy lg lh l li lj"><strong class="la io">let example = {hello: "world"}; </strong></span><span id="c1c0" class="le lf in la b gy lk lh l li lj">// same as...<br/>let example2 = new Object();<br/>example2.hello = "world";</span><span id="2554" class="le lf in la b gy lk lh l li lj"><strong class="la io">console.log(typeof example);<br/>// outputs: &gt; "object"</strong></span><span id="29b0" class="le lf in la b gy lk lh l li lj">// console.dir gives you more insights about the inheritance in the // dev console -&gt; see the image below<br/>console.dir(example);</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/9b2395c9c10f9730589b3cb3c6fd59d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbFhmBZs8D2HTNZ_IrqIFg.png"/></div></div></figure><p id="8f41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据类型<strong class="jx io">函数</strong>可以封装一段代码，可以自我继承或者被其他代码调用。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="96d2" class="le lf in la b gy lg lh l li lj">// arrow functions are a compact alternative to function<br/><strong class="la io">let example = () =&gt; 2 + 2;</strong></span><span id="75a9" class="le lf in la b gy lk lh l li lj">// same as...<br/>function example2() {<br/>    return 2 + 2;<br/>}</span><span id="eec2" class="le lf in la b gy lk lh l li lj"><strong class="la io">console.log(typeof example);<br/>// outputs: &gt; "function"</strong></span><span id="7f10" class="le lf in la b gy lk lh l li lj">// insights about the inheritence and scopes -&gt; see the image below<br/>console.dir(example);</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/925d25db6814f6b4b43ee4ba49c2060a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taEWfr3yMWJnd8Y3WtVtDQ.png"/></div></div></figure><p id="7d06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于数据类型的更多细节，请访问Mozilla的优秀文档<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="077c" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">原始类型的内存行为</h2><p id="4b00" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">对于每个基本类型，该值将总是单独保存，即使您将变量example保存到example2中。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="c6aa" class="le lf in la b gy lg lh l li lj">let example = "hello";<br/>let example2 = example;</span><span id="89cc" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>console.log(example2);</span><span id="1a2c" class="le lf in la b gy lk lh l li lj">// outputs: &gt; "hello"<br/>// outputs: &gt; "hello"</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/6c8f68b0cf9eb0b2e0b672296a102740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*zREs-WBhepdMMeMVIGRn1w.png"/></div></figure><p id="1e9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的关键点是变量example的变化不会影响example2，因为值是复制的。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="4ad7" class="le lf in la b gy lg lh l li lj">example = "hello world";</span><span id="7669" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>console.log(example2);</span><span id="a58a" class="le lf in la b gy lk lh l li lj">// outputs: &gt; "hello world"<br/>// outputs: &gt; "hello"</span></pre><h2 id="f526" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">引用类型的内存行为</h2><p id="ddcf" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">与基本类型相反，引用类型顾名思义只保存对值的引用，在本例中是对象。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="220c" class="le lf in la b gy lg lh l li lj">let example = {hello: "world"};<br/>let example2 = example;</span><span id="f78f" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>console.log(example2);</span><span id="b8b0" class="le lf in la b gy lk lh l li lj">// outputs: &gt; {hello: "world"}<br/>// outputs: &gt; {hello: "world"}</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/a26c287b166a263ac8fa18825f41cdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74KS3ozhdBXcRTO500cfog.png"/></div></div></figure><p id="b324" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的关键点是变量example的变化并不影响example2，因为该值只是被引用。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="ad45" class="le lf in la b gy lg lh l li lj">example.additionalField = 33;</span><span id="b6d6" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>console.log(example2);</span><span id="e7bb" class="le lf in la b gy lk lh l li lj">// outputs: &gt; {hello: "world", additionalField: 33}<br/>// outputs: &gt; {hello: "world", additionalField: 33}</span></pre><p id="3a40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您将您的引用移交给一个函数，您的原始对象会受到更改的影响。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="2890" class="le lf in la b gy lg lh l li lj">let example = {hello: "world"};</span><span id="9938" class="le lf in la b gy lk lh l li lj">const exampleFunction = (object) =&gt; {<br/>  object.number = 33;<br/>  <br/>  return object;<br/>}</span><span id="cce7" class="le lf in la b gy lk lh l li lj">exampleFunction(example);</span><span id="898a" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>// outputs: &gt; {hello: "world", number: 33}</span></pre><p id="279e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过使用spread操作符轻松解决这个问题，并将副本保存到一个新变量中。你可以阅读更多关于传播运营商<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><pre class="ku kv kw kx gt kz la lb lc aw ld bi"><span id="0b0c" class="le lf in la b gy lg lh l li lj">let example = {hello: "world"};</span><span id="b7bf" class="le lf in la b gy lk lh l li lj">const exampleFunction = (object) =&gt; {<br/>  const newObject = <strong class="la io">{...object}</strong>;<br/>  newObject.number = 333;<br/>  console.log(newObject);<br/>  <br/>  return object;<br/>}</span><span id="6e15" class="le lf in la b gy lk lh l li lj">exampleFunction(example);</span><span id="59fd" class="le lf in la b gy lk lh l li lj">console.log(example);<br/>// outputs: &gt; {hello: "world", number: 33}<br/>// outputs: &gt; {hello: "world"}</span></pre><p id="b1aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，用<strong class="jx io"> new </strong>关键字创建的几乎所有东西都是一个对象的实例，数组也是如此，不管你是通过调用<code class="fe mo mp mq la b">new Array()</code>还是仅仅通过<code class="fe mo mp mq la b">[]</code>来创建它们。</p><p id="b2e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望我对基本类型和引用类型做了全面的介绍。欢迎在评论中写下你的任何问题！</p><p id="e204" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ky">更多内容请看</em><a class="ae mn" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>