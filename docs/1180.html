<html>
<head>
<title>Hapi and TypeScript— splitting routes into multiple files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈比神和TypeScript—将路线分割成多个文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-hapi-and-typescript-routes-da37dfc324ca?source=collection_archive---------9-----------------------#2021-03-12">https://javascript.plainenglish.io/more-hapi-and-typescript-routes-da37dfc324ca?source=collection_archive---------9-----------------------#2021-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="de73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-with-hapi-73af8cc81118">上次我们离开的时候</a>，服务器只有一个单独的路由，而且都在一个文件里。这是一个不错的开始，但它不完全是可扩展的。让我们从外部文件添加一些路线。</p><p id="77ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将选择类似于传统的“你好世界”的东西。我们会有一个路由，<code class="fe km kn ko kp b">/hello</code>，上面会写着“Hello World”。我们还将在“那个”的“下面”增加一条路线，<code class="fe km kn ko kp b">/hello/name</code>，它将迎接<code class="fe km kn ko kp b">name</code>。</p><p id="bcb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们这里产生的文件都在<a class="ae kl" href="https://github.com/arafel/hapi-typescript" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>里。</p><h1 id="6da4" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">测试一下！</h1><p id="b609" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">当然，由于我们正在添加新的功能，我们知道什么是第一位的…好消息是，这次我们根本不需要做任何设置，我们可以直接使用测试文件。</p><p id="f83e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">test/hello.test.ts</code>:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="5be6" class="mb kr iq kp b gy mc md l me mf">import { Server } from "@hapi/hapi";<br/>import { describe, it, beforeEach, afterEach } from "mocha";<br/>import { expect } from "chai";<br/><br/>import { init } from "../src/server";<br/><br/>describe("server greets people", async () =&gt; {<br/>	let server: Server;<br/><br/>	beforeEach(() =&gt; {<br/>		server = await init();<br/>	})<br/>	afterEach(() =&gt; {<br/>		await server.stop();<br/>	});<br/><br/>	it("says hello world", async () =&gt; {<br/>		const res = await server.inject({<br/>			method: "get",<br/>			url: "/hello"<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>		expect(res.result).to.equal("Hello World");<br/>	});<br/><br/>	it("says hello to a person", async () =&gt; {<br/>		const res = await server.inject({<br/>			method: "get",<br/>			url: "/hello/Tom"<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>		expect(res.result).to.equal("Hello Tom");<br/>	});<br/>})</span></pre><p id="0a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进口产品大同小异。事实上，几乎所有这些都是与<code class="fe km kn ko kp b">index</code>测试相同的结构——唯一真正的区别是我们在一个<code class="fe km kn ko kp b">describe</code>块中有两个测试。</p><p id="2b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然它们如此相似，我就假设这是可以理解的，然后继续。但在此之前，先检查一下它是否失败:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="3138" class="mb kr iq kp b gy mc md l me mf">server greets people<br/>    1) says hello world<br/>    2) says hello to a person<br/><br/>  smoke test<br/>    ✓ index responds<br/><br/><br/>  1 passing (70ms)<br/>  2 failing</span></pre><p id="ac81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，这正是我们所期望的，但失败了。向前…</p><h1 id="0656" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">编码吧！</h1><h2 id="4cc7" class="mb kr iq bd ks mg mh dn kw mi mj dp la jy mk ml le kc mm mn li kg mo mp lm mq bi translated">路线</h2><p id="1cbe" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">同样，这次没有设置工作，只有代码。直入主题—我们希望将这些路线保存在单独的文件中。使用明显的名称…</p><p id="b140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">src/hello.ts</code>:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="5e0d" class="mb kr iq kp b gy mc md l me mf">import { Request, ResponseToolkit, ResponseObject, ServerRoute } from "@hapi/hapi";<br/><br/>async function sayHello(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>  const name: string = request.params.name || "World";<br/>  const response = h.response("Hello " + name);<br/>  response.header('X-Custom', 'some-value');<br/>  return response;<br/>}<br/><br/>export const helloRoutes: ServerRoute[] = [<br/>  {<br/>    method: "GET",<br/>    path: "/hello",<br/>    handler: sayHello<br/>  },<br/>  {<br/>    method: "GET",<br/>    path: "/hello/{name}",<br/>    handler: sayHello<br/>  }<br/>];</span></pre><p id="86d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，这个有很多我们以前没见过的类型。忽略我们上次遇到的<code class="fe km kn ko kp b">Request</code>型，我们刚刚遇到:</p><ul class=""><li id="accd" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><code class="fe km kn ko kp b"><a class="ae kl" href="https://hapi.dev/api/?v=20.1.0#response-toolkit" rel="noopener ugc nofollow" target="_blank">ResponseToolkit</a></code> -如果你没有使用<a class="ae kl" href="https://github.com/hapijs/vision" rel="noopener ugc nofollow" target="_blank"> Vision </a>来渲染模板，工具包是你通常用来发送你的响应的东西。您可以生成如上所示的响应。</li><li id="7e7e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><code class="fe km kn ko kp b"><a class="ae kl" href="https://hapi.dev/api/?v=20.1.0#response-object" rel="noopener ugc nofollow" target="_blank">ResponseObject</a></code>是<code class="fe km kn ko kp b">ResponseToolkit</code>产生的东西——看起来很合理，对吗？里面的很多东西你可以不去管。您可能需要像<code class="fe km kn ko kp b"><a class="ae kl" href="https://hapi.dev/api/?v=20.1.0#-responsecodestatuscode" rel="noopener ugc nofollow" target="_blank">response.code</a></code>这样的东西来显式设置状态代码。</li><li id="928d" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><code class="fe km kn ko kp b"><a class="ae kl" href="https://hapi.dev/api/?v=20.1.0#route-options" rel="noopener ugc nofollow" target="_blank">ServerRoute</a></code>顾名思义，是在服务器上定义的一条路线。上面的路线非常简单HTTP方法、路径和处理它的函数。</li></ul><p id="ad1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在路线定义中，<code class="fe km kn ko kp b">/hello/{name}</code>告诉hapi在<code class="fe km kn ko kp b">/hello/</code>之后捕获路径组件，并将其放在<code class="fe km kn ko kp b">request.params</code>对象中。</p><p id="2db1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你所需要做的，在这里你开始看到hapi和Express之间的一些区别——已经包含和处理了主体/请求解析，包含了电池，不需要插件。这使得使用相同的函数来处理两个路由变得简单。</p><p id="b7b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要提示—在现实生活中，<strong class="jp ir">不要</strong>简单地获取用户参数并回显它们。使用类似<a class="ae kl" href="https://hapi.dev/module/hoek/api/?v=9.1.1#escapehtmlstring" rel="noopener ugc nofollow" target="_blank"> Hoek的escapeHtml() </a>的东西。</p><h2 id="8c0e" class="mb kr iq bd ks mg mh dn kw mi mj dp la jy mk ml le kc mm mn li kg mo mp lm mq bi translated">计算机网络服务器</h2><p id="b326" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">将这些路由插入服务器很简单。导入路线数组:</p><p id="4b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">src/server.ts</code>:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="85b2" class="mb kr iq kp b gy mc md l me mf">import { helloRoutes } from "./hello";</span></pre><p id="4ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将其添加到服务器:</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="28ca" class="mb kr iq kp b gy mc md l me mf">server.route(helloRoutes);</span></pre><p id="cc43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我们应该完成了。我们当然要知道…</p><pre class="lt lu lv lw gt lx kp ly lz aw ma bi"><span id="f559" class="mb kr iq kp b gy mc md l me mf">$ yarn test<br/>yarn run v1.22.10<br/>$ NODE_ENV=test mocha -r ts-node/register test/**/*.test.ts<br/><br/><br/>  server greets people<br/>    ✓ says hello world<br/>    ✓ says hello to a person<br/><br/>  smoke test<br/>    ✓ index responds<br/><br/><br/>  3 passing (63ms)<br/><br/>✨  Done in 3.05s.</span></pre><p id="d381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美！</p></div></div>    
</body>
</html>