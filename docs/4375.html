<html>
<head>
<title>TypeScript Advanced: Mapped and Conditional Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级:映射类型和条件类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-advanced-mapped-and-conditional-types-2d10c96042fe?source=collection_archive---------0-----------------------#2021-09-01">https://javascript.plainenglish.io/typescript-advanced-mapped-and-conditional-types-2d10c96042fe?source=collection_archive---------0-----------------------#2021-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7bafab185daf876059eeec5eddb6f908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*7Zh4wEiM_3t-6XPCAfC7aA.png"/></div></figure><p id="65ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我修订TypeScript高级文档后的发现的延续。在本文中，我们将关注更强大的东西，它允许我们创建更复杂的类型，如将旧类型映射到新类型(<strong class="jw ir">映射类型)</strong>，向我们的类型(<strong class="jw ir">条件类型)</strong>添加额外的约束，并最终通过将<strong class="jw ir">映射类型</strong>和<strong class="jw ir">条件类型</strong>组合在一起来创建真正有用的类型。别说了，我们开始吧！</p><h2 id="defb" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated"><strong class="ak">映射类型</strong></h2><p id="8d20" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">一般来说，映射类型是基于“旧的”、已经存在的类型创建的类型。一个典型的例子是，当我们有一些接口，并希望拥有完全相同的属性，但却是可选的</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8445" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们应该映射类型，而不是重新定义所有接口。为此，我们可以在这里使用已经定义的实用程序类型<code class="fe lw lx ly lz b">Parital&lt;T&gt;</code>，<code class="fe lw lx ly lz b">T</code>是我们的接口(<code class="fe lw lx ly lz b">Car</code>)</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e1e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了这种方法更快、更干燥(我们不需要两次定义完全相同的接口)的事实之外，它还防止了我们在每次更新<code class="fe lw lx ly lz b">Car</code>接口时出现诸如打字错误或忘记更新<code class="fe lw lx ly lz b">CarPartial</code>接口之类的错误。</p><p id="254a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了<code class="fe lw lx ly lz b">Partial&lt;T&gt;</code>之外，我们通常用于映射类型的其他接口有</p><ul class=""><li id="dcf0" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe lw lx ly lz b">Readonly&lt;T&gt;</code>使所有<code class="fe lw lx ly lz b">T</code>类型属性不可更改</li></ul><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><ul class=""><li id="1137" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe lw lx ly lz b">Required&lt;T&gt;</code>与<code class="fe lw lx ly lz b">Partial&lt;T&gt;</code>相反，使所有<code class="fe lw lx ly lz b">T</code>类型属性成为必需</li></ul><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><ul class=""><li id="8f93" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe lw lx ly lz b">NonNullabel&lt;T&gt;</code>使所有属性不可为空</li></ul><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5130" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以创建自己的实用程序类型，例如与<code class="fe lw lx ly lz b">NonNullabel&lt;T&gt;</code>相反的<code class="fe lw lx ly lz b">Nullable&lt;T&gt;</code>,使所有属性都可以为空</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="afb1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe lw lx ly lz b">line 8</code>中，我们从类型<code class="fe lw lx ly lz b">T</code>中取出每个属性<code class="fe lw lx ly lz b">P</code>，并赋予完全相同的类型<code class="fe lw lx ly lz b">T[P]</code>，但也考虑到了<code class="fe lw lx ly lz b">null</code>的值。</p><p id="d19a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">用给定的键列表创建一个类型</strong></p><p id="e2e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一个有用的例子是创建一个具有几个属性的类型<code class="fe lw lx ly lz b">T1</code>,我们从另一个类型<code class="fe lw lx ly lz b">Keys</code>获取这些属性，后者保存一个键列表</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5dbd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以使用已经定义的实用程序类型<code class="fe lw lx ly lz b">Record&lt;K, T&gt;</code></p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h2 id="f0df" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">条件类型</h2><p id="e0a9" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">在条件类型的一般语法中，三元运算符非常相似</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="6953" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，如果类型<code class="fe lw lx ly lz b">T</code>扩展了类型<code class="fe lw lx ly lz b">U</code>，那么该类型将是<code class="fe lw lx ly lz b">X</code>，否则，它将是<code class="fe lw lx ly lz b">Y</code>，基于此，我们可以编写一个类型，将泛型类型<code class="fe lw lx ly lz b">T</code>与其中一个JavaScript类型进行比较，如果是相同的类型，则返回。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ca71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还可以使用<code class="fe lw lx ly lz b">extends</code>关键字作为泛型类型的约束，例如，假设我们想要创建一个返回数组长度的泛型类型<code class="fe lw lx ly lz b">Length&lt;T&gt;</code>，那么类型<code class="fe lw lx ly lz b">T</code>必须是一个数组。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h2 id="4cdb" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated">分配条件类型</h2><blockquote class="mj mk ml"><p id="ae5c" class="ju jv mm jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated">被检查类型为裸类型参数的条件类型称为<strong class="jw ir">分配条件</strong> <em class="iq">类型</em>。</p><p id="0690" class="ju jv mm jw b jx jy jz ka kb kc kd ke mn kg kh ki mo kk kl km mp ko kp kq kr ij bi translated">—打字稿文档</p></blockquote><p id="9700" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如:</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="24ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它是如何解析类型的？<code class="fe lw lx ly lz b">TypeName&lt;T&gt;</code>其中<code class="fe lw lx ly lz b">T extends U ? X : Y</code>并且如果<code class="fe lw lx ly lz b">T</code>有<code class="fe lw lx ly lz b">string | () =&gt; void</code>，那么它将被解析为<code class="fe lw lx ly lz b">(string extends U ? X : Y) | (() =&gt; void extends U ? X : Y)</code></p><p id="f45f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个使用条件类型和分布条件类型的例子可以是泛型类型<code class="fe lw lx ly lz b">Get&lt;T&gt;</code>，其中<code class="fe lw lx ly lz b">T</code>可以是<code class="fe lw lx ly lz b">object</code>或<code class="fe lw lx ly lz b">array</code>，这取决于我们使用的是<code class="fe lw lx ly lz b">GetProperty&lt;T&gt;</code>还是<code class="fe lw lx ly lz b">GetProperties&lt;T&gt;</code>类型</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2618" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意<code class="fe lw lx ly lz b">line 19</code>即使我们将<code class="fe lw lx ly lz b">string[]</code>作为第二个参数传递，它也解析为<code class="fe lw lx ly lz b">GetProperties&lt;string&gt;</code>，这是因为我们在<code class="fe lw lx ly lz b">line 3</code>中使用了<code class="fe lw lx ly lz b">T[number]</code>。我们利用了这样一个事实:在这一步，我们知道类型<code class="fe lw lx ly lz b">T</code>是一个<code class="fe lw lx ly lz b">array</code>类型(<code class="fe lw lx ly lz b">T extends any[]</code>返回<code class="fe lw lx ly lz b">true</code>)，我们可以使用<code class="fe lw lx ly lz b">array</code>的一些特定属性。</p><h2 id="3dae" class="ks kt iq bd ku kv kw dn kx ky kz dp la kf lb lc ld kj le lf lg kn lh li lj lk bi translated"><strong class="ak">结合在一起</strong></h2><p id="4756" class="pw-post-body-paragraph ju jv iq jw b jx ll jz ka kb lm kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ij bi translated">正如我在开始时提到的，我们可以通过使用<strong class="jw ir">映射类型</strong>和<strong class="jw ir">条件类型</strong>来创建真正有用的类型，所以现在我想更多地关注这一点。</p><p id="c1d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们以<code class="fe lw lx ly lz b">Readonly&lt;T&gt;</code>实用程序类型为例，但是我们的类型<code class="fe lw lx ly lz b">T</code>将是一个比我们描述映射类型时更复杂的类型</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a50f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，我们怎样才能使<code class="fe lw lx ly lz b">T</code>类型的所有属性都是只读的呢？如果我们试图将我们的<code class="fe lw lx ly lz b">T</code>作为<code class="fe lw lx ly lz b">Readonly&lt;T&gt;</code>的参数传递，那么只有<code class="fe lw lx ly lz b">propertyA</code>和<code class="fe lw lx ly lz b">propertyB</code>将被标记为只读</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/2af9f20470d36517c3c73354b17cb9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Q81xG-5CftiE6PVPqn55A.png"/></div></div></figure><p id="9c04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你所看到的，我们仍然能够给<code class="fe lw lx ly lz b">propertyB_A</code>赋值，所以我们的readonly对有<code class="fe lw lx ly lz b">depth &gt; 1</code>的属性不起作用</p><p id="3124" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解决这个问题，我们必须创建<code class="fe lw lx ly lz b">DeepReadonly&lt;T&gt;</code> a类型。首先，每当我们的属性是一个<code class="fe lw lx ly lz b">object</code>时，我们必须识别，为此我们创建一个<code class="fe lw lx ly lz b">ObjectType&lt;T&gt;</code></p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="b483" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们检查<code class="fe lw lx ly lz b">T</code>是否扩展了对象，如果是，那么我们必须创建另一个<code class="fe lw lx ly lz b">extends</code>来过滤掉<code class="fe lw lx ly lz b">Function</code>类型(函数扩展了对象)</p><p id="25b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，无论类型<code class="fe lw lx ly lz b">T</code>是否是对象，我们都可以创建<code class="fe lw lx ly lz b">DeepReadonly&lt;T&gt;</code></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/965789764ee1b6454aca3e742ee026c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjeH5gT4XJdWr6bq6z8LiQ.png"/></div></div></figure><p id="562d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">基本上，我们实现了常规的<code class="fe lw lx ly lz b">Readonly&lt;T&gt;</code>(从类型<code class="fe lw lx ly lz b">T</code>遍历所有属性<code class="fe lw lx ly lz b">P</code>)但是在<code class="fe lw lx ly lz b">T</code>是<code class="fe lw lx ly lz b">object</code>的情况下，我们递归地调用<code class="fe lw lx ly lz b">DeepReadonly&lt;T&gt;</code>并将当前属性作为参数，因此在我们的情况下<code class="fe lw lx ly lz b">T[P]</code>将是<code class="fe lw lx ly lz b">propertyA</code>、<code class="fe lw lx ly lz b">propertyB</code>、<code class="fe lw lx ly lz b">propertyB_A</code>、<code class="fe lw lx ly lz b">propertyB_B</code>。</p><p id="a1d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结果，我们不能给<code class="fe lw lx ly lz b">propertyB_A</code>赋值，所以我们的<code class="fe lw lx ly lz b">DeepReadonly&lt;T&gt;</code>有效！</p><p id="d4a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">自己尝试一下，尤其是尝试将<strong class="jw ir">映射类型</strong>与<strong class="jw ir">条件类型</strong>结合起来，并创建一些有用的类型，如<code class="fe lw lx ly lz b">DeepReadonly&lt;T&gt;</code>。</p><p id="a6f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">推特</strong>:<a class="ae mw" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"><em class="mm">k _ wdowik</em></a></p><p id="46fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mm">更多内容请看</em><a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"><em class="mm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>