<html>
<head>
<title>Build PDF Documents with React on the Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在服务器上使用React构建PDF文档</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-pdf-documents-with-react-on-the-server-ac7bfed4f56?source=collection_archive---------4-----------------------#2021-09-07">https://javascript.plainenglish.io/build-pdf-documents-with-react-on-the-server-ac7bfed4f56?source=collection_archive---------4-----------------------#2021-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/52b14102fc4fe18343ee1f90ab520ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofX9Cba0yOVwLSlYVo3c0g.png"/></div></div></figure><div class=""/><p id="7f9c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成PDF文档或报告是软件开发中非常常见的任务。有许多这样的用例:医院报告、公司时间日志、发票，只要你能想到的。相信我，每个开发人员都面临着相同的任务问题。</p><ul class=""><li id="6671" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">使用什么方法生成PDF？</li><li id="2f61" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如何管理分页符？</li><li id="e20a" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">是否可以立即预览最终文档？</li><li id="32c8" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们需要Java/C#/Python或任何其他基于语言的服务器吗，或者我们可以用JavaScript来实现吗？</li><li id="e681" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们是否应该考虑一些第三方解决方案，以及它是否满足我们的所有要求？</li><li id="7b26" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">也许应该在前端(客户端)而不是后端？</li></ul><p id="23a3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当涉及到PDF生成时，这些问题以及许多其他问题是常见的。目标不同，答案也不同。我们的目标是有一个通用的方法，在服务器上使用React和JavaScript(确切地说是TypeScript)构建PDF文档，并在UI上提供即时预览。我希望这将是一次你会喜欢的旅行！</p><h1 id="c08d" class="lh li iy bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">首先需要回答问题</h1><h2 id="b0c7" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">如果我们可以在浏览器的UI中打印它，为什么它应该在服务器上？</h2><p id="ad89" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">在客户端的浏览器中从客户端的机器进行渲染是一项挑战。两个用户之间没有一致性，因为最终结果取决于许多因素，如屏幕分辨率、字体的可用性、是否是retina屏幕，以及用户可能使用的浏览器之间的差异。这将适用于非常低的需求水平，或者作为第一个版本，因为它很容易实现。</p><h2 id="83ad" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">我应该在服务器或第三方服务上使用其他编程语言吗？</h2><p id="0b2e" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">第三方服务可以很好地处理通用pdf，可能具有一定程度的灵活性，但很可能永远不会像自定义解决方案那样灵活。这是使用易用性的一个权衡。</p><p id="b291" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，使用其他语言限制了我们在PDF报告和即时预览中重用React组件的能力。稍后，我们将更明确地讨论这一点，但现在—我们可以假设，添加另一种语言会增加代码库的复杂性，需要我们学习/了解该语言，或者专门为此雇用另一名开发人员。</p><h2 id="910a" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">有没有办法将React用作内容构建器？</h2><p id="9811" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">是的，绝对的！React能够在服务器端呈现HTML字符串，之后我们可以很容易地将其转换成最终的PDF。</p><p id="494e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果我们使用React，并且拥有一组专用的文档组件，我们就可以即时预览最终文档，并且还可以在服务器上重用这些组件来创建PDF版本。你不觉得这很棒吗？</p><h1 id="9e36" class="lh li iy bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">从哪里开始？</h1><h2 id="05b2" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">简介:</h2><p id="75e6" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">我们的目标是获得一个工具，它可以轻松地重用我们在UI应用程序中使用的相同组件来创建PDF文件。</p><p id="032a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，我们将创建3个项目:UI应用程序、共享组件和PDF报告服务。想法是定义可能的PDF的构建块，分离数据层，并在UI应用程序上有即时预览。现在，让我们深入细节。</p><h2 id="1f74" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第一步:项目结构</h2><p id="3a94" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">将组件提取到单独的代码库很重要，因为我们需要将它们导入到Web UI和报告服务中。你实现它的方式并不重要。它可以是共享组件或monorepo或任何其他方法的私有包。主要目标是能够在两端访问相同的共享代码库，UI和报告服务。下面是该结构的一个简单预览。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mw"><img src="../Images/89a74e6359ee5b9c3258d26f5abdd4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPAaqvYBTFSwzpuBEwL79w.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Codebase dependencies structure</figcaption></figure><p id="51e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的例子中，我使用了一个带有Yarn工作空间的基本Lerna monorepo设置，最终的代码repo将在最后被链接。我有3个包，如上图所示，所以<code class="fe nf ng nh ni b">component</code>包被导入到Web UI和报告服务。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/92964c278b8c573675799db832354ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*DSYXisW47wAqof2GK96kVw.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Project folders structure</figcaption></figure><h2 id="08c5" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第二步:设置基本的Web用户界面布局</h2><p id="2d95" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">出于演示的目的，我们可以在屏幕上有一个非常简单的布局。我们把它分成两半，左边的是数据源，右边的是即时PDF文档预览。现在我们只有一个基本的工作输入表单，只需要最少的验证。实际上，这个表单是从<code class="fe nf ng nh ni b">react-hook-form</code>中复制粘贴<a class="ae nk" href="https://react-hook-form.com/get-started" rel="noopener ugc nofollow" target="_blank">示例</a>，我在这里也使用了它。</p><p id="a99f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一半是空的预览容器，我们稍后会更新它。目前，它只是一个具有A4文档格式尺寸的占位符。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nl"><img src="../Images/e6f7a05cfe93bf06ef33ddd6e9729540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcW6-XwSr6GkrG_p0YoFCQ.png"/></div></div></figure><h2 id="b0a5" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第三步:基本报表组件设置</h2><p id="dcb0" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">在此步骤中，我们将设置共享组件包。为了简单起见，我再次使用了<em class="nm">创建React库</em>。在我们的例子中，设置并不重要，我们唯一需要的是拥有一个最终的构建文件，其中包含可以在客户端和服务器端重用的组件。</p><p id="8b9f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，真正重要的是定义我们愿意为PDF文档提供什么样的组件。所以，现在我们可以自由地从组件的概念过渡到块。</p><p id="c73f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么你可能会问，组件和块的区别是什么？从技术上讲，块是一个递归的可序列化的数据结构。它描述了使用哪种UI元素，从哪里获取数据，以及是否有任何特定的属性可用于它。我们希望在PDF文档中包含的任何类型的UI元素——我们应该首先将其描述为一个块。换句话说——每个泛型元素都有一个<code class="fe nf ng nh ni b">BaseBlock</code>抽象类和大量具体类。把块想象成我们想要看到的东西的描述，比如一个<code class="fe nf ng nh ni b">Title</code>块或者<code class="fe nf ng nh ni b">Image</code>块，也可能是一个条目列表的块。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/b39f8ba058d3225a0f28521185878fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxvUR_7b6Vk5HketzzASkw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Base block abstract class</figcaption></figure><p id="6845" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个块都有一个必需属性的列表:<code class="fe nf ng nh ni b">Identifier</code>和<code class="fe nf ng nh ni b">Component</code>。此外，我们还有一个<code class="fe nf ng nh ni b">accessor</code>、<code class="fe nf ng nh ni b">metadata</code>和<code class="fe nf ng nh ni b">items</code>。</p><p id="6467" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe nf ng nh ni b">Identifier</code> enum，我们可以将块从JSON反序列化为正确的具体类实现，其中将有一个<code class="fe nf ng nh ni b">Component</code>属性，这是该块的实际UI的功能。使用<code class="fe nf ng nh ni b">accessor</code>,我们可以获得块的这个特定实例的值(想想标题块，可能有许多不同的标题，但是块是一个，所以我们只改变访问器)。块是递归的，所以每个块(几乎)都有一个<code class="fe nf ng nh ni b">items</code>属性，一个子块列表。最后但同样重要的是<code class="fe nf ng nh ni b">metadata</code>属性，我们需要它来描述块实例的一些具体细节。例如，标题栏可以有不同的样式，如<strong class="jx iz">粗体</strong>、<em class="nm">斜体</em>等。这就是元数据。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi no"><img src="../Images/0f2e4b16c9140a7d0513ae65bf2e5815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQTnXqmtmO4iZCnB2IRpVw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Title block implementation</figcaption></figure><p id="a36b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过利用块的力量，我们可以为我们想要的文档类型构建一个模式。我们可以定义几个模式，每个模式都是由许多块组成的。一个模式可以描述雇员时间日志的文档结构，另一个模式描述发票的结构。两者都由相同的砌块制成，但结构不同。</p><p id="cd44" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">通过拥有可串行化的块数据结构，我们获得了几个好处:</strong></p><ol class=""><li id="1155" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks np kz la lb bi translated">报告的布局可以动态构建。</li><li id="b8b4" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">我们不仅可以在我们的服务中使用schema，还可以在用不同编程语言构建的其他服务中使用schema，以防我们将来需要支持它。</li><li id="20ed" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">模式可以作为一个简单的JSON存储在数据库中，很容易通过网络传输。</li><li id="949d" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">我们创建了一组有限的受支持的块，所以这里没有魔法。这也有助于避免模糊的产品需求。</li><li id="c758" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">作用域实现，防止不可读的混乱代码结构。</li></ol><p id="9ecf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的另一件事是在React中呈现模式。你猜怎么着？它之所以如此简单，是因为从渲染的角度来看，每个块都是相同的，它并不关心实际的块实现，它只是进行渲染。</p><p id="8e7a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为这个结构是递归的，所以我们以递归的方式呈现它。只有在相同的嵌套级别上，键优化才是重要的，因此为了简单起见，我们使用一个带有索引的标识符。但是你可以用一些ID或者实际值来代替。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nq"><img src="../Images/1deb1fce9dfa9c6a2c3370bbc833d54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVLI94mBfUmfSlXubeW2yQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Component to render the Schema</figcaption></figure><p id="3ce1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，实际的模式只是块实例的多层JavaScript对象。我们将把它输入到<code class="fe nf ng nh ni b">RenderBlock</code>组件中，所有的魔法都在那里完成。整洁！</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/04eaff00f50c26953dd2bbabdeffb5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZuuf8OfmXgRBNtfLyZFWw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Example of the Schema</figcaption></figure><h2 id="46ad" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第三步:数据提供者</h2><p id="f492" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">将模式从实际数据中分离出来是一件大事，因此它们可以是动态的。谁会需要一个与数据紧密耦合的布局呢？这就是为什么每个块都有一个<code class="fe nf ng nh ni b">accessor</code>属性。通过访问器，我们可以真正地访问这个特定块实例所需的数据。让我们说，我们可以有几个标题，所以可能的访问者是<code class="fe nf ng nh ni b">firstName</code>、<code class="fe nf ng nh ni b">lastName</code>等。</p><p id="55a9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现这一点的React方法很简单——上下文API。我们的数据对象大部分是平面对象，所以我们避免复杂的访问器(尽管这是可能的，但是更难维护)。提供者组件将包装RenderBlock组件。通过这种方式，数据由DataProvider提供，可以通过块实现内部的钩子轻松访问，并且布局(模式)是单独提供的。嗯，你应该已经得到了这个想法和好处。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/2493cfe9e46360df5aaaedd15b46fbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdqXfkHoy0RzVPn08PSmDg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Data provider code</figcaption></figure><p id="ccf9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们能够实现的另一件大事是，TypeScript不允许我们将未知的访问器推送到块实例。我们用可用访问器及其类型的列表定义了我们的数据对象。让我们尝试使用一个未知的访问器，看看会发生什么。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/c722e93fca2809dc51c5558c7ad8c027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTSycl6juV4WrxUqleNIBQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Passing unknown accessor error</figcaption></figure><p id="8918" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢打字稿！这对于防止开发人员的错误非常有用。当然，这只是一个编译时错误，但无论如何都是有帮助的。如果需要的话——我们可以做更多的运行时检查，但是现在，这不是我们的目标。</p><h2 id="6f73" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第四步:设置服务器端</h2><p id="57fc" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">我们可以采用直接(express)或结构化(Nest.js)的方法。我更喜欢使用Nest.js作为后端服务，因为它有一种干净的开箱即用的方式。不仅如此，这是一个框架，所以我不需要额外的设置步骤。</p><p id="8c1c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个简单的用例，我们真正需要的是单个端点。为此，我们将使用模式和数据来推动主体。然后，剩下的工作被转移到服务中。</p><p id="3e55" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">获得实际PDF结果的策略是遵循几个简单的步骤:</p><ol class=""><li id="177b" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks np kz la lb bi translated">通过REST(不一定)API接受模式和数据</li><li id="3100" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">解析主体并验证它。(检查未知标识符等)</li><li id="aa1b" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">将模式JSON反序列化为实际的块实例</li><li id="5b79" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">将模式提供给<code class="fe nf ng nh ni b">RenderBlock</code>组件，将数据提供给<code class="fe nf ng nh ni b">DataProvider</code>组件</li><li id="59d2" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">将所有内容呈现给HTML字符串(或流)。可选地包括必要的CSS代码</li><li id="7b1c" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">净化HTML结果以消除安全风险</li><li id="6ce8" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated"><strong class="jx iz">在headless Chrome中使用木偶师渲染HTML，并使用支持的API提取PDF文件</strong></li><li id="2781" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks np kz la lb bi translated">在HTTP响应中将PDF文件作为流推送到客户端</li></ol><p id="fc10" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是以这种方式创建PDF的基本步骤。当然，我们可以在中间有一些额外的步骤，但这是另一个故事。主要想法是创建一个最终的HTML，并将其转换成PDF使用木偶戏。</p><p id="fb13" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不熟悉puppet er——它是无头Chrome或Chromium浏览器上的一个API抽象层。</p><p id="473c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，同样重要的是在Docker容器中运行服务。这样我们就可以得到一致的PDF文档，而不依赖于它运行的服务器类型。</p><p id="894b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主体的验证使用起来非常简单。对于我们这里的数据结构，重要的是只检查来自模式的块标识符是否是我们知道的那个，否则，它是有效载荷中的一个错误。如果主体无效，我们将抛出一个异常。在Nest.js中，这是通过使用<code class="fe nf ng nh ni b">class-validator</code>库的验证管道来完成的。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nu"><img src="../Images/d92dbd98c9ad4460f36a49303a1659d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBTBBrLj0-yp-lSbRiroIA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">PDF controller with validation</figcaption></figure><p id="338a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一部分是反序列化。此时，我们可以确定主体是有效的，所以我们可以简单地将这个普通对象反序列化到实际的块中。我们已经为此做好了准备，在组件库中提供了用于反序列化的函数。将该逻辑保留在组件项目中是有意义的，这样它就被封装起来，服务不需要知道太多关于数据的信息。同样，在Nest.js中，我们使用<code class="fe nf ng nh ni b">class-transformer</code>将每个块转换成普通块(它只有一个实例，但没有实现任何UI)。普通块很有用，因为我们可以对它们进行验证。之后，我们使用<code class="fe nf ng nh ni b">deserializeSchema</code>将它们转换成正确的块，并输入到<code class="fe nf ng nh ni b">RenderBlock</code>组件中。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/296c8dd29607647966922fe74e726334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iObXN04Kv-tXPmiJOB7-xA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">PDF service with deserialization</figcaption></figure><p id="4945" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好的，很好，此时我们已经有了有效的和转换的数据，所以它可以被推进到渲染步骤。</p><p id="a988" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React library允许我们使用<code class="fe nf ng nh ni b">react-dom/server</code>包，用它我们能够呈现UI，但是特别是在服务器上。它可以是字符串或流，但为了简单起见，我们将使用HTML字符串。因此，这里的结构很清楚，我们呈现数据提供者和模式，然后将结果HTML字符串存储到一个变量中。我们不会在Nest.js设置中使用JSX来阻止支持该功能的配置。但是如果有必要的话你可以。一旦HTML准备好了，你只需要添加一个适当的HTML包装，我的意思是头部，身体，风格，如果必要的话。</p><p id="79fc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，如果你把它们转换成一个<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" rel="noopener ugc nofollow" target="_blank">数据URL </a>，你可以得到图片的支持。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/9640aa171714409feaf1ad69a4321113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hgpdls4zbYFWXChsPITCQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">HTML generation</figcaption></figure><p id="2f52" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">整个HTML都准备好了。为了安全起见，你也可以像<a class="ae nk" href="https://www.npmjs.com/package/ent" rel="noopener ugc nofollow" target="_blank"> ent </a>一样通过解码器来运行。现在，我们可以把它推进木偶，得到PDF文件。还可以为页眉和页脚添加HTML模板，但它只支持内嵌CSS样式。</p><p id="100b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要用PDF的UI打开页面，我们应该用base64编码将它转换成数据URL。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/fae6226faa9e86992fc58f5f324f0aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8eaCUJf9NoLEHv8OCA0_w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">HTML to PDF conversion</figcaption></figure><p id="d85f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果是一个PDF缓冲区，我们可以简单地将它输入到响应流中。当然，您可以将其作为一个普通的HTML字符串，但是在流的支持下，我们可以稍微减少内存负载。对于文件流，我们应该用最终文件名指定内容类型、内容长度和内容处置。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ny"><img src="../Images/5e8b4b4b296f9b2e1bc75d599cabfbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVc-16ntM1iGu-QZEDg_sw.png"/></div></div></figure><h2 id="85f8" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第五步:连接UI和共享组件</h2><p id="9c21" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">既然UI和共享组件都已经可以使用了，现在，我们应该开始连接它们了。很高兴，使用Lerna，我们可以很容易地在项目之间导入组件，就像使用PDF服务一样。</p><p id="d2ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以用真正的预览替换PDF预览容器内容。所以，正如之前提到的——数据是分离的，模板也是分离的。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nz"><img src="../Images/a50c012a0059015cd706e41268053a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxyCD4ci479tTJroq2GpqA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Rendering instant preview of the PDF</figcaption></figure><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oa"><img src="../Images/b8e6f86e6c6ceb1971b90a5cb89781ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oqzK_N_21n-VgUWt8C6KQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Data payload creation</figcaption></figure><p id="55fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们做了很多努力使预览版易于使用。此外，为了简单起见，我们重用包含标题的默认模板。成效显著！所以现在，我们可以从预览中反映的形式中识别出每一个变化。当然，如果有必要，您也可以创建单独的页面模拟。但是在我们的例子中不是这样。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ob"><img src="../Images/484981a7515c2b2b20dda9d54aeb8fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-HJkNEMgX5LAp0TjIyxzEA.gif"/></div></div></figure><h2 id="6a59" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">第六步:连接UI和服务</h2><p id="3f05" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">在这一点上，我们所能做的已经不多了。让我们将UI与服务连接起来，并以PDF格式查看最终结果！</p><p id="b636" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个简单的例子，仅仅使用<code class="fe nf ng nh ni b">fetch</code>方法来调用服务就足够了。因此，我们将在新窗口中打开生成的PDF文档。但是，你当然可以以任何你想要的方式保存结果Blob。</p><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oc"><img src="../Images/0d98aea72334ceb9246f1fd1bceb4c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjAh06SnRnfsMmBAxU-Ccg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">HTTP Request to the PDF service</figcaption></figure><figure class="mx my mz na gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi od"><img src="../Images/a03aa53835c14fcaaf7e291d4f0e4d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mzQcsL3g_lI0rGt6_ollxw.gif"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">PDF generation</figcaption></figure><p id="391e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你有了！使用React组件的PDF文件！</p><h2 id="ac88" class="mf li iy bd lj mg mh dn ln mi mj dp lr kg mk ml lv kk mm mn lz ko mo mp md mq bi translated">结论:</h2><p id="0a79" class="pw-post-body-paragraph jv jw iy jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">您经历了PDF生成的整个周期，从基本步骤到最终结果。</p><p id="37b0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，还有许多其他可能的生成pdf的方法，但是你所经历的这种方法非常适合基于React的UI。</p><p id="d220" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们能够重用UI和PDF服务上的组件，这给了我们最终文件的即时预览。我们还创建了一个可预测的块结构(Schema ),这保证了结果报告的一致性。通过利用无头chrome和puppeteer，我们最终能够生成PDF文件。在Nest.js框架和TypeScript的帮助下，使用REST API将两边粘合起来。</p><p id="353c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用这种方法，您可以创建任何类型的块，动态的或静态的，复杂的或简单的，可重用的或不可重用的。主要思想是展示解决问题的一种可能的方法。</p><p id="1e91" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还没有真正讨论分页符的问题，但是通过这种方法，你可以使用<code class="fe nf ng nh ni b"><a class="ae nk" href="https://css-tricks.com/almanac/properties/p/page-break/" rel="noopener ugc nofollow" target="_blank">page-break-*</a></code> CSS属性，这取决于如何放置它们的要求。</p><p id="a027" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的代码都可以在<a class="ae nk" href="https://github.com/bohdanbirdie/react-pdf-report" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。欢迎向我提出建议、提议甚至批评:)</p><p id="e334" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PS:库也包含了服务的Docker设置，代码包含了额外的东西(比如API swagger等等)，主题中的例子非常简单。</p><p id="9a10" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nm">更多内容尽在</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>