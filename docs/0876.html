<html>
<head>
<title>What is Huffman Coding?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是霍夫曼编码？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-huffman-coding-a5c09bc60184?source=collection_archive---------9-----------------------#2021-02-23">https://javascript.plainenglish.io/what-is-huffman-coding-a5c09bc60184?source=collection_archive---------9-----------------------#2021-02-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="25ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">霍夫曼编码算法是许多压缩算法的一个组成部分，例如PNG图像格式和GZIP使用的DEFLATE算法。</p><p id="957f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(我的<a class="ae ki" href="https://www.baseclass.io/newsletter/" rel="noopener ugc nofollow" target="_blank">时事通讯</a>的订阅者首先收到了这个)</p><h2 id="8722" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">我为什么要在乎？</h2><p id="bf0f" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">您是否曾想过:</p><ul class=""><li id="1865" class="lh li in jm b jn jo jr js jv lj jz lk kd ll kh lm ln lo lp bi translated">我们如何在不丢失任何数据的情况下压缩一些东西？</li><li id="5578" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated">为什么有些东西压缩得比其他的好？</li><li id="5468" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated">GZIP是如何运作的？</li></ul><p id="e98f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们想压缩一个字符串(哈夫曼编码可以用于任何数据，但字符串是很好的例子)。</p><p id="8c75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不可避免的是，在要压缩的文本中，某些字符会比其他字符出现得更频繁。霍夫曼编码利用了这一事实，并对文本进行编码，使得最常用的字符比不常用的字符占据更少的空间。</p><h2 id="9251" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">编码字符串</h2><p id="67c2" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">让我们使用霍夫曼编码来压缩来自尤达的(部分)报价；“做还是不做”。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/ab6a90f728ecc938d4eac9d6ffadf8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*JmW-KZY_MXHQMgOL4Rdqbw.png"/></div></figure><p id="b662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“做或不做”是12个字符长。它有一些重复的字符，所以应该压缩得很好。</p><p id="35e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了便于讨论，我们假设存储每个字符需要8位(字符编码完全是另一个话题)。这句话将花费我们96位，但我们可以做得更好的霍夫曼编码！</p><p id="07c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从建立一个树形结构开始。我们的数据中最常见的字符会更靠近树的根，而离根最远的节点代表不太常见的字符。</p><p id="c43f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是字符串“做或不做”的霍夫曼树:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/c7a83856b8e1d713e3fd406b38edc5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntQgFgx3fdXdhfG4415Beg.png"/></div></div></figure><p id="d8b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">字符串中最常见的字符是“o”(4次出现)和空格(3次出现)。请注意，这些字符的路径离根只有两步，而最不常见的字符(' t ')只有三步。</p><p id="42e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以存储字符的路径，而不是存储字符本身。</p><p id="85cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从根节点开始，沿着树向我们想要编码的字符前进。如果我们走左边的路，我们会存储一个<code class="fe mi mj mk ml b">0</code>，如果我们走右边的路，我们会存储一个<code class="fe mi mj mk ml b">1</code>。</p><p id="64b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是我们如何使用此树对第一个字符<code class="fe mi mj mk ml b">d</code>进行编码:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/a1faf87f0f1dfb52bbb1defbd2f5e3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLZjaP4A5Qf3kaFnw41MBA.png"/></div></div></figure><p id="0b8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终结果是<code class="fe mi mj mk ml b">1</code> <code class="fe mi mj mk ml b">0</code> <code class="fe mi mj mk ml b">0</code> - 3位而不是8位。这是一个很大的进步！</p><p id="8777" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">整个编码字符串如下所示:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/e7bf991c592b064abc37c56bb24b6a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6hWZh7dC69fZ_P757UE5Q.png"/></div></div></figure><p id="3c9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是29位，而不是96位，没有数据丢失。太好了。</p><h2 id="1fad" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">解码我们的字符串</h2><p id="1ccc" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">为了解码我们的文本，我们只需跟随每个<code class="fe mi mj mk ml b">0</code>(左分支)或<code class="fe mi mj mk ml b">1</code>(右分支)直到我们到达一个字符。我们记下这个角色，然后从头开始:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/9bb8e77b03045b954135c3e4d900ba22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pLyucOU9lpxSw7rbZKXzw.png"/></div></div></figure><h2 id="1341" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">发送编码文本</h2><p id="1337" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">但是等等..当我们将编码文本发送给其他人时，他们不也需要树吗？是的。另一方需要相同的哈夫曼树，以便正确解码文本。</p><p id="0a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最简单但效率最低的方法是简单地将树和压缩文本一起发送。</p><p id="c617" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以先在树上达成一致，在编码或解码任何字符串时都使用该树。当我们可以提前预测字符的分布时，这是可行的，并且可以建立一个相对有效的树，而不必先看到我们正在编码的特定内容(例如，我们可以对英文文本进行编码)。</p><p id="8ba4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种选择是发送足够的信息，让另一方建立和我们一样的树(这就是GZIP的工作方式)。例如，我们可以发送每个字符出现的总次数。但是我们必须小心。同一个文本块有不止一个可能的Huffman树，所以我们必须确保我们都以完全相同的方式在<em class="mm">中构造树。</em></p><p id="1d36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">延伸阅读:</strong></p><ul class=""><li id="7810" class="lh li in jm b jn jo jr js jv lj jz lk kd ll kh lm ln lo lp bi translated"><a class="ae ki" href="https://www.programiz.com/dsa/huffman-coding" rel="noopener ugc nofollow" target="_blank">如何构建霍夫曼树(比你想象的要简单)</a></li><li id="2c18" class="lh li in jm b jn lq jr lr jv ls jz lt kd lu kh lm ln lo lp bi translated"><a class="ae ki" href="https://jvns.ca/blog/2015/02/22/how-gzip-uses-huffman-coding/" rel="noopener ugc nofollow" target="_blank">这在GZIP是如何使用的</a></li></ul></div></div>    
</body>
</html>