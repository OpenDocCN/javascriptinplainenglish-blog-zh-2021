<html>
<head>
<title>React useMemo is not a classical memorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应使用备忘录不是一个经典的记忆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-usememo-is-not-a-classical-memorization-432a21d28431?source=collection_archive---------4-----------------------#2021-08-14">https://javascript.plainenglish.io/react-usememo-is-not-a-classical-memorization-432a21d28431?source=collection_archive---------4-----------------------#2021-08-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8343" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么你不应该混淆记忆和背诵</p><p id="5ffd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许这只是我，但很长一段时间，我把自己绑在一个<code class="fe ki kj kk kl b">useMemo</code>和一个经典记忆之间。但实际上从对<code class="fe ki kj kk kl b">useMemo</code>源代码的研究中，我讲和地发现它们非常不同，至少它们没有太多的重叠。也许他们唯一分享的就是一个偏旁的单词“memo”。</p><h2 id="68df" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">设计和实施</h2><p id="ac48" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useMemo</code>与<code class="fe ki kj kk kl b">useEffect</code>非常接近，信不信由你，就语法、用法以及实现而言。也许我们甚至可以用一个<code class="fe ki kj kk kl b">useEffect</code>来模拟一个<code class="fe ki kj kk kl b">useMemo</code>的行为。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="64db" class="km kn in kl b gy ls lt l lu lv">const Title = ({ text1, text2 }) =&gt; {<br/>  const [textB, setTextB] = <strong class="kl io">useState</strong>("Hello")<br/>  <strong class="kl io">useEffect</strong>(() =&gt; {<br/>    setTextB(text1 + "s")<br/>  }, [text1])</span><span id="bc4d" class="km kn in kl b gy lw lt l lu lv">  return (<br/>    &lt;&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB textB={textB} /&gt;<br/>    &lt;/&gt;<br/>  ) <br/>}</span></pre><p id="8964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前面的代码中，当<code class="fe ki kj kk kl b">text1</code>改变时，它更新通过prop <code class="fe ki kj kk kl b">textB</code>发送给ChildB组件的<code class="fe ki kj kk kl b">textB</code>。</p><p id="2e2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你问我什么是<code class="fe ki kj kk kl b">useMemo</code>，我会说就是这个想法。它希望跳过任何不相关的状态或属性更改的渲染，这样ChildB就不会得到不必要的渲染。如果ChildB是一个很重的组件或者<code class="fe ki kj kk kl b">text1 + "s"</code>是一个很重的操作，这就是你为了更好的性能而改进的地方。</p><p id="2c43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以争辩说<code class="fe ki kj kk kl b">textB</code>不值得一个被动效果，它是在所有组件以异步方式渲染和刷新后收集的。当然，让我们用一个<code class="fe ki kj kk kl b">useMemo</code>来替换它，它在组件标题的相同呈现下被调用。不错！</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="caf3" class="km kn in kl b gy ls lt l lu lv">const Title = ({ text1, text2 }) =&gt; {<br/>  const textB = <strong class="kl io">useMemo</strong>(() =&gt; {<br/>    return text1 + "s"<br/>  }, [text1])</span><span id="4af2" class="km kn in kl b gy lw lt l lu lv">  return (<br/>    &lt;&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB textB={textB} /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="5025" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个简单的接口和执行并没有改变它只是跳过渲染和有条件赋值的事实。</p><h2 id="0d8b" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">记住</h2><p id="812d" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">现在来说说什么是识记，或者说关于缓存的一些东西。</p><blockquote class="lx ly lz"><p id="155e" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">记忆化是计算机程序中的一种优化技术，主要设计用于通过存储昂贵运算的结果并返回缓存的结果(如果它以前已经在相同条件下计算过)来加速过程。</p></blockquote><p id="424b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以一个经典的斐波那契问题为例。递归写入成本很高，因此我们使用缓存来存储过去计算的值，以减少未来的计算。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="7044" class="km kn in kl b gy ls lt l lu lv">const fibs = { 0: 1, 1: 1 }</span><span id="7eab" class="km kn in kl b gy lw lt l lu lv">function fib(n) {<br/>  if (!fibs[n]) {<br/>    fibs[n] = fibs[n - 1] + fibs[n - 2]<br/>  }</span><span id="10db" class="km kn in kl b gy lw lt l lu lv">  return fibs[n]<br/>}</span></pre><p id="2212" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比如在React应用中，我们从<code class="fe ki kj kk kl b">n=0</code>开始，除非<code class="fe ki kj kk kl b">n=1</code>我们不想计算新的值。我们可以添加一个<code class="fe ki kj kk kl b">useMemo</code>。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="64ab" class="km kn in kl b gy ls lt l lu lv">const Title = ({ n, text }) =&gt; {<br/>  const f = useMemo(() =&gt; fib(n), [n])<br/>  <br/>  return &lt;div&gt;{text} - {f}&lt;/div&gt;<br/>}</span></pre><p id="8c6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们很快发现的第一件事是，它实际上重用了<code class="fe ki kj kk kl b">fib</code>函数，这意味着它们的功能根本没有重叠。另一方面,<code class="fe ki kj kk kl b">useMemo</code>不做<code class="fe ki kj kk kl b">fib</code>做的事情。惊艳？</p><p id="2d46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个发现是，标题所做的是确保当另一个道具<code class="fe ki kj kk kl b">text</code>改变时，它不会再次计算<code class="fe ki kj kk kl b">f</code>。但是如果我们把<code class="fe ki kj kk kl b">n</code>从<code class="fe ki kj kk kl b">3</code>改成<code class="fe ki kj kk kl b">2</code>，它仍然从<code class="fe ki kj kk kl b">useMemo</code>开始赋值。这意味着代码可以简化为以下内容。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="9cb5" class="km kn in kl b gy ls lt l lu lv">const Title = ({ n, text }) =&gt; {<br/>  const f = fib(n)<br/>  <br/>  return &lt;div&gt;{text} - {f}&lt;/div&gt;<br/>}</span></pre><p id="6b28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈哈，这现在有点搞笑了。我们真的去掉了<code class="fe ki kj kk kl b">useMemo</code>。为什么？因为保存的计算已经被<code class="fe ki kj kk kl b">fib</code>实现了，经典的背诵。我们不能简单地利用<code class="fe ki kj kk kl b">useMemo</code>，因为将<code class="fe ki kj kk kl b">n</code>更改为任何其他值都会保证一个新的渲染。</p><p id="cdcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是这里的<code class="fe ki kj kk kl b">useMemo</code>是干什么用的。是的，没什么。</p><h2 id="748e" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">什么是使用备忘录</h2><p id="4621" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useMemo</code>有一个仅为<strong class="jm io">先前值</strong>构建的记忆存储器。如果你能利用它来避免一些额外的渲染，那就太好了。否则你只会让事情变得过于复杂。</p><p id="c7a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要指望<code class="fe ki kj kk kl b">useMemo</code>会给你比以前更多的值。React本身就是一个大的状态机，给定一个变化，它就移动到一个新的状态。它关心的只是未来和现在的场景。从<code class="fe ki kj kk kl b">t-1</code>切换到<code class="fe ki kj kk kl b">t</code>是它所关心的。但是记住所有的<code class="fe ki kj kk kl b">t</code>并从<code class="fe ki kj kk kl b">t</code>切换到<code class="fe ki kj kk kl b">t-2</code>并不适合React上下文。因此<code class="fe ki kj kk kl b">useMemo</code>甚至不能开始适应记忆环境。如果你真的想争辩，我们可以说React使用了一种非常专门的对先前状态的记忆，或者就叫它状态机。</p><p id="0598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">useMemo</code>的源代码不能再紧凑了，附在这里供参考。第一次渲染，它调用<code class="fe ki kj kk kl b">mountMemo</code>。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="f83f" class="km kn in kl b gy ls lt l lu lv">function mountMemo(nextCreate, deps) {<br/>  const hook = mountWorkInProgressHook()<br/>  const nextDeps = deps === undefined ? null : deps<br/>  const nextValue = nextCreate()<br/>  hook.memoizedState = [nextValue, nextDeps]<br/>  return nextValue<br/>}</span></pre><p id="71e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了将来的更新，它调用<code class="fe ki kj kk kl b">updateMemo</code>。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="757e" class="km kn in kl b gy ls lt l lu lv">function updateMemo(nextCreate, deps) {<br/>  const hook = updateWorkInProgressHook()<br/>  const nextDeps = deps === undefined ? null : deps<br/>  const prevState = hook.memoizedState<br/>  if (prevState !== null) {<br/>    if (nextDeps !== null) {<br/>      const prevDeps = prevState[1]<br/>      if (areHookInputsEqual(nextDeps, prevDeps)) {<br/>        return prevState[0]<br/>      }<br/>    }<br/>  }<br/>  const nextValue = nextCreate()<br/>  hook.memoizedState = [nextValue, nextDeps]<br/>  return nextValue<br/>}</span></pre><p id="ae51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从某种意义上说，<code class="fe ki kj kk kl b">useMemo</code>是一个高级赋值语句，它赋予我们有条件赋值的能力。</p><pre class="lk ll lm ln gt lo kl lp lq aw lr bi"><span id="0957" class="km kn in kl b gy ls lt l lu lv">const a = 1<br/>const a = useMemo(() =&gt; 1, [])  // conditionally</span></pre><p id="09aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">听起来很有趣，但这就是它的全部功能。</p><figure class="lk ll lm ln gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/1e6785404339506c90e97ade03573a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*zWtL0aY8C54ulZJvRJydfQ.png"/></div></figure><p id="0e6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ma">更多内容请看</em><a class="ae mi" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ma">plain English . io</em></strong></a></p></div></div>    
</body>
</html>