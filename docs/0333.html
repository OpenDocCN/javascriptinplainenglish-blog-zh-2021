<html>
<head>
<title>All ES2021 Confirmed Changes for JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有ES2021已确认的JavaScript更改</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dont-you-wish-an-es-fresh-like-es2021-e2b6ca33c983?source=collection_archive---------12-----------------------#2021-01-19">https://javascript.plainenglish.io/dont-you-wish-an-es-fresh-like-es2021-e2b6ca33c983?source=collection_archive---------12-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a0de7fde43e2c30c43110240080fbf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*12FNnFWzCG08j3zX.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image Credits: <a class="ae kc" href="https://morioh.com/" rel="noopener ugc nofollow" target="_blank">moroioh.com</a></figcaption></figure><p id="3632" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES2020的发布时间不长，但其他功能已经在开发中，只等发布。TC39工作组负责将这些特性纳入ECMAScript标准的新版本。这篇文章为您带来了TC39第4阶段已经具备的特性。</p><p id="00ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TC39提供以下阶段:</p><h2 id="f9d1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">阶段0:稻草人</strong></h2><p id="f797" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">TC39成员可以提出以前没有提出过的(或以前被完全否决的)任何想法、变化或补充。</p><h2 id="48a9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">第一阶段:提案</strong></h2><p id="0070" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">TC39成员创建了一个提案。它描述了一个具体的问题和相关的解决方案。</p><h2 id="ec57" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">第二阶段:草稿</strong></h2><p id="4e84" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">提案的语法和语义用正式规范语言描述。</p><h2 id="3fd9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">第三阶段:候选人</strong></h2><p id="da20" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">提案的规范已经完成，审阅者已经批准了它。第4阶段—完成:提案可以包含在即将发布的ECMAScript版本中。</p><h2 id="bf88" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">第四阶段:完成</strong></h2><p id="c441" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">该提案可能会包含在即将发布的ECMAScript版本中。ES2021大概会在2021年6月发布。</p><h1 id="47f1" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">逻辑赋值运算符</h1><p id="8a06" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">逻辑赋值运算符组合了逻辑运算符和赋值表达式。它们使代码更短，并使变量和对象属性的条件值赋值更容易。ES2021将引入三种新的逻辑运算符，每种运算符处理两个操作数。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8313" class="lb lc iq mv b gy mz na l nb nc">||=  <em class="nd">// combines logical OR with ASSIGN<br/></em>&amp;&amp;=  <em class="nd">// combines logical AND with ASSIGN<br/></em>??=  <em class="nd">// combines NULLISH with ASSIGN</em></span></pre><p id="07b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑OR运算符<code class="fe ne nf ng mv b">||=</code>是逻辑运算符<code class="fe ne nf ng mv b">||</code>和赋值运算符的组合。如果右操作数的值为<em class="nd">false</em>(即测试结果为false的值)，并且是符号<code class="fe ne nf ng mv b">a||(a=b)</code>的缩写形式，则将右操作数赋给左操作数。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑AND赋值操作符<code class="fe ne nf ng mv b">&amp;&amp;=</code>的工作方式相同，但它组合了逻辑<code class="fe ne nf ng mv b">&amp;&amp;</code>操作符和赋值操作符，并且仅当第一个操作数具有<em class="nd">真值</em>时，才将右操作数赋给左操作数(即评估为真的值)。它是符号<code class="fe ne nf ng mv b">a&amp;&amp;(a=b)</code>的简称。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑<em class="nd">无效</em>赋值<code class="fe ne nf ng mv b">??=</code>的操作符是符号<code class="fe ne nf ng mv b">a??(a=b)</code>的缩写。只有当第一个操作数为空或未定义时，它才会将第二个操作数赋给第一个操作数。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b73b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新运算符对于对象属性的初始化非常方便。它们有助于在内部确保对象<code class="fe ne nf ng mv b">person</code>的属性<code class="fe ne nf ng mv b">firstName</code>用值<code class="fe ne nf ng mv b">Commander</code>初始化，如果属性还没有被赋值的话。</p><p id="e025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们很快就走完了老路:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c3b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用ES2021，您可以缩短整个结构:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b96b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，您只是缩短了为未初始化的变量分配默认值的方式。出发地:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5624" class="lb lc iq mv b gy mz na l nb nc">person.firstName = person.firstName|| person.firstName='Commander';</span></pre><p id="5015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="01df" class="lb lc iq mv b gy mz na l nb nc">person.firstName ||= 'Commander';</span></pre><p id="46d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="nd">注意</em> </strong> <em class="nd">:除此之外，旧的方法停止了对可能存在的getter方法的访问。另一种方法是调用底层的getter，如果存在的话。</em></p><h1 id="c406" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">字符串替换</h1><p id="4ab1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当您替换字符串中所有出现的子字符串时，使用正则表达式是最好的方法。您还可以使用polyfill函数<code class="fe ne nf ng mv b">replaceAllPolyfill()</code>，该函数将指定正则表达式的全局搜索应用于相应的字符串。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cd6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个选择是使用字符串方法<code class="fe ne nf ng mv b">split()</code>来完成。这个方法在传递的子字符串出现的所有地方分割字符串，并将各个部分作为数组返回。在这个数组上调用<code class="fe ne nf ng mv b">join()</code>,指定要插入的新字符串，将整个事情放回一起。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ba8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该清楚的是，由于性能原因，这些方法效率较低。长字符串和频繁出现的搜索字符串会很快发现这一点。<code class="fe ne nf ng mv b">replaceAll()</code>方法将来会简化这一切:它用指定为第二个参数的新字符串替换指定为第一个参数的子字符串的所有出现。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bc34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你现在看到的，我们可以优化一切，以编写更少的代码和更高的性能。</p><h1 id="0079" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">承诺</h1><p id="fc2d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">ES2020已经有了一个通过<code class="fe ne nf ng mv b">allSettled()</code>方法扩展承诺的特性。在ES2021我们会在这个团队中得到一个新的玩家，他就是<code class="fe ne nf ng mv b">any()</code>。它期望得到一个可重复的承诺，并返回一个承诺，当一个承诺被实现时，这个承诺就被实现。每当所有通过的承诺被拒绝时，同样的行为对于拒绝也是有效的，并且<code class="fe ne nf ng mv b">any()</code>返回一个被拒绝的承诺。在后一种情况下，用户可以通过<code class="fe ne nf ng mv b">AggregateError</code>访问关于所有被拒绝承诺的相应错误的详细信息。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，当滚动异步解决/拒绝承诺示例时，<code class="fe ne nf ng mv b">any()</code> <em class="nd"> </em>函数等待第一个解决的示例，然后才打印出<code class="fe ne nf ng mv b">firstResolver</code>。当每个承诺都被拒绝时，它会为try-catch包装器触发一个错误。第三个例子清楚地说明了为什么<code class="fe ne nf ng mv b">firstResolver</code>没有控制台打印。</p><h1 id="af80" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">WeakRefs</h1><p id="b916" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我打赌你知道<code class="fe ne nf ng mv b">WeakSet</code>和<code class="fe ne nf ng mv b">WeakMap</code>。自ES2015年开始实施。WeakSet是对象的集合。WeakMap是键-值对的集合，其中每个键必须是一个对象。它们之间的联系是让对象被弱引用。这意味着，如果没有对这些对象的其他强引用，这些对象可以作为垃圾收集的一部分从内存中移除。因此，对对象的弱引用是一种不阻止垃圾收集器从内存中移除该对象的引用。相反，正常(或强)引用将对象保存在内存中。</p><p id="82a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES2021可以通过手动使用<code class="fe ne nf ng mv b">WeakRef</code>对象来创建对<code class="fe ne nf ng mv b">WeakSet</code>或<code class="fe ne nf ng mv b">WeakMap</code>上下文之外的对象的弱引用。相应的建议警告您在使用<code class="fe ne nf ng mv b">WeakRef</code>之前要小心。无论如何，检查它的使用是否合理。基本上，如果可能的话，应该避免使用。垃圾收集太复杂且依赖于系统，因此很难预测垃圾收集器的确切行为。</p><h1 id="31b8" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">二进制、十六进制和BIGINT最终变得可读</h1><p id="7769" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">阅读大数字容易吗？我介意的答案是:不！这同样适用于大整数、大二进制数和十六进制数。那么，为什么要等到2021年才引入大数值的可读格式呢？我不知道，因为其他语言也有(Java、Python、Perl、Ruby和C#)，但现在JavaScript也有了。数字分隔符的功能将帮助我们的眼睛保持清醒。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="15ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个分隔符，我们只需将分隔符放在相应的数字组之间，就可以使数值更具可读性。分隔符适用于十进制记数法中的数字、二进制或十六进制记数法中的数字，并使用ES2020中引入的BigInts。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="744a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="nd">注意</em> </strong> <em class="nd">:通过</em> <code class="fe ne nf ng mv b"><em class="nd">===</em></code> <em class="nd">运算符比较时，分隔符不影响数值。</em></p><h1 id="e147" class="lz lc iq bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">结论</h1><p id="4b79" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Javascript的标准一直在稳步发展。虽然发布还有几个月，但一些相当不错的功能已经完成，正在等待2021版的大发布。如果所有的特性都融入到新版本中，这将是JavaScript的又一次伟大的进步。在<a class="ae kc" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposals</a>上展示了当前状态的概述，在<a class="ae kc" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tc39/proposals/blob/master/finished-proposals . MD</a>上提供了第四阶段功能的概述。[1], [2]</p><p id="a194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">张贴支持表的图片是不够的，因为一旦我做了一个截图，该表几乎立即过时。点击<a class="ae kc" href="https://kangax.github.io/compat-table/esnext/" rel="noopener ugc nofollow" target="_blank">这里</a>查看对通用操作系统、服务器端JavaScript运行时环境(如Node.js)和移动浏览器的支持。</p><p id="0f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为你自己节省大量的时间，专注于重要的主题。  </p><p id="3fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">延伸阅读</strong></p><div class="nj nk gp gr nl nm"><a href="https://medium.com/javascript-in-plain-english/dont-fall-for-these-3-common-typescript-pitfalls-43dd597fc723" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">不要陷入这三个常见的类型脚本陷阱</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">我打赌你以前遇到过这3种类型脚本/JavaScript陷阱…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jw nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://medium.com/agileinsider/is-kanban-just-putting-sticky-notes-onto-a-wall-1d8c3092213e" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">看板只是把便签贴在墙上吗？</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">关于何时以及何时不使用看板的看板指南</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jw nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://medium.com/front-end-weekly/html-dom-guide-for-everyone-ec07fdca93a1" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">面向所有人的HTML DOM指南</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">关于HTML 5中的DOM您必须知道的一切</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa jw nm"/></div></div></a></div><p id="7330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考文献</strong></p><p id="11d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[1] TC39提案<a class="ae kc" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposals</a></p><p id="296a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2] TC39第四阶段功能<a class="ae kc" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" rel="noopener ugc nofollow" target="_blank">https://github . com/TC39/proposals/blob/master/finished-proposals . MD</a>。</p><p id="eb10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]https://kangax.github.io/compat-table/esnext/ECMA支持表<a class="ae kc" href="https://kangax.github.io/compat-table/esnext/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>