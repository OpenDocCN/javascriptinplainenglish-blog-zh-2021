<html>
<head>
<title>Why You Should Stop Using Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该停止使用循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-stop-using-loops-88a6a789106e?source=collection_archive---------9-----------------------#2021-03-30">https://javascript.plainenglish.io/why-you-should-stop-using-loops-88a6a789106e?source=collection_archive---------9-----------------------#2021-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="78ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你和我一样，你在JavaScript中使用for和while循环的时间最长。我是说，如果它能完成任务，那还有什么问题呢？嗯，虽然它完成了工作，但是当应用程序的规模和复杂性增加时，它可能会成为一个问题。</p><p id="3c7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有3个很好的理由说明为什么你应该停止使用循环。我们还将看看循环的各种替代方案，它们将帮助我们以更好的方式完成任务。</p><h1 id="2c64" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">1.易于阅读和维护</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/23f75a8b5070149310be846a8ad179fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwTkAI8W-sBhM1eGi1j8rg.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lw" href="https://pixabay.com/photos/fittings-water-polo-construction-2784899/" rel="noopener ugc nofollow" target="_blank">The cleaner it is the easier it is to maintain it.</a></figcaption></figure><p id="1b2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数式编程是一个概念，应用程序中的一切都可以归结为纯粹的函数。一个纯函数是这样的，它接受一组参数，进行一些计算并返回一个结果。它不访问函数之外的任何东西，<strong class="jm io"> <em class="lx">它自己就是纯粹的</em> </strong>。更重要的是，它只做一件事。功能越简单越好。好处是:减少冗余，模块化和易于维护。</p><p id="1b53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这和循环有什么关系？让我们看一个简单的例子。假设我们需要一个数组，把所有的数字加进去，然后把它连接成一个字符串:</p><p id="0c84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">非函数式编程方式同For循环:</em> </strong></p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="950d" class="md kj in lz b gy me mf l mg mh">var numberArray = [1,2,3,4,5,6];<br/>var stringToConcatTo = "Total:";</span><span id="1728" class="md kj in lz b gy mi mf l mg mh">function addNumbersAndConcat(arr, str){<br/>  var total = 0;<br/>  for (var index = 0; index &lt; arr.length; index++){<br/>    total += arr[index];      <strong class="lz io"><em class="lx">// Add total</em></strong><br/>  }<br/>  str += total.toString();    <strong class="lz io"><em class="lx">// Concatenate to the string <br/>  </em></strong>return str;<br/>}<br/><strong class="lz io"><em class="lx">// Function Call</em></strong><br/>this. addNumbersAndConcat(numberArray, stringToConcatTo);</span></pre><p id="fbfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，代码按照我们希望的那样工作，但是，它偏离了函数式编程的概念。该函数执行不止一次计算(加法代码块和级联代码块)。我们可以通过将加法部分放在不同的函数中，然后在这里调用它来解决这个问题。这样，这个函数只接受加法函数的输出，并进行连接。所以在这种情况下，它只是为连接做“计算”。</p><p id="2bb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">功能编程方式同For循环:</em> </strong></p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="4cfc" class="md kj in lz b gy me mf l mg mh">var numberArray = [1,2,3,4,5,6];<br/>var stringToConcatTo = "Total:";</span><span id="bb80" class="md kj in lz b gy mi mf l mg mh">function addArray(arr) {<br/>  var total = 0;<br/>  for (var index = 0; index &lt; arr.length; index++){<br/>    total += arr[index];      <strong class="lz io"><em class="lx">// Add total</em></strong><br/>  }<br/>  return total.toString();<br/>}</span><span id="4a42" class="md kj in lz b gy mi mf l mg mh">function concatToTotal(arr, str){<br/>  str += this.addArray(arr);    <strong class="lz io"><em class="lx">// Concatenate to the string <br/>  </em></strong>return str;<br/>}</span><span id="e707" class="md kj in lz b gy mi mf l mg mh">concatToTotal(numberArray, stringToConcatTo); <strong class="lz io"><em class="lx">// Function Call</em></strong></span></pre><p id="6ab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很好，但如果我们只是消除循环，我们可以做得更好。在JavaScript中我们可以使用<strong class="jm io"> <em class="lx">映射、归约和过滤。</em> </strong> <em class="lx"> </em>这些功能就是为此而设计的。使用它们，我们使我们的代码更容易阅读，理解，并保持其功能性编程。在我们的特例中，我们将使用<strong class="jm io"> <em class="lx">减少</em> </strong>来改进我们的代码。</p><p id="313b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">无循环功能编程方式:</em> </strong></p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="ab11" class="md kj in lz b gy me mf l mg mh">var numberArray = [1,2,3,4,5,6];<br/>var stringToConcatTo = "Total:";</span><span id="828b" class="md kj in lz b gy mi mf l mg mh">function concatToTotal(arr, str){<br/>  str += arr.reduce((acc, currVal) =&gt; acc + currVal).toString();<br/>  return str;<br/>}</span><span id="7a51" class="md kj in lz b gy mi mf l mg mh">concatToTotal(numberArray, stringToConcatTo);</span></pre><p id="4cac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经重构了我们的be严格函数，reduce帮助我们消除了循环，使它更紧凑，更易于阅读，更易于将来维护。</p><p id="1f73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">注:</em> </strong> <em class="lx">由于reduce的函数被很好地定义，代码更容易阅读，因此，看到reduce你就已经知道它应该做什么了。不像loop，需要检查每一行才能了解循环在做什么。还要注意，在这种情况下使用reduce over for-loop不会显著提高性能。</em></p><p id="6829" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里阅读更多关于reduce <a class="ae lw" href="https://levelup.gitconnected.com/one-reduce-to-rule-them-all-504e1b790a83" rel="noopener ugc nofollow" target="_blank">的内容。这是我迄今为止发现的对reduce最好的解释之一。</a></p><h1 id="ec5b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 2。可组合性</strong></h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/5c9337e708a7c4a03f176040be9601af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5bS4wnWOn9PYjhc1vxqAQ.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lw" href="https://pixabay.com/photos/chain-stainless-steel-metal-iron-4049725/" rel="noopener ugc nofollow" target="_blank">Composability is chain-like</a></figcaption></figure><p id="6027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，JavaScript array类提供的函数map、reduce和filter是通用的，并且支持可组合性。可组合性简单地说就是，你可以在一个函数中做一件事，然后将输出传递给下一个函数，再传递给下一个函数以获得最终输出。这就像链接多个循环，但更漂亮。</p><p id="bbae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举一个例子:你应该在你的web应用程序中创建一个特性。它返回销售额最高的销售人员的姓名。</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="a736" class="md kj in lz b gy me mf l mg mh">var nameList = [<br/>  {<br/>    "name": "Alice", "role": "Accountant", "papers_sold": 0<br/>  },<br/>  {<br/>    "name": "Bob", "role": "Sales", "papers_sold": 1000<br/>  },<br/>  {<br/>    "name": "Charles", "role": "Accountant", "papers_sold": 0<br/>  }<br/>  {<br/>    "name": "Dan", "role": "Sales", "papers_sold": 1200<br/>  }<br/>  {<br/>    "name": "Emily", "role": "Sales", "papers_sold": 1600<br/>  } <br/>]</span></pre><p id="c419" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先我们需要把销售和会计分开。然后，我们需要找出售出论文数量最多的销售人员。</p><p id="6fa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">传统上，我们会使用for循环来遍历数组。制作一个只有销售人员的新阵列。然后我们检查一下，找到销售额最高的人。它最终看起来会比实际需要的更丑陋、更复杂。</p><p id="3351" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，通过组合filter和reduce，我们可以这样做</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="a1ea" class="md kj in lz b gy me mf l mg mh">function bestRecordInDept(nameList, role){ <br/>  return nameList<br/>      .filter(record =&gt; record.role === role)<br/>      .reduce((acc, value) =&gt; { <br/>        <strong class="lz io"><em class="lx">// Replace with the greater value</em></strong>  <br/>        acc = acc.papers_sold &gt; value.papers_sold ? value : acc; <br/>        return acc.name;                     <br/>      }, {})<br/>}</span></pre><p id="93ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们使用filter过滤掉只有Sales作为角色的记录，然后将数据减少到销售量最大的销售人员的姓名。在这里，我们能够在不修改原始数组的情况下构造filter和reduce，这将我们带到下一点。</p><p id="3dbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lx">注意:</em> </strong> <em class="lx">实际上，对于这个特定的用例，我们将避免使用filter，而只在reduce中使用if语句。这将通过过滤器为我们节省一次数组迭代。我们在这里使用filter只是作为可组合性的一个例子。关于可组合性更详细的例子，你可以看这里的</em><a class="ae lw" href="https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209" rel="noopener ugc nofollow" target="_blank"><em class="lx"/></a></p><h1 id="eb62" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">3.不变</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/f969320cffc4b52a8a452fdc2b269d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZdok4bxcGYB8iRy4N8XWQ.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lw" href="https://pixabay.com/photos/parrot-kitty-ara-cat-bird-animal-3762988/" rel="noopener ugc nofollow" target="_blank">That’s a mutant</a></figcaption></figure><p id="3ca2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，通过使用循环，我们最终会修改我们正在循环的原始数组。这可能会导致难以跟踪的错误。如果不小心的话，通过在多个地方改变数组的内容，我们可能会导致一些严重的不希望的“特性”。</p><p id="c848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用固有的JavaScript原型函数，如map，我们消除了这种可能性。这是因为，map从不修改原始数组。它总是返回一个新的数组。这使得您的原始数组不可变，从而防止了未来在这方面出现任何错误的可能性。</p><p id="1b9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比方说，你需要看看给每个人加薪2%是什么样子。这意味着您需要保持原始记录不变。你只需要看到一些数据来为未来做准备。</p><p id="8674" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您使用传统的循环来实现这一点，它可能看起来像这样:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="41ea" class="md kj in lz b gy me mf l mg mh">var newNameList = nameList;<br/>for (var index = 0; index &lt; newNameList.length; index++){<br/>  newNameList[index].salary = newNameList[index].salary*0.25;<br/>}<br/>console.log(newNameList);</span></pre><p id="ece0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题就在这里。当您将一个数组分配给另一个数组时，它会通过引用创建一个副本。也就是说，当您修改newNameList salary时，NameList(您的原始数组)中的salary也会发生变化。这可不好。</p><p id="b066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种方法是通过值创建数组的副本。可以通过在数组上使用slice来实现这一点，如下所示:name list . slice()；</p><p id="cae3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我们可以通过简单地使用这样的映射来避免整个问题:</p><pre class="lh li lj lk gt ly lz ma mb aw mc bi"><span id="a02b" class="md kj in lz b gy me mf l mg mh">console.log(nameList.map(x =&gt; x.salary += x.salary* 0.02));</span></pre><p id="f864" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">干净多了，没有变异。:)</p><h1 id="e845" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">性能问题</h1><p id="6f1f" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">如果使用得当，传统循环与映射、减少和过滤之间的性能差异可以忽略不计。</p><p id="8a9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两个主要因素需要考虑:</p><p id="de93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">迭代:</strong> <em class="lx">与传统的循环相比，只要你使用map、reduce和filter来保持相同或更少的迭代次数，你应该是不错的。</em></p><p id="1cea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据的大小:</strong> <em class="lx">对于非常大的数据，比如100万条数据记录，你最好使用一个For循环，必要时中间要有一个断点。在我的测试中，大约有0.2-0.3秒的微小差异，不会更多。当然，数据越大，差异就越显著。</em></p><h1 id="a2e9" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">那么什么时候应该使用循环呢？</strong></h1><p id="c7a6" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">大多数程序员习惯于考虑一个需要迭代的问题，并直接使用循环，因为这是我们最开始使用的，而且用得很多。这篇文章，最重要的是，在你思考问题的时候，努力让你远离这种思维定势。这并不意味着您需要完全丢弃循环。</p><p id="a47c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我问自己两个简单的问题来决定是否需要一个循环:</p><ol class=""><li id="1db9" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">性能是否受到显著影响？</li><li id="28f8" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我只是想让我的代码看起来更酷吗？<em class="lx">(我们都经历过)</em>目标是让未来的你读起来简单。过度设计只会使维护更加困难。</li></ol><p id="aaf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这两个问题的答案都是肯定的，那么我就去循环。</p><h1 id="b9c7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="8f7a" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">我希望有助于影响您将来编码和思考问题的方式。我很想听听你的想法。你同意吗？不同意？请在评论中告诉我。</p><p id="02e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些有用的链接:</strong><br/><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">JavaScript中的Map函数</a><br/><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">JavaScript中的Reduce函数</a><br/><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">JavaScript中的Filter函数</a></p><p id="f44a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lx">更多内容看</em><a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>