<html>
<head>
<title>Fixing useContext Performance Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复使用上下文性能问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fixing-usecontext-performance-issues-bfc695f48192?source=collection_archive---------6-----------------------#2021-01-16">https://javascript.plainenglish.io/fixing-usecontext-performance-issues-bfc695f48192?source=collection_archive---------6-----------------------#2021-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f847" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您希望使用useState和useContext作为状态管理解决方案，但是每次上下文提供者的值发生变化时，整个树都会重新呈现。你可以使用像<a class="ae ki" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>、<a class="ae ki" href="https://github.com/pmndrs/valtio" rel="noopener ugc nofollow" target="_blank"> Valtio </a>、<a class="ae ki" href="https://zustand.surge.sh/" rel="noopener ugc nofollow" target="_blank"> Zustand </a>和<a class="ae ki" href="https://github.com/pmndrs/jotai" rel="noopener ugc nofollow" target="_blank"> Jotai </a>这样的库来解决这个问题，但是你必须改变你存储和访问全局状态的方式。</p><p id="e964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有没有一种方法可以解决useContext的问题？很高兴你问了！是的有！这是<a class="ae ki" href="https://react-tracked.js.org/" rel="noopener ugc nofollow" target="_blank"> react-tracked </a>，一个来自Daishi Kato的新库，他在react状态管理领域做了惊人的工作。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7f4e3e9e53371a85aa13630c42eb9760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oce5M2lgmhM_50gF36guhA.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Banner image</figcaption></figure><h1 id="d2cd" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设置useState/useContext全局存储</h1><p id="a3c5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">你需要做的第一件事是正确设置你的商店。Daishi已经有了一些关于这个的优秀文档，但是让我们一步一步地浏览这个商店的打字版本。</p><p id="690a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们创建一个<code class="fe mc md me mf b">store.tsx</code>文件，并以一些React导入、存储结构和一个创建<code class="fe mc md me mf b">useState</code>钩子的函数开始该文件。</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="9e72" class="mk la in mf b gy ml mm l mn mo"><em class="mp">import</em> React, { createContext, useState, useContext } <em class="mp">from</em> 'react';</span><span id="c631" class="mk la in mf b gy mq mm l mn mo"><em class="mp">const</em> initialState = {<br/>  text1: "text1",<br/>  text2: "hello",<br/>};</span><span id="32cf" class="mk la in mf b gy mq mm l mn mo"><em class="mp">const</em> useMyState = () =&gt; useState(initialState);</span></pre><p id="c754" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的初始存储非常简单，我们有几段文本，我们有一个函数调用带有初始状态的React <code class="fe mc md me mf b">useState</code>钩子。</p><p id="7601" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我们不直接调用<code class="fe mc md me mf b">useState</code>并缓存结果呢？因为React挂钩需要从React组件内部调用，这样它们就可以绑定到组件实例。因此，我们需要一个能在需要时创建状态的函数。</p><p id="bc84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是创建上下文:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="7162" class="mk la in mf b gy ml mm l mn mo"><em class="mp">const</em> MyContext = createContext&lt;ReturnType&lt;<em class="mp">typeof</em> useMyState&gt; | <em class="mp">null</em>&gt;(<em class="mp">null</em>);</span></pre><p id="ce6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个标准的<code class="fe mc md me mf b">createContext</code>调用，其中上下文要么保存<code class="fe mc md me mf b">null</code>(启动时)，要么保存来自<code class="fe mc md me mf b">useMyState</code>调用的返回类型。这将是带有当前值的数组的标准<code class="fe mc md me mf b">useState</code>返回，以及一个setter函数。</p><p id="adb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们需要创建<code class="fe mc md me mf b">SharedStateProvider</code> React功能组件:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="4ab9" class="mk la in mf b gy ml mm l mn mo"><em class="mp">const</em> MyContext = createContext&lt;ReturnType&lt;<em class="mp">typeof</em> useMyState&gt; | <em class="mp">null</em>&gt;(<em class="mp">null</em>);</span><span id="2388" class="mk la in mf b gy mq mm l mn mo"><em class="mp">export</em> <em class="mp">const</em> SharedStateProvider: React.FC = ({ children }) =&gt; (<br/>   &lt;MyContext.Provider value={<strong class="mf io">useMyState()</strong>}&gt;<br/>      {children}<br/>   &lt;/MyContext.Provider&gt;<br/>);</span></pre><p id="21d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该组件位于React树的顶部，并向下提供上下文给任何使用它的子组件。注意，我们此时正在调用<code class="fe mc md me mf b">useMyState</code>，因为我们在React组件的上下文中，这样做是安全的。</p><p id="79de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的最后一步是创建一个定制钩子来获取状态和状态设置器:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="e5a4" class="mk la in mf b gy ml mm l mn mo"><em class="mp">export</em> <em class="mp">const</em> useSharedState = () =&gt; {<br/>   <em class="mp">const</em> value = useContext(MyContext);<br/>   <em class="mp">if</em> (value === <em class="mp">null</em>)<br/>     <em class="mp">throw</em> <em class="mp">new</em> Error('Please add SharedStateProvider');<br/>   <em class="mp">return</em> value;<br/>};</span></pre><p id="1475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个定制钩子首先使用<code class="fe mc md me mf b">useContext</code>来获取上下文。然后，它检查以确保它有那个上下文，如果没有，就抛出一个错误。最后，它返回上下文，这将是<code class="fe mc md me mf b">useState</code>的输出，因此是一个带有值和setter的数组。</p><p id="6684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们的全球商店设置已经完成。没有图书馆。只是用钩子做一些基本的反应，并以一种非常简洁的方式构造。</p><h1 id="bed8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用商店</h1><p id="6b93" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">现在我们已经定义了我们的商店，我们首先导入<code class="fe mc md me mf b">SharedStateProvider</code>，并将其添加到我们的<code class="fe mc md me mf b">App</code>，如下所示:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="767e" class="mk la in mf b gy ml mm l mn mo">import { SharedStateProvider } from "./store";</span><span id="0842" class="mk la in mf b gy mq mm l mn mo">const App = () =&gt; (<br/>  &lt;SharedStateProvider&gt;<br/>     ...<br/>  &lt;/SharedStateProvider&gt;<br/>);</span></pre><p id="7a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不仅将为任何想要使用它的组件提供上下文，还将状态初始化为<code class="fe mc md me mf b">initialState</code>中的值。</p><p id="bcf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们可以添加一些使用该状态的组件，如下所示:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="ed9e" class="mk la in mf b gy ml mm l mn mo">import { useSharedState} from "./store";</span><span id="9eb6" class="mk la in mf b gy mq mm l mn mo">const Input1 = () =&gt; {<br/>  const [state, setState] = useSharedState();<br/>  return (<br/>    &lt;input<br/>      value={state.text1}<br/>      onChange={(evt) =&gt;<br/>        setState({<br/>          ...state,<br/>          text1: evt.target.value,<br/>        })<br/>      }<br/>    /&gt;<br/>  );<br/>};</span><span id="2df8" class="mk la in mf b gy mq mm l mn mo">const Text1 = () =&gt; {<br/>  const [state] = useSharedState();<br/>  return (<br/>    &lt;div&gt;<br/>      {state.text1}<br/>      &lt;br /&gt;<br/>      {Math.random()}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="b40e" class="mk la in mf b gy mq mm l mn mo">const Text2 = () =&gt; {<br/>  const [state] = useSharedState();<br/>  return (<br/>    &lt;div&gt;<br/>      {state.text2}<br/>      &lt;br /&gt;<br/>      {Math.random()}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="9144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在这段代码可以正常工作了。但是您会注意到,<code class="fe mc md me mf b">Text2</code>组件永远不需要更新，因为我们没有办法更新它所查看的<code class="fe mc md me mf b">text2</code>值，它会在全局状态改变时更新。</p><p id="10b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为React无法跟踪组件正在查看状态的哪一部分。它不会为你做这些工作，当你有很多全局状态时，这最终会成为一个性能问题。即使是最微小的变化，最终也会重新渲染一堆不需要重新渲染的组件。</p><p id="f4a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这个例子中看到这一点，因为当你在<code class="fe mc md me mf b">Input1</code>中输入字符时<code class="fe mc md me mf b">Text2</code>上的随机数会不断变化。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mr"><img src="../Images/ce6a8943d2334b049d1e236978e72010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z3kn-JBYZQHSRYLUrfDAfw.gif"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">GIF showing errant re-rendering of the Text2 component</figcaption></figure><p id="09b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面看到的，我没有改变<code class="fe mc md me mf b">text2</code>，但是显示<code class="fe mc md me mf b">text2</code>值的组件正在重新呈现。</p><h1 id="bae3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">反应-跟踪救援</h1><p id="643a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">为了解决这个问题，我们引入了5Kb的<code class="fe mc md me mf b">react-tracked</code>库，将其添加到我们的应用程序中:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="c9d8" class="mk la in mf b gy ml mm l mn mo">npm install react-tracked</span></pre><p id="b573" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从那里我们返回到<code class="fe mc md me mf b">store.tsx</code>文件并从库中导入<code class="fe mc md me mf b">createContainer</code>函数:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="c123" class="mk la in mf b gy ml mm l mn mo">import { createContainer } from "react-tracked";</span></pre><p id="bf23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后<strong class="jm io">删除<code class="fe mc md me mf b">useSharedState</code>和<code class="fe mc md me mf b">SharedStateProvider</code>的定义</strong>，并添加以下代码:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="fe75" class="mk la in mf b gy ml mm l mn mo"><em class="mp">export</em> <em class="mp">const</em> {<br/>  Provider: SharedStateProvider,<br/>  useTracked: useSharedState,<br/>} = createContainer(useMyState);</span></pre><p id="1193" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mc md me mf b">createContainer</code>函数取状态创建函数:</p><pre class="kk kl km kn gt mg mf mh mi aw mj bi"><span id="7104" class="mk la in mf b gy ml mm l mn mo"><em class="mp">const</em> useMyState = () =&gt; useState(initialState);</span></pre><p id="a06d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后它返回一个<code class="fe mc md me mf b">Provider</code>和一个<code class="fe mc md me mf b">useTracked</code>，它们在导出时被重新映射到<code class="fe mc md me mf b">SharedStateProvider</code>和<code class="fe mc md me mf b">useSharedState</code>，这是组件所期望的。</p><p id="e520" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果是一种隔离，其中组件仅在它们“跟踪”的数据被更改时才重新呈现，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mr"><img src="../Images/3d19c93e023e6d17cbe1f1f0aa61feef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wjHXQQOBnqku-8htRuoF3w.gif"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">GIF showing only the Text1 component rendering when text1 is changed</figcaption></figure><p id="8d51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我改变<code class="fe mc md me mf b">text1</code>时，只有<code class="fe mc md me mf b">Text1</code>组件会改变。</p><p id="2d8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于5个5Kb的额外代码来说，这已经不错了。</p><h1 id="9f1e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="1149" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Daishi Kato的<code class="fe mc md me mf b">react-tracked</code>库是一种简单的方法，通过智能地跟踪状态的哪些部分被每个组件使用，来获得一个分解良好的<code class="fe mc md me mf b">useState/useContext </code>状态管理解决方案，并使其具有高性能。</p><h1 id="ccfa" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">视频版本</h1><p id="57db" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果你想要这篇文章的视频版本，请查看react-tracked上的这个蓝领代码短片。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Link to a YouTube version of this article</figcaption></figure></div></div>    
</body>
</html>