<html>
<head>
<title>Monads For JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript开发人员的单子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/monads-for-javascript-developers-af29819823c?source=collection_archive---------2-----------------------#2021-02-07">https://javascript.plainenglish.io/monads-for-javascript-developers-af29819823c?source=collection_archive---------2-----------------------#2021-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="bbed" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">JavaScript Alpha指南</h2><div class=""/><div class=""><h2 id="c2e9" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">什么是单子？你不必是范畴理论专家就能理解。你必须知道JavaScript的承诺。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7c0a83cba56a944cd267a73561816606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gA2dHvfpZEylFTBuiLiKxw.jpeg"/></div></div></figure><p id="3b25" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">像其他程序员一样，我想知道什么是单子。但是每次你在网上搜索单子，你都会被范畴理论论文淹没。而其他资源似乎也没多大意义。</p><p id="0c46" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为了了解单子是什么，我付出了艰辛的努力。我开始学习哈斯克尔。几个月后我才意识到，人们对单子太过重视了。如果您是一名JavaScript开发人员，那么您肯定每天都在使用它们。你只是没有意识到。</p></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="ca1b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们不会详细讨论范畴理论或Haskell，但是有一件事你需要知道。当你在互联网上搜索单子时，你不能错过这个定义:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="24f0" class="mf mg in mb b gy mh mi l mj mk">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span></pre><p id="135c" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这是Haskell中一个<code class="fe ml mm mn mb b">bind</code>操作符的定义。不同的语言对此操作有不同的名称，但它们都表示相同的意思。一些替代的名字是<code class="fe ml mm mn mb b">chain</code>、<code class="fe ml mm mn mb b">bind</code>、<code class="fe ml mm mn mb b">flatMap</code>、<code class="fe ml mm mn mb b">then</code>、<code class="fe ml mm mn mb b">andThen</code>。</p><h1 id="3104" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">一元语境</h1><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="cfb0" class="mf mg in mb b gy mh mi l mj mk">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><span id="95b2" class="mf mg in mb b gy nf mi l mj mk">m    :: monadic context<br/>a, b :: value inside the context (string, number, ..)</span></pre><p id="5353" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">一元上下文</strong>只是一个盒子，它实现了这个盒子成为一元所需的所有东西。一个非常简单的(非一元的)盒子可能是这样的:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="e16c" class="mf mg in mb b gy mh mi l mj mk">const Box = val =&gt; ({ val }); <br/>const foo = Box("John");</span></pre><p id="1417" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这是一个盒子——只是一个包装好的值。该框没有任何行为，因为它没有任何方法。</p><blockquote class="ng"><p id="82ed" class="nh ni in bd nj nk nl nm nn no np ls dk translated">要使某物成为单子，你必须让它自己表现得像单子。</p></blockquote><p id="350d" class="pw-post-body-paragraph kx ky in kz b la nq jx lc ld nr ka lf lg ns li lj lk nt lm ln lo nu lq lr ls ig bi translated">所以让我们回到<code class="fe ml mm mn mb b">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>。<code class="fe ml mm mn mb b">(&gt;&gt;=)</code>用作中缀运算符:<code class="fe ml mm mn mb b">m a &gt;&gt;= (a -&gt; m b)</code>。并且<code class="fe ml mm mn mb b">(&gt;&gt;=)</code>操作的结果是<code class="fe ml mm mn mb b">m b</code>。</p><h1 id="46e3" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">问题是</h1><p id="d847" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">有没有注意到我们有<code class="fe ml mm mn mb b">m a</code>，但是函数把<code class="fe ml mm mn mb b">a</code>作为参数？这就是单子的意义。</p><p id="9f0c" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><code class="fe ml mm mn mb b">(&gt;&gt;=)</code>操作是关于在一元上下文<code class="fe ml mm mn mb b">m a</code>中取一个值，展开它，所以我们只得到<code class="fe ml mm mn mb b">a</code>并将它流水线化到函数<code class="fe ml mm mn mb b">(a -&gt; m b)</code>。这不是魔法。您必须自己编写该行为的代码。我们以后会看到的。</p><h1 id="b733" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">JavaScript承诺类似于单子</h1><p id="89fb" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">更好地说，他们有单子式的行为。对于要成为单子的东西，它还必须实现一个<strong class="kz ix">函子</strong>和<strong class="kz ix">可应用的</strong>接口。我提到这一点只是为了完整性，但我们不会更深入。</p><p id="5fc1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">JavaScript <strong class="kz ix">承诺</strong>用<code class="fe ml mm mn mb b">.then()</code>方法实现一元接口。让我们看看。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="245f" class="mf mg in mb b gy mh mi l mj mk">// p :: m a :: Promise { 42 }<br/>const p = Promise.resolve(42);</span></pre><p id="73fa" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这基本上创建了一个盒子。我们有一个值<code class="fe ml mm mn mb b">42</code>，在<strong class="kz ix">承诺</strong>里面。☝️这是我们的<code class="fe ml mm mn mb b">m a</code>。</p><p id="57ab" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">然后我们有一个将一个数除以二的函数。输入没有包含在<strong class="kz ix">承诺</strong>中。但是返回的函数被包装在一个<strong class="kz ix">承诺</strong>中。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="8eba" class="mf mg in mb b gy mh mi l mj mk">// divideByTwo :: (a -&gt; m b)<br/>const divideByTwo = val =&gt; Promise.resolve(val / 2);</span></pre><p id="63a5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">☝️这是我们的<code class="fe ml mm mn mb b">(a -&gt; m b)</code>。</p><p id="0b9e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">再次注意，我们在<strong class="kz ix">承诺</strong>中有一个值<code class="fe ml mm mn mb b">42</code>，但是函数<code class="fe ml mm mn mb b">divideByTwo</code>接受一个未包装的值。我们仍然可以把这些连接起来。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="472a" class="mf mg in mb b gy mh mi l mj mk">// p :: m a :: Promise { 42 }<br/>const p = Promise.resolve(42);<br/>// p2 :: m a :: Promise { 21 }<br/>const p2 = p.then(divideByTwo);<br/>// p3 :: m a :: Promise { 10.5 }<br/>const p3 = p2.then(divideByTwo);</span></pre><p id="4c38" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">或者更明显的是:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a889" class="mf mg in mb b gy mh mi l mj mk">// p :: m a :: Promise { 10.5 }<br/>const p4 = p.then(divideByTwo).then(divideByTwo);</span></pre><p id="e400" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">这是单子最重要的特征。</strong></p><p id="204e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">你有一个值在盒子里— <code class="fe ml mm mn mb b">Promise { 42 }</code>。您有一个接受展开值的函数— <code class="fe ml mm mn mb b">42</code>。类型不匹配— <code class="fe ml mm mn mb b">m a</code> vs. <code class="fe ml mm mn mb b">a</code>。您仍然可以将该函数应用于装箱后的值。</p><h2 id="5dd5" class="mf mg in bd mp ob oc dn mt od oe dp mx lg of og mz lk oh oi nb lo oj ok nd it bi translated">这怎么可能</h2><p id="dd41" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">因为<strong class="kz ix">承诺</strong>以那种方式实现了<code class="fe ml mm mn mb b">then</code>方法。大多数时候，运行在<strong class="kz ix">承诺</strong>中的代码是异步的。但是<strong class="kz ix"> Promise的</strong>单子式行为使得链接一系列函数成为可能。</p><p id="b96f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">单子抽象掉辅助数据管理、控制流或副作用。</strong>将可能复杂的功能序列转化为简洁的流水线。</p><h1 id="b25d" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">自定义单子式类</h1><p id="dad3" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">我用TypeScript编写了一个非常简单的单子式类的例子。它不会产生任何副作用，但允许函数链接。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5a23" class="mf mg in mb b gy mh mi l mj mk">class Dummy&lt;T&gt; {<br/>  constructor(private val: T) {}</span><span id="8c8e" class="mf mg in mb b gy nf mi l mj mk">  chain&lt;TResult&gt;(fn: (value: T) =&gt; Dummy&lt;TResult&gt;): Dummy&lt;TResult&gt; {<br/>    return fn(this.val);<br/>  }</span><span id="61eb" class="mf mg in mb b gy nf mi l mj mk">  static unit&lt;T&gt;(val: T): Dummy&lt;T&gt; {<br/>    return new Dummy(val);<br/>  }<br/>}</span><span id="8600" class="mf mg in mb b gy nf mi l mj mk">const d = new Dummy(41);<br/>d.chain(val =&gt; new Dummy(val + 1))<br/> .chain(val =&gt; new Dummy("The answer is: " + val));</span></pre><h1 id="f739" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated"><strong class="ak">单子定律</strong></h1><p id="f3ec" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">有单子行为的类必须遵守一些法则。</p><ul class=""><li id="168f" class="ol om in kz b la lb ld le lg on lk oo lo op ls oq or os ot bi translated">左侧标识</li><li id="bc95" class="ol om in kz b la ou ld ov lg ow lk ox lo oy ls oq or os ot bi translated">正确的身份</li><li id="803b" class="ol om in kz b la ou ld ov lg ow lk ox lo oy ls oq or os ot bi translated">结合性</li></ul><p id="2cc4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">你可以在网上了解更多。我将在这里放一段代码，证明虚拟类遵循这些规则。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="bdfd" class="mf mg in mb b gy mh mi l mj mk">const m = Dummy.unit(1);<br/>const f = (val: number) =&gt; new Dummy(val + 1);<br/>const g = (val: number) =&gt; new Dummy(val + 2);</span><span id="7883" class="mf mg in mb b gy nf mi l mj mk">// 1. left identity<br/>Dummy.unit(1).chain(f) ==== f(1)</span><span id="40c9" class="mf mg in mb b gy nf mi l mj mk">// 2. right identity<br/>m.chain(Dummy.unit) ==== m</span><span id="2696" class="mf mg in mb b gy nf mi l mj mk">// 3. associativity<br/>const m1 = Dummy.unit(1);<br/>m.chain(f).chain(g) ==== m.chain(val =&gt; f(val).chain(g)</span></pre><p id="3d24" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><code class="fe ml mm mn mb b">==</code>或<code class="fe ml mm mn mb b">===</code>在这里不起作用；对象引用不同。为此，我使用了不存在的<code class="fe ml mm mn mb b">====</code>,但将其理解为比较单子对象的内部值。</p><h1 id="2280" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">包扎</h1><p id="09e6" class="pw-post-body-paragraph kx ky in kz b la nv jx lc ld nw ka lf lg nx li lj lk ny lm ln lo nz lq lr ls ig bi translated">我希望这能对单子是什么有所启发。如果您是JavaScript开发人员，那么您每天都在使用它们。将封装在<strong class="kz ix">承诺</strong>中的值提供给期望解包值的函数。并再次返回一个包装在<strong class="kz ix">承诺</strong>中的新值。</p><h1 id="fec1" class="mo mg in bd mp mq mr ms mt mu mv mw mx kc my kd mz kf na kg nb ki nc kj nd ne bi translated">资源</h1><ul class=""><li id="c458" class="ol om in kz b la nv ld nw lg oz lk pa lo pb ls oq or os ot bi translated">(一)<a class="ae pc" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Monad _(functional _ programming)</a></li></ul></div></div>    
</body>
</html>