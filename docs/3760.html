<html>
<head>
<title>How to Escape the Try-Catch Hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何逃离试捕地狱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/escaping-the-try-catch-hell-176884be4ff2?source=collection_archive---------6-----------------------#2021-07-28">https://javascript.plainenglish.io/escaping-the-try-catch-hell-176884be4ff2?source=collection_archive---------6-----------------------#2021-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63b7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">承诺修复回调地狱，异步/等待修复承诺地狱，但还有一件事…</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6182bb5d0c9cf5740e59b77f57fb4dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W46lA4_hO9T2aK8EhFcLQ.png"/></div></div></figure><p id="cadb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将在async/await的上下文中解释什么是try-catch地狱，并且我还将分享一些如何避免这种情况的技巧。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="917c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们深入研究解决方案之前，让我们回顾一下过去和现在的情况。</p><p id="cd7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">起初，我们有回调，这是没问题的，直到我们必须执行多个顺序异步操作，这导致了深度嵌套。为了解决这个问题，ES6引入了承诺。承诺提供了<strong class="kt ir">然后</strong>、<strong class="kt ir">捕捉</strong>、<strong class="kt ir">最后</strong>等方法来处理不同的状态变化。ECMAScript 2017中引入了async/await。它基本上充当承诺之上的语法糖，使异步代码更容易编写和阅读。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="9780" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">什么是试捕地狱？试捕塔！</h2><p id="a5fe" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">除非必须处理错误，否则使用async/await非常有用。让我们来看看这个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/c58c3c5cfc17ebab62f0279e8db373b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PtRtfr-_MjRGHPL9CM8iQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Try-catch hell</figcaption></figure><p id="9dec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有两个将按顺序运行的请求。</p><p id="a8b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，为了对每个请求执行错误处理，我们需要为每个<strong class="kt ir"> await添加一个<strong class="kt ir"> try-catch </strong>块。</strong></p><p id="1f70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也许看起来不太糟，但是如果我们有3个请求呢？..还是4？..还是10？</p><p id="2731" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你同意这会变得很混乱。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="2141" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated"><strong class="ak">如何逃离试捕地狱？</strong></h2><p id="9167" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我不是go-lang开发人员，你可能也不是，但是让我们快速看一下go-lang通常是如何处理错误的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/91eeef2b92eb78b00a7839bc71049f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c38J9R8QtQJUzrgpdk-00Q.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">An HTTP request. Source: <a class="ae my" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/net/http/</a></figcaption></figure><p id="3773" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不使用try-catch块，而是返回一对两个值<strong class="kt ir">【结果，错误】</strong>。用javascript实现类似的东西很容易，我们只需要一个助手函数来包装返回一个承诺。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/7158a3ac167a4bd116bf0d2f1deefdfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvYPBwp5Jhw1QILSTfQElQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Additional function to handle errors</figcaption></figure><p id="07a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个看起来干净多了。</p><p id="c944" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个解决方案是将promises中的<strong class="kt ir"> catch </strong>方法与<strong class="kt ir"> await </strong>关键字结合起来，就像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/bc48783a1c2d91c6f8fbc200fa03cac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CkSAoV9ztHSmJlwDjwqOQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Combining promises with async/await</figcaption></figure><h2 id="6c6f" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">最后一点</h2><p id="07fe" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">使用一个额外的函数作为错误处理的包装器，可以为代码的可重用性提供一系列的可能性。例如，我们可以修改<strong class="kt ir">到</strong>函数来接收自定义功能，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/36b40c590b9a0c8a21e00438d2b82c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76ituLviBgaMgMPA1OLf-g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Custom error functionality</figcaption></figure><p id="e8c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不仅可以摆脱try-catch地狱，还可以使代码更易于维护和阅读。</p><p id="4771" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这些建议有用！</p><p id="a9e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nc">更多内容请看</em><a class="ae my" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>