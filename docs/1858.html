<html>
<head>
<title>How Does JavaScript Actually Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript实际上是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-does-javascript-actually-work-under-the-hood-567f9f17b855?source=collection_archive---------7-----------------------#2021-04-19">https://javascript.plainenglish.io/how-does-javascript-actually-work-under-the-hood-567f9f17b855?source=collection_archive---------7-----------------------#2021-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3d31" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript引擎、事件循环、回调队列和Web APIs的概述。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc8a508015cc0b9f8e3c9572ee65452e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yu5NcLYdU8kSM-1bZSuXsg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Credits: <a class="ae kv" href="https://wall-street.com/wp-content/uploads/2017/01/JavaScript.gif" rel="noopener ugc nofollow" target="_blank">wall-street.com</a> | Edited by the author</figcaption></figure><blockquote class="kw"><p id="2dc3" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">JavaScript是一种高级、单线程、垃圾收集、解释或即时编译、基于原型、多范例的动态语言，具有非阻塞事件<em class="lh">循环。</em></p></blockquote><p id="fd0c" class="pw-post-body-paragraph li lj iq lk b ll lm jr ln lo lp ju lq lr ls lt lu lv lw lx ly lz ma mb mc lg ij bi translated">由于JavaScript是单线程语言，它一次只能执行一组指令。考虑到有许多其他语言擅长处理并发和多线程，这种执行似乎很慢。</p><p id="acb8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">但是单线程执行的概念只是部分正确。JavaScript引擎作为一种执行手段可能是单线程的，但是JavaScript以不同的方式处理异步代码以实现并发。这是通过提供一些作为运行时环境一部分的附加组件来实现的，如事件循环、回调队列和Web APIs，它们是浏览器或Node.js运行时环境的一部分。</p><p id="6c7a" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这里我们将看看运行JavaScript代码时所涉及的不同组件。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="f7e0" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">JavaScript引擎</h1><p id="818b" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">JavaScript引擎是执行代码的部分。</p><p id="32ad" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">这里列出了一些流行的JavaScript引擎:</p><ul class=""><li id="0d98" class="nm nn iq lk b ll md lo me lr no lv np lz nq lg nr ns nt nu bi translated">谷歌Chrome浏览器和Node.js中使用的谷歌V8。</li><li id="3656" class="nm nn iq lk b ll nv lo nw lr nx lv ny lz nz lg nr ns nt nu bi translated">Mozilla Firefox浏览器中使用的SpiderMonkey。</li><li id="34d6" class="nm nn iq lk b ll nv lo nw lr nx lv ny lz nz lg nr ns nt nu bi translated">在Safari浏览器中使用的苹果公司的Nitro和JavaScriptCore。</li><li id="dbcd" class="nm nn iq lk b ll nv lo nw lr nx lv ny lz nz lg nr ns nt nu bi translated">微软的Chakra和CharkraCore，用于微软Edge浏览器。</li></ul><p id="e695" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">JavaScript引擎将您的JavaScript代码转换为机器语言，以便您的计算机可以执行它。</p><p id="0871" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">引擎的两个主要组件是堆内存(内存分配)和调用堆栈(执行上下文)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fed88d3f03f26dbae1b1699dec09851d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*s4lAzbu5-B8TwKj6srMV4A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Overview of the chrome’s V8 engine</figcaption></figure><h2 id="1644" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated"><strong class="ak">堆内存</strong></h2><p id="6800" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">它是引擎中为变量和函数声明分配内存的部分。</p><h2 id="bc06" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated"><strong class="ak">调用栈</strong></h2><p id="8ae7" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">它是引擎中负责执行代码的部分。当从上到下解析代码时，它被推到调用堆栈上。由于堆栈遵循<strong class="lk ir"> LIFO </strong>顺序，任何被推入堆栈的代码都将被执行，然后被弹出。这个过程将一直持续到每个代码块都被执行完。</p><p id="8ef8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">任何被推入调用堆栈的同步代码都会被立即执行并弹出。但是异步代码需要一些时间来完成，所以堆栈不会等到它完成才弹出堆栈。</p><p id="a556" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">相反，当任何异步代码被推到堆栈上时，它将立即弹出到运行时环境提供的Web APIs进行处理。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="0a61" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">示例显示了一个简单的同步任务以及整个执行过程中调用堆栈的状态:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/25f5e7becb36ab70453c133744f62b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/1*0QT0SGZ2qpEW9_C2uAgpPA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack for printing the result of 5 raised to the power of 4</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="5e49" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">示例显示了一个简单的同步任务在整个执行过程中抛出一个错误以及调用堆栈的状态:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/dfb29acd308690e7c26cb86db588cedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/1*Iqt3BbAMZeVGO3cQNAs-eQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The different states of the stack before throwing an error</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="06f4" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">运行时环境</h1><p id="b018" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">JavaScript的运行时环境可以是浏览器，也可以是已经安装的Node.js运行时环境。</p><p id="9fb1" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">如果代码是同步的，那么它会被立即执行。但是，如果一些代码需要更长的时间来运行，或者需要获取一些数据，或者需要一些繁重的处理，它将阻塞主线程。阻塞主线程直到所有的事情都完成了，这将导致网页停止做其他的事情。这将导致锁定页面，禁止滚动、执行进一步的指令，并且在每个任务执行之前，任何新组件的呈现都将被阻止。</p><p id="5a9d" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">JavaScript运行时环境(包括JavaScript引擎)提供了一些组件，如Web API、回调队列和事件循环，以使JavaScript并发。让我们详细讨论每一个问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/43b92bed9b8bd3fb0fde3ed7a1d0b05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l90LIcVik7ml_mi4X5UoWw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An overview of the runtime environment including the JS engine</figcaption></figure><h2 id="6878" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated"><strong class="ak"> Web API </strong></h2><p id="5dd1" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">大多数可能需要一些时间才能完成的异步任务将被推到调用堆栈上，然后立即弹出到运行时环境的Web APIs部分。</p><p id="916f" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">浏览器提供的一些具有异步行为的Web APIs是DOM APIs、Timer (setTimeout和setInterval)、Fetch API，同步的是存储API(session Storage和localStorage)。</p><p id="4bd4" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">你可以在这里查看所有可用的Web API<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="503d" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated"><strong class="ak">回调队列(任务队列)</strong></h2><p id="01d2" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">来自各种Web APIs的所有回调和结果都将被推送到回调或任务队列中。所有的回调/结果将被排队，稍后由事件循环移动到调用堆栈上。</p><p id="5c82" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">V8引擎的回调队列有一个微任务队列和一个宏任务队列。</p><p id="f253" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">回调、承诺、异步函数调用被归类为微任务。上述任务的优先级高于setTimeout、setInterval、DOM事件等。，它们被视为宏任务。</p><p id="d7a1" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">一旦WebAPIs处理了结果和回调，它们就被移动到各自的队列中。</p><h2 id="d456" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated"><strong class="ak">事件循环</strong></h2><p id="4d7e" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">事件循环是一个连续的过程，它的全部目的是查看调用堆栈是否为空。如果调用堆栈为空，它将在回调队列中查找任何排队的回调或任务，并将它们推送到调用堆栈。现在，事件循环首先选择哪个是基于它们的优先级。</p><p id="cba2" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">事件循环首先将任务从微任务队列推到调用堆栈上，然后查看宏任务队列。这个过程一直重复，直到回调或任务队列中的所有内容都被推送到堆栈上并执行。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="24e8" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">现在，让我们看看几个使用不同Web APIs的例子，以及事件循环根据回调队列中的微任务和宏任务选择了什么。</p><p id="c38c" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">一个示例显示了设置超时的执行顺序以及正常的控制台日志:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/749ff3de105857383a629d9126640674.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*E7guFDOlGuQKaJM0kO0mSQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack with console logs and a set timeout</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="784a" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">一个示例，显示了设置的超时时间为零时的执行顺序以及正常的控制台日志:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/570baf071063d0213803b96fa2a39408.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*WGkgzANYIdIw21tJNN1HCg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack with console logs and a set timeout with 0 waiting time</figcaption></figure><p id="d8b1" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在上面的例子中，即使<code class="fe ot ou ov ow b">setTimeout()</code>的等待时间为0，它也会被推送到Web APIs并立即移动到回调队列中，在所有同步控制台日志都打印出来后被回调。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="16bb" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">一个显示多个相同时间的超时以及控制台日志的例子:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/98d895e22a52025c761a3acb3098f06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*Q3iRSQLv2hgv8uXwmsMrYQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack with multiple set timeouts of the same time and console logs</figcaption></figure><p id="133a" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">在上面的例子中，三个<code class="fe ot ou ov ow b">setTimeout()</code>有相同的1000作为等待时间并被推送到Web APIs，然后在1000后按相同的顺序逐个移动到回调队列，并在所有同步控制台日志打印出来后被回调。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="9770" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">一个带有设置超时和异步函数的例子，该函数具有获取API和控制台日志:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/4276ce3bbc2f3e07fa38b0fd26d5893a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*lnd5I-p8U7TCqJ4SJB1B4A.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack with a set timeout, a fetch API, and a console log</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="50e6" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><strong class="lk ir">DOM onClick事件、setTimeout和简单控制台日志的示例:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/aa47d2eb15c030954e2963cb60d41dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*boMCcaFGTwl3uOc5-SZGVA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different states of the call stack with an onClick event, set timeouts and console logs</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="1efb" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated">结论</h2><p id="b350" class="pw-post-body-paragraph li lj iq lk b ll nh jr ln lo ni ju lq lr nj lt lu lv nk lx ly lz nl mb mc lg ij bi translated">这是JavaScript如何在幕后工作的概述，涉及不同的组件，如JavaScript引擎、WebAPIs、回调队列和事件循环。我希望这篇文章对你有所帮助。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h2 id="feaa" class="ob mq iq bd mr oc od dn mv oe of dp mz lr og oh nb lv oi oj nd lz ok ol nf om bi translated">参考</h2><ul class=""><li id="8b99" class="nm nn iq lk b ll nh lo ni lr ox lv oy lz oz lg nr ns nt nu bi translated">[1]JavaScript:Jeff Delaney在YouTube<a class="ae kv" href="https://www.youtube.com/watch?v=FSs_JYwnAdI" rel="noopener ugc nofollow" target="_blank">上介绍了它是如何制作的。</a></li><li id="45c3" class="nm nn iq lk b ll nv lo nw lr nx lv ny lz nz lg nr ns nt nu bi translated">wikipedia.org上的JS发动机。</li><li id="b36f" class="nm nn iq lk b ll nv lo nw lr nx lv ny lz nz lg nr ns nt nu bi translated">事件循环到底是什么？由菲利普·罗伯茨在YouTube上发布。</li></ul><p id="480e" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated">感谢阅读，祝学习愉快！</p><p id="8bb5" class="pw-post-body-paragraph li lj iq lk b ll md jr ln lo me ju lq lr mf lt lu lv mg lx ly lz mh mb mc lg ij bi translated"><em class="pa">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="pa">plain English . io</em></a></p></div></div>    
</body>
</html>