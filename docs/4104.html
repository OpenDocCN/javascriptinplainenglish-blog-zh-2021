<html>
<head>
<title>Introduction to Web Components — Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件简介—深入探讨</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-web-components-full-walkthrough-623023d365f1?source=collection_archive---------4-----------------------#2021-08-16">https://javascript.plainenglish.io/intro-to-web-components-full-walkthrough-623023d365f1?source=collection_archive---------4-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b175f41e501b71724c55286029ef5280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOgKD_B5fYSuv9K5-DJ_tQ@2x.jpeg"/></div></div></figure><p id="e6ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着更广泛和更好的支持，Web组件技术越来越受欢迎，并成为我和许多其他人最喜欢的构建web UI的方式。这些新的API解决了许多web开发问题，并提供了一种更简单的方法来将您的网站分成更小的可消化的部分，同时允许您更好地组织这些部分。</p><h2 id="f2d2" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">什么是Web组件？</h2><p id="4013" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Web Components不是一个单一的API，而是一个技术集合，它允许您使用封装的逻辑和样式创建可重用的元素(标记)。这是一种构建组件的原生方式，就像您使用React、Angular或Vue一样，但是没有一大堆的包袱。</p><p id="f3ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些API包括:</p><ul class=""><li id="b840" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry" rel="noopener ugc nofollow" target="_blank">自定义元素注册表</a></li><li id="a56e" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">暗影DOM </a></li><li id="a1dd" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">模板</a>和<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank">槽</a>标签</li></ul><h2 id="0af1" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">何时以及为何使用Web组件</h2><p id="9e00" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">虽然您可能不太听说它的采用，但它可以代替或与其他第三方UI库和框架一起使用，如React、Vue、Svelte、Angular等等。Angular特别提供了使用它来创建角度组件的选项。</p><p id="4d2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web组件不应该被视为第三方选项的替代品，而应该被视为增强器。也就是说，有几个原因让你应该考虑Web组件而不是第三方组件:</p><ul class=""><li id="203d" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><strong class="ka ir">小得多的包</strong>:当你使用第三方库来创建你的组件时，你不仅要把那些组件的代码，还要把库发送到浏览器，这样组件才能工作。然而，已经创建了一些第三方库，或者提供了编译成Web组件的选项，所以JavaScript包要小得多。</li><li id="f88e" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">封装</strong>:一些第三方选项提供了封装你的代码和风格的选项。您可以安装许多库来帮助您解决这个问题。Web组件通过私有组件范围中的影子DOM提供了这种封装选项。</li><li id="1463" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">小的学习曲线</strong>:如果你已经熟悉HTML、CSS和DOM API，学习Web组件应该会感觉超级容易，因为Web组件就是所有这些加上一些新东西。</li><li id="7674" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">构建一次，随处使用</strong>:事实上，你可以将它与其他库和框架一起使用，这使得它非常适合UI库。您不再需要为您使用的框架寻找UI库版本，或者维护同一个库的多个版本。</li></ul><p id="9dfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有什么是完美的，所以这里有一些你需要知道的使用Web组件的缺点:</p><ul class=""><li id="ccf4" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><strong class="ka ir">浏览器支持</strong>:因为是浏览器中的新事物，旧版本可能不支持，这意味着你需要使用polyfills才能100%依赖它。但是有<a class="ae md" href="https://github.com/Polymer/polymer" rel="noopener ugc nofollow" target="_blank">聚合物项目</a>和<a class="ae md" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank">其他库</a>已经解决了这个问题。</li><li id="2add" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated">SEO:任何需要生成Javascript的标记都会给搜索引擎带来挑战。Web组件对<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"> shadow-dom </a>封装提出了额外的挑战。</li><li id="9194" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">其他可能的Web API问题</strong>:因为Web组件是创建UI的一种不同方式，所以您可能会遇到这样的问题，例如，如果您创建了一个自定义按钮，它将不会被Forms API或ARIA标签选中，这些标签有时可能需要在组件中设置得很深才能与其他标签一起工作。</li></ul><p id="4d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web组件是一种新的、不断发展的构建UI的方式，与流行时起时落的第三方库不同，Web组件会一直存在，并且会变得越来越好。</p><h2 id="698d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">Web组件库</h2><p id="59f8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">还有许多可用的库简化了您使用web组件的方式，并且已经包含了聚合填充，以确保您的组件可以在大多数浏览器中工作。以下是我最喜欢的几个:</p><ul class=""><li id="fc2e" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><a class="ae md" href="https://www.npmjs.com/package/cwco" rel="noopener ugc nofollow" target="_blank"> CWCO </a></li><li id="9b45" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank">点亮</a></li><li id="57f4" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank">模板</a></li><li id="397a" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://open-wc.org/" rel="noopener ugc nofollow" target="_blank">打开网页组件</a></li><li id="31cf" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components#see_also" rel="noopener ugc nofollow" target="_blank">更多……</a></li></ul></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="df23" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创建和注册您的组件</h2><p id="f730" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">要创建一个组件，你必须定义一个类来扩展HTMLElement或者一些其他元素，比如HTMLButtonElement。要知道，Safari浏览器不支持<a class="ae md" href="https://developers.google.com/web/fundamentals/web-components/customelements#extendhtml" rel="noopener ugc nofollow" target="_blank">扩展其他原生元素</a>，因为苹果决定不实现它们。</p><p id="fc25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够扩展本地元素，你必须为Web组件使用polyfills或库，比如<a class="ae md" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> lit </a>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1a92" class="kw kx iq mv b gy mz na l nb nc">class <strong class="mv ir">CounterWidget</strong> extends <strong class="mv ir">HTMLElement</strong> {<br/>  ...<br/>}</span></pre><p id="d5ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，一个<code class="fe nd ne nf mv b"><strong class="ka ir">CounterWidget</strong></code>类被定义为扩展<code class="fe nd ne nf mv b"><strong class="ka ir">HTMLElement</strong></code> <strong class="ka ir">。你应该把元素类看作是我们创建的HTML标签的控制器，但是仅仅这样并不能给我们组件。我们还必须使用<code class="fe nd ne nf mv b"><strong class="ka ir"><em class="ng">customElements.define</em></strong></code>注册我们的标签。</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="027a" class="kw kx iq mv b gy mz na l nb nc">customElements.define('counter-digget', <strong class="mv ir">CounterWidget</strong>);</span></pre><p id="0004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">define方法采用标签的名称和控制它的类的名称。该名称必须遵循正常的HTML标记名称规则，并且不能是一个单词。您不必匹配类名，但我喜欢这样做，作为一种跟踪事物的机制。</p><p id="566b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们要扩展一个原生元素，那么定义的方法将需要第三个参数，在这里指定要扩展哪个原生元素。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3583" class="kw kx iq mv b gy mz na l nb nc">class <strong class="mv ir">MyButton</strong> extends <strong class="mv ir">HTMLButtonElement</strong> {<br/>  ...<br/>}</span><span id="74d5" class="kw kx iq mv b gy nh na l nb nc">customElements.define('my-button', <strong class="mv ir">HTMLButtonElement, {extends: 'button'</strong>);</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="282f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">渲染您的组件</h2><p id="00d6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">创建并注册了组件后，您可以继续将它用作普通的HTML标记。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="706f" class="kw kx iq mv b gy mz na l nb nc">&lt;<strong class="mv ir">counter-digget</strong>&gt;&lt;/<strong class="mv ir">counter-digget</strong>&gt;</span></pre><p id="d260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这不会渲染任何东西，因为我们从来没有定义它需要渲染什么。在<code class="fe nd ne nf mv b"><strong class="ka ir">CounterWidget</strong></code>类中，我们可以使用<code class="fe nd ne nf mv b"><em class="ng">this</em></code>关键字来访问元素并做我们想做的任何事情。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fd3c" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <br/>    <strong class="mv ir">this.innerHTML = `<br/>      &lt;p&gt;count: &lt;span class="count"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;div class="counter-buttons"&gt;<br/>        &lt;button type="button"&gt;-&lt;/button&gt;<br/>        &lt;button type="button"&gt;+&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    `</strong>;<br/>  }<br/>}</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/e30aef1943e2e24d7cf1b53ec18e8ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MFYO-M02HKqG7MgANLE6Q.png"/></div></div></figure><p id="38e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在扩展另一个类，所以如果我们定义构造函数，我们必须总是调用<em class="ng"> super </em>。我们使用“<em class="ng"> this </em>”来设置内部HTML，这与选择标签并设置内部HTML的查询相同。</p><p id="77a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这很好，但它没有利用影子DOM的封装，这意味着它的内部HTML很容易被CSS或任何其他DOM选择作为目标。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="260e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">阴影DOM</h2><p id="807d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">影子DOM是组件封装的一个重要部分，因为它将内容呈现在与文档分离的“分离”DOM中。整个网页内容的根元素是文档本身，但是对于使用影子DOM的组件，根是影子根。</p><p id="36e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建我们的影子根，我们必须调用我们可以访问的<code class="fe nd ne nf mv b"><strong class="ka ir">attachShadow</strong></code>方法，因为这是一个元素。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ded6" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <br/>    const shadow = this.<strong class="mv ir">attachShadow</strong>({<br/>      <strong class="mv ir">mode: 'closed', </strong><br/>     <strong class="mv ir"> delegatesFocus: true</strong><br/>    });</span><span id="fe9e" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">    shadow.innerHTML</strong> = `<br/>      &lt;p&gt;count: &lt;span class="count"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;div class="counter-buttons"&gt;<br/>        &lt;button type="button"&gt;-&lt;/button&gt;<br/>        &lt;button type="button"&gt;+&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>  }<br/>}</span></pre><p id="f344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">attachShadow函数不是特定于web组件的。您可以用同样的方式<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow" rel="noopener ugc nofollow" target="_blank">将阴影DOM附加到一些HTML元素上</a>，而无需创建组件。当您调用它时，您可以指定模式，该模式可以是“<em class="ng">打开</em>”或“<em class="ng">关闭</em>”，这定义了是否可以从元素外部访问影子根。</p><p id="976c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以指定<code class="fe nd ne nf mv b"><strong class="ka ir">delegatesFocus</strong></code>选项，这几乎意味着每当内部的任何元素获得焦点时，整个标签都会获得标签的焦点样式。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/91e94d32fe9f5cdda7599fdb7dfadc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7m-lbga-VFxTZwIwFgrDQ.png"/></div></div></figure><p id="67a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与任何组件一样，也可以检测组件何时被附加到DOM或从DOM中移除，以及属性何时被设置或更改。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="ef92" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">生命周期挂钩</h2><p id="c553" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Web组件带有四个生命周期挂钩，您可以利用它们:</p><ul class=""><li id="2d76" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><strong class="ka ir"> connectedCallback </strong>:每次将自定义元素追加到文档连接元素中时调用。每次移动节点时，这可能发生在元素的内容被完全解析之前。</li><li id="92f6" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir"> disconnectedCallback </strong>每次从DOM中删除定制元素时调用，例如，在选择元素后对元素调用<code class="fe nd ne nf mv b"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/remove" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">remove</strong></a></code>方法。</li><li id="1c04" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">每次使用<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptNode" rel="noopener ugc nofollow" target="_blank">adopted node</a>方法调用将定制元素移动到新文档时，都会调用adoptedCallback </strong>。例如，自定义元素存在于一个<code class="fe nd ne nf mv b">iFrame</code>中，您想将它移动到您的文档中。</li><li id="1956" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">attributeChangedCallback</strong>在每次添加、删除或更改定制元素的属性时被调用。在静态get <code class="fe nd ne nf mv b">observedAttributes</code>方法中指定了哪些属性需要注意变化</li></ul><p id="57d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给你一个我们如何使用这些生命周期的例子，我稍微重构了一下计数器小部件类，以利用<code class="fe nd ne nf mv b"><strong class="ka ir">connectedCallback</strong></code>来调用我们新的<code class="fe nd ne nf mv b"><strong class="ka ir">render</strong></code>方法。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a8e3" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <br/>    this.attachShadow({<br/>      <strong class="mv ir">mode: 'open', </strong><br/>      delegatesFocus: true<br/>    });<br/>   <br/>  }<br/>  <br/>  <strong class="mv ir">connectedCallback</strong>() {<br/>    <strong class="mv ir">this.render();</strong><br/>  }<br/>  <br/>  <strong class="mv ir">render() {<br/>    this.shadowRoot.</strong>innerHTML<strong class="mv ir"> = `<br/></strong>      &lt;p&gt;count: &lt;span class="count"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>      &lt;div class="counter-buttons"&gt;<br/>        &lt;button type="button"&gt;-&lt;/button&gt;<br/>        &lt;button type="button"&gt;+&lt;/button&gt;<br/>      &lt;/div&gt;<strong class="mv ir"><br/>    `;<br/>  }</strong><br/>}</span></pre><p id="894a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#elements_you_can_attach_a_shadow_to" rel="noopener ugc nofollow" target="_blank">一些元素</a>有它们的<code class="fe nd ne nf mv b"><strong class="ka ir">shadowRoot</strong></code> <strong class="ka ir"> </strong>属性，如果阴影是在模式设置为<code class="fe nd ne nf mv b"><em class="ng">closed</em></code>的情况下创建的，那么属性将是<code class="fe nd ne nf mv b">null</code>。如果模式设置为<code class="fe nd ne nf mv b">open</code>，则为<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot" rel="noopener ugc nofollow" target="_blank">影子根元素</a>。</p><h2 id="0c6c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">将数据传递给组件</h2><p id="9458" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有两种方法可以将数据传递给自定义组件，要么通过属性，要么在选择元素后通过元素。</p><ul class=""><li id="7d2d" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><strong class="ka ir">属性数据</strong>:可以在标签上设置任意属性，设置想要传递的值。这个方法非常适合传递简单的数据，它总是以<code class="fe nd ne nf mv b">String</code>的形式被接收。您可以将字符串解析为数字和JSON对象，但理想情况下，使用这种方法传递简单的字符串值。</li><li id="26b9" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><strong class="ka ir">元素属性数据</strong>:你可以使用这个方法将复杂的数据类型传递给元素，首先选择你的自定义标签，然后直接在元素上设置一个属性，这个属性在你的组件类中，你可以通过setters来处理。</li></ul></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="a9fe" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">处理属性更改</h2><p id="91ad" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我想设置一个开始计数小部件的初始计数值，以及计数的最小值和最大值。因为这些是简单的数据，我们可以使用属性。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5591" class="kw kx iq mv b gy mz na l nb nc">&lt;counter-digget <strong class="mv ir">max="10"</strong> <strong class="mv ir">min="-10"</strong> <strong class="mv ir">count="0"</strong>&gt;&lt;/counter-digget&gt;</span></pre><p id="5411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了处理属性，我们必须首先告诉组件我们想要<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">观察哪个属性的更新</a>。接下来，我们可以使用<code class="fe nd ne nf mv b"><strong class="ka ir">attributeChangedCallback</strong></code>来处理更新。调用这个生命周期回调函数有3个参数:属性的名称、旧值和新值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="399d" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  <strong class="mv ir">min = 0;<br/>  max = 10;<br/>  count = 0;</strong><br/>  <br/>  ...<br/>  <br/>  static get <strong class="mv ir">observedAttributes</strong>() { <br/>    <strong class="mv ir">return ['min', 'max', 'count'];</strong> <br/>  }<br/>  <br/>  <strong class="mv ir">attributeChangedCallback</strong>(<strong class="mv ir">name, oldValue, newValue</strong>) {<br/>    switch(name) {<br/>      case 'min':<br/>        <strong class="mv ir">this.min = newValue || 0;</strong><br/>        break;<br/>      case 'max':<br/>        <strong class="mv ir">this.max = newValue || 10;</strong><br/>        break;<br/>      case 'count':<br/>        <strong class="mv ir">this.count = newValue || this.count;</strong><br/>        break;<br/>    }<br/>  }</span><span id="b856" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="87a8" class="kw kx iq mv b gy nh na l nb nc">}</span></pre><p id="f414" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还用初始值定义了类中的属性，在attribute changed回调中，我为每个期望的属性使用了一个开关来更新那些内部属性。</p><p id="b152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果属性没有值或者属性被删除，那么<code class="fe nd ne nf mv b">newValue</code>将为空，所以当这种情况发生时，我将内部属性重置为默认值或当前值。</p><p id="352e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我们正在处理属性更新，我们还没有更新我们正在渲染的内容。我也没有处理按钮点击，这也应该更新呈现的内容。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="0a5a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">更新时重新渲染</h2><p id="a1bc" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">使用Web组件，您可以控制在更新时重新呈现整个组件，或者自己处理单个元素的更新。</p><p id="5133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，当计数改变时，我想重新呈现包含总数的span标记。当计数改变时，我不需要重新呈现整个标记，为此，我需要选择我想要操作的元素。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ba36" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<br/>  max = 10;<br/>  count = 0;<br/>  <br/>  ...<br/>  <br/>  <strong class="mv ir">updateCountElement</strong>(newCount) {<br/>    <strong class="mv ir">if(!this.</strong><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" rel="noopener ugc nofollow" target="_blank"><strong class="mv ir">isConnected</strong></a><strong class="mv ir">) return;</strong></span><span id="a1db" class="kw kx iq mv b gy nh na l nb nc">    // make sure the count is withing range<br/>    <strong class="mv ir">newCount = Math.min(Math.max(this.min, newCount), this.max);</strong><br/>    <br/>    <strong class="mv ir">if(this.count !== newCount)</strong> {<br/>      <strong class="mv ir">this.count = newCount;<br/>      this.countElement.textContent = this.count;</strong><br/>    }<br/>  }<br/>  <br/>  render() {<br/>    this.shadowRoot.innerHTML = `<br/>      &lt;p&gt;count: &lt;span <strong class="mv ir">class="count"</strong>&gt;<strong class="mv ir">${this.count}</strong>&lt;/span&gt;&lt;/p&gt;<br/>      &lt;div <strong class="mv ir">class="counter-buttons"</strong>&gt;<br/>        &lt;button type="button"&gt;<strong class="mv ir">-</strong>&lt;/button&gt;<br/>        &lt;button type="button"&gt;<strong class="mv ir">+</strong>&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>    <br/>    <strong class="mv ir">this.countElement</strong> = this.shadowRoot<br/>      <strong class="mv ir">.querySelector('.count');</strong><br/>    const counterButtons = this.shadowRoot<br/>      <strong class="mv ir">.querySelector('.counter-buttons');</strong><br/>    <br/>    // decrement count  <br/>    counterButtons.<strong class="mv ir">children[0]</strong><br/>      .addEventListener('<strong class="mv ir">click</strong>', <br/>      () =&gt; this.<strong class="mv ir">updateCountElement</strong>(this.count - 1));<br/>    <br/>    // increment count <br/>    counterButtons.<strong class="mv ir">children[1]</strong><br/>      .addEventListener('<strong class="mv ir">click</strong>', <br/>      () =&gt; this.<strong class="mv ir">updateCountElement</strong>(this.count + 1));<br/>  }<br/>}</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4f5810f4dbab56c63e3ac4ec027e2e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*K9qFJwkD4Ue5awNJLWDsoA.gif"/></div></figure><p id="e1cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过选择按钮，很容易附加一个click事件并调用<code class="fe nd ne nf mv b"><strong class="ka ir">updateCountElement</strong></code> <strong class="ka ir"> </strong>方法，只要新的计数在范围内且不同于当前计数，该方法就用新的计数值更新计数元素文本内容。</p><p id="ffa9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，如果元素不在DOM上，updateCountElement不会做任何事情，首先检查元素<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" rel="noopener ugc nofollow" target="_blank">是否连接了</a>。这是确保某些操作只在元素活动时发生的最好方法，这样可以避免不必要的或依赖于DOM的操作。</p><p id="029c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当count属性得到更新时，我们也可以调用这个<code class="fe nd ne nf mv b"><strong class="ka ir">updateCountElement</strong></code>方法。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d63a" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<br/>  max = 10;<br/>  count = 0;<br/>  <br/>  ...<br/>  <br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    switch(name) {<br/>      case 'min':<br/>        this.min = newValue || 0;<br/>        break;<br/>      case 'max':<br/>        this.max = newValue || 100;<br/>        break;<br/>      case 'count':<br/>        <strong class="mv ir">this.updateCountElement(</strong>newValue || this.count<strong class="mv ir">);</strong><br/>        break;<br/>    }<br/>  }<br/>  <br/>  ...<br/>}</span></pre><p id="4c4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着如果我选择定制元素并设置count属性，组件将更新它的计数</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="881f" class="kw kx iq mv b gy mz na l nb nc">const counter = document.querySelector('counter-digget');</span><span id="57c0" class="kw kx iq mv b gy nh na l nb nc">counter.setAttribute('count', 5);</span></pre><p id="a0e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在从属性更新中更新内部HTML，所以知道在调用<code class="fe nd ne nf mv b"><strong class="ka ir">render</strong></code>方法的<code class="fe nd ne nf mv b"><strong class="ka ir">connectedCallback</strong></code> <strong class="ka ir"> </strong>之前可以调用<code class="fe nd ne nf mv b"><strong class="ka ir">attributeChangedCallback</strong></code>是很重要的，这可能是一个问题。因此，确保你从<code class="fe nd ne nf mv b"><strong class="ka ir">constructor</strong></code>函数中进行初始渲染。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a441" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<br/>  max = 10;<br/>  count = 0;<br/>  <br/>  constructor() {<br/>    super();<br/>    <br/>    this.attachShadow({<br/>      mode: 'open', <br/>      delegatesFocus: true<br/>    });<br/>    <strong class="mv ir">this.render();</strong><br/>  }<br/>  <br/>  connectedCallback() {<br/>    <strong class="mv ir">// this.render();</strong><br/>  }</span><span id="6087" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="4cde" class="kw kx iq mv b gy nh na l nb nc">}</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="23fe" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">处理复杂数据</h2><p id="423b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">属性允许我们很好地处理简单的数据，但是如果我们想要发送一个Map对象或另一个类实例，甚至一个复杂的对象，属性就帮不了我们。为此，我们需要做一些选择并设置一个属性。</p><p id="7fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它就像选择我们创建的自定义标记并在元素上设置一个属性一样简单。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="082b" class="kw kx iq mv b gy mz na l nb nc">const <strong class="mv ir">counter</strong> = document.querySelector('counter-digget');</span><span id="70d0" class="kw kx iq mv b gy nh na l nb nc">// counter.setAttribute('count', 5);</span><span id="d5a3" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">counter.data = {<br/>  max: 10,<br/>  min: -10,<br/>  count: 5<br/>}</strong></span></pre><p id="7161" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为了处理这些传入的数据，我们可以使用一个<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" rel="noopener ugc nofollow" target="_blank"> setter </a>来读取数据，并对它做任何我们想做的事情。为此，我将使用传入的值来设置最小值和最大值，并更新count元素的内容。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fc2f" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<br/>  max = 10;<br/>  count = 0;<br/>  <br/>  ...<br/>  <br/><strong class="mv ir">  set data(value) {<br/></strong>    this.min = <strong class="mv ir">value</strong>.min || this.min;<br/>    this.max = <strong class="mv ir">value</strong>.max || this.max;</span><span id="27c5" class="kw kx iq mv b gy nh na l nb nc">    this.updateCountElement(<strong class="mv ir">value</strong>.count || this.count);<strong class="mv ir"><br/>  }</strong></span><span id="449a" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="9bef" class="kw kx iq mv b gy nh na l nb nc">}</span></pre><p id="f738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以在使用数据之前验证<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" rel="noopener ugc nofollow" target="_blank"> setter </a>中的数据以及进行任何格式化。使用setter的全部意义在于一旦数据被设置，就能够检测到它们。</p><p id="808a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您不一定需要setter，例如，您也可以直接从元素中更改内部属性<code class="fe nd ne nf mv b">min</code>、<code class="fe nd ne nf mv b">max</code>和<code class="fe nd ne nf mv b">count</code>，因为它们不是私有的。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fcbc" class="kw kx iq mv b gy mz na l nb nc">const <strong class="mv ir">counter</strong> = document.querySelector('counter-digget');</span><span id="10db" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">counter.min = -10;<br/>counter.max = 10;<br/>counter.count = 5;</strong></span></pre><p id="f3a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不希望这种情况发生，您可以将这些内部属性设为私有。对于我们的例子，我们可以将<code class="fe nd ne nf mv b">count</code>设为私有和只读的，这样它只能从内部操作。为了对<code class="fe nd ne nf mv b">min</code>和<code class="fe nd ne nf mv b">max</code>有更多的控制，你也可以把它们改成<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" rel="noopener ugc nofollow" target="_blank">设置器</a>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3afc" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<strong class="mv ir"><br/></strong>  max = 10;<strong class="mv ir"><br/>  #count = 0;</strong></span><span id="67e6" class="kw kx iq mv b gy nh na l nb nc">  get <strong class="mv ir">count</strong>() {<br/>    return this.#count;<br/>  }</span><span id="b4fc" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="66b9" class="kw kx iq mv b gy nh na l nb nc">}</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="c692" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">从组件中获取数据</h2><p id="5a35" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">您现在知道了如何使用属性和特性获取组件内部的数据，但是有时您还需要获取数据。</p><p id="bcd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能想将一个函数传递给组件以用作回调，但这被认为不是一个好的做法，从一个元素中获取数据的最佳方式是像其他元素一样通过事件。</p><p id="e389" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的计数器小部件，最好知道什么时候计数<code class="fe nd ne nf mv b">changed</code>，这样我们就可以根据值做一些事情。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8f10" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<strong class="mv ir"><br/></strong>  max = 10;<strong class="mv ir"><br/>  </strong>#count = 0;</span><span id="8591" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="af68" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">  updateCountElement</strong>(newCount) {<br/>    if(!this.isConnected) return;</span><span id="8f4c" class="kw kx iq mv b gy nh na l nb nc">    newCount = Math.min(Math.max(this.min, newCount), this.max);<br/>    <br/>    if(this.#count !== newCount) {<br/>      <strong class="mv ir">this.dispatchEvent(new Event('changed'));</strong><br/>      this.#count = newCount;<br/>      this.countElement.textContent = this.#count;<br/>    }<br/>  }</span><span id="9923" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="e4a2" class="kw kx iq mv b gy nh na l nb nc">}</span><span id="d220" class="kw kx iq mv b gy nh na l nb nc"><em class="ng">// from outside</em></span><span id="db90" class="kw kx iq mv b gy nh na l nb nc">const counter = <strong class="mv ir">document.querySelector('counter-digget');</strong></span><span id="1e8e" class="kw kx iq mv b gy nh na l nb nc">counter<strong class="mv ir">.addEventListener('changed'</strong>, (e) =&gt; {<br/>  console.log('changed', <strong class="mv ir">e.target.count</strong>)<br/>})</span></pre><p id="c02f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面的代码中看到的，每次计数改变为不同的值时，我们都会调度一个<code class="fe nd ne nf mv b">changed</code>事件。对您可以调度的事件类型没有限制，如果需要，您甚至可以调度适合您的组件的<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent" rel="noopener ugc nofollow" target="_blank">自定义事件</a>。</p><p id="c830" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明一个自定义事件，还将调度一个自定义事件<code class="fe nd ne nf mv b">countforced</code>，用于当用户停留在最小值或最大值上，但继续单击按钮以向上或向下计数时。如果我们想向用户显示消息，这可能是有用的。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0c55" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {<br/>  min = 0;<strong class="mv ir"><br/></strong>  max = 10;<strong class="mv ir"><br/>  </strong>#count = 0;</span><span id="be9a" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="af3c" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">  updateCountElement</strong>(newCount) {<br/>    if(!this.isConnected) return;</span><span id="feb8" class="kw kx iq mv b gy nh na l nb nc">    newCount = Math.min(Math.max(this.min, newCount), this.max);<br/>    <br/>    if(this.#count !== newCount) {<br/>      this.dispatchEvent(new Event('changed'));<br/>      this.#count = newCount;<br/>      this.countElement.textContent = this.#count;<br/>    } else {<br/>      <strong class="mv ir">this.dispatchEvent(new CustomEvent('countforced', { <br/>        detail: {<br/>          forcedValue: newCount === this.max <br/>             ? 'max' <br/>             : 'min'<br/>         }<br/>      }));</strong><br/>    }<br/>  }</span><span id="4272" class="kw kx iq mv b gy nh na l nb nc">  ...</span><span id="d88f" class="kw kx iq mv b gy nh na l nb nc">}</span><span id="a8e7" class="kw kx iq mv b gy nh na l nb nc"><em class="ng">// from outside</em></span><span id="6184" class="kw kx iq mv b gy nh na l nb nc">const counter = <strong class="mv ir">document.querySelector('counter-digget');</strong></span><span id="0670" class="kw kx iq mv b gy nh na l nb nc"><em class="ng">// listen to count forced event</em><br/>counter<strong class="mv ir">.addEventListener('countforced'</strong>, (e) =&gt; {<br/>  console.log('countforced', <strong class="mv ir">e.detail.forcedValue</strong>)<br/>})</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="ce66" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">模板</h2><p id="7c21" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们已经通过在render方法中设置shadow根的内部HTML进行了某种类型的模板化，但是随着其他web组件技术的发展，引入了<code class="fe nd ne nf mv b"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">template</a></code>和<code class="fe nd ne nf mv b"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank">slot</a></code>标签，这使得可重用模板变得更加容易。</p><p id="753a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的页面主体标签中，你可以定义你的模板，浏览器会知道不要呈现它们。模板就像一个特殊的<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank">文档片段</a>，在其中它将只包含要重用的标记。我们也可以这样定义计数器小部件模板。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a6f9" class="kw kx iq mv b gy mz na l nb nc"><strong class="mv ir">&lt;template id="counter"&gt;</strong><br/>  &lt;p&gt;count: &lt;span class="count"&gt;0&lt;/span&gt;&lt;/p&gt;<br/>  &lt;div class="counter-buttons"&gt;<br/>    &lt;button type="button"&gt;-&lt;/button&gt;<br/>    &lt;button type="button"&gt;+&lt;/button&gt;<br/>  &lt;/div&gt;<br/><strong class="mv ir">&lt;/template&gt;</strong></span></pre><p id="0a6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们这样做，从render方法，我们将查询它的id，而不是使用它。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="15ba" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {</span><span id="06b4" class="kw kx iq mv b gy nh na l nb nc">  ...<br/>  <br/>  render() {<br/>    <strong class="mv ir">const template = document.getElementById('counter');</strong><br/>    this.shadowRoot.<strong class="mv ir">appendChild</strong>(<strong class="mv ir">template.content</strong>);<br/>    <br/>    ...<br/>  }<br/>}</span></pre><p id="190c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个模板都有自己的内容，我们不需要设置内部HTML，而是需要将模板内容附加到影子根中。关于我们的计数器小部件的其他一切都可以保持不变，这里唯一的区别是模板可以被另一个组件使用。</p><p id="89cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是在组件之间共享模板的完美方式，并且整个组件主体不必是一个单一的模板。您可以使用许多模板来设置组件内容，也可以仅将模板用于组件内容的一部分。</p><p id="b765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以将按钮模板化，并保留包含计数的段落。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5974" class="kw kx iq mv b gy mz na l nb nc"><strong class="mv ir">&lt;template id="counter-buttons"&gt;</strong><br/>  &lt;div class="counter-buttons"&gt;<br/>    &lt;button type="button"&gt;-&lt;/button&gt;<br/>    &lt;button type="button"&gt;+&lt;/button&gt;<br/>  &lt;/div&gt;<br/><strong class="mv ir">&lt;/template&gt;</strong></span><span id="ea6f" class="kw kx iq mv b gy nh na l nb nc">...</span><span id="764c" class="kw kx iq mv b gy nh na l nb nc">class CounterWidget extends HTMLElement {</span><span id="513e" class="kw kx iq mv b gy nh na l nb nc">  ...<br/>  <br/>  render() {<br/>    <strong class="mv ir">const template = document.getElementById('counter-buttons');</strong><br/>    <br/>    this.shadowRoot.<strong class="mv ir">innerHTML</strong> = `<br/>      &lt;p&gt;count: &lt;span class="count"&gt;${this.count}&lt;/span&gt;&lt;/p&gt;<br/>    `;</span><span id="a670" class="kw kx iq mv b gy nh na l nb nc">    this.shadowRoot.appendChild(<strong class="mv ir">template.content</strong>);<br/>    <br/>    ...<br/>  }<br/>}</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="1832" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用插槽</h2><p id="4cdd" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">插槽是将HTML注入模板或组件主体的强大方法。slot标签充当HTML的占位符，如果没有提供任何内容，它可以包含默认标记。这也是用额外的标记来扩展定制组件的一种强大的方式，允许一些灵活性，而不是将模板硬编码为总是相同的。</p><p id="d396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的计数器小部件示例，我们可以让递增和递减按钮可以被任何其他按钮替换，从而允许人们对按钮的外观有更多的控制，特别是因为样式被封装在组件内部，不能被轻易覆盖。</p><p id="24d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以修改计数器按钮模板来包含按钮的槽。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0183" class="kw kx iq mv b gy mz na l nb nc">&lt;template id="<strong class="mv ir">counter-buttons</strong>"&gt;<br/>  &lt;div class="counter-buttons"&gt;<br/>    <strong class="mv ir">&lt;slot name="dec-btn"&gt;<br/>      </strong>&lt;button type="button"&gt;-&lt;/button&gt;<br/>    <strong class="mv ir">&lt;/slot&gt;</strong><br/>    <strong class="mv ir">&lt;slot name="inc-btn"&gt;<br/>      </strong>&lt;button type="button"&gt;+&lt;/button&gt;<br/>    <strong class="mv ir">&lt;/slot&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="a5f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在没有提供任何内容的情况下，插槽标签内的内容将被用作默认值。插槽上的name属性是一个标识符，我们可以用它来指定用新标签替换哪个插槽。</p><p id="e803" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们想要呈现标签时，我们可以指定我们的新按钮，并使用slot属性来指定用这些新按钮替换哪个占位符。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ce25" class="kw kx iq mv b gy mz na l nb nc">&lt;counter-digget max="10" min="-10" count="2"&gt;<br/>  &lt;button <strong class="mv ir">slot="inc-btn"</strong>&gt;increment&lt;/button&gt;<br/>  &lt;button <strong class="mv ir">slot="dec-btn"</strong>&gt;decrement&lt;/button&gt;<br/>&lt;/counter-digget&gt;</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/d99335720a13b16ec8887672051c1749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFVYlVC8H_xYMUDoyQlhCQ.png"/></div></div></figure><p id="0bc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们不是通过一个特定的属性来选择按钮，所以这些按钮工作得很好。</p><p id="e9ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要为插槽使用模板标签。如果我们像最初一样切换回使用带有内部HTML的普通模板，这仍然可以很好地工作。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d449" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {</span><span id="cd1c" class="kw kx iq mv b gy nh na l nb nc">  <strong class="mv ir">...</strong><br/>  <br/>  <strong class="mv ir">render</strong>() {<br/>    this.shadowRoot.<strong class="mv ir">innerHTML</strong> = `<br/>      &lt;p&gt;count: &lt;span class="count"&gt;${this.#count}&lt;/span&gt;&lt;/p&gt;<br/>      &lt;div class="counter-buttons"&gt;<br/>        <strong class="mv ir">&lt;slot name="dec-btn"&gt;</strong><br/>           &lt;button type="button"&gt;-&lt;/button&gt;<br/>        <strong class="mv ir">&lt;/slot&gt;</strong><br/>        <strong class="mv ir">&lt;slot name="inc-btn"&gt;</strong><br/>           &lt;button type="button"&gt;+&lt;/button&gt;<br/>        <strong class="mv ir">&lt;/slot&gt;</strong><br/>      &lt;/div&gt;<br/>    `;<br/>    <br/>    <strong class="mv ir">...</strong><br/>  }<br/>}</span></pre><p id="bfc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当您希望在组件之间共享模板时，才使用body标记中的模板。我不喜欢把不会呈现的东西放在body标签中，所以我把它们放在一个单独的文件中，这样我就可以随时查询或创建它们。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="83a6" class="kw kx iq mv b gy mz na l nb nc">const templates = {<br/>  get <strong class="mv ir">couterButtons</strong>() {<br/>    const template = document.<strong class="mv ir">createElement</strong>('<strong class="mv ir">template</strong>');<br/>    <br/>    template.<strong class="mv ir">innerHTML</strong> = `<br/>      &lt;div class="counter-buttons"&gt;<br/>        &lt;slot name="dec-btn"&gt;<br/>          &lt;button type="button"&gt;-&lt;/button&gt;<br/>        &lt;/slot&gt;<br/>        &lt;slot name="inc-btn"&gt;<br/>          &lt;button type="button"&gt;+&lt;/button&gt;<br/>        &lt;/slot&gt;<br/>      &lt;/div&gt;<br/>    `;<br/>    <br/>    <strong class="mv ir">return template;</strong><br/>  }<br/>}</span></pre><p id="4695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么使用起来就容易多了…</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1d8e" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {</span><span id="1adb" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">  ...</strong><br/>  <br/>  <strong class="mv ir">render</strong>() {<br/>    const template = <strong class="mv ir">templates</strong>.<strong class="mv ir">couterButtons</strong>;<br/>    this.shadowRoot.innerHTML = `<br/>      &lt;p&gt;count: &lt;span class="count"&gt;${this.count}&lt;/span&gt;&lt;/p&gt;<br/>    `;<br/>    this.shadowRoot.appendChild(<strong class="mv ir">template.content</strong>);<br/>    <br/>    <strong class="mv ir">...</strong><br/>  }<br/>}</span></pre><p id="aac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为它只是JavaScript和DOM API，你能有多大的创造力只取决于你自己。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="3922" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">造型组件</h2><p id="d2cc" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">使用您的自定义组件，您可以在其中添加一个样式标记，该标记将包含该组件的样式。如果你使用影子DOM，这个样式不能被外部覆盖，这减少了破坏UI外观的CSS冲突。</p><p id="c544" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢为样式设置一个getter，让事情变得更简单。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1929" class="kw kx iq mv b gy mz na l nb nc">class CounterWidget extends HTMLElement {</span><span id="83bf" class="kw kx iq mv b gy nh na l nb nc"><strong class="mv ir">  ...</strong></span><span id="d93c" class="kw kx iq mv b gy nh na l nb nc">  get <strong class="mv ir">style</strong>() {<br/>    return `<br/>     <strong class="mv ir">&lt;style&gt;</strong><br/>       p {<br/>         margin: 0 0 5px;<br/>         text-transform: capitalize;<br/>         display: flex;<br/>         justify-content: space-between;<br/>         padding: 0 10px 0 5px;<br/>       }<br/>       <br/>       p span {<br/>         font-weight: bold;<br/>       }<br/>       <br/>       .counter-buttons {<br/>          display: flex;<br/>          align-items: center;<br/>          padding: 10px;<br/>          background: #f6f6f6;<br/>          border-radius: 3px;<br/>       }p<br/>     <strong class="mv ir">&lt;/style&gt;</strong><br/>    `<br/>  }</span><span id="8c39" class="kw kx iq mv b gy nh na l nb nc">  <strong class="mv ir">render</strong>() {<br/>    const template = templates.couterButtons;<br/>    this.shadowRoot.innerHTML = `<br/>      <strong class="mv ir">${this.style}</strong><br/>      &lt;p&gt;count: &lt;span class="count"&gt;${this.count}&lt;/span&gt;&lt;/p&gt;<br/>    `;<br/>    this.shadowRoot.appendChild(template.content);<br/>    <br/>    <strong class="mv ir">...</strong><br/>  }<br/>}</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/643a51c763b6ecaf74e076b9b127fbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKZikE_Ub8UeS--U4eW_-w.png"/></div></div></figure><p id="f363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以把样式标签放在模板本身里面，这样它总是有它自己的样式，如果你想的话，你可以从组件里面覆盖它。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e992" class="kw kx iq mv b gy mz na l nb nc">&lt;template id="counter-buttons"&gt;<br/>  <strong class="mv ir">&lt;style&gt;<br/>   ...<br/>  &lt;/style&gt;</strong><br/>  &lt;div class="counter-buttons"&gt;<br/>    &lt;slot name="dec-btn"&gt;&lt;button type="button"&gt;-&lt;/button&gt;&lt;/slot&gt;<br/>    &lt;slot name="inc-btn"&gt;&lt;button type="button"&gt;+&lt;/button&gt;&lt;/slot&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="f64c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">覆盖组件样式</h2><p id="403e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">控制组件的方法之一是留下槽，在那里可以插入元素，并且它们的样式已经打开。如果您知道您需要覆盖组件的样式，您可以保持阴影DOM打开，这样您就可以从JavaScript中查询它并设置样式，或者使用<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank"> CSS变量</a>。</p><p id="88cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为计数器小部件有一个打开的阴影DOM，我可以锁定它，并使计数器按钮变成紫色。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8cc4" class="kw kx iq mv b gy mz na l nb nc">const counter = document.querySelector('counter-digget');</span><span id="40e8" class="kw kx iq mv b gy nh na l nb nc">counter.<strong class="mv ir">shadowRoot</strong><br/>  .querySelector('.counter-buttons')<br/>  <strong class="mv ir">.style.backgroundColor = '#ae63e4'</strong></span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/33a6084cd663db47583508ae859aee4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0RVPZnJxHGqoVD4Knf4HQ.png"/></div></div></figure><p id="6d60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种方法是使用变量来设置计数器按钮的背景。CSS <code class="fe nd ne nf mv b">var</code>采用要使用的变量的名称，以及在变量不存在的情况下使用的可选默认值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e2e1" class="kw kx iq mv b gy mz na l nb nc"><strong class="mv ir">.counter-buttons</strong> {<br/>   display: flex;<br/>   align-items: center;<br/>   padding: 10px;<br/>   <strong class="mv ir">background: var(--grey, #f6f6f6);</strong><br/>   border-radius: 3px;<br/>}</span></pre><p id="2a45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为变量是有作用域的，所以它们通过web组件的影子根。我们可以利用这一点，在组件内部创建变量占位符，以便从外部覆盖。</p><p id="15d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在计数器小部件标签的主体或任何父标签中定义了颜色，那么将使用该值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7378" class="kw kx iq mv b gy mz na l nb nc">body {<br/>  --grey: #717790;<br/>}</span></pre><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/893a0ef57a44015449ea245c54834861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKpZJkQOkVUYaUjjBjyF-w.png"/></div></div></figure><p id="b493" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是创建遵循主题或UI系统调色板的组件的好方法，您可以动态交换该主题和调色板，并使所有组件都相应地改变。</p><blockquote class="nk nl nm"><p id="b32c" class="jy jz ng ka b kb kc kd ke kf kg kh ki nn kk kl km no ko kp kq np ks kt ku kv ij bi translated"><strong class="ka ir">在<a class="ae md" href="https://codepen.io/beforesemicolon/pen/BaRqLgV" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">中可以找到本文使用的所有代码</strong>，该代码链接</a></strong> 。</p></blockquote></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="261c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">通过例子学习</h2><p id="3269" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">了解更多的最好方法是通过例子，我制作了一些视频，专门介绍如何在简单到复杂的例子中使用Web组件，你可以从中学到很多东西。<strong class="ka ir">请查看以下视频</strong>:</p><ul class=""><li id="76b3" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><a class="ae md" href="https://www.youtube.com/watch?v=rkqqBA6ohc0" rel="noopener ugc nofollow" target="_blank">用Web组件</a>创建<strong class="ka ir">音频播放器标签</strong></li><li id="2419" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated"><a class="ae md" href="https://www.youtube.com/watch?v=g1Zd0Y7OJuI" rel="noopener ugc nofollow" target="_blank">用Web组件</a>创建<strong class="ka ir">日期选择器标签</strong></li></ul><h2 id="d8f4" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="069f" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">网络组件将会一直存在，我相信一旦你尝到了它的味道，你会渴望更多。在学习了JavaScript和DOM之后，在进入诸如reactor、Angular、Vue或Svelte之类的库之前，总是会建议下一步。</p><p id="a1bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">慢慢来，探索、学习并创造令人惊叹的事物。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/79122679204c8ac0aa65ca22857737ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kKfpitAbaRbqRAXx0-YqTw.gif"/></div></div></figure><p id="924c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> YouTube频道</strong> : <a class="ae md" href="https://www.youtube.com/channel/UCrU33aw1k9BqTIq2yKXrmBw" rel="noopener ugc nofollow" target="_blank">分号前</a> <br/> <strong class="ka ir">网站</strong>:<a class="ae md" href="https://beforesemicolon.com/" rel="noopener ugc nofollow" target="_blank">beforesemicolon.com</a></p></div></div>    
</body>
</html>