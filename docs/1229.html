<html>
<head>
<title>Are For Loops or ForEach Better in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中For循环和ForEach哪个更好？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-for-loops-or-foreach-better-in-javascript-e2e603b58393?source=collection_archive---------8-----------------------#2021-03-15">https://javascript.plainenglish.io/are-for-loops-or-foreach-better-in-javascript-e2e603b58393?source=collection_archive---------8-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a70279e67f71291963bc3e269267a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uZD58Tjp1AxyWKQv"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathew Schwartz</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="f0a2" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">你应该选择哪一个，为什么</h2></div><p id="83c8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我审查一个代码时，我看到人们在他们的代码中不断混合<strong class="kx jh">代表</strong>和<strong class="kx jh">代表</strong>。要么是搞混了，要么是分不清for和forEach。根据经验法则，除了少数情况，您应该始终使用forEach。在这篇文章中，我将解释什么时候你应该做出那些例外。这对<code class="fe lr ls lt lu b"><strong class="kx jh">Array.map</strong></code>也有效。</p><h2 id="c480" class="lv lw jg bd lx ly lz dn ma mb mc dp md le me mf mg li mh mi mj lm mk ml mm mn bi translated">基本语法</h2><p id="16c2" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">在继续之前，让我们快速浏览一下这两种语法。</p><p id="cb83" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">为循环:</strong></p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="fe96" class="lv lw jg lu b gy nb nc l nd ne">for ([initialExpression]; [conditionExpression];[incrementExpression]) {<br/>  statement|s<br/>}</span><span id="e487" class="lv lw jg lu b gy nf nc l nd ne">const array = [1, 2, 3, 4, 5];<br/>for (let index = 0; index &lt; array.length; index++) {<br/>  console.log(array[index]);<br/>}</span></pre><p id="f159" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> ForEach循环:</strong></p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="c580" class="lv lw jg lu b gy nb nc l nd ne">arr.forEach(callback(currentValue[, index[, array]]) {<br/>  // execute something<br/>}[, thisArg]);</span><span id="02fd" class="lv lw jg lu b gy nf nc l nd ne">const array = [1, 2, 3, 4, 5];<br/>array.forEach((item) =&gt; {<br/>  console.log(item);<br/>});</span></pre><p id="c2f9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的示例中，两个代码都将打印数字的对数序列。ForEach采用功能方法来解决问题。ForEach接受一个函数回调，并对数组中的每个值执行。<strong class="kx jh"> forEach </strong>方法看起来比<strong class="kx jh"> For循环</strong>更简洁。但是有些情况下我们需要for循环，或者我们可以说for循环比forEach好。我们来探索一下。</p><p id="801c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> 1。循环到一个值范围:</strong>假设你必须循环一些特定次数的代码(假设100)。这里不能用forEach。因为对于ForEach，你需要一个数据数组。可以使用<strong class="kx jh">数组(100)。fill(0)到</strong>创建一个用0填充的数据数组。但这是一个额外的头痛。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="6866" class="lv lw jg lu b gy nb nc l nd ne">// Sum of the first 99 natural numbers</span><span id="6406" class="lv lw jg lu b gy nf nc l nd ne">let sum = 0;<br/>for (let index = 0; index &lt; 100; index++) {<br/>  sum += index;<br/>}</span></pre><p id="13df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用forEach的相同代码</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="3c2f" class="lv lw jg lu b gy nb nc l nd ne">let sum = 0;<br/>Array(100)<br/>  .fill(0)<br/>  .forEach((_, index) =&gt; {<br/>    sum += index;<br/>  });<br/>console.log(sum); // 4950</span></pre><p id="6447" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里代码的复杂度很高(<strong class="kx jh"> O(2n) </strong>)。因为我们循环了两次。一个用来填充数组，另一个用来迭代数组以收集自然数。</p><p id="3bc1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> 2。除了1之外的增量索引:</strong>这是另一个很好的例子，此时应该使用for循环而不是forEach。这将降低代码的复杂性。</p><p id="be3f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，假设您有一个数据数组，您必须执行收集数据对。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="195e" class="lv lw jg lu b gy nb nc l nd ne">let numbers = [0, 1, 2, 3, 4, 5, 6, 7];<br/>let pairs = [];<br/>for (let index = 0; index &lt; numbers.length; index += 2) {<br/>  pairs.push([numbers[index], numbers[index + 1]]);<br/>}</span><span id="268e" class="lv lw jg lu b gy nf nc l nd ne">console.log(pairs); // [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ], [ 6, 7 ] ]</span></pre><p id="2a57" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们可以跳过(递增)任何数量的索引。如果你必须使用forEach循环做同样的事情，你必须有一些逻辑每次跳过第二个数字。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="8b43" class="lv lw jg lu b gy nb nc l nd ne">let numbers = [0, 1, 2, 3, 4, 5, 6, 7];<br/>let pairs = [];</span><span id="8c17" class="lv lw jg lu b gy nf nc l nd ne">numbers.forEach((item, index) =&gt; {<br/>  if (index % 2 === 0) {<br/>    pairs.push([item, numbers[index + 1]]);<br/>  }<br/>});<br/>console.log(pairs); // [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ], [ 6, 7 ] ]</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9144ff22dc5f724b7f5e4aa7515f7570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*eVk5KcB6Cn33M2sPVDmSeQ.jpeg"/></div></figure><p id="f269" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> 3。条件中断/继续循环:</strong>由于某种原因如果你的代码要求条件中断循环。For循环比forEach更好使用。这是因为打破forEach循环是痛苦的。我写了一整篇文章来解释如何打破循环。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="4eb5" class="lv lw jg lu b gy nb nc l nd ne">let numbers = [0, 1, 2, 3, 4, 5, 6, 7];</span><span id="3193" class="lv lw jg lu b gy nf nc l nd ne">for (let index = 0; index &lt; numbers.length; index++) {<br/>  if (numbers[index] &gt; 5) {<br/>    break;<br/>  }<br/>  console.log(numbers[index]); // 0, 1, 2, 3, 4, 5<br/>}</span></pre><p id="0a45" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似的代码如果你必须使用forEach来写，你必须抛出一个错误并捕捉它。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="b578" class="lv lw jg lu b gy nb nc l nd ne">let numbers = [0, 1, 2, 3, 4, 5, 6, 7];</span><span id="1a85" class="lv lw jg lu b gy nf nc l nd ne">const printValueTill5 = (v) =&gt; {<br/>  if (v % 5 == 0) {<br/>    <strong class="lu jh">throw new Error("index is greater than 5");</strong><br/>  }<br/>  console.log(v);<br/>};<br/>try {<br/>  numbers.forEach(printValueTill5);<br/>} catch {}</span></pre><p id="1bc3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> 4。在块中工作，分割数组:</strong>另一个好的用例可能是当你必须在数据块中工作时。所以你可以从第一次迭代剩下的地方开始索引。</p><p id="04d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，假设您必须合并两个数组，并且您不确定这两个数组的大小。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="cf4a" class="lv lw jg lu b gy nb nc l nd ne">const array1 = [1, 3, 5, 7, 8, 9, 10];<br/>const array2 = [2, 4, 6];<br/>const merged = [];</span><span id="0df5" class="lv lw jg lu b gy nf nc l nd ne">let index = 0;<br/>for (; index &lt; array1.length &amp;&amp; index &lt; array2.length; index++) {<br/>  merged.push(array1[index]);<br/>  merged.push(array2[index]);<br/>}</span><span id="b89f" class="lv lw jg lu b gy nf nc l nd ne">// loop over array1, if left any<br/>for (; index &lt; array1.length; index++) {<br/>  merged.push(array1[index]);<br/>}</span><span id="91fe" class="lv lw jg lu b gy nf nc l nd ne">// loop over array2, if left any<br/>for (; index &lt; array2.length; index++) {<br/>  merged.push(array2[index]);<br/>}</span><span id="c859" class="lv lw jg lu b gy nf nc l nd ne">console.log(merged); // [1,2,3,4,5,6,7,8,9,10]</span></pre><p id="4782" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我甚至想不出用forEach写同样的代码。</p><p id="1098" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> 5。使用嵌套循环:</strong>forEach循环的另一个挑战是使用嵌套循环。嵌套forEach会导致非常难看的循环。同时也很容易导致回调地狱。</p><p id="190a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，填充2D/3D阵列。</p><pre class="mt mu mv mw gt mx lu my mz aw na bi"><span id="d9a5" class="lv lw jg lu b gy nb nc l nd ne">let matrix = [];</span><span id="91dc" class="lv lw jg lu b gy nf nc l nd ne">for (let i = 0; i &lt; 3; i++) {<br/>  matrix[i] = [];<br/>  for (let j = 0; j &lt; 3; j++) {<br/>    matrix[i][j] = [i, j];<br/>  }<br/>}<br/>console.log(matrix);</span><span id="472f" class="lv lw jg lu b gy nf nc l nd ne">/*<br/>[<br/>  [ [ 0, 0 ], [ 0, 1 ], [ 0, 2 ] ],<br/>  [ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ] ],<br/>  [ [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] ]<br/>]<br/>*/</span></pre><h2 id="e44e" class="lv lw jg bd lx ly lz dn ma mb mc dp md le me mf mg li mh mi mj lm mk ml mm mn bi translated">结论</h2><p id="34d1" class="pw-post-body-paragraph kv kw jg kx b ky mo kh la lb mp kk ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">也许使用raw for循环很棘手，容易出错。但是for循环有它自己的位置。它让您完全控制<strong class="kx jh">数据</strong>、<strong class="kx jh">指标</strong>和<strong class="kx jh">条件</strong>流程。同时基于上面的例子，我们可以假设每当你的工作需要更多的与索引/条件表达式的交互时。可以使用for-loop。对于其余情况，使用<strong class="kx jh"> forEach </strong>进行数据优先使用。</p><p id="cbbb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢欣赏我的努力。它鼓励我比以前写得更多更好。</p><p id="9748" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我知道这很艰难，但我还是会为你加油</p></div></div>    
</body>
</html>