<html>
<head>
<title>LeetCode Algorithm Series: Maximum Subarray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:最大子阵列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-maximum-subarray-776252f61ea0?source=collection_archive---------14-----------------------#2021-09-24">https://javascript.plainenglish.io/leetcode-algorithm-series-maximum-subarray-776252f61ea0?source=collection_archive---------14-----------------------#2021-09-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Sortino</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2a1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天的算法题来自Leetcode的顶级面试题——轻松下<em class="ky">动态编程</em>章节。</p><p id="bad0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">最大子阵列:</strong></p><blockquote class="kz la lb"><p id="f4c5" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">给定一个整数数组<code class="fe lf lg lh li b">nums</code>，找到具有最大和的连续子数组(至少包含一个数),并返回其和<em class="in"/>。</p><p id="8c69" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">一个<strong class="kc io">子数组</strong>是一个数组的<strong class="kc io">连续</strong>部分。</p></blockquote><p id="46fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="ebaf" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br/><strong class="li io">Output:</strong> 6<br/><strong class="li io">Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</span><span id="fe75" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> nums = [1]<br/><strong class="li io">Output:</strong> 1</span><span id="a184" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> nums = [5,4,-1,7,8]<br/><strong class="li io">Output:</strong> 23</span></pre><p id="ae57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，强力方法是列出所有可能的连续数组，然后计算每个和，并找出最大和。所以从第一个数字开始，会有N个子阵列。然后移动到下一个数字，将有N-1个子阵列，等等。此外，我还需要得到每个子数组的总和，这太耗费时间和空间了。</p><p id="cab4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，我相信这个算法可以通过遍历整个数组一次，以O(N)的时间复杂度解决。在迭代时，我可以跟踪当前的和，而不是创建子数组，这样就不需要在内存中保存多个数组。每当我迭代到下一个数字时，我就把当前的总和加到它上面。如果新的和大于当前的数，那么我的子数组可以继续。如果添加下一个数字会使和减少，那么这意味着当前的数字更大，所以我希望这个数字开始我的新的子数组。这就是我如何创建和检查各种子数组的总和，而不需要实际跟踪它们。需要的额外步骤是，每当你得到一个新的和，从技术上讲，这是一个新的子阵列，你要检查，看看新的子阵列和是否大于以前的最大和。如果是，则替换该值。</p><h1 id="9468" class="ly ls in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">步骤/思考过程</h1><p id="9ab1" class="pw-post-body-paragraph ka kb in kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">让我们用第三个例子<code class="fe lf lg lh li b"><em class="ky">nums = [5,4,-1,7,8]</em></code></p><ul class=""><li id="528d" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">我将index0的值设置为等于一个<strong class="kc io"> max </strong>和<strong class="kc io"> currSum </strong>变量，以提供一个比较的起点。<code class="fe lf lg lh li b"><em class="ky">max = 5 currSum = 5</em></code></li><li id="135e" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">然后从index1开始，我使用循环的<strong class="kc io">来处理主数组中的其他数值。</strong></li><li id="7b70" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">我检查当前值+我的当前总和是否大于当前值。<code class="fe lf lg lh li b"><em class="ky">5 + currSum =&gt; 5 + 4 = 9 | is 9 &gt; 4? Yes</em></code></li></ul><blockquote class="kz la lb"><p id="2743" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">注意:我检查的是当前值，而不是当前总和，因为我不是从5和4开始，而是从-2和1开始。总和会是-1，比我现在的总和-2要大。然而，它小于我现在的值1。请记住，一个数字本身仍然算作一个连续的子数组，所以我的子数组和[index1]将大于我的子数组和[index0，index1]。所以，我想用index1开始我的新的连续子数组。</p></blockquote><ul class=""><li id="54a3" class="na nb in kc b kd ke kh ki kl nc kp nd kt ne kx nf ng nh ni bi translated">因此，如果我的新总和大于当前值，我想把它加到<strong class="kc io"> currSum </strong>中。任何时候<strong class="kc io"> currSum </strong>发生变化，我都要检查新值是否大于我当前的<strong class="kc io"> max </strong> sum。如果是，那么我设置一个新的最大值。</li><li id="e10f" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">正如我在注释中提到的，如果<strong class="kc io"> currSum </strong>不大于当前值，那么我想用那个值开始我的新子数组(即<strong class="kc io"> currSum </strong>)。所以我把值设为等于它。请记住，再次<strong class="kc io"> currSum </strong>已经更改，所以我需要检查新值是否大于我的<strong class="kc io"> max </strong>。如果是，那么我设置一个新的最大值。</li><li id="44dd" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated">您继续通过原始数组，直到到达末尾</li></ul><p id="36e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们看看第一个例子，看看子阵列建筑是什么样子的:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="2a01" class="lr ls in li b gy lt lu l lv lw">nums = [-2,1,-3,4,-1,2,1,-5,4]<br/>-----------------------<br/>[-2]              currSum = -2 max = -2  is -2 + 1 &gt; 1 ? NO<br/>[1]               currSum =  1 max =  1  is 1 + -3 &gt; -3 ? YES<br/>[1,-3]            currSum = -2 max =  1  is -2 + 4 &gt; 4 ? NO<br/>[4]               currSum =  4 max =  4  is 4 + -1 &gt; -1 ? YES<br/>[4,-1]            currSum =  3 max =  4  is 3 + 2 &gt; 2 ? YES<br/>[4,-1,2]          currSum =  5 max =  5  is 5 + 1 &gt; 1 ? YES<br/>[4,-1,2,1]        currSum =  6 max =  6* is 6 + -5 &gt; -5 ? YES<br/>[4,-1,2,1,-5]     currSum =  1 max =  6  is 1 + 4 &gt; 4 ? YES<br/>[4,-1,2,1,-5,4]   currSum =  5 max =  6</span><span id="42b3" class="lr ls in li b gy lx lu l lv lw">*So even though my array kept building, I had already recorded that this continuous subarray was my largest one.</span></pre><p id="a0a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我完成的代码:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="08c5" class="lr ls in li b gy lt lu l lv lw">var maxSubArray = function(nums) {<br/>  let max = nums[0]<br/>  let currSum = nums[0]</span><span id="3852" class="lr ls in li b gy lx lu l lv lw">  for (let i = 1; i &lt; nums.length; i++) {<br/>    let num = nums[i]</span><span id="e16e" class="lr ls in li b gy lx lu l lv lw">    if (num + currSum &gt; num) {<br/>      currSum += num<br/>      if (max &lt; currSum) {<br/>        max = currSum<br/>      }<br/>    } else {<br/>        currSum = num<br/>        if (max &lt; num) {<br/>          max = num<br/>        }<br/>      }<br/>  }<br/>  return max<br/>};</span></pre><p id="a8df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样做的时间复杂度是O(n ),因为我有一个循环的<strong class="kc io">。<strong class="kc io"> </strong>在LeetCode上运行这个，运行时间是<strong class="kc io"> 84ms </strong>，比提交的<strong class="kc io"> 53.10% </strong>要好。</strong></p><p id="b9e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有一个不同的方法来解决这个问题，或者你是如何解决这个算法的，我很乐意听到我的代码如何改进。如果你正在与它斗争，我希望这有助于澄清它！</p><p id="402f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请关注未来更多的LeetCode解决方案！</p><p id="c4ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="kz la lb"><p id="cf8c" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="1a0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>