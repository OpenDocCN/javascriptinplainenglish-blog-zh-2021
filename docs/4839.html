<html>
<head>
<title>5 Easy Tips for More Readable and Maintainable Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高代码可读性和可维护性的5个简单技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-easy-tips-for-more-readable-and-maintainable-code-540f81daa711?source=collection_archive---------7-----------------------#2021-09-28">https://javascript.plainenglish.io/5-easy-tips-for-more-readable-and-maintainable-code-540f81daa711?source=collection_archive---------7-----------------------#2021-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/521cc3e7792a225a7b7b93471aa8103f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qd1rtvspz5dwCfo3"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sadswim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ian dooley</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fc51" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.用动词如“是”或“可以”作为布尔变量的前缀</h1><p id="f4ba" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">声明布尔变量时，在变量名前加上动词前缀，如“is”或“can ”,以帮助读者快速理解他们正在处理的值的类型。让我们看一些例子。</p><p id="87ff" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io"> <em class="mb">显示vs is display</em></strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b7d0" class="ml kb in mh b gy mm mn l mo mp">const display = false;<br/>const isDisplaying = false; // Better</span></pre><p id="8660" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">虽然你可以将<em class="mb">显示</em>解释为“是”或“否”，但我认为该显示也可以包含“阻塞”、“内嵌”、“无”等值。而使用“isDisplaying”时，可能性的范围可能仅限于“真”或“假”</p><p id="632d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io"> <em class="mb">拨动vs康托</em> </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c785" class="ml kb in mh b gy mm mn l mo mp">const toggle = false;<br/>const canToggle = false; // Better</span></pre><p id="0f82" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">再一次，我认为“canToggle”比“Toggle”更直观。“切换”为更多的解释打开了大门，比如“关”或“开”，或者甚至可以是执行一些附加逻辑的功能。使用canToggle，很明显，它要么是一个布尔值，要么是一个将返回布尔值的函数。</p><p id="64a1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io"> <em class="mb">更多项目vs更多项目</em> </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ab9e" class="ml kb in mh b gy mm mn l mo mp">const moreItems = false;<br/>const areMoreItems= false; // Better</span></pre><p id="4c84" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个例子中，我们用“are”作为前缀，这只是“is”的一种形式。“moreItems”在这个上下文中可以指一系列附加的项目，但是MoreItems清楚地表示是否有更多的项目。</p><h1 id="0acf" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.将“id”属性放在HTML元素的前面</h1><p id="7e8e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果你使用HTML，或者像React或Vue这样的JavaScript框架，你应该知道一个<input/>或<div>上的属性数量会快速增长。当浏览一个大的html文件或表单时，总是将id="elementId "属性<strong class="la io">放在第一个</strong>会很有帮助，这样读者可以很快知道他们在看什么元素</div></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e18f" class="ml kb in mh b gy mm mn l mo mp">&lt;form id="signUpForm"&gt;<br/>   // RIGHT WAY<br/>   &lt;input <br/>      id="email"  // Clear at top<br/>      type="email"<br/>      onChange={(e) =&gt; setEmail(e.target.value)} // React code<br/>      value={email}<br/>      tabIndex="1"<br/>    &lt;/input&gt;</span><span id="c775" class="ml kb in mh b gy mq mn l mo mp">    // WRONG WAY<br/>    &lt;input <br/>      onChange={(e) =&gt; setPhone(e.target.value)} // React code<br/>      value={phone}<br/>      tabIndex="2"<br/>      id="phone" // ID is harder to find<br/>      type="phone"   <br/>    &lt;/input&gt;<br/>&lt;/form&gt;</span></pre><p id="1e26" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对于第一个输入，我们将id属性放在第一位，对于第二个输入，我们将它隐藏在几个属性中。当扫描这段代码时，我认为读者会比第二个更快地将第一个输入识别为电子邮件字段。在第二个输入中，读者可能不得不扫描onChange方法，并试图从那里进行解释，而在第一个输入中，这是很难错过的。</p><h1 id="7e1d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.当与DOM交互时，总是用“handle”作为函数的前缀</h1><p id="c2b0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果在使用React之类的框架/库时，您正在向DOM元素传递回调函数，并且您正在接收一个“事件”对象的形式，我强烈建议您在函数前面加上“handle”。您会在React文档中经常看到这一点，但是我想重申一下，当通读一个组件时，这种约定是多么有用。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b3c1" class="ml kb in mh b gy mm mn l mo mp">// NOT AS GOOD<br/>function save(event){<br/>   event.preventDefault();<br/>}</span><span id="095e" class="ml kb in mh b gy mq mn l mo mp">&lt;button onClick={save}&gt;&lt;/form&gt;</span><span id="0a34" class="ml kb in mh b gy mq mn l mo mp">VS</span><span id="5937" class="ml kb in mh b gy mq mn l mo mp">// GOOD<br/>function handleSave(event){<br/>   <!-- -->event.preventDefault();<br/>}</span><span id="446a" class="ml kb in mh b gy mq mn l mo mp">&lt;button onClick={handleSave}&gt;&lt;/form&gt;</span></pre><p id="c5f3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您从执行业务逻辑或调用API服务的外部来源引入其他方法，如“save ”,那么区分与DOM元素交互的函数和不与DOM元素交互的函数会很有帮助，使用前缀“handle”会使这变得简单而高效。</p><h1 id="9f7a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">4.使用CQRS模式来区分查询和命令</h1><p id="e42e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果你不熟悉CQRS模式，我建议你先阅读马丁·福勒的这篇伟大的文章。我的快速总结是，动作分为两类，查询(获取信息)和命令(对某些东西进行操作)。如果你了解CRUD，那么查询就是“R”，命令就是“CUD”(以及其他一切)。</p><p id="53d4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">由于大多数应用程序在查询和命令之间有一个平衡，构建应用程序来区分这两者可以使代码更容易阅读和维护。例如，如果您的应用程序调用api，我会在我的React应用程序中创建一个backendConfig文件，并像这样构造它。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9e29" class="ml kb in mh b gy mm mn l mo mp">// backendConfig.js //</span><span id="202d" class="ml kb in mh b gy mq mn l mo mp">export queryEndpoints = {<br/>   getAllCustomers: '/api/get-all-customers'<br/>   getCustomer: '/api/get-customer/'<br/>}</span><span id="23d4" class="ml kb in mh b gy mq mn l mo mp">export commandEndpoints = {<br/>   createCustomer: '/api/create-customer',<br/>   updateCustomer: '/api/update-customer'<br/>}</span><span id="48d0" class="ml kb in mh b gy mq mn l mo mp"><br/>// CustomerService.js //</span><span id="6d96" class="ml kb in mh b gy mq mn l mo mp">import {queryEndpoints, commandEndpoints} from './backendConfig.js'</span><span id="b811" class="ml kb in mh b gy mq mn l mo mp">// Create Customer method<br/>...<br/>axios.post(commandEndpoints.createCustomer, customer);<br/>...</span><span id="9979" class="ml kb in mh b gy mq mn l mo mp">// Get Customer method<br/>...<br/>const customer = await axios.get(queryEndpoints.getCustomer + customerId);<br/>...</span></pre><p id="a18e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个例子省略了很多相关的逻辑，但是希望您理解将端点划分为查询和命令的意图和好处。如果您有一个更大的API，这将非常有用，并且在添加新的端点或查找现有的端点时会节省您的时间。</p><h1 id="b177" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">5.条件语句总是使用花括号</h1><p id="cb50" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你们中的一些人可能不同意我的观点，但是我在写条件语句时总是使用括号。如果您来自Python，也许您喜欢只使用缩进，但是我发现花括号提供了大量的空白，既可以阅读代码，又可以快速确认您需要考虑的条件。此外，您会遇到必须对多行条件语句使用花括号的情况，因此最好保持一致，并在任何地方都使用它们。我知道你可能希望使用更少的代码行，但是我认为不值得为了让某人不小心跳过一个重要的条件而进行权衡。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="da96" class="ml kb in mh b gy mm mn l mo mp">// GOOD<br/>if(isValid){<br/>   save();<br/>}</span><span id="5847" class="ml kb in mh b gy mq mn l mo mp">vs</span><span id="38dd" class="ml kb in mh b gy mq mn l mo mp">// NOT AS GOOD - Less consistent<br/>if(isValid) save(); <br/>OR <br/>if(isValid)<br/>   save();</span></pre><p id="6650" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我确实使用三元运算符，但我通常会通过换行和缩进来使它们变得明显。我也只在把结果赋给变量的时候使用它们。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="4428" class="ml kb in mh b gy mm mn l mo mp">const errorMessage = !form.isValid<br/>   ? "The form is invalid" <br/>   : "";</span></pre><h1 id="44d1" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">包扎</h1><p id="1aa1" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在你知道了！编写更简洁、更易维护的代码的5个简单技巧。如果你同意或不同意这些观点，请在下面的评论中留言，如果你喜欢这篇文章，请留下一些掌声，跟我来。编码快乐！</p><p id="c8e4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="mb">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="mb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>