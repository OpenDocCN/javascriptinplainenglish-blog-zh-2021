<html>
<head>
<title>Angular:How I used Regex to validate form and display the type (uppercase, special, etc)of each character typed in a textbox and its count</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:我如何使用Regex来验证表单并显示文本框中输入的每个字符的类型(大写、特殊等)及其计数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-used-regex-to-verify-and-display-the-type-uppercase-special-etc-of-each-character-typed-in-a-b959d3b487f8?source=collection_archive---------2-----------------------#2021-12-22">https://javascript.plainenglish.io/how-i-used-regex-to-verify-and-display-the-type-uppercase-special-etc-of-each-character-typed-in-a-b959d3b487f8?source=collection_archive---------2-----------------------#2021-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bf360dc2696bbf61fc36d00308891410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BPqkEv44h3SHnuOP"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@cbpsc1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clint Patterson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0445" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一些网站上(最近是Myntra)，我看到了注册表单，用户需要在密码字段中输入大写字符或特殊字符。当用户输入他的密码时，显示输入的字符类型。该表单还显示用户输入特定类型字符的次数。</p><p id="b72e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我开始探索Regex之前，我从未对这个特性给予太多关注。Regex是我一直回避的话题，因为它太庞大了。下面的网站在很大程度上帮助了我理解和测试Regex。</p><div class="ky kz gp gr la lb"><a href="https://regex101.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">regex101:构建、测试和调试regex</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">正则表达式测试器，语法高亮，解释，PHP/PCRE，Python，GO，JavaScript的备忘单…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">regex101.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="9ee3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到故事，我想分享一个与我在这些网站上看到的功能非常相似的例子。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/9773a38528ca47d34864a47fb0af87d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzlfTH3t-zpK1pwBl2MYDQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Character Validator Form</figcaption></figure><p id="45a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的目标如下:</p><ol class=""><li id="daa3" class="lv lw in kc b kd ke kh ki kl lx kp ly kt lz kx ma mb mc md bi translated">用户可以在文本框中输入最多8个字符的<strong class="kc io"/>。增加这一限制是为了使测试更容易。用户应该至少输入<strong class="kc io"> 1个大写字符、2个特殊字符、2个数字和1个小写字符。</strong></li><li id="f547" class="lv lw in kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated">我们已经展示了4种过滤器类型:<strong class="kc io">大写、特殊字符、数字和小写</strong>。只要每种类型下的<strong class="kc io">字符数少于预期数</strong>，这些类型就会显示为<strong class="kc io">红色</strong>。如果这些类型<strong class="kc io">下的计数超过预期计数</strong>，标签颜色从<strong class="kc io">红色变为绿色</strong>。</li><li id="cedb" class="lv lw in kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated">最后，只有当每个过滤器类型的预期字符数都满足时，用户才能提交表单。</li></ol><p id="5423" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于过滤器类型和每个类型下的预期字符数是一个常数，我们将使用名为<strong class="kc io"> count </strong>的<strong class="kc io"> enum </strong>来定义这个数据。enum的键包含过滤器名称，对应于该键的值包含用户需要为该过滤器类型输入的预期字符数。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="db29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还导出了一个函数<strong class="kc io"> getFilterList() </strong>，它返回enum的所有键(过滤器名称)的数组。今后，我们将在多个地方使用该列表。</p><p id="b45e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> AppComponent模板:</strong></p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="69ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该模板包含一个简单的表单<strong class="kc io"> characterValidatorForm </strong>，其中包含一个文本框，并应用了一个指令<strong class="kc io"> valueCheck </strong>。在这个例子中，这个指令将完成我们的大部分工作。</p><p id="c40f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有一个名为<strong class="kc io">过滤器</strong>的对象数组。每个对象包含3个属性:<strong class="kc io">名称，计数和支出。</strong><strong class="kc io">名称</strong>属性将包含值<strong class="kc io">大写、特殊字符、数字和小写。</strong><strong class="kc io">count</strong>属性将包含用户在上述每种类型下输入的字符数，而<strong class="kc io"> expCount </strong>属性包含为使表单有效而在每种类型下输入的字符数。</p><p id="e084" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只要表单无效，<strong class="kc io">提交</strong>按钮就会保持禁用状态。</p><p id="298c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将<strong class="kc io">过滤器</strong>数组作为@Input()传递给<strong class="kc io"> valueCheck </strong>指令。</p><p id="c9c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次从<strong class="kc io"> valueCheck </strong>指令触发<strong class="kc io"> filterCountUpdated </strong>事件时，都会调用<strong class="kc io"> filterCountUpdated() </strong>。每当筛选器类型的count属性更新时，都会触发此事件。</p><p id="d487" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当过滤器类型的预期计数与过滤器类型的预期字符数不匹配时，我们还会显示一条错误消息<strong class="kc io"> errMessage </strong>。</p><p id="46f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果过滤器类型的<strong class="kc io">计数</strong>属性超过或等于<strong class="kc io">支出计数</strong>属性，那么匹配的CSS类<strong class="kc io">将被应用到&lt; p &gt;标签。否则，CSS类<strong class="kc io">不匹配</strong>将被应用。</strong></p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="f145" class="mq mr in mm b gy ms mt l mu mv">.<strong class="mm io">matched</strong>{<br/>color:green;<br/>}</span><span id="410d" class="mq mr in mm b gy mw mt l mu mv">.<strong class="mm io">not-matched</strong>{<br/>color:red;<br/>}</span></pre><p id="a4cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们跳到<strong class="kc io"> AppComponent类</strong>。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个类非常简单。</p><ol class=""><li id="189b" class="lv lw in kc b kd ke kh ki kl lx kp ly kt lz kx ma mb mc md bi translated">正如已经讨论过的，该类定义了<strong class="kc io">过滤器</strong>数组。我们已经使用导出的方法<strong class="kc io"> getFilterList() </strong>和enum <strong class="kc io"> count </strong>来填充数组中每个对象的<strong class="kc io"> name </strong>和<strong class="kc io"> expCount </strong>属性。</li><li id="f957" class="lv lw in kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated"><strong class="kc io"> characterValidatorForm </strong>只有一个FormControl <strong class="kc io"> textbox </strong>。</li></ol><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="8f23" class="mq mr in mm b gy ms mt l mu mv">public <strong class="mm io">characterValidatorForm </strong>= new FormGroup({ <br/><strong class="mm io">textbox</strong>: new FormControl(‘’) <br/>});</span></pre><p id="49d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.在ngOnInit()生命周期钩子中，我们将一个名为<strong class="kc io"> characterValidator </strong>的自定义验证器应用到这个FormControl中，通过<strong class="kc io"> setValidator() </strong>显示错误消息。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="cd25" class="mq mr in mm b gy ms mt l mu mv"><strong class="mm io">ngOnInit()</strong> {<br/>this.setValidator();    <br/>this.returnErrorMessage();<br/>}</span></pre><p id="9024" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还编写了错误消息显示的逻辑。我们已经使用了<strong class="kc io"> returnErrorMessage() </strong>来设置<strong class="kc io"> errMessage </strong>属性，以便向用户显示。</p><p id="b59a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> returnErrorMessage()和setValidator() </strong>被调用两次:第一次加载组件时，以及每次更新过滤器类型的计数时。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="3223" class="mq mr in mm b gy ms mt l mu mv"><strong class="mm io">returnErrorMessage()</strong> {<br/>let errObject = this.characterValidatorForm.get(‘textbox’).errors;<br/>this.<strong class="mm io">errMessage </strong>= errObject ? Object.keys(errObject)[0] : ‘’;<br/>}</span></pre><p id="0f8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们完成了指令，我们将返回到<strong class="kc io"> filterCountUpdated() </strong>。</p><p id="3f87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> ValueCheckDirective类:</strong></p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><ol class=""><li id="9fb3" class="lv lw in kc b kd ke kh ki kl lx kp ly kt lz kx ma mb mc md bi translated">从AppComponent接收到作为<strong class="kc io"> @Input() filterList </strong>的<strong class="kc io">过滤器</strong>数组。</li></ol><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="74e9" class="mq mr in mm b gy ms mt l mu mv">@Input(‘filterList’) filterList: any;</span></pre><p id="d873" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将<strong class="kc io">更新<strong class="kc io">过滤器列表</strong>中的计数属性</strong>，并将其发送回AppComponent以更新显示。</p><p id="202c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们再次调用了导出的方法<strong class="kc io"> getFilterList() </strong>来将过滤器名称存储在属性<strong class="kc io"> filterNameList </strong>中。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="d7c8" class="mq mr in mm b gy ms mt l mu mv">public filterNameList = getFilterList();</span></pre><p id="c5cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.每当用户在文本框中输入内容时，就会触发一个<strong class="kc io"> keyup </strong>事件。我们设置了一个<strong class="kc io"> @HostListener </strong>来监听这个keyup事件，并调用<strong class="kc io"> onKeyUp() </strong>方法。</p><p id="43be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">A.每次触发该事件时，我们都希望将每个过滤器类型的count属性重置为0。应该对每次按键重新进行计数计算。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="c8c6" class="mq mr in mm b gy ms mt l mu mv">this.filterList.map((x) =&gt; (x.count = 0)); </span></pre><p id="1065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">B.考虑一个场景，用户输入几个字符，然后删除所有字符。在这种情况下，我们需要用每个过滤器类型的最新计数值来更新AppComponent。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="239b" class="mq mr in mm b gy ms mt l mu mv">if (!value.length) { <br/><strong class="mm io">this.filterCountUpdated.emit(this.filterList); </strong><br/>}</span></pre><p id="b0ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">C.文本框中输入的文本可以是单个字符串或一串字符。我们正在遍历字符串，并使用<strong class="kc io"> match()将每个字符与一个正则表达式进行匹配。</strong></p><p id="7fd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">/^[A-Z]*$/检查字符是否是大写字符。</p><p id="3ddc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">/^[a-z]*$/检查字符是否是小写字符。</p><p id="f86e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">/^[0–9]*$/检查字符是否是一个数字。</p><p id="1c88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">/^\W$/检查字符是否是数字或字母以外的任何东西。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="6d97" class="mq mr in mm b gy ms mt l mu mv">for (let i = 0; i &lt; value.length; i++) { <br/>if (value[i].match(<strong class="mm io">/^[A-Z]*$/</strong>)) { this.updateFilterCount(this.filterNameList[0]); }</span><span id="4924" class="mq mr in mm b gy mw mt l mu mv">else if (value[i].match(<strong class="mm io">/^[a-z]*$/</strong>)) { this.updateFilterCount(this.filterNameList[3]); <br/>}</span><span id="9133" class="mq mr in mm b gy mw mt l mu mv">else if (value[i].match(<strong class="mm io">/^[0–9]*$/</strong>)) { this.updateFilterCount(this.filterNameList[2]); <br/>}</span><span id="6aa2" class="mq mr in mm b gy mw mt l mu mv">else if (value[i].match(<strong class="mm io">/^\W$/</strong>)) { <br/>this.updateFilterCount(this.filterNameList[1]); <br/>} <br/>}</span></pre><p id="a513" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当有任何正则表达式匹配时，我们调用<strong class="kc io"> updateFilterCount() </strong>将过滤器名称作为参数传递。</p><p id="581d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">D.在<strong class="kc io"> updateFilterCount() </strong>中，我们首先检索filterList数组中对象的<strong class="kc io">索引，该数组具有与方法参数中传递的过滤器名称相同的<strong class="kc io">名称属性</strong>。我们使用该索引来增加相应对象的计数属性</strong>。最后，我们通过<strong class="kc io"> filterCountUpdated </strong>事件发射器将<strong class="kc io">更新的filterList </strong>数组发送回AppComponent。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="21d3" class="mq mr in mm b gy ms mt l mu mv"><strong class="mm io">updateFilterCount(filterName: string)</strong> { </span><span id="c4df" class="mq mr in mm b gy mw mt l mu mv">let match = this.filterList.findIndex( (filter) =&gt; filter.name === filterName );<br/>this.filterList[match].count++; <br/>this.filterCountUpdated.emit(this.filterList); <br/>}</span></pre><p id="a840" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们检查由<strong class="kc io"> filterCountUpdated </strong>触发的事件是如何在AppComponent中由<strong class="kc io"> filterCountUpdated() </strong>方法处理的。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="c094" class="mq mr in mm b gy ms mt l mu mv"><strong class="mm io">filterCountUpdated(filterList) {</strong><br/>console.log(filterList);<br/>this.filters.forEach((filter) =&gt; {<br/>let match = filterList.findIndex((fltr) =&gt; fltr.name === filter.name);<br/>filter.count = filterList[match].count;</span><span id="c70f" class="mq mr in mm b gy mw mt l mu mv">this.setValidator();<br/>this.returnErrorMessage(); <br/>});<br/>}</span></pre><p id="d156" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我输入“H！”在如下所示的文本框中，我已经记录了指令发送给AppComponent的更新后的<strong class="kc io"> filterList </strong>数组。我们正在迭代<strong class="kc io">过滤器</strong>数组属性和<strong class="kc io">更新来自<strong class="kc io">过滤器列表</strong>数组的每个过滤器类型的计数属性</strong>。</p><p id="480a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个筛选器类型的更新计数显示在AppComponent模板中。</p><p id="2975" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还重置了自定义验证器<strong class="kc io"> characterValidator </strong>并更新了错误消息属性<strong class="kc io"> errMessage。</strong></p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/288068bb55915528ba7b62c008d2f81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CT5EVdty8DpcGiy1dx1tZg.png"/></div></div></figure><p id="d2a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了理解FormControl <strong class="kc io"> textbox </strong>的错误验证是如何发生的，我们需要检查自定义验证器<strong class="kc io"> characterValidator </strong>。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="mj mk l"/></div></figure><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="96af" class="mq mr in mm b gy ms mt l mu mv">export function <strong class="mm io">characterValidator</strong>(filterList: any) {<br/> return (control: AbstractControl): ValidationErrors | null =&gt; {<br/>//logic<br/>}<br/>}</span></pre><p id="acfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经将AppComponent中的<strong class="kc io"> filters </strong>数组作为参数传递给了下面的<strong class="kc io"> setValidator() </strong>中的<strong class="kc io"> characterValidator </strong>函数。</p><pre class="lr ls lt lu gt ml mm mn mo aw mp bi"><span id="1514" class="mq mr in mm b gy ms mt l mu mv"><strong class="mm io">setValidator() { </strong>   <br/>this.characterValidatorForm.get('textbox')     .setValidators([<strong class="mm io">characterValidator(this.filters)</strong>]);    </span><span id="fe7c" class="mq mr in mm b gy mw mt l mu mv">this.characterValidatorForm.get('textbox').<strong class="mm io">updateValueAndValidity</strong>();  }</span></pre><p id="f474" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">characterValidator函数将返回一个错误对象，该对象在键和值为真时包含<strong class="kc io">错误消息，或者返回null。在后一种情况下，它意味着FormControl没有错误。</strong></p><p id="e1ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，对于每种过滤器类型，我们检查用户输入的字符数是否等于或超过预期数。如果没有，我们会显示一条错误消息。错误信息不是硬编码的，完全由<strong class="kc io">枚举计数</strong>控制。因此，我们必须更新过滤器名称或预期计数，我们只需要更新枚举。其他地方不需要改变。</p><p id="9d79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在下面的链接查看整个作品:</p><div class="ky kz gp gr la lb"><a href="https://stackblitz.com/edit/angular-x1zf9z?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">角形(叉形)堆叠</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">编辑描述</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">stackblitz.com</p></div></div><div class="lk l"><div class="mx l lm ln lo lk lp jt lb"/></div></div></a></div><h2 id="b2d1" class="mq mr in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">进一步阅读</h2><div class="ky kz gp gr la lb"><a rel="noopener  ugc nofollow" target="_blank" href="/best-tool-for-web-scraping-beautifulsoup-vs-regex-vs-advanced-web-scrapers-50b8fb92950d"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">最佳网络抓取工具:beautiful soup vs . Regex vs . Advanced Web Scrapers</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">BeautifulSoup、正则表达式或高级web scraper——哪一个是web抓取的最佳工具？深潜…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lk l"><div class="np l lm ln lo lk lp jt lb"/></div></div></a></div><p id="6d7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nq">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nq">plain English . io</em></strong></a><em class="nq">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nq">免费周报</em> </strong> </a> <em class="nq">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nq">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nq">LinkedIn</em></strong></a><em class="nq"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nq">YouTube</em></strong></a><em class="nq"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nq">不和</em> </strong> </a> <strong class="kc io"> <em class="nq">。</em>T49】</strong></p><p id="7ad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nq">对缩放您的软件启动感兴趣</em> </strong> <em class="nq">？检查</em> <a class="ae jz" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nq">电路</em> </strong> </a> <em class="nq">。</em></p></div></div>    
</body>
</html>