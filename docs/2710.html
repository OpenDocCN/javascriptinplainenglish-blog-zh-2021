<html>
<head>
<title>An Explanation of the Vue Context Argument — A Composition API Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Vue上下文参数的解释——一个组合API教程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explaining-the-vue-context-argument-a-composition-api-tutorial-864f9c3a41ce?source=collection_archive---------21-----------------------#2021-06-03">https://javascript.plainenglish.io/explaining-the-vue-context-argument-a-composition-api-tutorial-864f9c3a41ce?source=collection_archive---------21-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1c5114cf873df5752b7246a1400decfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K23BKNkCGEBTqcXb"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="5549" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当在Vue 3 <a class="ae jd" href="https://learnvue.co/2020/01/4-vue3-composition-api-tips-you-should-know/" rel="noopener ugc nofollow" target="_blank">组合API </a>中工作时，有全新的方式来访问组件功能。在本文中，我们将看看设置函数的上下文参数。</p><p id="e06f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些改变是必要的，因为在组合API中，我们没有像在选项API中那样引用<code class="fe lb lc ld le b">this</code>。</p><p id="569a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Options API中，我们可以在任何选项中调用<code class="fe lb lc ld le b">console.log(this)</code>,并获得对组件本身的引用——让我们能够访问它的属性、计算属性、数据等等。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c3b4" class="ln lo jg le b gy lp lq l lr ls">export default { <br/>  props: { lastName: String, }, <br/>  data() { <br/>    return { <br/>      name: 'hello' <br/>    } <br/>  }, <br/>  created() { <br/>    console.log(this.lastNameModifiers) // props are on `this` <br/>    console.log(this.name) // data is on `this` <br/>    this.createdMethod() // methods are on `this` <br/>  }, <br/>  methods: { <br/>    createdMethod() { <br/>      console.log('created' )<br/>    } <br/>  } <br/>}</span></pre><p id="e220" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，<a class="ae jd" href="https://learnvue.co/2020/12/setting-up-your-first-vue3-project-vue-3-0-release/" rel="noopener ugc nofollow" target="_blank"> Vue 3允许我们使用组合API </a>，其中我们所有的代码都位于一个<code class="fe lb lc ld le b">setup</code>函数中。这意味着setup是我们声明反应数据、方法和计算属性的地方。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a57d" class="ln lo jg le b gy lp lq l lr ls">import { ref } from 'vue' </span><span id="2e59" class="ln lo jg le b gy lt lq l lr ls">export default { <br/>  props: { lastName: String, }, <br/>  setup () { <br/>    // how do we access props without this??<br/>    const createdMethod = () =&gt; { <br/>      console.log('created')<br/>    } <br/>    const name = ref('hello') <br/>    createdMethod() <br/>    return { <br/>      createdMethod, <br/>      name <br/>    } <br/>  } <br/>}</span></pre><p id="caf1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Setup在我们的组件实例实际创建之前运行，由于我们的setup属性实际上是我们为组件定义所有内容的地方，因此<strong class="kf jh">不再使用<code class="fe lb lc ld le b">this</code>引用</strong>组件本身。</p><h1 id="0383" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">那么我们如何访问组件属性呢？</h1><p id="bc84" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">Composition API为我们提供了访问重要组件信息的替代方法，比如它的props和slots。</p><figure class="lf lg lh li gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/980252db35f733d19720f0903e81c11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1VhY3rhL35mPBN9p.png"/></div></div></figure><p id="27ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可能的，因为我们的设置函数采用了<strong class="kf jh">两个属性</strong>，让我们可以访问一些组件属性:<code class="fe lb lc ld le b">props</code>和<code class="fe lb lc ld le b">context</code>。</p><p id="fc7c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这三个属性是:</p><ol class=""><li id="3cad" class="mx my jg kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><code class="fe lb lc ld le b">context.attrs </code>-<strong class="kf jh">非属性</strong>传递给我们的组件</li><li id="5894" class="mx my jg kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lb lc ld le b">context.slots</code> -一个包含我们所有<strong class="kf jh">模板槽的渲染函数</strong>的对象</li><li id="5c2a" class="mx my jg kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe lb lc ld le b">context.emit </code> -我们的组件向<strong class="kf jh">发出事件</strong>的方法</li></ol><p id="5cf4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地了解一下其中的每一项。</p><h1 id="ad44" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.上下文.属性</h1><p id="4530" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">同样，<code class="fe lb lc ld le b">context.attrs</code>包含了传递给组件的所有非属性。</p><p id="9267" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是什么意思？</p><p id="5515" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们实际使用我们的组件时，我们添加的任何没有在我们的props 中声明的元素属性都将在<code class="fe lb lc ld le b">context.attrs</code>中可用</p><p id="6e5e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个自定义组件，它接受一个名为value的属性。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="39c1" class="ln lo jg le b gy lp lq l lr ls">export default { <br/>  props: { value: String, }, <br/>  setup (props, context) { <br/>    console.log(context.attrs) <br/>  } <br/>}</span></pre><p id="5af7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在父组件中，我们传递给它几个属性。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="43a2" class="ln lo jg le b gy lp lq l lr ls">&lt;template&gt; <br/>  &lt;custom-component :value="value" test="hi" @close="close" /&gt; &lt;/template&gt;</span></pre><p id="3e90" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的日志语句的结果将是:</p><figure class="lf lg lh li gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/0dbd178a1a2f138ccbd372094e6c9537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qaYzQ8LnBtDvI5Ds.png"/></div></div></figure><p id="9d0e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，它包含了除我们声明的道具之外的所有内容。这包括事件监听器和HTML属性。</p><p id="9a17" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的一点是attrs是<strong class="kf jh">非反应式</strong>。也就是说，如果我们想要应用副作用来响应属性值的改变，我们应该使用非更新的生命周期钩子。</p><h1 id="bf59" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">上下文.插槽</h1><p id="767e" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">接下来，<code class="fe lb lc ld le b">context.slots</code>有点令人困惑，所以让我们通过一个例子来看看它什么时候有用。</p><p id="9fc4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，<code class="fe lb lc ld le b">context.slots</code>让我们可以访问每个槽的<a class="ae jd" href="https://learnvue.co/2019/12/using-component-slots-in-vuejs%20-%20an-overview/" rel="noopener ugc nofollow" target="_blank">渲染方法。当我们编写自己的<strong class="kf jh">自定义渲染函数</strong>而不使用模板代码时，这很有用。</a></p><p id="61b3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue建议在大多数用例中使用模板，但是如果你真的想使用Javascript的全部功能，我们可以创建自己的渲染函数。</p><p id="1b44" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://v3.vuejs.org/guide/render-function.html" rel="noopener ugc nofollow" target="_blank">Vue文档中的例子</a>使用自定义渲染方法的一个很好的例子是，如果我们创建一个组件，它根据道具的值使用不同的等级标题来渲染槽值。</p><figure class="lf lg lh li gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6bf4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这段代码中，我们对所有6个标题选项使用了v-if和v-else-if条件。如你所见，有很多重复的代码，看起来非常混乱。</p><p id="7884" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以使用render函数以编程方式生成标题。对于组合API设置函数，看起来是这样的。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="711f" class="ln lo jg le b gy lp lq l lr ls">import { h } from 'vue'</span><span id="8d00" class="ln lo jg le b gy lt lq l lr ls">export default { <br/>  props: { <br/>    level: Number, <br/>  }, <br/>  setup (props, context) { <br/>    console.log('here') <br/>    return () =&gt; <br/>      h( <br/>        'div', <br/>        {}, // props and attributes: OPTIONAL <br/>        /* MISSING!! this is where children go, for us our slot */ <br/>      ) <br/>  } <br/>}</span></pre><p id="0dcf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们如何让我们的插槽渲染？？</p><p id="ae12" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<code class="fe lb lc ld le b">context.slots</code>发挥作用的地方。</p><p id="2b61" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过允许我们访问每个插槽的渲染函数，我们可以很容易地将插槽添加到渲染函数中。每个插槽都可以通过其名称来访问，因为我们没有明确地命名我们的插槽，所以它被命名为default。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="77ba" class="ln lo jg le b gy lp lq l lr ls">import { h } from 'vue'</span><span id="0646" class="ln lo jg le b gy lt lq l lr ls">export default { <br/>  props: { <br/>    level: Number, <br/>  }, <br/>  setup (props, context) { <br/>    console.log('here') <br/>    return () =&gt; <br/>      h( <br/>        'div', <br/>        {}, // props and attributes: OPTIONAL <br/>        context.slots.default() /* renders our slot */<br/>      ) <br/>  } <br/>}</span></pre><p id="b46d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们用这样一个简单的父组件运行它</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0a31" class="ln lo jg le b gy lp lq l lr ls">&lt;template&gt; <br/>  &lt;child-component :level="1"&gt; Hello World &lt;/child-component&gt; &lt;/template&gt;</span></pre><p id="3c60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们完成的DOM的样子。</p><figure class="lf lg lh li gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/c997c4ab6c14fb397869b8999701f1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*95iI6pZ2SNA9AymP.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Our H1 is programmatically created with our slot</figcaption></figure><p id="7143" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="d910" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，你可能不会经常使用context.slots，但是当你编写复杂的Javascript渲染函数时，它是一个强大的特性。</p><h1 id="b77e" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">上下文.发出</h1><p id="5522" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">最后，<code class="fe lb lc ld le b">context.emit</code>取代了<code class="fe lb lc ld le b">this.$emit</code>，成为我们从组件向<a class="ae jd" href="https://learnvue.co/2020/01/a-vue-event-handling-cheatsheet-the-essentials/" rel="noopener ugc nofollow" target="_blank">发出事件的方式。</a></p><p id="7807" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于向父组件发送任何类型的事件都很有用，不管有没有数据。</p><p id="d7f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要创建一个X按钮，它发出一个名为<code class="fe lb lc ld le b">close</code>的事件。</p><figure class="lf lg lh li gt is"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7c0e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的父组件中，我们可以用<code class="fe lb lc ld le b">v-on</code>指令监听这个关闭事件。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="920c" class="ln lo jg le b gy lp lq l lr ls">&lt;modal-component @close="handleClose" /&gt;</span></pre><p id="d481" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得在Vue中使用<a class="ae jd" href="https://learnvue.co/2021/05/a-guide-to-vue-emit-how-to-emit-custom-events-in-vue/" rel="noopener ugc nofollow" target="_blank"> emit的完整指南，请查看这篇文章</a>或<a class="ae jd" href="https://youtu.be/EEeaG0BTBQo" rel="noopener ugc nofollow" target="_blank"> YouTube教程</a>！</p><h1 id="78a7" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">在设置中我们不能访问什么</h1><p id="e697" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，我们已经看到了组合API如何让我们访问四个不同的属性:<code class="fe lb lc ld le b">props</code>、<code class="fe lb lc ld le b">attrs</code>、<code class="fe lb lc ld le b">slots</code>和<code class="fe lb lc ld le b">emit</code>。</p><p id="c013" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是由于安装程序在我们的组件实例创建之前运行，我们<strong class="kf jh">将不能</strong>访问这三个组件属性:</p><p id="c909" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是我们在<code class="fe lb lc ld le b">setup</code>内部声明的属性，但是我们没有一个内置的方法来访问所有数据属性的列表。</p><h1 id="23be" class="lu lo jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后的想法</h1><p id="1654" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在本文中，我们已经了解了Composition API如何访问一些组件属性。</p><p id="d3a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们不能像Options API那样访问它，所以setup函数有两个参数可以用来访问组件的props、attrs、slots和emit方法。</p><p id="8fa1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用props和上下文参数，我们可以访问强大的组件属性，并为所有类型的Vue项目添加完整的功能。</p><p id="996c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何问题，请在下面的回复中留下！</p><p id="3004" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://learnvue.co/vue-3-essentials-cheatsheet/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="np">如果你有兴趣学习更多关于Vue 3的知识，下载我的免费Vue 3基本知识备忘单，比如Composition API、Vue 3模板语法等等。</em> </strong> </a></p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="58dd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="np">原载于2021年6月3日https://learnvue.co</em><em class="np">T21</em><a class="ae jd" href="https://learnvue.co/2021/06/explaining-the-vue-context-argument-a-composition-api-tutorial/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>