<html>
<head>
<title>8 Tips to Improve Your Frontend Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高前端性能的8个技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/8-tips-to-improve-your-frontend-performance-51e78a1c2131?source=collection_archive---------16-----------------------#2021-06-24">https://javascript.plainenglish.io/8-tips-to-improve-your-frontend-performance-51e78a1c2131?source=collection_archive---------16-----------------------#2021-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ba99a495da5fc1b7e57557ce5abf374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zb14xNXseK-dCe-Y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mimithian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mimi Thian</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">性能改进是我们在任何前端应用程序中面临的最常见问题之一。几乎在每个项目中，在某个时候(通常在后期)，您都会遇到这个问题。在这篇文章中，我想介绍一些我在许多项目中使用过的技术，并希望这些指南和模式也能帮助你。</p><p id="66a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一些我已经在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/did-someone-say-composition-c7843d898b2">我的另一篇文章</a>中提到了，但是除此之外，在你真正进行改进之前，还有其他方面需要研究。</p><h1 id="7cfe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在任何变化之前</h1><p id="f341" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，当我们谈到性能调优时，我们需要建立一些测量机制。你不能依赖直觉，因为它很容易把你引向错误的方向。我们认为可能是性能问题背后的原因<em class="me">通常</em>根本没有任何问题。一旦你有了度量，就像我们有覆盖所有逻辑的单元测试一样，通常它可以引导你走向正确的方向——或者至少当你在错误的道路上时你会注意到。</p><h1 id="d979" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义你的目标</h1><p id="9f52" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在进行性能调优项目之前，明确自己的目标至关重要。它决定了你是否会达到你的目标。所以这里的问题应该是——好的表现意味着什么？达到什么程度我们才能说有了实质性的改善？你不能只是说越快越好。</p><p id="e453" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果页面加载时间减少20%意味着成功，那么接下来的每一步都应该以实现这个目标为目标。</p><h1 id="4341" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置测量</h1><p id="8434" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们知道了<em class="me">改进意味着什么</em>，我们可以研究测量的方法并建立基线。这是实现度量定义步骤的一个步骤，您需要在构建管道中设置一个性能测试，并可视化您上面定义的<code class="fe mf mg mh mi b">DoD</code>。您可能不需要每次提交都运行它们，但是可能需要定期检查(每日构建)来了解您的目标和当前状态之间的差距。</p><p id="0b7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，从浏览器发送的在屏幕上呈现某样东西的请求需要5秒，我们可以将这5秒设置为基线，你的团队所做的所有更改都不应该比它慢。就像任何其他测试一样，当页面呈现时间增加时，它会失败。此外，您也可以使用包大小或其他指标来衡量性能。</p><p id="7734" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有像<code class="fe mf mg mh mi b">yslow</code>或<code class="fe mf mg mh mi b">lighthouse</code>这样的工具，你可以用来持续集成服务，让你保持正轨。</p><h1 id="d587" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分析和分类</h1><p id="d829" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们定义什么是成功，以及相应的反馈回路。<strong class="kf ir">怎么做</strong>从这个阶段开始最重要。我们通常需要对问题进行分析和分类。</p><p id="686f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要分析它是什么类型的慢。是单纯的代码问题还是更广泛的架构问题？或者，在某些情况下，你会发现一个设计问题。代码问题很简单，也很容易解决。比如使用一些低性能的依赖项(只需替换它们就能获得更好的结果)，或者使用<code class="fe mf mg mh mi b">debounce</code> / <code class="fe mf mg mh mi b">throttle</code>来减少调整输入框大小或改变输入框的事件处理量。</p><p id="e061" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，所有其他问题都可以归为设计问题，比如如何构建模块，或者组件之间的依赖关系是什么。这些问题通常会涉及大的变化，但投资回报率也很高。从长远来看，这对维护和降低缺陷率都有好处。</p><p id="605f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在此步骤中，您应该确定哪些问题可以通过简单的更改(替换依赖项、添加缓存或记忆叶组件)简单地解决。实际上，因为我们有一个先前定义的基线，一些目标可以通过这些简单的改变来实现。</p><p id="54bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不令人满意，我们需要向前迈进一步。</p><h1 id="e8f4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概述</h1><p id="e97c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果简单的更改不起作用，我们需要更多的时间和精力来重构和重新设计我们的应用程序，以满足性能需求。</p><p id="bf75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过几个具体的例子来讨论一些我们可以使用的技术。我们需要确定一些问题，从正确的方向进行抽象，然后进行拆分。最终目标是确保每个模块/组件尽可能独立，并且易于与其他模块/组件组合。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/22af19148e54b616a12d30730ec663d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y5VceUeGkmGiLhJ_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@xavier_von_erlach?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Xavier von Erlach</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e17" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">控制反转—类型1</h1><p id="71f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就像我在本文中讨论的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/did-someone-say-composition-c7843d898b2">,<code class="fe mf mg mh mi b">Avatar</code>不应该包含<code class="fe mf mg mh mi b">Tooltip</code>，它们应该组合在一起或者单独使用。</a></p><p id="25f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改变后，<code class="fe mf mg mh mi b">Avatar</code>不再依赖<code class="fe mf mg mh mi b">Tooltip</code>:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="7dd1" class="ms lc iq mi b gy mt mu l mv mw">import Avatar from "@atlaskit/avatar";  <br/>import Tooltip from "@material-ui/core/Tooltip";</span><span id="b463" class="ms lc iq mi b gy mx mu l mv mw">const MyAvatar = (props) =&gt; (  <br/>  &lt;Tooltip title="Juntao Qiu" placement="top" classes={...}&gt;  <br/>    &lt;Avatar  <br/>      name="Juntao Qiu"  <br/>      url="https://avatars.githubusercontent.com/u/122324"  <br/>    /&gt;  <br/>  &lt;/Tooltip&gt;  <br/>);</span></pre><h1 id="d880" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">控制的反向——类型2</h1><p id="e170" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在其他一些情况下，一个组件被链接到另一个组件，但是它们可以被其他类似的组件替换。像我上一篇文章中<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/did-someone-say-composition-c7843d898b2">的<code class="fe mf mg mh mi b">InlineEdit</code>和<code class="fe mf mg mh mi b">InlineDialog</code>场景。</a></p><p id="523f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<a class="ae kc" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> render props </a>来反转控件，使得一个组件不依赖于具体的实现，而是依赖于一个接口(或者一个协议)。这样，实现接口的所有组件都可以匹配，然后我们可以削减对具体包的依赖(在<code class="fe mf mg mh mi b">package.json</code>中定义)。</p><p id="aa56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这与前面的场景非常相似，不同之处在于拆分后这两个组件之间存在一些薄弱环节。<code class="fe mf mg mh mi b">render</code>函数中的参数是双方都在使用的协议。</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="3d1e" class="ms lc iq mi b gy mt mu l mv mw">const MyEdit = () =&gt; {  <br/>  return (  <br/>    &lt;InlineEdit  <br/>      editView={(fieldProps, isInvalid, error) =&gt; (  <br/>        &lt;Popover open={isInvalid}&gt;  <br/>          &lt;Typography&gt;{error}&lt;/Typography&gt;  <br/>          &lt;Textfield {...fieldProps} /&gt;  <br/>        &lt;/Popover&gt;  <br/>      )}  <br/>      validate={(value) =&gt; {  <br/>        return false;  <br/>      }}  <br/>    /&gt;  <br/>  );  <br/>};</span></pre><p id="94a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像上面的例子一样，<code class="fe mf mg mh mi b">editView</code>的参数不是任意的，它必须是一个包含<code class="fe mf mg mh mi b">fieldProps</code>、<code class="fe mf mg mh mi b">isInvalid</code>和<code class="fe mf mg mh mi b">error</code>的对象(尽管用户可以选择忽略一些参数)。</p><h1 id="0dd9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">多个入口点</h1><p id="268b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在有些情况下，您只使用一体化库中的一小部分，我们可以使用多个入口点来拆分库，让消费者挑选他们需要的东西。</p><p id="6e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个典型的例子是在早期版本的<code class="fe mf mg mh mi b">lodash</code>中，当用户想要使用一个函数，比如说<code class="fe mf mg mh mi b">partition</code>，他们需要导入整个包:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="6bd7" class="ms lc iq mi b gy mt mu l mv mw">import _ from 'lodash';</span><span id="a900" class="ms lc iq mi b gy mx mu l mv mw">const result = _.partition([1, 2, 3, 4], n =&gt; n % 2)</span></pre><p id="a6b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过多个入口点，您可以只导入您现在需要的内容:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="cfad" class="ms lc iq mi b gy mt mu l mv mw">import partition from 'lodash/partition';</span><span id="7f85" class="ms lc iq mi b gy mx mu l mv mw">const result = partition([1, 2, 3, 4], n =&gt; n % 2)</span></pre><p id="d59d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很可能，你可能有一个<code class="fe mf mg mh mi b">Button</code>包，它有所有的变体，你可以按类型分割它们并分别导出它们。像<code class="fe mf mg mh mi b">StandardButton</code>、<code class="fe mf mg mh mi b">LoadingButton</code>(内置一个附加图标)，或者任何其他专门的类型。</p><h1 id="5b57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">惰性负载</h1><p id="159e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你不必一开始就加载所有内容，有些内容可以异步加载，或者只在使用时加载。例如，在react中，我们可以使用<code class="fe mf mg mh mi b">React.lazy</code>或者像<code class="fe mf mg mh mi b">loadable</code>这样的第三方库来进行延迟加载。它在主页加载(或者只有上面的折叠屏幕)的情况下工作得很好，例如，在用户配置文件下可能有一个巨大的下拉菜单，当用户真正需要它时，你可以让它延迟加载。</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="c877" class="ms lc iq mi b gy mt mu l mv mw">const UserProfile = React.lazy(() =&gt; import('./UserProfile'));</span></pre><p id="6399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mf mg mh mi b">loading</code>期间，您可以有一个占位符组件:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="845a" class="ms lc iq mi b gy mt mu l mv mw">function HomePage() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>        &lt;UserProfile /&gt;<br/>      &lt;/Suspense&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="9974" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用缓存</h1><p id="822c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最后一个技巧是使用缓存，这也是人们在后端一直使用的传统方法。简单地缓存昂贵的计算结果，并在内存中的某个地方减少更改内容，可以为以后的访问节省大量时间。它可以在代码级别、本地浏览器数据库(LocalStorage或SessionStorage)中，也可以在更高级别，如CDN或redis缓存服务中。</p><p id="94a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在React中，我们可以使用如下API:</p><ul class=""><li id="b57f" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated"><code class="fe mf mg mh mi b">useMemo</code>获取数据</li><li id="2388" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mf mg mh mi b">useCallback</code>为功能</li><li id="e692" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mf mg mh mi b">memo</code>对于通常在叶节点的组件</li></ul><p id="6ddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个<code class="fe mf mg mh mi b">Toggle</code>组件:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="8c6c" class="ms lc iq mi b gy mt mu l mv mw">const Toggle = ({defaultChecked}) =&gt; {<br/>    const [checked, setChecked] = useState(defaultChecked);<br/>    <br/>    const styles = getToggleStyles('light');<br/>    <br/>    const onClick = () =&gt; {<br/>        setChecked(checked =&gt; !checked)<br/>    }<br/>    <br/>    return &lt;label css={styles}&gt;<br/>        //...<br/>    &lt;/label&gt;<br/>}</span><span id="2d58" class="ms lc iq mi b gy mx mu l mv mw">export default Toggle;</span></pre><p id="8bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mf mg mh mi b">React</code>中的缓存API，代码可能如下所示:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="8344" class="ms lc iq mi b gy mt mu l mv mw">const Toggle = ({defaultChecked}) =&gt; {<br/>    const [checked, setChecked] = useState(defaultChecked);<br/>    <br/>    const styles = useMemo(getToggleStyles('light'));<br/>    <br/>    const onClick = useCallback(() =&gt; {<br/>        setChecked(checked =&gt; !checked)<br/>    }, [])<br/>    <br/>    return &lt;label css={styles}&gt;<br/>        //...<br/>    &lt;/label&gt;<br/>}</span><span id="a187" class="ms lc iq mi b gy mx mu l mv mw">export default memo(Toggle);</span></pre><p id="caf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意当使用像<code class="fe mf mg mh mi b">useMemo</code>或<code class="fe mf mg mh mi b">useCallback</code>这样的API时，这些函数本身的调用不是免费的，所以你需要确保我们之前设置的性能测试告诉你使用前后的区别。</p><h1 id="5f7d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="b808" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本文中，我们讨论了前端开发中性能改进的几种方法和模式。在进行任何代码更改之前，我们需要确保我们有成功的定义，然后我们设置基线和相应的测试，以便在任何给定的时间我们都知道更改实际上是否有效。</p><p id="7ec4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们分析问题并将其分为两大类。简单的修复有时已经很令人满意了。如果不能，那么我们必须使用一些其他的高级技术，比如反向控制、多入口点来简化每个组件，并且更加倾向于可组合的API。</p><p id="9c33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一些其他的库或框架中，你可能需要一些其他的API，但是我们在这里讨论的想法是非常通用的，可以应用在其他类似的场景中。</p><p id="2600" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me">更多内容尽在</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="me">plain English . io</em></strong></a></p></div></div>    
</body>
</html>