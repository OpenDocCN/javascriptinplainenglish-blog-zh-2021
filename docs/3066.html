<html>
<head>
<title>An Entry-Level Guide to Memory Management in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript内存管理入门指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-memory-management-works-in-javascript-f07ccd544190?source=collection_archive---------3-----------------------#2021-06-22">https://javascript.plainenglish.io/how-memory-management-works-in-javascript-f07ccd544190?source=collection_archive---------3-----------------------#2021-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/351c0765853f489a73dc9314fc80de00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMNnCvYPPA_autabOLeiUQ.png"/></div></div></figure><p id="fb03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在过去的8年里，我一直在写JavaScript代码。通过这些年，我学到了很多关于JavaScript的知识，比如代码优化、代码可读性、跨浏览器功能、内存管理等等。</p><p id="8ac7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以前，我是一名初级开发人员。我在做我的工作，不用担心性能和内存。当我的高级开发人员在讨论像内存管理这样的事情时，我觉得他们好像在说某种外星语言。事情进行得很顺利，直到一个客户报告了一个关于页面冻结的问题。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/ac5cd846548a2a177fbe90aab3b7fc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ReWlmJAqaL1eILyNLiJbqQ.png"/></div></div></figure><p id="37d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一位客户报告了一个问题，当点击一个按钮，然后Chrome关闭该页面时，页面变得没有响应。我最初认为这可能是Chrome扩展的问题。因此，我在隐姓埋名模式下进行测试，但问题也在隐名模式下重现。</p><p id="472a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决这个问题后，我花了很多时间阅读和理解JavaScript及其编译器。</p><p id="a2a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我以中级或入门级JavaScript开发人员能够理解的方式写了这篇文章。如有疑问，欢迎留言评论；我将尝试回答这些问题。</p><h1 id="45ce" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内存泄漏</h1><p id="7da8" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">内存泄漏被描述为不需要的内存，但由于某种原因，它没有返回内存池。</p><p id="55b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript的设计方式是，一旦变量被使用，它会自动删除分配的内存，这个过程被称为垃圾收集。</p><p id="5fd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript编译器使用两种不同的垃圾收集器，一种是<strong class="jx io">主要垃圾收集器</strong>，另一种是<strong class="jx io">次要垃圾收集器</strong>。</p><p id="3e12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">信息:【https://v8.dev/blog/trash-talk T4】</p><p id="2e3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主垃圾收集器:主垃圾收集器从整个堆中收集垃圾。</p><p id="9de5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">未成年GC </strong>:未成年GC在年轻一代收集垃圾。</p><p id="38d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是次要和主要GC的单行定义。</p><p id="356a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我用简单的英语来解释这些。</p><h2 id="b2b2" class="mc kz in bd la md me dn le mf mg dp li kg mh mi lm kk mj mk lq ko ml mm lu mn bi translated">主要GC:</h2><p id="9fbf" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">主垃圾收集器是主要的垃圾收集器，它识别活的和死的对象，并删除它们死的对象。但是主GC是在主线程上运行的，所以如果GC被频繁调用，页面就会变得不负责任。</p><p id="a60d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">垃圾收集为什么会冻结页面？</strong></p><p id="f3c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Garage collector运行在主线程上，所以它会阻塞所有用户输入，从而使页面变得不负责任。</p><p id="0107" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧但是，</p><p id="dffc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么主线程会阻塞所有用户输入？</strong></p><p id="d331" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单的答案是事件循环。而对于长篇大论的回答，你需要看这个视频。对事件循环和JavaScript编译器的极好解释。</p><p id="dbef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:<a class="ae mb" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><h1 id="b0d7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提高应用程序内存管理的一般指南。</h1><p id="841c" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated"><strong class="jx io"> 1。全局变量</strong></p><p id="33c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">垃圾收集器从不收集全局变量的内存，所以在开始声明全局变量之前要三思。</p><p id="86b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但有时，我们会不小心引入一个全局变量。</p><p id="aaa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看这段代码</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="a0a7" class="mc kz in mp b gy mt mu l mv mw">function foo(arg) {<br/>  bar = "this is a hidden global variable";<br/>}</span></pre><p id="1c7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会注意到，bar没有定义，但是赋值了，所以这将成为一个全局变量。</p><p id="6477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们泄漏了一个字符串内存，你可能认为这不会造成大问题，但它会覆盖其他一些全局方法，导致另一个破坏。</p><p id="0a03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。<br/>永远引用</strong>永远做关心内存，说到对象和数据绑定。</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="c74f" class="mc kz in mp b gy mt mu l mv mw">function run(){<br/>  var domObjects = $(".myClass");<br/>  domObjects.click(function(){<br/>  domObjects.addClass(".myOtherClass");<br/>  });<br/>}</span></pre><p id="3e89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦函数被调用，JavaScript将移除分配的内存。但是在代码上面，GC没有办法收集“domObjects”的内存，因为它被绑定到事件监听器。如果要删除这些记忆，可以手动删除。</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="c01e" class="mc kz in mp b gy mt mu l mv mw">function run(){<br/> var domObjects = $(".myClass");<br/> domObjects.click(function(){<br/> if(domObjects){<br/>  domObjects.addClass(".myOtherClass");<br/>  domObjects = null;<br/> }<br/> });<br/>}</span></pre><p id="346d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。字符串串联</strong></p><p id="ca73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这听起来很奇怪，但是字符串连接需要额外的内存。所以避免字符串连接，而使用模板文字。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/dfe35dd121ee005cfa93e84e0f9236d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyhoxQqg_30AK1GZ3Gs6lg.png"/></div></div></figure><p id="30b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。避开新物体</strong></p><p id="cdc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">新的内存被分配给新的对象、数组等。尝试找到一种方法来减少这种情况。</p><p id="0697" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个jQuery的例子，</p><p id="d88f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当从不使用<code class="fe my mz na mp b">jQuery</code>时，它会增加堆中的内存，所以我们可以避免使用jQuery链接方法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1cde4be3b420e064b29d2db84d14572d.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*Hckfu5jid0GeXDod9cxBZA.png"/></div></figure><p id="6ed9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 6。JSON解析</strong></p><p id="bf55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您的应用程序在页面加载期间基于JSON呈现时，可以考虑使用JSON.stringify和JSON.parse来处理这些数据。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/9634783b56c1765338a1b9de488beed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*nxZURd6L4tRTnNOvs_EnCw.png"/></div></figure><p id="fad8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:<a class="ae mb" href="https://v8.dev/blog/cost-of-javascript-2019#json" rel="noopener ugc nofollow" target="_blank">https://v8.dev/blog/cost-of-javascript-2019#json</a></p><p id="f764" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 7。避免试抓</strong></p><p id="cab9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Try-catch比if检查分配更多的内存。但是对于大多数应用程序来说，试捕是必要的，如果你正确地分析，你可以把它们变成试捕。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8997b8362555f67f2fe17f9273fd9f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*WPt1KeaAR_e85KDsamudLA.png"/></div></figure><p id="0e81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请看看这一期，</p><p id="2027" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由node js环境中的try-catch引起的一个有趣的内存泄漏问题。您将获得一些关于尝试捕捉和内存泄漏的知识</p><p id="6327" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mb" href="https://github.com/nodejs/node/issues/35048" rel="noopener ugc nofollow" target="_blank">https://github.com/nodejs/node/issues/35048</a></p><p id="08ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 8。新窗口</strong></p><p id="aaa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在新窗口中工作时，请在窗口分离后取消设置引用变量。<br/>当关闭窗口时，只调用次要的GC，所以只清除几个内存块。</p><p id="0638" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想检查使用的JSHeap内存，请在控制台上输入以下代码。</p><pre class="ku kv kw kx gt mo mp mq mr aw ms bi"><span id="7a9d" class="mc kz in mp b gy mt mu l mv mw"><strong class="mp io">performance. memory.usedJSHeapSize</strong></span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/f69ada3f276cfc6d8141ebcc1a13bbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ixg_47qwCATt586HudgYqA.png"/></div></div></figure><p id="a422" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 9。回调</strong></p><p id="4176" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果事件回调的频率非常高，请考虑避免它。</p><p id="7d1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以卷轴为例。</p><p id="6cc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您将滚动事件绑定到窗口时，每当用户向下/向上滚动时，都会调用回调。但这里的问题是回调调用的频率非常高。可以避开那些使用去抖或者节流功能的。</p><p id="be5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一篇关于去抖和节流的优秀文章。</p><div class="nf ng gp gr nh ni"><a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">节流和去抖动的区别</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">前几天我把这些弄混了，有人纠正了我。所以我把它放在博客帖子的旧列表中，这里…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">css-tricks.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jt ni"/></div></div></a></div><p id="9530" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">感谢您的阅读！</strong>如果你喜欢这篇文章，可以考虑<a class="ae mb" href="https://twitter.com/NaveenDA_" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>，并与你的开发者朋友分享这篇文章。</p><p id="ad7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nx">更多内容尽在</em><a class="ae mb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>