<html>
<head>
<title>How to Get the Difference Between Two Arrays in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中得到两个数组的区别？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-the-difference-between-two-arrays-in-javascript-8fbdb2155bf0?source=collection_archive---------1-----------------------#2021-11-20">https://javascript.plainenglish.io/how-to-get-the-difference-between-two-arrays-in-javascript-8fbdb2155bf0?source=collection_archive---------1-----------------------#2021-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b2d5242439569bb20f55e5b9e1fbfd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gUckrO8U-onl2k0g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时候我们需要知道两个JavaScript数组的区别。</p><p id="8a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区别在于一个数组中的项目不在另一个数组中。</p><p id="db80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在JavaScript中获得两个数组之间的各种差异。</p><h1 id="90b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Intersection</code></h1><p id="17f5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">两个数组的交集是两个数组中都有的一组项。</p><p id="07cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到交集，我们可以使用<code class="fe lz ma mb mc b">filter</code>方法。</p><p id="595e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9b39" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = ['a', 'b'];<br/>const arr2 = ['a', 'b', 'c', 'd'];<br/>const intersection = arr1.filter(x =&gt; arr2.includes(x));<br/>console.log(intersection)</span></pre><p id="192a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来计算交叉路口。</p><p id="cd88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个阵列，<code class="fe lz ma mb mc b">arr1</code>和<code class="fe lz ma mb mc b">arr2</code>。</p><p id="3f6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过用回调函数调用<code class="fe lz ma mb mc b">arr1</code>上的<code class="fe lz ma mb mc b">filter</code>来计算<code class="fe lz ma mb mc b">intersection</code>，回调函数检查来自<code class="fe lz ma mb mc b">arr1</code>的项目<code class="fe lz ma mb mc b">x</code>是否也包含在<code class="fe lz ma mb mc b">arr2</code>中。</p><p id="b51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以切换第3行中的<code class="fe lz ma mb mc b">arr1</code>和<code class="fe lz ma mb mc b">arr2</code>，得到相同的结果。</p><p id="5a01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="af94" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = ['a', 'b'];<br/>const arr2 = ['a', 'b', 'c', 'd'];<br/>const intersection = arr2.filter(x =&gt; arr1.includes(x));<br/>console.log(intersection)</span></pre><p id="a4fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两种情况下，<code class="fe lz ma mb mc b">intersection</code>都是<code class="fe lz ma mb mc b">[“a”, “b”]</code>。</p><h1 id="9267" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">两个阵列之间的差异</strong></h1><p id="e2e5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">两个数组之间的区别在于一个数组中包含一个数组中可用但另一个数组中不可用的所有项目。</p><p id="d6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有像上面这样的<code class="fe lz ma mb mc b">arr1</code>和<code class="fe lz ma mb mc b">arr2</code>，我们可以通过编写以下内容从<code class="fe lz ma mb mc b">arr2</code>中获取不在<code class="fe lz ma mb mc b">arr1</code>中的所有项目:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="0f43" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = ['a', 'b'];<br/>const arr2 = ['a', 'b', 'c', 'd'];<br/>const intersection = arr2.filter(x =&gt; !arr1.includes(x));<br/>console.log(intersection)</span></pre><p id="8c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的只是改变<code class="fe lz ma mb mc b">filter</code>回调来检查<code class="fe lz ma mb mc b">arr2</code>中的项目<code class="fe lz ma mb mc b">x</code>是否包含在<code class="fe lz ma mb mc b">arr1</code>中。</p><p id="3db0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是，我们就把它放在<code class="fe lz ma mb mc b">intersection</code>数组中。</p><p id="43ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，<code class="fe lz ma mb mc b">intersection</code>就是<code class="fe lz ma mb mc b">[“c”, “d”]</code>。</p><h1 id="5175" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">两个阵列之间的对称差异</strong></h1><p id="9818" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">两个数组之间的对称差异是在其中一个数组中但不在两个数组中的项目集。</p><p id="cce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了计算对称差，我们可以写出:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="66a9" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = ['a', 'b', 'e'];<br/>const arr2 = ['a', 'b', 'c', 'd'];<br/>const symDiff = [...new Set([...arr1, ...arr2])].filter(x =&gt; (!arr1.includes(x) &amp;&amp; arr2.includes(x)) || (arr1.includes(x) &amp;&amp; !arr2.includes(x)))<br/>console.log(symDiff)</span></pre><p id="28b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将一个包含来自<code class="fe lz ma mb mc b">arr1</code>和<code class="fe lz ma mb mc b">arr2</code>的条目的数组传递给<code class="fe lz ma mb mc b">Set</code>构造函数，将所有数组项放入一个集合中。</p><p id="ab51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将从组合数组中移除任何重复的元素。</p><p id="4691" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们用外展操作符将集合转换回数组。</p><p id="f17f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用这个调用<code class="fe lz ma mb mc b">filter</code>:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="20ad" class="mq lc iq mc b gy mr ms l mt mu">(!arr1.includes(x) &amp;&amp; arr2.includes(x)) || (arr1.includes(x) &amp;&amp; !arr2.includes(x))</span></pre><p id="4a76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由回调函数返回，以获取仅在<code class="fe lz ma mb mc b">arr1</code>或仅在<code class="fe lz ma mb mc b">arr2</code>中的所有元素。</p><p id="9586" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe lz ma mb mc b">symDiff</code>应该是<code class="fe lz ma mb mc b">[“e”, “c”, “d”]</code>。</p><h1 id="cbac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1acb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用集合和数组方法计算数组之间的各种差异。</p><p id="926f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">说白了。在这里注册我们的</em> </a><a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mv">免费周报</em> </a> <em class="mv">。</em></p></div></div>    
</body>
</html>