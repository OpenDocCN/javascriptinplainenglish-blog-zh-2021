<html>
<head>
<title>Learn Selection Sort So Well That You’ll Be Able To Teach It To Others</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">把选择排序学得很好，这样你就能把它教给别人了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-selection-sort-so-well-that-youll-be-able-to-teach-it-to-others-1addd79072ac?source=collection_archive---------13-----------------------#2021-01-18">https://javascript.plainenglish.io/learn-selection-sort-so-well-that-youll-be-able-to-teach-it-to-others-1addd79072ac?source=collection_archive---------13-----------------------#2021-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/06cad9d1153a8aa3caff26536c2b20ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*u0rJ8J75vwtmaLPCT4w7yQ.png"/></div></figure><p id="4513" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<a class="ae kp" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>，<strong class="jt io">选择排序</strong>是一种<a class="ae kp" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">原地</a> <a class="ae kp" href="https://en.wikipedia.org/wiki/Comparison_sort" rel="noopener ugc nofollow" target="_blank">比较</a> <a class="ae kp" href="https://en.wikipedia.org/wiki/Sorting_algorithm" rel="noopener ugc nofollow" target="_blank">排序算法</a>。它有一个<a class="ae kp" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> O </a> ( <em class="kq"> n </em> 2) <a class="ae kp" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">的时间复杂度</a>，这使得它在大型列表上的效率很低，一般比类似的<a class="ae kp" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>的性能要差。选择排序以其简单性而著称，并且在某些情况下，特别是在<a class="ae kp" href="https://en.wikipedia.org/wiki/Auxiliary_memory" rel="noopener ugc nofollow" target="_blank">辅助存储器</a>有限的情况下，比更复杂的算法具有性能优势。</p><p id="6bd7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该算法将输入列表分为两个部分:在列表的前面(左侧)从左到右构建的已排序项目子列表，以及占据列表剩余部分的剩余未排序项目子列表。最初，排序的子列表是空的，未排序的子列表是整个输入列表。该算法通过在未排序的子列表中找到最小(或最大，取决于排序顺序)的元素，将其与最左边的未排序的元素交换(交换)(按排序顺序放置),并将子列表边界向右移动一个元素来进行。</p><p id="5941" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">选择排序的时间效率是二次的，因此有许多排序技术比选择排序具有更好的时间复杂度。选择排序区别于其他排序算法的一点是，它进行尽可能少的交换，在最坏的情况下，<em class="kq">n</em>-1。</p><p id="a02c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">与其他排序算法相比，选择排序并不难分析，因为没有一个循环依赖于数组中的数据。选择最小值需要扫描<strong class="jt io"> <em class="kq"> n </em> </strong>个元素(进行<strong class="jt io"> <em class="kq"> n-1 </em> </strong>比较)，然后将其交换到第一个位置。寻找下一个最低的元素需要扫描剩余的<strong class="jt io"> <em class="kq"> n-1 </em> </strong>元素等等。</p><h1 id="5e40" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">分步示例</h1><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="5212" class="ly ks in lu b gy lz ma l mb mc"><strong class="lu io"><em class="kq">First Pass</em></strong><br/>( <strong class="lu io">5</strong> <strong class="lu io">1</strong> 4 2 8 ) → ( <strong class="lu io">1</strong> <strong class="lu io">5</strong> 4 2 8 ), swaps since 5 &gt; 1<br/>( <strong class="lu io">1</strong> 5 <strong class="lu io">4</strong> 2 8 ) → ( <strong class="lu io">1</strong> 4 <strong class="lu io">5</strong> 2 8 )<br/>( <strong class="lu io">1</strong> 4 5 <strong class="lu io">2</strong> 8 ) → ( <strong class="lu io">1</strong> 4 5<strong class="lu io"> 2</strong> 8 )<br/>( <strong class="lu io">1</strong> 4 5<strong class="lu io"> </strong>2<strong class="lu io"> 8</strong> ) → ( <strong class="lu io">1</strong> 4 5<strong class="lu io"> </strong>2<strong class="lu io"> 8</strong> ), Now, since these elements are already in order (8 &gt; 1), algorithm does not swap them.</span><span id="6815" class="ly ks in lu b gy md ma l mb mc"><strong class="lu io"><em class="kq">Second Pass</em></strong><br/>( 1 <strong class="lu io">4</strong> 5<strong class="lu io"> </strong>2<strong class="lu io"> </strong>8 ) → ( 1 <strong class="lu io">4</strong> <strong class="lu io">5 </strong>2<strong class="lu io"> </strong>8 )<br/>( 1 <strong class="lu io">4</strong> 5<strong class="lu io"> 2 </strong>8 ) → ( 1 <strong class="lu io">2 </strong>5<strong class="lu io"> 4</strong> 8 ), Swap since 4 &gt; 2<br/>( 1 <strong class="lu io">2</strong> 5<strong class="lu io"> </strong>4<strong class="lu io"> 8</strong> ) → ( 1 <strong class="lu io">2</strong> 5<strong class="lu io"> </strong>4 <strong class="lu io">8</strong> )</span><span id="ca81" class="ly ks in lu b gy md ma l mb mc">Now, the array is already sorted, but the algorithm does not know if it is completed. The algorithm needs one <strong class="lu io">whole</strong> pass without <strong class="lu io">any</strong> swap to know it is sorted.</span><span id="f0e5" class="ly ks in lu b gy md ma l mb mc"><strong class="lu io">Third Pass</strong><br/>( 1 2 <strong class="lu io">5 4 </strong>8 ) → ( 1 2 <strong class="lu io">4 5 </strong>8 )<br/>( 1 2 <strong class="lu io">4 </strong>5 <strong class="lu io">8</strong> ) → ( 1 2 <strong class="lu io">4 </strong>5<strong class="lu io"> 8</strong> )</span></pre><h1 id="36e1" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">分步示例2</h1><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div class="gh gi me"><img src="../Images/e5b23dcf093bdff8f155407f83a543a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*VXbbuLbGCH5IoJxc59L-kw.png"/></div></figure><h1 id="3b7c" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">分步编码示例</h1><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/0529fea6f2d1fad8e18a443ca23482b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RlJzBvtOyc7uOsWc_EwpCg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Step 1</figcaption></figure><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mo"><img src="../Images/b7416d4fe72d7c3e17c9e59499098452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcrkoR9gliZhVQnii9ehfA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Step 2</figcaption></figure><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mp"><img src="../Images/59e8a51138285748af0654516e9ce728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-FDXSbaiypUhqBEdhoj_g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Step 3</figcaption></figure><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/ecaed2adf127e9dd38893755bf0528a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Z_E0P3heiS3mA2p3lD9Mw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Step 4</figcaption></figure><h1 id="1673" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">表演</h1><p id="3685" class="pw-post-body-paragraph jr js in jt b ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">像冒泡排序一样，由于嵌套循环，选择排序的最坏情况和平均复杂度为O(n)。这意味着它的效率随着元素数量的增加而急剧下降</p><p id="b757" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">虽然就写入次数而言，选择排序优于插入排序(θ(<em class="kq">n</em>)交换相对于ο(<em class="kq">n</em>)交换)，但它几乎总是远远超过(且从未超过)循环排序的写入次数，因为循环排序在写入次数方面理论上是最佳的。如果写入比读取成本高得多，这可能很重要，例如使用<a class="ae kp" href="https://en.wikipedia.org/wiki/EEPROM" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io">电可擦除可编程只读存储器</strong> </a>或<a class="ae kp" href="https://en.wikipedia.org/wiki/Flash_memory" rel="noopener ugc nofollow" target="_blank">闪存</a>，其中每次写入都会缩短存储器的寿命。</p><p id="226e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，在更大的数组上，选择排序大大优于θ(<em class="kq">n</em>log<em class="kq">n</em>)<a class="ae kp" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分治算法</a>，例如<a class="ae kp" href="https://en.wikipedia.org/wiki/Mergesort" rel="noopener ugc nofollow" target="_blank"> merge-sort </a>。但是，插入排序或选择排序对于小数组(即少于10–20个元素)通常都更快。在实践中，递归算法的一个有用的优化是对于“足够小”的子列表切换到插入排序或选择排序。</p><h1 id="95b0" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">奖金</h1><p id="b6cc" class="pw-post-body-paragraph jr js in jt b ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated"><strong class="jt io">选择排序</strong>能够<strong class="jt io">擅长</strong>检查一切是否已经<strong class="jt io">排序</strong>。在内存空间有限的情况下，使用它也很好。这是因为与其他<strong class="jt io">排序</strong>算法不同的是，<strong class="jt io">选择排序</strong>直到最后才开始交换数据，因此使用的临时存储空间更少。</p><h1 id="d218" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">包扎</h1><p id="06e5" class="pw-post-body-paragraph jr js in jt b ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ig bi translated">考虑到所有的事情，选择排序仍然是一个有趣的算法，可能会在编码挑战中出现。或者，您可能会得到一个选择排序函数，并被问及Big-O符号是什么以及为什么。希望本文中的例子能够帮助您准备好应对这两种情况。</p><p id="8530" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我希望你有一个美好的一天，感谢你花时间阅读这篇文章。</p><p id="6269" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我希望你有一个美好的一天，感谢你花时间阅读这篇文章。</p></div></div>    
</body>
</html>