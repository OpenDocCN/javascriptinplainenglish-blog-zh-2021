<html>
<head>
<title>How to Use React Fragments and Why You Should</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React片段以及为什么应该使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-react-fragments-and-why-you-should-d71a74f61a09?source=collection_archive---------13-----------------------#2021-11-15">https://javascript.plainenglish.io/how-to-use-react-fragments-and-why-you-should-d71a74f61a09?source=collection_archive---------13-----------------------#2021-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/54ccaf31efe0f96676ccc6294b1aeaaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1AGDioprvxQu6Hn-.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">How to use React fragments and why you should!</figcaption></figure><blockquote class="jz ka kb"><p id="72ca" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">React和React Native使用了视图在视图之上的简单思想，这就是React片段非常重要的原因。</p></blockquote><h1 id="49e7" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">好吧，在我们继续深入之前，你可能已经面临了<strong class="ak">臭名昭著的</strong>(是的，<strong class="ak">臭名昭著的</strong>)错误警告— <strong class="ak">相邻的JSX元素必须用封闭标签</strong>包裹起来。这就是React碎片派上用场的地方。</h1><p id="bf30" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">但是为什么会出现这个错误，React片段如何帮助您以有效的方式解决这个问题呢？嗯，<strong class="kf io"> React render方法期望返回单个节点元素</strong>。</p><p id="0b91" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">嗯，你可能有过<strong class="kf io">绝妙的</strong>想法，简单地将所有相邻的JSX元素包装在一个div或另一个包装器中并返回它们，但是这真的是最好的选择吗？嗯，老实说没有<strong class="kf io"> <em class="ke">但是</em>有效</strong>，你可能会说，嗯，有效，<em class="ke">但是</em>还可以更好。</p><p id="d42c" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">那么，为什么简单地将任何相邻的JSX元素包装在div或类似的HTML元素中不是一个好主意呢？嗯，它们<strong class="kf io">增加了UI </strong>的额外开销。是的，在HTML上添加任何嵌套级别都意味着要花费额外的时间来呈现嵌套的UI。</p><h2 id="1304" class="mh lc in bd ld mi mj dn lh mk ml dp ll mb mm mn lp md mo mp lt mf mq mr lx ms bi translated">为什么避免额外的嵌套</h2><p id="0492" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">为了了解这种无意的嵌套是如何成为一个问题的，我们先来讨论一下React本机片段。如果你曾经在Android上工作过，你可能会发现嵌套是非常不鼓励的，因为它会降低渲染UI的总时间。因此，<strong class="kf io">安卓</strong>提倡<strong class="kf io">扁平的用户界面层次</strong>，而不是<strong class="kf io">高度嵌套的层次</strong>。</p><p id="da64" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">一般来说，根据经验，最好在DOM树中尽可能少地嵌套。</p><p id="486a" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">现在，让我们回到反应原生组件。当您的React原生应用程序构建完成后，您的组件，无论是<strong class="kf io">核心还是原生</strong>，都将被转换到选择的目标平台中(在我们的例子中，我们使用<strong class="kf io"> Android </strong>)。</p><p id="39ef" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">现在，我们回到那些额外的<strong class="kf io">div</strong>上来，这些div是你出于好心，为了修正我们之前提到的错误而无意添加的。</p><p id="8c03" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">当<strong class="kf io">div</strong>被转换成<strong class="kf io"> Android原生视图</strong>时，它们类似于<strong class="kf io">视图组</strong>是什么。所以，现在你知道这是怎么回事了。你会有一个<strong class="kf io">工作但UI昂贵的代码</strong>带在身边。所有的<strong class="kf io">div</strong>都将被转换成<strong class="kf io">视图组</strong>！你会问，如何解决这个问题？</p><h2 id="31ed" class="mh lc in bd ld mi mj dn lh mk ml dp ll mb mm mn lp md mo mp lt mf mq mr lx ms bi translated">你还在这里！</h2><p id="8442" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">那么，如何解决嵌套问题呢？嗯，<strong class="kf io">输入React片段</strong>！React片段是UI包装器，它使得封装相邻的JSX元素成为可能，就像divs，<strong class="kf io">一样，但是它的额外好处是没有向UI添加节点</strong>！</p><p id="0de1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">好了，说了这么多，可以说这个话题已经结束了，但是，还没有，当使用React片段或React本机片段时，你需要知道一些事情，这取决于你正在构建什么。</p><h2 id="732f" class="mh lc in bd ld mi mj dn lh mk ml dp ll mb mm mn lp md mo mp lt mf mq mr lx ms bi translated">如何使用React片段</h2><p id="2df1" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">让我们看看这段代码:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="61a2" class="mh lc in my b gy nc nd l ne nf">function aLetterToParentDiv() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;div&gt;Div, You are awesome&lt;/div&gt;<br/>            &lt;div&gt;Always remember that!&lt;/div&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="c3f6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">嗯，这是对<strong class="kf io"> parentDiv </strong>这些年来为你的代码所做的工作的一种感谢。</p><p id="b924" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">然而，使用<strong class="kf io"> React fragments </strong>我们有两种方法来实现这一点。</p><p id="268f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">第一种方法是反应片段较短的方法，我们有:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2207" class="mh lc in my b gy nc nd l ne nf">function aLetterToShorterParentFragment() {<br/>    return (<br/>        &lt;&gt;<br/>            &lt;span&gt;ShorterParentFragment, You are awesome&lt;/span&gt;<br/>            &lt;span&gt;But additional support is needed!&lt;/span&gt;<br/>        &lt;&gt;<br/>    )<br/>}</span></pre><p id="de85" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">还有一种更长的方法:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8605" class="mh lc in my b gy nc nd l ne nf">function aLetterToLongerParentFragment(itemId) {<br/>    return (<br/>        &lt;React.Fragment&gt;</span><span id="5e44" class="mh lc in my b gy ng nd l ne nf">            &lt;span&gt;ShorterParentFragment, You are awesome&lt;/span&gt;<br/>            &lt;span&gt;But additional support is needed!&lt;/span&gt; </span><span id="0ae4" class="mh lc in my b gy ng nd l ne nf">        &lt;/React.Fragment&gt;</span><span id="6b41" class="mh lc in my b gy ng nd l ne nf">    )<br/>}</span></pre><p id="54c6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">嗯，较短的方法和较长的方法基本上服务于消除<strong class="kf io">div</strong>的相同目的，但是较长的方法<strong class="kf io">起作用。片段</strong>更好，因为它支持<strong class="kf io"> keys属性</strong>，这是最重要的React和React本地组件属性之一！</p><h2 id="f14f" class="mh lc in bd ld mi mj dn lh mk ml dp ll mb mm mn lp md mo mp lt mf mq mr lx ms bi translated">关键外卖！</h2><p id="18a6" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">好了，这就结束了对React片段的简短介绍，也应该适用于React本地片段。</p><p id="48dc" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">所以永远记住:</p><ul class=""><li id="a6bf" class="nh ni in kf b kg kh kk kl mb nj md nk mf nl la nm nn no np bi translated">Div(以及封装相邻元素的类似方式)向DOM树添加了额外的和不必要的节点。这在React native中将是一项昂贵的任务。</li><li id="9903" class="nh ni in kf b kg nq kk nr mb ns md nt mf nu la nm nn no np bi translated">反应片段是封闭相邻JSX元素的更好方法。</li><li id="44bc" class="nh ni in kf b kg nq kk nr mb ns md nt mf nu la nm nn no np bi translated">较长的方法比较短的方法好，因为它支持keys属性。</li></ul><h2 id="bc94" class="mh lc in bd ld mi mj dn lh mk ml dp ll mb mm mn lp md mo mp lt mf mq mr lx ms bi translated">结论</h2><p id="750a" class="pw-post-body-paragraph kc kd in kf b kg lz ki kj kk ma km kn mb mc kq kr md me ku kv mf mg ky kz la ig bi translated">好了，这就是这篇文章的内容。</p><p id="6045" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated">直到下一个！</p><p id="51c1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated"><strong class="kf io"> <em class="ke">快乐编码！</em> </strong></p><blockquote class="jz ka kb"><p id="ffe2" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">你有兴趣学习<strong class="kf io">反应</strong>吗？类似牛逼的文章在这里结账:<a class="ae nv" href="https://bingeoncode.com/article/react/How%20to%20use%20react%20fragments%20and%20why%20you%20should%21#related-articles" rel="noopener ugc nofollow" target="_blank">相关文章</a></p></blockquote><p id="ec58" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mb kp kq kr md kt ku kv mf kx ky kz la ig bi translated"><em class="ke">更多内容请看</em><a class="ae nv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="ke">plain English . io</em></strong></a></p></div></div>    
</body>
</html>