<html>
<head>
<title>Rethinking State Machines in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中状态机的再思考</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rethinking-state-machines-in-react-8c34fc8e2170?source=collection_archive---------11-----------------------#2021-02-13">https://javascript.plainenglish.io/rethinking-state-machines-in-react-8c34fc8e2170?source=collection_archive---------11-----------------------#2021-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/81185b08b6a739866f85fa8387a780cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nrLrlKFBZf4lkIJ0SKWIw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Illustration Credit: <a class="ae jz" href="https://careerfoundry.com/en/blog/ux-design/what-are-user-flows/" rel="noopener ugc nofollow" target="_blank">Careerfoundry</a></figcaption></figure><p id="d066" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为状态机非常适合前端开发，一年多来，它们一直是我工具箱的一部分。有很多很好的FSM实现，比如<a class="ae jz" href="https://github.com/davidkpiano/xstate" rel="noopener ugc nofollow" target="_blank"> xstate </a>和<a class="ae jz" href="https://thisrobot.life/" rel="noopener ugc nofollow" target="_blank"> Robot </a>，它们可以很好地与React应用一起工作，使得复杂的用户流更容易实现。然而，最近我对将它们引入工作流变得更加犹豫，没有足够有力的理由，因为它们似乎用额外的样板文件膨胀了代码，并经常干扰我对接口的推理方式以及它们在用户与应用程序存储/状态的交互中所起的作用。</p><h2 id="778b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">1.错误并不总是全局状态</h2><p id="5eac" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我发现越来越多的问题是，上述实现中失败的转换会迫使您改变整个机器的状态或上下文。当我们考虑用户界面和用户交互时，一个可纠正的错误不应该导致整个机器进入失败状态。从状态A调用转换的组件应该能够报告发生了错误，并列举可以采取的纠正问题的步骤，而不需要整个应用程序在新的失败状态下重新呈现。想象一下服务器端验证阻止了某个更新的发生，但这并不意味着转换是完全不可能的。</p><p id="6b14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转换是将机器从状态A转换到状态b所需的一系列操作。如果任何操作失败，那么机器可能会保持在相同的状态A，而不会被迫转换到状态c。</p><p id="6b38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用转换的组件知道如何处理错误:它可以选择向用户弹出一条消息，改变它的行为或者将机器转换到不同的状态。在机器内部处理错误会导致失败的去上下文化——无论是改变机器状态还是在机器上下文中存储错误都无法帮助用户在他们正在执行的操作的上下文中处理错误。</p><h2 id="0f5a" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak"> 2。未决转换不应需要中间状态</strong></h2><p id="538c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">与错误类似，正在进行的转换不应该要求状态机改变其状态。挂起的转换要么成功导致新的状态和上下文变化，要么未能将机器保持在具有相同上下文的相同状态，以防止不必要的重新呈现和大量样板文件来说明UI中的加载状态。</p><p id="e7f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正在进行的过渡是一种承诺，它应该与悬念和其他异步策略一起很好地工作，以向用户提供反馈。当点击一个按钮开始一个转换时，你想简单地在按钮上显示一个微调器，而不是重新呈现一个新的加载状态，它的框架既不匹配上一个屏幕也不匹配下一个屏幕。</p><h2 id="bf1e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">3.状态管理不应该成为瓶颈</h2><p id="eefe" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">React钩子已经提供了高效状态管理和反应所需的一切。使用发布/订阅与React组件之外创建的机器进行通信会创建一个新的存储层，需要保持同步。如果您已经在使用状态管理库a-la反冲，那么您会感到有点头疼，维护多个不兼容的存储机制。</p><p id="ea56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当每个承诺都被当作可以影响整个机器状态的子机时，将本地状态与服务器同步也变得越来越困难。</p><h2 id="cd10" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">用本土的解决方案解决问题</h2><p id="5751" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">所以，我一直在考虑这些问题和想法，并提出了一个精简的状态机实现，没有数学状态机的所有复杂性。让我带你走一遍。</p><p id="4ea0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们假设我们想要构建一个允许我们向服务器发送消息的应用程序，但是每当我们做出更改时，都会在本地存储中保留一个草稿。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6b3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以这样理解:当在<code class="fe mc md me mf b">writing</code>状态下执行<code class="fe mc md me mf b">send</code>转换时，调用一系列处理程序，如果都成功，则传播目标状态和上下文。</p><p id="7330" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，每个处理程序将接收状态机上下文和有效负载作为参数。</p><p id="1317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个上下文，作为我们机器的真实来源。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0b40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们创建一个钩子工厂，它将允许我们根据它的名字创建一个转换处理程序。在这个例子中，我使用了<code class="fe mc md me mf b">react-async-hook</code>，但是你可以把它换成你现有应用中已经使用的任何实现。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="dbe7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们正在创建一个异步处理程序，它将链接我们为转换定义的所有处理程序。在所有处理程序都成功解析之前，状态机上下文不会发生变化。<code class="fe mc md me mf b">useAsyncCallback</code>的结果是一个对象<code class="fe mc md me mf b">{ execute, error, loading, result }</code>。因此，我们可以使用特定的有效负载调用转换处理程序，并对调用它的组件中的错误/加载状态做出反应。</p><p id="2cae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们稍微修饰一下我们的状态，以便于访问。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="af35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以很容易地访问机器的上下文和状态，使用树中任何组件的一些帮助函数。</p><p id="bb6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们也创建一些助手组件。<code class="fe mc md me mf b">&lt;Transition&gt;</code>可用于通过JSX过渡机器(类似于react路由器的<code class="fe mc md me mf b">&lt;Redirect&gt;</code>)。并且<code class="fe mc md me mf b">&lt;State&gt;</code>将允许我们检查当前状态来决定我们是否应该渲染组件。这将消除我们JSX中的条件句。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2e3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们构建我们的应用程序。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1988" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mc md me mf b">&lt;ComposerView&gt;</code>将是一个受控组件，用机器状态作为真理的来源。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="170e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后是显示已发送消息的<code class="fe mc md me mf b">&lt;MessageView&gt;</code>。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="1ee0" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="3ced" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">就是这样。我们现在有了一个基本的状态机，它执行转换时不需要中间状态改变或上下文突变。你可以用定制的钩子来扩展这一点，比如推送或者替换浏览器状态。您还可以轻松地将它与任何其他React库和钩子系统集成在一起。您还可以在处理程序中使用钩子，例如访问当前用户的JWT，以避免无休止地将机器上下文与执行转换所需的所有数据同步。</p><p id="b3df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">期待大家的评论。</p></div></div>    
</body>
</html>