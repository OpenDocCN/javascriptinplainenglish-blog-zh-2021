<html>
<head>
<title>How to Create a Custom Layer Component in React-Leaflet v3 with Leaflet.Ellipse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React-leaf v3中用传单创建自定义图层组件？椭圆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-an-ellipse-in-react-leaflet-72e2c5beff03?source=collection_archive---------3-----------------------#2021-04-23">https://javascript.plainenglish.io/creating-an-ellipse-in-react-leaflet-72e2c5beff03?source=collection_archive---------3-----------------------#2021-04-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9132fee7578d9762cb922ab2a6c22e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u_xlvRx9F7wxuwgU"/></div></div></figure><p id="cfe2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在地图应用程序中使用<a class="ae kt" href="https://react-leaflet.js.org/" rel="noopener ugc nofollow" target="_blank"> React-Leaflet </a>，可能会有需要在地图上以<a class="ae kt" href="http://wiki.gis.com/wiki/index.php/Ellipse" rel="noopener ugc nofollow" target="_blank">椭圆</a>的形式显示数据的时候。<a class="ae kt" href="https://leafletjs.com/index.html" rel="noopener ugc nofollow" target="_blank"> Leaflet </a>默认不提供椭圆标记，这意味着React-Leaflet也不提供。</p><p id="f491" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="https://leafletjs.com/reference-1.7.1.html" rel="noopener ugc nofollow" target="_blank">传单文档</a>的<a class="ae kt" href="https://leafletjs.com/plugins.html" rel="noopener ugc nofollow" target="_blank">传单插件章节</a>中，有一个插件叫做<a class="ae kt" href="https://github.com/jdfergason/Leaflet.Ellipse#leafletellipse" rel="noopener ugc nofollow" target="_blank">传单。椭圆</a>允许用户在普通传单应用程序中创建一个椭圆。但是，如何让这个插件与他们的React-Leaflet应用程序一起工作呢？答案是使用<a class="ae kt" href="https://react-leaflet.js.org/docs/core-introduction" rel="noopener ugc nofollow" target="_blank"> React小叶核心API </a>。</p><p id="6a77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">核心API的目的是使React-Leaflet的内部逻辑可用，以便像我们这样的开发人员可以实现我们自己的自定义行为和第三方插件。为了更好地理解这个API是如何工作的，让我们通过创建我们自己的椭圆组件来扩展<code class="fe ku kv kw kx b">Leaflet.Ellipse</code>以使用React-Leaflet。</p><p id="db3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让事情变得简单，我在Stack Blitz<a class="ae kt" href="https://stackblitz.com/edit/devto-react-leaflet-ellipse?file=src/components/Map.jsx" rel="noopener ugc nofollow" target="_blank">上创建了一个React-Leaflet模板，这样你就不用担心设置问题了。如果你想在你的本地机器上编码，你可以按照React-leaf</a><a class="ae kt" href="https://react-leaflet.js.org/docs/start-introduction" rel="noopener ugc nofollow" target="_blank">入门指南</a>开始。当你安装React-Leaflet时，也要安装<code class="fe ku kv kw kx b">@react-leaflet/core</code>。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="8c8b" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">简单实现</h2><p id="4207" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">现在，让我们把注意力集中在地图上的椭圆上。让我们在组件目录中创建一个名为<code class="fe ku kv kw kx b">Ellipse.jsx</code>的新文件:</p><h2 id="3a95" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">Ellipse.jsx</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们使用来自核心API的<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api#useleafletcontext" rel="noopener ugc nofollow" target="_blank">useLeafletContext</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api#useleafletcontext" rel="noopener ugc nofollow" target="_blank">钩子</a>来访问由<code class="fe ku kv kw kx b">Map.jsx</code>中的<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">MapContainer</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/api-map#mapcontainer" rel="noopener ugc nofollow" target="_blank">组件</a>创建的上下文。我们还将从props中析构必要的数据位:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/ff01544c63804a1bdd6ff06fc6bfe248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-be3TRKM6Qh2eIVg3o7oQQ.png"/></div></div></figure><p id="dc45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们使用<a class="ae kt" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React的</a> <code class="fe ku kv kw kx b"><a class="ae kt" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code> <a class="ae kt" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">钩子</a>来创建<code class="fe ku kv kw kx b">L.Ellipse</code>实例，方法是将以下内容传递给<code class="fe ku kv kw kx b">Ellipse</code> <a class="ae kt" href="https://github.com/jdfergason/Leaflet.Ellipse#api" rel="noopener ugc nofollow" target="_blank">构造函数</a>:</p><ul class=""><li id="e0ed" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated"><strong class="jx io">中心</strong> —椭圆[lat，lng]中心的位置。</li><li id="9f7b" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><strong class="jx io">半径</strong> —长半轴和短半轴，单位为米</li><li id="e2a6" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><strong class="jx io">倾斜</strong> —椭圆从西方以度为单位的旋转</li><li id="6281" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><strong class="jx io">选项</strong> —传递给L.Path的选项字典</li></ul><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/88080435f5035039558c4bf1050e14fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HKCj3_nBUXg63O81frkSQ.png"/></div></div></figure><p id="6228" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经设置了ellipse实例，就需要将该层添加到通过上下文提供给我们的容器中。这将是一个父容器，如<a class="ae kt" href="https://react-leaflet.js.org/docs/api-components#layergroup" rel="noopener ugc nofollow" target="_blank">图层组</a>或地图实例:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/a1c30a030279e020651a6a0ed78039c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIyWhqCknhnL7amNANa_AQ.png"/></div></div></figure><p id="e32c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe ku kv kw kx b">useEffect</code>钩子的末尾，我们将返回一个<a class="ae kt" href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" rel="noopener ugc nofollow" target="_blank">清理函数</a>，它将把我们的椭圆从它的父容器中移除:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/a3a3f53c99a5f773560ec27d737cc0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsnm1ATg7RBNGU2vdZEUDg.png"/></div></div></figure><p id="3006" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我们是如何在组件末尾返回一个<code class="fe ku kv kw kx b">null</code>值的。从一个组件返回<code class="fe ku kv kw kx b">null</code>只是意味着React将评估我们的组件，而不是呈现任何东西。通常，我们需要从组件中返回一个有效的React节点，但是因为need将执行渲染，所以我们只返回一个<code class="fe ku kv kw kx b">null</code>值。我们现在可以将我们的<code class="fe ku kv kw kx b">Ellipse</code>组件导入到我们的<code class="fe ku kv kw kx b">Map</code>组件，并通过我们的城市数据将<code class="fe ku kv kw kx b">.map</code>导入到我们的省略号中:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="2dcf" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">改进更新逻辑</h2><p id="3a69" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">到目前为止，我们构建的<code class="fe ku kv kw kx b">Ellipse</code>组件在大多数简单的情况下都能很好地工作，但是有一个问题。随着组件的每一次渲染，<code class="fe ku kv kw kx b">useEffect</code>回调函数将会运行，并在地图上添加/移除椭圆，即使道具没有改变。当使用React时，这不是预期的行为，因为虚拟DOM检查哪些更新是应用于DOM所必需的。因为我们使用React-Leaflet，所以<a class="ae kt" href="https://react-leaflet.js.org/docs/start-introduction/#core-concepts" rel="noopener ugc nofollow" target="_blank"> DOM渲染由Leaflet </a>执行，所以我们需要改进我们的更新逻辑，以避免对DOM进行不必要的更改:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7ce5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们通过使用<a class="ae kt" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> React的</a> <code class="fe ku kv kw kx b"><a class="ae kt" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code> <a class="ae kt" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">钩子</a>来创建对我们的传单椭圆实例及其道具的引用:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/c057375d58c0ea10ed99c3433b651b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daD20ITYFXqEs9IBJOgSyA.png"/></div></div></figure><p id="b32b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将把椭圆创建逻辑和更新逻辑分开，把它们放在单独的<code class="fe ku kv kw kx b">useEffect</code>回调中。我们希望第一个<code class="fe ku kv kw kx b">useEffect</code>回调只在安装和卸载椭圆组件时运行，所以我们将依赖数组设置为空数组:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/6fa56938190a982e9bbced1baa17de56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9JNpE_sdAAekvs3zecpxQ.png"/></div></div></figure><p id="984d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当道具的数据发生变化时，我们会调用第二个<code class="fe ku kv kw kx b">useEffect</code>，这样小叶就可以有条件地对我们的椭圆层进行任何更新。这意味着我们只需将我们从道具中破坏的数据传递给第二个<code class="fe ku kv kw kx b">useEffect</code>的依赖数组。我们可以通过查看从第63行开始的<code class="fe ku kv kw kx b"><a class="ae kt" href="https://github.com/jdfergason/Leaflet.Ellipse/blob/master/l.ellipse.js" rel="noopener ugc nofollow" target="_blank">Leaflet.Ellipse</a></code> <a class="ae kt" href="https://github.com/jdfergason/Leaflet.Ellipse/blob/master/l.ellipse.js" rel="noopener ugc nofollow" target="_blank">源文件</a>，找到需要调用什么方法来更新我们的椭圆:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/157b0a77324ddea6f70bb9c9a52e6a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoXhKgfwJ9W1I1Xm0nKXqw.png"/></div></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="8bbc" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">元素挂钩厂</h2><p id="858c" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">到目前为止，我们已经为我们的reactor-小叶应用程序提供了一个功能齐全的<code class="fe ku kv kw kx b">Ellipse</code>组件，但是Core API提供了类似于<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createelementhook" rel="noopener ugc nofollow" target="_blank">createElementHook</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createelementhook" rel="noopener ugc nofollow" target="_blank">工厂</a>的功能，以使过程变得更简单，并删除一些重复的代码:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与其将我们的创建和更新逻辑保存在<code class="fe ku kv kw kx b">useEffect</code>回调中，不如将它们提取到实现 <code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createelementhook" rel="noopener ugc nofollow" target="_blank">createElementHook</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createelementhook" rel="noopener ugc nofollow" target="_blank">函数</a>所期望的<a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createelementhook" rel="noopener ugc nofollow" target="_blank">接口的独立函数中:</a></p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/323e8641fc708dd7d426bf4dffe05daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHZkaHhQUqR76mLZ8xD56w.png"/></div></div></figure><p id="d9ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们将这些创建和更新函数传递给<code class="fe ku kv kw kx b">createElementHook</code>工厂函数:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/f7d1c9cbc405f7426129969d5698af2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7QXk_e6T-cpABcaE4WlIw.png"/></div></div></figure><p id="b137" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个钩子跟踪椭圆元素的实例和道具，这意味着我们只需要一个<code class="fe ku kv kw kx b">useEffect</code>钩子就可以在地图上添加/移除椭圆图层:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/84da74af71367055790c10cc30f3fa04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgzsTYTEp8DlaiNEQJJObA.png"/></div></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="6443" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">层生命周期挂钩</h2><p id="ca85" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">核心API提供了用于处理特定逻辑的钩子，比如<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#uselayerlifecycle" rel="noopener ugc nofollow" target="_blank">useLayerLifecycle</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#uselayerlifecycle" rel="noopener ugc nofollow" target="_blank">钩子</a>。此挂钩的全部目的是在父容器或地图中添加和移除指定的图层。让我们使用它并去掉当前处理添加/删除逻辑的<code class="fe ku kv kw kx b">useEffect</code>钩子:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="3db1" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">更高级别的createPathHook</h2><p id="31f4" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我们还可以通过核心API访问更高级别的工厂功能。这些更高级的工厂函数，像<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createpathhook" rel="noopener ugc nofollow" target="_blank">createPathHook</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createpathhook" rel="noopener ugc nofollow" target="_blank">函数</a>，实现了由不同钩子共享的逻辑。如果我们想进一步简化我们的<code class="fe ku kv kw kx b">Ellipse</code>组件，我们可以去掉<code class="fe ku kv kw kx b">useLeafletContext</code>和<code class="fe ku kv kw kx b">useLayerLifecycle</code>函数，只需在椭圆组件内调用我们用<code class="fe ku kv kw kx b">createPathHook</code>创建的钩子:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="19aa" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">组件工厂</h2><p id="d9e2" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">现在，我们的<code class="fe ku kv kw kx b">Ellipse</code>组件的所有逻辑都在我们创建的<code class="fe ku kv kw kx b">useEllipse</code>钩子中实现了，组件变得非常简单。我们实际上可以使用我们的功能组件，并用<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createleafcomponent" rel="noopener ugc nofollow" target="_blank">createLeafComponent</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createleafcomponent" rel="noopener ugc nofollow" target="_blank">函数</a>来替换它，这也允许我们现在通过以下方式访问我们的<code class="fe ku kv kw kx b">Ellipse</code>实例:</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="aa96" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">支持子元素</h2><p id="b182" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我们的<code class="fe ku kv kw kx b">Ellipse</code>组件工作得很好，我们所有的逻辑只用几行代码就实现了。我们的ellipse现在的问题是，它还不支持儿童，而这是React-leaf组件的一个相当常见的要求。由于我们的<code class="fe ku kv kw kx b">Ellipse</code>是一个传单层，我们可以在<code class="fe ku kv kw kx b">Ellipse</code>上附加弹出窗口和工具提示之类的覆盖层:</p><h2 id="ce8e" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">Ellipse.jsx</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h2 id="ffd1" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">Map.jsx</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f074" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了支持这些覆盖，我们需要在我们的<code class="fe ku kv kw kx b">createEllipse</code>函数中将创建的层设置为上下文的<code class="fe ku kv kw kx b">overlayContainer</code>。记住，从<code class="fe ku kv kw kx b">createEllipse</code>函数<strong class="jx io">返回的上下文对象必须是函数参数</strong>中提供的上下文对象的副本，并且函数<strong class="jx io">不能改变所提供的上下文</strong>:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/eec1c612e49d2d0bd07ba2f0f5f41dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXZ_6R8MgEXrQ7KJHWFWRg.png"/></div></div></figure><p id="9d2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们用<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createcontainercomponent" rel="noopener ugc nofollow" target="_blank">createContainerComponent</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createcontainercomponent" rel="noopener ugc nofollow" target="_blank">工厂函数</a>替换组件工厂。<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createleafcomponent" rel="noopener ugc nofollow" target="_blank">createLeafComponent</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createleafcomponent" rel="noopener ugc nofollow" target="_blank">功能</a>和<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createoverlaycomponent" rel="noopener ugc nofollow" target="_blank">createOverlayComponent</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createoverlaycomponent" rel="noopener ugc nofollow" target="_blank">功能</a>也可用于创建覆盖图，如弹出窗口和工具提示:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/a2efb0b97ff7b3dd157301892b4e4f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIgVn6KrsmzRSY9l0K_UkQ.png"/></div></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="44f2" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">更高级别的部件工厂</h2><p id="bfa3" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">React Leaflet的核心API提供了React组件，用于处理创建传单元素并与之交互的逻辑。API公开的这些不同的钩子和工厂实现了各种逻辑，需要组合这些逻辑来创建组件。在某些情况下，相同系列的功能用于创建不同的组件。看看我们用来创建椭圆的函数:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/8fa40a2eb1513177613b538e1feeee47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JReWAmsGyJDXEApTwwFxyQ.png"/></div></div></figure><p id="fc0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用这些函数来创建许多不同类型的层，因此React-Leaflet提供了更高级别的组件工厂，像<code class="fe ku kv kw kx b"><a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createpathcomponent" rel="noopener ugc nofollow" target="_blank">createPathComponent</a></code> <a class="ae kt" href="https://react-leaflet.js.org/docs/core-api/#createpathcomponent" rel="noopener ugc nofollow" target="_blank">函数</a>，它结合了所有三者的逻辑。我们可以删除上面的函数，并将创建和更新函数直接传递给<code class="fe ku kv kw kx b">createPathComponent</code>工厂，就像这样:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/1dbc83d10c55e6a0a05607ea796a17fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kd7ptMCK4PGViB6LQBx6Lw.png"/></div></div></figure><h2 id="9fd7" class="lf lg in bd lh li lj dn lk ll lm dp ln kg lo lp lq kk lr ls lt ko lu lv lw lx bi translated">Ellipse.jsx</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="de74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的<code class="fe ku kv kw kx b">Ellipse</code>组件现在完成了！我们只用了几行代码就完成了，多亏了React-Leaflet核心API，我们有了一个完全交互式的传单层。关于核心API，我们已经讨论了很多，但是还有很多。</p><p id="93af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我鼓励您尝试创建自己的自定义React-Leaflet元素，或者扩展第三方传单插件以在React-Leaflet应用程序中工作。如果你这样做了，写下你的博客并分享你的链接来帮助其他开发者！</p><p id="1f0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在这里发现任何错误或有任何建议，请随时告诉我。感谢阅读！</p><p id="6bb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nj">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>