<html>
<head>
<title>Passing Data From Child to Parent Component in TypeScript React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript React中将数据从子组件传递到父组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/passing-data-from-child-to-parent-component-in-typescript-react-92ab6d03ceb1?source=collection_archive---------0-----------------------#2021-05-01">https://javascript.plainenglish.io/passing-data-from-child-to-parent-component-in-typescript-react-92ab6d03ceb1?source=collection_archive---------0-----------------------#2021-05-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fffd2f56497e3bbd0389c961f8c6e0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_otGxMhQQYeAODaylsf5A.png"/></div></div></figure><p id="44f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在现代前端开发中，由于其复杂性和规模，需要健壮的库、工具和框架。使用ReactJS，我们能够有效地管理复杂的状态、动画、频繁的更新和DOM操作。另一方面，Typescript已经成为克服JavaScript的大部分缺点(如松散类型)的一座巨大桥梁。</p><p id="c8da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将向您介绍如何在react中使用typescript将数据从子组件传递到父组件，所以请喝杯咖啡继续阅读。</p><h1 id="6010" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">React中的数据流</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/abb5e7905ca44387fa09a8f7f4174635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*RpIia3SaIKVxaa2G7Ch90g.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">data flow | react</figcaption></figure><p id="87fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上react被设计成有一个<strong class="jx io">单向</strong>数据流，这个概念意味着<strong class="jx io">数据</strong>有一个且只有一个方式被传输到应用程序的其他部分，即状态被传递到视图和子组件。</p><p id="18e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是显示数据流的简单代码片段</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="0bdc" class="mf ku in mb b gy mg mh l mi mj">// parent.tsx</span><span id="f690" class="mf ku in mb b gy mk mh l mi mj">const Parent:React.FC = () =&gt; {</span><span id="17ac" class="mf ku in mb b gy mk mh l mi mj">const [parentName, setParentName] = useState&lt;string&gt;('John Obi')</span><span id="1fc2" class="mf ku in mb b gy mk mh l mi mj">return (<br/>     &lt;div&gt;</span><span id="663a" class="mf ku in mb b gy mk mh l mi mj">       &lt;FirstChild name={parentName} /&gt;<br/>       &lt;SecondChild name={parentName} /&gt;</span><span id="1239" class="mf ku in mb b gy mk mh l mi mj">     &lt;/div&gt;</span><span id="49a4" class="mf ku in mb b gy mk mh l mi mj">  )<br/>}</span></pre><p id="9885" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是状态通常被移动到组件树顶部的原因之一，这样它们可以在需要访问它的组件之间共享。</p><p id="f474" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，值得注意的是，在react应用程序的这种通用单向数据流中，子组件的状态变化不会影响父组件，而只会影响子组件以及子组件的子组件(如果有)。</p><p id="2914" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将介绍克服这一缺点的基本方法，还有其他方法，其中之一是使用一个全局存储，如redux和上下文API。</p><h1 id="b358" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">克服这个缺点</h1><p id="f6f8" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">首先，让我们定义上面看到的父组件的子组件</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="0f2f" class="mf ku in mb b gy mg mh l mi mj">// firstChild.tsx</span><span id="1e21" class="mf ku in mb b gy mk mh l mi mj">interface IfirstChildProps {<br/>  name: string</span><span id="ab87" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="9883" class="mf ku in mb b gy mk mh l mi mj">const FirstChild: React.FC&lt;IfirstChildProps&gt; = ({name}) =&gt; {</span><span id="e470" class="mf ku in mb b gy mk mh l mi mj">const [firstChildName, setFirstChildName] = useState&lt;string&gt;('')</span><span id="225c" class="mf ku in mb b gy mk mh l mi mj">return (</span><span id="e873" class="mf ku in mb b gy mk mh l mi mj">&lt;section&gt;<br/>  &lt;h1&gt; {firstChildName} &lt;/h1&gt;<br/> &lt;button&gt; first child &lt;/button&gt;<br/>&lt;/section&gt;</span><span id="eb9d" class="mf ku in mb b gy mk mh l mi mj">)</span><span id="edff" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="b854" class="mf ku in mb b gy mk mh l mi mj">export default FirstChild;</span></pre><p id="7b27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在typescript中，你必须为所有东西定义类型，因此，对于我们的<em class="mq">第一个孩子</em>组件，我们将她的道具声明为类型<em class="mq">ifirschildprops</em>并将<em class="mq">名称</em>道具声明为字符串。我们也给了它一个本地状态<em class="mq"> firstChildName </em>，在未来，我们将致力于使本地状态值成为其父组件的状态。</p><p id="f4f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mq">记住默认情况下，在react中，你只能单向传递数据或状态，即从父组件到子组件</em></p><p id="8fc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们以同样的方式声明<em class="mq"> secondChild </em>组件</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="7156" class="mf ku in mb b gy mg mh l mi mj">// secondChild.tsx</span><span id="1a0f" class="mf ku in mb b gy mk mh l mi mj">interface IsecondChildProps {<br/>  name: string</span><span id="dd47" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="b42d" class="mf ku in mb b gy mk mh l mi mj">const SecondChild: React.FC&lt;IsecondChildProps&gt; = ({name}) =&gt; {</span><span id="4615" class="mf ku in mb b gy mk mh l mi mj">const [secondChildName, setSecondChildName] = useState&lt;string&gt;('')</span><span id="f18a" class="mf ku in mb b gy mk mh l mi mj">return (<br/>&lt;section&gt;<br/></span><span id="bc0c" class="mf ku in mb b gy mk mh l mi mj">  &lt;h1&gt; {secondChildName} &lt;/h1&gt;<br/>  &lt;button&gt;second child&lt;/button&gt;</span><span id="cabc" class="mf ku in mb b gy mk mh l mi mj">&lt;/section&gt;</span><span id="aa4f" class="mf ku in mb b gy mk mh l mi mj">)</span><span id="4bd4" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="60f1" class="mf ku in mb b gy mk mh l mi mj">export default SecondChild;</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/8d19755f95e037d9226f5f8bf609bd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*GONFO_rvaI_-5HbtBkpD4Q.jpeg"/></div></figure><p id="e39f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是呈现子组件中的按钮和一个empy h2 html标记。</p><p id="3a9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以此时，我们将为每个子组件添加<a class="ae ms" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"><em class="mq">use effect</em></a><em class="mq"/>钩子，它将<em class="mq"> parentName </em> prop(来自父组件)设置为其子组件的本地状态名称(F <em class="mq"> irstChildName </em>，S<em class="mq">second child name</em>)的值。</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="8100" class="mf ku in mb b gy mg mh l mi mj">// firstChild.tsx</span><span id="5950" class="mf ku in mb b gy mk mh l mi mj">interface IfirstChildProps {<br/>  name: string</span><span id="3ab7" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="6d8f" class="mf ku in mb b gy mk mh l mi mj">const FirstChild: React.FC&lt;IfirstChildProps&gt; = ({name}) =&gt; {</span><span id="3350" class="mf ku in mb b gy mk mh l mi mj">const [firstChildName, setFirstChildName] = useState&lt;string&gt;('')</span><span id="c659" class="mf ku in mb b gy mk mh l mi mj">useEffect(() =&gt; {</span><span id="a542" class="mf ku in mb b gy mk mh l mi mj">  setFirstChildName(name)</span><span id="6181" class="mf ku in mb b gy mk mh l mi mj">},[name])</span><span id="492c" class="mf ku in mb b gy mk mh l mi mj"> ...</span><span id="bf9c" class="mf ku in mb b gy mk mh l mi mj">export default FirstChild;</span></pre><p id="40f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，名称属性被添加到<em class="mq"> useEffect </em>钩子的依赖关系中，这样，一旦组件挂载，并且名称属性发生变化，它将重新渲染组件</p><p id="4c18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们对<em class="mq"> SecondChild </em>组件做同样的事情</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="5eba" class="mf ku in mb b gy mg mh l mi mj">// secondChild.tsx</span><span id="7ef6" class="mf ku in mb b gy mk mh l mi mj">interface IsecondChildProps {<br/>  name: string</span><span id="48c3" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="3790" class="mf ku in mb b gy mk mh l mi mj">const SecondChild: React.FC&lt;IsecondChildProps&gt; = ({name}) =&gt; {</span><span id="e4f8" class="mf ku in mb b gy mk mh l mi mj">const [secondChildName, setSecondChildName] = useState&lt;string&gt;('')</span><span id="eaea" class="mf ku in mb b gy mk mh l mi mj">useEffect(() =&gt; {</span><span id="fa0f" class="mf ku in mb b gy mk mh l mi mj">setSecondChildName(name)</span><span id="2748" class="mf ku in mb b gy mk mh l mi mj">},[name])</span><span id="b5c8" class="mf ku in mb b gy mk mh l mi mj"> ...</span><span id="77e2" class="mf ku in mb b gy mk mh l mi mj">export default SecondChild;</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f0a15f3aed4fec691f2a10830fd585ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*3PUzmKsoLqzAXq3usthJwQ.jpeg"/></div></figure><p id="7386" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以看到父组件中的名称“John Obi ”,同时呈现在两个组件上</p><h2 id="87d0" class="mf ku in bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated">履行</h2><p id="faaf" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">此时，我们将实现我们的目的— <em class="mq">将数据从子组件传递到父组件</em></p><p id="df4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从向父组件添加一个助手函数开始。让我们将这个函数命名为<em class="mq"> updateName </em>，这个函数将接受一个字符串类型的参数，并在被调用时更新父组件的状态。</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="1d1a" class="mf ku in mb b gy mg mh l mi mj">// parent.tsx</span><span id="7baa" class="mf ku in mb b gy mk mh l mi mj">const Parent:React.FC = () =&gt; {</span><span id="8bb1" class="mf ku in mb b gy mk mh l mi mj">const [parentName, setParentName] = useState&lt;string&gt;('Mr John Obi');</span><span id="ac86" class="mf ku in mb b gy mk mh l mi mj">const updateName = (name: string):void =&gt; {<br/>     setParentName(name)<br/>}</span><span id="3b96" class="mf ku in mb b gy mk mh l mi mj">return (<br/>     &lt;div&gt;</span><span id="bab4" class="mf ku in mb b gy mk mh l mi mj">      &lt;FirstChild name={parentName} /&gt;<br/>      &lt;SecondChild name={parentName} /&gt;</span><span id="64b5" class="mf ku in mb b gy mk mh l mi mj">    &lt;/div&gt;</span><span id="3fcd" class="mf ku in mb b gy mk mh l mi mj">)<br/>}</span></pre><p id="a793" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，我认为这很简单</p><p id="43d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将这个函数作为道具传递给子组件</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="530e" class="mf ku in mb b gy mg mh l mi mj">// parent.tsx</span><span id="a130" class="mf ku in mb b gy mk mh l mi mj">const Parent:React.FC = () =&gt; {</span><span id="e21a" class="mf ku in mb b gy mk mh l mi mj">const [parentName, setParentName] = useState&lt;string&gt;('Mr John Obi');</span><span id="dfe1" class="mf ku in mb b gy mk mh l mi mj">const updateName = (name: string):void =&gt; {<br/>     setParentName(name)<br/>}</span><span id="d351" class="mf ku in mb b gy mk mh l mi mj">return (<br/>     &lt;div&gt;</span><span id="556a" class="mf ku in mb b gy mk mh l mi mj">       &lt;FirstChild name={parentName} updateName={updateName} /&gt;<br/>       &lt;SecondChild name={parentName} updateName={updateName} /&gt;</span><span id="11d3" class="mf ku in mb b gy mk mh l mi mj">    &lt;/div&gt;</span><span id="6e89" class="mf ku in mb b gy mk mh l mi mj">)<br/>}</span></pre><p id="912f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">呜！typescript应该在这里对你大吼大叫，因为你为组件传递了一个属性，而不是属性类型(接口)的一部分，不要担心，我们将在接下来的几段中修复它</p><p id="bbe0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将简单地添加这个<em class="mq"> updateName </em>道具，作为每个孩子的道具的类型定义(接口)的一部分</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="0b50" class="mf ku in mb b gy mg mh l mi mj">// firstChild.tsx</span><span id="33ec" class="mf ku in mb b gy mk mh l mi mj">...</span><span id="d328" class="mf ku in mb b gy mk mh l mi mj">interface IfirstChildProps {<br/>  name: string,<br/><strong class="mb io">  </strong>updateName: (arg: string) =&gt; void</span><span id="c906" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="7d6d" class="mf ku in mb b gy mk mh l mi mj">const firstChild: React.FC&lt;IfirstChildProps&gt; = ({name, updateName}) =&gt; {</span><span id="283a" class="mf ku in mb b gy mk mh l mi mj"> ...</span><span id="2e42" class="mf ku in mb b gy mk mh l mi mj">export default firstChild;</span></pre><p id="6693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，对S<em class="mq">second child</em>组件进行同样的操作</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="e949" class="mf ku in mb b gy mg mh l mi mj">// secondChild.tsx</span><span id="88b8" class="mf ku in mb b gy mk mh l mi mj">...</span><span id="f989" class="mf ku in mb b gy mk mh l mi mj">interface IsecondChildProps {<br/>  name: string,<br/>  updateName: (arg: string) =&gt; void<br/>}</span><span id="cd81" class="mf ku in mb b gy mk mh l mi mj">const SecondChild: React.FC&lt;IsecondChildProps&gt; = ({name, updateName}) =&gt; {</span><span id="64c9" class="mf ku in mb b gy mk mh l mi mj">...</span><span id="cc8a" class="mf ku in mb b gy mk mh l mi mj">export default SecondChild;</span></pre><p id="1c3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我认为我们已经走了很长一段路，在这一点上，我们将添加一个onclick事件到每个孩子的按钮上，这样当点击时，<em class="mq"> updateName </em>函数将用一个给定的字符串调用</p><p id="96d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们把我们的Fi <em class="mq"> rstChild </em>组件<strong class="jx io"> Micheal </strong>，和我们的<em class="mq"> secondChild </em>组件<strong class="jx io"> David </strong>，所以当每个子组件中的按钮被点击时，它显示名字，Micheal或David。</p><p id="4a01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们走吧？</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="d762" class="mf ku in mb b gy mg mh l mi mj">...</span><span id="669f" class="mf ku in mb b gy mk mh l mi mj">return (</span><span id="e89c" class="mf ku in mb b gy mk mh l mi mj">  &lt;h1&gt; {firstChildName} &lt;/h1&gt;<br/>  &lt;button onClick={() =&gt; updateName('Micheal')}&gt;first child&lt;/button&gt;</span><span id="3966" class="mf ku in mb b gy mk mh l mi mj">    )</span><span id="b5a7" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="4e80" class="mf ku in mb b gy mk mh l mi mj">export default firstChild;</span></pre><p id="26cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对S <em class="mq">第二胎</em>组件进行同样的操作</p><pre class="ls lt lu lv gt ma mb mc md aw me bi"><span id="6727" class="mf ku in mb b gy mg mh l mi mj">...</span><span id="2cd5" class="mf ku in mb b gy mk mh l mi mj">return (</span><span id="46ff" class="mf ku in mb b gy mk mh l mi mj">  &lt;h2&gt; {secondChildName} &lt;/h2&gt;<br/>  &lt;button onClick={() =&gt; updateName('David')}&gt;second child&lt;/button&gt;</span><span id="7b0f" class="mf ku in mb b gy mk mh l mi mj">)</span><span id="fd21" class="mf ku in mb b gy mk mh l mi mj">}</span><span id="dd5a" class="mf ku in mb b gy mk mh l mi mj">export default secondChild;</span></pre><p id="b75d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mq">恭喜！，您刚刚将数据从子节点传递到父节点</em></p><p id="c796" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哇！很简单，对吧？尝试单击按钮，看到姓名更新为David或Micheal</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/180ba8eed14e382df1a931fd8ab64866.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/format:webp/1*oI7rxuqHqAnHR8Q5Hce5xw.jpeg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">result when on the first-child button is clicked</figcaption></figure><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/dd76ce5420bd6e401ddbcbf5a7bc789c.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/format:webp/1*z8MX0D34nm2ZheOfqN6Qqg.jpeg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">result when the second-child button is clicked</figcaption></figure><h1 id="54e4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="61b8" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">一般来说，react有一个单向的数据流，也就是说，数据是单向流动的——从父节点到子节点。但是反过来传递数据的基本策略是<em class="mq">从父组件到子组件传递和调用带有所需数据的函数。</em></p><p id="dd7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你今天学会了酷，感谢阅读这篇文章，你可以在这里获得完整的代码<a class="ae ms" href="https://codesandbox.io/s/react-typescript-forked-j40t2?file=/src/index.tsx" rel="noopener ugc nofollow" target="_blank"/>，也可以在<a class="ae ms" href="https://twitter.com/AI_Lift" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ms" href="https://github.com/armstrong99" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae ms" href="https://www.linkedin.com/in/ndukwearmstrong/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上关注我，祝你有美好的一天。</p><p id="d36c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mq">更多内容请看</em><a class="ae ms" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>