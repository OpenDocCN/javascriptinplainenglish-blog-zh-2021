<html>
<head>
<title>How to Create a Comment Section Using HTML and Vanilla JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用HTML和普通JavaScript创建评论区？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-comment-section-using-html-and-vanilla-js-aa6b6a53b9cf?source=collection_archive---------1-----------------------#2021-06-21">https://javascript.plainenglish.io/how-to-create-a-comment-section-using-html-and-vanilla-js-aa6b6a53b9cf?source=collection_archive---------1-----------------------#2021-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/04adeb3d5caf04490f8ee4d25e940ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AloP1e9ewjMocrHA"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="97d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新的一天，新的问题陈述！今天我们将使用纯JavaScript和HTML创建一个评论部分。许多公司如瑞士、优步、Flipkart、Ola、Cred等。使用机器编码轮作为他们的主要过滤器，以消除候选人。任何机器编码都不允许你使用依赖项或库，比如React、Lodash、jQuery、Bootstrap等等。因此，你应该使用普通的JavaScript和HTML来解决一些问题，以提高你的速度，获得这些行的舒适性，并最终赢得这一轮比赛。</p><p id="d39a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我常说的，把你的问题分成几个子集，然后逐一解决每个子集。</p><p id="2411" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">子集— </strong></p><ol class=""><li id="827b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">页面总是在顶部有一个静态文本区和一个允许用户添加评论的添加按钮。</li><li id="0521" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">添加的每条评论都会有回复、赞和删除按钮。</li><li id="1bbe" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">回复按钮将在父评论下启动一个新的文本区，允许用户添加回复或取消添加。</li><li id="da07" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一个喜欢的按钮会不断增加每次点击相应评论的喜欢数。</li><li id="3f09" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">删除按钮将删除整个评论链。</li><li id="5b34" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">评论可以像树状结构一样被链接，其中每个子评论将在父评论的左边对齐一些像素。</li><li id="1e23" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">添加的评论应该在页面重新加载时保持不变——这是一个改进，如果您有时间，可以在最后进行处理。</li></ol><p id="105f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您进入代码之前，后退几分钟，看看您的需求并评估哪些部分可以使用相同的代码。记住这句话——“最好的代码就是没有代码”。不要从字面上理解。这个短语试图告诉我们，一个人的代码的质量是由它的可重用性和紧凑性决定的。我们希望提供高质量的产品，不是吗？</p><p id="ff88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过查看我们的需求来评估的一个因素是，自始至终创建的注释看起来都是相似的，与子注释的左边距不同。因此，我们可以有一个可重用的函数来处理评论的创建。</p><p id="d019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一起编码吧！</p><h1 id="2705" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">顶部有一个静态文本区和一个添加评论的按钮—</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="63d0" class="mt ln in mp b gy mu mv l mw mx"><strong class="mp io"><em class="my">&lt;div class="container"&gt;<br/>    &lt;label for="newComment" name="newComment"&gt;Add your comment below-&lt;/label&gt;<br/>    &lt;textarea id="newComment"&gt;&lt;/textarea&gt;<br/>    &lt;button id="addComments"&gt;Add Comment&lt;/button&gt;<br/>    &lt;div id="allComments"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</em></strong></span></pre><p id="c076" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们通过在页面顶部添加一个接受新评论的文本区域和一个在我们的部分添加新评论的添加按钮来开始代码。</p><p id="fc8f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还创建了一个div — <code class="fe mz na nb mp b"><strong class="kc io">allComments</strong></code>,我计划在其中添加所有添加到页面的评论。</p><h1 id="fcd1" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">动态添加评论—</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8be2" class="mt ln in mp b gy mu mv l mw mx"><strong class="mp io"><em class="my">const commentContainer = document.getElementById('allComments');<br/>document.getElementById('addComments').addEventListener('click', function (ev) {<br/>   addComment(ev);<br/>});<br/><br/>function addComment(ev) {<br/>    let commentText, wrapDiv;<br/>    const textBox = document.createElement('div');<br/>    const replyButton = document.createElement('button');<br/>    replyButton.className = 'reply';<br/>    replyButton.innerHTML = 'Reply';<br/>    const likeButton = document.createElement('button');<br/>    likeButton.innerHTML = 'Like';<br/>    likeButton.className = 'likeComment';<br/>    const deleteButton = document.createElement('button');<br/>    deleteButton.innerHTML = 'Delete';<br/>    deleteButton.className = 'deleteComment';<br/>    const wrapDiv = document.createElement('div');<br/>    wrapDiv.className = 'wrapper';<br/>    wrapDiv.style.marginLeft = 0;<br/>    commentText = document.getElementById('newComment').value;<br/>    document.getElementById('newComment').value = '';<br/>    textBox.innerHTML = commentText;<br/>    wrapDiv.append(textBox, replyButton, likeButton, deleteButton);<br/>    commentContainer.appendChild(wrapDiv);<br/>    <br/>}</em></strong></span></pre><p id="e1c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们首先在Add Comments按钮上添加一个事件监听器。监听器调用<code class="fe mz na nb mp b"><strong class="kc io">addComment </strong></code>函数。用自我解释的名称来定义您的函数是一个很好的做法。总是增加代码的可读性。</p><p id="86d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mz na nb mp b"><strong class="kc io">addComment </strong></code>函数中，我们正在创建评论，稍后会添加到我们的页面中。我们在textarea中选取上面输入的注释文本，将其附加到我们新创建的div中。我们还为新创建的评论创建了回复、喜欢和删除按钮。我们将所有的元素包装在一个新的div中，然后追加到<code class="fe mz na nb mp b"><strong class="kc io">allComments </strong></code> div中。此外，可以这样假设，一旦新的注释被添加到下面的部分，文本区将再次为空，以便输入新的注释。因此，我们删除了上面文本区中输入的文本。</p><h1 id="b5a2" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">处理回复、喜欢和删除按钮—</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d45e" class="mt ln in mp b gy mu mv l mw mx"><strong class="mp io"><em class="my">function hasClass(elem, className) {<br/>    return elem.className.split(' ').indexOf(className) &gt; -1;<br/>}</em></strong></span><span id="c0cd" class="mt ln in mp b gy nc mv l mw mx"><strong class="mp io"><em class="my">document.getElementById('allComments').addEventListener('click', function (e) {<br/>    if (hasClass(e.target, 'reply')) {<br/>        const parentDiv = e.target.parentElement;<br/>        const wrapDiv = document.createElement('div');<br/>        wrapDiv.style.marginLeft = (Number.parseInt(parentDiv.style.marginLeft) + 15).toString() + 'px';<br/>        wrapDiv.className = 'wrapper';<br/>        const textArea = document.createElement('textarea');<br/>        textArea.style.marginRight = '20px';<br/>        const addButton = document.createElement('button');<br/>        addButton.className = 'addReply';<br/>        addButton.innerHTML = 'Add';<br/>        const cancelButton = document.createElement('button');<br/>        cancelButton.innerHTML = 'Cancel';<br/>        cancelButton.className='cancelReply';<br/>        wrapDiv.append(textArea, addButton, cancelButton);<br/>        parentDiv.appendChild(wrapDiv);<br/>    } else if(hasClass(e.target, 'addReply')) {<br/>        addComment(e);<br/>    } else if(hasClass(e.target, 'likeComment')) {<br/>         const likeBtnValue = e.target.innerHTML;<br/>         e.target.innerHTML = likeBtnValue !== 'Like' ? Number.parseInt(likeBtnValue) + 1 : 1;<br/>    } else if(hasClass(e.target, 'cancelReply')) {<br/>        e.target.parentElement.innerHTML = '';<br/>    } else if(hasClass(e.target, 'deleteComment')) {<br/>        e.target.parentElement.remove();<br/>    }<br/>});</em></strong></span></pre><p id="7e81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种模块化的方式，在点击回复、喜欢和删除按钮时为每个评论添加事件监听器。</p><p id="a1e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义事件来捕捉主<code class="fe mz na nb mp b"><strong class="kc io">allcomments</strong></code> div中的任何点击。一旦事件被捕获，您可以通过检查附加到该元素的类来找到触发事件的元素。除了采用这种方法，您还可以在<code class="fe mz na nb mp b"><strong class="kc io">addComments </strong></code>函数中创建事件的地方为回复、删除和喜欢按钮单独定义事件。但是，当我们可以从一个事件处理程序中实现相同的行为时，我们真的需要一堆事件处理程序吗？</p><p id="25e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在点击添加回复按钮时，我再次使用addComments功能。但是，我们必须在函数中处理这个问题，因为目前它只知道如何将注释添加到主注释容器中。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f8e9" class="mt ln in mp b gy mu mv l mw mx"><strong class="mp io"><em class="my">function addComment(ev) {<br/>    let commentText, wrapDiv;<br/>    const textBox = document.createElement('div');<br/>    const replyButton = document.createElement('button');<br/>    replyButton.className = 'reply';<br/>    replyButton.innerHTML = 'Reply';<br/>    const likeButton = document.createElement('button');<br/>    likeButton.innerHTML = 'Like';<br/>    likeButton.className = 'likeComment';<br/>    const deleteButton = document.createElement('button');<br/>    deleteButton.innerHTML = 'Delete';<br/>    deleteButton.className = 'deleteComment';<br/>    if(hasClass(ev.target.parentElement, 'container')) {<br/>        const wrapDiv = document.createElement('div');<br/>        wrapDiv.className = 'wrapper';<br/>        wrapDiv.style.marginLeft = 0;<br/>        commentText = document.getElementById('comment').value;<br/>        document.getElementById('comment').value = '';<br/>        textBox.innerHTML = commentText;<br/>        wrapDiv.append(textBox, replyButton, likeButton, deleteButton);<br/>        commentContainer.appendChild(wrapDiv);<br/>    } else {<br/>        wrapDiv = ev.target.parentElement;<br/>        commentText = ev.target.parentElement.firstElementChild.value;<br/>        textBox.innerHTML = commentText;<br/>        wrapDiv.innerHTML = '';<br/>        wrapDiv.append(textBox, replyButton, likeButton, deleteButton);<br/>    }<br/>  }</em></strong></span></pre><p id="2393" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们修改后的<code class="fe mz na nb mp b"><strong class="kc io">addComments()</strong></code>函数的样子。现在它负责向主容器或注释链添加注释。而且可以重复使用！</p><h1 id="7505" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重新加载评论—</h1><p id="ce9e" class="pw-post-body-paragraph ka kb in kc b kd nd kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt nh kv kw kx ig bi translated">我们的评论区已经准备好了。只剩下最后一点需要补充。评论部分必须在页面刷新时维护，因为评论不仅仅与会话相关，而是永远相关，直到被删除。</p><p id="69fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用浏览器localStorage的强大功能来实现这一点。localStorage保存其数据，直到被手动清除或删除。</p><p id="c3a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以以最适合我们需求的任何格式存储数据。在上面的例子中，我们可以直接存储整个模板。重新加载整个部分的简单方法。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0807" class="mt ln in mp b gy mu mv l mw mx"><strong class="mp io"><em class="my">function setOnLocalStorage () {<br/>    localStorage.setItem('template', document.getElementById('allComments').innerHTML);<br/>}</em></strong></span></pre><p id="1d6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的函数将使用<code class="fe mz na nb mp b"><strong class="kc io"><em class="my">allComments </em></strong></code> div的innerHTML设置localStorage中的<code class="fe mz na nb mp b"><strong class="kc io"><em class="my">template </em></strong></code>键。每当您向该部分添加新的评论、添加对评论的回复(如评论)或删除评论时，都应该调用该函数。</p><p id="06ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就对了。你的个性化评论区已经准备好了，你可以生活在你自己的虚拟世界里了。😆</p><figure class="mk ml mm mn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/429a8ad2e7c21f4f8dc3350b3858601f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-HFCEJQPGGae7imDDpMenA.png"/></div></div></figure><p id="6d66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是不要停下来！你带了一个向导，他让你的旅程轻松了许多。现在是时候让你独自行走，探索风景，获得更深刻的见解了。</p><p id="0b43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我有一些任务给你，你可以自己完成，对自己的技能更有信心。</p><ol class=""><li id="5bb6" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">将username属性添加到comments中(它保存了进行评论的用户的一些模拟名称)。</li><li id="b6c0" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">like按钮目前有一个简单的实现。它应该显示1喜欢，2喜欢等，而不是1，2，3喜欢的增量。</li><li id="3e6b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">允许用户编辑现有评论。</li><li id="004b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">为每个评论添加一个发布属性，显示上次编辑/发布的日期和时间。</li><li id="c5b8" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一种扩展和折叠父评论的方法(通过手风琴)或者任何可能的更好的方法。</li><li id="929c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果目标文本区为空，则禁用添加/回复按钮，这将限制用户添加空评论。</li></ol><p id="2662" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦您完成了将这些特性添加到您的项目中，您一定会对您对我们这里所采用的方法的理解更有信心。</p><p id="61e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">坚持练习，自己感受不同。:)</p><p id="6280" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整代码，请访问GitHub链接—【https://github.com/SaloniMishra/Comment-section T2】</p><p id="4754" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="my">plain English . io</em></strong></a></p></div></div>    
</body>
</html>