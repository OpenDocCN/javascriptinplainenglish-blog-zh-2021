<html>
<head>
<title>Create Connections Between Objects with Konva and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Konva和React创建对象之间的连接</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-connections-between-objects-with-konva-react-34eebb7c50a?source=collection_archive---------5-----------------------#2021-08-12">https://javascript.plainenglish.io/creating-connections-between-objects-with-konva-react-34eebb7c50a?source=collection_archive---------5-----------------------#2021-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/931426be463f22b48ab00e04c17f66b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*RYjgorzXvBMaSCagpxeOsg.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">an example of creating a connection in Reciprocal.dev</figcaption></figure><p id="7862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我目前正在开发的应用(<a class="ae kw" href="https://reciprocal.dev" rel="noopener ugc nofollow" target="_blank"> Reciprocal.dev </a>)为用户提供了一个交互式用户旅程地图，它基本上包含了许多用户旅程步骤，这些步骤以类似于流程图的方式用线连接在一起。</p><p id="f74f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然<a class="ae kw" href="https://bootcamp.uxdesign.cc/faking-it-to-make-it-f5a94279ad5e" rel="noopener" target="_blank">我们使用一组硬编码的数据和手摇SVG路径</a>验证了这个想法，但我们确信我们有值得追求的东西。下一项重要工作是构建一个编辑器，这样用户就可以创建自己的用户旅程地图。</p><p id="52b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该编辑器需要允许用户在用户旅程中创建多个步骤，然后在两个步骤之间拖动一条线，以便将它们连接起来。这是许多工具中使用的常见模式，例如Miro，所以UX已经被定义了，但仍然存在如何在我选择的画布框架<a class="ae kw" href="https://konvajs.org/" rel="noopener ugc nofollow" target="_blank">——Konva</a>中实现行为的问题。</p><h2 id="fb5c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">连接对象</h2><p id="d185" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">幸运的是，Konva网站上有许多展示不同技术的非常有用的例子。其中一个例子是<a class="ae kw" href="https://konvajs.org/docs/sandbox/Connected_Objects.html" rel="noopener ugc nofollow" target="_blank">‘连接对象’</a>,它有许多由一组线连接的圆。</p><p id="8851" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的设置有一些不同(我使用的是<a class="ae kw" href="https://www.npmjs.com/package/react-konva" rel="noopener ugc nofollow" target="_blank"> react-konva </a>)，但是我能够将这个例子改编成连接如何工作的基本概念证明。</p><p id="9d59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这个例子的关键是连接的数据结构。该线条使用源对象和目标对象的位置坐标，而不是单独为其连接的对象绘制线条，因此当这些对象移动时，线条的位置也会移动。</p><p id="fcab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于示例中使用的直线，这意味着该直线没有位置坐标，因为它只引用它所连接的两个对象。</p><p id="2440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过我想要建立的连接并不简单，因为我希望用户能够在连接的对象中重新定位线的源点和目的点，这样他们就可以在屏幕上可视化元素，从而触发用户旅程的进展。</p><p id="43d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我修改了数据结构，使其也包含可以应用于位置坐标的偏移量。当用户移动源点或目标点时，这些偏移将被更新，这意味着如果其中一个连接的对象移动，那么该点的位置将仍然反映用户想要的。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The linked objects position has the offset applied so the connection sits within the step properly</figcaption></figure><h1 id="b261" class="mb ky iq bd kz mc md me lc mf mg mh lf mi mj mk li ml mm mn ll mo mp mq lo mr bi translated">建造UX来建立联系</h1><p id="f4bc" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在Miro等工具中创建连接的UX是在选定的对象周围有一个边框，该边框有一组“锚点”,拖动时会创建一条跟随指针位置的线。当用户在另一个对象上悬停时释放指针，则线条将被转换为两个对象之间的连接。</p><p id="b776" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建这种交互模式需要许多组件:</p><ul class=""><li id="0a7b" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">将被连接的对象</li><li id="61b9" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">将突出显示所选对象的边框</li><li id="e2d4" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">拖动时将作为线条源点的边框上的锚点</li><li id="19f5" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">从锚点到指针位置的直线</li><li id="9016" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">源对象和目标对象之间的最终连接</li></ul><p id="7778" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在这篇文章中讨论边界、锚点、线条和连接，因为将要连接的对象可以是任何对象，所以对于任何示例，我将只使用一些基本的矩形。</p><h2 id="9129" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">创建选定的对象边框</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/89beb1b36a2b1db9cb87d93883e577ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*NbPh-i0Os4Kx3S4b7rrSxg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">A border with anchors for creating connections with</figcaption></figure><p id="3d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建border组件，我创建了一条线，它形成了一个矩形，与它所围绕的对象尺寸相同，当与该对象处于相同位置时，看起来就像有一个边框围绕着它。</p><p id="bfaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用Line而不是Rect来实现这一点的原因是，如果Rect没有填充，它仍然会阻止其下任何项目的click事件，这意味着在连接的对象内移动连接源的预期功能不会工作。</p><p id="7021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现创建一个新的层来渲染边界和它的锚点更容易，因为这确保了它们总是在画布上渲染的任何其他元素之上。</p><p id="b2a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了知道对象是否被选中，需要某种形式的状态来跟踪哪些步骤被选中。这意味着需要一种容易识别每个对象的方法。</p><p id="708e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了做到这一点，我创建了一个对象映射，它将被迭代以在画布上呈现对象，这些对象中的每一个都有一个ID，该ID将作为键，然后将被添加到所选对象的数组中，并从该数组中移除，以跟踪其选择状态。然后，这个选定对象id的数组将用于呈现这些对象的边框数组。我还创建了一个连接数组来呈现在地图上(稍后会详细介绍)。</p><p id="163a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我为该对象创建了一个onClick处理程序，这样，当单击该对象时，它会将ID包含在所选对象的数组中。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Showing which rectangle has been selected</figcaption></figure><h2 id="93cd" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">向所选对象边框添加锚点</h2><p id="d226" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">实现了边框后，我需要添加锚点，如果用户将指针放在地图上的另一个对象上，这些锚点将用于创建线条和最终的连接。</p><p id="29fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我修改了边框组件，在顶部、底部、左侧和右侧添加了10px边距的圆圈，这样就不会与边框形状发生冲突。</p><p id="4449" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了添加拖动行为，我在圆圈上添加了<code class="fe nh ni nj nk b">draggable</code>道具，并添加了一个<code class="fe nh ni nj nk b">dragBoundFunc</code>，当圆圈被拖动时，它会将圆圈锁定在适当的位置。当被拖动时，圆圈保持静止的行为并不像我希望的那么容易。</p><p id="fe0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传入<code class="fe nh ni nj nk b">dragBoundFunc</code>的位置是一个绝对位置，并期望返回一个绝对位置，但是，如果锚点在一个组内，位置坐标将是相对于该组的，因此，如果该组不在0，0位置，您可能会遇到拖动时圆圈移动的问题。</p><p id="91bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我通过对圆使用ref并返回ref在<code class="fe nh ni nj nk b">dragBoundFunc</code>中的绝对位置(如果设置了的话)来解决这个问题。</p><p id="3a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">锚点设置为固定后，下一步是确保在用户拖动锚点时创建并更新一条线。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The dragBoundFunc uses the ref to ensure the anchor stays stationary during a drag</figcaption></figure><h2 id="0b93" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">拖动锚点时显示一条线</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/aef440d4a7b84137af73f6c31d47e546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GVEZUrX0KNhx5gm7vvulQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Connection Preview when the anchor is dragged in Reciprocal.dev</figcaption></figure><p id="ce08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为线只需要在锚被拖动时显示，我决定使用状态来存储线组件或者<code class="fe nh ni nj nk b">null</code>,这取决于拖动是否发生。</p><p id="ff70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我可以在我为边框和锚点创建的组中的其他项目上添加这个状态值的渲染，因为<code class="fe nh ni nj nk b">null</code>在React中不渲染任何东西，它只会在拖动活动时显示线条。</p><p id="2c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">react-konva中的阻力生命周期有三个阶段；<code class="fe nh ni nj nk b">onDragStart</code>、<code class="fe nh ni nj nk b">onDragMove</code>和<code class="fe nh ni nj nk b">onDragEnd</code>所以我为它们创建了处理程序，这些处理程序将在<code class="fe nh ni nj nk b">onDragStart</code>期间创建并设置Line in状态，在<code class="fe nh ni nj nk b">onDragMove</code>期间将目标坐标更新为指针的位置，并在<code class="fe nh ni nj nk b">onDragEnd</code>期间将状态设置为<code class="fe nh ni nj nk b">null</code>。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The connection preview renders a Line when the drag on the anchor is active</figcaption></figure><h2 id="e76c" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">如果在另一个对象上释放指针，则创建连接</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/900e6dc9a739a971c05b9175ddddb34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4h_zsE7_Dt17a6AH19-xw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Different types of connection in Reciprocal.dev. These use the offsets to give users flexibility of how the line looks while still linking two screens together</figcaption></figure><p id="410a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最初试图使用<code class="fe nh ni nj nk b">onMouseOver</code>事件监听器来确定指针是否在对象上被释放，但是当拖动发生时，因为线在指针下面，所以这从未触发，所以我然后看着<code class="fe nh ni nj nk b">getIntersection</code>被对象调用，但是最后决定从对象本身移除点击逻辑，而保留拖动逻辑。</p><p id="ace8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了检测拖动是否在对象上被释放，我创建了一个简单的函数来检测指针的位置是否在对象的边界内，并且作为<code class="fe nh ni nj nk b">onDragEnd</code>的一部分，遍历对象来找出是否有交集。</p><p id="27c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果释放拖动时指针在对象的边界内，则开始对象和释放拖动的对象用于在存储在状态中的连接数组中创建新项目。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The connection is added to an array of connections which is mapped over during render to create the lines</figcaption></figure><h1 id="91d6" class="mb ky iq bd kz mc md me lc mf mg mh lf mi mj mk li ml mm mn ll mo mp mq lo mr bi translated">结果</h1><p id="3e3a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我对在<a class="ae kw" href="https://reciprocal.dev" rel="noopener ugc nofollow" target="_blank"> Reciprocal.dev </a>中创建连接的方式非常满意，希望这篇文章能对如何实现类似的结果有所启发。</p><p id="c284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这种类型的行为有很多应用，比如构建白板或流程图设计工具，所以我希望代码可以跨多个领域重用。</p><p id="1091" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到我在下面这篇文章中提到的行为和代码的简单演示。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nr ma l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">To use the demo click a rectangle to select it. Once selected the anchors can be dragged to create a connection between the two shapes</figcaption></figure><p id="1259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ns">更多内容尽在</em><a class="ae kw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>