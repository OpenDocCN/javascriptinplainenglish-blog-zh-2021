<html>
<head>
<title>Testing JavaScript performance with Benchmark.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Benchmark.js测试JavaScript性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-javascript-performance-with-benchmark-js-3d3f4e4b9fc2?source=collection_archive---------5-----------------------#2021-11-02">https://javascript.plainenglish.io/testing-javascript-performance-with-benchmark-js-3d3f4e4b9fc2?source=collection_archive---------5-----------------------#2021-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9cea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我们想要提高代码的性能时，重要的是首先要有度量标准来测量和比较，以确保我们的更改达到预期的效果。<a class="ae ki" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank"> Benchmark.js </a>是一个常用的工具，用于测量JavaScript代码的执行时间，支持高分辨率的计时器以提高测量精度，并确保返回具有统计意义的结果。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/42eedd39381076559ad6082f5b6a6473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_d7ijCQKFNBwYHJg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@veri_ivanova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Veri Ivanova</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a317" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多web工具都基于Benchmark.js，允许您快速创建测试套件，然后在浏览器中运行。虽然<a class="ae ki" href="https://jsperf.com/" rel="noopener ugc nofollow" target="_blank"> jsPerf </a>直接隶属于Benchmark.js，但它往往不可靠(在撰写本文时，它已经因“402: Payment required”错误而关闭了几天)，所以我个人最喜欢的是<a class="ae ki" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank"> JSBench。Me </a>，它允许您创建一个帐户来保存您的测试套件，并与他人共享它们。</p><p id="52bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这个测试套件展示了基于在一个<code class="fe kz la lb lc b">for</code>循环中遍历数组的手写等价函数<code class="fe kz la lb lc b">Array.prototype.some</code>的性能。我们可以将不同的测试用例放入不同的盒子中，并添加尽可能多的测试用例进行比较。任何设置逻辑都应该放入<em class="ld"> Setup JavaScript </em>字段，以确保测试用例完全专注于运行我们实际想要测试的代码。当我们准备好了，我们只需点击<em class="ld">运行</em>按钮和JSBench。Me将在后台配置Benchmark.js来运行我们的代码并比较结果，清晰地呈现不同选项之间的性能差异。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi le"><img src="../Images/59cfef59838d57baf6d494753f2c53fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME7xuCj8eihxBm_mYE0IEA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">An example test run from JSBench.Me</figcaption></figure><p id="255e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，手写版本的性能明显更好，JSBench也是如此。Me强调这个测试用例是最快的，并确定其他每个测试用例慢多少。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="74f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然在线工具对于快速比较代码片段非常有用，但是您可能还希望将Benchmark.js集成到您自己的应用程序中，例如在CI管道中包括性能测试，以帮助防止回归。</p><p id="36ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">入门容易；只需通过运行以下命令来安装Benchmark.js:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="da1f" class="lq lr in lc b gy ls lt l lu lv">npm i --save-dev benchmark</span></pre><p id="ccf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后创建一个新文件(例如<code class="fe kz la lb lc b">bench.js</code>)来包含你的基准套件。您需要导入基准库:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="265d" class="lq lr in lc b gy ls lt l lu lv">const Benchmark = require('benchmark');</span></pre><p id="86f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建<code class="fe kz la lb lc b">Suite</code>对象，如果您喜欢，可以给它起个名字:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="8eb8" class="lq lr in lc b gy ls lt l lu lv">const suite = new Benchmark.Suite('My performance test');</span></pre><p id="e820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后您需要配置测试套件，它具有一个漂亮流畅的界面。您可以向套件中添加测试和运行它的调用:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="5c1e" class="lq lr in lc b gy ls lt l lu lv">suite<br/>    .add('RegExp#test', () =&gt; /o/.test('Hello World!'))<br/>    .add('String#indexOf', () =&gt; 'Hello World!'.indexOf('o') &gt; -1)<br/>    .run();</span></pre><p id="ac54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以通过执行文件来运行套件，例如运行:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="23d1" class="lq lr in lc b gy ls lt l lu lv">node bench.js</span></pre><p id="4ed9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样做，您将看到脚本需要一些时间来运行，然后…不返回任何内容。不幸的是，我们需要采取一些额外的步骤来实际获得一些结果！</p><p id="65d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Benchmark.js在运行时发布了许多事件，我们在配置测试套件时为这些事件添加了监听器:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="90b8" class="lq lr in lc b gy ls lt l lu lv">suite.on('complete', event =&gt; {<br/>  const suite = event.currentTarget;<br/>  const fastestOption = suite.filter('fastest').map('name');</span><span id="d4f1" class="lq lr in lc b gy lw lt l lu lv">  console.log(`The fastest option is ${fastestOption}`));<br/>});</span></pre><p id="87f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件上的<code class="fe kz la lb lc b">currentTarget</code>是完整的<code class="fe kz la lb lc b">Suite</code>对象。运行该套件现在将输出以下内容:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="af5b" class="lq lr in lc b gy ls lt l lu lv">The fastest option is String#indexOf</span></pre><p id="4785" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道<code class="fe kz la lb lc b">String#indexOf</code>测试用例以最快的速度运行。如果我们还想随着测试套件的进展获得更多的输出，我们可以监听<code class="fe kz la lb lc b">cycle</code>事件:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="a1b6" class="lq lr in lc b gy ls lt l lu lv">suite.on('cycle', event =&gt; {<br/>  const benchmark = event.target;</span><span id="1f82" class="lq lr in lc b gy lw lt l lu lv">  console.log(benchmark.toString());<br/>});</span></pre><p id="2e04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件上的<code class="fe kz la lb lc b">target</code>是最后一次运行基准。现在，我们的输出将类似于以下内容:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="27a8" class="lq lr in lc b gy ls lt l lu lv">RegExp#test x 48,985,511 ops/sec ±0.73% (90 runs sampled)<br/>String#indexOf x 819,109,711 ops/sec ±0.77% (92 runs sampled)<br/>The fastest option is String#index</span></pre><p id="9478" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在有了更多关于不同选项运行速度的信息，以及这些结果的差异。幸运的是，这里有一个明显的赢家，<code class="fe kz la lb lc b">indexOf</code>方法快了一个数量级，低方差让我们对结果有很高的信心。</p><p id="f74e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Benchmark.js提供了比我们在本文中提到的更多的选项:您可以在他们的<a class="ae ki" href="https://benchmarkjs.com/docs" rel="noopener ugc nofollow" target="_blank"> API文档</a>中找到更多信息。</p><p id="ccdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，这里是我们最初在JSBench中运行的相同测试。Me但是直接用Benchmark.js写的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="dcb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="b194" class="lq lr in lc b gy ls lt l lu lv">Array.prototype.some x 111 ops/sec ±1.33% (78 runs sampled)<br/>for loop x 1,687 ops/sec ±2.01% (91 runs sampled)<br/>The fastest option is for loop</span></pre><p id="2a9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以在浏览器中运行该套件，方法是将其封装在一个简单的HTML页面中:</p><pre class="kk kl km kn gt lm lc ln lo aw lp bi"><span id="5a1f" class="lq lr in lc b gy ls lt l lu lv">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;Benchmark.js test&lt;/title&gt;<br/>        &lt;meta charset="utf-8"&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"&gt;&lt;/script&gt;<br/>        &lt;script src="https://cdn.jsdelivr.net/npm/benchmark@2.1.4/benchmark.min.js"&gt;&lt;/script&gt;<br/>        &lt;script src="bench.js"&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b1d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并在开发人员工具控制台中查看输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/d92a05bb220327207bedc49d2ede021e.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*-4CxVW7IlrWOkbV00KibXg.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Output from benchmark suite in browser</figcaption></figure><blockquote class="ma mb mc"><p id="1273" class="jk jl ld jm b jn jo jp jq jr js jt ju md jw jx jy me ka kb kc mf ke kf kg kh ig bi translated">注意:您必须从<code class="fe kz la lb lc b">bench.js</code>中移除<code class="fe kz la lb lc b">require</code>以避免浏览器出错；<code class="fe kz la lb lc b">Benchmark</code>对象将在全球范围内可用</p></blockquote></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><p id="4668" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然您已经了解了使用Benchmark.js的基本知识，那么您就可以开始对代码的性能做出量化的决定，并证明您何时在进行改进。前进，让你的代码更快！</p><p id="ca3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，在此之前，先了解一下如何使用剧作家跨不同的浏览器运行Benchmark.js测试</p><p id="d88a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ld">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ld">plain English . io</em></strong></a></p></div></div>    
</body>
</html>