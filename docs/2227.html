<html>
<head>
<title>Expose Database over Rest API with TypeORM and First-Class Entity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeORM和一流实体公开Rest之上的数据库API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/expose-database-over-rest-api-with-typeorm-and-first-class-entity-70f2f53bb2a8?source=collection_archive---------4-----------------------#2021-05-10">https://javascript.plainenglish.io/expose-database-over-rest-api-with-typeorm-and-first-class-entity-70f2f53bb2a8?source=collection_archive---------4-----------------------#2021-05-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/91c485c6b507747edb5be0b13d5e7bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3MY7Yi5RNIOR-3Jd"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Arnold Francisca</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9653" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过REST API公开数据库似乎是一个疯狂的想法。但是有了良好的API设计、适当的安全处理和定制选项，它可以为立即构建API提供优势。</p><p id="ee21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于一个需要创建具有后端功能的应用程序的小团队或全栈程序员来说，这很有帮助，因为他们需要集中精力为用户体验创建一个好的UI/UX。</p><p id="eab9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个故事中，我将解释称为一级实体的<a class="ae jz" href="https://plumierjs.com" rel="noopener ugc nofollow" target="_blank"> Plumier </a>特性，它在内部使用TypeORM进行数据访问。一流的实体注重安全性、定制性和清晰性。一流的实体保证公开的API是安全的，完全可定制的，并且对于安全审查是透明的。</p><p id="1c86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于不熟悉的人来说，Plumier是一个TypeScript后端框架，它专注于工作效率，并有一个专用的反射库来帮助您愉快地创建一个健壮、安全和快速的API。</p><h2 id="9738" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">挑战</h2><p id="e2cf" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">出现的一些问题与通过API公开数据库有关，尤其是通过Rest API公开SQL数据库。大多数都是安全问题，但也有更多。</p><ul class=""><li id="0a74" class="lw lx in kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me bi translated">它是如何处理关系的？一对多、多对一和一对一？如何设置关系数据？以及如何检索与父母记录相关的记录？</li><li id="15d1" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">由于数据库表可能包含敏感数据，它如何防止数据泄漏？它如何基于用户角色保护读/写访问？</li><li id="5cc0" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">在保存记录之前，它如何处理密码哈希等微过程？保存数据后，它是否会发送通知(电子邮件或推送通知)？或者甚至使用请求上下文值，比如获取<code class="fe mk ml mm mn b">createdBy</code>列的当前登录用户？</li><li id="4785" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">由于表是在使用REST API时直接公开的，它如何处理查询(过滤、选择、排序)？它如何确保查询对敏感数据无害？</li></ul><p id="8742" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在深入细节之前，我们将先了解一下这个一流的实体是什么样子的，以及Plumier是如何在幕后处理它的。</p><h2 id="b784" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">术语</strong></h2><p id="ceef" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">第一类实体是指在框架组件中被视为第一类公民的ORM(对象关系映射)实体。它比普通的ORM实体有更多的控制权，这使得它可以安全地作为API公开。除了作为表模式表示的原始任务之外，第一类实体还可以控制框架特性，例如。</p><ul class=""><li id="b37d" class="lw lx in kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me bi translated">对应用编程接口网址的控制。</li><li id="5f6b" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">对验证的控制。</li><li id="98d7" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">控制值/数据类型转换的请求和响应模式。</li><li id="1d7f" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">对安全和授权的控制。</li></ul><p id="3ea4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一流的实体不是ORM特有的特性，相反，它是Plumier提供的实体的独立扩展特性。通过一些规范化，它可以应用于其他ORM。</p><h2 id="52fc" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它是如何工作的？</h2><p id="42d0" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最简单的一级实体是一个用Plumier配置修饰的TypeORM实体，如下所示。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b913" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过像上面一样在实体上应用<code class="fe mk ml mm mn b">@genericController()</code> decorator，Plumier route generator知道实体将由通用控制器处理。Plumier有一些内置的通用控制器，它们将成为每个控制器的基类。例如，对于简单(非关系)实体，基本通用控制器如下所示。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3cdb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面是内置通用控制器的简化版本。它有<code class="fe mk ml mm mn b">T</code>通用参数，这将是响应的模型和请求体，在本例中，请求体是实体。</p><p id="4051" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它还有定义实体ID的数据类型的<code class="fe mk ml mm mn b">TID</code>参数，此外，这用于检查ID为的资源标识符上ID的数据类型，如<code class="fe mk ml mm mn b">GET /path/:id</code>、<code class="fe mk ml mm mn b">PUT /path/:id</code>等。它确保提供的值与实体ID的数据类型相匹配。</p><p id="9483" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier反射库支持泛型类型自省，这使得Plumier路由生成器可以生成从泛型控制器继承的控制器。在后台，Plumier route generator动态创建一个新的控制器，如下图所示。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fd35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的控制器继承了它的所有基类方法，这些方法产生了下面的六条路线。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="85d6" class="ky kz in mn b gy my mz l na nb">GET    /products       # get products list<br/>GET    /products/:id   # get product by id<br/>POST   /products       # add new product<br/>PUT    /products/:id   # replace product<br/>PATCH  /products/:id   # modify product <br/>DELETE /products/:id   # delete product</span></pre><h2 id="c70f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它是如何处理对象关系的？</h2><p id="781e" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">一个ORM实体拥有一对一或多对一的关系是很常见的行为，这通常有一个object的数据类型，例如，我们的最后一个Product实体可能拥有类型为<code class="fe mk ml mm mn b">Category</code>的<code class="fe mk ml mm mn b">category</code>属性。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bd3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题是，我们将如何设置<code class="fe mk ml mm mn b">category</code>属性的值？因为它只是一个引用属性，所以它的值是<code class="fe mk ml mm mn b">Category</code>的ID，而不是category对象本身。另一个重要的问题是，由于<code class="fe mk ml mm mn b">category</code>属性的数据类型是<code class="fe mk ml mm mn b">Category</code>类型，我们不可能提供number(ID)类型的值，因为框架类型转换器会拒绝它。</p><p id="9815" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier通过提供一个自定义类型转换器来解决这个问题，它允许通过ID匹配对象ID数据类型来设置对象关系，并保持数据类型转换。所以在这种情况下，我们可以像下面这样在<code class="fe mk ml mm mn b">POST</code>方法上发送产品请求体。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="111f" class="ky kz in mn b gy my mz l na nb">POST /products<br/>{ </span><span id="9f36" class="ky kz in mn b gy nc mz l na nb">   /** ---- other properties ---- **/</span><span id="e1e5" class="ky kz in mn b gy nc mz l na nb">   // use the ID instead of the category object <br/>   "category": 20<br/>}</span></pre><p id="4784" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mk ml mm mn b">category</code>属性在请求产品API <code class="fe mk ml mm mn b">GET /products</code>或<code class="fe mk ml mm mn b">GET /products/:id</code>时也会自动填充，解决了检索对象关系时的问题。</p><h2 id="f882" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它是如何处理数组关系的？</h2><p id="8028" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">与对象关系不同，在数组关系中设置值可能会有问题，因为它不能通过提供id来完成。例如，当修改记录时，不清楚是打算添加集合还是用新值替换当前集合。当属性有大量记录时，检索值也有问题，这通常通过分页来解决。</p><p id="52e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">REST在描述嵌套资源时有最佳实践。这是通过使用嵌套的资源标识符(URL)来实现的，例如。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="6188" class="ky kz in mn b gy my mz l na nb">GET    /parents/{parentId}/children?offset&amp;limit&amp;filter<br/>GET    /parents/{parentId}/children/{id}<br/>POST   /parents/{parentId}/children<br/>PUT    /parents/{parentId}/children/{id}<br/>PATCH  /parents/{parentId}/children/{id}<br/>DELETE /parents/{parentId}/children/{id}</span></pre><p id="67a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier遵循这些实践，并提供了一个特殊的通用控制器来服务嵌套资源。例如，有一个实体与关系商店-产品像下面的例子。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ca79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，<code class="fe mk ml mm mn b">@genericController()</code>装饰器直接应用于<code class="fe mk ml mm mn b">products</code>属性。它告诉Plumier route generator在生成路线时使用嵌套的通用控制器。因此，它会生成下面的嵌套路由。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="c774" class="ky kz in mn b gy my mz l na nb">GET    /shops/:pid/products       # get shop's products list<br/>GET    /shops/:pid/products/:id   # get shop's product by id<br/>POST   /shops/:pid/products       # add new shop's product<br/>PUT    /shops/:pid/products/:id   # replace shop's product<br/>PATCH  /shops/:pid/products/:id   # modify shop's product<br/>DELETE /shops/:pid/products/:id   # delete shop's product</span></pre><h2 id="8161" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它如何保护数据？</h2><p id="3d78" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最后，我们到达了故事最重要的部分。我们如何保护被API客户端访问(读/写)的敏感数据，比如密码或信用卡号被泄露？时间戳或删除标志被覆盖？甚至我们如何保护基于用户角色的敏感数据？</p><p id="d539" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier具有基于策略的授权，可以应用于第一类实体声明，旨在保护API端点、请求体和响应体。我们最后一个产品实体是这样的。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eb5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码片段显示，我们添加了一些配置，根据用户的角色来限制对用户的访问。</p><ol class=""><li id="dfba" class="lw lx in kc b kd ke kh ki kl ly kp lz kt ma kx nd mc md me bi translated">我们配置通用控制器来限制对其变异器(<code class="fe mk ml mm mn b">PUT</code>、<code class="fe mk ml mm mn b">PATCH</code>、<code class="fe mk ml mm mn b">POST</code>、<code class="fe mk ml mm mn b">DELETE</code>)端点的访问，只有<code class="fe mk ml mm mn b">ShopOwner</code>和<code class="fe mk ml mm mn b">Staff</code>策略可以访问。</li><li id="a35f" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx nd mc md me bi translated">我们保护仅可通过<code class="fe mk ml mm mn b">ShopOwner</code>和<code class="fe mk ml mm mn b">Staff</code>策略访问的<code class="fe mk ml mm mn b">basePrice</code>财产。因为我们已经保护了mutators端点，所以没有必要保护对<code class="fe mk ml mm mn b">basePrice</code>属性的写访问，因为路由授权比其他授权评估得更早。</li><li id="cac5" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx nd mc md me bi translated">我们保护的<code class="fe mk ml mm mn b">price</code>属性只能由<code class="fe mk ml mm mn b">ShopOwner</code>策略设置，任何人都可以看到。</li><li id="7db8" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx nd mc md me bi translated">我们保护<code class="fe mk ml mm mn b">createdOn</code>不被任何人覆盖。因为它将由TypeORM填充。</li></ol><p id="9ff6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义策略<code class="fe mk ml mm mn b">ShopwOnwer</code>和<code class="fe mk ml mm mn b">Staff</code>非常简单。诀窍在于我们在登录过程中在JWT令牌上添加的角色声明。然后，我们检查授权逻辑声明，如下所示。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="0f1a" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它是如何解决请求上下文过程的？</h2><p id="76a6" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如前所述，API有时需要在实体保存到数据库之前或之后执行一些微处理。TypeORM提供了<a class="ae jz" href="https://typeorm.io/#/listeners-and-subscribers" rel="noopener ugc nofollow" target="_blank">实体监听器</a>在实体事件中执行一些微进程，如<code class="fe mk ml mm mn b">BeforeInsert</code>、<code class="fe mk ml mm mn b">AfterInsert</code>、<code class="fe mk ml mm mn b">BeforeUpdate</code>、<code class="fe mk ml mm mn b">AfterUpdate</code>等。但是，我们不能依赖它们，因为这不是一个请求上下文流程。我们无法从方法内部检索请求数据。</p><p id="5776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier提供了<a class="ae jz" href="https://plumierjs.com/generic-controller#request-hook" rel="noopener ugc nofollow" target="_blank">请求钩子</a>，这是一个由专门的中间件内部调用的方法。它支持的<a class="ae jz" href="https://plumierjs.com/controller/#parameter-binding" rel="noopener ugc nofollow" target="_blank">参数绑定</a>，可以轻松地将请求上下文值绑定到方法参数中，以供将来使用。</p><p id="7844" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在我们之前的产品实体中，我们添加了<code class="fe mk ml mm mn b">createdBy</code>实体，该实体将自动填充当前登录用户。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2616" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面代码的重要部分是从第9行到第16行。首先，我们用<code class="fe mk ml mm mn b">@authorize.readonly()</code> decorator保护<code class="fe mk ml mm mn b">createdBy</code>属性，防止任何用户覆盖该属性的值。然后我们提供了<code class="fe mk ml mm mn b">@preSave("post")</code>钩子，它将方法标记为在实体保存到数据库之前执行的请求钩子。注意，它使用了<code class="fe mk ml mm mn b">post</code>过滤器，这意味着钩子只调用了<code class="fe mk ml mm mn b">POST</code>方法。</p><p id="d2bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后在第14行，我们绑定请求上下文值(JWT声明),用于填充<code class="fe mk ml mm mn b">createdBy</code>属性的值。</p><h2 id="354d" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">它是如何处理查询的？</h2><p id="294b" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">由于表直接暴露在一个API上，默认情况下，当获取记录列表时会以默认的模式和顺序返回记录。它需要进一步的查询(过滤、选择、排序)来使返回的数据符合我们的需要。</p><p id="29ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到REST最佳实践，使用如下查询字符串定义REST标识符的额外参数。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="456d" class="ky kz in mn b gy my mz l na nb">GET /users?name=john&amp;deleted=false</span></pre><p id="4b28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用查询字符串的问题是，API客户端不可能使用复杂的过滤来查询数据，比如使用<code class="fe mk ml mm mn b">OR</code>操作符，甚至不能使用分组过滤，比如<code class="fe mk ml mm mn b">(name=john or name=jane) and deleted=false</code>。</p><p id="8e21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier提供了<a class="ae jz" href="https://plumierjs.com/query-parser/" rel="noopener ugc nofollow" target="_blank">查询解析器</a>，它提供了一个简单的表达式语言解析器。它提供了三种类型的解析器，即:过滤解析器、选择解析器和顺序解析器。基于上述问题，可以通过以下请求轻松解决。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="5fa5" class="ky kz in mn b gy my mz l na nb">GET /users?filter=((name='john' or name='jane') and deleted=false)</span></pre><p id="a082" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也可以像下面一样同时提供订单和选择。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="92f6" class="ky kz in mn b gy my mz l na nb"># get list users which is not deleted<br/># select only the name and email<br/># order by createdAt descending</span><span id="a19f" class="ky kz in mn b gy nc mz l na nb">GET /users?filter=(deleted=false)&amp;select=name,email&amp;order=-createdAt</span></pre><p id="1559" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的查询字符串没有直接解析为SQL查询，而是解析为TypeORM查询。所以保证会妥善处理SQL注入。</p><p id="ffa2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查询解析器尊重用户对查询属性的访问。它检查用户是否拥有对该属性的读取权限。比如下面给我们之前的产品实体。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="94bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于上面的配置，我们将对<code class="fe mk ml mm mn b">basePrice</code>属性的读取权限只授予特定的角色。这意味着查询<code class="fe mk ml mm mn b">basePrice</code>也只适用于那些角色。</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="ca5e" class="ky kz in mn b gy my mz l na nb">GET /products?filter=basePrice &gt; 200</span></pre><p id="1d81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述请求仅在当前登录用户拥有<code class="fe mk ml mm mn b">ShopOwner</code>或<code class="fe mk ml mm mn b">Staff</code>角色时有效。否则将返回HTTP错误401或403。这个安全限制也适用于选择解析器和顺序解析器。</p><h2 id="7950" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">更极端的定制？</h2><p id="f87d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">第一类实体是如此的灵活，<code class="fe mk ml mm mn b">@genericController()</code>接受一些配置来定制你需要的通用控制器行为，你可以在这里查看全面的文档<a class="ae jz" href="https://plumierjs.com/generic-controller" rel="noopener ugc nofollow" target="_blank">。如果这些定制不能满足您的需要，您可以省略使用一级实体，手动创建控制器，或者直接扩展通用控制器。Plumier提供了一个工厂来创建可重用的通用控制器，如下所示。</a></p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5d34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mk ml mm mn b">GenericController</code>是一个返回通用控制器类的工厂函数。你可以把上面的控制器放在你的项目目录的任何地方，Plumier会像对待一个普通的控制器一样对待它们。</p><p id="db58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，上述修改很少需要，大多数情况下所有的<code class="fe mk ml mm mn b">@genericController()</code>配置都可以解决您需要的定制。</p><h2 id="f712" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">遗言</h2><p id="76d8" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最后，我们来到了这个故事的结尾。如果您一直在关注上面的故事，那么您现在已经理解了一级实体如何通过直接公开数据库和提供良好的API端点来加速您的API开发，同时维护您的数据的安全性。在这里参考关于如何开始一个一流实体项目<a class="ae jz" href="https://plumierjs.com/quick-start" rel="noopener ugc nofollow" target="_blank">的Plumier文档。</a></p><p id="2bb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier是一个相对年轻的框架。如果你喜欢这个特性，可以在它的<a class="ae jz" href="https://github.com/plumier/plumier" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上开始这个项目。</p><p id="d29d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ne">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ne">plain English . io</em></a></p></div></div>    
</body>
</html>