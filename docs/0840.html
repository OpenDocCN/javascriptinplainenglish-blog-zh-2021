<html>
<head>
<title>Make Your Code More Scalable With The Strategy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用策略模式使您的代码更具可伸缩性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/make-your-code-more-scalable-with-the-strategy-pattern-2ef1619c0127?source=collection_archive---------7-----------------------#2021-02-21">https://javascript.plainenglish.io/make-your-code-more-scalable-with-the-strategy-pattern-2ef1619c0127?source=collection_archive---------7-----------------------#2021-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="030f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">两个真实的例子将帮助你更好地理解这个有用的设计模式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/614f7dabf90a0c198b878073cf75c804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LuVtj7UY0PUR0vyx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@bharat_patil_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bharat Patil</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c1ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，假设你的公司决定马上发放奖金。奖金基于员工的工资基数和绩效评分。</p><ul class=""><li id="be60" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">绩效评级为A的员工可以获得相当于其基本月薪5倍的奖金。</li><li id="c856" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">绩效评级为B的员工可以获得相当于其基本月薪3倍的奖金。</li><li id="bbef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">绩效评级为C的员工可以获得相当于其月基本工资两倍的奖金。</li></ul><p id="c3b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你的老板要你写一个程序来计算每个员工应该得到的奖金。你会怎么做？</p><p id="22fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实这是普遍存在的需求，相信每个编程初期的程序员都会遇到类似的问题。</p><p id="2061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不考虑编码技巧和后续迭代，大多数人期望编写的第一个程序版本是这样的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/d11847e313058decd3dded75faab046f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dpDiSkHL5yPJlWBmoXB9A.png"/></div></div></figure><p id="3601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">员工有三个评级，所以我们为每个评级写一个判断逻辑。的确，这是一个非常直观的代码。我相信大多数开发人员都曾经编写过这样的代码，有些人可能会使用switch语句而不是if-else语句，但是没有根本的区别。</p><p id="1cfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的老板不打算改变未来奖金的计算方式，如果我们不需要在其他地方重用这些奖金算法，那么像这样编写代码确实可以完成工作。</p><p id="5744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在一个真实的项目中，如果您遇到一个更复杂、动态的场景，上面的代码会暴露出很多问题。</p><ul class=""><li id="334a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果我们需要添加一个新的绩效等级D，或者如果我们想将绩效等级A的奖金系数更改为6，那么我们必须直接更改<code class="fe mh mi mj mk b">getBonus</code>函数。对核心功能的频繁更改容易出错，难以测试，并且难以协作。</li><li id="6c16" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">函数<code class="fe mh mi mj mk b">getBonus</code>很容易变得臃肿笨拙。</li><li id="3cbc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">代码重用性差。如果我们想在程序的其他地方重用这些奖金算法，那么我们唯一的选择就是复制和粘贴。</li></ul><p id="b0ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如何才能优化上面的代码呢？</p><p id="09a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，如果我们仔细看看上面的代码，我们可以看到，在上面的代码中，每个性能评级都对应一个算法。比如A级对应的奖金应该是<code class="fe mh mi mj mk b">monthlySalary * 5</code>。</p><p id="3bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码就是这么描述的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/9de7bf679da61b0e861504f74c84dd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WewOdrnzCQZJBc2-v0Z_rw.png"/></div></div></figure><p id="ad05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将这些计算从主函数中去掉，并将<code class="fe mh mi mj mk b">getBonus</code>函数的流程简化为如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/18f46333986bfdc246816039e8364262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOBVO-Nf9MdVa-TlwqlhtA.png"/></div></div></figure><p id="b417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何通过评级来获得策略呢？在JavaScript中，通过使用映射或对象来存储映射关系，可以很容易地解决这个问题。</p><p id="1fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/8dfe475e6c64dadccbf3c5dc52120938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tC7ArVo7o5dlWHNnq1zBVQ.png"/></div></div></figure><pre class="kg kh ki kj gt mo mk mp mq aw mr bi"><span id="53c5" class="ms mt iq mk b gy mu mv l mw mx">let strategies = {<br/>  "A": monthlySalary =&gt; monthlySalary * 5,<br/>  "B": monthlySalary =&gt; monthlySalary * 3,<br/>  "C": monthlySalary =&gt; monthlySalary * 2,<br/>}</span><span id="fe43" class="ms mt iq mk b gy my mv l mw mx">function getBonus(rating, monthlySalary){<br/>  <br/>  let strategy = strategies[rating]</span><span id="07c1" class="ms mt iq mk b gy my mv l mw mx">  return strategy(monthlySalary)<br/>}</span></pre><p id="689f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e3594f001ce3e23ca7a8b2f587b6c1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*8RACd6h8OEFimfCGXTeEZQ.png"/></div></figure><p id="704e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设现在我们的老板想要增加一个新的评级:绩效评级为S的员工可以获得10倍于其基本月薪的奖金。</p><p id="3251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我们不需要改变我们的<code class="fe mh mi mj mk b">getBonus</code>函数，我们只需要添加一个新的策略到我们的策略集中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/cb22322ed0496c0fcc8d2a87cbaebf42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fN1Mx7zNZ0UIhgyJ_anfKw.png"/></div></div></figure><p id="e498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，上面使用的重构技巧是设计模式中的策略模式。</p><p id="cb0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算在这里和你讨论战略模式的官方定义，因为我认为它太理论化了，没有意义。如果你真的想知道官方的定义，你可以去谷歌搜索一下。我想让你知道的是<strong class="ky ir">如果你的代码中有很多条件分支，每个分支对应一个特定的算法，你可以考虑把那些特定的小算法拉出来，放在一起</strong>。这使得你的主要功能集中在程序的整体流程上。</p><p id="0957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实际开发中，我们经常扩展算法的含义，以便策略模式也可以用于封装一组“业务规则”只要这些业务规则指向相同的目标，并且可以互换使用，我们就可以用策略模式封装它们。</p><p id="20ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看一个更常见也更复杂的例子。</p><h1 id="2f36" class="nb mt iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated">表单验证</h1><p id="63b5" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">假设我们正在编写一个供用户注册的HTML页面。当用户单击提交按钮时，我们需要验证以下规则:</p><ul class=""><li id="bbfd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">用户名不能为空</li><li id="de15" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">密码长度不能少于10个字符</li><li id="53db" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">电子邮件地址应该包含一个<code class="fe mh mi mj mk b">@</code>符号</li></ul><p id="ff7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我给出一个HTML的基本模板。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="046a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需求很简单，但是写出高质量的代码就不简单了。你将如何编写验证代码？</p><p id="14fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先使用传统的方法来完成需求，然后使用策略模式。然后让我们比较一下，看看哪个更好。</p><p id="1143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传统的方法是使用if-else语句来验证各种规则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/c7279f605698d0c7ba15ba31fe35932b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0FjsWRMiViHbO8vOrOffw.png"/></div></div></figure><p id="1582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想使用策略模式，我们首先列出所有的策略。如您所见，每个验证规则只是输入一个字符串，如果不符合规则，就会返回一条错误消息。</p><p id="392f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以这样写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/3b11d6d427f3458654440e39d7c8e926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adMjvhet34ixVGoQurt8sw.png"/></div></div></figure><p id="9b33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为有很多规则需要验证，每个验证逻辑都需要处理一个错误消息，所以我们可以再次拉出具体的验证逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/671c5263a72a8cf43c4741d44d5a3fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_BaUsE_cK3FsGESF_EZnA.png"/></div></div></figure><p id="1ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们完成了主要功能。完整代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc ny l"/></div></figure><p id="e1ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来我们正在编写更复杂的代码。事实上，如果您确信您的需求在未来不会改变，并且您不打算在其他地方重用该算法，那么您可以只使用通常的方法，而不需要使用策略模式或其他设计模式。但是，如果您的项目需求发生变化，或者如果您计划重用代码，战略模式可以帮助您完成工作。</p><p id="edf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设随着项目的进展，我们添加了一个新的表单。该表单中有三个字段:</p><ul class=""><li id="a16f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">名和姓。我们需要确保它们不是空的。</li><li id="6444" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">电话号码。我们需要验证电话号码是否符合格式。</li></ul><pre class="kg kh ki kj gt mo mk mp mq aw mr bi"><span id="29af" class="ms mt iq mk b gy mu mv l mw mx">&lt;form id='registor'&gt;<br/>    Username: &lt;input type="text" name="username" /&gt;<br/>    Password: &lt;input type="text" name="password" /&gt; <br/>    Email: &lt;input type="text" name="email" /&gt;<br/>    &lt;button&gt;submit&lt;/button&gt;<br/>&lt;/form&gt;</span><span id="7e43" class="ms mt iq mk b gy my mv l mw mx">&lt;form id='userInfo'&gt;<br/>    first name: &lt;input type="text" name="firstname" /&gt; <br/>    last name: &lt;input type="text" name="lastname" /&gt; <br/>    phone number: &lt;input type="text" name="phoneNumber" /&gt;<br/>    &lt;button&gt;submit&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="f342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直接给出用于验证电话号码的正则表达式。你直接抄就可以了，不用管细节。</p><pre class="kg kh ki kj gt mo mk mp mq aw mr bi"><span id="6812" class="ms mt iq mk b gy mu mv l mw mx">/^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/im</span></pre><p id="cdc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们使用常规方法，我们需要大量的复制和粘贴。你可以自己尝试一下，但是为了文章大小，我就不做了。</p><p id="a625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用策略模式，我们可以重用很多代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc ny l"/></div></figure><p id="194a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在脚本中，我们只需要添加一个新的策略，不需要修改验证器，可以很好地重用之前的代码。使用传统方法很难做到这一点。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h2 id="dbf9" class="ms mt iq bd nc ok ol dn ng om on dp nk lf oo op nm lj oq or no ln os ot nq ou bi translated">结论</h2><p id="46da" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">这些是我在开发过程中学到的一些例子。希望对你有帮助。</p></div></div>    
</body>
</html>