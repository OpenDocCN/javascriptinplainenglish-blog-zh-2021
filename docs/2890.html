<html>
<head>
<title>How to Compare the Date Part of a Date Object Only Without Comparing the Time in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中只比较日期对象的日期部分而不比较时间</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-compare-the-date-part-of-a-date-object-only-without-comparing-the-time-in-javascript-a1f0af96eb96?source=collection_archive---------8-----------------------#2021-06-12">https://javascript.plainenglish.io/how-to-compare-the-date-part-of-a-date-object-only-without-comparing-the-time-in-javascript-a1f0af96eb96?source=collection_archive---------8-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f8463de947f4fd6321903ac570e6c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pplGXfjx_eDdAfIC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ashkfor121?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ashkan Forouzani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们可能希望只比较日期的日期部分，而不比较JavaScript应用程序中的时间。</p><p id="ded1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用JavaScript在不比较时间的情况下比较日期。</p><h1 id="a6a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Date.prototype.setHours</code></h1><p id="6c75" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">要比较日期而不比较时间部分，我们可以使用JavaScript date对象附带的<code class="fe lz ma mb mc b">setHours</code>方法将两个日期都设置为午夜。</p><p id="5f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1bd9" class="mq lc iq mc b gy mr ms l mt mu">const date1 = new Date(2021, 1, 1, 1, 1, 1)<br/>date1.setHours(0, 0, 0, 0)</span><span id="41a2" class="mq lc iq mc b gy mv ms l mt mu">const date2 = new Date(2021, 2, 1)<br/>date2.setHours(0, 0, 0, 0)</span><span id="4919" class="mq lc iq mc b gy mv ms l mt mu">console.log(+date2 &gt; +date1)</span></pre><p id="a66e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe lz ma mb mc b">date1</code>上的<code class="fe lz ma mb mc b">setHours</code>将<code class="fe lz ma mb mc b">date1</code>的时、分、秒全部设置为0。</p><p id="b82a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将日期设置为午夜。</p><p id="0d5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以像在最后一行中那样，用&gt;操作符比较这两个没有时间部分的值，</p><p id="81eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了安全起见，我们首先用<code class="fe lz ma mb mc b">+</code>操作符将它们转换成时间戳。</p><p id="c3b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，控制台日志应该显示<code class="fe lz ma mb mc b">true</code>，因为<code class="fe lz ma mb mc b">date2</code>在<code class="fe lz ma mb mc b">date1</code>之前。</p><p id="9fdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更安全，我们可以在将两个日期都转换为UTC日期时间后进行比较。</p><p id="9e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7349" class="mq lc iq mc b gy mr ms l mt mu">const date1 = new Date(2021, 1, 1, 1, 1, 1)<br/>const date1Copy = new Date(Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate()));<br/>date1Copy.setHours(0, 0, 0, 0)</span><span id="d74d" class="mq lc iq mc b gy mv ms l mt mu">const date2 = new Date(2021, 2, 1)<br/>const date2Copy = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate()));<br/>date2Copy.setHours(0, 0, 0, 0)</span><span id="1aad" class="mq lc iq mc b gy mv ms l mt mu">console.log(+date2Copy &gt; +date1Copy)</span></pre><p id="582a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用从<code class="fe lz ma mb mc b">date1</code>和<code class="fe lz ma mb mc b">date2</code>检索的日期部分调用<code class="fe lz ma mb mc b">Date.UTC</code>来创建一个UTC时间戳。</p><p id="f080" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它们传递给<code class="fe lz ma mb mc b">Date</code>构造函数来创建新的日期对象。</p><p id="511d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在复制的日期上调用<code class="fe lz ma mb mc b">setHours</code>，然后与它们进行比较。</p><p id="b128" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该从控制台日志中得到相同的结果。</p><h1 id="3c3f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Moment.js</h1><p id="95b9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">moment.js库有一个<code class="fe lz ma mb mc b">isAfter</code>方法，可以让我们比较两个没有时间部分的日期时间。</p><p id="2f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ea77" class="mq lc iq mc b gy mr ms l mt mu">const date1 = new Date(2021, 9, 20, 12, 0, 0);<br/>const date2 = new Date(2021, 9, 20, 12, 1, 0);<br/>const isAfter = moment(date2).isAfter(date1, 'day');</span><span id="46c7" class="mq lc iq mc b gy mv ms l mt mu">console.log(isAfter)</span></pre><p id="2932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在用<code class="fe lz ma mb mc b">date2</code>日期对象创建的时刻日期对象上调用<code class="fe lz ma mb mc b">isAfter</code>。</p><p id="8670" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lz ma mb mc b">'day'</code>传入第二个参数，从比较中排除每个日期的时间部分。</p><p id="e273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe lz ma mb mc b">isAfter</code>的结果应该是<code class="fe lz ma mb mc b">false</code>，因为除了时间部分，它们都是同一个日期。</p><h1 id="4b91" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="85ab" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用本地JavaScript日期方法或moment.js来比较没有时间部分的日期。</p><p id="7ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>