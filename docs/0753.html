<html>
<head>
<title>6 JavaScript UI Testing Anti-Patterns You Need to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6 JavaScript UI测试您需要避免的反模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-javascript-ui-testing-anti-patterns-you-need-to-avoid-f77f9902ef9e?source=collection_archive---------2-----------------------#2021-02-16">https://javascript.plainenglish.io/6-javascript-ui-testing-anti-patterns-you-need-to-avoid-f77f9902ef9e?source=collection_archive---------2-----------------------#2021-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f670" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">探索最常见的不良实践以及如何实施正确的解决方案。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/571370034e99dda6a91f69f502e544dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*caEM9uJpUS5gV2Ro"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ruben244?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ruben Mishchuk</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dc0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着越来越多的公司寻求为手工测试提供程序化的解决方案，测试自动化开始流行起来。</p><p id="6bf0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以美元计算，测试自动化领域预计将从2019年的126亿美元飙升至2024年的288亿美元。五年内增加了100%以上。这种天文数字的增长将带来大量的机会。</p><p id="b7b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不幸的是，新的机会也会导致不良测试实践的增加。在本文中，我们将介绍该领域中六种最常见的JavaScript测试自动化反模式，以便新手可以主动避免它们。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="e551" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">等待中…</h1><p id="e0bc" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">现代的自动化框架，如Cypress和剧作家，使用隐式和显式等待，直到页面加载完毕，元素可见，或者元素可以被交互。通过给浏览器时间加载到可测试状态，这确保了测试不那么古怪和容易失败。一旦加载完成，测试可以继续执行。</p><p id="71c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个正确使用等待的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A comparison of waiting for selectors using Cypress and Playwright.</figcaption></figure><p id="94ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最常见的等待反模式是等待代码执行之间的显式超时。这样做会停止执行，然后在超时结束后继续执行。这最终会延迟测试的执行，并减慢整个测试的运行速度。</p><p id="58ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个不正确使用等待的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Comparing timeout waits using Cypress and Playwright.</figcaption></figure><p id="bb1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要编写上面的代码，而是使用内置的等待策略，比如等待元素或响应。考虑在上面的例子中点击“newHeadingButton”分派一个请求。我们可以等待请求完成，然后再采取下一步行动。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Proper waits using Cypress and Playwright.</figcaption></figure><h1 id="7b68" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">把UI测试看得太重了</h1><p id="9e86" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">如果您或者您的工程师正在使用UI设置测试状态，您可能正在参与一个糟糕的测试实践。通过UI生成测试状态很麻烦，并且会导致测试失败。相反，利用现有的应用程序实现来创造密封的用户旅程。</p><p id="b523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当测试一个全新用户的应用程序登录时，不要通过UI构建一个新用户，然后尝试登录。您的测试不再是密封的，因为它现在测试两个用户旅程:</p><ol class=""><li id="d8c9" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nf ng nh ni bi translated">新用户注册</li><li id="d92b" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">应用程序登录</li></ol><p id="ac13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相反，使用应用程序的API为新用户创建一个请求，然后尝试使用新构建的凭证登录。使用Cypress的内置请求库和别名可以毫不费力地做到这一点。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A Cypress request with a response alias.</figcaption></figure><p id="352c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用JavaScript HTTP库的剧作家可以使用类似的模式，比如<a class="ae ks" href="https://www.npmjs.com/package/requestify" rel="noopener ugc nofollow" target="_blank"> Requestify </a>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A Playwright request using the Requestify NPM package.</figcaption></figure><h1 id="4dad" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">独立于CI的测试</h1><p id="5b40" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">测试自动化中一个非常常见的反模式是独立于持续集成运行测试。直接的结果是失败的测试没有直接的影响。当在CI中运行时，一个失败的测试可以阻止一个构建被合并，从而避免潜在的失败到达验证或生产环境。此外，一个失败的测试可以作为一个开发团队将他们的注意力转向失败的号召。</p><p id="ba68" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">测试工程师应该与站点可靠性或基础设施工程师一起工作，以确保自动化测试在每个构建或每个合并的基础上运行。如果一个工程团队决定采用这样的工具，当使用像<a class="ae ks" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank"> Pre-Commit </a>这样的包时，测试甚至可以在提交或预推送时运行。</p><p id="27dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我个人建议团队使用预提交，在预提交时运行林挺/格式化，然后在预推送时运行单元测试。由于UI测试需要更长的时间，我会使用Github Actions或Jenkins workflow之类的东西在每次构建或每次合并的基础上运行它们。</p><h1 id="e08e" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">行为驱动开销</h1><p id="9848" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我曾经是行为驱动开发(BDD)的大力支持者，以至于我为我过去工作过的两家公司编写了最佳实践标准。然而，我已经不再使用BDD了，因为我已经得出结论，这个过程提供了很少甚至没有价值，同时也是重构痛苦的来源。</p><p id="9933" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像Cucumber这样的行为驱动的开发工具非常适合在梦幻场景中使用，在这种场景中，整个公司都已经接受了BDD的艺术。然而，经常是测试团队用小黄瓜写作，而业务的其他方面要么忽略实践，要么不做贡献。在这种情况下，BDD失去了作为部门间协作工具的价值。这种做法没有使产品管理、开发和QA更加紧密，反而疏远了QA。</p><p id="5dc7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">移除BDD的另一个原因是编写和重构测试所涉及的开销。考虑一个用户旅程，其中一个普通用户导航到一个登录页面，提交有效信息，并检查是否成功。我们可以把它写在特写里。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="9e00" class="nt lx in np b gy nu nv l nw nx">// login.feature</span><span id="8b68" class="nt lx in np b gy ny nv l nw nx">Feature: Application Login<br/>    As a user,<br/>    I would like to login to the application</span><span id="1089" class="nt lx in np b gy ny nv l nw nx">    Scenario: Login with valid information<br/>        Given we visit the login page<br/>        When we submit valid credentials<br/>        Then we should redirect to our profile page</span></pre><p id="455f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们需要一个steps文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Steps file for both Cypress and Playwright automation frameworks.</figcaption></figure><p id="05cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果登录工作流不再重定向到个人资料页面会怎样？</p><p id="816d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，您必须分两步进行重构，而不是在没有BDD的情况下在一个位置进行重构:步骤和特性。BDD最明显的痛点是这样一个事实，小的重构比完全不使用BDD要花两倍的时间来完成。您的测试旅程没有单一的真实来源，而是有两个独立的模块，它们必须保持同步才能正常工作。</p><p id="28e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你应该写更多的声明性用户旅程，而不是使用BDD。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Declarative testing using Cypress and Playwright.</figcaption></figure><p id="cd9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的旅程对读者(无论是测试人员、产品经理还是开发人员)来说都是足够明确的，测试需要一个用户，输入有效数据，并成功提交。不需要任何步骤、特性或复杂的开销，只需要简单的JavaScript。</p><h1 id="5399" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">情况</h1><p id="c1e4" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">测试工程师应该尽可能地从测试中删除条件逻辑，以减少错误。条件测试会产生不确定的测试，这些测试很难排除故障并放心运行。</p><p id="9b9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我为一家需要测试第三方集成的公司工作。该测试的一部分是通过第三方登录，然后重定向到他们的应用程序。由于测试的古怪性质，验证状态被证明是不可预测的。他们实现了条件逻辑，试图在before步骤中处理它。</p><ul class=""><li id="6f60" class="na nb in kv b kw kx kz la lc nc lg nd lk ne lo nz ng nh ni bi translated">如果用户已登录，注销，然后登录</li><li id="e4bc" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nz ng nh ni bi translated">如果用户未登录，请登录</li></ul><p id="6866" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于这种条件逻辑，测试是非常不可靠的。有时他们会通过，尽管大多数时候会彻底失败。在拆卸步骤中，我选择移除条件逻辑，支持API注销方法。用户总是必须登录(除非测试执行被手动中断)，这使得测试在运行时更加可靠。</p><p id="48e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">工程师不应该使用条件逻辑流，而是应该尽可能地使用API来构建测试状态，无论是通过发出请求还是模仿响应。</p><p id="f5d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们考虑一个正在进行A/B测试的示例应用程序。这个应用程序是一个书店，为A组显示一本书，为b组显示另一本书。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Response mocks with Cypress and Playwright.</figcaption></figure><p id="0d2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们的测试是确定的和可靠的，因为我们使用API而不是试图通过UI来构建测试状态。</p><h1 id="87a9" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">选择错误的选择器</h1><p id="b214" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">通常，使用正确的选择器标准是一项困难的任务。测试自动化中一个常见的反模式是在构建页面对象或编写测试时使用非常脆弱的选择器。脆弱的选择器是那些可能由于实现重构而改变的选择器。不适当的选择器标准是使用非唯一的id和类，或者Xpath。</p><p id="757c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Cypress通过采用JQuery <code class="fe oa ob oc np b">.first()</code>和<code class="fe oa ob oc np b">.last()</code>方法，以及用于DOM遍历的方法，如<code class="fe oa ob oc np b">.sibling()</code>和<code class="fe oa ob oc np b">.parent()</code>，特别减轻了一些痛苦。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="0973" class="nt lx in np b gy nu nv l nw nx">// Cypress<br/>cy.get('.chat-message').last();</span></pre><p id="d6b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">建议通过添加定制的选择器来强化您的选择器方法，而不是依赖这些选择方法(除非您无法访问源代码)。</p><p id="57a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在大多数情况下，测试工程师应该与他们的开发团队同步，以确保唯一的选择器被添加到代码库中。这些包括选择器，如<code class="fe oa ob oc np b">data-id</code>、<code class="fe oa ob oc np b">data-test-id</code>、<code class="fe oa ob oc np b">data-cy</code>或它们的任何变体。它们可以像自动化框架中的任何属性一样使用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Proper selector criteria using Cypress and Playwright.</figcaption></figure><h1 id="472f" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">摘要</h1><p id="030d" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我们现在可以识别并避免JavaScript测试自动化中最常见的六种反模式。请记住，这些并不是自动化测试世界中唯一的反模式。当你继续在这个行业工作的时候，你会注意到在灌输好的测试实践的时候要避免的其他模式。</p><h1 id="b5c0" class="lw lx in bd ly lz mv mb mc md mw mf mg jt mx ju mi jw my jx mk jz mz ka mm mn bi translated">资源</h1><ol class=""><li id="17c6" class="na nb in kv b kw mo kz mp lc od lg oe lk of lo nf ng nh ni bi translated">"自动化测试市场."<em class="og">市场研究公司</em>，<a class="ae ks" href="http://www.marketsandmarkets.com/Market-Reports/automation-testing-market-113583451.html." rel="noopener ugc nofollow" target="_blank">www . Market and markets . com/Market-Reports/automation-testing-Market-113583451 . html .</a></li><li id="fedb" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">"条件测试."<em class="og"> Cypress Documentation </em>，2021年2月15日，<a class="ae ks" href="http://docs.cypress.io/guides/core-concepts/conditional-testing.html#Definition" rel="noopener ugc nofollow" target="_blank">docs . Cypress . io/guides/core-concepts/conditional-testing . html # Definition</a>。</li><li id="cf9b" class="na nb in kv b kw nj kz nk lc nl lg nm lk nn lo nf ng nh ni bi translated">“最佳实践。”<em class="og"> Cypress Documentation </em>，2021年2月15日，<a class="ae ks" href="http://docs.cypress.io/guides/references/best-practices.html#Selecting-Elements" rel="noopener ugc nofollow" target="_blank">docs . Cypress . io/guides/references/best-practices . html # select-Elements</a>。</li></ol></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="5d12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">乔纳森·汤普森</strong>高级质量工程师，专注于测试自动化。他目前居住在北卡罗来纳州的罗利，与他的妻子和一个名叫温斯顿的戈德多德尔(Goldendoodle)住在一起。您可以通过<a class="ae ks" href="https://www.linkedin.com/in/jonathanmnthompson/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与他联系，也可以通过<a class="ae ks" href="https://twitter.com/jacks_elsewhere" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ks" href="http://github.com/ThompsonJonM" rel="noopener ugc nofollow" target="_blank"> Github </a>关注他。</p></div></div>    
</body>
</html>