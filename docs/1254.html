<html>
<head>
<title>A TypeScript Runtime Data Validators Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript运行时数据验证器比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-cdbb532f0b89?source=collection_archive---------7-----------------------#2021-03-16">https://javascript.plainenglish.io/a-typescript-runtime-data-validators-comparison-cdbb532f0b89?source=collection_archive---------7-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4c72" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第5部分:ajv</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4249aee99bc255929d1c75a905354fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhJynhO6dwlkWpUzPNFSSg.png"/></div></div></figure><p id="9418" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是基于我的实践经验的运行时数据验证器比较系列报告的第5篇。在继续本系列的其余部分之前，您应该阅读第一篇文章中的介绍，以理解制作该报告所涉及的目标和测试方法。</p><ol class=""><li id="b685" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-50a6abf3c559">简介</a></li><li id="effe" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-eeedc6b0583a"> io-ts </a></li><li id="c4bd" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-c422e431926a"> joi </a></li><li id="dda3" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-15f0ea2e3265">对</a></li><li id="0f65" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated">ajv</li><li id="436f" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-92887e22ee65">佐德</a></li><li id="442e" class="lk ll in kq b kr lu ku lv kx lw lb lx lf ly lj lp lq lr ls bi translated"><a class="ae lt" rel="noopener ugc nofollow" target="_blank" href="/a-typescript-runtime-data-validators-comparison-67cb9abb599b">超级结构</a></li></ol><h1 id="9383" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">介绍</h1><p id="c302" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Ajv是一个基于JSON模式的验证器，这使它有别于其他测试过的验证器。Ajv自称“超级快”，后端(Node.js)和前端(浏览器)都管用。独特的是，ajv采用了一种代码生成方法，并支持生成独立的失效代码。</p><p id="ac8a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就下载量而言，ajv是测试过的验证器中最受欢迎的，下载量是第二受欢迎的(joi)的10倍。</p><h1 id="0428" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">设计目标的实现</h1><h2 id="8d81" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">1.一个定义，多种用途——可实现，有故障</h2><p id="882b" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Ajv是用TypeScript编写的，可以很好地使用TypeScript。然而，ajv本身并不提供从JSON Schema到TypeScript类型的生成，反之亦然。</p><p id="8fb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是“个人”数据的模式。请注意“dob”属性中使用的自定义关键字“olderThanFromNow ”,以及为“sex”属性提供的默认值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/40e88c1d94496621a49cf4c5e88af3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ShQIg3bDeEweAg3iZ4V16g.png"/></div></figure><p id="d5b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有一些第三方工具可以将JSON模式转换为TypeScript类型。我测试了<a class="ae lt" href="https://www.npmjs.com/package/json-schema-to-typescript" rel="noopener ugc nofollow" target="_blank">JSON-schema-to-type script</a>包。它可以工作，但是有一些小故障。下面是从“Person”模式生成的界面。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1d56cf4f2629c9799a3f9e6cacc57db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*OQ_iTaVC5zL2Q4Ca2gwLaA.png"/></div></figure><p id="5708" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">属性“sex”被类型化为文字类型的联合，并且是可选的，这与模式完全匹配。然而,“dob”属性的类型是错误的，不能给它赋值。</p><p id="6554" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有其他工具以相反的方式工作，从带注释的TypeScript类型生成JSON模式。然而，我发现他们的文件都有点不足。他们能处理自定义验证关键字吗？他们如何处理组合关键词，如“所有的”、“任何的”、“一个的”？这些都是悬而未决的问题。</p><p id="54ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的观点是，最好用JSON Schema编写模式并生成TypeScript类型，而不是相反。首先，JSON Schema拥有比TypeScript类型更丰富的一组关键字(比如最小/最大长度)。其次，JSON Schema是一个定义良好且有文档记录的标准。另一方面，那些用于增强TypeScript类型的注释不像JSON Schema那样定义和记录良好。</p><h2 id="e236" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">2.可组合和可扩展的模式—已实现</h2><p id="e585" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">通过将“$ref”与组合关键字(如“allOf”、“anyOf”和“oneOf”)一起使用，可以组合和扩展现有模式。请阅读“理解JSON模式”一书中的“<a class="ae lt" href="https://json-schema.org/understanding-json-schema/structuring.html#extending" rel="noopener ugc nofollow" target="_blank">扩展</a>”一节，以获得进一步的说明和示例。</p><p id="54fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是“司机”的模式，它是从“人”的模式扩展而来的</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/23dc27f21a84d37f993b313193c75b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*owItbhjo9sVpFMM-uM09pQ.png"/></div></figure><p id="3944" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“车队”模式是通过组装“驾驶员”和“车辆”模式来定义的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/40df47284aa618bfca2ec28751df1377.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*ncOfyXB6dfOwb7w4NbGLUg.png"/></div></figure><p id="97ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了允许模式相互引用，在“$ref”中的路径必须与被引用模式的“$id”相匹配，并且所有的模式都应该被添加到ajv实例中。下面展示了ajv实例是如何构造的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/83fbe354718e79ca591fcd110c45dd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcLzE34xDd65Aw_OMExqLw.png"/></div></div></figure><h2 id="7295" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">3.丰富的功能集—已实现</h2><p id="36cc" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">JSON schema提供了一组丰富的现成的关键字。</p><h2 id="42dd" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">4.完成和中止-早期验证-已实现</h2><p id="9cd7" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">通过提供一个<code class="fe nn no np nq b"><a class="ae lt" href="https://ajv.js.org/options.html#validation-and-reporting-options" rel="noopener ugc nofollow" target="_blank">allErrors</a></code>选项，Ajv可以被配置为执行完整的和提前中止的验证。完整验证的结果提供了数据中发现的所有故障的详细信息。下面是无效车队对象的验证结果的一部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/91d82a76eece85a910623ed7c469e126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*XoLL9oNDeVO5orcmnh03Mw.png"/></div></figure><h2 id="c0e7" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">5.可组合和可定制—存档</h2><p id="3836" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">支持现成的关键字组合。ajv支持自定义关键字。详见ajv文档中的<a class="ae lt" href="https://ajv.js.org/guide/user-keywords.html" rel="noopener ugc nofollow" target="_blank">自定义关键字</a>和ajv项目的<a class="ae lt" href="https://github.com/ajv-validator/ajv/blob/master/docs/keywords.md#define-keyword-with-code-generation-function" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="188d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我用ajv定义自定义关键字的经验是，关于这方面的ajv文档有点含糊不清，不完整(目前有一些断开的链接，我还需要查看ajv的源代码以了解更多信息)。我花了一段时间才弄明白如何创建一个用于数据验证的关键字，甚至花了更多的时间来创建一个用于数据强制的关键字。Ajv允许用四种方法定义关键字:代码生成、验证函数、编译函数和宏函数。代码生成似乎是首选方法，因为所有预定义的关键字都是用这种方法定义的。然而，使用代码生成有点绕弯，很难进行故障排除和调试。</p><p id="2548" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是如何创建两个自定义关键字。关键字“olderThanFromNow”是使用代码生成方法创建的，关键字“toDate”是作为验证函数创建的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/522f42b2180dbbb14e97909e73c77afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*gfmdz31fWXG0H9XryaYXyA.png"/></div></figure><h2 id="19bc" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">6.类型强制和默认—已实现</h2><p id="c1c4" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Ajv有内置的类型强制，遵循这里<a class="ae lt" href="https://ajv.js.org/coercion.html" rel="noopener ugc nofollow" target="_blank">记载的类型强制规则</a>。要启用它，请在ajv实例构造过程中使用<code class="fe nn no np nq b">true</code>传递<code class="fe nn no np nq b">coerceTypes</code>选项。</p><p id="80b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，ajv不提供从ISO日期字符串到日期对象的现成强制。为了实现这一点，我创建了一个自定义关键字“toDate ”,如上所示。custom关键字用强制值替换属性的值。</p><p id="53f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ajv也支持缺省值，这是通过用<code class="fe nn no np nq b">true</code>传递<code class="fe nn no np nq b">useDefaults</code>选项来实现的。</p><h2 id="7e2d" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">7.可遍历模式—已实现</h2><p id="4ecc" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Ajv是基于JSON模式标准的，这是一个定义良好、文档完备的标准。模式只是简单的旧javascript对象，很容易被遍历。</p><h2 id="419a" class="mw ma in bd mb mx my dn mf mz na dp mj kx nb nc ml lb nd ne mn lf nf ng mp nh bi translated">8.标准—是</h2><h1 id="8009" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">摘要</h1><p id="2127" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Ajv是一个基于JSON模式的验证器。如果您希望用标准语言定义您的数据，这可能是您的选择。</p><p id="1280" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，ajv并不是最容易使用的。JSON Schema不难学。"<a class="ae lt" href="https://json-schema.org/understanding-json-schema/" rel="noopener ugc nofollow" target="_blank">理解JSON模式</a>"是一本好书。有了合适的代码编辑器的支持，编写代码也不会太难。然而，与joi和yup等验证器提供的fluent API相比，JSON schema有点冗长。用ajv定义自定义关键字比用其他验证器更复杂，部分原因是模式是在文档中定义的，而不是在代码中定义的，部分原因是没有足够的文档和代码生成。还有，JSON Schema是一个JSON文档，不支持注释，这个事实有点烦人。</p><p id="761c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ajv不支持从模式生成TypeScript类型。我测试了一个第三方工具，结果不太令人满意。</p><p id="e44e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ajv还支持从模式中生成独立验证功能模块的代码。然而，尽管<a class="ae lt" href="https://github.com/ajv-validator/ajv/blob/master/docs/standalone.md" rel="noopener ugc nofollow" target="_blank">文档</a>指出使用独立验证代码的一个原因是它是“预编译的，可以在没有ajv的情况下使用”，但后来该文档提到“Ajv包仍然应该是大多数模式的运行时依赖项，但生成的模块只能依赖于它的一小部分，因此如果您需要应用程序代码中具有独立验证代码的模块，整个Ajv将不会包含在包中(或被执行)。”还有一个限制。使用独立验证代码时，仅支持使用代码生成定义的自定义关键字。</p><p id="b232" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总之，ajv是一个基于明确定义的标准的强大且非常受欢迎的验证器。然而，这可能有点难以操作(至少在开始阶段)。保持TypeScript类型和模式同步可能很棘手。</p></div></div>    
</body>
</html>