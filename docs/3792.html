<html>
<head>
<title>Recursion, Memoization, and the Staircase Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归、记忆和阶梯算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursion-memoization-and-the-staircase-algorithm-f17c337d7657?source=collection_archive---------3-----------------------#2021-07-30">https://javascript.plainenglish.io/recursion-memoization-and-the-staircase-algorithm-f17c337d7657?source=collection_archive---------3-----------------------#2021-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e70c8dc5fac67ce136bc256002a2ed21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HRWVpbqpl9uuy5PE"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@serhatbeyazkaya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Serhat Beyazkaya</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="76a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们进入这些定义之前，让我们先来看看引发这一切的Leetcode问题:楼梯问题。</p><blockquote class="ky kz la"><p id="d612" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">你正在爬楼梯。到达顶端需要<code class="fe lf lg lh li b">n</code>步。</p><p id="5cbe" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">每次你可以爬<code class="fe lf lg lh li b">1</code>或<code class="fe lf lg lh li b">2</code>台阶。有多少种不同的方式可以让你爬上顶峰？</p></blockquote><p id="23af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题乍一看似乎足够简单。你稍微思考一下，然后提出一些基本原则:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="aacd" class="lr ls in li b gy lt lu l lv lw">input: n = 1<br/>output: 1<br/>// 1 step<br/>-----------------------<br/>input: n = 2<br/>output: 2<br/>// 1 step + 1 step<br/>// 2 steps<br/>-----------------------<br/>input n = 3<br/>output: 3<br/>// 1 step + 1 step + 1 step<br/>// 2 steps + 1 step<br/>// 1 step + 2 steps</span></pre><p id="acfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没那么难。但是当你有一个40度的楼梯时会发生什么呢？不仅你的四边形会燃烧，而且你还会得到如此多的分支路径决策。</p><h1 id="b2d9" class="lx ls in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">思维过程</h1><p id="3497" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">当你问自己这个简单的问题时，这个问题的症结就打开了:<em class="lb">“我可以从哪些步骤到达第n步？”</em></p><p id="1f89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第n步只能从<code class="fe lf lg lh li b">n-1</code>和<code class="fe lf lg lh li b">n-2</code>步到达，因为那是你能迈出的最大一步。所以，如果我们把到达n-1步的所有方法加起来，再加上到达n-2步的所有方法，我们就应该得到答案了！例:如果<code class="fe lf lg lh li b">n = 4</code>，我们需要做的就是把<code class="fe lf lg lh li b">n = 3 </code>和<code class="fe lf lg lh li b">n = 2</code>相加，得到我们的答案。有了这两条路径，我们可以进一步缩小范围。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/2960b1126a673108f1f1740298a59645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MJvmugkEqZ5jWBkSPjXgw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Representation of n=4 steps</figcaption></figure><h1 id="2fc7" class="lx ls in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">天真的解决方案</h1><p id="8533" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">所有这些重复和缩小到一个单一的情况开始听起来很熟悉。看来我们的好朋友<strong class="kc io">递归要来拜访我们了。</strong></p><p id="6f4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于那些不了解递归的人，FreeCodeCamp的Beau Carnes写了一篇很好的文章，解释了你可以在这里阅读的基础知识。现在，我将复习一下最低限度。</p><p id="9d1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在递归中，你需要一个<strong class="kc io">基础用例</strong>，和一个<strong class="kc io">递归用例</strong>。基本情况告诉你什么时候停止调用你的函数(也就是说，我们知道如果n=1，我们总是返回1)。递归情况调用<em class="lb">本身</em>并改变输入，所以我们将其缩小到基本情况。</p><p id="1be2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个简单解决方案的基本代码:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="4395" class="lr ls in li b gy lt lu l lv lw">function climbStairs(n) {</span><span id="e302" class="lr ls in li b gy na lu l lv lw">    if (n === 1 || n === 0) return 1;</span><span id="d415" class="lr ls in li b gy na lu l lv lw">    return climbStairs(n - 1) + climbStairs(n - 2)<br/>}</span></pre><p id="eeb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！然而，有一个问题。这种递归需要很多时间。我说的很多是指很多。让我们回头看看我们的图表。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/9ad9c2613d65c79d48544cc50f6eb65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arI5xlFA3njMZs_U8naxJg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Recursion Tree</figcaption></figure><p id="d5dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会注意到树的两个圈起来的部分是完全相同的，并且将返回相同的值。随着增长，很快我们将会有数以千计的小函数被反复调用。如果有一种方法可以告诉函数记住越来越大的输入值，那么我们就不必处理同一个函数被多次调用的情况了。进入<strong class="kc io">记忆</strong>。</p><h1 id="7f93" class="lx ls in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">记忆化</h1><p id="4f05" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">事实证明，我们的函数有办法记住之前递归循环的答案。记忆化就是准确记录这一过程。因为在一个对象中搜索需要相对较少的时间，如果我们将输入/答案作为键/值对保存在一个对象中，我们可以跟踪我们的循环并大大加快我们的运行时间。</p><p id="b2c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们所要做的就是使用一个助手函数来检查memo对象的值<code class="fe lf lg lh li b">n</code>。如果它找到了，太好了！如果没有，我们仍然可以做递归，并继续循环。这只是确保我们不会重复大量的递归代码。</p><p id="bf7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它看起来是这样的:</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/df2cfa5aec2a89396e49a46d241ea5f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BunflZ_PBJB8pKRHiW0pRg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">climbStairs() with memoization</figcaption></figure><p id="0b9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到我们声明了一个<code class="fe lf lg lh li b">memo</code>对象和一个<code class="fe lf lg lh li b">helper</code>函数来进行递归。第6行检查我们的当前值<code class="fe lf lg lh li b">n</code>是否已经在我们的备忘录中。如果是，则将<code class="fe lf lg lh li b">value</code>的值设置为该值，然后在线路16上返回所述值。然而，如果我们不知道值，我们可以重复我们最初的递归代码块(第9-13行)。最后，我们确保用我们发现的这个新值更新我们的备忘录。最后，在第18行，我们用原始的<code class="fe lf lg lh li b">n</code>调用我们的助手函数，它将返回我们所寻求的答案。</p><h1 id="b988" class="lx ls in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="c625" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">虽然楼梯问题一开始看起来很抽象和混乱，但是一旦你把它分解成一个简单的递归问题，它就变得更容易处理了。最后，用记忆化来分解我们缓慢的递归大大提高了这个函数的时间复杂度。想想看，每一次<code class="fe lf lg lh li b">n</code>增加，我们必须进行的函数调用的数量几乎翻倍。通过记忆化和Javascript对象的快速访问，我们将时间复杂度从大约O(1.68ⁿ降低到了O(n)。这是一个巨大的差异。例如，40步和41步之间的差别是大约60，000，000种不同的组合。</p><p id="d994" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题到此为止。和往常一样，欢迎发表评论，谈谈你自己的递归或记忆之旅。感谢阅读！</p><p id="4b31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>