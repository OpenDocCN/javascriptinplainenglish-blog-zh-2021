<html>
<head>
<title>Angular Note To Self: Manage State Through StateAtoms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自我提醒:通过状态原子管理状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-note-to-self-manage-state-through-stateatoms-3f395763b895?source=collection_archive---------5-----------------------#2021-02-09">https://javascript.plainenglish.io/angular-note-to-self-manage-state-through-stateatoms-3f395763b895?source=collection_archive---------5-----------------------#2021-02-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/d92c77a2d2b90641e53ca7f4d3e9b460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m74Qw1DuC1T4Otpv"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Photo by <a class="ae kd" href="https://unsplash.com/@les_photos_de_raph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Raphaël Biscaldi</a> on <a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d70a" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当谈到Angular应用程序中的基本状态管理时，我是这样做的。除了RxJS之外，它不需要其他库。</p><h2 id="742b" class="lc ld ir bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">状态原子</h2><p id="ea73" class="pw-post-body-paragraph ke kf ir kg b kh lv kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ik bi translated">没找到更好的名字，就叫<strong class="kg is">态原子</strong>。这是一个存储和跟踪单个值的类——一个原语、一个对象或一个数组。我们用一个<code class="fe ma mb mc md b">BehaviorSubject</code>来存储值，用一个<code class="fe ma mb mc md b">Observable</code>来通知变化。此外，很少有方便的类方法来更新和重置值。</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig 1: State Atom class</figcaption></figure><p id="7c65" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">只有状态原子不足以进行状态管理。相反，我们将编写一个助手服务来实现业务逻辑，同时消除复杂性，并使其易于对更改和加载数据做出反应。</p><h2 id="ece0" class="lc ld ir bd le lf lg dn lh li lj dp lk kp ll lm ln kt lo lp lq kx lr ls lt lu bi translated">国家服务</h2><p id="4175" class="pw-post-body-paragraph ke kf ir kg b kh lv kj kk kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ik bi translated">我喜欢让我的控制器瘦，服务胖。因此，例如，我将为<code class="fe ma mb mc md b">ArticleViewPageComponent</code>创建一个特定的服务<code class="fe ma mb mc md b">ArticleViewPageStateService</code>。<code class="fe ma mb mc md b">root</code>范围内不提供服务。相反，我将把它<strong class="kg is">注入到组件</strong>中，因为这个服务应该和组件有相同的生命周期:</p><pre class="me mf mg mh gu mk md ml mm aw mn bi"><span id="de9e" class="lc ld ir md b gz mo mp l mq mr">@Component({<br/>    templateUrl: './view-article-page.component.html',<br/>    styleUrls: ['./view-article-page.component.scss'],<br/>    <strong class="md is">providers: [ViewArticlePageStateService]</strong>,<br/>})<br/>export class ViewArticlePageComponent implements OnInit {}</span></pre><p id="5904" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我为状态创建了一个接口，以确保正确的类型。仅仅为了这个例子，设想一个页面，其中显示了一篇文章，并且与该文章相关联的评论以分页的方式显示。每次我的页面获取数据和更新视图时，我都会显示一个加载指示器。因此，页面状态可能如下所示:</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig 2: Page State interface and initial value</figcaption></figure><p id="d9e6" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现在，在<code class="fe ma mb mc md b">ViewArticlePageStateService</code>中，我将介绍原子。原子需要一个初始状态。所以我将在<code class="fe ma mb mc md b">initialState</code>对象中定义的初始值传递给每个原子。</p><p id="aefa" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">原子暴露了其存储值的可观察性。这意味着如果我们通过<code class="fe ma mb mc md b">combineLatest</code> RxJS操作符收集所有原子的值，那么我们将总是得到最新的状态。</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig 3: Building the state with atoms</figcaption></figure><p id="1cd6" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们可以跟踪特定的原子值是否被改变。基于此，我们可以更新状态的其他属性。这是使用副作用的最佳地方，比如从服务器加载数据。我们在页面状态服务的实例化过程中注册了<code class="fe ma mb mc md b">handleEffects()</code>触发器，它一直运行到服务被销毁。</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig 4: Registering side effects</figcaption></figure><p id="baf8" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了理解这里的机制，让我们考虑当任何一个<code class="fe ma mb mc md b">_start,_limit</code>或<code class="fe ma mb mc md b">_sort</code>查询参数改变时，我们想要加载注释。为此，我在效果处理器中点击<code class="fe ma mb mc md b">commentsPagination</code>流(通过<code class="fe ma mb mc md b">combineLatest</code>)。每当有新的值时，我们将它传递给<code class="fe ma mb mc md b">switchMap</code>操作符，并从<code class="fe ma mb mc md b">commentService</code>加载注释。SwitchMap用于取消之前的呼叫。如果您认为由于您在效果处理程序中跟踪许多atom值而导致调用过多，那么您可以使用<code class="fe ma mb mc md b">debounceTime</code>操作符来最小化这个数量。最后，我更新了subscribe块中的状态。</p><p id="9344" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这只是一个例子。您可以使用更多的处理程序来完成必要的副作用，例如从多个REST服务加载数据、进行计算等。</p><p id="9343" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">最后，我添加了更多的类方法来方便状态的操作，比如<code class="fe ma mb mc md b">reset(), getStateSnapshot(), updateXyz()</code>等。下面是整个StateService的样子:</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Fig 5: StateService to be provided in the page component</figcaption></figure><p id="c86d" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们已经完成了简单的状态管理器。让我们看看如何在页面组件中使用它。</p><figure class="me mf mg mh gu js"><div class="bz fq l di"><div class="mi mj l"/></div></figure><p id="7bae" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这种国家服务提供了许多优势:</p><ul class=""><li id="20c9" class="ms mt ir kg b kh ki kl km kp mu kt mv kx mw lb mx my mz na bi translated">我可以安全地使用<code class="fe ma mb mc md b">OnPush</code>变更检测策略，而不用担心bug。</li><li id="e185" class="ms mt ir kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated">所有的模板变量都位于<code class="fe ma mb mc md b">state$</code> observable内部。在模板中使用with <code class="fe ma mb mc md b">async</code> pipe时，它会自动退订，让您高枕无忧。</li><li id="01da" class="ms mt ir kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated">架构变得干净，真正的反应。我更新状态原子，状态服务反映原子的变化。</li><li id="4ea3" class="ms mt ir kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated">数据单向流动，因此更容易调试。</li><li id="05bd" class="ms mt ir kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated">我可以突然提高单元可测试性，因为服务中的方法更小了。组件控制器的责任很小。</li><li id="10b6" class="ms mt ir kg b kh nb kl nc kp nd kt ne kx nf lb mx my mz na bi translated">我可以对多个组件使用相同的状态服务。</li></ul><p id="99c6" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这种方法是托马斯·伯利森这篇伟大文章的略微修改版本:</p><div class="ng nh gq gs ni nj"><a href="https://thomasburlesonia.medium.com/push-based-architectures-with-rxjs-81b327d7c32d" rel="noopener follow" target="_blank"><div class="nk ab fp"><div class="nl ab nm cl cj nn"><h2 class="bd is gz z fq no fs ft np fv fx iq bi translated">具有RxJS的基于推送的架构</h2><div class="nq l"><h3 class="bd b gz z fq no fs ft np fv fx dk translated">你一直编码错误！</h3></div><div class="nr l"><p class="bd b dl z fq no fs ft np fv fx dk translated">thomasburlesonia.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jx nj"/></div></div></a></div><p id="2f1c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">感谢阅读！</p></div></div>    
</body>
</html>