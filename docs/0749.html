<html>
<head>
<title>Create A ‘Control Room’ for Client-Side Rendered Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为客户端呈现的应用程序创建一个“控制室”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-control-room-for-client-side-rendered-apps-31047e011a37?source=collection_archive---------10-----------------------#2021-02-15">https://javascript.plainenglish.io/a-control-room-for-client-side-rendered-apps-31047e011a37?source=collection_archive---------10-----------------------#2021-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c39d1aea36f9360b05cac71871cf1053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juz4GiIRp2awqV0jVVUG6g.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@hectorfarahani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Hector Farahani</a> on <a class="ae ja" href="https://unsplash.com/s/photos/yazd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="17f7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不确定这个帖子的标题，我想了24个小时，没有找到更好的，所以就叫它<em class="ky">“为客户端渲染的前端应用程序创建控制室！”</em> \_(ツ)_/。<br/>如果你需要与你的前端应用程序进行一些<code class="fe kz la lb lc b">States</code>交流，这种模式是有益的，正如我们所知，对于客户端渲染应用程序来说，存在一些挑战。在这篇文章中，我将通过一个例子给你一个全面的描述。</p><h2 id="d1c2" class="ld le jd bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated"><strong class="ak">客户端渲染应用</strong></h2><p id="8dd0" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">部署前端应用程序最简单的方法是构建它，并将资产(Javascript、CSS、HTML等)推送到您的服务器(或无服务器)，并让应用程序在客户端呈现(而不是服务器端呈现)。一个非常常见的例子是构建一个React应用程序，并将其推送到AWS S3，然后就这样了！但这种方法有一个问题，即在客户端渲染后，你无法控制应用程序的<strong class="kc je">状态</strong>，如果你正在处理一个每天有很多用户的企业应用程序，这是一个非常重要的问题。</p><p id="8abd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果由于一些API迁移或API服务上的一些基础设施任务，您需要将应用程序置于维护窗口中，您如何处理这种情况？你发布一个新版本来更新你的应用程序<strong class="kc je">状态</strong>吗？</p><p id="e82d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个例子是，每当你发布一个新版本时，使用你的应用程序的用户在刷新他们的页面之前不知道新版本，因此，如果你部署了一个新版本的API服务，需要在前端进行一些更改，你如何让用户知道他们需要刷新他们的页面以获得最新版本？</p><h2 id="bce9" class="ld le jd bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated"><strong class="ak">适用于所有场景的通用解决方案</strong></h2><p id="82fc" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">底线是我们想为我们的前端应用程序创建一个控制室。我想在这里谈论的解决方案是众多解决方案中的一个，它不一定是最好的，但如果你正在开发一个需要这种级别控制的应用程序，你可以考虑一下。</p><p id="f979" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在这里的方法是让我们添加一个可以发送<code class="fe kz la lb lc b">messages</code>到我们的前端应用程序的<code class="fe kz la lb lc b">Web Socket Server</code>，然后前端应用程序可以处理这些消息。在我们进入细节之前，让我们先来看看我的演示应用。</p><h2 id="7a5d" class="ld le jd bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated"><strong class="ak">新版本可用</strong></h2><p id="755b" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了演示的目的，我创建了一个超级简单的React应用程序(几乎是空的)，你可以在这里看到部署的版本<a class="ae ja" href="http://websocket-app.s3-website-us-east-1.amazonaws.com/" rel="noopener ugc nofollow" target="_blank"/>并查看代码，你可以检查这个<a class="ae ja" href="https://github.com/mostafa-drz/better-client-side-react" rel="noopener ugc nofollow" target="_blank">库</a>。让我们看一下部署脚本:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="48fd" class="ld le jd lc b gy mj mk l ml mm">"prepush":"yarn build",<br/>"push": "aws s3 sync --delete build s3://websocket-app --profile websocket",<br/>"postpush": "node postPush.js"</span></pre><p id="55c1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">部署脚本包括构建资产，然后将其推送到S3。我们不会在这篇文章中讨论React的应用部署，但如果你感兴趣，你可以看看这篇<a class="ae ja" href="https://www.newline.co/fullstack-react/articles/deploying-a-react-app-to-s3/" rel="noopener ugc nofollow" target="_blank">文章</a>。我们的重点是<code class="fe kz la lb lc b">postpush</code>中发生的事情，我们的目标是向我们的前端应用程序发送一条<strong class="kc je">消息</strong>，让用户知道有一个新版本可用，他们需要刷新他们的页面才能获得它。</p><figure class="mb mc md me gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mn"><img src="../Images/e8eb67fc2b1b63f8145b36ffb63ef8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Zs-ac9FhpRXvFzETCMatrQ.gif"/></div></div></figure><h2 id="9069" class="ld le jd bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated"><strong class="ak">如何？</strong></h2><p id="186a" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我浏览代码之前，我应该提到，在这篇文章中，我不想浏览一个生产就绪的解决方案，因为它可能会因不同的交付解决方案和管道而有所不同，我只想让您对这种方法有一个总体的了解。</p><p id="34fc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了实现这种方法，我使用了<code class="fe kz la lb lc b">Web Sockets</code>。如果你从未与<code class="fe kz la lb lc b">Web Sockets</code>合作过，你所需要知道的就是与HTTP协议相比，没有任何请求。<code class="fe kz la lb lc b">Clients</code>打开与<code class="fe kz la lb lc b">server</code>的连接，然后他们等待来自服务器的消息(这正是我们想要的！)如果你想了解更多关于web sockets的知识，你可以阅读这篇文章。</p><p id="b820" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于前端，我创建了一个<code class="fe kz la lb lc b">Context</code>，它在顶层包装了整个应用程序，并将负责打开与我们的<code class="fe kz la lb lc b">Web Socket Server</code>的连接，每当它收到消息时，就根据<code class="fe kz la lb lc b">messageId</code>和消息提供的更多数据采取行动。当我们的应用程序加载时，在<code class="fe kz la lb lc b">useEffect</code>中，我们连接到我们的Web Socket服务器，然后我们监听所有传入的消息:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="781d" class="ld le jd lc b gy mj mk l ml mm">useEffect(() =&gt; {<br/>    socket.current.onopen = function (e) {<br/>      console.info("[open] Connection established");<br/>    };<br/>    socket.current.onerror = function (error) {<br/>      console.error(`[error] ${error}`);<br/>    };</span><span id="6be3" class="ld le jd lc b gy mo mk l ml mm">socket.current.onmessage = function (event) {<br/>      const data = JSON.parse(event.data);<br/>      switch (data.messageId) {<br/>        case "new-version":<br/>          notify.show(<br/>            &lt;div&gt;<br/>              &lt;h2&gt;Sorry to intrupt you 🙈&lt;/h2&gt;<br/>              &lt;p&gt;<br/>                A new version of our App is available and to get the latest<br/>                features you should refresh your page<br/>              &lt;/p&gt;<br/>              &lt;button onClick={() =&gt; window.location.reload()}&gt;Reload&lt;/button&gt;<br/>            &lt;/div&gt;,<br/>            "warning",<br/>            -1<br/>          );</span><span id="c21c" class="ld le jd lc b gy mo mk l ml mm">break;<br/>        case "maintenance":<br/>          if (data.status === "on") {<br/>            notify.show(<br/>              &lt;div&gt;<br/>                &lt;h2&gt;Sorry to intrupt you 🙈&lt;/h2&gt;<br/>                &lt;p&gt;{data.message}&lt;/p&gt;<br/>                &lt;button onClick={() =&gt; notify.hide()}&gt;Ok&lt;/button&gt;<br/>              &lt;/div&gt;,<br/>              "warning",<br/>              -1<br/>            );<br/>            setMaintWindow(true); <br/>          } else {<br/>            setMaintWindow(false);<br/>          }<br/>          break;<br/>        default:<br/>          break;<br/>      }<br/>    };<br/>  }, []);</span></pre><p id="0875" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里看到前端应用<a class="ae ja" href="https://github.com/mostafa-drz/better-client-side-react" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p><p id="0881" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在在后端，为了演示的目的，我创建了一个简单的HTTP和Web Socket服务器。HTTP服务器是为了能够向控制室服务发送一些事件(我喜欢，很花哨的名字，控制室！😅)然后控制室将消息服务<code class="fe kz la lb lc b"><strong class="kc je">Broadcasts</strong></code>给所有连接的客户端。让我们来看看服务器代码，它非常简单:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="b01b" class="ld le jd lc b gy mj mk l ml mm">const WebSocket = require("ws");<br/>const express = require("express");<br/>const app = express();<br/>const http = require("http");<br/>const server = http.createServer(app);<br/>const PORT = process.env.PORT || 8080;<br/>const path = require("path");</span><span id="1df9" class="ld le jd lc b gy mo mk l ml mm">app.use(express.json());<br/>let wss;</span><span id="82fe" class="ld le jd lc b gy mo mk l ml mm">app.post("/api/message", function (req, res) {<br/>  const { messageId, messageBody } = req.body;<br/>  switch (messageId) {<br/>    case "new-version":<br/>      broadCastToAllClients(<br/>        wss,<br/>        JSON.stringify({<br/>          messageId,<br/>          newVersion: messageBody.version,<br/>        })<br/>      );<br/>      return res.send("ok");<br/>    case "maintenance":<br/>      broadCastToAllClients(<br/>        wss,<br/>        JSON.stringify({<br/>          messageId,<br/>          message: messageBody.message,<br/>          status: messageBody.status,<br/>        })<br/>      );<br/>      return res.send("ok");<br/>    default:<br/>      return res.status(400).send("what do you mean?");<br/>  }<br/>});</span><span id="8483" class="ld le jd lc b gy mo mk l ml mm">app.get("/", (req, res) =&gt; {<br/>  res.sendFile(path.resolve(__dirname, "index.html"));<br/>});</span><span id="ee0b" class="ld le jd lc b gy mo mk l ml mm">app.get("/api/ping", (req, res) =&gt; {<br/>  res.send("PONG");<br/>});</span><span id="0616" class="ld le jd lc b gy mo mk l ml mm">server.listen(PORT, (error) =&gt; {<br/>  if (error) {<br/>    console.error(`Something went wrong on Express Server 💔`);<br/>  } else {<br/>    console.log(`Express server is running on port ${PORT}`);<br/>    wss = new WebSocket.Server({ server });<br/>  }<br/>});</span><span id="9187" class="ld le jd lc b gy mo mk l ml mm">function broadCastToAllClients(wsServer, message) {<br/>  wsServer.clients.forEach(function each(client) {<br/>    if (client.readyState === WebSocket.OPEN) {<br/>      client.send(message);<br/>    }<br/>  });<br/>}</span></pre><p id="7659" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢尝试，你可以在两个不同的标签上打开前端应用程序和Web Socket服务，然后尝试一下:</p><p id="c055" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">前端应用:<a class="ae ja" href="http://websocket-app.s3-website-us-east-1.amazonaws.com/" rel="noopener ugc nofollow" target="_blank">http://websocket-app.s3-website-us-east-1.amazonaws.com/</a><br/>Web Socket服务:<a class="ae ja" href="https://thawing-depths-04303.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://thawing-depths-04303.herokuapp.com/</a><br/>你可以在前端应用上尝试那些简单的命令，看看结果。<br/>既然您已经尝试了演示应用，让我们回到我们的<code class="fe kz la lb lc b">publish</code>脚本，看看<code class="fe kz la lb lc b">postpush</code>做了什么:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="c494" class="ld le jd lc b gy mj mk l ml mm">"postpush": "node postPush.js"</span></pre><p id="120f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而<code class="fe kz la lb lc b">postPush.js</code>:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="f55f" class="ld le jd lc b gy mj mk l ml mm">const fetch = require("node-fetch");</span><span id="cb9a" class="ld le jd lc b gy mo mk l ml mm">const body = {<br/>  messageId: "new-version",<br/>  messageBody: {<br/>    version: "1.1.1",<br/>  },<br/>};</span><span id="7b1f" class="ld le jd lc b gy mo mk l ml mm">fetch("<a class="ae ja" href="https://thawing-depths-04303.herokuapp.com/api/message" rel="noopener ugc nofollow" target="_blank">https://thawing-depths-04303.herokuapp.com/api/message</a>", {<br/>  method: "POST",<br/>  headers: { "Content-Type": "application/json" },<br/>  body: JSON.stringify(body),<br/>})<br/>  .then((resp) =&gt; resp.text())<br/>  .then((data) =&gt; console.log(data))<br/>  .catch((error) =&gt; console.log("Ooops", error));</span></pre><p id="0116" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在这个脚本中看到的，我们所做的就是向我们的<code class="fe kz la lb lc b">Control Room Service</code>发送一个<code class="fe kz la lb lc b">POST</code>请求，让它知道有一个新的前端版本，这样它就可以向所有连接的客户端广播消息。</p><h2 id="c96d" class="ld le jd bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated"><strong class="ak">结论</strong></h2><p id="36a1" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">客户端渲染应用带来了一些挑战，在这篇文章中，我试图向你展示一种方法，你可以用它来更好地控制它们。基于您的管道，您可能能够以不同的方式实现它。</p><p id="a4c4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢我的<em class="ky">控制室服务</em>😉</p><p id="e01f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意安全，🤿</p><p id="6d49" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://www.linkedin.com/in/mostafa-darehzereshki/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je"> <em class="ky">穆斯塔法</em> </strong> </a></p></div></div>    
</body>
</html>