<html>
<head>
<title>June 3: Parsing and validating SVG paths with regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6月3日:用regex解析和验证SVG路径</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/june-3-parsing-and-validating-svg-paths-with-regex-7bd0e245115?source=collection_archive---------10-----------------------#2021-06-03">https://javascript.plainenglish.io/june-3-parsing-and-validating-svg-paths-with-regex-7bd0e245115?source=collection_archive---------10-----------------------#2021-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/82db87211ce7f4cc9319175e22aa56a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mY1W2J7GelOkgZrvch_UMw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo credit: Milton Bradley Company</figcaption></figure><blockquote class="jz ka kb"><p id="a871" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">感谢Yann Armelin在这个课题上的惊人工作。</p></blockquote><p id="8ba0" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">没有什么比矢量图形更令人愉快的了。使用光栅图形时，对角线和曲线看起来都很脆，很难定义，但是使用矢量时，它们在任何比例下都无比光滑和清晰。矢量文件轻如鸿毛，尤其是与JPEGs相比，所以加载时间可以忽略不计，性能很快。</p><p id="e993" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">在今天的博文中，我们将深入探讨我在矢量图形个人工作中遇到的一个任务:<strong class="kf io">解析和验证路径描述符。</strong>我认为它将为SVG的活动部分提供一些深刻的见解，因为它触及了如此多的SVG。</p><h1 id="fe66" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">背景:用一个标签来管理它们</h1><p id="fe51" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">大多数图像文件都是光栅图形文件，本质上就是巨大的像素阵列。<strong class="kf io">矢量图形，</strong>另一方面，用标准化语法定义笛卡尔(二维)平面上的点。这个概念是在50年代为空军和后来的民用空中交通管制使用的计算机而创造的，现在在消费计算机上普遍使用。</p><p id="1773" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">web上矢量图形的主导标准，<strong class="kf io">可缩放矢量图形(SVG)，</strong>大约有20年的历史了。您可以在任何文本编辑器中打开一个<code class="fe mi mj mk ml b">.svg</code>文件，如果您这样做了，您会看到表面上类似于HTML的语法:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e940" class="mu lg in ml b gy mv mw l mx my">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>   &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;<br/>   &lt;svg version="1.1"  xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="522px" height="522px" viewBox="0 0 522 522" enable-background="new 0 0 522 522" xml:space="preserve"&gt;<br/>...</span></pre><p id="253d" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">它实际上只是XML，是HTML的表亲。没错:<strong class="kf io">只是文本标记。这使得用JavaScript操作它变得轻而易举，因为形状被表示为熟悉的标签。</strong></p><h1 id="980c" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">正义之人的道路</h1><p id="2fc6" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">SVG库中有一些<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes" rel="noopener ugc nofollow" target="_blank">基本形状</a>——基本的<code class="fe mi mj mk ml b">&lt;line&gt;</code>段，由像<code class="fe mi mj mk ml b">&lt;polyline&gt;</code>、<code class="fe mi mj mk ml b">&lt;rect&gt;</code>角和<code class="fe mi mj mk ml b">&lt;polygon&gt;</code> s这样的线段组成的形状，以及像<code class="fe mi mj mk ml b">&lt;circle&gt;</code> s和<code class="fe mi mj mk ml b">&lt;ellipse&gt;</code> s这样的曲线形状。但是今天我们将把重点放在最重要的SVG元素上:<code class="fe mi mj mk ml b">&lt;path&gt;</code>。它是如此强大<strong class="kf io">它可以取代所有其他元素；</strong>使用Adobe Illustrator等典型矢量图形编辑器创建的大多数SVG文件都是90% <code class="fe mi mj mk ml b">&lt;path&gt;</code>标签。</p><p id="09f7" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">所有的SVG标签都有各种各样的样式属性。有些是不言自明的样式属性，如<code class="fe mi mj mk ml b">stroke=</code>和<code class="fe mi mj mk ml b">fill=</code>，但重要的是特定于每个标签的属性，定义了形状的基本外观。一个<code class="fe mi mj mk ml b">&lt;path&gt;</code>标签<em class="ke">需要</em>的唯一属性是一个<strong class="kf io">描述符</strong>属性，用<code class="fe mi mj mk ml b">d=</code>定义:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="943e" class="mu lg in ml b gy mv mw l mx my">&lt;path d="M 0 397.833 c 9.688 1.337 17.864 1.417 27.229 -0.735 c 7.506 -1.725 15.587 0.872 23.494 -0.734 c 13.812 -2.807 16.568 -19.019 29.683 -23.269..." /&gt;</span></pre><p id="d150" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">路径的描述符是一系列连锁的<strong class="kf io">命令</strong>(字母)，可以是<strong class="kf io">绝对</strong>(大写)或<strong class="kf io">相对</strong>(小写)，后跟一个或多个标准格式的<strong class="kf io">参数</strong>(数字)。absolute命令的参数表示相对于视图框的坐标；相对命令的参数表示相对于形状中上一点的坐标。这意味着下面的两个标签将绘制相同的形状:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="d80c" class="mu lg in ml b gy mv mw l mx my">&lt;path d="M 25 25 L 75 25 L 75 75 L 25 75 Z" /&gt; // absolute commands</span><span id="4ce7" class="mu lg in ml b gy mz mw l mx my">&lt;path d="m 25,25 l 50,0 l 0,50 l -50,0 z" /&gt; // relative commands</span></pre><p id="a2e3" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">允许混合使用绝对命令和相对命令，但不鼓励这样做。</p><p id="d1e6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">六种类型的路径命令是:</p><ul class=""><li id="d2d8" class="na nb in kf b kg kh kk kl lc nc ld nd le ne la nf ng nh ni bi translated"><strong class="kf io">招:</strong> <code class="fe mi mj mk ml b">M</code>，<code class="fe mi mj mk ml b">m</code></li><li id="a8ff" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated"><strong class="kf io">行:</strong><code class="fe mi mj mk ml b">L</code><code class="fe mi mj mk ml b">l</code><code class="fe mi mj mk ml b">H</code><code class="fe mi mj mk ml b">h</code><code class="fe mi mj mk ml b">V</code><code class="fe mi mj mk ml b">v</code></li><li id="35bf" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated"><strong class="kf io">立方曲线:</strong><code class="fe mi mj mk ml b">C</code><code class="fe mi mj mk ml b">c</code><code class="fe mi mj mk ml b">S</code><code class="fe mi mj mk ml b">s</code></li><li id="f197" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated"><strong class="kf io">四次曲线:</strong><code class="fe mi mj mk ml b">Q</code><code class="fe mi mj mk ml b">q</code><code class="fe mi mj mk ml b">T</code><code class="fe mi mj mk ml b">t</code></li><li id="a0c9" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated"><strong class="kf io">圆弧曲线:</strong> <code class="fe mi mj mk ml b">A</code>，<code class="fe mi mj mk ml b">a</code></li><li id="7fc2" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated"><strong class="kf io">关闭:</strong> <code class="fe mi mj mk ml b">Z</code>，<code class="fe mi mj mk ml b">z</code></li></ul><p id="e871" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">假设你正在写一个矢量编辑器或者一个矢量游戏。如果是的话，您可能需要一种快速、简单的方法来获取整数，这些整数表示定义SVG形状的坐标，以便它们能够正确显示和碰撞。事实上，这正是像<a class="ae lb" href="http://snapsvg.io/" rel="noopener ugc nofollow" target="_blank"> Snap </a>和<a class="ae lb" href="https://github.com/svgdotjs" rel="noopener ugc nofollow" target="_blank"> SVG.js </a>这样的软件包所做的——但是，与其使用软件包，不如让我们亲自动手编写一些逻辑代码。</p><h1 id="1a13" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一种方法:用正则表达式验证SVG路径</h1><p id="91d4" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">我的方法将使用<strong class="kf io"> regex，</strong> <a class="ae lb" href="https://joshgoestoflatiron.medium.com/january-23-a-word-matching-game-using-regular-expressions-in-ruby-19268bb92c02" rel="noopener">，我在之前的</a>博客中已经讨论过了，强调每次我这样做的时候，写它就像切一个疖子一样有趣。我尽我所能召唤这些<strong class="kf io">被诅咒的式神</strong>来验证命令并从字符串中提取它们:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2b7e" class="mu lg in ml b gy mv mw l mx my">const validCommand = /([ml](\s?-?((\d+(\.\d+)?)|(\.\d+)))[,\s]?(-?((\d+(\.\d+)?)|(\.\d+))))|([hv](\s?-?((\d+(\.\d+)?)|(\.\d+))))|(c(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){5})|(q(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){3}(\s?t?(\s?-?((\d+(\.\d+)?)|(\.\d+)))[,\s]?(-?((\d+(\.\d+)?)|(\.\d+))))*)|(a(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){2}[,\s]?[01][,\s]+[01][,\s]+([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){2})|(s(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){3})|z/ig;</span><span id="dcd0" class="mu lg in ml b gy mz mw l mx my">const isValidDescriptor = /^m(\s?-?((\d+(\.\d+)?)|(\.\d+)))[,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(([ml](\s?-?((\d+(\.\d+)?)|(\.\d+)))[,\s]?(-?((\d+(\.\d+)?)|(\.\d+))))|([hv](\s?-?((\d+(\.\d+)?)|(\.\d+))))|(c(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){5})|(q(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){3}(\s?t?(\s?-?((\d+(\.\d+)?)|(\.\d+)))[,\s]?(-?((\d+(\.\d+)?)|(\.\d+))))*)|(a(\s?-?((\d+(\.\d+)?)|(\.\d+)))([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){2}[,\s]?[01][,\s]+[01][,\s]+([,\s]?(-?((\d+(\.\d+)?)|(\.\d+)))){2}))[,\s]?)+z/ig;</span></pre><blockquote class="jz ka kb"><p id="68b3" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">完全公开:这两种方法都让一些极端的边缘情况溜走了，但是它们捕捉到了大量有效的路径，对于一些凌晨2点的本地主机来说已经足够好了。</p></blockquote><p id="0570" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这两个表达式看起来都像一家失火的儿童医院，因为有效的SVG路径有多种形式:路径命令参数通常必须用空格分隔，但在某些情况下可以用逗号、负/十进制符号分隔，或者根本不用分隔。显然，Regex中的分支并不好看；这里是通过一个<code class="fe mi mj mk ml b">()</code>捕获组列表来完成的，由于正则表达式或<code class="fe mi mj mk ml b">|</code>元字符，任何一个捕获组都将触发一个匹配，就像这样:<code class="fe mi mj mk ml b">()|()|()|...</code>路径命令根据它们必须接受的参数数量来分别处理。</p><h2 id="3f08" class="mu lg in bd lh no np dn ll nq nr dp lp lc ns nt lt ld nu nv lx le nw nx mb ny bi translated">这种方法的局限性和副作用</h2><p id="b67d" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated"><code class="fe mi mj mk ml b">.match()</code> <code class="fe mi mj mk ml b">validCommand</code>的能力出头就好了...</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6666" class="mu lg in ml b gy mv mw l mx my">const shape1 = "m 150,150 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0 z";<br/>const shape2 = "m 40 254 s 35 -27 30 -69 s 33 -49 75 -25 z";<br/>const wrongShape = "m l 250 a -400, -350 .";</span><span id="c153" class="mu lg in ml b gy mz mw l mx my">isValidDescriptor.test( shape2 )<br/>   -&gt; true<br/>isValidDescriptor.test( wrongShape )<br/>   -&gt; false</span><span id="061c" class="mu lg in ml b gy mz mw l mx my">shape1.match( validCommand )<br/>   -&gt; [ 'm 150,150', 'a 25,25 0 1,1 50,0', 'a 25,25 0 1,1 -50,0', 'z' ]</span><span id="c9e2" class="mu lg in ml b gy mz mw l mx my">shape2.match( validCommand ).map( command =&gt; command.split( /[\s,]/ ).map( parameter =&gt; parseInt( parameter ) || parameter ) );<br/>   -&gt; [ [ 'm', 40, 254 ], [ 's', 35, -27, 30, -69 ], [ 's', 33, -49, 75, -25 ], [ 'z' ] ]</span></pre><p id="1fd8" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">但是JavaScript中这种语法的简单和清晰是以regex中的绝对垃圾火为代价的。正则表达式通常以指数时间运行，因此它们容易受到一种独特的攻击，即所谓的邪恶正则表达式。</p><p id="84a0" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我不认为这能很好地扩展或者证明是健壮的。结合我上面提到的偶尔出现的错误匹配，我认为仅仅为了使用<code class="fe mi mj mk ml b">.match()</code>和<code class="fe mi mj mk ml b">.test()</code>这两种已经很慢的方法是不值得的。所以我没有直接使用regex，而是选择了一种混合的方法…</p><h1 id="faca" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">另一种方法:用正则表达式分割/切片，用JavaScript验证</h1><p id="2b31" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">与其将邪恶引入我们的生活，不如定义一些更小的正则表达式来匹配命令的核心组成部分——它的<strong class="kf io">命令</strong>字母、数字(<strong class="kf io">参数</strong>、<strong class="kf io">标志</strong>或<strong class="kf io">坐标</strong>)和<strong class="kf io">分隔符</strong>(逗号、空格和负/十进制符号——都是可选的，但有些在某些情况下是必需的)。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c470" class="mu lg in ml b gy mv mw l mx my">const validFlagEx = /^[01]/;</span><span id="d991" class="mu lg in ml b gy mz mw l mx my">const commaEx = /^(([\t\n\f\r\s]+,?[\t\n\f\r\s]*)|(,[\t\n\f\r\s]*))/;</span><span id="d28c" class="mu lg in ml b gy mz mw l mx my">const validCommandEx = /^[\t\n\f\r\s]*([achlmqstvz])[\t\n\f\r\s]*/i;</span><span id="1f1a" class="mu lg in ml b gy mz mw l mx my">const validCoordinateEx = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;</span></pre><p id="a056" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">让我们简单地分解一下:</p><ul class=""><li id="ba0a" class="na nb in kf b kg kh kk kl lc nc ld nd le ne la nf ng nh ni bi translated">注意<strong class="kf io">这些表达式不再携带</strong> <code class="fe mi mj mk ml b"><strong class="kf io">/g</strong></code> <strong class="kf io">叶形标志</strong>和<strong class="kf io">都以一个开始</strong> <code class="fe mi mj mk ml b"><strong class="kf io">^</strong></code> <strong class="kf io">元字符开始代替！这个稍后会很重要。</strong></li><li id="2553" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated">有效标志是一个零或一个<code class="fe mi mj mk ml b">[01]</code>。</li><li id="f8c0" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated">有效的分隔符要么是可选逗号<code class="fe mi mj mk ml b">,?</code>和可选空格前的一个空格，要么是任意数量的可选空格前的一个逗号。</li><li id="30b8" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated">一个有效的命令字母<code class="fe mi mj mk ml b">[achlmqstvz]</code>前后可以有任意数量的可选空格。</li><li id="ac1c" class="na nb in kf b kg nj kk nk lc nl ld nm le nn la nf ng nh ni bi translated">一个有效的数字有一个可选的负号<code class="fe mi mj mk ml b">[+-]?</code>，并且必须是零个或多个数字，零个或多个数字带一个小数点，或者零个或多个数字后跟一个小数点和一个或多个数字。(在电子记数法的最后还有一个恼人的边缘情况。)</li></ul><p id="6e02" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">然后让我们创建一个<strong class="kf io">语法— </strong>对象来存储每个命令的语法是如何正确形成的，就像小学一样:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="647b" class="mu lg in ml b gy mv mw l mx my">const pathGrammar = {<br/>   z: [],<br/>   h: [ validCoordinateEx ],<br/>   v: [ validCoordinateEx ],<br/>   m: [ validCoordinateEx, validCoordinateEx ],<br/>   l: [ validCoordinateEx, validCoordinateEx ],<br/>   t: [ validCoordinateEx, validCoordinateEx ],<br/>   s: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>   q: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>   c: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>   a: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validFlagEx, validFlagEx, validCoordinateEx, validCoordinateEx ],<br/>};</span></pre><p id="3e99" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">现在我们有了语法和一些规则，让我们制作这些变量<code class="fe mi mj mk ml b">static</code>并定义一个<strong class="kf io">类</strong>来存储它们并构造如何使用它们。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e0ed" class="mu lg in ml b gy mv mw l mx my">class PathParser {</span><span id="cf0f" class="mu lg in ml b gy mz mw l mx my">static validCommand = /^[\t\n\f\r\s]*([achlmqstvz])[\t\n\f\r\s]*/i;<br/>   static validFlag = /^[01]/;<br/>   static validCoordinate = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;<br/>   static validComma = /^(([\t\n\f\r\s]+,?[\t\n\f\r\s]*)|(,[\t\n\f\r\s]*))/;</span><span id="0232" class="mu lg in ml b gy mz mw l mx my">static pathGrammar = {<br/>      z: [],<br/>      h: [ validCoordinateEx ],<br/>      v: [ validCoordinateEx ],<br/>      m: [ validCoordinateEx, validCoordinateEx ],<br/>      l: [ validCoordinateEx, validCoordinateEx ],<br/>      t: [ validCoordinateEx, validCoordinateEx ],<br/>      s: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>      q: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>      c: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx, validCoordinateEx ],<br/>      a: [ validCoordinateEx, validCoordinateEx, validCoordinateEx, validFlagEx, validFlagEx, validCoordinateEx, validCoordinateEx ],<br/>   };</span><span id="9d9c" class="mu lg in ml b gy mz mw l mx my">static parseRaw( path ) {}</span><span id="b0cf" class="mu lg in ml b gy mz mw l mx my">static parseComponents( type, path, cursor ) {}</span><span id="66dd" class="mu lg in ml b gy mz mw l mx my">}</span></pre><p id="33bd" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">我们的类将有一个main方法来<code class="fe mi mj mk ml b">parseRaw()</code>将整个路径分解为raw原语，它使用一个helper方法来<code class="fe mi mj mk ml b">parseComponents()</code>。<code class="fe mi mj mk ml b">parse()</code>稳步地啃掉<code class="fe mi mj mk ml b">path</code>，一次啃掉字符串开头的<code class="fe mi mj mk ml b">cursor</code>大小的块——因此有了开始<code class="fe mi mj mk ml b">^</code>元字符！</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7073" class="mu lg in ml b gy mv mw l mx my">static parseRaw( path ) {<br/>   let cursor = 0, parsedComponents = [];<br/>   while ( cursor &lt; path.length ) {<br/>const match = path.slice( cursor ).match( this.validCommand );<br/>      if ( match !== null ) {<br/>         const command = match[ 1 ];<br/>         cursor += match[ 0 ].length;<br/>         const componentList = PathParser.parseComponents( command, path, cursor );<br/>         cursor = componentList[ 0 ];<br/>         parsedComponents = [ ...parsedComponents, ...componentList[1] ];<br/>      } else {</span><span id="e964" class="mu lg in ml b gy mz mw l mx my">throw new Error(  `Invalid path: first error at char ${ cursor }`  );<br/>      }<br/>   }<br/>   return parsedComponents;<br/>}</span><span id="0bc4" class="mu lg in ml b gy mz mw l mx my">static parseComponents( type, path, cursor ) {<br/>   const expectedCommands = this.pathGrammar[ type.toLowerCase() ];<br/>   const components = [];<br/>   while ( cursor &lt;= path.length ) {<br/>      const component = [ type ];<br/>      for ( const regex of expectedCommands ) {<br/>         const match = path.slice( cursor ).match( regex );<br/>         if ( match !== null ) {<br/>            component.push( parseInt( match[ 0 ] ) );<br/>            cursor += match[ 0 ].length;<br/>            const nextSlice = path.slice( cursor ).match( this.validComma );<br/>            if ( nextSlice !== null ) cursor += nextSlice[ 0 ].length;<br/>         } else if ( component.length === 1 ) {<br/>            return [ cursor, components ];<br/>         } else {<br/>            throw new Error( `Invalid path: first error at char ${ cursor }` );<br/>         }<br/>      }<br/>      components.push( component );<br/>      if ( expectedCommands.length === 0 ) return [ cursor, components ];<br/>      if ( type === 'm' ) type = 'l';<br/>      if ( type === 'M' ) type = 'L';<br/>   }<br/>   throw new Error( `Invalid path: first error at char ${ cursor }` );<br/>}</span></pre><p id="ae90" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><code class="fe mi mj mk ml b">parseRaw()</code>将路径分割成组件，然后将它们传递给<code class="fe mi mj mk ml b">parseComponents()</code>方法，根据<code class="fe mi mj mk ml b">expectedCommand</code>的构造规则从我们的<code class="fe mi mj mk ml b">pathGrammar</code>以及任何<code class="fe mi mj mk ml b">validComma</code>中搜索一个<code class="fe mi mj mk ml b">match()</code>。注意<code class="fe mi mj mk ml b">parseComponents()</code> <code class="fe mi mj mk ml b">return</code>是一个数组，包含命令的<code class="fe mi mj mk ml b">cursor</code>位置(起始索引)和新解析的<code class="fe mi mj mk ml b">command</code>。</p><p id="eb52" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">当<code class="fe mi mj mk ml b">parseComponents()</code>快速通过我们正在解析的<code class="fe mi mj mk ml b">path</code>时，它检查匹配，将其作为一个整数解析到结果<code class="fe mi mj mk ml b">components</code>数组，如果当前正在解析的命令在<code class="fe mi mj mk ml b">path</code>字符串的末尾，则返回，如果有任何错误，则在<code class="fe mi mj mk ml b">Error()</code>中执行<code class="fe mi mj mk ml b">throw</code>。</p><h1 id="77a2" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1000个光点</h1><p id="46c1" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">我们的<code class="fe mi mj mk ml b">PathParser</code>解决了两个重要问题。当然，它很好地解析和格式化了SVG路径字符串，但是当解析一个无效路径时，它也是一个<code class="fe mi mj mk ml b">throw</code>,使得用<code class="fe mi mj mk ml b">try {} catch {} finally {}</code>块处理验证变得容易。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e24f" class="mu lg in ml b gy mv mw l mx my">const shape = "m 150,150 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0 z";</span><span id="2c99" class="mu lg in ml b gy mz mw l mx my">const parsedShape = PathParser.parseRaw( shape )<br/>   -&gt; [ [ 'm', 50, 50 ], [ 'l', 100, 0 ], [ 'l', 0, 100 ], [ 'l', -100, 0 ], [ 'z' ] ]</span></pre><p id="89d7" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这也将有助于我们映射经过解析的点，为DOM创建<code class="fe mi mj mk ml b">&lt;path&gt;</code>标签。但是要记住，<em class="ke">路径可以用绝对或者相对的术语来定义，</em> <strong class="kf io"> </strong>并且不同的命令有不同的规则。所以计算视图框坐标将是另一个带语法的方法的工作——这次是<code class="fe mi mj mk ml b">pointGrammar</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7061" class="mu lg in ml b gy mv mw l mx my">static pointGrammar = {<br/>   z: () =&gt; [],<br/>   Z: () =&gt; [],<br/>   m: ( point, command ) =&gt; [ point[ 0 ] + command[ 1 ], point[ 1 ] + command[ 2 ] ],<br/>   M: ( point, command ) =&gt; command.slice( 1 ),<br/>   h: ( point, command ) =&gt; [ point[ 0 ] + command[ 1 ], point[ 1 ] ],<br/>   H: ( point, command ) =&gt; [ command[ 1 ], point[ 1 ] ],<br/>   v: ( point, command ) =&gt; [ point[ 0 ], point[ 1 ] + command[ 1 ] ],<br/>   V: ( point, command ) =&gt; [ point[ 0 ], command[ 1 ] ],<br/>   l: ( point, command ) =&gt; [ point[ 0 ] + command[ 1 ], point[ 1 ] + command[ 2 ] ],<br/>   L: ( point, command ) =&gt; command.slice( 1 ),<br/>   a: ( point, command ) =&gt; [ point[ 0 ] + command[ 6 ], point[ 1 ] + command[ 7 ] ],<br/>   A: ( point, command ) =&gt; command.slice( 6 ),<br/>   c: ( point, command ) =&gt; [ point[ 0 ] + command[ 5 ], point[ 1 ] + command[ 6 ] ],<br/>   C: ( point, command ) =&gt; command.slice( 5 ),<br/>   t: ( point, command ) =&gt; [ point[ 0 ] + command[ 1 ], point[ 1 ] + command[ 2 ] ],<br/>   T: ( point, command ) =&gt; command.slice( 1 ),<br/>   q: ( point, command ) =&gt; [ point[ 0 ] + command[ 3 ], point[ 1 ] + command[ 4 ] ],<br/>   Q: ( point, command ) =&gt; command.slice( 3 ),<br/>   s: ( point, command ) =&gt; [ point[ 0 ] + command[ 3 ], point[ 1 ] + command[ 4 ] ],<br/>   S: ( point, command ) =&gt; command.slice( 3 ),<br/>};</span></pre><p id="3cd4" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><code class="fe mi mj mk ml b">pointGrammar</code>的键这次指向的不是regex，而是取当前点和命令，吐出下一个点的纯函数。当然，绝对(大写)命令要简单得多，因为在这种情况下，我不需要知道当前点的任何信息就可以找到下一个点的位置。</p><p id="85e3" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">准备就绪后，我的<code class="fe mi mj mk ml b">PathParser</code>就可以解析来自SVG路径的坐标了:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c5fa" class="mu lg in ml b gy mv mw l mx my">static points( path ) {<br/>   let currentPoint = [ 0, 0 ];<br/>   return PathParser.parseRaw( path ).reduce( ( result, command ) =&gt; {<br/>      currentPoint = this.pointGrammar[ command[ 0 ] ]( currentPoint, command );<br/>      return [ ...result, currentPoint ];<br/>   }, [] );<br/>}</span></pre><p id="4f7f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">该方法使用<code class="fe mi mj mk ml b">pointGrammar</code>和<code class="fe mi mj mk ml b">currentPoint</code>缓冲区将那些<code class="fe mi mj mk ml b">parse</code> d命令<code class="fe mi mj mk ml b">reduce()</code>到一个视图框坐标数组中:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c0d5" class="mu lg in ml b gy mv mw l mx my">const sameShape = [<br/>   "m 25,25 l 50,0 l 0,50 l -50,0 z",<br/>   "M 25 25 L 75 25 L 75 75 L 25 75 Z"<br/>];</span><span id="11bf" class="mu lg in ml b gy mz mw l mx my">PathParser.parseRaw( sameShape[ 0 ] )<br/>   -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]<br/>PathParser.parseRaw( sameShape[ 1 ] )<br/>   -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]</span></pre><h1 id="d2b3" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论:阻力最小的路径</h1><p id="3529" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lc mf kq kr ld mg ku kv le mh ky kz la ig bi translated">我们结合了regex的文本匹配能力和JavaScript的灵活性，可以将原始文本路径解析为点坐标数组。仅此一点就足以让用户在DOM中对一个<code class="fe mi mj mk ml b">&lt;svg&gt;</code> <code class="fe mi mj mk ml b">&lt;path&gt;</code>拥有很大的控制权。添加<code class="fe mi mj mk ml b">PathParser</code>方法来计算曲线手柄等并不困难，这使得从Adobe Illustrator等品牌图形编辑器中复制选项/功能变得容易。</p><p id="3d82" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated">这个故事的寓意是什么？<strong class="kf io"> Regex本身不好，不好，对解析技术语法不好；</strong>通常只是嵌套太多。<a class="ae lb" href="https://stackoverflow.com/questions/6751105/why-its-not-possible-to-use-regex-to-parse-html-xml-a-formal-explanation-in-la" rel="noopener ugc nofollow" target="_blank">这个帖子</a>有最好的电梯解释为什么。</p><p id="8049" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la ig bi translated"><em class="ke">更多内容尽在</em><a class="ae lb" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf io"><em class="ke">plain English . io</em></strong></a></p></div></div>    
</body>
</html>