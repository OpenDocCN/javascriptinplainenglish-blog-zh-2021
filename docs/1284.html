<html>
<head>
<title>React: Component, Props, and State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:组件、道具和状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-component-props-and-state-734d36d52610?source=collection_archive---------15-----------------------#2021-03-17">https://javascript.plainenglish.io/react-component-props-and-state-734d36d52610?source=collection_archive---------15-----------------------#2021-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="8cf0" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">编程反应和前端开发</h2><div class=""/><div class=""><h2 id="3f15" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">React组件基础的详细说明，以及如何使用props和state来制作一个正常工作的应用程序。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ed55e2551f6c3ddc6fc94c00be2fa88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUoJpwe88p5AW3OcQ-MIdQ.jpeg"/></div></div></figure><p id="cdbc" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">根据React中组件的官方定义:</p><blockquote class="lt"><p id="fe8a" class="lu lv in bd lw lx ly lz ma mb mc ls dk translated">组件可以让你将用户界面分割成独立的、可重用的部分，并独立地考虑每一部分。</p></blockquote><p id="a770" class="pw-post-body-paragraph kx ky in kz b la md jx lc ld me ka lf lg mf li lj lk mg lm ln lo mh lq lr ls ig bi translated">组件可以被视为整个网页的一部分。导航条，主要内容，页脚等，都可以转换成单独的组件。甚至组件的部分也可以进一步划分为组件。该组件的目的是让一个单元执行一个单独的任务，然后整个网页以一致的方式工作。如果没有组件，您可以使用jQuery来定位DOM中的特定元素。然而，越来越多的web开发人员选择像React这样的UI框架来执行前端任务。</p><h1 id="d1ab" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">基于类的组件与功能组件</h1><p id="d572" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">您可以在React中使用类或函数编写组件。旧的代码库通常使用基于类的组件，现在有一批新的工程师将函数式编程作为比旧的OOP(面向对象编程)风格更好的编码方式。</p><p id="1de0" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，你可能需要学习功能组件和基于类的组件，直到每个人都开始使用功能组件。然而，我们未来将主要关注功能组件，顺应潮流。</p><h1 id="cc61" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">成分</h1><h2 id="0431" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">功能成分</h2><p id="911d" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">我们将从功能组件开始。在src文件夹中创建一个文件夹“components”。</p><p id="52ce" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在components文件夹中，创建一个文件并将其命名为Navbar.js</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f586" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:我们正在导入React(您的应用程序不导入它也可以运行良好，但是当我们使用基于类的组件时，我们需要导入React)。</p><p id="1cbb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第3行:我们创建了一个Navbar功能组件。</p><p id="ef0c" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4行:无论我们在返回语句中放入什么，我们的函数都会输出。</p><p id="f237" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:我们放在return语句中的任何东西都必须在1个标签下，要么是h1，p，要么是div。然而，将div放在h1中并不是一个最佳实践，所以我们应该放一个div标签或者只是片段(&lt;&gt; &gt;)。</p><p id="8b45" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第6行:这个Navbar功能组件只是返回h1中的Navbar语句。</p><p id="2090" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第11行:我们正在导出Navbar，这样我们可以在App.js中导入它。</p><p id="a55a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">应该是这样的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/256704ebef4697eb6d7d614be179afa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spZkoT4hcOD1GUXb8E2Osg.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Navbar.js</figcaption></figure><p id="6ec1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们的功能组件已经可以使用了，我们可以将其导入到我们的App.js中</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="79b8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:导入Navbar。</p><p id="9d7b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第2行:导入styles.css文件。它现在是空白的。</p><p id="9753" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4行:创建App功能组件并在同一行中导出。</p><p id="3d60" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:返回语句。</p><p id="7e54" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第6行:将所有内容包含在div标签中。</p><p id="1fd8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第7行:这是有趣的部分，我们将功能组件Navbar放入return语句中，我们也可以这样写:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="1b88" class="nf mj in ny b gy oc od l oe of">&lt;div className = "App"<br/>   <strong class="ny ix">&lt;Navbar&gt;&lt;/Navbar&gt;</strong><br/>&lt;/div&gt;</span></pre><h2 id="b6d1" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">基于类的组件</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2550" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">你可以把一个<a class="ae og" href="https://reactjs.org/docs/state-and-lifecycle.html#converting-a-function-to-a-class" rel="noopener ugc nofollow" target="_blank">功能组件变成一个基于类的组件</a>。</p><p id="a032" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:我们正在导入React和组件类。</p><p id="8cd8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第3行:我们的Navbar ( N是大写)，扩展了组件类。</p><p id="502a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4行:调用了render方法</p><p id="a13e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:return语句返回h1标签中的Navbar。</p><p id="9cc8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">代码笔链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh nr l"/></div></figure><p id="1368" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第一部分结束</p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="b5bb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">组件现在应该被清除了。现在我们应该转移到主要话题、道具和状态。</p><h1 id="1748" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">小道具</h1><p id="17eb" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">在理解props之前，我们应该知道React中的父、子和兄弟组件是什么，以及如何在它们之间移动数据。如果你能理解这一点，你就已经成功了一半以上。</p><p id="dcaf" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">React中有三种处理数据的方法:</p><p id="9e19" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">a.)使用props的父到子组件。</p><p id="a896" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">b.)在兄弟组件之间使用上下文API，Redux</p><p id="0a09" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">c.)使用回调的子到父</p><h2 id="2077" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">使用props的父到子组件</h2><h2 id="45d8" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">功能成分</h2><p id="8aa7" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">你会在React里随处看到道具。如果你想成为一名更好的React开发者，这一部分值得你关注。Props是将数据从应用程序的一部分传递到另一部分的方法。我们为什么这样做，可能有很多原因，首先，我们可能知道我们将从用户那里获得什么数据，如果你不知道你将获得什么数据，你将如何显示它。看下面的例子来理解我所说的:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="ea1f" class="nf mj in ny b gy oc od l oe of">export default PrintName(){<br/>    <strong class="ny ix">return &lt;h1&gt; Hi, {name} &lt;/h1&gt;</strong><br/>}</span></pre><p id="00e6" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这是说明为什么道具很重要的经典例子。现在，我们不知道name参数是什么。要传递参数，PrintName()函数首先需要带一个参数。这个参数一定来自某个地方，对吗？</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="609e" class="nf mj in ny b gy oc od l oe of">export default PrintName(props){<br/>    <strong class="ny ix">return &lt;h1&gt; Hi, {props.name} &lt;/h1&gt;</strong><br/>}</span><span id="0804" class="nf mj in ny b gy op od l oe of">//in App.js</span><span id="3c25" class="nf mj in ny b gy op od l oe of"><strong class="ny ix">&lt;PrintName name = {name} /&gt;</strong></span></pre><p id="2237" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这叫传道具。现在你知道我们为什么要用道具了。每当你会困惑的时候，回到这个页面，看看我们为什么要使用道具，如果你是一个初学者，你需要学习很多次同样的东西，然后它才会印在你的潜意识里。</p><h2 id="8e3a" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">ES6-破坏</h2><p id="dbf5" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">你也可以通过新的析构方式使用道具:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="553b" class="nf mj in ny b gy oc od l oe of">export default PrintName({name}){<br/>    <strong class="ny ix">return &lt;h1&gt; Hi, {name} &lt;/h1&gt;</strong><br/>}</span><span id="fd5f" class="nf mj in ny b gy op od l oe of">//in App.js</span><span id="1e58" class="nf mj in ny b gy op od l oe of"><strong class="ny ix">&lt;PrintName name = {name} /&gt;</strong></span></pre><p id="eb12" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这里不需要写' props.name '，直接用{name}做自变量就可以了。</p><p id="e82a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">代码笔链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh nr l"/></div></figure><h2 id="4633" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">箭头功能组件中的传递道具</h2><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="b6aa" class="nf mj in ny b gy oc od l oe of">const <strong class="ny ix">PrintName=({name})=&gt;</strong>(<br/>   <strong class="ny ix"> </strong>return &lt;h1&gt; Hi, {name} &lt;/h1&gt;<br/>)</span><span id="1290" class="nf mj in ny b gy op od l oe of">export default PrintName</span><span id="6aa8" class="nf mj in ny b gy op od l oe of">//in App.js</span><span id="c126" class="nf mj in ny b gy op od l oe of"><strong class="ny ix">&lt;PrintName name = {name} /&gt;</strong></span></pre><blockquote class="oq or os"><p id="615b" class="kx ky ot kz b la lb jx lc ld le ka lf ou lh li lj ov ll lm ln ow lp lq lr ls ig bi translated">提示:</p><p id="5fa1" class="kx ky ot kz b la lb jx lc ld le ka lf ou lh li lj ov ll lm ln ow lp lq lr ls ig bi translated">记住，如果你在return语句中使用arrow函数或者有多行，你需要一个大括号{}。</p></blockquote><p id="58b2" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">b .)和c .)部分将在以后讨论，因为在讨论b .)和c .)之前，我们仍然没有涉及一些基础知识</p><h2 id="194b" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">基于类的组件</h2><p id="0fae" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">秀色可餐</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1acf" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:导入React</p><p id="1aef" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第3行:创建一个类ShowSum</p><p id="597f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4行:渲染方法</p><p id="67ef" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:不带括号的return语句。如果有一条以上的线，我们必须将JSX放在括号内。在p标签中，我们通过“this”拉动我们的道具，然后将两个道具相加得到总和</p><p id="4126" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">App.js看起来是这样的:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="a062" class="nf mj in ny b gy oc od l oe of">&lt;div&gt;</span><span id="9f90" class="nf mj in ny b gy op od l oe of">&lt;ShowSum num1={5} num2={10} /&gt;</span><span id="269a" class="nf mj in ny b gy op od l oe of">&lt;/div&gt;</span></pre><p id="0a40" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">代码笔链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh nr l"/></div></figure><p id="bbe9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第二部分结束</p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h1 id="c1ad" class="mi mj in bd mk ml ox mn mo mp oy mr ms kc oz kd mu kf pa kg mw ki pb kj my mz bi translated">反应中的状态</h1><p id="995f" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">道具和状态的区别在于，道具是我们在应用程序的不同部分之间发送的数据，而状态是组件的条件。按钮是开还是关，由状态管理，当按钮开还是关时显示什么是道具的责任。</p><h2 id="31a3" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">处理基于类的组件中的状态</h2><p id="d10a" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">在本节中，我们将构建一个显示两个给定数字的和与差的应用程序。这看起来可能是一个简单的任务，但它会拉伸你的一些反应肌肉。</p><p id="25d7" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Calculate.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8ee1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:创建计算类</p><p id="5ff9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第2行:调用构造函数，我们可以在构造函数内部直接分配this.state。同样，我们也可以绑定我们的事件监听器。</p><p id="2a15" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第3行:调用超级方法</p><p id="db8a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:绑定句柄单击</p><p id="9245" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第6行:绑定handleDiffClick</p><p id="8ff0" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第7行:在state对象中，我们给showSum一个false值。这个状态值可以通过click事件变成true和false。</p><p id="c860" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第10行:定义handleSumClick方法。这将使状态保持在错误值。</p><p id="d6f9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第14行:定义handleDiffClick方法。这将使状态保持在真实值。</p><p id="cca3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第18行:在render方法中，我们将状态值存储在一个const变量中，通过条件呈现，我们可以在SumButton和DiffButton之间切换。</p><p id="100e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第31行:这个组件只返回一个ShowCal组件，它本身接受showSum属性(带有来自状态的true或false值)</p><p id="09b6" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">简而言之，在政府的帮助下，我们在两个按钮之间切换。一个是显示数字的和，另一个是显示差。所以一次只有一个按钮可见，这是在render方法中实现的。通过使用if-else，我们可以根据状态值显示任意一个按钮。</p><p id="8fd1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">最后，我们将返回ShowCal组件，并将showSum作为道具传递。</p><p id="0f8f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> ShowCal.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="65ff" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第3行:状态值来自计算组件。</p><p id="949a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第5行:如果showSum为真，则显示Diff组件，否则显示Sum</p><p id="f46b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们从ShowCalc组件向Diff和Sum传递属性。</p><p id="8768" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> SumButton.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c52b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> DiffButton.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5071" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Sum.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="891a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Diff.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f49a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">代码笔链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh nr l"/></div></figure><h2 id="8153" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">在基于功能的组件中处理状态</h2><p id="3818" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">在功能组件中，我们使用钩子来管理状态。我们将会看到如何将之前的练习转换为显示函数部分中两个给定数字的和或差。</p><p id="123a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Calculate.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8a88" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:创建一个功能组件计算就像我们在基于类的组件中做的那样。</p><p id="eeef" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4行:在功能组件中，我们没有类，所以我们不使用“this”关键字。我们可以用钩子代替。我们创建了一个包含两个元素的数组，第一个是showSum，它是一个布尔值，setShowSum是一个函数。看看如果使用console.log([showSum，setShowSum])会得到什么。</p><p id="af70" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第7，11行:添加事件监听器。</p><p id="94d3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第15行:条件渲染将根据条件(真或假)显示两个按钮中的任何一个，我们用prop showSum传递我们的ShowCal组件。该属性将根据其值(真或假)显示相关的ShowCal组件。</p><p id="a48f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> ShowCalc.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d3c9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第1行:ShowCal是一个函数组件，从Calculate组件获得一个属性。此属性将用于显示Sum或Diff组件。</p><p id="ffff" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第2行:我们创建了一个变量showSum，并给它分配了一个道具。</p><p id="8a14" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">第4，8行:根据属性的值为真或假，有条件地呈现Sum或Diff组件。</p><p id="6685" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Sum.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f152" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix"> Diff.js </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4008" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">代码笔链接:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh nr l"/></div></figure><p id="9954" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在下一个教程中，我们将深入探讨钩子。</p><blockquote class="lt"><p id="ec58" class="lu lv in bd lw lx ly lz ma mb mc ls dk translated">你可以在我的YouTube频道上找到更多关于编程的教程，Saran科技，【https://www.youtube.com/channel/UCOHJCOprtOf4caI50lJlHSQ T4】</p></blockquote></div></div>    
</body>
</html>