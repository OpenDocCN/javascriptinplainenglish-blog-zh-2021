<html>
<head>
<title>Declarative Web Audio API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明性网络音频API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/declarative-web-audio-api-ad98b9b49d7e?source=collection_archive---------11-----------------------#2021-08-16">https://javascript.plainenglish.io/declarative-web-audio-api-ad98b9b49d7e?source=collection_archive---------11-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b0cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Web组件构建AudioNodes的更好方法！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e8338c20b85773434fe2fc7a72f92b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ORNLoAbKQrfYgknyEubKQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@schluditsch" rel="noopener ugc nofollow" target="_blank">Daniel Schludi</a> on <a class="ae kv" href="https://unsplash.com/search/photos/typing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" rel="noopener ugc nofollow" target="_blank">网络音频API </a>是现代浏览器拥有的丰富的多媒体特性。它允许我们处理音频信号，构建从有趣的游戏到完整的数字音频工作站的惊人应用。但是在其原始范例中使用复杂的可重用代码结构是很困难的。让我们来看看基本的回声效果示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/faa2c8afc6d9501688589b431e504ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCm7aks1gtgjxWLj7fXtiA.png"/></div></div></figure><p id="1dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切都发生在<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext" rel="noopener ugc nofollow" target="_blank">AudioContext</a></code>之内。该图由一个链接到<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioDestinationNode" rel="noopener ugc nofollow" target="_blank">AudioDestinationNode</a></code>的源节点组成。它还有一个反馈环<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/DelayNode" rel="noopener ugc nofollow" target="_blank">DelayNode</a></code>来引入延迟，还有<code class="fe lt lu lv lw b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/GainNode" rel="noopener ugc nofollow" target="_blank">GainNode</a></code>来控制回声衰减的速度。这个循环也连接到目的地。</p><p id="a835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置包括3个步骤:</p><ol class=""><li id="e602" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">创建节点</li><li id="0568" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">配置参数</li><li id="4687" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">将图表连接在一起</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="2fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何复杂的处理模块，这很快就会变得乏味，尤其是如果我们想要实时控制参数的话。这是一种势在必行的方法。我们编写了一组命令，这些命令按照改变程序状态的顺序执行。</p><p id="995b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我想起了很多用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> Canvas API </a>画图。我们可以通过给出坐标的连续命令来手动绘制形状。还有另一种方法来绘制形状，即使是非常复杂的形状，那就是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/SVG" rel="noopener ugc nofollow" target="_blank">SVG</a>——可缩放矢量图形。让我们试着为Web Audio API构建我们自己的“SVG”——一种基于声明性XML的方式，用于构建节点图、更改参数和轻松重用代码！</p><h1 id="9822" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">准备</h1><p id="6830" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们的解决方案将基于本地Web组件。作为概念验证，让我们创建一个简单的音量控件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/d603deb624671504a0e975ca7de769ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tjeZScm6_wKTNYgGYoG5w.png"/></div></div></figure><p id="e3e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们的组件准备就绪，HTML5音频标签作为自定义组件充当源时，此图看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ae6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够将所有这些节点链接在一起，我们将使用<em class="nl">依赖注入</em>模式。简而言之，这很简单。父母为孩子提供依赖，孩子可以注入依赖，这将从拥有它的最近的父母请求。</p><p id="14f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的演示，我们将使用自定义DOM事件。因为它们是同步的、有作用域的，只需要几行代码就可以实现。我在Justin Fagnani talk 上看到了这种模式，它很适合我们的情况。</p><p id="21f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Web组件扩展了本地HTML元素，并且JavaScript中没有多重继承——我们将制作一个<em class="nl"> mixin </em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b1ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">provide</code>方法将接受一个<code class="fe lt lu lv lw b">Map</code>令牌密钥和提供者值。它将侦听自定义事件<em class="nl">“inject”</em>，如果请求的令牌出现在给定的映射中，它将停止传播，并将映射中的值分配给事件。</p><p id="092b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而<code class="fe lt lu lv lw b">inject</code>方法将接受一个令牌，分派一个自定义事件并返回结果。</p><h1 id="e1f6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">Web组件</h1><p id="9455" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们的音量控制有4个组成部分。</p><p id="3781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di"> 1。</span>最顶层的组件是<strong class="ky ir">上下文</strong>。所有web组件都有一个在初始化时被调用的<code class="fe lt lu lv lw b">connectedCallback</code>方法。我们将使用一个映射图<code class="fe lt lu lv lw b">AudioContext</code>作为令牌，使用<code class="fe lt lu lv lw b">new AudioContext()</code>实例作为值来调用<code class="fe lt lu lv lw b">provide</code>。这将允许所有孩子注入相同的音频环境:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e30f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di"> 2。</span> <strong class="ky ir">源节点</strong>将扩展<code class="fe lt lu lv lw b">HTMLAudioElement</code>。在它的<code class="fe lt lu lv lw b">connectedCallback</code>中，它将注入上下文并创建一个新的<code class="fe lt lu lv lw b">MediaElementAudioSourceNode</code>实例。它会将它作为<code class="fe lt lu lv lw b">AudioNode</code>放入该元素提供的映射中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="afa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di"> 3。</span> <strong class="ky ir">增益</strong>稍微复杂一点，因为它有参数。我们将用<code class="fe lt lu lv lw b">GainNode</code>创建一个私有属性。在<code class="fe lt lu lv lw b">connectedCallback</code>中，我们将注入父<code class="fe lt lu lv lw b">AudioNode</code>并将其连接到我们的<code class="fe lt lu lv lw b">GainNode</code>。我们还将为所有孩子提供<code class="fe lt lu lv lw b">GainNode</code>作为<code class="fe lt lu lv lw b">AudioNode</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="aa02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Web组件有一个静态getter，它返回您可以更改的可能属性的数组。在这种情况下，应该是<code class="fe lt lu lv lw b">gain</code>。当增益属性改变时，我们将其解析为float并更新<code class="fe lt lu lv lw b">AudioParam</code>。</p><blockquote class="nv nw nx"><p id="ad97" class="kw kx nl ky b kz la jr lb lc ld ju le ny lg lh li nz lk ll lm oa lo lp lq lr ij bi translated">不要忘记，这是一个概念验证，所以我们现在将忽略参数自动化。</p></blockquote><p id="f124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di"> 4。</span>的<strong class="ky ir">目的地</strong>的组件很简单。我们只是注入父节点<code class="fe lt lu lv lw b">AudioNode</code>和<code class="fe lt lu lv lw b">AudioContext</code>，并将节点连接到目的节点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在剩下要做的就是注册我们的Web组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="c1c6" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结果</h1><p id="0d34" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">您可以在此处查看该自定义控件:</p><div class="ob oc gp gr od oe"><a href="https://waterplea.github.io/declarative-web-audio/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">Web组件驱动的声明性Web音频-概念验证</h2><div class="ol l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">water lea . github . io</p></div></div></div></a></div><p id="4679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你启动<code class="fe lt lu lv lw b">AudioContext</code>，你会看到一个连接到自定义音量控制的输入滑块。本机HTML5音频控件位于下方，两者都是功能性的。</p><p id="d07a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这可能看起来不怎么样，但它概述了这个概念。只需相对较少的代码，我们就可以将所有web音频API特性转换为Web组件。我是一个非常视觉化的人。对我来说，这比普通的网络音频API要干净和容易理解得多。我知道很多音乐家也和我一样。它们用于从物理块中构建处理链，将它们相互连接起来。所以这种方式对目标受众是有意义的。</p><p id="0d5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我是一个角度爱好者，所以当我用普通JavaScript创建这个概念证明时，我已经将Web音频API完全转换为声明性角度指令:</p><div class="ob oc gp gr od oe"><a href="https://github.com/ng-web-apis/audio" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">GitHub - ng-web-apis/audio:这是一个用于声明性使用web音频API和Angular的库</h2><div class="om l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">这是一个用于Angular 7+的Web音频API声明性使用的库。这是一个完整的…</h3></div><div class="ol l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><p id="6989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对Angular感兴趣，可以看看<a class="ae kv" href="https://medium.com/its-tinkoff/writing-retrowave-in-angular-4e1ff80798a8" rel="noopener">这篇文章</a>覆盖了这个库，还有<a class="ae kv" href="https://medium.com/its-tinkoff/jam-on-your-midi-keyboard-in-angular-2a2c3f91ad75" rel="noopener">这篇跟进</a>关于Web MIDI API的文章。有了这两个库，我做了一个基于浏览器的吉他英雄游戏，可以和真正的合成器一起玩。它还具有卡拉ok模式，可以跟着唱，看看你的音调匹配得如何。欢迎您尝试一下:</p><div class="ob oc gp gr od oe"><a href="https://jamigo.app/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">Jamigo.app</h2><div class="om l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Jamigo是一款音乐游戏。它帮助你使练习变得有趣和容易。从目录中选择一首歌曲，用…</h3></div><div class="ol l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">jamigo.app</p></div></div><div class="on l"><div class="ot l op oq or on os kp oe"/></div></div></a></div><p id="6b42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这是一个有趣的角度。声明式方法可以使复杂的任务更容易管理，也更容易理解。</p><p id="bcf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">更多内容请看</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>