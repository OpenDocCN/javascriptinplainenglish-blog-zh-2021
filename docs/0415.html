<html>
<head>
<title>Creating an Unbeatable Tic-Tac-Toe AI in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建无与伦比的井字游戏人工智能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-add-an-unbeatable-ai-to-react-tic-tac-toe-c57392579381?source=collection_archive---------6-----------------------#2021-01-25">https://javascript.plainenglish.io/lets-add-an-unbeatable-ai-to-react-tic-tac-toe-c57392579381?source=collection_archive---------6-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7b68" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过在正式的React教程中增加几行代码。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/85d52801c45e235e451c07511a98ada2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wZ_KAyQ8lpNHYIdK"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7688" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不管你是已经知道React，还是刚刚开始学习，你可能在某个时候遇到过官方的<a class="ae ks" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">井字游戏教程</a>。最终的结果非常简洁——一个具有历史跟踪功能的全功能井字游戏用户界面:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The <a class="ae ks" href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010" rel="noopener ugc nofollow" target="_blank">official final result</a> linked from the official <a class="ae ks" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">React Tic-Tac-Toe tutorial</a>.</figcaption></figure><p id="cba5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是你只能和你自己(或者一个朋友)玩得很开心。让我们用一些智慧来增加它的趣味吧！通过增加一点点代码，你可以增加一个无敌的人工智能对手:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/60c7bb678bf3decbde4b7daf78a0226e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/1*1st9mEYtREFohhC9SL-hbQ.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Me (X) playing against the AI (O). Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><h1 id="876d" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">它是如何工作的？</h1><p id="359a" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">在开始编写代码之前，让我们先了解一下算法。假设现在的棋盘是这样的，轮到玩家O了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/f979bb3638ef2c3611291b5b51548f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*mRf-pTOKBME0U9XvNkF15g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The current Player (O) has three possible moves in this example board. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="b656" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时参与人O有三种可能的行动。哪一步是最优的？我们可以模拟从当前棋盘到残局的所有可能的移动，并将它们布局为一棵树:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/1ca93dee3217d1f1629b02ba13defd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuyoHvV8Eae39vgE3gEhEQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example Tic-Tac-Toe game tree. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="6b22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很明显，下一步的一些选择会导致玩家O“赢”，而一些会导致“平”或“输”。如果赢(或平)是好，输是坏，那么我们来量化一个“赢”用正分+1，“平”用0，“输”用负分-1:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/8779dff809c3664f463436fa768ed0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88k0E53xc-7fbGdSETQo5w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example Tic-Tac-Toe game tree, with all possible endgames scored with +1, 0, and -1 for a “win”, “tie”, and “loss” respectively by the current Player O. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="e826" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你是玩家O，你会希望游戏沿着一条通往高分结局的道路进行。类似地，你的对手玩家X会希望游戏进行到一个低得分的结局，因为这意味着你输了。换句话说，当轮到你的时候，你会选择最大化残局分数的一步，而玩家X会选择最小化残局分数的一步。这为得分移动提供了一个很好的回溯策略:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/e8f8e4d0449e57c7238d1798adf40da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTRfOi9LUuwikeJ93xWOjA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The Minimax Algorithm on Tic-Tac-Toe. Starting from the scored endgames, backtrack up the tree to score every move by either taking the minimum scoring move (Player X) or the maximum scoring move (Player O). Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="d063" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到，从左到右，参与人O的三种可能移动的得分分别是0，+1，-1。作为最大化的玩家，玩家O应该选择+1的移动，这立刻导致了一个“赢”。</p><p id="6655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我上面刚刚描述的是应用于井字游戏的<a class="ae ks" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank">极大极小算法</a>。如上图所示，基本的想法是模拟所有可能的残局，并在假设两个玩家都发挥最佳的情况下对所有的棋步打分。从玩家当前可能的走法中，选择最终会给玩家带来最佳结果的当前走法(在井字游戏中是赢或平)。这个算法可以使用递归直接实现，这将在下一节中介绍。</p><h1 id="f6b4" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">给我看看代码！</h1><p id="a76f" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">剧透:最终结果和代码在<a class="ae ks" href="https://codepen.io/wlouie1/pen/YzGOpbV?editors=0010" rel="noopener ugc nofollow" target="_blank">这里</a>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The final result of enhancing the official React Tic-Tac-Toe tutorial with an unbeatable AI. Code by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="ef69" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本指南结束时，你会发现到达这里并不需要做太多的工作！接下来的部分可能看起来很长，但那是因为我试图一步一步地向你解释。</p><p id="a9c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">先说官方<a class="ae ks" href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010" rel="noopener ugc nofollow" target="_blank"> React井字游戏教程应用</a>的<a class="ae ks" href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010" rel="noopener ugc nofollow" target="_blank">最终结果</a>。概括地说，代码结构基本上是:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="3baf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe ms mt mu mv b">Game</code>组件由一个<code class="fe ms mt mu mv b">Board</code>组件和它右边的游戏信息和历史组成。<code class="fe ms mt mu mv b">Board</code>组件由一个由<code class="fe ms mt mu mv b">Square</code>组件组成的3 x 3网格组成。如果点击了一个<code class="fe ms mt mu mv b">Square</code>，那么<code class="fe ms mt mu mv b">Game</code>中的<code class="fe ms mt mu mv b">handleClick()</code>将处理该事件，更新相应的状态以反映在方块上的移动。页面由一个单独的<code class="fe ms mt mu mv b">Game</code>组件组成。</p><h2 id="6337" class="mw lt in bd lu mx my dn ly mz na dp mc lc nb nc me lg nd ne mg lk nf ng mi nh bi translated">Minor handleClick()重构</h2><p id="a8cb" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">让我们仔细看看<code class="fe ms mt mu mv b">handleClick()</code>函数。现在看起来是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="1ebd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你点击一个<code class="fe ms mt mu mv b">Square</code>，调用<code class="fe ms mt mu mv b">handleClick()</code>来应用移动到那个方块。在我们的智能版本中，我们希望<code class="fe ms mt mu mv b">handleClick()</code>应用你的移动，然后应用AI的移动。我们可以通过将当前<code class="fe ms mt mu mv b">handleClick()</code>的所有逻辑转移到<code class="fe ms mt mu mv b">makeMove()</code>函数中，然后在<code class="fe ms mt mu mv b">handleClick()</code>中重用<code class="fe ms mt mu mv b">makeMove()</code>来实现这一点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="369d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是等等！回想一下，React的<code class="fe ms mt mu mv b">setState()</code>是异步的。从他们的文档来看:</p><blockquote class="ni nj nk"><p id="c3de" class="kt ku nl kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">React可能会将多个<code class="fe ms mt mu mv b">setState()</code>调用批处理到单个更新中以提高性能。</p><p id="2815" class="kt ku nl kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">因为<code class="fe ms mt mu mv b">this.props</code>和<code class="fe ms mt mu mv b">this.state</code>可能会异步更新，所以您不应该依赖它们的值来计算下一个状态。</p></blockquote><p id="4ac5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，即使我们试图通过第一个<code class="fe ms mt mu mv b">makeMove()</code>用人的移动来更新状态，在AI查看状态以确定最佳响应移动之前，状态可能实际上还没有被更新。我们需要确保第一个<code class="fe ms mt mu mv b">makeMove()</code>的状态更新在继续AI逻辑之前完成。</p><p id="188e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于<code class="fe ms mt mu mv b">setState()</code>接受了一个在更新完成后调用的<a class="ae ks" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank">可选回调</a>，我们可以加入一些<code class="fe ms mt mu mv b">async</code>、<code class="fe ms mt mu mv b">await</code>和<code class="fe ms mt mu mv b">Promise</code>魔法来使一切同步:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="fd4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了上面的改变，<code class="fe ms mt mu mv b">makeMove()</code>返回一个<code class="fe ms mt mu mv b">Promise</code>，只有当<code class="fe ms mt mu mv b">setState()</code>完成时才解析。然后，我们使用<code class="fe ms mt mu mv b">await this.makeMove()</code>来阻塞代码，直到<code class="fe ms mt mu mv b">makeMove()</code>完成，然后再进入<code class="fe ms mt mu mv b">handleClick()</code>内部。</p><p id="af71" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在剩下要做的就是人工智能的实现(上面的Minimax计算逻辑<code class="fe ms mt mu mv b">bestSquare</code>)，然后我们就完成了！</p><h2 id="f53b" class="mw lt in bd lu mx my dn ly mz na dp mc lc nb nc me lg nd ne mg lk nf ng mi nh bi translated">添加智能</h2><p id="d8d3" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">给定当前棋盘，人工智能需要选择最佳的方格来放置它的移动。我们可以通过实现一个<code class="fe ms mt mu mv b">findBestSquare(squares, player)</code>函数来实现这一点，该函数接受当前棋盘(<code class="fe ms mt mu mv b">squares</code>)和AI的身份(<code class="fe ms mt mu mv b">player</code>)，例如，如果人类玩家是“X”，则返回“0”，如果游戏结束，则返回-1。如前所述，最佳正方形将由最小最大算法选择:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="e229" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们修改<code class="fe ms mt mu mv b">handleClick()</code>以正确调用<code class="fe ms mt mu mv b">findBestSquare()</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr lq l"/></div></figure><p id="d888" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">就是这样！现在，每当你点击一个方块来移动时，人工智能会相应地移动。</p><h1 id="16a3" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">结论</h1><p id="3bbf" class="pw-post-body-paragraph kt ku in kv b kw mk jo ky kz ml jr lb lc mm le lf lg mn li lj lk mo lm ln lo ig bi translated">正如本指南中所展示的，通过执行一些小的重构，并在官方React <a class="ae ks" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">井字游戏教程</a>中实现Minimax算法，你可以轻松地用无与伦比的人工智能增强项目。最终结果和代码可在这里<a class="ae ks" href="https://codepen.io/wlouie1/pen/YzGOpbV?editors=0010" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="3408" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望你觉得这很有趣，也很有见地；编码快乐！</p></div></div>    
</body>
</html>