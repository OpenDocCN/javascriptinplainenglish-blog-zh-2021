<html>
<head>
<title>Design Patterns In React Native: Component Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的设计模式:组件模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/design-patterns-in-react-native-component-patterns-785d585ac3f?source=collection_archive---------8-----------------------#2021-01-04">https://javascript.plainenglish.io/design-patterns-in-react-native-component-patterns-785d585ac3f?source=collection_archive---------8-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习在React Native &amp; More中创建可重用的表示组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ea07f2995999f787e42610108bf568f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bTWTbzMf10xI5XlD.png"/></div></div></figure><p id="fca0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发Android  &amp; <strong class="kt ir"> iOS </strong>应用程序对于向最终用户交付合适的产品来说从未如此简单。<strong class="kt ir"> React-Native </strong>自推出以来彻底改变了这个问题，了解React-Native中的设计模式是开发人员应该知道的基本技能。在React-Native生态系统中，我们设计应用的方式总是更容易，因为由于有大量的社区支持，你可以很容易地选择其他优秀开发人员所做的一些工作。我将讨论React-Native中的一些设计模式，它们将帮助您用示例编写更易维护的代码。</p><h1 id="f147" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">React-Native中的组件</h1><p id="13ca" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">React大部分时间都在使用组件，以正确的方式编写组件非常重要，因为你开始制作真实世界和更大的应用，这些应用需要长时间的实际维护。专业开发人员仍在使用这些实践来制作令人敬畏的React-Native应用程序，我也将讨论为什么在我们的例子中学习React或React-Native中的设计模式如此重要</p><p id="abb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当谈到组件时，使它们可重用是非常重要的，因为随着时间的推移，你会发现每次都很难制作新的组件用于其他地方，并最终遵循众所周知的程序员原则- <strong class="kt ir">不要重复自己(干)。表示组件就是用来做这个的。</strong></p><h2 id="d6d7" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">我将在本文中讨论以下实践:</h2><ol class=""><li id="a0ef" class="mw mx iq kt b ku mf kx mg la my le mz li na lm nb nc nd ne bi translated"><strong class="kt ir"> <em class="nf">无状态和有状态的组件</em> </strong>，有更短更复杂的例子。</li><li id="b064" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated"><strong class="kt ir"> <em class="nf">创建易于配置的表示组件</em> </strong>。</li><li id="2e0c" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated"><strong class="kt ir"> <em class="nf">容器组件。</em> </strong></li><li id="f1de" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated">以及如何创建(<strong class="kt ir"><em class="nf">【HOC】)</em></strong>-<strong class="kt ir">高阶组件。</strong></li></ol><h1 id="d7e9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">无状态和有状态组件</h1><p id="8d80" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果您使用<strong class="kt ir">Create React-Native App(CRNA)</strong>创建一个简单的React-Native项目，您将会看到简单的React组件已经写入文件<strong class="kt ir"> <em class="nf"> App.js </em> </strong>中。该组件是使用<strong class="kt ir"> ES6 </strong>中引入的类语法创建的，此类组件称为<strong class="kt ir">类组件。</strong></p><p id="3fc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nf">你可以深入看看下面的例子:</em> </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Class Component</strong></figcaption></figure><p id="8e15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类组件可以用来创建有状态组件，在这种情况下，类组件是不必要的，我们可以使用无状态组件来代替。</p><blockquote class="nr ns nt"><p id="7d02" class="kr ks nf kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">让我们了解如何将它转换成一个<strong class="kt ir">无状态组件。</strong></p></blockquote><p id="9da9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最常见的方法是通过使用<strong class="kt ir"><em class="nf">【ES6】</em></strong>箭头语法，因为这样的组件被称为<strong class="kt ir">功能</strong>组件。<strong class="kt ir"> <em class="nf">(如果不习惯箭头语法，可以使用常规语法)</em> </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Functional Component</strong></figcaption></figure><p id="3cc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想到的问题是为什么<strong class="kt ir">无状态</strong>？因为它不包含任何内部状态，这意味着我们没有在其中存储任何私有数据，组件呈现的所有内容都是从外部世界提供的，在这种情况下，组件并不关心这些。</p><p id="1172" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们没有向组件传递任何类型的外部数据。为了传递一些数据，我们将创建另一个名为<strong class="kt ir"> <em class="nf"> HelloText </em> </strong>的新组件，它使用属性来显示一些文本。为此，用于将文本传递给这种组件的通常惯例是在开始和结束标记之间放置一个文本，</p><p id="c273" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:<strong class="kt ir"> &lt; HelloText &gt;待传文本&lt; /HelloText &gt; </strong></p><p id="ce28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是要在我们的功能组件中检索这样一个道具，我们仍然需要使用一个名为<strong class="kt ir"> <em class="nf">子</em> </strong>的特殊键。</p><p id="96ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的功能组件中实现了这些道具之后，它看起来会是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Functional Component With Props</strong></figcaption></figure><p id="be0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<strong class="kt ir">子</strong>道具使得<strong class="kt ir"> HelloText </strong>组件更加强大，因为道具是灵活的，你可以发送任何有效的<strong class="kt ir"> JavaScript </strong>类型。在这种情况下，我们只发送了一个<strong class="kt ir">文本</strong>，但是您也可以发送其他组件。</p><p id="c749" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是时候给我们的组件添加更多的功能了，我们将在按下标题文本后展开第三个文本块。为了实现这个功能，我们需要存储一个<strong class="kt ir">状态</strong>，它会记住组件是展开还是折叠。</p><h2 id="bb35" class="mk lo iq bd lp ml mm dn lt mn mo dp lx la mp mq lz le mr ms mb li mt mu md mv bi translated">以下是我们需要做出的改变:</h2><ol class=""><li id="55a1" class="mw mx iq kt b ku mf kx mg la my le mz li na lm nb nc nd ne bi translated">首先，我们需要将组件更改为一个<strong class="kt ir">类语法。</strong></li><li id="1ca4" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated">为了利用React库中的状态对象，我们必须在类构造函数中初始化状态，并在默认情况下使<strong class="kt ir">文本</strong>折叠。</li><li id="aa27" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated">给组件<strong class="kt ir"> <em class="nf">添加条件渲染</em> </strong>功能。</li><li id="a69f" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated">添加新闻处理程序，一旦我们点击标题或文本，它将改变状态。</li></ol><p id="25e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里做了这些更改后，我们的代码看起来会是什么样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nx"><p id="6043" class="ny nz iq bd oa ob oc od oe of og lm dk translated">现在为了理解设计模式，我们将做一些更有挑战性的事情(任务列表)</p></blockquote><p id="1aa5" class="pw-post-body-paragraph kr ks iq kt b ku oh jr kw kx oi ju kz la oj lc ld le ok lg lh li ol lk ll lm ij bi translated">要创建以下功能，构造函数应该在其状态下初始化任务列表，在本例中，任务列表将是一个字符串数组。它将迭代任务，为每个任务&amp;创建<strong class="kt ir"> <em class="nf">文本</em> </strong>组件，这应该发生在<strong class="kt ir">应用</strong>组件的渲染函数中。</p><p id="7905" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意，您可以简单地使用map函数迭代，而不是使用<em class="nf"> for </em>循环。</strong></p><blockquote class="nr ns nt"><p id="e4ad" class="kr ks nf kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">在这里做了修改后，它看起来会是什么样子。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="4767" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">为什么是无状态组件？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/33023f803dbeae355137a1f66f26be33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u6uErS9dKUav9_DX"/></div></div></figure><p id="4429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会选择使用有状态类组件，并用它开发一个完整的应用程序，但为什么我们还要为此费心呢，答案是性能。无状态功能组件可以更快地呈现，因为无状态功能组件不需要一些生命周期挂钩。</p><blockquote class="nx"><p id="83c2" class="ny nz iq bd oa ob on oo op oq or lm dk translated">F <!-- -->功能性组件速度更快，在大多数情况下都优于扩展<strong class="ak"><em class="os">react . pure component .</em></strong>的类组件</p></blockquote><h1 id="1735" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ot jx lz jz ou ka mb kc ov kd md me bi translated">React中的成分组成是什么？</h1><p id="a4c5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在任何其他的<strong class="kt ir"> OOP </strong>语言中，你必须广泛使用继承。但是在<strong class="kt ir"> JavaScript </strong>中，继承是基于<strong class="kt ir"> proptypes </strong>的，我们称之为<strong class="kt ir">原型继承。</strong>功能不会复制到对象中，而是从对象的原型中继承，甚至可能通过原型树中的其他原型继承。</p><p id="d24a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<em class="nf"> React </em>中，继承不是一个非常常见的概念，因为我们有组件，这里我们采用另一种模式，称为<strong class="kt ir">组件组合。我们不是创建一个新类并从基类继承，而是创建一个新的父组件，它将使用它的子组件来使自己更强大。</strong></p><p id="f9ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Component Composition</strong></figcaption></figure><p id="b88f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> App </strong>组件是使用:<strong class="kt ir"> View，Text &amp; WarningText </strong>构建的，这是一个完美的例子，展示了一个组件如何通过组件组合来重用其他组件的功能。</p><p id="3f1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">警告文本</strong>组件使用合成来使用<strong class="kt ir">文本</strong>组件中的橙色文本颜色，这使得通用<strong class="kt ir">文本</strong>组件更加具体。我们现在可以在应用程序中任何需要的地方重用<strong class="kt ir">警告文本</strong>。</p><blockquote class="nr ns nt"><p id="84cc" class="kr ks nf kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">如果你正在做一个真正的<strong class="kt ir"> React-Native项目</strong>并且设计师打算改变颜色，你可以使用这些<strong class="kt ir">设计模式</strong>实践来快速适应新的设计。</p></blockquote><h1 id="efc5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">撰写应用程序布局</h1><p id="ff23" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们将在应用程序中创建一个简单的欢迎屏幕。</p><p id="71ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分为3个部分:</p><ol class=""><li id="b02e" class="mw mx iq kt b ku kv kx ky la ow le ox li oy lm nb nc nd ne bi translated"><strong class="kt ir">表头。</strong></li><li id="bee7" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated"><strong class="kt ir">主要内容。</strong></li><li id="7145" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated"><strong class="kt ir">页脚。</strong></li></ol><p id="ab05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目的是为登录用户和匿名用户创建一致的边距和样式。要创建这样的组件:</p><ol class=""><li id="5ea4" class="mw mx iq kt b ku kv kx ky la ow le ox li oy lm nb nc nd ne bi translated">创建执行某些样式的<strong class="kt ir"> AppLayout </strong>组件，它应该接受三个道具:<strong class="kt ir"> <em class="nf"> header，MainContent &amp; Footer。</em> </strong></li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/36702e0e4f2edf7ac6fa549698c1b61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRjOiksnBoXhisWdKG66Xg.png"/></div></div></figure><p id="2ba0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.现在我们将为页眉、页脚和内容创建占位符。这些被命名为<strong class="kt ir"> WelcomeHeader，welcome content&amp;welcome footer。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/b577d4ee3fa8e1bf97069dfd1eb0295e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzu0ozQMVhkyuZm9ACiyjw.png"/></div></div></figure><p id="867d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.现在我们必须将<strong class="kt ir"> AppLayout </strong>与我们的占位符组件连接起来，并创建<strong class="kt ir"> WelcomeScreen </strong>来将占位符组件作为道具传递给AppLayout。</p><p id="d8cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.在为我们的应用程序的根组件创建一些样式的最后一步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">WelcomeScreen</strong></figcaption></figure><h1 id="5a4e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">表示组件模式</h1><p id="fe27" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在，我们将学习创建可重用的组件，使它们可以灵活使用，为了实现这一点，最好的模式是<strong class="kt ir"> <em class="nf">表示组件模式。</em>T15】</strong></p><blockquote class="nr ns nt"><p id="2f8a" class="kr ks nf kt b ku kv jr kw kx ky ju kz nu lb lc ld nv lf lg lh nw lj lk ll lm ij bi translated">如果你在某个地方熟悉使用Redux，那么你一定经常听到这个模式。</p></blockquote><p id="4a2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个网站都有3个主要模块:<strong class="kt ir"> CSS，HTML &amp; JavaScript。然而，在<strong class="kt ir"> React </strong>中，方法有点不同，因为基于JavaScript的HTML自动生成使HTML变得虚拟。(你可能听说过<strong class="kt ir">虚拟文档对象模型——虚拟DOM)。</strong></strong></p><p id="4356" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">概念的分离——HTML、CSS和JavaScript应该只存在于JavaScript世界中，这就是为什么我们使用表示组件来模拟逻辑的HTML和容器组件。要理解这一点，请看下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Presentational Component</strong></figcaption></figure><ol class=""><li id="3894" class="mw mx iq kt b ku kv kx ky la ow le ox li oy lm nb nc nd ne bi translated">我们将标记移到了单独的表示组件中。</li><li id="4336" class="mw mx iq kt b ku ng kx nh la ni le nj li nk lm nb nc nd ne bi translated">之后我们更换了<strong class="kt ir">渲染</strong>功能。</li></ol><p id="abc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您运行代码，您将在<strong class="kt ir"> HelloText </strong> press事件上收到一个错误，这是由于<strong class="kt ir"> JavaScript </strong>如何处理<strong class="kt ir"> <em class="nf">这个</em> </strong>关键字。我们将<strong class="kt ir"> expandOrCollapse </strong>函数传递给另一个对象，这里<strong class="kt ir"> <em class="nf">指的是一个不同的对象(它不能访问状态的原因)。</em>T41】</strong></p><blockquote class="nx"><p id="a708" class="ny nz iq bd oa ob on oo op oq or lm dk translated">为了<!-- -->解决这个错误，我们将坚持使用箭头函数，考虑到应用程序的最佳性能，这是最好的方法。</p></blockquote><blockquote class="nr ns nt"><p id="76e5" class="kr ks nf kt b ku oh jr kw kx oi ju kz nu oj lc ld nv ok lg lh nw ol lk ll lm ij bi translated"><strong class="kt ir"> <em class="iq">所以现在我们成功地将一个组件重构为两个(一个负责表示，一个负责逻辑)。</em>T46】</strong></p></blockquote><h1 id="fe2d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">分离风格</h1><p id="8434" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在上面使用的例子中，样式与表示组件紧密耦合，因为我们通过使用<strong class="kt ir"> style={styles.container} </strong>显式地包含它们，因为样式对象是不可配置的，所以我们不能替换任何<strong class="kt ir">样式道具</strong>。在某些情况下，这是理想的实现，但这对开发人员来说是一个麻烦，因为他们必须查找特定的<strong class="kt ir">样式道具</strong>来进行任何进一步的新更改。</p><p id="2df8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们将使用的方法是非常可取的，那就是使样式成为可选的道具，如果没有提供样式，我们可以回到默认值。T9】</p><p id="0c47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">观察<strong class="kt ir"> ||操作符</strong>在styles *<strong class="kt ir">(conatinerStyles | | styles . container)*中的使用。</strong>它首先检查<strong class="kt ir"> conatinerStyles </strong>是否被定义，如果它没有返回任何值，那么它返回styles.container，默认情况下这是我们硬编码的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">Decoupling Styles</strong></figcaption></figure><h1 id="a229" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">高阶组件(HOC)模式</h1><p id="7e4a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这种模式的存在是为了用额外的道具或功能来增强组件，或者如果你想让它们变得可有可无。</p><p id="4a66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不只是创建一个有状态容器，而是使用HOC模式来实现，让我们将<strong class="kt ir">有状态</strong>容器组件重构为一个HOC，并将其命名为<strong class="kt ir"> <em class="nf"> makeExpandable。</em> </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">HOC</strong></figcaption></figure><p id="a79e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">makeExpandable组件接受ComponentToEnrich，因此我们可以创建一个根组件(App ),如下所示:</p><blockquote class="nx"><p id="e4e8" class="ny nz iq bd oa ob on oo op oq or lm dk translated"><strong class="ak">导出默认make expandable(hello box)；</strong></p></blockquote><p id="7690" class="pw-post-body-paragraph kr ks iq kt b ku oh jr kw kx oi ju kz la oj lc ld le ok lg lh li ol lk ll lm ij bi translated">为了更好地理解这一点，我们创建了一些其他组件，并用我们的<strong class="kt ir"> HOC </strong>来丰富它，它将是一个显示文本hide或show的小按钮(它将显示或隐藏一个小的彩色框)。</p><p id="80aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><strong class="ak">HOC Hide Button</strong></figcaption></figure><p id="794a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在前面的示例中，SomeSection组件由<strong class="kt ir"> makeExpandable </strong> HOC包装，并接收<strong class="kt ir"> isExpanded </strong>和<strong class="kt ir">expander collapse</strong>属性。</p><p id="56a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nf">为了让它更加灵活，我将使用一个非常有用的技巧:</em> </strong></p><p id="94bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们有一个包含以下属性的组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/903b4bdef51567a6617bef66fda69075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsi9skqWWU-g3VaU59ZejA.png"/></div></div></figure><p id="795c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用以下渲染模式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/6b605d726c7853cf96ed4e3c72d95e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qzmUCeR8ZUOH7kn5wyPQA.png"/></div></div></figure><p id="6b4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这部分有点棘手，因为它提供了重命名传递给HOC的属性的能力，要重命名它，我们需要传递一个名为<strong class="kt ir"> propNames </strong>的配置对象给HOC，如果传递了这样一个对象，并且它包含s key，那么我们覆盖这个名称。</p><p id="8315" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我们必须确保在<strong class="kt ir"> <em class="nf">渲染</em> </strong>函数中创建变量时的性能影响，因为这会降低应用程序的速度。</p><p id="2aed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用模式可能会牺牲一点性能，但有时不会，所以要明智地使用它们。</p><p id="7554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">感谢阅读；</strong></p></div></div>    
</body>
</html>