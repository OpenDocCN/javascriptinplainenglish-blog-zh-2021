<html>
<head>
<title>Publish npm packages using CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CircleCI发布npm软件包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/publish-npm-packages-using-circleci-31f73abd5263?source=collection_archive---------18-----------------------#2021-01-04">https://javascript.plainenglish.io/publish-npm-packages-using-circleci-31f73abd5263?source=collection_archive---------18-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="edf4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用CirclerCi发布npm软件包的正确CI/CD设置和工作流</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95db8c4a777e45df392d5f4515aaaee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWuH3Zackjj2z1cmDXWj5g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@fakurian" rel="noopener ugc nofollow" target="_blank">Milad B. Fakurian</a></figcaption></figure><h1 id="ee65" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="9bfa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您总是可以在本地机器上手动发布您的npm包，但是如果您想为它创建CI/CD过程呢？这个问题引入了许多其他问题，比如如何管理分支或版本，如何管理产品发布。在本文中，我们将探索一个简单的基础过程，您可以根据您的项目偏好对其进行扩展。包含用于正确CI/CD流程的主要模块的基础。</p><p id="aa2c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">发布有一些副作用:</p><ul class=""><li id="b521" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">版本控制</li><li id="c6dd" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">不同阶段/环境释放</li><li id="7413" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">跟踪发布</li></ul><p id="2283" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们需要的是一个支持团队和项目需求的工作流。有两个著名的工作流影响了软件开发社区。<a class="ae kv" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> Github-Flow </a>和<a class="ae kv" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Git-Flow </a>，我们要用的是Github-Flow但是有一篇很好的<a class="ae kv" href="https://medium.com/swlh/git-flow-vs-github-flow-3ad44bd46407" rel="noopener">文章</a>讨论了两者的区别。</p><h1 id="fd1a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Github流</h1><p id="a3f0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Github-Flow中的主分支总是为产品发布做好准备，发布定期进行，并且分支是轻量级的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/4fbd8e899aa453c06b78261e24ab0a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qf6h0g4rwVo61dSjWw_qRg.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank">Github Flow</a></figcaption></figure><ul class=""><li id="ca77" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">为某个功能或错误修复创建分支</li><li id="c5e0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">添加提交</li><li id="0d2c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">打开拉式请求</li><li id="647f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">讨论和回顾</li><li id="d4c6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">合并和部署</li></ul><h1 id="1eb8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">发布工作流</h1><p id="f8b7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以下是我们基于Github流程的规则:</p><ul class=""><li id="2814" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">仅对打开的拉取请求运行测试和构建流程</li><li id="ff51" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">只有当测试通过并且构建成功时，合并才可用</li><li id="b2f3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">其他分支机构将跳过CI/CD工作流程</li><li id="28f3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">对<code class="fe ne nf ng nh b">master</code>分支的任何提交或合并都会触发释放过程</li><li id="0938" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">更改只能通过拉请求应用于<code class="fe ne nf ng nh b">master</code>,并且受到保护</li><li id="1d75" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">使用<code class="fe ne nf ng nh b">npm publish patch</code>增加补丁版本</li><li id="7848" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">为了增加次要版本和主要版本，应该通过拉请求来实现</li><li id="2c2f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe ne nf ng nh b">npm publish</code>创建一个<strong class="lq ir"> git标签</strong></li><li id="d156" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">发布后，我们需要在不触发CI/CD工作流的情况下，将<code class="fe ne nf ng nh b">tag</code>和更新的<code class="fe ne nf ng nh b">package.json</code>推回到主分支</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/4b007ffd25b3f61ae2e5d28b6d9a3c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tkiD3tultq3VJwnp6yIqQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Release NPM Package with CircleCI Workflow</figcaption></figure><h1 id="1f9f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">CircleCI配置文件</h1><p id="2bb4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，在您的项目中创建<code class="fe ne nf ng nh b">.circleci</code>文件夹，并创建<code class="fe ne nf ng nh b">config.yml</code>文件，其中包含发布工作流的CircleCi配置。我将分解每个部分，但在此之前，如果你不熟悉CircleCI，你可以从这里开始。</p><p id="8a80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">工作流程由3个步骤组成:</p><ul class=""><li id="05bb" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">试验</li><li id="2be4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">建设</li><li id="9e45" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">释放；排放；发布</li></ul><p id="b149" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最需要考虑的是<code class="fe ne nf ng nh b">npm publish</code>有副作用。<code class="fe ne nf ng nh b">npm publish</code>用发布版本标记分支，并用版本号更新<code class="fe ne nf ng nh b">package.json</code>文件。最棘手的部分是在不触发CircleCI工作流和导致无限循环的情况下将这些更改收回到git存储库中。</p><h2 id="5137" class="nj kx iq bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated"><strong class="ak">初始配置</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d1d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在该文件的顶部，我们定义了CircleCi版本，该版本代表了我们可以在该文件中使用的功能集，我们还将创建一些默认配置，这些配置将被作业重用。可重用配置是YAML的特性，而不是CircleCI的配置定义方式。这就是所谓的YAML的<code class="fe ne nf ng nh b">anchor</code> <a class="ae kv" href="https://blog.daemonl.com/2016/02/yaml.html" rel="noopener ugc nofollow" target="_blank">特色</a>。点击阅读更多关于YAML锚以及如何使用它来重用配置<a class="ae kv" href="https://circleci.com/blog/circleci-hacks-reuse-yaml-in-your-circleci-config-with-yaml/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="7355" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认配置包括<code class="fe ne nf ng nh b">working_directory</code>和默认的docker图像，每个作业将在相应的容器中运行。</p><h2 id="0f98" class="nj kx iq bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated">测试作业</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f724" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们将用他们的步骤来定义我们的工作。在上面的代码中，我们定义了<code class="fe ne nf ng nh b">jobs</code>，第一个作业是<code class="fe ne nf ng nh b">test</code>。第3行注入测试作业的默认配置，即<code class="fe ne nf ng nh b">working_directory</code>和<code class="fe ne nf ng nh b">docker image</code>，作业的容器将基于此创建。</p><p id="f08b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">测试作业检查代码，然后根据CircleCI缓存中的<code class="fe ne nf ng nh b">package.json</code>校验和恢复<code class="fe ne nf ng nh b">node_module</code>依赖关系，并运行<code class="fe ne nf ng nh b">npm install</code>和<code class="fe ne nf ng nh b">npm test</code>命令来检查此阶段的一切是否正确。最后，将包括<code class="fe ne nf ng nh b">node_module</code>在内的更改保存到工作区，供下次作业使用。</p><h2 id="20ad" class="nj kx iq bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated"><strong class="ak">建造工作</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="289b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个非常简单，它从第4行的工作区中获取最新的变更，并运行<code class="fe ne nf ng nh b">npm run build</code>命令来构建项目。最后，将更改保存回工作区。</p><h2 id="9873" class="nj kx iq bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated">发布作业</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a82a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Release job还会从工作区中提取所有内容，然后将Github.com添加到容器的<code class="fe ne nf ng nh b">known_hosts</code>文件中，因为在这个作业中我们会将一些更改推回GitHub。版本控制步骤使用<code class="fe ne nf ng nh b">-m</code> <strong class="lq ir"> </strong>参数运行<code class="fe ne nf ng nh b">npm version patch</code>，该参数为<a class="ae kv" href="https://docs.npmjs.com/cli/v6/commands/npm-version" rel="noopener ugc nofollow" target="_blank">提交消息</a>获取一个字符串。</p><p id="91d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ne nf ng nh b">[skip ci]</code>告诉CircleCI跳过这个提交。下一步是将包括更新的<code class="fe ne nf ng nh b">package.json</code>提交和<strong class="lq ir"> git标签</strong>在内的变更推回到git仓库。最后，通过将npm令牌添加到<code class="fe ne nf ng nh b">.npmrc</code>文件并运行<code class="fe ne nf ng nh b">npm publish</code>，新版本在npmjs.com上发布。</p><p id="2721" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以通过在项目的根目录下放置一个类似下面的<code class="fe ne nf ng nh b">.npmignore</code>文件来控制您想要发布到npm的内容。我的<code class="fe ne nf ng nh b">npm run build</code>命令将包构建到<code class="fe ne nf ng nh b">lib</code>文件夹中，所以我释放了包括<code class="fe ne nf ng nh b">package.json</code>和<code class="fe ne nf ng nh b">lib</code>文件夹在内的所有东西，不需要的文件和文件夹除外。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">.npmignore file — controls files not to publish</figcaption></figure><p id="86c0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过CircleCI仪表板上的设置页面将<code class="fe ne nf ng nh b">EMAIL</code>、<code class="fe ne nf ng nh b">GIT_AUTHOR_NAME</code>和<code class="fe ne nf ng nh b">GIT_COMMITTER_NAME</code>添加到项目的环境变量中。为了能够在工作流中执行git操作，这是必须的。</p><p id="75de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，<code class="fe ne nf ng nh b">NPM_TOKEN</code>将通过<a class="ae kv" href="https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-project" rel="noopener ugc nofollow" target="_blank"> CircleCI仪表板</a>上的项目设置页面作为环境变量提供，这将由npm用于发布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/2568c7b79bd576126aec27c34d3fe2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYXL94tZqyWX2uBUnpQKZQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">CircleCI — Project Setting Page — Environment Variables</figcaption></figure><p id="d14d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了能够对git存储库进行更改，包括使用更新的<code class="fe ne nf ng nh b">package.json</code>提交和CircleCI仪表板上项目设置页面中的新版本git标签，我们需要配置一个用户密钥。(<a class="ae kv" href="https://support.circleci.com/hc/en-us/articles/360018860473-How-to-push-a-commit-back-to-the-same-repository-as-part-of-the-CircleCI-job" rel="noopener ugc nofollow" target="_blank">这很重要</a>)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/5adf4f85366bb5cc83c4fde547094dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXVCtOH29y7AnEDHvqA0IQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">CircleCI — Project Setting Page — SSH Keys</figcaption></figure><h2 id="9be8" class="nj kx iq bd ky nk nl dn lc nm nn dp lg lx no np li mb nq nr lk mf ns nt lm nu bi translated">工作流程</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="76af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们用特定的步骤定义了作业之后，我们将告诉CircleCI以什么顺序运行它们。这将使用<code class="fe ne nf ng nh b">workflow</code>定义来完成。第一个要运行的作业是<code class="fe ne nf ng nh b">test</code>，它没有任何先决条件。<code class="fe ne nf ng nh b">build</code>依赖于成功的<code class="fe ne nf ng nh b">test</code>，因此使用CircleCI配置规范，我们定义构建需要第7行中的测试。最后，发布依赖于成功的构建，并且只发生在主分支上。通过过滤分支，我们排除了在其他分支上运行这个步骤，并且主服务器上的一切都是生产就绪的。</p><h1 id="058c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">CircleCI完整配置</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="c83d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><p id="39ac" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以下是一些帮助我了解CircleCI和Github Flow的链接。</p><ul class=""><li id="8722" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><a class="ae kv" href="https://lucamezzalira.com/2014/03/10/git-flow-vs-github-flow/" rel="noopener ugc nofollow" target="_blank">https://lucamezzalira . com/2014/03/10/git-flow-vs-github-flow/</a></li><li id="64ae" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://medium.com/swlh/git-flow-vs-github-flow-3ad44bd46407" rel="noopener">https://medium . com/swlh/git-flow-vs-github-flow-3a d44 BD 46407</a></li><li id="b13d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://docs.npmjs.com/cli/v6/commands/npm-version" rel="noopener ugc nofollow" target="_blank">https://docs.npmjs.com/cli/v6/commands/npm-version</a></li><li id="ebf7" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://circleci.com/blog/circleci-hacks-reuse-yaml-in-your-circleci-config-with-yaml/" rel="noopener ugc nofollow" target="_blank">https://circle ci . com/blog/circle ci-hacks-reuse-YAML-in-your-circle ci-config-with-YAML/</a></li><li id="5d0f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://discuss.circleci.com/t/using-defaults-syntax-in-config-yaml-aka-yaml-anchors/16168" rel="noopener ugc nofollow" target="_blank">https://discuse . circle ci . com/t/using-defaults-syntax-in-config-YAML-aka-YAML-anchors/16168</a></li><li id="8f70" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank">https://guides.github.com/introduction/flow</a></li><li id="7b28" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-project" rel="noopener ugc nofollow" target="_blank">https://circle ci . com/docs/2.0/env-vars/#在项目中设置环境变量</a></li><li id="41f5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://support.circleci.com/hc/en-us/articles/360018860473-How-to-push-a-commit-back-to-the-same-repository-as-part-of-the-CircleCI-job" rel="noopener ugc nofollow" target="_blank">https://support . circle ci . com/HC/en-us/articles/360018860473-How-to-push-a-commit-back-to-the-same-repository-as-part-of-the-the-circle ci-job</a></li><li id="1767" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">https://hacker noon . com/how-to-publish-your-package-on-NPM-7 fc 1 f 5 aae 600</li></ul></div></div>    
</body>
</html>