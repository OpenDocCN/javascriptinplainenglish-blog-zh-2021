# 如何在 JavaScript 中创建和使用哈希表

> 原文：<https://javascript.plainenglish.io/hash-tables-in-javascript-cb2b804cd1c8?source=collection_archive---------5----------------------->

![](img/2137a1fa3ed963ae238682e388542322.png)

Photo by [Pisit Heng](https://unsplash.com/@pisitheng?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

哈希表是由键和值对组成的数据结构。一个很好的类比是把它想象成一本字典(书)，关键字是单词，值是定义。如果你觉得这听起来很熟悉，那你就对了，JavaScript 对象就是哈希表的一个例子。也就是说，使用 JavaScript 的内置对象或映射，会比我在这里实现的更快更好。这篇博客更多的是关于理解哈希表背后的概念。

# 散列表的利与弊

## 赞成的意见

*   快速查找
*   快速插入
*   快速删除

## 骗局

*   哈希冲突(特别是当有很多哈希冲突时)
*   对少量数据效率不高
*   对于在不知道键的情况下搜索值来说不是很有效(在哈希表中迭代)
*   不适合排序

# 履行

## 从数组开始

为了实现哈希表，我们将利用数组的快速查找和插入时间。为此，我们将初始化一个数组，其大小大致相当于我们要存储的键和值对的数量(我们将创建一个动态大小的哈希表，所以如果我们不知道数量，也没关系)。在这里，我们将创建一个散列函数。

## 散列法

散列的目的是给定一个键，它将生成一个在数组边界内的索引。给定相同的密钥，哈希算法总是产生相同的索引，这一点很重要。这样我们就可以通过给定的键来查找条目。散列算法相对较快也很重要，因为每个条目和查找都必须运行它。

在一个完美的实现中，每个给定的键会产生一个唯一的索引，这被称为完美散列函数。但是，您更有可能遇到两个或更多产生相同索引的键。这叫做碰撞。

## 碰撞

由于碰撞几乎是不可避免的，我们需要一种方法来处理它们。一般来说，有两种方法来处理冲突。

**单独链接**

这包括在散列表的每个索引处存储一些其他类型的列表结构。这是我将在这里讨论的方法。有许多不同的方式进行单独的链接，每一种都有自己的优点和缺点。我就不多说了。

**开放寻址**

开放式寻址不是在哈希表的每个索引处存储另一个列表，而是在给定索引处已经有一个元素时实现一个探测序列。简而言之，探测序列是关于在哈希表中下一步在哪里查找以尝试找到空槽的指令。

例如，在线性探测中，探测器之间的间隔是固定值。所以如果你的哈希函数给你的索引是 0，但是已经有了，你可以加 4，如果索引是 4，你再加 4，那么索引 8 是空的，所以你可以在那里存储你的键和值对。

# 密码

我将使用一个 JavaScript 类来实现一个散列表。这是类和构造函数，从这里开始，所有的代码都将进入这个类。

“桶”是一个术语，用于表示存储在索引中的一系列键和值对。在独立链接中，一个桶中可以存储不止一个键和值对，而在开放式寻址中，一个桶中只存储一个键和值对。

现在我们需要我们的散列函数。

Link to source for hash function: [https://logicmason.com/2013/how-to-implement-a-hash-table/](https://logicmason.com/2013/how-to-implement-a-hash-table/)

我从上面的链接得到了这个散列函数，功劳归于马克·威尔伯。我不明白为什么它会给我们这么好的分布。我已经在代码的注释中尽可能多地解释了这一点。你将在大多数(如果不是全部)散列函数中看到的最重要的部分是使用模数(%运算符)。这确保了数字在数组索引的范围内。

因为我们的索引是通过散列函数确定的，所以让我们使用一些方法来轻松地将一个键转换成一个索引，并在该索引处抓取桶。

记住，bucket 可以包含多个键和值对。因此，虽然我们有办法访问 bucket，但是我们还需要做更多的工作来访问正确的键和值对。

在我们能够检索任何元素之前，我们需要能够插入它们。

我们的代码在这里变得有点复杂。首先，我们需要确定存储桶的索引。然后我们看看这个桶是否存在(如果里面什么都没有，那么访问这个索引将返回`undefined`)。如果不存在，实例化一个空数组来存储我们的键和值对。

从那里我们可以获取`bucket`本身(即使它只是一个空数组)。如果我们已经插入了一个键和值对，我们需要覆盖与之相关的值。如果没有，我们需要将它插入桶中。

我们将键和值对存储为一个元组。元组是包含两个项目的数组。因此，我们知道我们的键总是在索引 0，我们的值在索引 1。所以我们的桶是充满元组的数组。

我们遍历我们的桶，如果有一个键与我们插入的键匹配，我们就覆盖这个值。如果没有，我们就把它推进桶里。如果我们必须把它推进去，我们就增加我们的尺寸。

从那里我们检查哈希表是否需要调整大小(有时称为重散列)。这由装载系数决定，装载系数实质上是装满的铲斗与最大尺寸之间的比率。在时间和空间复杂度之间具有良好折衷的负载因子在. 25 和. 75 之间。

你可以这样考虑装载系数，我们的铲斗越少，就越有可能发生碰撞。但是，一堆空桶占用了不必要的空间。

让我们来看看`resize`法。

该函数获取当前的存储桶，并将它们存储在一个临时变量(`tempBuckets`)中。在那里，我们将大小重置为 0，并清除当前的存储桶。我们遍历我们的`tempBuckets`,将每个键和值对添加回调整后的哈希表中。我们通过我们的`set`方法运行它，因为它使用`getIndex`来运行我们的散列函数。我们需要再次这样做，因为我们的散列函数的结果取决于散列表的最大大小。因此，我们的旧指数不会与新指数保持一致。

现在我们知道了如何添加元素，以及调整哈希表的大小时会发生什么。让我们看看`get`方法，我们用它来检索给定的键和值对的值。

给我们一把钥匙，我们取回水桶。我们遍历该桶中的键和值对，并返回与给定键相关联的值。如果没有 bucket，我们就不会将那个键插入哈希表，所以我们返回`undefined`。

我们可以用`get`和`set`元素。让我们创建一个`remove`方法！

对于`remove`，这是一个类似于`get`的概念。我们找到正确的桶，并遍历桶，直到找到正确的键。我们将`splice`存储桶，而不仅仅是返回它，以便从中移除那个键和值对。如果加载因子很低，我们将调整哈希表的大小。然后我们返回我们移除的节点的值。

就是这样！我们可以在哈希表中插入、检索和删除元素。

# 时间和空间复杂性

## 时间复杂度

您可能想知道，由于所有的额外复杂性，这怎么比数组快呢？我们正在遍历一个包含列表(桶)的列表，以便找到正确的键和值对！

创建哈希表的主要目标是尽可能减少冲突。大多数情况下，一个桶中只有一个键和值对，所以即使我们在搜索，也应该立即找到。

让我们看看上述方法的时间复杂性:

*   `HashFunction`、`getIndex`、`getBucket`都是 O(1)。`HashFunction`的运行时间是由键的长度决定的，所以和哈希表本身的大小无关。
*   `get`最糟糕的情况是，每个键和值对都存储在同一个桶中，我们要找的那个在最后。这将导致 O(n)个时间复杂度。然而，如前所述，这种情况非常罕见。通常`get`需要 O(1)个时间。
*   `set`，假设我们不需要调整哈希表的大小，类似于`get`。最坏的情况是，所有对都在同一个桶里，我们需要把它加到最后。但是，大多数时间需要 O(1)次。
*   `remove`，最坏的情况是 O(n)。这是因为如果我们需要删除包含所有对的桶中的最后一对。我们将首先遍历所有的对，得到正确的对，然后使用`splice`即 O(n)。这是 O(n + n)，简化为 O(n)。但是，在大多数情况下，一个存储桶中只有一对，因此需要 O(1)。
*   `resize`将始终取 O(n)。因为我们需要将每一对复制到调整了大小的哈希表中。

因此，对于查找、删除和插入，最坏的时间复杂度是 O(n)，但更可能是 O(1)。

## 空间复杂性

哈希表的空间复杂度是 O(n)。这是因为我们正在动态调整哈希表的大小。哈希表中存储桶的数量应该具有 0 . 25 到 0 . 75 的负载系数。这意味着在任何给定的点上，哈希表应该在 25%到 75%之间，如果不是，我们就调整大小。因此，随着配对数量的增加或减少，我们的桌子也相应地增加和减少。

# 最后

哈希表是一种有用的数据结构，用于解决许多现实世界中的问题。它们的一些用例包括:编译器使用它们来识别关键字、缓存和数据库索引。当您有大量相关数据时，哈希表是很好的选择，其中顺序并不重要。我想我会坚持 JavaScript 的内置数据结构，但是观察事物在幕后是如何工作的总是很有趣的。你可以从这个博客的[这个 GitHub 库](https://github.com/ReginaF2012/javascript-hash-table)中找到代码。