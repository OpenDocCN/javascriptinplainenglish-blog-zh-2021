<html>
<head>
<title>How to Use React’s useCallback Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React的useCallback钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-reacts-usecallback-hook-24f444ec08a9?source=collection_archive---------9-----------------------#2021-05-13">https://javascript.plainenglish.io/how-to-use-reacts-usecallback-hook-24f444ec08a9?source=collection_archive---------9-----------------------#2021-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c867" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React中的useCallback钩子到底是什么，为什么要用它？在本文中，您将了解useCallback钩子到底是什么，它的优点是什么，以及如何使用它来优化应用程序的性能。听起来不错？让我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ece3ddcaeea65d0984f53f7d28d33d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FoiwI0lStkbSeUi4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8a33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React文档将useCallback钩子定义为“<strong class="jm io">一个记忆化的回调”。回调只是函数的一个花哨的名字。所以回调基本上是一段代码，它接受一个输入并返回一些信息。</strong></p><p id="bf98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么<strong class="jm io">记忆化</strong>回调到底是什么意思呢？这意味着它被存储起来，不必在每次组件重新呈现时重新初始化。为了理解这一点，让我们以下面的例子为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="0f6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么这段代码发生了什么呢？首先，我们创建两个组件，一个ParentComponent和一个ChildComponent。在ParentComponent中，在<em class="lb">第4行</em>上，我们初始化了一个函数，你必须想象这个函数执行一个API请求并返回结果。我们将这个函数传递给第11行上的ChildComponent。然后，在我们的ChildComponent中，我们使用useMemo钩子进行了一次昂贵的计算，并将其存储在内存中。在<em class="lb">第27行</em>我们呈现了这个昂贵计算的结果。</p><p id="0e64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码的性能对您的应用程序来说可能是毁灭性的，您能猜到原因吗？</p><p id="0e10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题在于“getSomethingFromApi”函数是“expensiveCalculation”的依赖项。当我们的父组件重新呈现时，所发生的是函数“getSomethingFromApi”被重新初始化。这意味着我们的“expensiveCalculation”的依赖性将会改变，这意味着每次重新呈现父对象时，将会重新触发昂贵的计算。<strong class="jm io">这样对性能不好！</strong></p><p id="5cfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看如何使用useCallback钩子来获得一个'<strong class="jm io"> Memoized </strong>'回调，并防止代价高昂的计算重新触发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="e2cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的代码中没有太多变化，在第6行，我们已经将函数包装在一个useCallback钩子中。就是这样。</p><p id="52a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的函数现在被记忆化了，这意味着在重新呈现ParentComponent时它不会被重新初始化。这也意味着引用不会在ChildComponent中改变，并且expensiveCalculation不会被重新执行！太神奇了！如果子组件被渲染很多次，你的小添加将会产生巨大的效果。这显示了useCallback钩子的威力。</p><p id="b150" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在不同的情况下，您可能会发现使用useCallback挂钩很有趣。在依赖关系比较的上下文中，正如在这个例子中看到的，它当然有助于实现我们编写高性能应用程序的目标。</p><p id="7f6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，您了解了useCallback钩子，以及它如何帮助您提高应用程序的性能。请注意，这种解决方案并不适合所有的用例，有时记忆计算或回调的成本更高，然后使用像useMemo或useCallback这样的钩子可能是有害的。小心，继续测试，祝你好运！</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="6fda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个月，我将介绍一些鲜为人知的React钩子以及它们的具体用途。我的上一篇文章介绍了“useReducer”挂钩，如果您有兴趣阅读，可以在这里找到它:</p><div class="lj lk gp gr ll lm"><a href="https://diederik-mathijs.medium.com/create-a-comment-system-using-1-react-hook-4169ba8f4d6a" rel="noopener follow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd io gy z fp lr fr fs ls fu fw im bi translated">构建一个只有1个React钩子的评论系统。</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">最近，我发现了React中各种钩子的惊人的可能性。这就是为什么每周…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">diederik-mathijs.medium.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma ks lm"/></div></div></a></div><p id="c561" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lb">更多内容尽在</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lb">plain English . io</em></a></p></div></div>    
</body>
</html>