<html>
<head>
<title>How To Speed Up Your Docker Builds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何加速你的Docker构建</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/docker-build-example-nodejs-9eb174e081f1?source=collection_archive---------9-----------------------#2021-01-05">https://javascript.plainenglish.io/docker-build-example-nodejs-9eb174e081f1?source=collection_archive---------9-----------------------#2021-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e009" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Node.js应用程序示例中，从60秒增加到6秒</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cc4d3f1c9b734fae82eb7bf8ecd25c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjowdlr2ZUvz8gIY9c8MeQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ventiviews?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Cameron Venti</a> on <a class="ae kv" href="https://unsplash.com/s/photos/whale?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6f61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本帖中，我们将看到一个Node.js API应用程序的docker构建示例，从慢到快了大约10倍。我已经谈到了在开发环境中使用docker的<a class="ae kv" href="https://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective/" rel="noopener ugc nofollow" target="_blank">原因。我在过去的帖子中也提到过</a><a class="ae kv" href="https://geshan.com.np/blog/2018/11/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade/" rel="noopener ugc nofollow" target="_blank">docker如何改变我们软件工程师的工作方式</a>和<a class="ae kv" href="https://geshan.com.np/blog/2019/11/how-to-use-docker-multi-stage-build/" rel="noopener ugc nofollow" target="_blank">多阶段docker构建</a>。对于这一个，让我们着眼于docker构建示例，考虑更快的构建。</p><h1 id="6241" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">跳进去之前的信息</h1><ol class=""><li id="2152" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">需要熟悉docker和Docker构建过程</li><li id="43f0" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">所有的例子都是基于苹果电脑上的<code class="fe na nb nc nd b">Docker version 19.03.13, build 4484c46d9d</code></li><li id="d6d7" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">这个docker构建示例使用了<a class="ae kv" href="https://github.com/geshan/currency-api" rel="noopener ugc nofollow" target="_blank"> Currency API </a>应用程序</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/710953066e8c9d771687427e2136e61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxhci880CmdT_7h1Rdyt-w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by <a class="ae kv" href="https://pixabay.com/users/thedigitalartist-202249/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1696051" rel="noopener ugc nofollow" target="_blank">Pete Linforth</a> from <a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1696051" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="dfe8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么更快的docker构建</h1><p id="5a0d" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">您希望Docker容器构建得更快有许多原因，下面是一些紧迫的原因:</p><ol class=""><li id="502f" class="mk ml iq ky b kz la lc ld lf ni lj nj ln nk lr mr ms mt mu bi translated">这将节省软件工程师在等待CI/CD管道中构建容器映像的时间。想象一下，如果你的docker构建只需要一半的时间，那么等待的时间会少很多。</li><li id="896d" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">这也将节省工程师在本地构建和运行软件的时间。在这个微服务的时代，如果这些映像能够构建得更快，将会有很大帮助。</li><li id="f8f5" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">更快的构建还支持更快的部署和发布。如果您想回滚一个有问题的部署(如果构建花了10分钟),那么在构建恢复的更改时，有问题的代码至少会在prod中停留10分钟。</li></ol><h1 id="2fc7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Docker构建示例:缓慢构建</h1><p id="8d4b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">让我们看看下面的docker，这个看起来很无辜的docker文件取自一个<a class="ae kv" href="https://github.com/geshan/currency-api/commit/1bfa57939bb7647d9350a7445d223e4c0789f112" rel="noopener ugc nofollow" target="_blank">节点Js API </a>。随着我们的深入，我们将会发现一个主要问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bf5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">RUN npm ci</code>是代替<code class="fe na nb nc nd b">RUN npm install --production</code>的另一个更好的<a class="ae kv" href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" rel="noopener ugc nofollow" target="_blank">选项</a></p><h1 id="b24c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们使用常规的docker版本</h1><p id="6004" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">当我们尝试使用以下命令用docker build构建上述docker文件时</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">time</code> <a class="ae kv" href="https://www.computerhope.com/unix/utime.htm" rel="noopener ugc nofollow" target="_blank">命令</a>放在<code class="fe na nb nc nd b">docker build</code>命令的前面，这样我们就知道docker build命令完成所需的时间。下面是花了多长时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/8145f4d0762d3fae7e146fd55c2a52f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L715pz3Ect6LxG7bd_qkVQ.jpeg"/></div></div></figure><p id="f0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">如上所示，耗时57.17秒。</em></p><h1 id="0fa5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">轻松加速，使用BUILDKIT</h1><p id="138e" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">Docker build最近从18.09版本增加了<a class="ae kv" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> BUILDKIT </a>。Docker基本上说这是对构建过程的彻底检查。正如这篇<a class="ae kv" href="https://brianchristner.io/what-is-docker-buildkit/" rel="noopener ugc nofollow" target="_blank">文章</a>中提到的，它更快、更高效、更并发。你可以在这篇关于docker.com的文章中读到更多关于它的好处。现在，让我们看看它的运行情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="84f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看花了多长时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/4975bfab37e86ec7e4784676a5fccad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxYiO7eZSiXP6HlKqyPEWw.jpeg"/></div></div></figure><p id="41e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，构建时间不到没有BUILDKIT时的一半。</p><p id="51a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">这个构建只花了27.32秒，而上面的构建花了57.14秒。</em></p><h1 id="5dd8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Docker构建示例:快速构建</h1><p id="b1ee" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">好的，在我们之前的docker文件中有一个主要问题。无论是我们的自定义代码还是任何其他添加的npm模块，docker缓存在每次更改时都会被破坏。在这篇<a class="ae kv" href="https://pythonspeed.com/articles/docker-caching-model/" rel="noopener ugc nofollow" target="_blank">文章</a>中也可以读到更多关于docker构建缓存的信息。</p><h2 id="da30" class="np lt iq bd lu nq nr dn ly ns nt dp mc lf nu nv me lj nw nx mg ln ny nz mi oa bi translated">通过适当的缓存加快docker构建</h2><p id="8244" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我们的代码几乎每次都会改变，但是我们引入的npm模块很少改变。因此，我们可以安全地缓存npm模块，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ae7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看看这两个docker文件<a class="ae kv" href="https://github.com/geshan/currency-api/compare/docker-build...docker-build-better-cache?expand=1#diff-dd2c0eb6ea5cfc6c4bd4eac30934e2d5746747af48fef6da689e85b752f39557R1" rel="noopener ugc nofollow" target="_blank">的区别。主要的变化是我们首先复制package.json和package-lock.json文件，然后运行npm install。只有在这之后，自定义代码才被复制到<code class="fe na nb nc nd b">/src</code>。因此，如果您不添加新的npm库，缓存将保持不变。</a></p><p id="0713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">使用下面的命令第一次构建花了34秒:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述命令的输出如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/864b0c2bf4fa328ca16f37e31a2ba13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEn98EIpDJ3UrQZTN_WpZQ.jpeg"/></div></div></figure><h1 id="8cb5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码更改后docker构建速度快吗？</h1><p id="c8db" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">对于这个docker构建示例，我在Node JS API应用程序的index.js文件中添加了一行<a class="ae kv" href="https://github.com/geshan/currency-api/compare/docker-build...docker-build-better-cache?expand=1#diff-e727e4bdf3657fd1d798edcd6b099d6e092f8573cba266154583a746bba0f346R30" rel="noopener ugc nofollow" target="_blank">注释</a>。现在让我们看看它需要多长时间，以及它是否缓存了在<code class="fe na nb nc nd b">npm install</code>命令中使用的node_modules。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">构建只花了6.01秒，这要感谢docker对缓存的大量使用和BUILDKIT的使用，如下所示:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/603b3948d3ce7131008e9353173ccc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3fSs53JtRmWnngrbnLwAg.jpeg"/></div></div></figure><p id="768c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管代码发生了变化，但NPM模块被缓存，使得构建仅用了6秒钟就完成了。同样的原理也适用于利用docker构建缓存。可以用composer.json和composer.lock文件应用于PHP或者其他任何语言。总是想到以前的命令运行，以及如何更好地缓存它。</p><p id="7d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有四张图片的大小都在233 MB左右，其中一张花了大约60秒，最后一张花了6秒。速度快了10倍。</p><h1 id="ba20" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="ff47" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">如果你正在构建docker图像，别忘了使用BUILDKIT，它非常高效。在BUILDKIT之上，始终分析如何利用 <a class="ae kv" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" rel="noopener ugc nofollow" target="_blank"> <em class="no"> docker构建缓存</em> </a> <em class="no">来加快docker构建。</em></p><p id="aa94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这个小的docker构建示例对您有所帮助。像使用alpine base Image这样的较小的docker图像也可以帮助你加快docker的构建。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="cdc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">最初发表于</em><a class="ae kv" href="https://geshan.com.np/blog/2020/10/docker-build-example-faster-docker-build/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://geshan.com.np</em></a></p></div></div>    
</body>
</html>