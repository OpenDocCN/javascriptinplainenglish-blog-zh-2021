<html>
<head>
<title>How to Shorten Import Paths in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何缩短React中的导入路径</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-shorten-import-paths-in-react-and-typescript-nodejs-5b257ee0c3fa?source=collection_archive---------0-----------------------#2021-03-15">https://javascript.plainenglish.io/how-to-shorten-import-paths-in-react-and-typescript-nodejs-5b257ee0c3fa?source=collection_archive---------0-----------------------#2021-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="34fe" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在TypeScript和Node.js中也是如此</h2></div><p id="d2c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你曾经不得不用<code class="fe ky kz la lb b">import ModuleName from '../../../one/two/component'</code>导入一个模块吗？本文将消除这一痛点，并允许TypeScript开发人员高效且有效地为<strong class="ke io">前端</strong>和<strong class="ke io">后端</strong>代码库导入模块！是时候告别漫长的导入路径了。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/1d2438fea62bab596d7f4bd3b4c37da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NILTgbOuUHd15CVwmUzwnQ.png"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="a935" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，由于捆绑器的不同，我将向导分为前端和后端。</p><ul class=""><li id="ad8f" class="lv lw in ke b kf kg ki kj kl lx kp ly kt lz kx ma mb mc md bi translated"><a class="ae me" href="#61c3" rel="noopener ugc nofollow">链接(点击此处)到前端创建React应用程序导入缩短</a></li><li id="d60f" class="lv lw in ke b kf mf ki mg kl mh kp mi kt mj kx ma mb mc md bi translated"><a class="ae me" href="#a80e" rel="noopener ugc nofollow">链接(点击此处)到后端打字稿导入缩短</a></li></ul></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="61c3" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">前端创建React应用程序导入缩短</h1><p id="6059" class="pw-post-body-paragraph kc kd in ke b kf nc jo kh ki nd jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">在react代码库中，我们经常发现自己要从远离JSX的地方导入可共享的组件。元素文件。例如，我们从components文件夹导入按钮，如图所示。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nh"><img src="../Images/0e6ee57920121e9e158a6eba12a63945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YhimX_n44kzp-_vc9BONQ.png"/></div></div></figure><p id="38ea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这并不理想，因为嵌套的路径会降低代码的可维护性。因此，我们想把它变成<code class="fe ky kz la lb b">'@components/componentName';</code>,因为这将允许绝对路径导入，不管我们在哪个子文件夹中，与上面的相对路径相比，它不会保持不变。当你把你的导入改成<code class="fe ky kz la lb b">'@components/componentName';</code>时，你会发现下面的错误。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ni"><img src="../Images/f9c486c57b26d0717f4d1839fc92547e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-qaEnWLBm_xtyGdDskA8g.png"/></div></div></figure><p id="0fc2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们需要配置webpack别名。因此，我们需要安装craco软件包。Craco指的是创建React应用程序配置覆盖！</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="151d" class="nn ml in lb b gy no np l nq nr">$ npm install @craco/craco</span></pre><p id="f42e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安装craco后，使用以下参数创建craco.config.js。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="be4f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不仅如此，您还必须在package.json脚本部分用craco替换react-scripts。</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="b33d" class="nn ml in lb b gy no np l nq nr">{<br/>    // ...<br/>    "scripts": {<br/>-     "start": "react-scripts start",<br/>-     "build": "react-scripts build",<br/>-     "test": "react-scripts test",<br/>+     "start": "craco start",<br/>+     "build": "craco build",<br/>+     "test": "craco test",<br/>      "eject": "react-scripts eject"<br/>    },<br/>  }</span></pre><p id="f64c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在反应过来的邦德勒明白了，我们还没完。我们也需要“告诉”visual studio代码，以便VSC智能感知能够工作。创建名为paths.json的新文件。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f6ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修改现有的tsconfig.json，将其扩展到paths.json。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5b77" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Tadaaa！现在你完成了！无论您在哪个嵌套文件夹中，您都可以使用绝对短路径！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nu"><img src="../Images/4055675c07000566270a551bc03ee7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G47ogXbAfi46-Pse456CYw.png"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="a80e" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">后端打字稿导入缩短</h1><h2 id="a53b" class="nn ml in bd mm nv nw dn mq nx ny dp mu kl nz oa mw kp ob oc my kt od oe na of bi translated">发展环境</h2><p id="c1e1" class="pw-post-body-paragraph kc kd in ke b kf nc jo kh ki nd jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">当您的代码库变得越来越大时，您的导入路径往往会变得越来越长。因此，在某些时候，我们将需要绝对导入路径来使我们的代码库更易于维护。在这一节中，我将介绍如何在TypeScript非webpack项目中实现这一点。在下面的例子中，我从嵌套文件夹中导入一个接口。在这个例子中，我使用<a class="ae me" href="https://www.npmjs.com/package/create-express-typescript-application" rel="noopener ugc nofollow" target="_blank">create-express-typescript-application</a>模块生成项目。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi og"><img src="../Images/df9f4e7df16ccae5440f1072c75d8e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWDmOjXIis_f-rAwUEPa7Q.png"/></div></div></figure><p id="10fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为它是基本文件夹，所以仍然是可跟踪的。然而，当您需要从<code class="fe ky kz la lb b">'../../parentFolder/childFolder/grandChildFolder/index.ts';</code>导入时，事情就变得混乱了。为此，您需要从npm安装tsconfig-paths和require-json5模块。</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="a82c" class="nn ml in lb b gy no np l nq nr">$ npm install tsconfig-paths require-json5</span></pre><p id="2e3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，通过在compilerOptions下添加以下内容来修改tsconfig.json。</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="e2d8" class="nn ml in lb b gy no np l nq nr">"baseUrl": "./",    <br/>"paths": {<br/>      "@auth-user": ["./database/authentication/user"]<br/>},</span></pre><p id="3c2f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，您的tsconfig.json应该如下所示。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a0f1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦修改了tsconfig.json，就可以修改启动脚本了。</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="d390" class="nn ml in lb b gy no np l nq nr"><br/>    "scripts": {<br/>-     <!-- -->"dev": "ts-node ./src/index.ts"<!-- -->,<br/>-     <!-- -->"dev:nodemon": "nodemon -w src -e ts,json -x ts-node ./src/index.ts"<!-- -->,<br/>+     "<!-- -->dev<!-- -->": "<!-- -->ts-node -r tsconfig-paths/register ./src/index.ts<!-- -->",<br/>+     "<!-- -->dev:nodemon<!-- -->": "<!-- -->nodemon -w src -e ts,json -x ts-node  -r tsconfig-paths/register ./src/index.ts<!-- -->",<br/><br/>    },</span></pre><p id="51db" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦将<code class="fe ky kz la lb b">-r tsconfig-paths/register</code>作为参数添加到<code class="fe ky kz la lb b">node</code>或<code class="fe ky kz la lb b">ts-node</code>命令中，就大功告成了！然而，这只适用于开发环境。一旦您使用tsc命令构建了项目，事情就会发生变化。</p><h2 id="c5f6" class="nn ml in bd mm nv nw dn mq nx ny dp mu kl nz oa mw kp ob oc my kt od oe na of bi translated">构建环境</h2><p id="65f0" class="pw-post-body-paragraph kc kd in ke b kf nc jo kh ki nd jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">为此，您需要创建js文件作为自定义注册。用下面的代码创建tspaths.js。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="987e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最初，我的启动脚本如下</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="4016" class="nn ml in lb b gy no np l nq nr">"start": "cd build &amp;&amp; node ./build/index.js"</span></pre><p id="7af0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将不得不修改它来读取自定义寄存器…</p><pre class="ld le lf lg gt nj lb nk nl aw nm bi"><span id="c120" class="nn ml in lb b gy no np l nq nr">"start": "node -r ./tspaths ./build/src/index.js",</span></pre><p id="bdee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过注册自定义路径，不仅是typescript，我们还允许js从绝对路径中受益。</p><p id="e384" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我最终的package.json如下所示。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="68d7" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">结论</h1><p id="34a7" class="pw-post-body-paragraph kc kd in ke b kf nc jo kh ki nd jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">我希望你已经从这篇文章中受益。本文向您展示了如何通过在基于webpack的前端CRA以及在nodemon (ts-node)和使用tsc构建的后端中将相对路径更改为绝对路径来减少错误和时间。万事如意！</p></div></div>    
</body>
</html>