<html>
<head>
<title>Why the React Testing Library is Much More Than a Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么React测试库不仅仅是一个测试库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-testing-library-is-much-more-than-a-testing-library-22edd6bd45d4?source=collection_archive---------3-----------------------#2021-06-14">https://javascript.plainenglish.io/react-testing-library-is-much-more-than-a-testing-library-22edd6bd45d4?source=collection_archive---------3-----------------------#2021-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8b6a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让您的测试再次变得可靠</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dfb037caa8d6c2f649a4b3c9ef5db93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cm_JcYKdJhwbRSIa"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@elsbethcat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Beth Macdonald</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8d7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">软件开发感觉就像用有裂纹的玻璃工作一样不稳定——在这种情况下，你的应用程序中拥有的特性越多，就会产生更多的bug(也就是裂纹)来填充测试(也就是大量的碎玻璃)。测试是把关者，在代码发布到产品之前先发制人地捕捉bug。那么，为什么我一次又一次地发现自己在每次更新代码时都在修正旧的测试呢？以下是我的回答。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9a34" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">测试实施细节</h1><p id="52c6" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">您是否曾经因为更新了React应用程序中的状态键名而不得不修改测试？当您删除测试正在寻找的带有<code class="fe mt mu mv mw b">id</code>的<code class="fe mt mu mv mw b">&lt;div&gt;</code>时会怎么样呢？你是否觉得你的测试是如此的脆弱，以至于对代码的任何更新都会导致它们失败？</p><p id="4706" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">别担心，你不是唯一一个。无数开发者(包括我自己)陷入<a class="ae ks" href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">测试实现细节</strong> </a>而不是实际用户体验的陷阱。然而，我们并不是唯一应该受到谴责的当事方。像<a class="ae ks" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>这样的可用测试库公开了API，允许我们直接修改应用程序状态，这诱使我们测试实现细节。例如，使用来自<a class="ae ks" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/setState.html" rel="noopener ugc nofollow" target="_blank"> setState API </a>的示例:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="7d38" class="nb lx in mw b gy nc nd l ne nf">// Foo.js<br/>class Foo extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { name: 'foo' };<br/>  }</span><span id="438a" class="nb lx in mw b gy ng nd l ne nf">render() {<br/>    const { name } = this.state;<br/>    return (<br/>      &lt;div className={name} /&gt;<br/>    );<br/>  }<br/>}</span><span id="47f7" class="nb lx in mw b gy ng nd l ne nf">// Foo.test.js<br/>const wrapper = shallow(&lt;Foo /&gt;);<br/>expect(wrapper.find('.foo')).to.have.lengthOf(1);<br/>expect(wrapper.find('.bar')).to.have.lengthOf(0);<br/>wrapper.setState({ name: 'bar' });<br/>expect(wrapper.find('.foo')).to.have.lengthOf(0);<br/>expect(wrapper.find('.bar')).to.have.lengthOf(1);</span></pre><p id="1c74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个例子看起来非常简单，但是想象一下，如果您将州名更新为<code class="fe mt mu mv mw b">firstName</code>而不是<code class="fe mt mu mv mw b">name</code>，您的测试会立即中断，因为您的新应用程序状态对象中缺少了州名<code class="fe mt mu mv mw b">name</code>。这是测试实现细节的隐藏结果。</p><h1 id="c517" class="lw lx in bd ly lz nh mb mc md ni mf mg jt nj ju mi jw nk jx mk jz nl ka mm mn bi translated">为什么要测试React库？</h1><p id="11db" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated"><a class="ae ks" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a>是由React向导<a class="ae ks" href="https://kentcdodds.com/" rel="noopener ugc nofollow" target="_blank"> Kent C. Dodds </a>和来自世界各地的众多知名开发人员开发的测试库。在我看来，RTL优于其他测试库，因为它</p><ul class=""><li id="679e" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">阻止测试实现细节</li><li id="2a3c" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">模仿真实用户与组件的交互</li><li id="81d6" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">自我文档</li><li id="72f8" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">提供了简化编写测试的优秀工具</li></ul><p id="a967" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，请允许我更深入地探讨一下这些好处，并希望说服您搭乘RTL列车。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="b1a0" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">使用React测试库</h1><p id="715a" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">正如我在上面提到的，测试实现细节使测试变得不可靠，并且会导致大量的管理开销。让我们看看RTL是如何解决这个问题的。</p><p id="7d3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们这里有一个简单的计数器，可以增加或减少显示的计数。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="28e0" class="nb lx in mw b gy nc nd l ne nf">import React, { useState } from 'react';</span><span id="1807" class="nb lx in mw b gy ng nd l ne nf">const Counter = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  const increment = () =&gt; setCount(count =&gt; count + 1);<br/>  const decrement = () =&gt; setCount(count =&gt; count - 1);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;Count: {count}&lt;/div&gt;<br/>      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="2842" class="nb lx in mw b gy ng nd l ne nf">export default Counter;</span></pre><p id="d2ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于RTL，您的测试可能如下所示</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="392a" class="nb lx in mw b gy nc nd l ne nf">import * as React from 'react';<br/>import { render, screen } from '@testing-library/react';<br/>import userEvent from '@testing-library/user-event';<br/>import Counter from './counter';</span><span id="56a1" class="nb lx in mw b gy ng nd l ne nf">test('should update count when button clicked', () =&gt; {<br/>  const { container } = render(&lt;Counter /&gt;);<br/>  const increment = screen.getByRole('button', {name: /increment/i});<br/>  const decrement = screen.getByRole('button', {name: /decrement/i});<br/>  const message = screen.getByText(/count/i);<br/>  <br/>  expect(message).toHaveTextContent('Count: 0');<br/>  <br/>  userEvent.click(increment);<br/>  expect(message).toHaveTextContent('Count: 1');<br/>  <br/>  userEvent.click(decrement);<br/>  expect(message).toHaveTextContent('Count: 0');<br/>});</span></pre><p id="edb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从这个例子可以看出，我们并没有直接操纵任何app状态；相反，我们在模仿用户如何与应用程序交互。通过这样做，我们可以自由地更新<code class="fe mt mu mv mw b">&lt;Counter /&gt;</code>组件，甚至添加新特性，而不用担心测试中断。只要我们不改变正在测试的特性的行为，这些测试将保持有效。最重要的是，像上面这样的测试是如此清晰易懂，以至于它们可以很容易地作为你的组件的文档。</p><p id="624e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">T12】💡当我审查代码时，我总是在实际代码之前检查测试，以理解预期的行为。类似上面的测试定义了组件应该做什么的清晰规范。 </strong></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="43d7" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">用户事件</h1><p id="2edd" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">你可能会注意到我们正在使用来自<code class="fe mt mu mv mw b">@testing-library/user-event</code>的<code class="fe mt mu mv mw b">userEvent</code> API。这不是你平时的<code class="fe mt mu mv mw b">MouseEvent('click')</code>功能。我们创建MouseEvents与元素交互的老方法也是测试实现细节的一种形式。手动调度click事件不会验证元素是否是可点击的或可交互的，这将在您的产品代码中隐藏一个致命的错误。<code class="fe mt mu mv mw b"><a class="ae ks" href="https://github.com/testing-library/user-event/blob/master/src/click.ts#L116-L139" rel="noopener ugc nofollow" target="_blank">userEvent</a></code>精确模拟真实的用户交互，如果元素不可点击，它会警告你。如果这还不够，RTL生态系统中还有一个完整的图书馆列表。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="1a0e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">开发工具</h1><p id="f371" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">开始看到它的价值了吗？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="9f05" class="nb lx in bd ly od oe dn mc of og dp mg lc oh oi mi lg oj ok mk lk ol om mm on bi translated"><code class="fe mt mu mv mw b">screen.debug() &amp; screen.logTestingPlaygroundURL()</code></h2><p id="6282" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">有时可能很难找到您想要测试的正确元素，当我非常有信心的查询返回<code class="fe mt mu mv mw b">null</code>或<code class="fe mt mu mv mw b">undefined</code>时，这肯定会让我感到困惑。来自<code class="fe mt mu mv mw b">@testing-library/dom</code>的<code class="fe mt mu mv mw b">screen</code> API有两个功能可以消除这方面的歧义。通过将<code class="fe mt mu mv mw b">screen.debug()</code>添加到您的测试中，当测试运行时，您将能够看到呈现组件的DOM树，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/f3a43121b349c00213bc4714faeff1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6EDD_UKp-eW52yPAkAwOQ.png"/></div></div></figure><p id="af8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将允许您在测试中准确地确定要断言的正确查询。如果这还不够明显，您可以使用<code class="fe mt mu mv mw b">screen.logTestingPlaygroundURL()</code>来帮您弄清楚。该命令将返回一个生成的链接，您可以在浏览器中导航到该链接:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi op"><img src="../Images/698e514f8279e89193a484d4566e3d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0b5N3O0gA-e568Qo5uIdA.png"/></div></div></figure><p id="53e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就把我们带到了React测试库的下一个也是最后一个卖点。</p><h2 id="bbb9" class="nb lx in bd ly od oe dn mc of og dp mg lc oh oi mi lg oj ok mk lk ol om mm on bi translated">测试操场</h2><p id="6b68" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">尽管我们开发人员喜欢编码，但有时从单调乏味的工作中休息一下，让其他工具为我们做一些繁重的工作也是不错的。这正是测试操场的用武之地。<a class="ae ks" href="https://testing-playground.com/" rel="noopener ugc nofollow" target="_blank"> testing playground </a>是一个交互式网站，在这里你可以粘贴DOM树并找到你想要的元素的精确查询。您既可以粘贴来自<code class="fe mt mu mv mw b">screen.debug()</code>的结果，也可以从<code class="fe mt mu mv mw b">screen.logTestingPlaygroundURL()</code>的输出链接开始，选择您想要查询的元素，并将结果直接复制粘贴到您的测试中。用户界面感觉就像开发者工具中的inspect元素，所以开始使用该网站的全部潜力是零学习曲线。为了更加方便，还有一个<a class="ae ks" href="https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano?hl=en" rel="noopener ugc nofollow" target="_blank">浏览器扩展</a>可以让你与任何网站互动！</p><h1 id="7b63" class="lw lx in bd ly lz nh mb mc md ni mf mg jt nj ju mi jw nk jx mk jz nl ka mm mn bi translated">结论</h1><p id="d415" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">编写测试可能没有开发新功能有趣，而且每当我们更新代码时都必须重写测试，这更让人不愉快。我们需要停止测试实现细节，开始镜像用户交互。</p><p id="41aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React测试库使测试实现细节变得困难，并为如何正确编写测试带来了光明。我真的很喜欢使用它，我希望你也一样。😄</p><p id="124e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="oa">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="oa">plain English . io</em></a></p></div></div>    
</body>
</html>