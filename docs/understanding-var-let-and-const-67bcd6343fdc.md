# 理解 var、let 和 const

> 原文：<https://javascript.plainenglish.io/understanding-var-let-and-const-67bcd6343fdc?source=collection_archive---------12----------------------->

每当你访问一个变量时，JavaScript 使用一个叫做*范围* *链*的东西来确定你引用的是哪个变量。

*作用域* *链* 的工作方式是这样的，JavaScript 开始在调用它的作用域中寻找变量，如果在那个作用域中找不到它，它就向上移动到下一级并在那里寻找，它一直这样做，直到找到全局空间，如果在全局作用域中找不到它，它就抛出一个错误。

我认为 ODB 抓住了这一点，当他说*“你看，我的名字是你不会知道的，除非你在布鲁克林动物园”*。

![](img/d1c5abc81050d41f071a944206fdb7e1.png)

R.I.P. Dirt McGirt

你看，如果你是一个吴唐门迷(又名打倒布鲁克林动物园)你知道 ODB，但如果你不听吴，你不会知道他的存在。这听起来很简单，对吗？它可能比听起来要复杂一点，让我们来看看一些代码。在下一节中，我将给出一些示例代码，解释代码中发生了什么，然后询问您代码将返回什么。我把单词*结果*放在答案前面，这样你就不会在猜测之前滚动太远看到答案。

在这种情况下，我们在全局空间中有一个变量叫做***hiphop artists***，它的值是一个 hipHopArtists 的数组。我们还有一个函数叫做***getdownthezoo***，在这个函数里面我们声明了另一个变量叫做***hipHopArtists***，它的值是一个 Wu 成员的数组。***getdownthezoo***也将***hipHopArtists***记录到控制台。在我们调用***getdownthezoo***的代码中，我们登录***hipHopArtists***，你认为这段代码会返回什么？让我们来看看。

代码是否返回了您所期望的结果？这里发生的事情是，我们在第 8 行记录 ***hipHopArtists*** ，因为有一个全局范围的变量叫做***【hiphop artists***我们得到下面的数组 *["Snoop Dogg "、" Liff 先生"、" Bus Driver "、" Devin the Dude"]* 。然后，我们调用***getDownWithTheZoo***函数，该函数还记录了***hipHopArtists***，因为有一个名为***hipHopArtists***的函数作用域变量，我们得到下面的数组 *["RZA "、" GZA "、" ODB "、" Inspectah Deck】]*。现在，让我们做一些改变，看看会发生什么。您希望下面的代码返回什么？

代码是否返回了您所期望的结果？这里发生的事情是，我们记录了***hipHopArtists***，由于有一个名为***hipHopArtists***的全局变量，我们得到了下面的数组 *["Snoop Dogg "、" Liff 先生"、" Bus Driver "、" Devin the Dude"]* 。然后，我们调用***get down with thezoo***函数，该函数记录了***brooklynzoartists***和***hipHopArtists***，由于有一个名为***brooklynzoartists***的函数作用域变量，我们得到下面的数组 *["RZA】，" GZA "，" ODB "，" inspecthak Deck "]*。接下来，我们记录***hiphop artists***并且由于在函数作用域中没有名为***hiphop artists***的变量，JavaScript 沿着 ***作用域链*** 向上移动到全局空间，并且在那里找到一个名为***hiphop artists***的变量，并且记录 *["Snoop Dogg "，"让我们再做一些改变，看看会发生什么。您希望下面的代码返回什么？*

代码是否返回了您所期望的结果？所以这里发生的是我们 console . log***hiphop artists***并且因为有一个全局范围的变量叫做 ***hipHopArtists*** 我们得到下面的数组 *["Snoop Dogg "，" Liff 先生"，" Bus Driver "，" Devin the Dude"]* 。然后，我们调用***get down with thezoo***函数，该函数记录***brooklynzoartists***和***hipHopArtists***，由于有一个函数作用域变量叫做***brooklynzoartists***，我们得到下面的数组 *["RZA】、" GZA "、" ODB "、" inspecthak Deck "]*。接下来，我们记录下***hiphop artists***，由于在函数作用域中没有名为***hiphop artists***的变量，JavaScript 沿着“作用域链”向上移动到全局空间，在那里找到名为***hiphop artists***的变量，并记录下 *["Snoop Dogg "、" Liff 先生"、" Bus Driver "、" Devin the Dude"]* 。然后我们调用 ***getHorror*** 函数，该函数有一个变量***horrorcorealtors***，该变量记录了***hipHopArtists***。由于在***get horror***作用域链*** 中没有名为 *hipHopArtists**** 的变量，并且由于没有名为***hipHopArtists***的变量●不料在全局空间中有一个名为 ***的变量 hipHopArtist*** 和 *["Snoop Dogg "、" Mr. Liff "、" Bus Driver "、" Devin the Dude"]* 被登录到控制台。好了，现在我们知道了 ***作用域链*** 是如何工作的，让我们来看看 *var* 、 *let 和 const* 之间的区别。

![](img/8de6769c1a9e870814f4dafafd8f158a.png)

在谈论 *var* 、 *let* 、 *const* 时，我们首先需要覆盖的是*block***范围*。所以你可能听说过全局作用域和函数作用域，但是什么是块作用域呢？块作用域是当你在一个*代码* *块*中包含一个变量时，就像一个 for 循环或者一个条件语句(if 语句)。如果你看一下下面的代码，你会看到一个变量 ***i*** 那就是 for 循环里面的*块* *作用域* 。*

*现在我们知道了什么是 block scope，下面就来说说 *var* 、 *let* 和 *const* 的区别。关于 *var* 要记住的最重要的事情是它不能是块范围的。看看下面的代码片段，你认为控制台会记录什么？*

*代码记录了您所期望的吗？发生了什么事？所以当我们运行第一个日志时，我们得到 ***11*** ，因为 ***i*** 在全局空间中被定义为 ***11*** 。接下来，我们将 ***i*** 定义为 for 循环内部的***【0】***，但是由于 *var* 不能被 *block 作用域* ***i*** 泄漏到全局空间中，所以现在 ***i*** 在全局空间中的值为 ***0*** 。当我们运行 for 循环中的第二个日志时，在名为*的*块作用域*中没有*变量*，因为它泄漏到了全局空间中，所以 JavaScript 将作用域链向上移动到全局空间并返回 ***i*** ，它现在的值为 ***0*** 。每当 ***i*** 递增，直到 ***i*** 的值为 ***10*** 并且 for 循环停止时，都会发生这种情况。然后我们移动到第三个日志，它记录了全局空间中的 ***i*** ，其值为 ***10*** ，因为这是 for 循环停止的地方。让我们来看看当我们将 for 循环中的 ***var*** 改为 ***let*** 时会发生什么。**

**请注意，结果非常不同。那是因为 let 可以是*块范围的*，意味着有一个变量 ***i*** 存在于*全局范围*中，还有一个存在于 for 循环内部。因此，第一个日志引用全局范围中定义的 ***i*** ，第二个日志引用*块范围*中的 ***i*** ，递增到 ***10*** ，第三个日志引用回*全局空间*中存在的 ***i*** 。这里重要的一点是 *let* 关键字可以是*全局*、*功能*或块范围的，而 *var* 只能是*功能*或*全局*范围的。好了，现在我们明白了 *var* 和 *let* 的区别，让我们来讨论一下 *const* 。看看下面的代码，你认为在这个实例中控制台会记录什么？**

**啊哦，我们有一个错误。你认为这是为什么？ *const* 关键字和 *let* 关键字很像，都可以是*全局*功能和 *block* 作用域*。但是有一个非常重要的区别，用 *const* 声明的变量的值不能被重新赋值，所以当我们试图在 for 循环中增加 ***i*** 的值时，我们会得到一个错误，因为我们不能将 ***i*** 的值从 ***0*** 更改为 ***1 这可能有点令人困惑，因为用 *const* 声明的变量不能被重新赋值，但其值可能会发生变异。看一下下面的代码来看一个例子。******

*请注意，当我们将 100 加到 ***i*** 然后记录它时， ***i*** 的值仍然是 ***11。*** 那是因为 ***i*** 的值不能被重新赋值。但是，我们将 ***独眼巨人*** 赋给一个空数组的值，然后我们推送*我是变种人*的字符串，当我们登录 ***独眼巨人*** 我们得到下面的值 *['我是变种人']* 。那是因为 ***独眼巨人*** 还是同一个数组，所以我们没有重新分配 ***独眼巨人*** 的值，我们只是通过添加“*我是* *变异体*”的字符串对数组进行了变异。我喜欢这样想，如果你从你最喜欢的当地披萨店订购了一份黑橄榄披萨，但他们忘记在你的披萨上放橄榄，你可以把你的披萨拿回去，他们可以添加黑橄榄，然后把它放回烤箱几分钟，然后还给你。*

*所以基本上他们只是变异了你的披萨，但是如果你点了一份黑橄榄披萨，他们却意外地给了你鸡翅，那就没办法把你的鸡翅变异成披萨了。所以他们必须做一个全新的披萨。*

*![](img/234a1d268a5c192f2df1b1e54b1b7662.png)*

*好了，现在我们知道了 *var* 、 *let* 和 *const* 之间的区别，我们还有一个令人困惑的话题要在本文中讨论。还记得我们谈论 JavaScript 解释器时，我说过在创建阶段解释器会检查代码，找到所有的函数和变量，并为它们节省空间吗？该过程被解释人员称为 ***提升*** ，井*让*和*保持*不被*提升*。这意味着在执行阶段，直到解释器到达它们，它们才被定义。看看下面的例子，你认为控制台会记录什么？*

*这就是起重发挥作用的地方。当 JavaScript 解释器进入创建阶段时，它会看到 *var* 关键字，并在内存中为变量 *thing1* 节省空间，它还没有定义，但已经为它留出了空间。然后当它进入执行阶段时， *thing1* 被记录到控制台，因为它直到被调用后才被赋值，未定义的被记录到控制台。由于 *let* 和 *const* 关键字没有*提升*，JavaScript 解释器在创建阶段忽略它们。*

*因此，当我们进入执行阶段并尝试将 *thing2* 记录到控制台时，我们会得到以下错误: ***ReferenceError:无法在初始化*** 之前访问 thing2，因为 JavaScript 解释器不知道 *thing2* 的存在。吊装有点像去唱片店购买最新的吴唐专辑，唱片店还没有收到他们的货物，他们知道它的存在，他们只是没有库存。*

**让*和 c *onst* 不要被吊起来，这样就像去唱片店买一张还没有创作出来的武堂专辑，他们会告诉你，你要找的东西不存在。*

## *结论*

*我希望这篇文章有助于阐明作用域、作用域链以及 *var* 、 *let* 和 *const* 之间的区别。这些可能是非常令人困惑的话题，事实上，在写这篇文章的时候，我发现我并没有像我想象的那样理解这些概念。我发现花些时间修补你自己的代码将有助于巩固这些概念。我希望这篇文章对您有所帮助；如果你有任何你希望我在未来涉及的话题，请在评论中提出。*