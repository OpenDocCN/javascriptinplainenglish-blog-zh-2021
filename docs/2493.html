<html>
<head>
<title>This is how you Curry Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是你如何在JavaScript中运行函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-curry-functions-in-javascript-a609950fd73d?source=collection_archive---------14-----------------------#2021-05-22">https://javascript.plainenglish.io/how-to-curry-functions-in-javascript-a609950fd73d?source=collection_archive---------14-----------------------#2021-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a08f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近一直在涉猎函数式编程。如果你熟悉函数式编程，你会知道这是关于组成函数和重用它们，以便在你的源代码中实现更少的错误，并使代码更容易调试和测试。</p><p id="db3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用函数式编程的程序员使用的实用函数之一是curry函数。在这篇简短的博客中，我想分享它到底是做什么的，以及如何使用它来改进你的代码库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81b8ed3ca3e5706498428912649e96d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*46wNva8njxbpBLMY"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@laine23?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Laine Cooper</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b764" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">维基百科对Currying的定义是:<em class="kz"/><strong class="jm io"><em class="kz">currying</em></strong><em class="kz">是将一个带多个参数的函数转换成一系列每个带一个参数的函数的技术</em></p><p id="724a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，你分解函数来一个接一个地传递它们的参数。</p><p id="702d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript中，我们可以通过以下方式实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="2fdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们过一遍，这样你就会明白发生了什么。首先，我们定义最顶层的函数，它接受我们将要包装的函数和arity。</p><p id="ef25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数arity是函数声明中参数的数量。在JavaScript中，当你调用'<em class="kz"> function.length' </em>时，你会得到函数期望的参数个数。</p><p id="7bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，这里我们使其可配置，因为默认参数不计入<em class="kz">‘function . length’，</em>这允许您用默认值配置函数的arity参数。</p><p id="a861" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用函数调用这个最顶层的函数将返回一个自执行函数，该函数将返回<em class="kz"> 'curried' </em>函数。如果我们将第一个参数传递给curried函数，那么'<em class="kz"> previousArguments </em>'将是一个空数组，我们将简单地将第一个参数添加到参数列表中。</p><p id="7000" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们用我们的参数返回nextCurry函数，每当我们传递一个新的参数时，这个函数将重新开始这个过程。</p><p id="905c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们传递了所有的参数，我们的if语句就会触发，函数就会执行。试着真正理解这一点。最终结果是，只要函数有参数，您就可以多次调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="b686" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你不必自己在代码库中实现这个，像Lodash(<a class="ae ky" href="https://lodash.com/docs/#curry" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/#curry</a>)这样的现有库已经为你提供了这种现成的功能。</p><p id="804e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们怎样才能真正利用这个功能呢？假设我们有一个从API获取数据的函数。通常，该函数将接受3个参数；一个URL、一些数据和一个请求完成后的回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c766" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码片段中，我们通过向API传递productId来获取当前产品，并在回调函数中处理结果。</p><p id="3be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于编写它的人来说，这看起来没什么问题，但是让随机的ajax语句贯穿整个代码库可能会让下一个读者搞不清楚所有这些ajax调用到底是做什么的。</p><p id="0107" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，考虑一个更具声明性的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="7604" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，在<em class="kz">第2行</em>上，我们从使用上面详述的curry函数来实现我们的函数开始。<em class="kz">在第4行</em>中，我们初始化了“<code class="fe lc ld le lf b"><em class="kz">productEndpoint</em></code><em class="kz">”</em>。您应该意识到，这个端点非常广泛，可能会在很多地方使用，因为您可能想要获取产品列表、详细信息、提要。</p><p id="28bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，在我们的产品细节上，我们可以定义一个更具体的函数，叫做<code class="fe lc ld le lf b"><em class="kz">getCurrentProduct</em></code>，这个函数会用当前产品的id得到一个产品，叫做<code class="fe lc ld le lf b"><em class="kz">productEndpoint</em></code><em class="kz">‘</em>。现在，我们可以在多个其他函数中使用这个'<code class="fe lc ld le lf b"><em class="kz">getCurrentProduct</em></code> <em class="kz"> ' </em>，并对结果做不同的事情。</p><h1 id="50d2" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="f319" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我希望你意识到这有多强大。在最后一个例子中，我们的产品细节不再需要担心我们的API的URL到底是什么了。相反，它应该只使用productEndpoint函数来获取它想要的数据。我们让一切都变得更具陈述性。</p><p id="387a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一个阅读您的代码的人可能会更好地理解您的意图，花更少的时间来重新考虑重大变化，最终您的团队会变得更有效率，您的代码库会更有预见性。</p><p id="4c1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望我启发了你去思考以一种更具声明性的方式工作，以及它会对你的代码产生什么影响。享受你的编码吧！</p><p id="3043" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">多内容于</em> <a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kz">通俗易懂</em> </strong> </a></p></div></div>    
</body>
</html>