<html>
<head>
<title>The ‘Valid Parentheses’ LeetCode Algorithm Problem: The Algo Alcove</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“有效括号”LeetCode算法问题:Algo Alcove</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-algo-alcove-valid-parentheses-bb674b9501d7?source=collection_archive---------14-----------------------#2021-09-02">https://javascript.plainenglish.io/the-algo-alcove-valid-parentheses-bb674b9501d7?source=collection_archive---------14-----------------------#2021-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/235b0509916baf596f4a58bd325d70ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ao-c3OzaSk_wiHiI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也许你可能遇到的最简单但最重要的算法问题之一是“有效括号”问题。它使用了一种常见的问题解决技术，称为“频率计数”以及一种经典的数据结构:堆栈。</p><h1 id="c3da" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这个问题</h1><blockquote class="lw lx ly"><p id="b223" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">给定一个仅包含字符<code class="fe md me mf mg b">'('</code>、<code class="fe md me mf mg b">')'</code>、<code class="fe md me mf mg b">'{'</code>、<code class="fe md me mf mg b">'['</code>和<code class="fe md me mf mg b">']'</code>的字符串<code class="fe md me mf mg b">s</code>，确定输入的字符串是否有效。</p><p id="a114" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">在以下情况下，输入字符串有效:</p><p id="1e08" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">左括号必须用相同类型的括号括起来。</p><p id="d20c" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">左括号必须以正确的顺序结束。</p></blockquote><p id="0d74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个简单的林挺问题，可以帮助您确定一个字符串是否正确地结束了所有的括号和方括号(没有什么比搜索代码试图找到多余的花括号在哪里更糟糕的了)。</p><h1 id="04aa" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">思维过程</h1><p id="0b45" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">一个人的第一想法可能是:<em class="lz">我必须计算所有的开括号，并确保有同样多的闭括号与之匹配。</em></p><p id="5560" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种想法基本上是正确的，但是我们还需要一种方法来确定每个右括号是在左括号之后的。我们不想要这样的字符串:<code class="fe md me mf mg b">')))((('</code>。</p><p id="351f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们需要一种方法来跟踪最后一个开括号<strong class="kc io">是什么，以及在它之前所有其他开括号的顺序。这听起来像是一个<strong class="kc io">堆栈。</strong></strong></p><p id="8bb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">堆栈遵循LIFO排队顺序(后进先出),这意味着我们总是将最后一个左括号放在堆栈的顶部，当我们找到它的匹配时，可以弹出它。</p><p id="9936" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要一个<strong class="kc io">哈希映射</strong>来轻松检查右括号和匹配的左括号(不要让字符串看起来像<code class="fe md me mf mg b">'[){]'</code>)。</p><h1 id="ae9d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">伪代码</h1><ul class=""><li id="e2c2" class="mm mn in kc b kd mh kh mi kl mo kp mp kt mq kx mr ms mt mu bi translated">创建一个<strong class="kc io">散列映射</strong>，它将“闭括号”作为键，将它们匹配的“开括号”作为值。</li><li id="4851" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">创建一个<strong class="kc io">堆栈</strong>。</li><li id="1306" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">在字符串中循环。</li><li id="5486" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">如果角色是<strong class="kc io">开</strong>，将其加入堆栈。</li><li id="3209" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">如果字符是<strong class="kc io">闭合的，</strong>弹出堆栈，检查闭合字符是否与堆栈中的开放字符匹配(使用哈希映射)。</li><li id="7db3" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">如果它们不匹配，则返回false。</li><li id="ec7d" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">如果循环结束并且没有错误发生，则返回true。</li></ul><p id="891d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解决方案</strong></p><p id="f11c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一部分很简单:声明你的地图和栈。</p><pre class="na nb nc nd gt ne mg nf ng aw nh bi"><span id="742e" class="ni kz in mg b gy nj nk l nl nm">const validParentheses = (s) =&gt; {<br/>    let map = {<br/>        ')': '(',<br/>        ']': '[',<br/>        '}': '{'<br/>    };<br/>    let stack = [];<br/></span></pre><p id="c5d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，遍历字符串，将每个开放结构添加到堆栈中。</p><pre class="na nb nc nd gt ne mg nf ng aw nh bi"><span id="4087" class="ni kz in mg b gy nj nk l nl nm">for (let char of s) {<br/>    if (char === '(' || char === '[' || char === '{') {<br/>        stack.push(char);<br/>    }</span></pre><p id="4e0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这个结构是封闭的，就在栈顶检查它。</p><pre class="na nb nc nd gt ne mg nf ng aw nh bi"><span id="bc02" class="ni kz in mg b gy nj nk l nl nm">if (char === ')' || char === ']' || char === '}') {<br/>    let candidate = stack.pop();<br/>    if (map[char] !== candidate) {<br/>        return false;<br/>    };</span></pre><p id="c46d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们只要在循环结束时返回true，我们就完成了。下面是完整的代码:</p><pre class="na nb nc nd gt ne mg nf ng aw nh bi"><span id="f4dd" class="ni kz in mg b gy nj nk l nl nm">const validParentheses = (s) =&gt; {<br/>    let map = {<br/>        ')': '(',<br/>        ']': '[',<br/>        '}': '{'<br/>    };<br/>    let stack = [];</span><span id="1b10" class="ni kz in mg b gy nn nk l nl nm">    for (let char of s) {<br/>        if (char === '(' || char === '[' || char === '{') {<br/>            stack.push(char);<br/>        }</span><span id="c751" class="ni kz in mg b gy nn nk l nl nm">        if (char === ')' || char === ']' || char === '}') {<br/>            let candidate = stack.pop();<br/>            if (map[char] !== candidate) {<br/>                return false;<br/>            };<br/>        };<br/>    };<br/>return true;<br/>};</span></pre><p id="3b40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。这个问题很简单，但它显示了对大量算法基础的扎实理解。习惯于了解不同的问题解决技术，以及如何利用不同的数据结构，对于回答如此多的问题至关重要。</p><p id="e8cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！请在下面留下您可能希望我在未来的博客中涉及的其他算法的任何评论。</p><p id="9da5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！</p><p id="c5e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lz">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>