<html>
<head>
<title>Incorporating JavaScript into a Rust app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将JavaScript整合到Rust应用中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/embed-javascript-in-rust-3f7d66221f52?source=collection_archive---------1-----------------------#2021-09-09">https://javascript.plainenglish.io/embed-javascript-in-rust-3f7d66221f52?source=collection_archive---------1-----------------------#2021-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f6c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> WasmEdge融合了Rust的性能和JavaScript的易用性</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e0a6252d7a5bbf708e1d65bc97fb47f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYqeVDkg8KHF8_zajSQUdA.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae kz" href="https://unsplash.com/s/photos/rust-javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="058c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/running-javascript-in-webassembly-883ec71438e1">上一篇文章</a>中，我讨论了如何在WebAssembly沙箱中运行JavaScript程序。<a class="ae kz" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge运行时</a>为云原生JavaScript应用程序提供了一个轻量级、高性能和OCI兼容的“容器”。</p><p id="39a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，JavaScript是一种“慢”语言。使用JavaScript的原因主要是因为它的易用性和开发效率，尤其是对于初学者。另一方面，WebAssembly能够运行用Rust等语言编写的高性能应用程序。有没有结合JavaScript和Rust的解决方案？WasmEdge提供了两个世界中最好的东西。</p><p id="1193" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/" rel="noopener ugc nofollow" target="_blank"> WasmEdge和QuickJS </a>，开发者现在可以混合搭配这两种强大的语言来创建应用程序。它是这样工作的。</p><ul class=""><li id="f1ad" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated">应用本身是用Rust写的，编译成WebAssembly。它可以作为一个wasm字节码文件进行编译和部署。它可以通过Docker Hub、CRI-O和k8s等符合OCI标准的容器工具进行管理。</li><li id="146f" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">JavaScript程序嵌入在Rust应用程序中。JavaScript源代码可以在编译时包含，也可以在运行时通过文件、STDIN、网络请求甚至函数调用包含。这允许JavaScript程序由不同于Rust程序的开发人员编写。</li><li id="eea9" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">Rust程序可以处理应用程序中的计算密集型任务，而JavaScript程序可以处理“业务逻辑”。例如，Rust程序可以为JavaScript程序准备数据。</li></ul><p id="733c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们来看几个例子。查看<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/" rel="noopener ugc nofollow" target="_blank">wasmedge-quick js</a>Github repo，并转到<code class="fe lo lp lq lr b">examples/embed_js</code>文件夹继续跟进。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="948b" class="lw lx in lr b gy ly lz l ma mb">$ git clone https://github.com/second-state/wasmedge-quickjs<br/>$ cd examples/embed_js</span></pre><p id="52fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您必须安装<a class="ae kz" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank"> Rust </a>和<a class="ae kz" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>来构建和运行本文中的示例。</p><p id="a91f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lo lp lq lr b">embed_js</code>演示展示了如何在Rust中嵌入JavaScript的几个不同的例子。您可以构建并运行所有示例，如下所示。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="6854" class="lw lx in lr b gy ly lz l ma mb">$ cargo build --target wasm32-wasi --release<br/>$ wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm</span></pre><h1 id="9043" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">你好WasmEdge</h1><p id="bdc5" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">下面的Rust函数<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/embed_js/src/main.rs" rel="noopener ugc nofollow" target="_blank"> main.rs </a>在编译时嵌入了一行JavaScript程序。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="3fc8" class="lw lx in lr b gy ly lz l ma mb">fn js_hello(ctx: &amp;mut Context) {<br/>    let code = r#"print('hello quickjs')"#;<br/>    let r = ctx.eval_global_str(code);<br/>    println!("return value:{:?}", r);<br/>}</span></pre><p id="2a50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于嵌入式JavaScript程序不返回任何内容，您将看到如下执行结果。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="f1c2" class="lw lx in lr b gy ly lz l ma mb">hello quickjs<br/>return value:UnDefined</span></pre><h1 id="bd6b" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">返回值</h1><p id="057d" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">当然，嵌入式JavaScript程序可以向Rust程序返回值。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="abc8" class="lw lx in lr b gy ly lz l ma mb">fn run_js_code(ctx: &amp;mut Context) {<br/>    let code = r#"<br/>      let a = 1+1;<br/>      print('js print: 1+1=',a);<br/>      'hello'; // eval_return<br/>    "#;<br/>    let r = ctx.eval_global_str(code);<br/>    println!("return value:{:?}", r);<br/>}</span></pre><p id="f07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">返回值是一个字符串<code class="fe lo lp lq lr b">hello</code>。运行这个Rust程序的输出如下。注意，在Rust中，JavaScript字符串值被包装在<code class="fe lo lp lq lr b">JsString</code>中。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="3fb7" class="lw lx in lr b gy ly lz l ma mb">js print: 1+1= 2<br/>return value:String(JsString(hello))</span></pre><h1 id="81cd" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">调用嵌入式JavaScript函数</h1><p id="610c" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">从Rust程序中，您可以调用一个JavaScript函数，传入调用参数，并捕获返回值。第一个例子展示了如何将一个Rust字符串传递给一个JavaScript函数。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="e660" class="lw lx in lr b gy ly lz l ma mb">fn run_js_function(ctx: &amp;mut Context) {<br/>    let code = r#"<br/>      (x)=&gt;{<br/>          print("js print: x=",x)<br/>      }<br/>    "#;<br/>    let r = ctx.eval_global_str(code);<br/>    if let JsValue::Function(f) = r {<br/>        let hello_str = ctx.new_string("hello");<br/>        let mut argv = vec![hello_str.into()];<br/>        let r = f.call(&amp;mut argv);<br/>        println!("return value:{:?}", r);<br/>    }</span><span id="16f9" class="lw lx in lr b gy ne lz l ma mb">    ...<br/>}</span></pre><p id="4aaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">来自<code class="fe lo lp lq lr b">ctx.eval_global_str(code)</code>的值<code class="fe lo lp lq lr b">r</code>是一个映射到JavaScript函数的Rust函数。您可以调用Rust函数，并从调用JavaScript函数中获得预期的结果。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="26f8" class="lw lx in lr b gy ly lz l ma mb">js print: x= hello<br/>return value:UnDefined</span></pre><p id="7bab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以将一个数组从Rust传递给JavaScript函数，并让JavaScript函数返回值。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="e836" class="lw lx in lr b gy ly lz l ma mb">fn run_js_function(ctx: &amp;mut Context) {<br/>    ...</span><span id="86d8" class="lw lx in lr b gy ne lz l ma mb">    let code = r#"<br/>      (x)=&gt;{<br/>          print("\nx=",x)<br/>          let old_value = x[0]<br/>          x[0] = 1<br/>          return old_value<br/>      }<br/>    "#;<br/>    let r = ctx.eval_global_str(code);<br/>    if let JsValue::Function(f) = r {<br/>        let mut x = ctx.new_array();<br/>        x.set(0, 0.into());<br/>        x.set(1, 1.into());<br/>        x.set(2, 2.into());</span><span id="6eca" class="lw lx in lr b gy ne lz l ma mb">        let mut argv = vec![x.into()];<br/>        println!("argv = {:?}", argv);<br/>        let r = f.call(&amp;mut argv);<br/>        println!("return value:{:?}", r);<br/>    }<br/>}</span></pre><p id="6080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果如下。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="747b" class="lw lx in lr b gy ly lz l ma mb">argv = [Array(JsArray(0,1,2))]<br/>x= 0,1,2<br/>return value:Int(0)</span></pre><h1 id="3abc" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">使用JavaScript模块</h1><p id="baa7" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">嵌入式JavaScript程序可以将外部JavaScript文件作为模块加载。<code class="fe lo lp lq lr b">examples/embed_js_module</code>项目展示了这个用例。<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/embed_js_module/async_demo.js" rel="noopener ugc nofollow" target="_blank"> async_demo.js </a>文件包含一个带有导出函数的JavaScript模块，我们将导入该模块并在嵌入式JavaScript中使用。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="5e12" class="lw lx in lr b gy ly lz l ma mb">import * as std from 'std'</span><span id="c6ee" class="lw lx in lr b gy ne lz l ma mb">async function simple_val (){<br/>    return "abc"<br/>}</span><span id="49d2" class="lw lx in lr b gy ne lz l ma mb">export async function wait_simple_val (a){<br/>    let x = await simple_val()<br/>    print("wait_simple_val:",a,':',x)<br/>    return 12345<br/>}</span></pre><p id="4fd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rust程序源代码按照ES规范的要求异步导入<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/embed_js_module/async_demo.js" rel="noopener ugc nofollow" target="_blank"> async_demo.js </a>模块。执行结果<code class="fe lo lp lq lr b">p</code>是一个Rust <code class="fe lo lp lq lr b">Promise</code>，它将在异步函数返回后具有正确的值。Rust中的<code class="fe lo lp lq lr b">ctx.promise_loop_poll()</code>调用一直等到异步执行完成。然后我们可以从<code class="fe lo lp lq lr b">Promise</code>接收返回值。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="91cc" class="lw lx in lr b gy ly lz l ma mb">use wasmedge_quickjs::*;</span><span id="50d8" class="lw lx in lr b gy ne lz l ma mb">fn main() {<br/>    let mut ctx = Context::new();</span><span id="25da" class="lw lx in lr b gy ne lz l ma mb">    let code = r#"<br/>      import('async_demo.js').then((demo)=&gt;{<br/>        return demo.wait_simple_val(1)<br/>      })<br/>    "#;</span><span id="030b" class="lw lx in lr b gy ne lz l ma mb">    let p = ctx.eval_global_str(code);<br/>    ctx.promise_loop_poll();<br/>    println!("after poll:{:?}", p);<br/>    if let JsValue::Promise(ref p) = p {<br/>        let v = p.get_result();<br/>        println!("v = {:?}", v);<br/>    }<br/>}</span></pre><p id="e892" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果如下。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="ab5e" class="lw lx in lr b gy ly lz l ma mb">wait_simple_val: 1 : abc<br/>after poll:Promise(JsPromise([object Promise]))<br/>v = Int(12345)</span></pre><h1 id="8c39" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">下一步是什么</h1><p id="a09e" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">在Rust中嵌入JavaScript是创建高性能云原生应用的一种强大方式。在下一篇文章中，我们将研究另一种方法:<a class="ae kz" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用Rust实现JavaScript API</a>。它允许JavaScript开发人员利用WasmEdge运行时中的高性能Rust函数。</p><p id="586a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本系列文章:</p><ul class=""><li id="357c" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/" rel="noopener ugc nofollow" target="_blank">用WasmEdge在WebAssembly中运行JavaScript</a></li><li id="13be" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/embed-javascript-in-rust/" rel="noopener ugc nofollow" target="_blank">将JavaScript整合到Rust应用中</a></li><li id="0f9c" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用Rust创建高性能的JavaScript APIs】</a></li><li id="af34" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/call-native-functions-from-javascript/" rel="noopener ugc nofollow" target="_blank">从JavaScript调用本地函数</a></li></ul><p id="0ab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云原生WebAssembly中的JavaScript仍然是下一代云和边缘计算基础设施中的新兴领域。我们才刚刚开始！如果您感兴趣，请加入我们的<a class="ae kz" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>项目(或者通过提出功能请求问题告诉我们您想要什么)。</p><p id="2f67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>