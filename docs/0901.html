<html>
<head>
<title>Writing a Node.js GraphQL backend that actually scales</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写实际可伸缩的Node.js GraphQL后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-bd5b3411b293?source=collection_archive---------2-----------------------#2021-02-25">https://javascript.plainenglish.io/writing-a-node-js-graphql-backend-that-actually-scales-bd5b3411b293?source=collection_archive---------2-----------------------#2021-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5556" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:数据库和关系、ODM/ORM和字段解析器</h2></div><p id="4743" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你还没有参加本教程第一部分的学习，我强烈建议你参加。尽管您将在这里看到的内容可以很容易地应用于每个Node.js GraphQL项目，但我将假设您有一个与我们在上一部分中构建的文件结构和模式相似或相同的文件结构和模式。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/98e9aaf105b9dea8ec394e2626854328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENMJyVnsHHu9ksNkO1NkDg.jpeg"/></div></div></figure><p id="5236" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，让我们把之前构建的GraphQL服务器变成一个真正有用的服务器。</p><p id="96ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了让我们的数据发挥作用，我们必须做的第一件事是选择一个数据库，为了简单起见，我将选择<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。尽管这是一个NoSQL数据库，但我将把示例和模式附加到一个关系方法中，这样您就可以将同样的想法移植到您喜欢的任何数据库中。</p><p id="8222" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在我们开始之前，请将<a class="ae ky" href="http://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>添加到您的repo中，这是一个非常好的用于MongoDB的ODM，它将帮助我们建模和访问我们的数据库。</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="c21e" class="lq lr in lm b gy ls lt l lu lv">yarn add mongoose</span></pre><p id="afb5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注意:</strong>安装并运行MongoDB是一个先决条件，但是，因为您可以自由选择任何您想要的数据库，所以我不会讨论MongoDB的安装。你也可以在这里查看。</p><h1 id="a40c" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">连接我们的数据库</h1><p id="5251" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">你记得我们的<code class="fe ms mt mu lm b">index.js</code>文件吗？嗯，它本来是用来初始化的中心点。在本例中，我们将在初始化服务器之前，在同一个文件中初始化我们的数据库，这样数据可以立即可用。</p><p id="e842" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们首先创建一个连接到数据库的实用程序，遵循为与应用程序域相关的所有内容创建一个文件夹的相同方法。之前我们创建了两个:<code class="fe ms mt mu lm b">config</code>和<code class="fe ms mt mu lm b">graphql</code>。现在，出于显而易见的原因，我们将创建一个名为<code class="fe ms mt mu lm b">db</code>的文件夹。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bc88c252af13e3c0af3669cb59d0047a.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*QH5-4JTR41xxYEW16Y3hyQ.png"/></div></figure><p id="d058" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还在我们的<code class="fe ms mt mu lm b">db</code>文件夹中创建了另一个<code class="fe ms mt mu lm b">models</code>文件夹，所以我们可以在其中建模我们的数据。现在，请将以下脚本添加到index.js中，以连接到我们的数据库:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="00b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能会看到从我们的配置中导入了一个新的环境变量。现在，它会抛出一个错误，因为它是不可用的，但我们稍后会修复它。</p><p id="c62f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个脚本的目的是创建一个到我们数据库的连接，但是对于保存我们记忆的连接是有用的，所以如果你使用它从另一个文件(比如种子或测试)连接，它不会创建另一个到数据库的连接。</p><p id="41ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，我们将在index.js中使用它:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3f86" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您启用了您的服务器，您可能会看到一个错误，因为mongoose不知道如何连接到您的数据库，因为我们没有提供URI字符串来这样做。</p><p id="0cf4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用<code class="fe ms mt mu lm b">ctrl + c</code>关闭我们的服务器，并添加我们的环境变量(别忘了也把它放到你的<code class="fe ms mt mu lm b">.env.example</code>文件中)</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0fee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，使用它并将其从您的环境配置文件中导出:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="697a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，用<code class="fe ms mt mu lm b">yarn dev</code>重启你的服务器，如果一切正常，你会看到你的服务器和数据库的连接。</p><h1 id="1b17" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">为我们的数据建模</h1><p id="9358" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">你注意到我们在<code class="fe ms mt mu lm b">db</code>文件夹中放了一个<code class="fe ms mt mu lm b">models</code>文件夹。嗯，这是您创建模型的地方。</p><p id="b852" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个index.js，将其用作默认的导出文件，这样我们就可以像这样做:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="eb14" class="lq lr in lm b gy ls lt l lu lv">import { Book, Author, Publisher } from 'your/models/path'</span></pre><p id="769b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，为我们需要的每个模型创建一个文件。请记住我们在上一篇文章中展示的数据库图表。如果你想记起来，你应该这样做:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi my"><img src="../Images/015eafcf03a3dd2cc7e42ad55c0a85c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*w8LX9nTZFfpVYqtzLwhL0Q.png"/></div></figure><p id="57db" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的index.js应该是这样的:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cc21" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作者模型:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8c68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">书籍模型</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="32b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发布者模型:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b4fd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后但并非最不重要的一点是，我们与出版商和作者的联系很弱:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="843a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您可能已经看到的，mongoose模式上的timestamps选项自动创建和管理createdAt和updatedAt字段。所以你不需要照顾它。</p><p id="ce8b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看模式中的每个关系都有一个指向另一个模型名称的<code class="fe ms mt mu lm b">ref</code>属性。这样做是为了让mongoose能够在内部知道如何创建表之间的连接。尽管我们不会在本教程中使用它们(因为它们只在我们调用时使用。在我们的模型中，<a class="ae ky" href="https://mongoosejs.com/docs/populate.html" rel="noopener ugc nofollow" target="_blank"> populate </a>()总是拥有它们是很有用的，所以我们最终可以使用populate来消费解析器中的关系数据。除非您在这里或者在每个单独的。填充您制作的。</p><p id="5396" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，您应该很容易看到模型与我们之前定义的typedefs的对应关系。</p><h1 id="2853" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">解析数据</h1><p id="bfdd" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">如果你已经走了这么远，太好了！您已经准备好开始向GraphQL服务器添加真正的功能，我们将从完成解析器开始。</p><p id="e8fb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先要考虑的是，解析器有3个参数，允许我们构建解析器内部需要的规则，这3个参数是:</p><ul class=""><li id="0ead" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated"><strong class="ke io">父:</strong>这是前一个解析器的结果，我们通常在主解析器中忽略这一点，因为前一个解析器是查询/变异定义，在第一级没有用。但是，假设您需要在Book内部创建一个解析器来计算它拥有的“兄弟”(相同作者的书籍)的数量。好吧，你会在这个参数中收到书本身。在那里，您可以使用它来构建另一个数据库查询，以满足请求或您想要的任何东西。</li><li id="ea95" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated"><strong class="ke io"> Arguments: </strong>这是您从客户端提供给解析器的参数列表，显然，您可以使用它们来创建基于所提供参数的查询。</li><li id="6bb8" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated"><strong class="ke io">上下文:</strong>上下文就像一艘沿着解析器航行的宇宙飞船，它携带着可能对您使用很重要的数据，比如身份验证，或者在我们的例子中，数据定位器，我们将在下一篇文章中看到。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/377cb2a78fb4f5b03ce546c86ec8e171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*B1rxiSeFuoJV4JcY"/></div></figure><p id="b182" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解析器是提供给模式的一个对象，它们表示类型和它们的字段，所以我们告诉模式<em class="no">如何解析</em>一个类型中的特定字段，它们看起来像这样:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="64fe" class="lq lr in lm b gy ls lt l lu lv">{<br/>  ...<br/>  Query: {<br/>    field: (parent, arguments, context) =&gt; {}<br/>  },<br/>  Mutation: {<br/>    field: (parent, arguments, context) =&gt; {}<br/>  },<br/>  AnyOtherType: {<br/>    field: (parent, arguments, context) =&gt; {}<br/>  },<br/>  ...<br/>}</span></pre><p id="72d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">乍一看，你可能会注意到我把<code class="fe ms mt mu lm b">AnyOtherType</code>放在那里，还有常见的<code class="fe ms mt mu lm b">Query</code>和<code class="fe ms mt mu lm b">Mutation</code>。这是故意放在这里的，让你想知道它为什么会在那里。我们将在以后开始使用场分解器时讨论它……记住它们就行了。</p><p id="f6a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，也就是说，让我们填写作者的解析器，然后，我会让你自己做下一个。而且，如果你有问题，记得有一个<a class="ae ky" href="https://github.com/ernestognw/graphql-backend/tree/part-2" rel="noopener ugc nofollow" target="_blank">公共回购</a>在那里你可以检查在这个特定的部分所做的一切。</p><p id="7178" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ms mt mu lm b">graphql/resolvers/author/queries.js</code>:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1bb4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在完成我们的突变之前，让我们再看一下我们的数据库图表:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi np"><img src="../Images/b4c19ba790139aa9e65ba52a99063f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLgi7xBdptficIaVDdPJPg.png"/></div></div></figure><p id="3e13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还没有考虑如何通过我们的GraphQL模式建立WorksAt关系。这是因为通常情况下，我不喜欢直接通过模式暴露脆弱的实体，但这是我的个人偏好，如果你愿意，你可以用另一种方式，但我强烈推荐以下解决方案:</p><p id="68d0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然WorksAt是一个弱实体，因为它只服务于关联出版商和作者的目的，但它非常适合将这种关系附加到关系的一侧，例如，在本教程中，我们将认为每个WorksAt操作都是作者的操作，在自然语言中，您可以看到这好像我们从作者的角度谈论WorksAt，类似于“将作者与他们的出版商相关联”。</p><p id="6ee8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当关系中有额外的信息时，例如角色，这尤其有用。在那里，您可以询问用户在特定出版物中的角色。</p><p id="9d2a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住这一点，让我们在GraphQL模式中添加一个额外的查询typedef <code class="fe ms mt mu lm b">addAuthorToPublication</code>:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fe11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，让我们在<code class="fe ms mt mu lm b">graphql/resolvers/author/mutations.js</code>中为作者添加突变:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1d08" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我会让你完成剩下的，你只需要复制已经为作者提供的解决方案，并相应地进行修改。</p><blockquote class="nq nr ns"><p id="67ff" class="kc kd no ke b kf kg jo kh ki kj jr kk nt km kn ko nu kq kr ks nv ku kv kw kx ig bi translated">一如既往，如果你想检查我做了什么，去<a class="ae ky" href="https://github.com/ernestognw/graphql-backend/tree/part-2" rel="noopener ugc nofollow" target="_blank">回购</a>。</p></blockquote><h1 id="fc0d" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">播种数据</h1><p id="c1f3" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">为了继续，我们需要一些数据来处理，所以，我将为您提供一个种子脚本，所以您不需要担心数据。在你的<code class="fe ms mt mu lm b">db</code>文件夹中创建这个文件，在一个新的文件夹中，名为<code class="fe ms mt mu lm b">scripts</code>:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ed76" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，您可以将以下脚本添加到您的<code class="fe ms mt mu lm b">package.json</code>中:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="3531" class="lq lr in lm b gy ls lt l lu lv">"db:seed": "babel-node ./db/scripts/seed.js"</span></pre><p id="84dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，运行:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="a8af" class="lq lr in lm b gy ls lt l lu lv">yarn db:seed</span></pre><p id="7276" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你的数据库里会有这些数据。每当您想要重新启动数据时，都可以重复此操作。</p><p id="c412" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们上<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>开始查询一些数据:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="e169" class="lq lr in lm b gy ls lt l lu lv">query books {<br/>  books {<br/>    id<br/>    name<br/>    createdAt<br/>    updatedAt<br/>  }<br/>}</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nw"><img src="../Images/5b7c939fb66b0bf0964e1cdd62712699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ppvr5qOvRxgWSL1E6rN5pg.png"/></div></div></figure><p id="f412" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会注意到您的数据现在是可用的，但是如果我们试图请求我们的模型的连接关系呢？例如，请求一本书的作者，比如:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="0e24" class="lq lr in lm b gy ls lt l lu lv">query books {<br/>  books {<br/>    id<br/>    name<br/>    createdAt<br/>    updatedAt<br/>    <strong class="lm io">author {<br/>      id<br/>      name<br/>    }</strong><br/>  }<br/>}</span></pre><p id="e874" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于您的模型不能自动填充关系，您将会遇到一个错误，因为解析器试图返回author字段中的id，而不是一个对象。</p><p id="ebd7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决关系，我们需要利用GraphQL字段解析器…</p><h1 id="6962" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">关系和字段解析器</h1><p id="801a" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在使用REST APIs时，建模关系的方法是选择在数据服务器端填充一个深度级别，或者只是返回id，这样客户端就可以构造另一个查询来完成数据。</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="3f1a" class="lq lr in lm b gy ls lt l lu lv">// Server-side populated data<br/>[<br/>  ...<br/>  {<br/>    "id": "60328a4dc830684efb1f0833",<br/>    "name": "Hello world!: A JS tale",<br/>    "createdAt": "2021-02-21T16:29:01.265Z",<br/>    "updatedAt": "2021-02-21T16:29:01.265Z",<br/>    "author": {<br/>      "id": "60328a4dc830684efb1f082b",<br/>      "name": "Cynthia"<br/>     }<br/>   },<br/>  ...<br/>]</span><span id="a5f5" class="lq lr in lm b gy nx lt l lu lv">// Only id returned<br/>[<br/>  ...<br/>  {<br/>    "id": "60328a4dc830684efb1f0833",<br/>    "name": "Hello world!: A JS tale",<br/>    "createdAt": "2021-02-21T16:29:01.265Z",<br/>    "updatedAt": "2021-02-21T16:29:01.265Z",<br/>    "author":  "60328a4dc830684efb1f082b"<br/>   },<br/>  ...<br/>]</span></pre><p id="789b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两种选择都有明显的缺点。在第一个解决方案中，您正在做所谓的<em class="no">过度提取</em>，这意味着无论您的客户端需要什么，您总是在填充关系，因此，以一种可能不必要的方式影响性能。</p><p id="8e20" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种解决方案意味着您正在进行所谓的<em class="no">欠填充，</em>这意味着您永远不会填充关系，然后，您的客户端必须收集那些引用并创建另一个请求来填充数据，这导致了一系列串联查询中的最坏情况。</p><p id="ca6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">众所周知，GraphQL可以避免这个问题，但是，它到底是如何做到的呢？</p><h2 id="63d3" class="lq lr in bd lx ny nz dn mb oa ob dp mf kl oc od mh kp oe of mj kt og oh ml oi bi translated">展示现场解析器</h2><p id="c1fa" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">每当你向GraphQL返回一个东西时，它会试图解析它，直到它达到一个不可序列化的值，这意味着，任何可以在JSON中返回的东西。例如，如果在解析器中返回一个承诺，GraphQL将一直等待，直到该承诺被解析，无论从该承诺返回什么，都会尝试再次序列化，如果是另一个函数或承诺，则重复该过程。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi oj"><img src="../Images/0f2225f5e4a0234c7216b85081ba4827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8KUBdpUYbRzf7XPLKUXdQ.png"/></div></div></figure><p id="9559" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我们来说，这意味着我们可以返回函数来解析模式树中的下一个值，最棒的是<strong class="ke io"> GraphQL不会尝试解析客户端没有请求的字段，</strong>这太棒了，因为我们可以利用这一优势对关系进行建模，使解析器自动适应客户端的任何请求。</p><p id="43f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在我们的《解析器》一书中，我们可以这样做:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3308" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看我们如何在<code class="fe ms mt mu lm b">books.author</code>中返回一个函数。这只有在客户端请求特定字段时才会执行，但问题是我们必须对每个返回一本书的解析器重复这一操作，而这并不是我们想要实现的可伸缩性。这是场分解器进入场景的地方。</p><p id="20d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注意:</strong>我们不打算保留之前要点中的书籍解析器，所以，你可以把它恢复到原来的状态。</p><p id="ad18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你还记得当我们谈论解析器时，我放回的<code class="fe ms mt mu lm b">AnyOtherField</code>吗？这就是奇迹发生的地方。</p><p id="6dbd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">字段解析器</strong>允许我们为特定类型中的特定字段定义解析器。在book示例中，我们可以提供一个函数来解析author字段，告诉我们的模式在<code class="fe ms mt mu lm b">Book</code>中有一个名为<code class="fe ms mt mu lm b">author</code>的字段，我们会处理它。类似于下面的形状:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="543e" class="lq lr in lm b gy ls lt l lu lv">{<br/>  ...<br/>  Query: {<br/>    field: (parent, arguments, context) =&gt; {}<br/>  },<br/>  Mutation: {<br/>    field: (parent, arguments, context) =&gt; {}<br/>  },<br/>  <strong class="lm io">Book: {<br/>    author: (parent, arguments, context) =&gt; {<br/>      </strong>// Hi GraphQL, <br/>      // this fields is something you can't handle naturally. <br/>      // So we'll take care of it.<strong class="lm io"><br/>    }<br/>  },</strong><br/>  ...<br/>}</span></pre><p id="573a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很棒，因为我们不必关心在每个返回一本书的解析器中返回一个函数，我们只需要声明一个字段解析器，GraphQL就会知道为了填充那个字段，它需要调用我们的自定义函数。</p><p id="759c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转到您的<code class="fe ms mt mu lm b">resolvers/index.js</code>文件并添加:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2d32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们刚刚在Book下添加了一个新的字段解析器，它返回一个承诺，返回我们正在搜索的作者。看，我们使用解析器的父参数<strong class="ke io">，</strong>，这意味着当它被执行时，父参数就是书本身，所以我们可以将作者从id转换成实际的对象。</p><p id="36e5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，无论您只请求一本书还是许多书，您都可以填充作者的数据，而无需在每个解析器中处理这些数据。这甚至适用于你要还书的突变(比如说<code class="fe ms mt mu lm b">createBook</code>或<code class="fe ms mt mu lm b">updateBook</code>)</p><h1 id="b58c" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">重组字段解析器</h1><p id="8072" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">接下来，我们将把这些字段解析器传递到相应的文件夹，这样我们就可以(再次)做好一切准备。</p><p id="abf7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在每个解析器文件夹中创建一个<code class="fe ms mt mu lm b">fields.js</code>文件，这样我们可以将字段解析器放在那里，然后将其导出并合并到<code class="fe ms mt mu lm b">resolvers/index.js</code>中</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/457c87959a8016626cb32e7ff00a9253.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*KlprdCI57PUG4yCZgQXuSA.png"/></div></figure><p id="d301" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用我们已经拥有的内容填充图书字段:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fa3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你有了概念，我将挑战你从出版商到作者的关系建模，反之亦然。<strong class="ke io">提示:</strong>您可以查询WorksAt模型，然后返回关系的元素。</p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><p id="9416" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想知道怎么做，我给你看:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f59e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后要做的是将它们从各自的<code class="fe ms mt mu lm b">resolvers/&lt;entity&gt;/index.js</code>中重新导出，并将它们添加到主解析器索引文件中，如下所示:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="37c3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想测试这一点，你可以去操场开始玩数据。您会注意到，您可以请求任何深度的数据，如下所示:</p><pre class="la lb lc ld gt ll lm ln lo aw lp bi"><span id="0529" class="lq lr in lm b gy ls lt l lu lv">query authors {<br/>  authors {<br/>    id<br/>    publishers {<br/>      id<br/>      authors {<br/>        id<br/>        publishers {<br/>          authors {<br/>            id<br/>            publishers {<br/>              id<br/>              authors {<br/>                id<br/>                publishers {<br/>                  id<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2541" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管可能需要几秒钟才能完成，但您可能认为这会导致性能问题，您是对的，但是我们将在本系列的下一部分解决这个问题。</p><h1 id="20a3" class="lw lr in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">包裹</h1><p id="c9a5" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在本教程的第2部分中，我们将:</p><ul class=""><li id="3683" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated">增加了对ORM/ODM的支持</li><li id="6337" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">使用我们的ORM/ODM根据我们的GraphQL模式对我们的数据建模</li><li id="0d84" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">创建seeders来用测试数据填充我们的数据库</li><li id="63d4" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">了解了解析器的工作原理</li><li id="066e" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">为查询和突变创建了解析器</li><li id="88b5" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">了解了数据实际上是如何从GraphQL返回的</li><li id="6083" class="mz na in ke b kf ni ki nj kl nk kp nl kt nm kx ne nf ng nh bi translated">添加了字段解析器来完善模型之间的关系</li></ul><p id="a0e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，在这一点上的一切都可以咨询和审查到我的整个系列的公开回购中，<a class="ae ky" href="https://github.com/ernestognw/graphql-backend/tree/part-2" rel="noopener ugc nofollow" target="_blank">，你可以在这里找到</a>。</p><ul class=""><li id="f55c" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated">在社交媒体上关注我:<a class="ae ky" href="https://www.instagram.com/ernestognw/" rel="noopener ugc nofollow" target="_blank"> @ernestognw </a></li></ul><p id="defb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/writing-a-node-js-graphql-backend-that-actually-scales-d20c920a4494">此处第3部分</a></p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><p id="059c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="no">详见</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="no">plain English . io</em></strong></a></p></div></div>    
</body>
</html>