<html>
<head>
<title>Introduction to Memoization in JavaScript with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的记忆化介绍及示例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-memoization-in-javascript-with-examples-e1a2b7f44575?source=collection_archive---------1-----------------------#2021-04-02">https://javascript.plainenglish.io/intro-to-memoization-in-javascript-with-examples-e1a2b7f44575?source=collection_archive---------1-----------------------#2021-04-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/185832cd3a831f1cd4b293cc818c85a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*sf-Uvg52vAXyrLJIMSJU1w.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Photo by <a class="ae jv" href="https://www.pexels.com/@markusspiske" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a></figcaption></figure><p id="279e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在我的第一次现场编码面试中，我遇到了一个我从未见过的概念。我不记得这个问题的逐字逐句，但它大致是这样的:</p><p id="92fb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><em class="ku">创建一个memoize函数，它能记住以前的输入，并将它们存储在缓存中，这样它就不必多次计算相同的输入。该函数将接受未指定数量的整数输入和一个reducer方法。参见:</em></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="325a" class="le lf in la b gy lg lh l li lj">//Given reducer method: <br/>function add(a,b){<br/> return a+b<br/>}</span><span id="633d" class="le lf in la b gy lk lh l li lj">//Create a method called memoize such that: <br/>const memoizeAdd = memoize(add);</span><span id="84ba" class="le lf in la b gy lk lh l li lj">//then calling…<br/>memoizeAdd(100,100); //returns 200<br/>memoizeAdd(100); //returns 100<br/>memoizeAdd(100,200) //returns 300<br/>memoizeAdd(100,100) //returns 200 without computing</span></pre><p id="bffe" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">所以我在想… <em class="ku"> sh*t. </em>我以前从未使用过缓存，我该怎么回答这个问题呢！？然后我想起我听说过这个术语<em class="ku">记忆化</em>，甚至在我最近的【React本地项目中使用了它。如果我没记错的话，我当时遇到了性能问题，在StackOverflow上搜索了一些可能的解决方案，发现<a class="ae jv" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"><em class="ku">react . memo</em></a><em class="ku"/>是一个有效的解决方案。不过，我一定是下意识地忽略了记忆实际上是如何工作的。</p><p id="7f0b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">谢天谢地，这是一次风投面试，所以我花了几秒钟在谷歌上查了一下，“什么是memoize函数？”<em class="ku">(嗯……差不多吧)</em>。我找到了下面的<a class="ae jv" href="https://www.freecodecamp.org/news/understanding-memoize-in-javascript-51d07d19430e/" rel="noopener ugc nofollow" target="_blank">示例代码</a>，并将其作为参考来帮助回答问题的其余部分。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ba27" class="le lf in la b gy lg lh l li lj">// a simple function to add something<br/>const add = (n) =&gt; (n + 10);<br/>add(9);<br/>// a simple memoized function to add something<br/>const memoizedAdd = () =&gt; {<br/>  let cache = {};<br/>  return (n) =&gt; {<br/>    if (n in cache) {<br/>      console.log('Fetching from cache');<br/>      return cache[n];<br/>    }<br/>    else {<br/>      console.log('Calculating result');<br/>      let result = n + 10;<br/>      cache[n] = result;<br/>      return result;<br/>    }<br/>  }<br/>}<br/>// returned function from memoizedAdd<br/>const newAdd = memoizedAdd();<br/>console.log(newAdd(9)); // calculated<br/>console.log(newAdd(9)); // cached</span></pre><p id="8e1d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">首先，让我们了解记忆化是做什么的。然后我们将检查上面显示的示例代码。最后，我们将看看它是如何帮助解决上述面试问题的。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h2 id="0c9f" class="le lf in bd ls lt lu dn lv lw lx dp ly kh lz ma mb kl mc md me kp mf mg mh mi bi translated">记忆有什么作用</h2><p id="a118" class="pw-post-body-paragraph jw jx in jy b jz mj kb kc kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt ig bi translated">下面是我发现的关于函数记忆的一个简单而准确的解释:</p><p id="5542" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">“记忆化是一种优化技术，在这种技术中，代价高昂的函数调用被缓存起来，这样下次用相同的参数调用函数时，结果可以立即返回”。—乔纳森·莱曼， <a class="ae jv" href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" rel="noopener ugc nofollow" target="_blank"> <em class="ku"> JavaScript函数记忆化</em> </a></p><p id="85e7" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io"> <em class="ku">注意:</em> </strong> <em class="ku">这种场景下不需要应用浏览器缓存。</em></p><p id="a4d3" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我可能会这样详细说明:内存化通过将先前计算的结果存储在一个JavaScript对象(也称为缓存)中来帮助加速函数调用。换句话说，每次执行memoize方法时，都会发生以下两种情况之一:</p><ol class=""><li id="b12b" class="mo mp in jy b jz ka kd ke kh mq kl mr kp ms kt mt mu mv mw bi translated"><strong class="jy io">如果输入之前被使用过，在缓存中找到它并立即返回存储的值，而不执行任何进一步的计算。</strong></li><li id="95db" class="mo mp in jy b jz mx kd my kh mz kl na kp nb kt mt mu mv mw bi translated"><strong class="jy io">使用输入执行任何必要的计算，将结果存储在缓存中，返回结果。</strong></li></ol><h2 id="d693" class="le lf in bd ls lt lu dn lv lw lx dp ly kh lz ma mb kl mc md me kp mf mg mh mi bi translated">一个简单的记忆例子</h2><p id="86c0" class="pw-post-body-paragraph jw jx in jy b jz mj kb kc kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt ig bi translated">为了进行演示，让我们构建一个简单的memoize函数，类似于上面显示的函数。</p><p id="e6c2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">首先让我们用ES6定义我们的函数。作为一个参数，它将接受一个函数，<em class="ku"> fn </em>，用于计算。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8942" class="le lf in la b gy lg lh l li lj">const memoize = (fn) =&gt; {}</span></pre><p id="70a6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">接下来，让我们声明一个初始缓存对象。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f143" class="le lf in la b gy lg lh l li lj">const memoize = (fn) =&gt; {<br/>   let cache = {}<br/>}</span></pre><p id="b6af" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">太好了。现在让我们实际返回一些东西。我们将首先实现可能性# 1—“<em class="ku">如果输入以前被使用过，在缓存中找到它，并立即返回存储的值，而不执行任何进一步的计算。”</em></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="0bcd" class="le lf in la b gy lg lh l li lj">const memoize = (fn) =&gt; {<br/>   let cache = {}<br/>   return (n) =&gt; {<br/>      if (n in cache){<br/>         return cache[n]<br/>      }<br/>}</span></pre><p id="4b55" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我们来复习一下。首先，<em class="ku"> memoize </em>已经正式成为<a class="ae jv" href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99#:~:text=A%20higher%20order%20function%20is,return%20a%20function%20as%20output." rel="noopener">高阶函数</a>，因为它将一个函数作为输入和/或返回一个函数作为输出。更详细地说，如果我们调用<em class="ku"> memoize </em>，我们将得到另一个函数，该函数检查给定的参数<strong class="jy io"> <em class="ku"> n </em> </strong>是否是<strong class="jy io"> <em class="ku">缓存</em> </strong>中的一个键，并将返回其相应的值。这有什么特别的？事实上，返回的函数在其作用域内有<strong class="jy io"> <em class="ku">缓存</em> </strong>，可以访问或添加属性！向前看，这可以证明是非常强大的。</p><p id="e8bb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">现在，缓存对象将保持为空，因此让我们实现规则#2来改变这种情况—“<em class="ku">使用输入来执行任何必要的计算，将结果存储在缓存中，返回结果。”</em></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="aa6d" class="le lf in la b gy lg lh l li lj">const memoize = (fn) =&gt; {<br/>   let cache = {}<br/>   return (n) =&gt; {<br/>      if (n in cache){<br/>         return cache[n]<br/>      }else{<br/>         let result = fn(n);<br/>         cache[n] = result;<br/>         return result;<br/>      }<br/>   }<br/>}</span></pre><p id="46fd" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">厉害！现在，如果参数<strong class="jy io"> <em class="ku"> n </em> </strong>没有存储在<strong class="jy io"> <em class="ku">缓存</em> </strong>中，<em class="ku"> memoize </em>将执行计算<strong class="jy io"><em class="ku">【fn(n)</em></strong>，<strong class="jy io"> <em class="ku">结果</em> </strong>将存储在<strong class="jy io"> <em class="ku">缓存</em> </strong>中，如下:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="243b" class="le lf in la b gy lg lh l li lj"><em class="ku">/* Given n=5 and result=15, cache will contain the <br/>key:value pair of: */</em></span><span id="0f8e" class="le lf in la b gy lk lh l li lj">"5" : 15</span></pre><p id="e29d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">让我们看看它的实际效果。</p><p id="2a03" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">首先，给定一个函数<em class="ku"> add10 </em></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4760" class="le lf in la b gy lg lh l li lj">const add10 = (n) =&gt; n + 10</span></pre><p id="8405" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我们可以像这样声明</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9f18" class="le lf in la b gy lg lh l li lj">const memoizeAdd10 = memoize(add10);</span></pre><p id="c24d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">使用，<em class="ku"> memoizeAdd10 </em>，我们可能会进行以下函数调用</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6a43" class="le lf in la b gy lg lh l li lj">memoizeAdd10(15); //returns 25<br/>memoizeAdd10(20); //returns 30<br/>memoizeAdd10(25); //returns 35</span></pre><p id="1719" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在这些调用之后，<em class="ku"> memoizeAdd10 </em>的<strong class="jy io"> <em class="ku">缓存</em> </strong>将如下所示:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d727" class="le lf in la b gy lg lh l li lj">{<br/>   "15" : 25,<br/>   "20" : 30,<br/>   "25" : 35<br/>}</span></pre><p id="747a" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果我们称之为</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="42bb" class="le lf in la b gy lg lh l li lj">memoizeAdd10(15); //returns 25 without arithmetic computations</span></pre><p id="40e5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">另一次，不是计算结果，<em class="ku"> memoizeAdd10 </em>将只是潜入<strong class="jy io"> <em class="ku">缓存</em> </strong>，找到键“<strong class="jy io"><em class="ku">15</em></strong>”<strong class="jy io"><em class="ku"/></strong>并返回<strong class="jy io"> <em class="ku"> 25 </em> </strong>，而不必执行任何计算。你可能会想，<em class="ku">“但这只是一个加法函数，几乎不会给我们的机器带来任何压力，谁在乎呢？”当然，但是当算法从简单的加法发展到递归运算时，例如，记忆化可以证明是一个巨大的优势。</em></p><h2 id="ecc7" class="le lf in bd ls lt lu dn lv lw lx dp ly kh lz ma mb kl mc md me kp mf mg mh mi bi translated">解决我们的面试问题</h2><p id="636f" class="pw-post-body-paragraph jw jx in jy b jz mj kb kc kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt ig bi translated">让我们运用目前所学的知识来解决文章开头提到的面试问题。我们可以使用上面定义的相同的memoize函数，只是做了一些调整:</p><figure class="kv kw kx ky gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="498e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在这个例子中，我们改变了3件事。让我们复习一下:</p><ol class=""><li id="4f0e" class="mo mp in jy b jz ka kd ke kh mq kl mr kp ms kt mt mu mv mw bi translated"><strong class="jy io"><em class="ku">【n】</em></strong>➡️<strong class="jy io"><em class="ku">……args”(line 3)</em></strong><strong class="jy io"><em class="ku">—</em></strong>返回函数现在接受未指定数量的参数，可以通过使用数组<em class="ku"> args </em>或<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank"><em class="ku">args</em>object</a>来访问这些参数。</li><li id="89bf" class="mo mp in jy b jz mx kd my kh mz kl na kp nb kt mt mu mv mw bi translated"><strong class="jy io"> <em class="ku"> "cacheKey "(第4、5、6、9行)— </em> </strong>我们声明了一个名为"<em class="ku">" cache key "</em>的变量，它代表了键的名称<em class="ku">(以前为" n") </em>，该键将用于访问缓存或声明一个新的缓存属性。进行这种改变是为了跟踪多个输入。我们通过映射"<strong class="jy io"><em class="ku">【args】</em></strong>"数组并返回一串"<strong class="jy io"><em class="ku">【n】</em></strong>和一个"<strong class="jy io"> <em class="ku"> + </em> </strong>"来形成<strong class="jy io"><em class="ku"/></strong>。比如调用<em class="ku"> memoizeAdd(10，20，30) </em>的时候<em class="ku"/><strong class="jy io"><em class="ku">cacheKey</em></strong><em class="ku"/>会是<em class="ku">“10+20+30+”。</em></li><li id="cdbb" class="mo mp in jy b jz mx kd my kh mz kl na kp nb kt mt mu mv mw bi translated"><strong class="jy io"><em class="ku">【fn(n)】</em></strong>➡️<strong class="jy io"><em class="ku">" args . reduce((ACC，curr) = &gt; fn(acc，curr)，0)——</em></strong>由于<em class="ku"> memoizeAdd </em>可以接受任意未指定数量的参数，为了求所有参数之和我们可以使用<a class="ae jv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"><em class="ku">array . prototype . reduce</em></a><em class="ku"/></li></ol><p id="8329" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">使用我们新翻新的memoize函数，在进行以下函数调用后</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="a7b8" class="le lf in la b gy lg lh l li lj">memoizeAdd(10, 20, 30, 40); //returns 100<br/>memoizeAdd(1, 2, 3, 4); //returns 10<br/>memoizeAdd(5, 10) //returns 15</span></pre><p id="2776" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我们的缓存看起来像这样:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c67e" class="le lf in la b gy lg lh l li lj">{<br/>   "10+20+30+40+" : 100,<br/>   "1+2+3+4+" : 10,<br/>   "5+10+" : 15<br/>}</span></pre><p id="4e14" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果我们再打电话:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="630b" class="le lf in la b gy lg lh l li lj">memoizeAdd(1, 2, 3, 4); //returns 10 without arithmetic computations</span></pre><p id="5589" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">我们的函数<em class="ku"> memoizeAdd </em>将返回10，不需要算术运算。最终，随着更复杂的功能“<strong class="jy io"><em class="ku"/></strong>”这种技术被证明是极其有用的。然而，重要的是要记住什么时候不使用它。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h2 id="60d0" class="le lf in bd ls lt lu dn lv lw lx dp ly kh lz ma mb kl mc md me kp mf mg mh mi bi translated">结论</h2><p id="7188" class="pw-post-body-paragraph jw jx in jy b jz mj kb kc kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt ig bi translated">我们刚刚展示了JavaScript中函数记忆化的强大功能。我希望你喜欢阅读，并会考虑在你的下一个项目中使用这种方法！谢谢！</p></div></div>    
</body>
</html>