<html>
<head>
<title>Explained: All You Need to Know About Asynchronous JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:关于异步JavaScript你需要知道的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explained-all-you-need-to-know-about-asynchronous-javascript-d8ba58a11ed5?source=collection_archive---------14-----------------------#2021-05-11">https://javascript.plainenglish.io/explained-all-you-need-to-know-about-asynchronous-javascript-d8ba58a11ed5?source=collection_archive---------14-----------------------#2021-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="103d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">先说'<strong class="ak"> ay-SIHN-kro-nuhs' JavaScript。</strong></h2></div><p id="9f59" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在阅读本文之前，以下是先决条件:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/4c5a65571e4795b539ee036ef2832a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jEOy9LwiU7droUiM"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><ul class=""><li id="2e63" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated"><a class="ae lo" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=night-owl&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=15px&amp;lh=131%25&amp;si=false&amp;es=1x&amp;wm=false&amp;code=let%2520firstDrink%2520%253D%2520%28%29%2520%253D%253E%2520%257B%250A%2520%2520return%2520new%2520Promise%2520%28%28resolve%252C%2520reject%29%2520%253D%253E%2520%257B%250A%2520%2520%2520setTimeout%28%28%29%253D%253E%257B%250A%2520%2520%2520%2520%2520resolve%28%27coffee%27%29%253B%250A%2520%2520%2520%257D%252C%25201000%29%253B%250A%2520%257D%29%253B%250A%257D%250A%250Alet%2520secondDrink%2520%253D%2520%28%29%2520%253D%253E%2520%257B%250A%2520return%2520new%2520Promise%2520%28%28resolve%252C%2520reject%29%2520%253D%253E%2520%257B%250A%2520%2520%2520setTimeout%28%28%29%253D%253E%257B%250A%2520%2520%2520%2520%2520resolve%28%27tea%27%29%253B%250A%2520%2520%2520%257D%252C%25201000%29%253B%250A%2520%257D%29%253B%250A%257D%250A%250Aasync%2520function%2520firstFunctionHere%28%29%2520%257B%250A%2520%2520let%2520arr%2520%253D%2520await%2520Promise.all%28%255BfirstDrink%28%29%252C%2520secondDrink%28%29%255D%29%253B%250A%250A%2520%2520console.log%28%2560Can%2520I%2520drink%2520%2524%257Barr%255B0%255D%257D%2520or%2520%2524%257Barr%255B1%255D%257D%2520%253F%2560%29%253B%250A%257D%250A%250AfirstFunctionHere%28%29%253B%2520%252F%252F%2520Prints%253A%2520Can%2520I%2520drink%2520coffee%2520or%2520tea%2520%253F" rel="noopener ugc nofollow" target="_blank">JavaScript基础知识</a></li><li id="982e" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">JavaScript中的类</li><li id="6ef6" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">JavaScript中的模块</li><li id="bea1" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/explained-all-you-need-to-know-about-javascript-promises-5d35df9d9919">JavaScript中的承诺</a></li></ul><h1 id="59ac" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">类比</h1><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mv"><img src="../Images/dbb2f690149b0c9339371af9c9736d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eMQyPTSMBGKaxr6r"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@robschreckhise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rob Schreckhise</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e70f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，asynchronous——发音为<strong class="ke io"> ay-SIHN-kro-nuhs </strong>，来源于希腊语<strong class="ke io"> <em class="mw"> asyn- </em> </strong>，意为“<strong class="ke io">不与</strong>”和<strong class="ke io"> <em class="mw"> chronos </em> </strong>，意为“<strong class="ke io">time</strong>”——是一个形容词，描述时间上不协调的事件。</p><p id="3c7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常在构建网站或web应用程序时，我们肯定会遇到异步操作——我们可以在转移到其他任务时等待的操作。例如，从数据库获取数据并向特定网络发出请求。</p><h2 id="f143" class="mx me in bd mf my mz dn mj na nb dp mn kl nc nd mp kp ne nf mr kt ng nh mt ni bi translated">JavaScript是特殊的。为什么？</h2><p id="1f79" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">JavaScript是<strong class="ke io">非阻塞</strong>的，这意味着JavaScript为程序提供了在等待长时间运行的任务完成时继续运行其他代码的机会。这项耗时的任务在后台执行，而其余代码继续执行。JavaScript使用一个<strong class="ke io">事件循环</strong>，它使我们能够在等待异步操作完成的同时执行代码。</p><p id="9fb1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着JavaScript的不断发展，2017年发布的<strong class="ke io"> ES8 </strong>引入了<strong class="ke io"> </strong>一种全新的使用<code class="fe no np nq nr b">async</code>和<code class="fe no np nq nr b">await</code>处理异步操作的方式。<code class="fe no np nq nr b">async</code>和<code class="fe no np nq nr b">await</code> <strong class="ke io"> </strong>在JavaScript中充当了语法糖的角色，它并没有引入任何功能，也没有任何伟大的特性。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/51bb15a5aee134376c2c003e072addda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LqntAGEbR5HqOOrbyXykXQ.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Picture from Google</figcaption></figure><h2 id="5bb5" class="mx me in bd mf my mz dn mj na nb dp mn kl nc nd mp kp ne nf mr kt ng nh mt ni bi translated">什么是<strong class="ak">句法糖</strong>？</h2><p id="9e11" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">简而言之，<strong class="ke io">语法糖</strong>构建在一种编程语言中，它允许增加我们代码的可读性和可伸缩性，同时保持其语法简洁。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nt"><img src="../Images/c08a46607250275029069d42cdae8941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Wy6KOru2ox4k3yV"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mae Mu</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6c52" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">async和await关键字</h1><p id="9629" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">我们使用<code class="fe no np nq nr b">async</code>关键字来编写处理异步任务的函数。</p><p id="cba9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dd3e52d0eae8db97fa95dd2ddb6896fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*71tK6xlK827ELoPF3WbG3A.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">async</strong></figcaption></figure><p id="5bc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe no np nq nr b">async</code>函数总是返回一个承诺，这意味着它符合链接目的。有了<code class="fe no np nq nr b">async</code>，就可以用<code class="fe no np nq nr b">.then()</code>和<code class="fe no np nq nr b">.catch()</code>连锁了。</p><p id="8d9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a6e71a40fa6b32664dfc1d8aea662311.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*mc_RN6h1femkHJEU0X9yrA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of chaining</figcaption></figure><ul class=""><li id="02f9" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">从上面的例子中，我们创建了一个名为<code class="fe no np nq nr b">functionHere()</code>的函数，它返回一个字符串，具体来说是“T10”。</li><li id="02bc" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">然后我们调用该函数并用<code class="fe no np nq nr b">.then()</code>链接它，然后它将把解析后的值打印到控制台上，即“<code class="fe no np nq nr b">I am Alex</code>”。</li></ul><p id="fb53" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么<code class="fe no np nq nr b">await</code>呢？</p><p id="e4da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中，我们通常在代码中将<code class="fe no np nq nr b">async</code>和<code class="fe no np nq nr b">await</code>合并在一起。在上面的例子中，独立的<code class="fe no np nq nr b">async</code>，<code class="fe no np nq nr b">async</code>几乎不能执行这么多。</p><p id="dde0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe no np nq nr b">await</code>返回承诺的解析值，<code class="fe no np nq nr b">await</code>暂停<code class="fe no np nq nr b">async</code>函数的执行，直到给定的承诺被解析。如果一个特定的<code class="fe no np nq nr b">Promise</code>被拒绝，那么<code class="fe no np nq nr b">await</code>将向控制台抛出一个被拒绝值的错误。</p><p id="ff35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个例子，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b92f65f00555ba34d609cc7c05f5510f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*YNKam81pwrLsfZ8mJH-pzg.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">await</strong></figcaption></figure><ul class=""><li id="16a3" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">首先，我们创建了第一个函数，它有一个<code class="fe no np nq nr b">Promise</code>，这个函数的<code class="fe no np nq nr b">setTimeout()</code>带有<code class="fe no np nq nr b">reject</code>或<code class="fe no np nq nr b">resolve</code>。</li><li id="56ad" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">然后，我们用<code class="fe no np nq nr b">async</code>和<code class="fe no np nq nr b">await</code>创建了第二个函数。这就是<code class="fe no np nq nr b">async </code>和<code class="fe no np nq nr b">await</code>发挥作用的地方。</li><li id="361c" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">在我们的<code class="fe no np nq nr b">async</code>函数<code class="fe no np nq nr b">secondFunctionHere()</code>中，我们加入了<code class="fe no np nq nr b">await</code>来暂停代码的执行，直到在<strong class="ke io">一秒</strong>后<code class="fe no np nq nr b">firstFunctionHere()</code>被解决。然后，我们将解析后的值附加到一个名为<code class="fe no np nq nr b">resolved</code>的变量中，然后我们将解析后的值记录在函数中。</li><li id="7878" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">最后，我们调用了名为<code class="fe no np nq nr b">secondFunctionHere()</code>的函数，它将为我们提供解析后的值<code class="fe no np nq nr b">It has been resolved!</code>。</li></ul><h1 id="7bf5" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">2)处理依赖承诺</h1><p id="631f" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated"><code class="fe no np nq nr b">async</code>和<code class="fe no np nq nr b">await</code>的真正吸引力在于处理一系列相互依赖的异步任务。最初我们将使用<code class="fe no np nq nr b">.then()</code>来处理相互依赖的承诺，但是在本文中，我们将学习如何使用<code class="fe no np nq nr b">await</code>来处理它。</p><p id="bae8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个例子，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c4355ab8e39bb25739cc89998f8c0e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*mN1CUCD8ge347O890-wZRA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">promises</strong> depend on one another</figcaption></figure><ul class=""><li id="fe4f" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">首先，我们用<code class="fe no np nq nr b">async</code>关键字做一个函数。</li><li id="71e2" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">在这个函数中，我们将创建一个变量来保存等待承诺的解析值。在这种情况下，我们将<code class="fe no np nq nr b">await firstPromise()</code>保存到<code class="fe no np nq nr b">first</code>变量中，然后我们将记录它。</li><li id="3668" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">之后，我们创建另一个名为<code class="fe no np nq nr b">second</code>的变量，它将保存承诺的解析值<code class="fe no np nq nr b">secondPromise(first)</code>。</li><li id="5317" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">最后但同样重要的是，我们将<code class="fe no np nq nr b">second</code>的值记录到控制台。</li></ul><p id="3c9c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为链接<code class="fe no np nq nr b">.then()</code>函数的替代方法，<code class="fe no np nq nr b">async...await</code>语法使开发人员调试代码变得更加容易，因为它节省了一些输入并提高了代码的可读性。</p><h1 id="3de1" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">3)处理错误</h1><p id="6b89" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">每个人都讨厌错误，但是有一种方法可以测试我们的代码是否有错误。我们可以一起使用<code class="fe no np nq nr b">try...catch</code>和<code class="fe no np nq nr b">async...await</code>关键词。此外，<code class="fe no np nq nr b">try...catch</code>也允许同步和异步代码的共享错误处理。</p><p id="fe8b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个例子，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cdd653efaf4a1cfbc90818e8e40ac5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*fFZOqaUWFn-s8Q-HTKy7xg.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">try…catch</strong></figcaption></figure><ul class=""><li id="bc33" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">在第一个函数中，我们创建了一个错误<code class="fe no np nq nr b">thrown new Error(“Thrown error”);</code>。</li><li id="e822" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">我们用<code class="fe no np nq nr b">async...await</code>创建另一个函数，并使用<code class="fe no np nq nr b">try...catch</code>来捕捉代码中任何潜在的错误。</li><li id="cda2" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">在我们的<code class="fe no np nq nr b">try</code>块中，我们创建了一个变量并用<code class="fe no np nq nr b">await</code>关键字设置了<code class="fe no np nq nr b">functionError()</code>,意思是我们将暂停我们的程序来检查它是被<strong class="ke io">解决了</strong>还是被<strong class="ke io">拒绝了</strong>。</li><li id="804b" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">由于函数会抛出一个错误，那么<code class="fe no np nq nr b">catch</code>块将开始捕捉错误。</li><li id="c3fe" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">最后，我们将它记录到控制台，这将导致一个错误。</li></ul><h1 id="d1d6" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">4)处理独立承诺</h1><p id="3052" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">为什么要处理独立承诺？有时我们会遇到这样一种情况，即多个<code class="fe no np nq nr b">async</code>函数包含多个承诺，这些承诺在执行时并不相互依赖。那我们应该怎么做呢？</p><p id="8510" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个例子，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nx"><img src="../Images/5ca5369983861c8b92a479ff3f7bbe85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQqLIP_LbHEo9RujUHjwvA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">independent promises</strong></figcaption></figure><ul class=""><li id="f7e2" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">在顶部，我们编写了解析值为<code class="fe no np nq nr b">coffee</code>的<code class="fe no np nq nr b">firstDrink()</code>函数和解析值为包含<code class="fe no np nq nr b">setTimeout()</code>的<code class="fe no np nq nr b">tea</code>函数的<code class="fe no np nq nr b">secondDrink()</code>。</li><li id="b3e3" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">然后我们用<code class="fe no np nq nr b">async...await</code>创建另一个函数。然后，我们为<code class="fe no np nq nr b">firstDrink()</code>和<code class="fe no np nq nr b">secondDrink()</code>函数声明每个变量。我们用<code class="fe no np nq nr b">await</code>创造我们的承诺。为什么？<strong class="ke io">因为上面的例子是独立承诺。</strong></li><li id="a303" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">最后，我们将只在最后用<code class="fe no np nq nr b">await</code>进行字符串插值，它将处理独立的承诺，然后返回<code class="fe no np nq nr b">Can I drink coffee or tea ?</code>。</li><li id="7de7" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">如此说来，<code class="fe no np nq nr b">firstDrink()</code>和<code class="fe no np nq nr b">secondDrink()</code>异步操作可以同时运行。</li><li id="ac24" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">通过在函数中使用我们的<code class="fe no np nq nr b">async</code>关键字，我们应该能够利用<strong class="ke io"> <em class="mw">的并发性，</em> </strong>的意思是<strong class="ke io"> <em class="mw"> </em> </strong>在重叠的时间段内运行的多个异步操作。</li></ul><h1 id="566f" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">5)使用Promise.all</h1><p id="2d89" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">利用<strong class="ke io"> <em class="mw">并发</em> </strong>的另一种方法是在处理多个承诺时使用<code class="fe no np nq nr b">await</code>和<code class="fe no np nq nr b">Promise.all([])</code>。通过使用这个，我们可以将一个承诺数组作为参数传递给<code class="fe no np nq nr b">Promise.all([])</code>，这意味着只有当数组中的所有承诺都被解析时，承诺才会被解析。</p><p id="3a61" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe no np nq nr b">Promise.all([])</code>中，每个承诺都有一个解析后的值，它将存储在一个数组中。然而，如果<code class="fe no np nq nr b">Promise.all([])</code>里面的承诺之一失败，那么一切都将失败，这就是所谓的<strong class="ke io"> <em class="mw">失败快</em> </strong>。一旦有一个承诺被拒绝，它不会等待其余的异步操作完成。</p><p id="43dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个例子，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nx"><img src="../Images/5cbba65d379f6ef22a67884bfc07eec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cusspAhqMunyER_p3RnKA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example of <strong class="bd nv">Promise.all([ ])</strong></figcaption></figure><ul class=""><li id="4f52" class="lp lq in ke b kf kg ki kj kl lr kp ls kt lt kx lu lv lw lx bi translated">在上面的例子中，我们创建了两个将返回解析值的函数。</li><li id="5041" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">然后我们用<code class="fe no np nq nr b">async</code>创建一个函数，在这个函数中，我们将创建一个名为<code class="fe no np nq nr b">arr</code>的变量，它将<code class="fe no np nq nr b">await</code>并使用<code class="fe no np nq nr b">Promise.all([])</code>。</li><li id="b821" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">允许我们利用异步性——两个异步任务中的每一个都可以并发处理。</li><li id="aa17" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">然后，我们将一组承诺作为参数传递给<code class="fe no np nq nr b">Promise.all([])</code>，它将返回一个承诺。每个承诺的解析值将存储在一个数组中。</li><li id="6689" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx lu lv lw lx bi translated">最后但同样重要的是，我们通过使用括号符号访问解析的值来将其记录到控制台。我们会得到<code class="fe no np nq nr b">Can I drink coffee or tea ?</code>。</li></ul><h1 id="1894" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">关键外卖</h1><ol class=""><li id="42e1" class="lp lq in ke b kf nj ki nk kl ny kp nz kt oa kx ob lv lw lx bi translated"><code class="fe no np nq nr b">async...await</code>是内置在JavaScript中的语法糖，与使用导致<strong class="ke io"> <em class="mw">回调地狱</em> </strong>的回调相比，它增加了我们代码的可读性。</li><li id="89e9" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx ob lv lw lx bi translated">在我们的<code class="fe no np nq nr b">async</code>函数中使用<code class="fe no np nq nr b">try...catch</code>关键字来处理代码中的错误。</li><li id="a1e9" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx ob lv lw lx bi translated">编写相互依赖而不相互依赖的代码。</li><li id="26d1" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx ob lv lw lx bi translated">在<code class="fe no np nq nr b">async</code>函数中，我们使用<code class="fe no np nq nr b">await</code>来暂停我们代码的执行，直到一个异步任务完成，并且承诺不再挂起，这意味着它已经被解决。</li><li id="de33" class="lp lq in ke b kf ly ki lz kl ma kp mb kt mc kx ob lv lw lx bi translated">通过使用允许异步操作同时发生的<code class="fe no np nq nr b">async</code>函数来利用并发性。</li></ol><h1 id="51b0" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">结论</h1><p id="fd1a" class="pw-post-body-paragraph kc kd in ke b kf nj jo kh ki nk jr kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">太好了！您已经到了本文的结尾，这就是您需要了解的关于JavaScript中异步性和<code class="fe no np nq nr b">async...await</code>用法的全部内容。你从这篇文章中学到了什么吗？希望你觉得这篇文章有用，谢谢你的阅读。</p><p id="b012" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多阅读:</p><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/iterators-in-javascript-you-should-know-as-a-newbie-c1bf23fb50b2"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">新手应该知道的JavaScript迭代器</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">迭代器平滑了我们的代码，增加了可读性</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oo l"><div class="op l oq or os oo ot li of"/></div></div></a></div><p id="9456" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">通过</em><a class="ae lo" href="https://www.linkedin.com/in/eugene-goh-5236241a9/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mw">LinkedIn</em></strong></a><em class="mw">和</em><a class="ae lo" href="https://twitter.com/EugeneGohHere" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mw">Twitter</em></strong></a><strong class="ke io"><em class="mw">与我联系。</em> </strong></p><p id="be5a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">更多内容请看</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a></p></div></div>    
</body>
</html>