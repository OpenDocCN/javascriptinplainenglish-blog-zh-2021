<html>
<head>
<title>How to Use ImmerJS to Fix Software Development Pain Points</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用ImmerJS修复软件开发痛点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fix-a-pain-point-like-immerjs-e4a4e4a63441?source=collection_archive---------8-----------------------#2021-10-26">https://javascript.plainenglish.io/fix-a-pain-point-like-immerjs-e4a4e4a63441?source=collection_archive---------8-----------------------#2021-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5317" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">只需修改当前树</em> <a class="ae kj" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> Immer </em> </a> <em class="ki">即可创建下一棵不可变状态树。</em></p><p id="2578" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">软件都是为了减少人们的痛点。我们可以看到软件使我们周围的生活变得比以前更容易。</p><p id="eab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是软件开发者的痛点呢？</p><p id="ce35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时，一个出色的抽象会得到软件开发人员的喜爱。</p><p id="4c1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank"> ImmerJS </a>就是其中之一。Immer是2019年“年度突破”React开源奖和“最具影响力贡献”JavaScript开源奖的'<em class="ki">获得者。</em>'</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/b741e00c809e2fa04d8468dc74f26f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hMFMqWXC2dK5-mkM"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae kj" href="https://unsplash.com/@karishea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kari Shea</a> on <a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h2 id="495d" class="lh li in bd lj lk ll dn lm ln lo dp lp jv lq lr ls jz lt lu lv kd lw lx ly lz bi translated">痛点</h2><p id="7661" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">不变性是一个增加代码库整体健壮性的概念。但是它有它的痛点。</p><p id="6312" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看可变和不可变数据结构之间的例子。</p><pre class="kl km kn ko gt mf mg mh mi aw mj bi"><span id="561a" class="lh li in mg b gy mk ml l mm mn">const user  = {<br/>  name: 'John Doe',<br/>  likes: 45,<br/>}</span><span id="cc87" class="lh li in mg b gy mo ml l mm mn">user.likes = user.likes + 1</span></pre><p id="38da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相对</p><pre class="kl km kn ko gt mf mg mh mi aw mj bi"><span id="1687" class="lh li in mg b gy mk ml l mm mn">const user  = {<br/>  name: 'John Doe',<br/>  likes: 45,<br/>}</span><span id="5127" class="lh li in mg b gy mo ml l mm mn">const updatedLikes = user.likes+1<br/>const updatedUser = {<br/>  ...user,<br/>  likes: updatedLikes<br/>}</span><span id="eba4" class="lh li in mg b gy mo ml l mm mn">console.log(user, updatedUser)</span></pre><p id="9167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们包装了一个携带突变的新物体。</p><p id="aa60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着对象的大小和复杂性的增加，上面的例子会变得复杂。</p><p id="7dc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您需要快速了解不变性，可以看看下面的文章。</p><div class="mp mq gp gr mr ms"><a href="https://karthickragavendran.medium.com/understanding-immutability-d00ed097e020" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">理解不变性</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">在面向对象和函数式编程中，不可变对象是这样一种对象，它的状态在它…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">karthickragavendran.medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ku ms"/></div></div></a></div><h2 id="f6fd" class="lh li in bd lj lk ll dn lm ln lo dp lp jv lq lr ls jz lt lu lv kd lw lx ly lz bi translated">不可变的. js</h2><p id="f81e" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">Immutable.js提出了一个解决方案。</p><p id="ae3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不可变的. js提供了我们可以安全使用的数据结构，而不是像上面的例子那样使用JavaScript对象文字并重新创建一个对象。</p><pre class="kl km kn ko gt mf mg mh mi aw mj bi"><span id="9b56" class="lh li in mg b gy mk ml l mm mn">const { <strong class="mg io">Map</strong> } = require('immutable');</span><span id="0cb1" class="lh li in mg b gy mo ml l mm mn">const <strong class="mg io">user</strong> = Map({ name: 'John Doe', likes: 45, });<br/>const <strong class="mg io">updatedUser</strong> = <strong class="mg io">user</strong>.set('likes', user.get('likes')+1);</span><span id="3984" class="lh li in mg b gy mo ml l mm mn">user.get('likes') + ' vs. ' + updatedUser.get('likes'); <br/>// 45 vs. 46</span></pre><p id="2750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使<code class="fe nh ni nj mg b">user</code>对象变得太复杂，方法也会很简单。</p><p id="8a7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些由Immutable.js给出的数据结构被<strong class="jm io"> <em class="ki">优化</em> </strong>以提高性能，就像实现开箱即用的结构共享一样。</p><h2 id="92f6" class="lh li in bd lj lk ll dn lm ln lo dp lp jv lq lr ls jz lt lu lv kd lw lx ly lz bi translated">ImmerJS:鱼和熊掌不可兼得。</h2><p id="2edf" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">如果我们可以使用默认的JavaScript数据结构，并以更简单的方式执行更新，会怎么样？</p><p id="a9fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ImmerJS带着一个函数<code class="fe nh ni nj mg b">produce</code>出现了。它的工作原理如下:</p><pre class="kl km kn ko gt mf mg mh mi aw mj bi"><span id="da70" class="lh li in mg b gy mk ml l mm mn">cosnt updatedObj = produce(obj, draft =&gt; {<br/>  /* update the draft in a mutable way. */<br/>})</span></pre><p id="4dff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">produce函数有两个参数</p><ul class=""><li id="6d2c" class="nk nl in jm b jn jo jr js jv nm jz nn kd no kh np nq nr ns bi translated"><strong class="jm io">状态</strong>需要更新。</li><li id="1ed6" class="nk nl in jm b jn nt jr nu jv nv jz nw kd nx kh np nq nr ns bi translated">一个<strong class="jm io">回调</strong>提供一个<strong class="jm io">草稿版本</strong>的状态。我们可以修改draft对象，就好像它是可变的一样，ImmerJS会相应地生成一个新对象。</li></ul><p id="adc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，用ImmerJS看同一个例子。</p><pre class="kl km kn ko gt mf mg mh mi aw mj bi"><span id="ed9d" class="lh li in mg b gy mk ml l mm mn">const { <strong class="mg io">produce</strong> } = require( "immer")</span><span id="ee2a" class="lh li in mg b gy mo ml l mm mn">const user = { name: 'John Doe', likes: 45, }</span><span id="3b98" class="lh li in mg b gy mo ml l mm mn">const updatedLikes = user.likes+1<br/>const updatedUser = produce(user, <strong class="mg io">draft =&gt; {<br/>  draft.likes = updatedLikes<br/>}</strong>)</span><span id="3f24" class="lh li in mg b gy mo ml l mm mn">console.log(user, updatedUser)</span></pre><p id="25ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这有多简单？</p><p id="bbfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也不需要知道对象的完整结构来处理它。上面的例子知道对象有<code class="fe nh ni nj mg b">likes</code>属性，它需要被更新。我们不关心物体的其他部分。</p><p id="ad0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ImmerJS利用<a class="ae kj" href="http://raganwald.com/2019/01/14/structural-sharing-and-copy-on-write.html" rel="noopener ugc nofollow" target="_blank">结构共享</a>，一种<a class="ae kj" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank"> <em class="ki">写时复制</em> </a>机制，结合<a class="ae kj" href="https://hackernoon.com/introducing-javascript-es6-proxies-1327419ab413" rel="noopener ugc nofollow" target="_blank"> JavaScript代理</a>使用。</p><h2 id="506e" class="lh li in bd lj lk ll dn lm ln lo dp lp jv lq lr ls jz lt lu lv kd lw lx ly lz bi translated">实际应用</h2><p id="8e76" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">函数式编程中的reducer模式接受一个状态和动作，并返回更新后的状态。</p><p id="7d05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还原器曾经是使用redux的难点。它也容易出错。如果我们重新创建一个复杂的对象，包括一个小的变化。</p><p id="30cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看典型减速器的例子。</p><p id="eb2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">不带浸没的减速器:</strong></p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Reducer without immer</figcaption></figure><p id="5d54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要使用spread操作符从头开始重新组织状态对象，以返回一个新的实例。</p><p id="c70b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">与ImmerJS相同的减速器:</strong></p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3014" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在已经大大简化了。这就是ImmerJS。</p><p id="3a88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你。下次见。</p><p id="951f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae kj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>