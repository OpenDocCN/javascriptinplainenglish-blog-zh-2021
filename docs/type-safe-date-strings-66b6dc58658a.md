# TypeScript:键入安全日期字符串

> 原文：<https://javascript.plainenglish.io/type-safe-date-strings-66b6dc58658a?source=collection_archive---------0----------------------->

![](img/f1ed58c5b4dcd8b047409eaf7680ecb8.png)

Photo by [Debby Hudson](https://unsplash.com/@hudsoncrafted?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

最近，TypeScript 4.1 发布了，随之而来的是**模板文字类型**。

模板文字类型不仅让开发人员有机会声明某个变量应该是字符串类型，而且还允许开发人员声明字符串的格式。

## 用例是什么，你如何实现它？

如果你在问自己上面的问题，你很幸运！本文旨在展示一个这样的例子！看哪；键入安全日期字符串！

因此，让我们来看看如何实现这一点的可能实现。

让我们首先假设我们的应用程序有两个基本日期字符串，DateYMString 和 DateYMDString。这些分别在格式`YYYY-MM`和`YYYY-MM-DD`上。我们假设有效年份是 1900 年到 2099 年之间的任何年份。虽然这个约束现在看起来有点武断，但是我将在示例之后解释为什么这些界限确实是必要的。

我们将基于更小的模块化模板文字类型来构造我们的类型`DateYMString`和`DateYMDString`。让我们首先考虑我们最终想要的类型:

```
export type DateYMString = `${YYYY}-${MM}`;
export type DateYMDString = `${DateYMString}-${DD}`;
```

虽然您以前可能没有见过这种类型的脚本语法，但是这个例子应该足够简单。我们已经声明它们由我们尚未声明的`YYYY`(年)、`MM`(月)和`DD`(日)模板文字类型组成。

# 基本类型

那么这些类型看起来怎么样呢？我们知道它们每个都由数字组成，但是我们还没有任何指定数字的类型。先说最基本的:任意数。

为了尽量接近正则表达式的语法，我们将类型`d`声明如下:

```
type d = 1|2|3|4|5|6|7|8|9|0;
```

注意`d`在它的类型声明中使用实际的数字，而不是包含数字的字符串。在实现时，我发现这并没有什么不同，尽管我也明白可以进行一个论证来显式地将它们声明为字符串。我让读者来决定是否用或不用`"`来声明每个数字，以表示它们的严格用法。对于这个例子，我们将保持原样。

声明了基本数字类型后，我们可以如下声明`YYYY`:

```
type YYYY = `19${d}${d}` | `20${d}${d}`;
```

当声明一个 YYYY 类型的变量不是 1900–2099 范围内的字符串时，我们现在会得到一个类型错误。

接下来，我们要声明`MM`。我们希望月份数字始终为两位，并且在范围`01`到`12`内。为此，我们声明如下:

```
type oneToNine = 1|2|3|4|5|6|7|8|9;type MM = `0${oneToNine}` | `1${0|1|2}`;
```

我们想要重用下面的`oneToNine`,所以我们将它声明为自己的类型。同样，声明一个类型为`MM`的变量，当它不是一个值在 01 和 12 之间的字符串时，会产生错误。

对于我们最终的基本模板文字类型，我们将`DD`声明如下:

```
type DD = `${0}${oneToNine}` | `${1|2}${d}` | `3${0|1}`;
```

一个热心的读者现在会注意到，如果我们把`DD`和`MM`按原样组合，无效的日期可能会变成有效的类型。例如 2 月 31 日。

这是正确的。更复杂的类型可能能够检测到这一点，但是本文仅仅是对常见用例的模板文字类型的介绍，当然编写足够复杂的类型来检测所有无效日期不在此范围之内。也许改天吧。当然，我甚至不确定这是否可能，因为尽管模板文字字符串对于类型来说非常复杂，但它们不如正则表达式强大。

# 决赛成绩

让我们回到开始的地方:

```
export type DateYMString = `${YYYY}-${MM}`;
export type DateYMDString = `${DateYMString}-${DD}`;
```

随着`YYYY`、`MM`和`DD`的声明，我们看到我们已经完成了声明。

我们可以通过声明以下变量来测试我们的类型:

```
const validYM: DateYMString = "1987-03";const invalidYM: DateYMString = "1999-23";const validYMD: DateYMDString = "2004-03-19";const unfortunatelyValidYMD: DateYMDString = "1977-02-30";const invalidYMD: DateYMDString = "1988-01-32";
```

我们看到两个无效的日期字符串出现了类型错误。不幸的是，如上所述，我们还可以看到`unfortunatelyValidYMD`没有发出类型错误警告，这是这个实现的一个弱点。

但至少我们引入了一定程度的类型安全，至少在字符串本身的格式方面，这对于保持应用程序的一致性非常重要。

# 而且

讨论并没有到此结束。记忆力好的读者可能想知道为什么我们如此限制年份，而好奇的读者可能想进一步发展这一想法，为包含时间和日期的字符串创建类型检查。

如果您将`YYYY`的定义改为如下，您应该能够立即理解原因:

```
type YYYY = `${d}${d}${d}${d}`;
```

我们现在看到在`DateYMString`的声明中有一个错误，声明如下:

```
Expression produces a union type that is too complex to represent.(2590)
```

原来 TypeScript 只处理最多有 100，000 种不同类型的联合类型。

出于同样的原因，我们也知道在 DateYMDString 的末尾添加字符串类型会很快达到这个上限。

那么这种情况的解决方案是什么呢？

好问题。

老实说，我不确定。DateYMDString 涵盖了我需要它来涵盖的案例，并且目前正在我正在开发的一个生产应用程序中使用。

我可以想象一个类对象，其中日期和时间是具有不同类型检查的不同字段，但是问题变成了如何创建这些对象。如果将它们从单个字符串中分离出来，然后再转换成新的类型，那么肯定没有现实的方法来确保类型的一致性。如果谁有什么好的建议，请在评论里留下。

# 结论

模板文字类型是 TypeScript 的一个令人兴奋的新增功能，它的用例可能无法立即识别。本文旨在展示一个这样的用例，对于今天的 JavaScript 生态系统的好的日期库来说，这可能不是非常必要的，但是至少在我们的项目中，我们发现了这些**类型的安全日期字符串**的良好用途，如果您觉得它们对您的项目也有用，请不要犹豫使用它们。