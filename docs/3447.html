<html>
<head>
<title>The Benefits and Drawbacks of Adopting TypeScript: A 20-Year Veteran Developer’s Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用TypeScript的利与弊:一个20年经验丰富的开发人员的观点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-main-benefits-and-drawbacks-of-adopting-typescript-in-your-project-34952800059e?source=collection_archive---------12-----------------------#2021-07-12">https://javascript.plainenglish.io/the-main-benefits-and-drawbacks-of-adopting-typescript-in-your-project-34952800059e?source=collection_archive---------12-----------------------#2021-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="72dc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">当我加入一个新的团队和项目时，一个问题反复出现——我们应该采用TypeScript吗？我们来看看利弊。</h2></div><p id="2126" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“我们应该采用打字稿吗？”</p><p id="d006" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着TypeScript越来越受欢迎，当我加入一个新项目，从零开始选择工具和技术时，这个问题反复出现。因此，这里有一个最新的顶层，并且更深入地查看在您的项目中采用TypeScript的好处和缺点。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/32d5ecde4ca1b9273fe5a601ac197dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GqFk9_ReN31td6sB"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Photo by <a class="ae lp" href="https://unsplash.com/@kitera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kitera Dent</a> on <a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6ce2" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">打字优惠</strong></h1><ul class=""><li id="a511" class="mi mj in ke b kf mk ki ml kl mm kp mn kt mo kx mp mq mr ms bi translated">与文本编辑器更好的集成</li><li id="ff69" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">类型帮助自己记录代码</li><li id="b2e2" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">重构会更快</li><li id="7796" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">编译前捕捉错误</li><li id="16e8" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">可以编译成目标ES版本</li><li id="4a88" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">尽早获得JS的未来特性</li></ul><h1 id="ada4" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated"><strong class="ak">打字稿的弊端</strong></h1><ul class=""><li id="7a6f" class="mi mj in ke b kf mk ki ml kl mm kp mn kt mo kx mp mq mr ms bi translated">单元测试不再是即时的</li><li id="e9bf" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">编译时间会增加</li><li id="2b33" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">构建管道需要更长时间</li><li id="b08c" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">要雇佣的开发人员较少</li><li id="5cf8" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">非TS库需要类型</li><li id="90a5" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">固定版本类型以获得有效的编译</li><li id="b052" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">Typescript充满了令人困惑的怪癖</li><li id="2e8a" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">仅在编译时检查类型</li><li id="a23e" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">不会降低bug密度</li><li id="5700" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">将社区驱动的JS之路留给微软锁定</li><li id="f4fb" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">动态类型实际上很有用</li><li id="8197" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">需要编写更多的代码</li><li id="216f" class="mi mj in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">可怜的和不可理解的错误</li></ul><h1 id="93b2" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">利益</h1><h2 id="292b" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">与文本编辑器更好的集成(优势)</strong></h2><p id="bc33" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">一旦设置了TypeScript，大多数流行的文本编辑器都有可用的插件。Visual Studio代码，Atom，Webstorm等。下面的图片来自微软的Typescript安装教程。在第一幅图中，我们可以看到智能感知模式中所有可用的控制台方法，现在用类型进行了注释，以帮助您选择正确的方法。第二个图像显示了调用函数时的参数帮助，它显示了必需的和可选的参数类型。整洁！</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nn"><img src="../Images/90862f79c48ecca0efd088db239f9516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYonGhsmrp1QVBdIklM-Lg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Improvements to IntelliSense in VS Code</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi no"><img src="../Images/81e660bd6439101266f9dc90bba90cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3pAxQWvYyZWt7Y7hlJ7EA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Help with parameters</figcaption></figure><h2 id="b6af" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">类型帮助自我记录代码(优势)</strong></h2><p id="5257" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated"><a class="ae lp" href="https://dev.to/rocambille/how-typescript-helped-me-to-self-document-my-react-project-3ab5" rel="noopener ugc nofollow" target="_blank">这里的</a>是静态类型如何帮助自文档化代码的一个非常清晰简单的例子。使用像JavaScript这样的松散类型语言的一个问题是，你永远不能完全确定每个变量的用途，以及什么应该存储在哪里。你可能会说这是使用JavaScript的一个优势，但是当你开始借用结构来存储不需要的东西时，这可能会导致难以发现的错误。TypeScript可以防止这种情况，并允许您使用接口来正确定义结构。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi np"><img src="../Images/101e76b8d4dfef6837629243e22e54d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrUpboAuq9VxiOfdnePW2Q.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Only an object that implements the RouteInterface can be added to the routes array</figcaption></figure><h2 id="f512" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">重构更快(好处)</strong></h2><p id="320f" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">重构是开发过程的一部分。保持代码的干净、高效和整洁有助于你的同事和六个月后的你理解代码，这是不应该避免的。花时间进行重构会给以后的开发时间带来好处。然而，这也是一个昂贵的过程，任何额外的帮助只能是一件好事。在这里，我们可以看到安装TypeScript时出现的其他重构选项，在VS代码中，我可以右键单击变量或函数声明，并为我提取接口。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nq"><img src="../Images/7a4bccb2f873b34227ee4f7fc27c529a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gV3zOhjL3Joft8ZwKNvg4A.gif"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Additional refactoring options available in VS Code thanks to the adoption of TypeScript</figcaption></figure><h2 id="e766" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">编译前捕捉bug(受益)</strong></h2><p id="61c1" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">这里有一个基本的例子，说明了在使用TypeScript时，编译器是如何捕捉到某些bug的，从而避免部署到测试中，甚至可能滑入生产中。互联网上有各种各样的估计，可以通过TypeScript捕获预编译错误的百分比，有些数字高达15%。从我使用TypeScript的经验和bug密度没有减少的事实来看，我不相信这是事实(稍后解释)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nr"><img src="../Images/facd329c2676eaf288a90d7760f6fdb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB645irqkGPBPwHC13LdrQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Incorrect parameters can no longer be passed once TypeScript is adopted</figcaption></figure><h2 id="e80e" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">可以编译成目标ES版本(受益)</strong></h2><p id="c045" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">一旦用TypeScript设置了项目，它就有了一个可以配置选项的. tsconfig文件。其中之一就是<code class="fe ns nt nu nv b">target</code>。</p><p id="59c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将此设置为<code class="fe ns nt nu nv b">ES6</code>是该设置的一个常见值，因为所有现代浏览器都支持<code class="fe ns nt nu nv b">ES6</code>标准。但是，如果您想支持较旧的浏览器，您可以将这个值更改为ES标准的早期版本，代码将向下编译成JavaScript，与实现目标标准的浏览器配合良好。如果您的项目中有这种需求，TypeScript将不再需要编写特定于浏览器的代码。</p><h2 id="a051" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">提前获得JavaScript的未来特性(优势)</strong></h2><p id="a456" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">我记得这是TypeScript在2012年末首次实现时的一个非常大的卖点。JavaScript的ECMAScript (ES)标准进展有点慢，因为它们是社区驱动的。要对ES做出改变，必须得到大多数社区成员的同意，然后宣布，浏览器也必须开始解释这些特性。这可能需要一段时间。类就是一个例子。2012年，JavaScript开发人员知道类很快就会出现，并且会对他们有用，但是直到它发布后才能使用这个特性。通过采用TypeScript，开发人员可以使用类，然后TypeScript编译器可以简单地将代码编译成向后兼容的JavaScript。这一点现在不那么突出了，ES已经大大加快了速度，Babel解决了这类问题，允许JavaScript开发人员在他们的开发流程中添加任何他们能想到的语法特性。</p><h1 id="c5c9" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">缺点</h1><h2 id="1f5e" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">单元测试不再是即时的(缺点)</strong></h2><p id="174d" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">虽然TypeScript经常被认为可以捕捉没有它就会被忽略的错误，但是单元测试是最好的选择。TDD和单元测试减少了代码库中的bug密度，应该在某个阶段成为项目默认工作流的一部分。TypeScript在这里起了作用，通过在单元测试可以运行之前添加一个transpiling步骤，那些单元测试的运行不再是一个瞬时的过程。我希望我的测试能够立即运行，我希望进行修改并快速再次运行它们。Transpiling可能只会给代码-测试-代码-测试工作流增加一点点延迟，但是这一点点延迟很快就会变得令人讨厌。</p><h2 id="2a3a" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">编译时间增加(缺点)</strong></h2><p id="885c" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">单元测试不再是即时的，这是一个相似且紧密相关的缺点；我运行项目的时间会稍微长一点。在React中，我可能会有一个热重新加载工作流，但这也会因为transpiling步骤而变慢。使用热重新加载和TypeScript设置，我更改一行代码或标记，点击save，并在屏幕更新之前忍受非常轻微的延迟。这可能看起来不多，但快速的工作流程鼓励快速开发，所以我不希望这里有任何放缓。</p><h2 id="7f53" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">构建管道需要更长时间(缺点)</strong></h2><p id="e05f" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">传输步骤引入的另一个问题是等待构建管道完成的时间更长。生产构建需要更长的时间，当您有一个构建队列和一群等待的开发人员时，这可能是昂贵的。过多的这种延迟会导致构建超时，并且熟悉你最喜欢的Git解决方案中的<code class="fe ns nt nu nv b">rerun</code>按钮。</p><h2 id="d9cd" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">要雇佣的开发人员较少(退税)</strong></h2><p id="a90e" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">我经常看到这被列为TypeScript的正面。<br/><strong class="ke io"><br/></strong>“TypeScript是JavaScript，你可以雇佣任何一个JavaScript开发者来做TypeScript，学习曲线很浅很平滑”(或者类似这样的意思)</p><p id="4302" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这完全不是我的经历。在使用TypeScript完成了几个大型项目之后，让JavaScript开发人员参与进来，然后让他们花一天时间在TypeScript文档上，并期望他们没有任何问题，这通常不是事情的解决方式。不断地查看TypeScript文档中的每一个小细节，搜索难以理解的错误，在整个代码库中乱放关键字<code class="fe ns nt nu nv b">any</code>,这是我作为一个JavaScript开发人员“运行和射击”TypeScript项目的经历。因此，理想情况下，你会想为你的项目雇佣一个有经验的TypeScript开发人员，而你刚刚减少了42.3%的人才库，这是一个巨大的损失。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nw"><img src="../Images/06c743bcd707cd06d11af9881206352b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oz3W8hBrG2PZIlZ9SsiCYA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk"><a class="ae lp" href="https://insights.stackoverflow.com/survey/2020#most-popular-technologies" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/survey/2020#most-popular-technologies</a></figcaption></figure><h2 id="edbf" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">非TS库需要类型(退税)</strong></h2><p id="f595" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">如果您在项目中使用JavaScript，那么您很有可能会使用像npm或yarn这样的包管理器，并利用丰富的可用库使开发人员的工作变得更加轻松。如果使用TypeScript，JavaScript库不一定附带类型。通常，要让用JavaScript编写的库在TypeScript项目中工作，会发生两种情况之一。</p><p id="7800" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1.该库的开发人员事后才开发出一个带有自己版本的类型包，它们通常非常古怪，很少得到支持。在类型更新之前，库本身可以看到一系列的发布。</p><p id="1579" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.一些不在库上工作的人想要类型，所以他们自己写了一个类型库，并把它添加到npm中，然后当JavaScript库更新时，从不更新它。所以你正在使用一个旧的类型库，并以令人挠头的、几乎无法解决的错误而告终。</p><h2 id="f74f" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">锁定版本类型以获得工作编译(缺点)</strong></h2><p id="8d1b" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">我曾经遇到过这种情况，在react项目中，一个大型团队在一个相当大的代码库上有许多npm依赖项。大约有25个类型库被用来容纳这些包。以默认方式保留依赖关系的版本……类似于<code class="fe ns nt nu nv b">^4.0.1</code>的东西是一种告诉包管理器您将接受任何非破坏性变更的小更新的方式。这是更可取的，因为小错误甚至安全问题经常在这些包中得到修复，而次要版本被升级。一个开发人员将一个特性与一个颠簸的版本合并，这对他们来说很好，然后当你最终取出更新的<code class="fe ns nt nu nv b">package.json</code>并试图重新运行你的新代码时，你将面临编译错误。您会发现这要么是因为类型库不同步，要么是JavaScript库有了新的更改，导致TypeScript编译器出错。最终，您可以通过锁定版本号并删除类型库或包本身的<code class="fe ns nt nu nv b">package.json</code>中的<code class="fe ns nt nu nv b">^</code>符号来解决这个问题。我不想这么做，我想要最新版本。</p><h2 id="0159" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak"> Typescript充满了令人困惑的怪癖(缺点)</strong></h2><p id="e8de" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">我进入TypeScript的旅程是一个后端开发人员的旅程。十多年的C#和Java。许多其他开发人员来自前端或JavaScript学习路径，因此TypeScript对他们来说应该不太自然，我可能是真正应该欣赏TypeScript附带的类型系统的程序员之一。但我不这么认为，TypeScript并没有使JavaScript成为强类型，它只是增加了一些规则，使它有时表现得像一种强类型语言，但在其他情况下，会让您感到困惑，并想知道为什么TypeScript中的怪异之处会是这样。这里有几个例子。</p><p id="79f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">额外的属性是可以的…取决于你的语法</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nx"><img src="../Images/66fdf38cf76693c9864659ed1f42ffd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwDvox85RDhFbbTbwwsBLg.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Valid TypeScript, no problems here</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ny"><img src="../Images/77e193d142a5e6f80cc527f808e20995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okIgpmVnUUJTl6z-E7kftA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">This doesn’t work with inline objects for some reason</figcaption></figure><p id="9f19" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以将任何旧对象传递给需要特定类型的函数，只要它具有正确的属性。那么这是不是强类型的…嗯，都不是。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nz"><img src="../Images/9dc11f09b4a7e1a30c671c2576951ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rtf5QssSmbHosoMM8yE-Ig.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Valid TypeScript, use a Cat as a Dog, all good</figcaption></figure><p id="8d2d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以使用<code class="fe ns nt nu nv b">|</code>联合符号，来确定一个变量的类型。但是要小心。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi oa"><img src="../Images/77863c939cb56b8f323a6ce67122c50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWw0L7_o4NiFT3A78xvY1w.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Nice use of a union … the bark attribute is accessible without casting</figcaption></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ob"><img src="../Images/867466870a1acadcbcd961226e388eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vflc_-vAgcn7WQ0DzQ2T9A.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Invalid use of a union</figcaption></figure><h2 id="caf6" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">仅在编译时检查类型(退税)</strong></h2><p id="7012" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">这是一个很重要的区别。在运行时，没有可用的类型检查。TypeScript被转换成JavaScript，这时类型安全就不复存在了。网络调用、特定于平台的API、非类型库没有类型安全。编写JavaScript时，您必须编写代码来检查特定的类型(使用TypeScript的一个常见原因是能够从代码库中删除这些代码)。使用TypeScript，您依赖编译器为您完成这项工作，但它无法检查所有内容。当然，您可以编写与JavaScript类似的类型检查代码来获得某种运行时安全性，但是使用TypeScript的初衷是什么呢？解释语言，无法在运行时检查类型。</p><h2 id="e9a9" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">不降低bug密度(缺点)</strong></h2><p id="b935" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">这里有深入看这个<a class="ae lp" href="https://labs.ig.com/static-typing-promise" rel="noopener ugc nofollow" target="_blank">。静态类型化不会降低项目中的总体bug密度。</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi oc"><img src="../Images/a9433b24701473e0934dd79213c856be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSkpo-_8X9HjeSk484GpSQ.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Low bug density for a non statically typed language.</figcaption></figure><h2 id="f6f4" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">离开微软锁定的社区驱动的JS路径(缺点)</strong></h2><p id="0f1a" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">JavaScript现在是一个社区主导、社区驱动的项目。自从引入ES标准以来，在发布之前，会对变更进行讨论和广泛协作。如果你对某个你想看的功能有强烈的感觉，你可以投稿。</p><p id="ded2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然TypeScript已经被微软贴上了“开源”的标签，但在这种情况下，这仅仅意味着你可以浏览和阅读回购协议。但是你不会得到任何改变或建议。JavaScript社区也可能走上与微软不同的道路……所有那些数以千计的非类型脚本库也将随之而来。通过选择TypeScript，你承担了额外的风险，并且你接受了被一个公司所束缚，这个公司对特定的技术做了所有的决定。</p><h2 id="3686" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">需要编写更多代码(缺点)</strong></h2><p id="ce48" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">另一件很难进行精确测量或度量的事情。但是从我自己的经验来看，你至少要多写20%的代码。我真的很喜欢代码库是干的，并且在删除重复和不必要的逻辑中找到很多乐趣。代码库中的代码越少，存在bug的代码就越少。TypeScript需要接口、类型、转换和泛型来编译。这是无法避免的，如果没有TypeScript设置，您将不得不编写额外的代码。</p><h2 id="447c" class="my lr in bd ls mz na dn lw nb nc dp ma kl nd ne mc kp nf ng me kt nh ni mg nj bi translated"><strong class="ak">不良和不可理解的错误(缺点)</strong></h2><p id="bffb" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">我从事商业开发已经超过20年了。我用过很多不同的技术。从运行在DVD播放器上的解释器代码，到编译成只能在Windows上运行的面向对象代码，移动应用程序，以及一大堆来来去去的网络技术。没有一个比打字稿更让我困惑的错误了。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi od"><img src="../Images/48987923cff0213cb85e05e3c5ee0341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AED7FaH0mF40CZlf4WhFdA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Obvious … isn’t it?</figcaption></figure><p id="86d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当新的开发人员加入团队时，除非他们已经做了几年的TypeScript开发，否则会出现相同的模式，在文档上浪费时间，系统中几乎每个可能的错误都是堆栈溢出的问题，因为它们以看似不正确或令人困惑的方式弹出。</p><h1 id="1b59" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">我的新项目会采用TypeScript吗？</h1><p id="242a" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">简而言之，没有。</p><p id="363b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我看来，缺点仍然远远大于好处，我从来没有喜欢过使用类型脚本，我也没有看到我所列出的任何一个好处是我不能缺少的，或者是我可以用其他非类型脚本的方式解决的。</p><p id="8ad2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容尽在</em><a class="ae lp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>