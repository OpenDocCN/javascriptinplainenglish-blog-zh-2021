<html>
<head>
<title>JavaScript Features Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的JavaScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/built-in-javascript-features-and-methods-every-developer-should-know-1205b689d65c?source=collection_archive---------28-----------------------#2021-05-17">https://javascript.plainenglish.io/built-in-javascript-features-and-methods-every-developer-should-know-1205b689d65c?source=collection_archive---------28-----------------------#2021-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a517" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">为你的下一个JavaScript项目使用这些提示和技巧</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/265fcd224770b669a8541963c4d5ef31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IDeBb8w345MmB6iv.jpg"/></div></div></figure><p id="b01b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript诞生之前，网页只是静态的，缺乏动态行为的能力。然而，在1995年，网景公司的人决定解决这个问题，并开始在他们专有的网络浏览器中添加一种脚本语言。相反，他们想出了一种全新的编程语言，我们现在称之为JavaScript。</p><p id="d7b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，超过97%的网站使用JS作为他们的客户端编程语言，它可以说是现存的最流行的编程语言。自从1997年成为EMCA标准以来，这种语言已经有了许多改进和更新；包括许多内置的特性和方法。虽然开发人员可能熟悉常用的操作符，如<code class="fe kv kw kx ky b">.forEach()</code>、<code class="fe kv kw kx ky b">.map()</code>、<code class="fe kv kw kx ky b">.sort()</code>和递增/递减(<code class="fe kv kw kx ky b">++</code> / <code class="fe kv kw kx ky b">--</code>)操作符，但是有太多的这些功能有助于代码优化。</p><p id="a13f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有几个是每个开发者都应该知道的。</p><h2 id="3e67" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">逗号运算符</h2><p id="10b3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">逗号运算符(<code class="fe kv kw kx ky b">,</code>)从左到右计算其操作数，并返回最后一个操作数的值。它允许创建一个复合表达式，其中计算多个表达式，最终值是其成员表达式最右边的值。逗号操作符通常用于向一个<code class="fe kv kw kx ky b">for</code>循环提供多个参数。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="bf07" class="kz la in ky b gy mb mc l md me">let num = 10</span><span id="5930" class="kz la in ky b gy mf mc l md me">num = (num--, num)<br/>console.log(num)       <em class="ki">// expected output: 9</em></span><span id="6e23" class="kz la in ky b gy mf mc l md me">num = (20, 30)<br/>console.log(num)       <em class="ki">// expected output: 30</em></span><span id="bae7" class="kz la in ky b gy mf mc l md me">let a, b, c<br/>a = b = 3, c = 4<br/>console.log(a)         <em class="ki">// expected output: 3 (left-most)</em></span><span id="3cd6" class="kz la in ky b gy mf mc l md me">let x, y, z</span><span id="65b4" class="kz la in ky b gy mf mc l md me">x = (y = 5, z = 6)<br/>console.log(x)         <em class="ki">// expected output: 6 (right-most)</em></span></pre><h2 id="ea4a" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">一元加和求反运算符</h2><p id="0759" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一元加(<code class="fe kv kw kx ky b">+</code>)和求反(<code class="fe kv kw kx ky b">-</code>)运算符位于其操作数之前，并计算其操作数。加号(<code class="fe kv kw kx ky b">+</code>)操作符试图将它的操作数转换成一个数字，如果它还不是的话。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="b606" class="kz la in ky b gy mb mc l md me">+8               <em class="ki">// result: 8<br/></em>+"8"             <em class="ki">// result: 8<br/></em>+"-8"            <em class="ki">// result: -8<br/></em>+"8.8"           <em class="ki">// result: 8.8<br/></em>+"123e-4"        <em class="ki">// result: 0.0123<br/></em>+true            <em class="ki">// result: 1<br/></em>+false           <em class="ki">// result 0<br/></em>+null            <em class="ki">// result: 0<br/></em>+"Infinity"      <em class="ki">// result: Infinity<br/></em>+"not a number"  <em class="ki">// result: NaN<br/></em>+function(){}    <em class="ki">// result: NaN</em></span></pre><p id="3b9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">negation ( <code class="fe kv kw kx ky b">-</code>)操作符做同样的事情，但是对结果求反。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="9ea2" class="kz la in ky b gy mb mc l md me">-8               <em class="ki">// result: -8<br/></em>-"8"             <em class="ki">// result: -8<br/></em>-"-8"            <em class="ki">// result: 8<br/></em>-"8.8"           <em class="ki">// result: -8.8<br/></em>-"123e-4"        <em class="ki">// result: -0.0123<br/></em>-true            <em class="ki">// result: -1<br/></em>-false           <em class="ki">// result -0<br/></em>-null            <em class="ki">// result: -0<br/></em>-"Infinity"      <em class="ki">// result: -Infinity<br/></em>-"not a number"  <em class="ki">// result: -NaN<br/></em>-function(){}    <em class="ki">// result: -NaN</em></span></pre><h2 id="ca1d" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">三元运算符</h2><p id="02c4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当试图根据特定条件是否为真来执行代码块时，直觉是使用<code class="fe kv kw kx ky b">if...else</code>语句。三元运算符也是如此，接受三个操作数；一个条件后跟一个<code class="fe kv kw kx ky b">?</code>，如果条件为真则执行一个表达式，后跟一个<code class="fe kv kw kx ky b">:</code>，如果条件为假则执行一个表达式。写出来的运算符是这样的:</p><p id="035f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">条件<code class="fe kv kw kx ky b">?</code>表达式真<code class="fe kv kw kx ky b">:</code>表达式假</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="59c4" class="kz la in ky b gy mb mc l md me">const age = 19</span><span id="90fe" class="kz la in ky b gy mf mc l md me">let canDrink<br/>    if (age &gt;= 21) {<br/>        canDrink = "yes"<br/>    } else {<br/>        canDrink = "no"<br/>    }</span><span id="d68c" class="kz la in ky b gy mf mc l md me"><em class="ki">// identical to the above if...else statement<br/></em>canDrink = (age &gt;= 21) ? "yes" : "no"</span><span id="d129" class="kz la in ky b gy mf mc l md me">console.log(canDrink) <em class="ki">// expected output: "no"</em></span></pre><p id="8f87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用三元运算符可以将几行代码压缩成一行。</p><h2 id="0e49" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Switch语句</h2><p id="4498" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">虽然<code class="fe kv kw kx ky b">if...else if...else</code>对于基于条件执行不同的动作来说非常好，但是如果有三个以上的条件，它很快就会变得混乱。在这些情况下，最好使用<code class="fe kv kw kx ky b">switch</code>语句。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="29be" class="kz la in ky b gy mb mc l md me">const expression = 'dog'</span><span id="7765" class="kz la in ky b gy mf mc l md me">switch (expression) {<br/>    <em class="ki">//invoke the switch statement to evaluate an express<br/></em>    case 'cat':<br/>        <em class="ki">//code to be executed when the result of the expression  <br/>          matches 'cat'<br/>        </em>console.log('The cat meows.');<br/>        break;     <br/>           <em class="ki">// break statement ensures that the program<br/>              breaks out of switch once the matched statement is<br/>              executed<br/>    </em>case 'bird':<br/>        console.log('The bird chirps.');<br/>        break;<br/>    case 'dog':<br/>        console.log('The dog woofs.');<br/>            <em class="ki">// expected output: "The dog woofs."<br/>        </em>break;<br/>    default:<br/>        <em class="ki">// a default clause is executed if the value of the <br/>           expression doesn't match any of the cases<br/>        </em>console.log(`There are no animals matching ${expression}`)<br/>}</span></pre><p id="7f4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当使用一个<code class="fe kv kw kx ky b">switch</code>语句时，表达式的值与每种情况下的值进行比较。如果匹配，则执行相关的代码块。如果不匹配，则执行默认代码块。</p><h2 id="c6c3" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">For…Of和For…In循环</h2><p id="8280" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">for...of</code>和<code class="fe kv kw kx ky b">for...in</code>循环都是使用数字索引的标准<code class="fe kv kw kx ky b">for</code>循环的有效替代。</p><p id="56b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">for...of</code> <strong class="jm io"> </strong>循环是一种迭代可迭代对象的方法，包括字符串、数组、集合和其他类似数组的对象。它调用一个定制的迭代钩子，为对象的每个不同的属性值执行语句。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="cd89" class="kz la in ky b gy mb mc l md me">// iterating over a string<br/>const iterableStr = 'hello'<br/><br/>for (value of iterableStr) {<br/>  console.log(value)<br/>}<br/><em class="ki">// expected output:<br/>// "h"<br/>// "e"<br/>// "l"<br/>// "l"<br/>// "o"</em></span><span id="c755" class="kz la in ky b gy mf mc l md me">// iterating over an array<br/>const iterableArr = [5, 10, 15, 20]<br/><br/>for (value of iterableArr) {<br/>  value += 1<br/>  console.log(value)<br/>}<br/><em class="ki">// expected output:<br/>// 6<br/>// 11<br/>// 16<br/>// 26</em></span></pre><p id="4429" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">for..in</code>循环是一种迭代对象“可枚举”属性的方法，适用于所有具有这些属性的对象。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="346c" class="kz la in ky b gy mb mc l md me">const obj = { a: 'red', b: 'orange', c: 'yellow'};</span><span id="357e" class="kz la in ky b gy mf mc l md me">for (property in obj) {<br/>  console.log(`${property}: ${obj[property]}`);<br/>}</span><span id="f40b" class="kz la in ky b gy mf mc l md me">// expected output:<br/>// "a: red"<br/>// "b: orange"<br/>// "c: yellow"</span></pre><p id="4414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">注意:</em> </strong> <em class="ki">虽然</em> <code class="fe kv kw kx ky b"><em class="ki">for...in</em></code> <em class="ki">循环可以用来使用索引对数组和字符串进行迭代，但不建议这样做。一般的经验是数组和字符串用</em> <code class="fe kv kw kx ky b"><em class="ki">for...of</em></code> <em class="ki">，对象用</em> <code class="fe kv kw kx ky b"><em class="ki">for...in</em></code> <em class="ki">。</em></p><h2 id="a521" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Number.prototype.toFixed()和Number.prototype.toPrecision()</h2><p id="8a27" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.toFixed()</code>和<code class="fe kv kw kx ky b">.toPrecision()</code>都接受一个数字对象，并返回一个表示数字对象的字符串。</p><p id="44aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.toFixed()</code>使用定点符号格式化数字。将一个数字传递给该方法，该数字表示小数点后出现的位数。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="249c" class="kz la in ky b gy mb mc l md me">const numObj = 12345.6789<br/>numObj.toFixed()       <em class="ki">// result:  '12346'<br/></em>numObj.toFixed(1)      <em class="ki">// result:  '12345.7'<br/></em>numObj.toFixed(6)      <em class="ki">// result:  '12345.678900', zeros are added</em></span><span id="42fa" class="kz la in ky b gy mf mc l md me">(1.23e+20).toFixed(2)  <em class="ki">// result:  '123000000000000000000.00'<br/></em>(1.23e-10).toFixed(2)  <em class="ki">// result:  '0.00'<br/></em>2.34.toFixed(1)        <em class="ki">// result:  '2.3'<br/></em>2.35.toFixed(1)        <em class="ki">// result:  '2.4'<br/></em>2.55.toFixed(1)        <em class="ki">// result:  '2.5' *unexpected rounding behavior</em></span></pre><p id="a159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">注意:</em> </strong> <em class="ki">有一些奇怪的情况下</em> <code class="fe kv kw kx ky b"><em class="ki">toFixed()</em></code> <em class="ki">会出现意外的舍入行为。</em></p><p id="602d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.toPrecision()</code>与<code class="fe kv kw kx ky b">.toFixed()</code>功能相似，但将数字对象格式化为指定的数字精度。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="5554" class="kz la in ky b gy mb mc l md me">let numObj = 1.234567<br/>numObj.toPrecision()    <em class="ki">// result:  '1.234567'<br/></em>numObj.toPrecision(5)   <em class="ki">// result:  '1.2345'<br/></em>numObj.toPrecision(2)   <em class="ki">// result:  '1.2'<br/></em>numObj.toPrecision(1)   <em class="ki">// result:  '1'</em></span><span id="078f" class="kz la in ky b gy mf mc l md me">numObj = 0.000123<br/>numObj.toPrecision()    <em class="ki">// result:  '0.000123'<br/></em>numObj.toPrecision(5)   <em class="ki">// result:  '0.00012300'<br/></em>numObj.toPrecision(2)   <em class="ki">// result:  '0.00012'<br/></em>numObj.toPrecision(1)   <em class="ki">// result:  '0.0001'</em></span></pre><p id="35c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种方法通常用于金融和科学数据，以获得更高的准确性。</p><h2 id="8dd6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">数学对象</h2><p id="a646" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Math</code>是一个内置在JavaScript中的对象，它具有数学属性和方法。使用<code class="fe kv kw kx ky b">Math.<em class="ki">property</em></code> <em class="ki"> </em>语法可以访问八个数学常数。然而，有35个内置的静态方法。一些最常用的是<code class="fe kv kw kx ky b">Math.ceil()</code>、<code class="fe kv kw kx ky b">Math.floor()</code>、<code class="fe kv kw kx ky b">Math.round()</code>、<code class="fe kv kw kx ky b">Math.max()</code>、<code class="fe kv kw kx ky b">Math.min()</code>、<code class="fe kv kw kx ky b">Math.pow()</code>和<code class="fe kv kw kx ky b">Math.sqrt()</code>。</p><p id="6034" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Math.ceil()</code>函数总是将一个数向上舍入到下一个最大的整数；而<code class="fe kv kw kx ky b">Math.floor()</code>函数总是返回小于或等于给定数字的最大整数。<code class="fe kv kw kx ky b">Math.round()</code>但是，使用更传统的舍入方法，舍入到最接近的整数。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="91b5" class="kz la in ky b gy mb mc l md me">Math.ceil(.85)       <em class="ki">// result: 1<br/></em>Math.ceil(6)         <em class="ki">// result: 6<br/></em>Math.ceil(4.004)     <em class="ki">// result: 5<br/></em>Math.ceil(-8.005)    <em class="ki">// result: -8</em></span><span id="7fc8" class="kz la in ky b gy mf mc l md me">Math.floor(.85)      <em class="ki">// result: 0<br/></em>Math.floor(6)        <em class="ki">// result: 6<br/></em>Math.floor(4.004)    <em class="ki">// result: 4<br/></em>Math.floor(-8.005)   <em class="ki">// result: -9</em></span><span id="3e81" class="kz la in ky b gy mf mc l md me">Math.round(1.05)     <em class="ki">// result: 1<br/></em>Math.round(1.5)      <em class="ki">// result: 2<br/></em>Math.round(1.95)     <em class="ki">// result: 2<br/></em>Math.round(-1.05)    <em class="ki">// result: -1<br/></em>Math.round(-1.5)     <em class="ki">// result: -1<br/></em>Math.round(-1.95)    <em class="ki">// result: -2</em></span></pre><p id="8221" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Math.max()</code>函数返回作为参数给出的最大数值。<code class="fe kv kw kx ky b">Math.min()</code>反其道而行之，返回传入数字中的最小值。如果没有参数传递给任何一个函数，结果将是<code class="fe kv kw kx ky b">NaN</code>。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="b2e1" class="kz la in ky b gy mb mc l md me">Math.max(3, 5, 1)       <em class="ki">// result: 5<br/></em>Math.min(3, 5, 1)       <em class="ki">// result: 1</em></span><span id="b1a1" class="kz la in ky b gy mf mc l md me">Math.max(-1, -3, -2)    <em class="ki">// result: -1<br/></em>Math.min(-1, -3, -2)    <em class="ki">// result: -3</em></span><span id="ab17" class="kz la in ky b gy mf mc l md me">const array1 = [1, 3, 2, 8]<br/>Math.max(...array1)     <em class="ki">// result: 8<br/></em>Math.min(...array1)     <em class="ki">// result: 1</em></span><span id="6fda" class="kz la in ky b gy mf mc l md me">Math.max()              <em class="ki">// result: NaN<br/></em>Math.min()              <em class="ki">// result: NaN</em></span></pre><p id="5465" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Math.pow()</code>需要两个参数。第一个是基数，第二个是指数。它返回指数幂的底数。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="0ebe" class="kz la in ky b gy mb mc l md me">Math.pow(7, 2)     <em class="ki">// result:  49<br/></em>Math.pow(2, 10)    <em class="ki">// result:  1024<br/></em>Math.pow(4, 0.5)   <em class="ki">// result:  2 (square root of 4)</em></span><span id="fde2" class="kz la in ky b gy mf mc l md me">Math.pow(8, 1/3)   <em class="ki">// result:  2 (cube root of 8)<br/></em>Math.pow(2, 1/3)   <em class="ki">// result:  1.2599210498948732 (cube root of 2)</em></span><span id="c4a0" class="kz la in ky b gy mf mc l md me">Math.pow(-4, 2)    <em class="ki">// result:  16 (squares are positive)<br/></em>Math.pow(-4, 3)    <em class="ki">// result:  -64 (cubes can be negative)<br/></em>Math.pow(-4, 0.5)  <em class="ki">// result:  NaN (negative numbers don't have a  <br/>                      real square root)</em></span></pre><p id="badd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Math.sqrt()</code>简单地返回传递给方法的数字的平方根。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="2cf4" class="kz la in ky b gy mb mc l md me">Math.sqrt(9)      <em class="ki">// result:  3<br/></em>Math.sqrt(2)      <em class="ki">// result:  1.414213562373095<br/></em>Math.sqrt(1)      <em class="ki">// result:  1<br/></em>Math.sqrt(0)      <em class="ki">// result:  0<br/></em>Math.sqrt(-1)     <em class="ki">// result:  NaN<br/></em>Math.sqrt(-0)     <em class="ki">// result:  -0</em></span></pre><h2 id="695e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">String.prototype.replace()</h2><p id="3acb" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.replace()</code>是一个带两个参数的字符串方法；一个模式和一个替代品。模式可以是子字符串或RegExp，方法在字符串中搜索它。所有匹配都将被第二个参数替换。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="ecee" class="kz la in ky b gy mb mc l md me">const string = "Sally fed her dog vegetables. Her dog was happy."<br/>console.log(string.replace("dog", "monkey"))<br/><em class="ki">// expected output: "Sally fed her monkey vegetables. Her monkey was <br/>   happy."</em></span><span id="33b3" class="kz la in ky b gy mf mc l md me">let regex = /dog/i<br/>const newString = string.replace(regex, "son")<br/>console.log(newString)<br/><em class="ki">// expected output: "Sally fed her son vegetables. Her son was<br/>   happy."</em></span></pre><h2 id="2bf8" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">String.prototype.localeCompare()</h2><p id="922c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.localeCompare()</code>方法返回一个数字，指示一个引用字符串在排序顺序中是在给定字符串之前、之后还是相同。这在按字母顺序对字符串进行排序时特别有用。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="fc9f" class="kz la in ky b gy mb mc l md me">const arrayOfStrings = ['cat', 'dog', 'chicken', 'fish', 'bird']</span><span id="ec3b" class="kz la in ky b gy mf mc l md me">const sortedArr = arrayOfStrings.sort((a, b) =&gt; a.localeCompare(b))<br/>console.log(sortedArr)<br/>//<em class="ki"> expected output: ['bird', 'cat', 'chicken', 'dog', 'fish']</em></span></pre><p id="4a75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe kv kw kx ky b">.localeCompare()</code>，还可以选择包含<code class="fe kv kw kx ky b">locales</code>和<code class="fe kv kw kx ky b">options</code>参数。这些参数将改变方法的行为，并指定应该使用的语言和格式约定。</p><h2 id="4ea3" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">String.prototype.slice()</h2><p id="83d0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.slice()</code>方法从一个字符串创建一个子字符串，而不修改原始字符串。它可以接受一个或两个参数，指示原始字符串的开始和结束索引。如果只传入一个参数，子字符串将从该索引开始，一直延续到原始字符串的末尾。如果有两个参数，子字符串从起始索引开始提取字符，直到<em class="ki">，但不包括</em>结束索引。</p><p id="842b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，如果参数为负，则被视为<code class="fe kv kw kx ky b">str.length + index</code>。(例如，如果开始索引是<code class="fe kv kw kx ky b">-5</code>，则被视为<code class="fe kv kw kx ky b">str.length - 5</code>。)如果结束索引参数在开始索引参数之前，则返回一个空字符串。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="8dba" class="kz la in ky b gy mb mc l md me">const str = "JavaScript"</span><span id="7863" class="kz la in ky b gy mf mc l md me">let substr = str.slice(3)<br/>console.log(substr)        // <em class="ki">expected output: "aScript"</em></span><span id="cf40" class="kz la in ky b gy mf mc l md me">substr = str.slice(2,8)<br/>console.log(substr)        // <em class="ki">expected output: "vaScri"</em></span><span id="c5bf" class="kz la in ky b gy mf mc l md me">substr = str.slice(-3)<br/>console.log(substr)        // <em class="ki">expected output: "ipt"</em></span><span id="6740" class="kz la in ky b gy mf mc l md me">substr = str.slice(-7,-1)<br/>console.log(substr)        // <em class="ki">expected output: "aScrip"</em></span><span id="047c" class="kz la in ky b gy mf mc l md me">substr = str.slice(3, 1)<br/>console.log(substr)        // <em class="ki">expected output: ""</em></span><span id="a399" class="kz la in ky b gy mf mc l md me">substr = str.slice(-3, 1)<br/>console.log(substr)        // <em class="ki">expected output: ""</em></span></pre><h2 id="875c" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Array.prototype.slice()</h2><p id="a869" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当在一个数组上调用<code class="fe kv kw kx ky b">.slice()</code>时，它从原始数组返回一个元素的浅层副本。类似于<code class="fe kv kw kx ky b">.slice()</code> string方法，它也需要一个或两个参数，代表起始和结束索引。原始阵列不受影响。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="14d3" class="kz la in ky b gy mb mc l md me">const fruitsArr = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']</span><span id="3c00" class="kz la in ky b gy mf mc l md me">let newFruitsArr = fruitsArr.slice(3)<br/>console.log(newFruitsArr)<em class="ki"><br/>// expected output: ['Apple', 'Mango']</em></span><span id="971e" class="kz la in ky b gy mf mc l md me">newFruitsArr = fruitsArr.slice(1, 3)<br/>console.log(newFruitsArr)<br/>// <em class="ki">expected output: ['Orange', 'Lemon']</em></span><span id="ed26" class="kz la in ky b gy mf mc l md me">newFruitsArr = fruitsArr.slice(-4)<br/>console.log(newFruitsArr)<br/>// <em class="ki">expected output: ['Orange', 'Lemon', 'Apple', 'Mango']</em></span><span id="0571" class="kz la in ky b gy mf mc l md me">newFruitsArr = fruitsArr.slice(-4,-2)<br/>console.log(newFruitsArr)<br/>// <em class="ki">expected output: ['Orange', 'Lemon', 'Apple']</em></span><span id="c474" class="kz la in ky b gy mf mc l md me">newFruitsArr = fruitsArr.slice(4,2)<br/>console.log(newFruitsArr)<br/>// <em class="ki">expected output: []</em></span></pre><h2 id="a0e8" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Array.prototype.some()</h2><p id="20f0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">.some()</code>方法需要一个回调函数作为参数，并检查数组中是否至少有一个元素通过了由提供的函数实现的测试。如果数组中有符合条件的元素，则返回true否则返回false。它不会修改数组。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="b7f6" class="kz la in ky b gy mb mc l md me">const array = [1, 2, 3, 4, 5]</span><span id="a1bc" class="kz la in ky b gy mf mc l md me"><em class="ki">// checks whether an element is odd</em><br/>const odd = (element) =&gt; element % 2 !== 0</span><span id="cbbc" class="kz la in ky b gy mf mc l md me">console.log(array.some(odd))<br/><em class="ki">// expected output: true</em></span><span id="ed46" class="kz la in ky b gy mf mc l md me"><em class="ki">// checks whether an element is greater than or equal to 10</em><br/>const tenOrMore = (element) =&gt; element &gt;= 10</span><span id="8547" class="kz la in ky b gy mf mc l md me">console.log(array.some(tenOrMore))<br/><em class="ki">// expected output: false</em></span></pre><h2 id="da2e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Array.prototype.splice()添加元素</h2><p id="8e62" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">虽然<code class="fe kv kw kx ky b">.splice()</code>是修改和缩短数组最常用的方法之一，但它也可以通过包含附加参数来添加元素。当使用<code class="fe kv kw kx ky b">.splice()</code>移除元素时，只需要两个参数；第一个是开始更改数组的索引，第二个是指示要移除的元素数量的整数。但是，前两个参数后面的任何附加参数都是要添加到数组中的元素，从起始索引(第一个参数)开始。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="f5f3" class="kz la in ky b gy mb mc l md me">let cars = ['Honda', 'Toyota', 'BMW', 'Mercedes', 'Ford']</span><span id="a5b5" class="kz la in ky b gy mf mc l md me">// <em class="ki">using only two parameters, remove two elements starting at index  <br/>   2</em><br/>cars.splice(2,2)<br/>console.log(cars)            <br/><em class="ki">// expected output: ['Honda', 'Toyota', 'Ford']</em></span><span id="7e6e" class="kz la in ky b gy mf mc l md me"><em class="ki">// remove 0 elements starting at index 1 and insert 'Chevy' and <br/>   'Volkswagon'<br/></em>cars.splice(1,0,'Chevy','Volkswagen')<br/>console.log(cars)<br/><em class="ki">// expected output after the array has been modified by the previous <br/>   splice: ['Honda', 'Chevy', 'Volkswagen', 'Toyota', 'Ford']</em></span></pre><h2 id="8c06" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">数组. from()</h2><p id="fbe8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Array.from()</code>是一个静态方法，它从一个类似数组或可迭代的对象创建一个新的数组实例。当用两个参数调用时，第二个参数充当映射函数。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="50fc" class="kz la in ky b gy mb mc l md me">console.log(Array.from('foo'))<br/>// expected output: ["f", "o", "o"]</span><span id="3931" class="kz la in ky b gy mf mc l md me">console.log(Array.from([1, 2, 3]))<br/>// expected output: [1, 2, 3]</span><span id="68b7" class="kz la in ky b gy mf mc l md me">console.log(Array.from([1, 2, 3], x =&gt; 2 * x))<br/>// expected output: [2, 4, 6]</span></pre><h2 id="4487" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">object . prototype . hasownproperty()</h2><p id="b36e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">可以在对象上调用<code class="fe kv kw kx ky b">hasOwnProperty()</code>方法，并返回一个布尔值，指示该对象是否将指定的属性作为自己的属性。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="9c2e" class="kz la in ky b gy mb mc l md me">const obj = { color: 'red', number: 4, language: "Spanish" }</span><span id="6f64" class="kz la in ky b gy mf mc l md me">obj.hasOwnProperty('color')          <em class="ki"> // result: true</em><br/>obj.hasOwnProperty('meal')            <em class="ki">// result: false</em></span><span id="15fa" class="kz la in ky b gy mf mc l md me">obj.drink = null<br/>obj.hasOwnProperty('drink')          <em class="ki"> // result: true</em></span></pre><p id="4f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，因为<code class="fe kv kw kx ky b">Object</code>的所有后代都继承了<code class="fe kv kw kx ky b">hasOwnProperty</code>方法，所以也可以在数组上调用它来检查索引是否存在。</p><h2 id="21d6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">对象.分配()</h2><p id="6feb" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Object.assign()</code>方法将一个或多个源对象的所有可枚举的和自己的属性复制到一个目标对象。它返回已被修改的目标对象。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="ec93" class="kz la in ky b gy mb mc l md me">const target = { a: 2, b: 6 }<br/>const source = { b: 8, c: 9 }</span><span id="241b" class="kz la in ky b gy mf mc l md me">const returnedTarget = Object.assign(target, source)</span><span id="0205" class="kz la in ky b gy mf mc l md me">console.log(target)<br/>// expected output: { a: 2, b: 8, c: 9}</span><span id="5573" class="kz la in ky b gy mf mc l md me">console.log(returnedTarget)<br/>// expected output: { a: 2, b: 8, c: 9}</span></pre><h2 id="d789" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Object.freeze()和Object.seal()</h2><p id="f870" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">方法冻结一个对象，防止它被改变。冻结对象可防止添加新特性，并防止删除或更改现有特性的值。任何这样做的尝试都将失败，要么无声地失败，要么抛出一个<code class="fe kv kw kx ky b">TypeError</code>异常(最常见的，但不是唯一的，在严格模式下)。<code class="fe kv kw kx ky b">.isFrozen()</code>方法可用于检查对象是否冻结。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="1eaf" class="kz la in ky b gy mb mc l md me">const obj = { prop: 42 }</span><span id="6c3d" class="kz la in ky b gy mf mc l md me">console.log(Object.isFrozen(obj))<br/>// expected output: false</span><span id="1d59" class="kz la in ky b gy mf mc l md me">Object.freeze(obj)</span><span id="abb7" class="kz la in ky b gy mf mc l md me">obj.prop = 33;<br/>// Throws an error in strict mode</span><span id="a6d7" class="kz la in ky b gy mf mc l md me">console.log(Object.isFrozen(obj))<br/>// expected output: true</span></pre><p id="9a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Object.seal()</code>行为类似，但它允许更改现有属性，同时防止添加新属性和删除现有属性。<code class="fe kv kw kx ky b">.isSealed()</code>方法可用于检查对象是否密封。</p><pre class="kk kl km kn gt lx ky ly lz aw ma bi"><span id="0be0" class="kz la in ky b gy mb mc l md me">const obj = { prop: 42 }</span><span id="2b4b" class="kz la in ky b gy mf mc l md me">console.log(Object.isSealed(obj))<br/>// expected output: false</span><span id="d640" class="kz la in ky b gy mf mc l md me">Object.seal(obj)</span><span id="f457" class="kz la in ky b gy mf mc l md me">console.log(Object.isSealed(obj))<br/>// expected output: true</span><span id="31b7" class="kz la in ky b gy mf mc l md me">obj.prop = 33        // the object's existing property is changeable<br/>console.log(obj.prop)<br/>// expected output: 33</span><span id="66ad" class="kz la in ky b gy mf mc l md me">delete object1.property1      // cannot delete when sealed<br/>console.log(obj.prop)<br/>// expected output: 33</span></pre><p id="6fc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">Object.freeze()</code>和<code class="fe kv kw kx ky b">Object.seal()</code>都是用来创建不可扩展的对象，但是<strong class="jm io"> <em class="ki">需要注意的是</em> </strong> <em class="ki">对象一旦被冻结或者封存，就不能被撤销</em>。</p><h1 id="a685" class="mg la in bd lb mh mi mj le mk ml mm lh mn mo mp lk mq mr ms ln mt mu mv lq mw bi translated">结论</h1><p id="0c64" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">今天，JavaScript的使用已经远远超出了其web浏览器的范围，并继续革新计算。无论您是这门语言的新手，还是已经使用JS多年的人，希望您能在下一个项目中实现这里分享的一些特性和方法。虽然可能要花一生的时间来完全探索JavaScript，但好处是它似乎不会有任何进展。</p><p id="a0ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容看</em> <a class="ae mx" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>