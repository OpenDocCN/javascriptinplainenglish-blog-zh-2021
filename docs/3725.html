<html>
<head>
<title>JavaScript: What is ‘this’?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:这是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-what-is-this-3bd177378b66?source=collection_archive---------12-----------------------#2021-07-26">https://javascript.plainenglish.io/javascript-what-is-this-3bd177378b66?source=collection_archive---------12-----------------------#2021-07-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fe7b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解JavaScript中“this”关键字的范围和上下文。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/56daf0dde11006e485568f7201422b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmMt0XilTHvsH7FulZa7Sg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@emilpriver?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Emil Priver</a> on <a class="ae ks" href="https://unsplash.com/@emilpriver?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a27e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在编写JavaScript代码时，有一件事会让我们感到困惑，那就是关键字<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>。这是一个特殊的关键字，用来标识定义函数范围的自动性。在JavaScript中，每个函数在运行时都有一个对当前执行上下文的特殊引用，称为<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>，它从不引用原始类型，而是引用一个对象。</p><p id="9f9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于“this”关键字如何与执行上下文相关联，有四个基本规则，它们都取决于JavaScript函数的代码在哪里执行。在本文中，我们将分析这些规则，从与关键字<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>密切相关的JavaScript语言的一些关键概念开始，例如<strong class="kv io">范围</strong>和<strong class="kv io">上下文</strong>。</p><h1 id="1848" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">有些困惑</h1><p id="4f08" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">当谈到JavaScript中的<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字时，不要认为它指的是类、对象、实例和面向对象编程世界中的所有其他东西。此外，不要将<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字与其他编程语言进行比较。另一个需要澄清的重要事情是，功能的“上下文”和“范围”不是一回事。许多开发人员混淆了这些术语，将一个错误地描述为另一个。所以在继续之前，让我们先澄清这两个概念的含义。</p><h2 id="4d2b" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated">范围和背景</h2><p id="355d" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated"><strong class="kv io">范围是指变量的可见性</strong>。在JavaScript中，这是通过使用函数来实现的。当我们在函数内部使用<code class="fe lp lq lr ls b"><strong class="kv io">var</strong></code>关键字时，你正在初始化的变量是函数私有的，在函数外部是看不到的。但是，如果我们在其中声明了其他函数，那么这些“内部”函数就可以访问该变量，因为它们在同一个范围内。函数还可以访问在内部和外部声明的变量，但不能访问嵌套函数内部声明的变量。这在JavaScript中称为范围。</p><p id="29a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">上下文</strong>，另一方面<strong class="kv io">与对象</strong>相关。它指的是函数所属的对象。当使用JavaScript 'this '关键字时，它指的是函数所属的对象。执行上下文，其中<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字被评估，只不过是位置<strong class="kv io">，其中</strong>和<strong class="kv io">如何</strong>一个特定的函数被调用。</p><h1 id="88d3" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">全球范围</h1><p id="f3e1" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">为了更好地理解这一基本规则，让我们从下面的代码片段开始:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="3239" class="mq lu in ls b gy ng nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}</span><span id="0ced" class="mq lu in ls b gy nk nh l ni nj">print()</span></pre><p id="533f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在前三行代码中，我们声明了一个<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数，它引用了<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字，尤其是<code class="fe lp lq lr ls b"><strong class="kv io">name</strong></code>属性。在我们调用函数之后。在这种情况下，<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>并不指向任何对象，而是指向浏览器全局范围<code class="fe lp lq lr ls b"><strong class="kv io">Window</strong></code>，实际上试图通过以下方式修改我们的<code class="fe lp lq lr ls b"><strong class="kv io">console.log</strong></code>:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="094b" class="mq lu in ls b gy ng nh l ni nj">function print () {<br/>  console.log(this)<br/>}</span><span id="0cfe" class="mq lu in ls b gy nk nh l ni nj">print()</span></pre><p id="9a12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将获得类似这样的东西:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="7fe7" class="mq lu in ls b gy ng nh l ni nj">Window {window: Window, self: Window, document: document, name: "", location: Location, …}</span></pre><p id="dfcf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">全局范围没有一个名为<code class="fe lp lq lr ls b"><strong class="kv io">name</strong></code>的属性，所以从前面的脚本返回的结果是:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="a88e" class="mq lu in ls b gy ng nh l ni nj">My name is</span></pre><p id="8cbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当代码不在“严格模式”下运行时，会发生这种情况。事实上，如果我们试图通过在脚本开头添加<code class="fe lp lq lr ls b"><strong class="kv io">'strict mode'</strong></code>来修改代码:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="f850" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="8ca7" class="mq lu in ls b gy nk nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}</span><span id="15ee" class="mq lu in ls b gy nk nh l ni nj">print()</span></pre><p id="2af8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将获得一个<code class="fe lp lq lr ls b">TypeError</code>:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="15f5" class="mq lu in ls b gy ng nh l ni nj">Uncaught TypeError: Cannot read property 'name' of undefined<br/>    at print (&lt;anonymous&gt;:4:34)<br/>    at &lt;anonymous&gt;:7:1</span></pre><p id="573a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你不知道什么是“严格模式”，看看<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="0c28" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">隐式结合</h1><p id="584a" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">为了更好地理解第二条规则，让我们回到上一个例子中定义的漂亮的<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数，并创建两个引用它的对象。请记住，我们的目标是能够使用<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字查看函数的定义，并理解它所引用的内容。这个规律80%的时候能够让我们明白<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>指的是什么。现在考虑下面的代码:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="3c74" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="3aba" class="mq lu in ls b gy nk nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}</span><span id="6b6a" class="mq lu in ls b gy nk nh l ni nj">const person1 = { name: 'Paul', print: print }<br/>const person2 = { name: 'Steve', print: print }</span></pre><p id="47a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在代码示例中，我们有两个对象，<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>，它们有两个属性。第一个属性是<code class="fe lp lq lr ls b"><strong class="kv io">name</strong></code>:一个字符串，标识一个人的名字。现在，如果我们想在对象<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code> <strong class="kv io"> </strong>上调用<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数，我们必须使用“点”<code class="fe lp lq lr ls b">.</code>，如下所示:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="6c4a" class="mq lu in ls b gy ng nh l ni nj">person1.print()<br/>person2.print()</span></pre><p id="297e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了理解关键字<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>指的是什么，我们首先需要看一下函数的左边。如果有一个“点”,向点的左边看，找到由<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字引用的对象。</p><p id="5687" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上例中，<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>位于<em class="nl"/>点的“左侧”，这意味着关键字<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>首先指向<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>对象，然后指向<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>对象。在<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数内部，JavaScript解释器将<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>更改为<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>。</p><p id="d611" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们执行代码，您将获得以下结果:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="f1ca" class="mq lu in ls b gy ng nh l ni nj">Paul<br/>Steve</span></pre><p id="06dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们举一个类似的，但是稍微高级一点的例子:让我们在我们的<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>对象中定义第三个属性<code class="fe lp lq lr ls b"><strong class="kv io">father</strong></code>。该属性将是对<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>的引用:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="5deb" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="a2af" class="mq lu in ls b gy nk nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}</span><span id="3fc0" class="mq lu in ls b gy nk nh l ni nj">const person1 = { name: 'Paul', print: print }<br/>const person2 = { name: 'Steve', print: print, <strong class="ls io">father</strong>: person1 }</span><span id="d8c5" class="mq lu in ls b gy nk nh l ni nj">person2.print()<br/>person2.father.print()</span></pre><p id="5e54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如上所述，在80%的时间里我们需要看到<em class="nl">【点的左边】</em>来理解当我们调用<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数时<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字指的是谁。第一次调用print时，点左边的对象是<code class="fe lp lq lr ls b"><strong class="kv io">person2</strong></code>，所以<code class="fe lp lq lr ls b"><strong class="kv io">this.name</strong></code>会引用字符串“Steve”。然而，当第二次调用<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>时，在点的左边有<code class="fe lp lq lr ls b"><strong class="kv io">father</strong></code>属性，它是对<code class="fe lp lq lr ls b"><strong class="kv io">person1</strong></code>的引用，所以<code class="fe lp lq lr ls b"><strong class="kv io">this.name</strong></code>将引用字符串“保罗”。</p><h1 id="4d89" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">显式绑定</h1><p id="9df7" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">让我们重新考虑一下上一段给出的例子，但是这次不在<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数和<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>对象之间创建任何引用:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="5dd5" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="bc20" class="mq lu in ls b gy nk nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}</span><span id="05db" class="mq lu in ls b gy nk nh l ni nj">const person = { name: 'Paul' }</span></pre><p id="1ed1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们知道要知道<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字指的是什么，我们首先需要看看函数是在哪里被调用的。现在，问题是“我们如何调用<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>，但是用引用<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>对象的<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字调用它？”不能因为<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>没有<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>功能就直接用<code class="fe lp lq lr ls b"><strong class="kv io">person.print()</strong></code>。在JavaScript中，每个函数都包含一个允许我们这样做的方法，这个方法叫做<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>。</p><p id="734a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>是每个函数都有的一个方法，它允许你指定，作为第一个参数，调用函数的上下文。换句话说，您传递的第一个参数将是<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字在该函数中引用的内容。欲了解更多信息，请查阅<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="17b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们可以这样在<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>上下文中调用<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="4eda" class="mq lu in ls b gy ng nh l ni nj">print.<strong class="ls io">call</strong>(person)</span></pre><p id="4025" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相比隐式绑定规则，这次我们不用看<em class="nl">【点的左边】</em>，而是只看<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>函数的第一个参数；这将是<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>将在<code class="fe lp lq lr ls b">print</code>函数中引用的范围。这就是为什么这个规则被定义为显式绑定，因为我们显式地(使用<code class="fe lp lq lr ls b"><strong class="kv io">.call</strong></code>)指定了<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字所指的内容。</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="df9c" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="f0c0" class="mq lu in ls b gy nk nh l ni nj">function print () {<br/>  console.log(`My name is ${this.name}`)<br/>}<br/>const person = { name: 'Paul' }<br/>print<strong class="ls io">.call</strong>(person)</span></pre><p id="a748" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们执行下面的代码，结果将是:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="583a" class="mq lu in ls b gy ng nh l ni nj">Paul</span></pre><p id="94a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们试着修改我们的<code class="fe lp lq lr ls b"><strong class="kv io">print</strong></code>函数，增加两个参数<code class="fe lp lq lr ls b"><strong class="kv io">gender</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">age</strong></code>。</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="e172" class="mq lu in ls b gy ng nh l ni nj">function print (gender, age) {<br/>  console.log(`My name is ${this.name}, I'm a ${gender} of ${age} years old!`)<br/>}</span></pre><p id="691a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果我们想向被调用的函数传递一些参数，我们必须在指定第一个参数后一次传递一个参数:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="e864" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="af91" class="mq lu in ls b gy nk nh l ni nj">function print (gender, age) {<br/>  console.log(`My name is ${this.name}, I'm a ${gender} of ${age} years old!`)<br/>}</span><span id="1e04" class="mq lu in ls b gy nk nh l ni nj">const person = { name: 'Paul' }<br/>const arguments = ['male', 37]<br/>print.<strong class="ls io">call</strong>(person, <strong class="ls io">arguments[0]</strong>, <strong class="ls io">arguments[1]</strong>)</span></pre><p id="5ce4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是如何将参数传递给用<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>函数调用的函数。然而，不得不从我们的<code class="fe lp lq lr ls b"><strong class="kv io">arguments</strong></code>数组中一个接一个地传递参数有点烦人。如果我们可以将整个数组作为第二个参数传递，JavaScript会为我们将它们展开，那就太好了。这正是<code class="fe lp lq lr ls b"><strong class="kv io">apply</strong></code>功能的作用。</p><p id="c084" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b"><strong class="kv io">apply</strong></code>的工作方式与<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>完全一样，但是我们可以传递一个数组，apply会负责将数组的每个元素作为参数分配给函数，而不是一个接一个地传递参数。</p><p id="e249" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，使用<code class="fe lp lq lr ls b"><strong class="kv io">apply</strong></code>、<strong class="kv io">、</strong>我们的代码可以这样修改:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="2604" class="mq lu in ls b gy ng nh l ni nj">'use strict'</span><span id="f016" class="mq lu in ls b gy nk nh l ni nj">function print (gender, age) {<br/>  console.log(`My name is ${this.name}, I'm a ${gender} of ${age} years old!`)<br/>}</span><span id="914a" class="mq lu in ls b gy nk nh l ni nj">const person = { name: 'Paul' }<br/>const arguments = ['male', 37]<br/>print.<strong class="ls io">apply</strong>(person, <strong class="ls io">arguments</strong>)</span></pre><p id="1b22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，通过我们的<em class="nl">“显式绑定”</em>规则，我们已经了解了<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>和<code class="fe lp lq lr ls b"><strong class="kv io">apply</strong></code>，它们都允许您调用一个函数，指定<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字将引用什么。我们现在需要知道的最后一个函数是<code class="fe lp lq lr ls b"><strong class="kv io">bind</strong></code>。该函数与<code class="fe lp lq lr ls b"><strong class="kv io">call</strong></code>相同，但它不是立即调用该函数，而是返回一个新的函数，我们可以稍后调用。因此，如果我们使用<code class="fe lp lq lr ls b"><strong class="kv io">bind</strong></code>查看我们之前的代码，它将如下所示:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="72af" class="mq lu in ls b gy ng nh l ni nj">'use strict'<br/>function print (gender, age) {<br/>  console.log(`My name is ${this.name}, I'm a ${gender} of ${age} years old!`)<br/>}</span><span id="c0a0" class="mq lu in ls b gy nk nh l ni nj">const person = { name: 'Paul' }<br/>const arguments = ['male', 37]</span><span id="048f" class="mq lu in ls b gy nk nh l ni nj">const newPrint = print.<strong class="ls io">bind</strong>(person, arguments[0], arguments[1])<br/>newPrint()</span></pre><h2 id="86c5" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated">新操作员</h2><p id="f490" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">另一种理解这是指什么的方式是新的关键字。如果你不熟悉JavaScript中的<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字，那么考虑一下，每次你用<code class="fe lp lq lr ls b"><strong class="kv io">new</strong></code>关键字调用一个函数，JavaScript解释器都会为你创建一个新的对象，并把它命名为<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>。所以，当然，如果用关键字<code class="fe lp lq lr ls b"><strong class="kv io">new</strong></code>调用一个函数，<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>指的是解释器创建的新对象:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="c01f" class="mq lu in ls b gy ng nh l ni nj">function Person (name, age) {<br/>  <strong class="ls io">this</strong>.name = name <br/><strong class="ls io">  this</strong>.age = age<br/><strong class="ls io">  this</strong>.print = function () {<br/>    console.log(`Hello I'm ${<strong class="ls io">this</strong>.name} and I'm ${<strong class="ls io">this</strong>.age}!`)<br/>  }<br/>}</span><span id="2c96" class="mq lu in ls b gy nk nh l ni nj">const me = new Person('Davide', 37)<br/>me.print()</span></pre><p id="6c56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用JavaScript类，我们将获得相同的行为:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="e0d3" class="mq lu in ls b gy ng nh l ni nj">class Person {<br/>  constructor(name, age) {<br/>    <strong class="ls io">this</strong>.name = name<br/>    <strong class="ls io">this</strong>.age = age<br/>  }</span><span id="829d" class="mq lu in ls b gy nk nh l ni nj">  print () {<br/>    console.log(`Hello I'm ${<strong class="ls io">this</strong>.name} and I'm ${<strong class="ls io">this</strong>.age}!`)<br/>  }<br/>}</span><span id="f74d" class="mq lu in ls b gy nk nh l ni nj">const me = new Person('Davide', 37)<br/>me.print()</span></pre><p id="0f5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这两种情况下，<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>将引用使用<code class="fe lp lq lr ls b"><strong class="kv io">new</strong></code>操作符创建的对象，在这种情况下，只需查看<em class="nl">“点的左边”</em>即可了解<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>引用的是谁。在刚刚显示的示例中，我们将得到以下结果:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="a1e6" class="mq lu in ls b gy ng nh l ni nj">Hello I'm Davide and I'm 37</span></pre><h1 id="8cef" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">词汇装订</h1><p id="8927" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">JavaScript中的<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字可能比它应该的更复杂。好消息是，下一条规则是最直观的。您可能听说过并使用过“<em class="nl">箭头功能</em>”。它们从ES6开始引入。它们允许您以更简洁的格式编写函数:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="21a3" class="mq lu in ls b gy ng nh l ni nj">persons.map(person =&gt; person.name)</span></pre><p id="120c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">甚至比简洁性更重要的是，当涉及到<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>关键字时，这些类型的函数采取了更直观的方法。与普通函数不同，箭头函数没有<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>。相反，<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>是词汇上确定的。这是一种优雅的说法，即<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>是根据在原型链中寻找变量的正常规则确定的。让我们用一个例子来更好地阐明这个概念，考虑下面的代码示例:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="2e2b" class="mq lu in ls b gy ng nh l ni nj">const person = {<br/>  name: 'Davide',<br/>  age: 37,<br/>  gender: 'male',<br/>  frameworks: ['Fastify', 'Angular', 'Vue'],<br/>  print() {<br/>    <br/>    const message = `My name is ${this.name}, <br/>      I'm a ${this.gender} of ${this.age} years old! <br/>      My favourite frameworks are: `<br/>    <br/>    const frms = this.frameworks.reduce(function (str, f, i) {<br/>    <br/>      if (i === this.frameworks.length - 1) {<br/>        return `${str} and ${f}.`<br/>      }</span><span id="40c8" class="mq lu in ls b gy nk nh l ni nj">      return `${str} ${f},`<br/>    }, "")    </span><span id="a498" class="mq lu in ls b gy nk nh l ni nj">    console.log(message.concat(frms))<br/>  }<br/>}</span><span id="7718" class="mq lu in ls b gy nk nh l ni nj">person.print()</span></pre><p id="1b2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们运行这段代码，我们将获得以下错误:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="2789" class="mq lu in ls b gy ng nh l ni nj">if (i === this.frameworks.length - 1) {<br/>               ^<br/>TypeError: Cannot read property 'frameworks' of undefined</span></pre><p id="c87d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们调用<code class="fe lp lq lr ls b"><strong class="kv io">person.print()</strong></code>时，我们期望看到<em class="nl">“我叫大卫，男性，37岁！……”</em>。根据错误，<code class="fe lp lq lr ls b"><strong class="kv io">this.frameworks</strong></code>未定义。让我们通过我们的步骤来理解<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>指的是什么，最重要的是试图理解为什么它不应该指<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>。</p><p id="eb01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要看看函数是在哪里被调用的。该功能被传递给<code class="fe lp lq lr ls b"><strong class="kv io">.reduce</strong></code>，因此<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>的范围与<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>的范围不同。事实上，我们从未见过匿名函数的调用，因为在<code class="fe lp lq lr ls b"><strong class="kv io">.reduce</strong></code>的实现中，JavaScript会自己调用。这是个问题。我们必须指定我们传递给<code class="fe lp lq lr ls b"><strong class="kv io">.reduce</strong></code>的匿名函数在<code class="fe lp lq lr ls b"><strong class="kv io">person</strong></code>上下文中被调用。这样<code class="fe lp lq lr ls b"><strong class="kv io">this.frameworks</strong></code>将引用<code class="fe lp lq lr ls b"><strong class="kv io">person.frameworks</strong></code>。所以，我们可以使用<code class="fe lp lq lr ls b"><strong class="kv io">.bind</strong></code>:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="9270" class="mq lu in ls b gy ng nh l ni nj">const person = {<br/>  name: 'Davide',<br/>  age: 37,<br/>  gender: 'male',<br/>  frameworks: ['Fastify', 'Angular', 'Vue'],<br/>  print() {<br/>    <br/>    const message = `My name is ${this.name}, <br/>      I'm a ${this.gender} of ${this.age} years old! <br/>      My favourite frameworks are: `<br/>    <br/>    const frms = this.frameworks.reduce(function (str, f, i) {<br/>    <br/>      if (i === this.frameworks.length - 1) {<br/>        return `${str} and ${f}.`<br/>      }</span><span id="1ebd" class="mq lu in ls b gy nk nh l ni nj">      return `${str} ${f},`<br/>    }<strong class="ls io">.bind(this)</strong>, "")</span><span id="5ad5" class="mq lu in ls b gy nk nh l ni nj">    console.log(message.concat(frms))<br/>  }<br/>}</span><span id="02aa" class="mq lu in ls b gy nk nh l ni nj">person.print()</span></pre><p id="e357" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果我们运行代码，结果是:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="9ee0" class="mq lu in ls b gy ng nh l ni nj">My name is Davide, I'm a male of 37 years old! My favourite frameworks are:  Fastify, Angular, and Vue.</span></pre><p id="8fb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经看到了<code class="fe lp lq lr ls b"><strong class="kv io">.bind</strong></code>如何再一次为我们解决问题，但是它与箭头函数有什么关系呢？前面我们说过，在arrow函数中，这是由词汇决定的，然后遵循原型链，直到找到frameworks变量。在上面的例子中，按照原型链，这指的是人，因此是<code class="fe lp lq lr ls b"><strong class="kv io">this.frameworks</strong></code>。没有理由仅仅因为我们使用了<code class="fe lp lq lr ls b"><strong class="kv io">.reduce</strong></code>函数就创建新的执行上下文。因此，通过移除<code class="fe lp lq lr ls b"><strong class="kv io">.bind(this)</strong></code>函数并使用匿名箭头函数，代码将如下所示:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="343f" class="mq lu in ls b gy ng nh l ni nj">const person = {<br/>  name: 'Davide',<br/>  age: 37,<br/>  gender: 'male',<br/>  frameworks: ['Fastify', 'Angular', 'Vue'],<br/>  print() {<br/>    <br/>    const message = `My name is ${this.name}, <br/>      I'm a ${this.gender} of ${this.age} years old! <br/>      My favourite frameworks are: `<br/>    <br/>    const frms = this.frameworks.reduce(<strong class="ls io">(str, f, i) =&gt; {</strong><br/>    <br/>      if (i === this.frameworks.length - 1) {<br/>        return `${str} and ${f}.`<br/>      }</span><span id="a7eb" class="mq lu in ls b gy nk nh l ni nj">      return `${str} ${f},`<br/>    <strong class="ls io">}</strong>, "")</span><span id="c8e4" class="mq lu in ls b gy nk nh l ni nj">    console.log(message.concat(frms))<br/>  }<br/>}</span><span id="bfda" class="mq lu in ls b gy nk nh l ni nj">person.print()</span></pre><p id="fa5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，结果也将是:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="434e" class="mq lu in ls b gy ng nh l ni nj">My name is Davide, I'm a male of 37 years old! My favourite frameworks are:  Fastify, Angular, and Vue.</span></pre><p id="c75a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个结果表明箭头功能没有自己的<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>。相反，JavaScript解释器将在父范围内搜索，以确定它引用了什么。</p><h1 id="2e35" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><p id="37d9" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在本文中，我们仔细研究了<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>,以及它的范围是如何随着它的使用方式和位置而变化的。所以，如果你把这四个小规则应用到实践中，每次你在一个函数中找到关键字<code class="fe lp lq lr ls b"><strong class="kv io">this</strong></code>，你就能明白它指的是什么。目前:</p><pre class="kd ke kf kg gt nc ls nd ne aw nf bi"><span id="5387" class="mq lu in ls b gy ng nh l ni nj"><strong class="ls io">HAPPY, CODING!</strong></span></pre><h1 id="934f" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">文献学</h1><div class="nm nn gp gr no np"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this?retiredLocale=it" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">this - JavaScript | MDN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">与其他语言相比，函数的this关键字在JavaScript中的行为略有不同。它也有一些…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">developer.mozilla.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od km np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">function . prototype . bind()-JavaScript | MDN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">bind()方法创建了一个新函数，当调用该函数时，它的this关键字被设置为提供的值，并带有一个…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">developer.mozilla.org</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od km np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">function . prototype . call()-JavaScript | MDN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">调用时用作此的值。注意:在某些情况下，可能不是该方法看到的实际值。如果…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">developer.mozilla.org</p></div></div><div class="ny l"><div class="of l oa ob oc ny od km np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">箭头函数表达式- JavaScript | MDN</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">arrow函数表达式是传统函数表达式的一种紧凑替代形式，但它是有限的，不能…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">developer.mozilla.org</p></div></div><div class="ny l"><div class="og l oa ob oc ny od km np"/></div></div></a></div><p id="ec69" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nl">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>