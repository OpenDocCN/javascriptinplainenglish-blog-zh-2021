<html>
<head>
<title>Promises in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promises-in-typescript-27d887a8d380?source=collection_archive---------17-----------------------#2021-03-22">https://javascript.plainenglish.io/promises-in-typescript-27d887a8d380?source=collection_archive---------17-----------------------#2021-03-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/03c2d84ace3c4d3e7e1805f6646c3ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OOxyarVZhMoXxhJFHG0fQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/images/id-3047319/" rel="noopener ugc nofollow" target="_blank">Hopefully he has the candy you are looking for</a></figcaption></figure><p id="ef32" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下，你去店主那里买糖果。你要了一颗糖果，店主答应了(即承诺他/她会尽量给你一颗)。店主可能会花15秒或者2分钟找到你要的糖果，然后把它交给你。你下一步的行动取决于店主的反应。如果店主给你糖果，你付钱，然后吃掉它。如果店主说他们没有糖果，你可以要些别的或者继续。关键是在你采取任何行动之前，你要等待店主的承诺。这正是承诺在TypeScript中的工作方式。</p><p id="f035" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您正在构建一个应用程序，其中您需要执行一个异步任务，并且您希望下一个代码块等到异步任务完成后再执行它。这就是承诺发挥作用的地方。</p><h1 id="c5b0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.创造承诺</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b67b4a2a1ff650934902ba9885ed106e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YT5y4Qe1wSZfj4nugooTg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/photos/candy-sweetmeats-sweets-dessert-1961536/" rel="noopener ugc nofollow" target="_blank"><em class="ma">Trying to find this candy is the Promise</em></a></figcaption></figure><p id="929a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需创建一个promise类的对象，并将resolve和reject函数作为参数传递给构造函数，就可以创建一个Promise。在我们的类比中，这是我们店主的承诺。</p><blockquote class="mb mc md"><p id="a015" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">解决</em> </strong> —承诺成功时。(店主找到了糖果。)</p><p id="7a7a" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">拒绝</em> </strong> —承诺不成功时。(店主没有找到糖果。)</p></blockquote><pre class="lw lx ly lz gt mi mj mk ml aw mm bi"><span id="b32f" class="mn kz in mj b gy mo mp l mq mr">private tryToFindCandy(candyName: string): Promise&lt;boolean&gt;{<br/>  let findCandyPromise = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(()=&gt;{<br/>      if(candyExists(candyName)){<br/>         resolve(true);<br/>      } else {<br/>         reject(false)<br/>      }<br/>    }, 5000)<br/>  }) <br/>  return findCandyPromise;<br/>}</span></pre><p id="e2a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照我们的类比，我们有一个名为tryTo <em class="me"> FindCandy </em>的函数，它返回<em class="me">findCandyPromise</em>promise<em class="me">。</em>承诺解决，糖果存在则拒绝，糖果不存在则拒绝。(这在setTimeout函数内部，使函数异步)</p><p id="a47b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="me">注:</em> </strong> <em class="me">更实际的情况是，在findCandyPromise中会有一个API调用或文件读/写操作或任何类型的代码，需要一些时间来处理并获得响应。</em></p><h1 id="5339" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak"> 2。处理一个承诺</strong></h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/316803f7a641aa8d1a70e17e9eb0d15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9uAlahbmH1QDJ2hp2PoCg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/photos/hunger-hungry-eating-cookie-413685/" rel="noopener ugc nofollow" target="_blank">One way to handle the returned promise</a></figcaption></figure><p id="af3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以使用<strong class="kc io">然后<em class="me">、</em> catch最后</strong>来处理承诺。</p><ul class=""><li id="25b6" class="ms mt in kc b kd ke kh ki kl mu kp mv kt mw kx mx my mz na bi translated"><strong class="kc io">然后</strong> — <em class="me">承诺完成的时候。(</em> <strong class="kc io"> <em class="me">注:承诺是解决了还是拒绝了并不重要。只要有一个响应我们就到达那么块</em> </strong> <em class="me">)。这里我们可以有两个回调函数，一个用于已解决的承诺，另一个用于承诺被拒绝的情况。</em></li><li id="7873" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><strong class="kc io">捕捉</strong> — <em class="me">当承诺遇到运行时错误。(就像一个试抓块)</em></li><li id="97ee" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><strong class="kc io">最终</strong>——<em class="me">在执行完then/catch块后。(这用于执行一些需要在异步任务之后运行的操作，而不管异步任务中发生了什么。)</em></li></ul><p id="37a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的承诺会这样处理:</p><pre class="lw lx ly lz gt mi mj mk ml aw mm bi"><span id="01e6" class="mn kz in mj b gy mo mp l mq mr">private buyAndEatCandy(): void {<br/>  this.tryToFindCandy("Mars").then(res =&gt; {<br/>    payAndEat();         <strong class="mj io">// The Shopkeeper found the candy</strong><br/>  }, rej =&gt; {<br/>    askForAnotherCandy();<strong class="mj io">// The Shopkeeper couldn't find the candy</strong><br/>  }).catch(err =&gt; {<br/>    console.log("Something weird happened"); <strong class="mj io">// Some Runtime Error</strong><br/>  }).finally(() =&gt; {<br/>    goHome();            <strong class="mj io">// After all is said and done. Go Home :)</strong><br/>  })<br/>}</span></pre><p id="b37d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">恭喜你！现在你知道如何正确地创造和使用承诺。你可以用这个做很多事情。</p><p id="1fc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个函数可以调用多个异步函数。这就是承诺链和承诺分组的用武之地。</p><h1 id="2938" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak"> 3。连锁承诺</strong></h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e8389ab5d49e6a3b803f9ccd5d579b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6lhjvtw9zvIYpaEC5rvQg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/photos/chain-link-metal-strong-connect-690088/" rel="noopener ugc nofollow" target="_blank">One link after the other</a></figcaption></figure><p id="a2bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到我们的类比，假设你现在正在排队。店主现在必须给你一个承诺，完成它，转向下一个顾客，重复同样的事情。现在我们正在讨论一个接一个地运行多个异步任务。这就是承诺的连锁属性的来源。<strong class="kc io"> <em class="me">注意，下一个异步任务只有在前一个任务完成后才运行。</em> </strong></p><p id="abf1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在代码中加入承诺链:</p><pre class="lw lx ly lz gt mi mj mk ml aw mm bi"><span id="0c3f" class="mn kz in mj b gy mo mp l mq mr">private buyAndEatCandy(): void {<br/>  this.tryToFindCandy("Mars").then(res =&gt; {<br/>    payAndEat();<br/>    this.tryToFindCandy("Bounty").then(res =&gt; { <strong class="mj io">// Next customer</strong><br/>      payAndEat();<br/>      this.tryToFindCandy("Tobelorone").then(res =&gt; { <strong class="mj io">// Next one</strong><br/>        payAndEat();<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="034f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了简单起见，这里我们已经放弃了拒绝和错误处理模块。</p><h1 id="9ac0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4.分组承诺</h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2cbe2e4417c135fd3a16ac92da2deaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ib6LOfcyT1VXfNja1kJj-g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/photos/bonfire-camping-fire-flame-group-1867275/" rel="noopener ugc nofollow" target="_blank">Group your promises and keep them close</a></figcaption></figure><p id="a1aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们假设你正在治疗你的三个朋友，你把他们带来了。你们每个人心里都有不同的糖果。店主会倾听你们所有人的请求，向你们所有人承诺他会努力找到它，然后回来给你们所有人一个集体回复。<strong class="kc io">请注意，在你得到集体回应之前，需要完成所有的个人承诺。如果任何一个承诺被拒绝，你会得到一个集体拒绝。</strong></p><p id="ed63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们实现这一点的方法是创建一个充满这些承诺的数组。为了处理这个承诺数组，我们需要使用promise类的all方法来创建一个包含数组中所有这些承诺的新承诺。然后，我们可以在新创建的承诺上使用Then、catch和finally。</p><p id="42b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在代码中对一些承诺进行分组:</p><pre class="lw lx ly lz gt mi mj mk ml aw mm bi"><span id="f40a" class="mn kz in mj b gy mo mp l mq mr">private findCandyByNames(candyNames: Array&lt;string&gt;): {<br/>  let candyPromises;          <strong class="mj io">// This will hold all our promises</strong><br/>  for (let index = 0; index &lt; candyNames.length; index++){<br/>    let candyName = candyNames[index];<br/><strong class="mj io">    // Now we push promise returned from tryToFindCandy method we <br/>    // created before to an array for each one of the candy names.</strong><br/>    candyPromises.push(this.tryToFindCandy(candyName));<br/>  }<br/><strong class="mj io">  // Return a promise using all <br/>  </strong>let newPromise = Promise.all();<br/><strong class="mj io">  // Handle newPromise like any other promise<br/>  </strong>newPromise.then((res)=&gt;{<br/>    <strong class="mj io">// When all promises are resolved</strong><br/>    this.payAndEat();<br/>  }, (rej)=&gt;{<br/>    <strong class="mj io">// When any of the promises is rejected</strong><br/>    this.askForAnotherCandy();<br/>  }).catch(err =&gt; {<br/>    console.log("Some Runtime Error");<br/>  }). finally(()=&gt;{<br/>    <strong class="mj io">// When all the promises are either resolved or one of them is    //rejected</strong><br/>    this.goHome();<br/>  })<strong class="mj io">;</strong><br/>}</span></pre><p id="f93b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以并行(通过分组)或顺序(通过链接)处理多个异步方法。这两者都是非常强大的工具，并且是处理多异步代码块的干净方法。</p><h1 id="a6b4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak"> 5。即时承诺解决方案</strong></h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1040628227e85ece2329d95759884640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mD_pc6tTu-qB4f7uHFgs1Q.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://pixabay.com/photos/polaroid-camera-instant-photography-1245924/" rel="noopener ugc nofollow" target="_blank">Did someone say Instant?</a></figcaption></figure><p id="4be6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你也可以立即解决或拒绝承诺，就像这样:</p><pre class="lw lx ly lz gt mi mj mk ml aw mm bi"><span id="e058" class="mn kz in mj b gy mo mp l mq mr">let resolvedPromise = new Promise.resolve();<br/>let rejectedPromise = new Promise.reject();</span></pre><p id="f55d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这有一个非常合适的应用。其中一种情况是，您有一个函数，它有条件地执行一个异步任务并返回一个承诺。在这种情况下，即使异步代码不会运行，您也需要返回一个承诺。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="eb52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于承诺，这就是你需要知道的全部。只要确保你的店主信守承诺。没有人喜欢食言。</p></div></div>    
</body>
</html>