<html>
<head>
<title>4 Steps for Reusable User Wallet Logic in the Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端可重用用户钱包逻辑的4个步骤</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-steps-for-reusable-user-wallet-logic-in-frontend-1626d1cd126a?source=collection_archive---------16-----------------------#2021-07-08">https://javascript.plainenglish.io/4-steps-for-reusable-user-wallet-logic-in-frontend-1626d1cd126a?source=collection_archive---------16-----------------------#2021-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ea7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一次编写，随时随地使用。😎✌️</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/87f4cd88383f7065b75e4eaae7aa8a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QHP7VTI67wDhWeb"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@techdailyca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tech Daily</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="e6c1" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">在后台</h2><p id="4cc8" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这个想法从关于前端认证的可重用逻辑的最后一个故事开始。如果你还没有读过，我强烈建议给它一个机会，因为这个故事是一个故事链，我所有的文章最多需要7分钟来阅读😎。</p><div class="mh mi gp gr mj mk"><a href="https://shreyvijayvargiya26.medium.com/reusable-authentication-logic-in-frontend-beded754d4b7" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">前端中可重用的身份验证逻辑</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">一次编写，随时随地使用😎</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">shreyvijayvargiya26.medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kv mk"/></div></div></a></div><p id="94cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，让我们开始今天的故事，想法是编写可重用的前端逻辑来执行用户钱包系统。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="d908" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">概观</h2><p id="e1f2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这个想法很简单，每个与支付相关的移动应用都有自己的钱包系统。现在这种情况很常见，所以为什么不写一个可重用的基本逻辑，让它随时随地都可以使用。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="ed87" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">关键要求</h2><p id="ea54" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">前端业务中的每个钱包只需要很少的东西，这些是访问钱包和相应的<code class="fe mz na nb nc b">beneficialId</code>的令牌。我们甚至可以将这些细节存储在数据库中，但是与其通过网络获取数据，为什么不在前端编写逻辑呢？</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="0a8f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">要遵循的步骤</h2><p id="cc6a" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们整个逻辑的步骤包括以下内容-</p><ul class=""><li id="003b" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">创建初始用户钱包状态或全局存储</li><li id="16b1" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">创建相应的操作以在应用程序中启用用户钱包系统</li><li id="0569" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">创建一个操作来更新全局存储中的用户钱包详细信息。</li><li id="1b00" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">每次进行新交易时，重复使用用户钱包的详细信息</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="45cc" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">初始全局存储</h2><p id="b6a5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">如果您已经阅读了前面的故事，那么我们已经为用户创建了相同的默认全局状态。类似地，我们将为用户定义默认或初始钱包状态。您可以选择通过扩展在用户状态中定义状态，或者将钱包状态从用户数据状态中分离出来。</p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="65ec" class="lj lk iq nc b gy nv nw l nx ny">const initialState = {   <br/>   isUserLoggedIn: false,<br/>   loggedInUserData: { // user emails and id },<br/>   token: String,<br/>   userWalletData: { <br/>    beneficialId: String,<br/>    upiId: String<br/>    }<br/>};</span></pre><p id="0376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个故事，我只假设我们只存储用户<code class="fe mz na nb nc b">beneficialId</code>和UPI id。我们可以创建多个状态，例如，另一个UPI ID或相应的电子邮件连接到相应的UPI ID等等。您的产品提供的可扩展特性越多，您需要定义的状态就越多。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="dca4" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">启用钱包的操作</h2><p id="9bde" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">用户必须做的第一步也是最重要的一步是启用钱包系统。在大多数情况下，我们使用第三方支付或钱包系统，所以我们需要用户通过提供UPI id来启用它。</p><p id="52b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们进行网络调用或API调用，以获取相应的用户详细信息，如电子邮件和用户UPI id的授权确认。该步骤基本上是在启用钱包系统之前的确认检查，以防止任何误用，尤其是当应用程序被外来实体使用时。</p><p id="a8a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦网络调用给出了关于用户钱包细节和UPI id的绿色信号，我们就从同一个网络调用中获取用户<code class="fe mz na nb nc b">beneficialId</code>，作为响应，我们可以将它存储在我们的<code class="fe mz na nb nc b">userWalletData</code>中的全局存储中。</p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="7fa1" class="lj lk iq nc b gy nv nw l nx ny">function setUserWallet({ upiId, beneficialId }{<br/>   initialState.userWalletData.upiId = upiId;<br/>   initialState.userWalletData.beneficialId = beneficialId;<br/>};</span><span id="2449" class="lj lk iq nc b gy nz nw l nx ny">async function enableUserWallet(upid){<br/>  const response = await.post('/enable-wallet', { upi: upi });<br/>  if(response.success){ <br/>   setUserWallet({ upidId, beneficialId: response.benefialId });<br/>  };<br/>};</span></pre><p id="e671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的过程中，我们可以通过在post请求的主体中提供UPI id来进行网络调用，一旦响应成功，我们就可以在全局存储中使用用户<code class="fe mz na nb nc b">UPI</code> id来设置用户<code class="fe mz na nb nc b">beneficialId</code>。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="cbf9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">进行交易的行动</h2><p id="5404" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">如果您查看默认的初始状态，我们也已经定义了令牌，现在是使用令牌的时候了。用户进行的每一笔交易都必须是安全的，所以大多数时候，我们的服务器会检查用户是否经过授权和认证，这仅由令牌进行检查。</p><p id="f820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦用户成功登录到我们的应用程序，我们就存储这个令牌，现在为了进行每一个新的交易，我们必须在POST请求的头中提供这个令牌以及交易的金额。</p><p id="904f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数情况下，令牌也可能是由第三方提供的，您将使用该第三方的钱包，因此在网络调用中对用户UPI id进行身份验证时，我们会得到两个响应:<code class="fe mz na nb nc b">beneficialId</code>和交易令牌。因此，在这种情况下，您可以用一个密钥存储新令牌，如<code class="fe mz na nb nc b">transactionToken</code></p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="830a" class="lj lk iq nc b gy nv nw l nx ny">const initialState = {   <br/>   isUserLoggedIn: false,<br/>   loggedInUserData: { // user emails and id },<br/>   token: String,<br/>   <!-- -->userWalletData: { <br/>    beneficialId: String,<br/>    upiId: String<br/>    }<br/>    <!-- -->transactionToken: String, // token recived with <!-- -->beneficialId<br/>};</span></pre><p id="a68b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的部分是进行交易。每笔交易都需要一个令牌在头部，金额在请求体，如果交易成功，我们得到交易细节，如id，我们可以存储的<code class="fe mz na nb nc b">transactionStatus</code>告诉交易成功。</p><p id="7834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们甚至可以在初始状态下存储事务的细节，这是你的选择，但我建议只存储少量的事务细节，否则<code class="fe mz na nb nc b">intitalState</code>的大小会增加，并可能导致性能问题。</p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="567d" class="lj lk iq nc b gy nv nw l nx ny">function setTransaction({ transactionId,amount,transactionStatus }{<br/>   initialState.traactions.push = <br/>        { <br/>           transactionId, <br/>           amount, <br/>           transactionStatus  <br/>        }<br/>};</span><span id="25fc" class="lj lk iq nc b gy nz nw l nx ny">async function enableUserWallet(upid){<br/>  const response = await.post('/enable-transation', <br/>   { upi: upi });<br/>  if(response.success){ <br/>   setUserWallet({ upidId, beneficialId: response.benefialId });<br/>  };<br/>};<br/>function makeTransation({ amount, beneficalId, token }){<br/>  const response = await axios.get('/make-transaction', <br/>   headers: {<br/>     token: Bearer token<br/>   }<br/>   {<br/>     body: { amount, beneficialId  } <br/>   }<br/>  );<br/>  if(response.success){<br/>    setTransaction({ <br/>     transactionId: response.transactionId, <br/>     amount: amount,<br/>     transactionStatus: true<br/>     })<br/>  }else {<br/>     setTransaction({ <br/>       transactionId: response.transactionId, <br/>       amount: amount,<br/>       transactionStatus: false<br/>     })}<br/>  }<br/>}</span></pre><p id="127f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在网络呼叫响应的基础上，我们设置交易状态，以向用户给出关于交易的适当指示。这是钱的问题，所以对交易给出适当的指示对产生信任非常重要。</p><p id="f001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们最终的全球商店将如下所示-</p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="a359" class="lj lk iq nc b gy nv nw l nx ny">const initialState = {   <br/>   isUserLoggedIn: false,<br/>   loggedInUserData: { // user emails and id },<br/>   token: String,<br/>   <!-- -->userWalletData: { <br/>    beneficialId: String,<br/>    upiId: String<br/>    }<br/>    <!-- -->transactionToken: String, // token recived with <!-- -->beneficialI<br/>    transactions: [<br/>       transactionId: String, <br/>       amount: Number,<br/>       transactionStatus: Boolean<br/>     ]<br/>};</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="41d4" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">结论</h2><p id="2ccc" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">同样，这个逻辑是基本的基础，每次和大多数情况下，这个逻辑都是围绕这个概念解决的。所以我们的想法是创造一次，随时随地使用。</p><p id="8b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有讽刺意味的是，我们正在使用相同的逻辑在我们即将发布的网站(<a class="ae lb" href="http://www.ihatereading.in" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> iHateReading </strong> </a>)中启用钱包支付系统。因此，您可以信任流程和逻辑，并根据自己的方便修改它。</p><p id="a276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天就到这里吧，下次再见，祝你愉快。</p><pre class="km kn ko kp gt nr nc ns nt aw nu bi"><span id="5874" class="lj lk iq nc b gy nv nw l nx ny">For more such stories, Our wesbite - 💻 <a class="ae lb" href="http://www.ihatereading.in" rel="noopener ugc nofollow" target="_blank"><strong class="nc ir">iHateReading</strong></a></span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="ae82" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">更多阅读</h2><div class="mh mi gp gr mj mk"><a rel="noopener  ugc nofollow" target="_blank" href="/forget-the-browser-drag-drop-api-this-library-is-perfect-to-add-drag-and-drop-feature-f2a1a9e7d8e3"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">在你的网络应用中开发拖放功能</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">与React DnD合作，将拖放功能添加到您的网站</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mt l"><div class="oa l mv mw mx mt my kv mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://medium.com/codex/there-are-high-chances-that-redux-will-be-replaced-98f1c469bcce" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">redux很有可能被取代</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">看看redux的竞争对手，redux很有可能在未来被取代。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="ob l mv mw mx mt my kv mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://medium.com/nerd-for-tech/forms-and-validation-in-react-6f185108037f" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">React中的表单和验证</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">React钩子形式入门。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="oc l mv mw mx mt my kv mk"/></div></div></a></div><p id="c3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="od">更多内容尽在</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="od">plain English . io</em></a></p></div></div>    
</body>
</html>