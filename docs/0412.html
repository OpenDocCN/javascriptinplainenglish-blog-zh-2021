<html>
<head>
<title>Authentication and Authorization with JWT in a GraphQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GraphQL服务器中使用JWT进行认证和授权</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/authentication-and-authorization-with-jwt-in-a-graphql-server-d9cf6085f961?source=collection_archive---------3-----------------------#2021-01-25">https://javascript.plainenglish.io/authentication-and-authorization-with-jwt-in-a-graphql-server-d9cf6085f961?source=collection_archive---------3-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/40eb134ac874a0a4afb9132b343353c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRyepp44EvCHsrlQn6OF6A.jpeg"/></div></div></figure><p id="37a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个项目的安全和建设它一样重要。有时候，我们希望我们的数据只被之前注册的人访问，而不是所有人。我们为此提供了<strong class="jx io">认证</strong>。</p><p id="492c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时我们不希望每个人都访问每个数据和API。我们为此提供了<strong class="jx io">授权</strong>的概念。</p><p id="9e6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将讨论如何通过使用<strong class="jx io"> jsonwebtoken (jwt) </strong>和<strong class="jx io"> graphql-shield </strong>库在服务器端提供<em class="kt">授权</em>和<em class="kt">认证</em>。我将使用<strong class="jx io"> GraphQL </strong>在<strong class="jx io"> Node.js </strong>中构建服务器。然后，我将使用我们通过<em class="kt"> jwt </em>生成的<strong class="jx io">访问令牌</strong>进行登录。之后，我将使用<em class="kt"> graphql-shield </em>函数来决定允许哪个登录用户访问哪个API。</p><p id="e380" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建完服务器后，我将举例说明如何从客户端向这些GraphQL API发送请求。</p><p id="dcf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将使用<strong class="jx io"> Visual Studio代码</strong>作为IDE，使用<strong class="jx io"> Angular </strong> 11作为客户端，我假设您熟悉<em class="kt"> GraphQL </em>、<em class="kt"> Angular </em>和<em class="kt"> Node.j </em> s。如果您不熟悉这些概念，您可以在<a class="ae ku" href="https://medium.com/javascript-in-plain-english/building-graphql-server-with-node-js-c31ee3f54761" rel="noopener">这篇文章</a>中找到一些关于如何在<em class="kt">node . js</em>中构建<em class="kt"> GraphQL </em>服务器的信息</p><h1 id="450c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">JSON Web令牌(jwt)</h1><p id="73a2" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated"><strong class="jx io"> jwt </strong>的结构我就不说了。但是短暂的；<em class="kt"> jwt </em>是一种标准，它允许信息以加密的形式作为<em class="kt"> JSON对象</em>在各方之间传输。如果你用jwt 加密数据，你用一个特殊的字符串签名。同样，需要此签名来解密数据的传输位置。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/3f3abb07042e324014bf0b57b4f18633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TKTXHi029R_XJnUrYgUCA.jpeg"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">The structure of a jsonwebtoken</figcaption></figure><h1 id="0622" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">graphql-shield</h1><p id="4668" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated"><strong class="jx io"> graphql-shield </strong>是一个库，帮助你创建一个<em class="kt">权限层</em>来访问你用<em class="kt"> GraphQL </em>创建的API。有了这个库，你可以随心所欲地定义<em class="kt">认证</em>和<em class="kt">授权</em>的规则，并将它们应用于你想要的API。</p><p id="e5c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在创建我们的项目。我首先从<em class="kt">服务器端</em>开始:</p><p id="4fd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在将要创建项目的文件中创建文件<strong class="jx io"> package.json </strong>:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="458c" class="mm kw in mi b gy mn mo l mp mq">npm-init -y</span></pre><p id="bbbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我安装了两个提供语法便利的包:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="45f4" class="mm kw in mi b gy mn mo l mp mq">npm install babel-cli babel-preset-es2015</span></pre><p id="8a2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我将安装带有<strong class="jx io"> graphql-yoga </strong>的<em class="kt"> GraphQL-Server </em>，所以我正在安装相关的包:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="94d9" class="mm kw in mi b gy mn mo l mp mq">npm install graphql-yoga</span></pre><p id="d71a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我安装了<em class="kt">认证</em>和<em class="kt">授权</em>的必要包:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="e956" class="mm kw in mi b gy mn mo l mp mq">npm install jsonwebtoken graphql-shield</span></pre><p id="86a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们安装了必要的软件包。现在让我们添加我们将使用的数据。因为我不会使用数据库，所以我将包含一些用户信息的名为<strong class="jx io">用户</strong>的数组添加到名为<strong class="jx io"> data.js </strong>的文件中，并导出它:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="83ac" class="mm kw in mi b gy mn mo l mp mq">const Users = [<br/> {<br/>   id: 1,<br/>   username: “john”,<br/>   city: “Melbourne”,<br/>   password: “123456”, <br/>   role: “admin”,<br/> },<br/> {<br/>   id: 2,<br/>   username: “samet”,<br/>   city: “Istanbul”,<br/>   password: “123”,<br/>   role: “user”,<br/> },<br/> {<br/>   id: 3,<br/>   username: “maria”,<br/>   city: “Zagreb”,<br/>   password: “456”,<br/>   role: “user”,<br/> },<br/>];</span><span id="a50a" class="mm kw in mi b gy mr mo l mp mq">module.exports = Users;</span></pre><p id="9438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了eas代码的可读性，我为<em class="kt"> GraphQL </em>的两个主要概念创建了两个单独的文件；<strong class="jx io">类型定义</strong>和<strong class="jx io">解析器</strong>:</p><p id="e448" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个<strong class="jx io"> TypeDefs.js </strong>文件，并添加了以下代码:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="ad11" class="mm kw in mi b gy mn mo l mp mq">const typeDefs = `<br/>  type Query {<br/>    users: [User!]!<br/>    login(username:String!, password:String!): String<br/>  }  </span><span id="f72c" class="mm kw in mi b gy mr mo l mp mq">  type Mutation{<br/>    addUser(id:ID!, username:String!, city:String! ): [User]<br/>  }  <br/>  <br/>  type User{<br/>    id: ID!<br/>    username: String!<br/>    password: ID!<br/>    role: String!<br/>    city: String!<br/>  }<br/>`;</span><span id="a745" class="mm kw in mi b gy mr mo l mp mq">module.exports = typeDefs;</span></pre><p id="3dcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<strong class="jx io">“users”</strong>函数是获取所有用户的函数。<strong class="jx io">“登录”</strong>功能将执行<em class="kt">认证</em>。<strong class="jx io">“addUser”</strong>是向数组中添加新用户的函数。</p><p id="8df7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了<strong class="jx io"> resolvers.js </strong>文件，并添加了以下代码:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="7136" class="mm kw in mi b gy mn mo l mp mq">import Users from “./data”;<br/>import jwt from “jsonwebtoken”;</span><span id="d948" class="mm kw in mi b gy mr mo l mp mq">const resolvers = {<br/>  Query: {<br/>    users: async (parent, args) =&gt; {<br/>      return Users;<br/>    },<br/>    login: async (_, { username, password }) =&gt; {<br/>      let user = Users.find((u) =&gt; u.username === username &amp;&amp; u.password === password<br/>    );<br/>    if(user){<br/>     const token = jwt.sign(<br/>      {username: user.username, password: user.password, role:   user.role }, “MY_TOKEN_SECRET”);<br/>      return token;    } else return "unknown user"<br/>  },<br/>},  </span><span id="2ea5" class="mm kw in mi b gy mr mo l mp mq">  Mutation: {<br/>    addUser: async (_, { id, username, city }) =&gt; {<br/>      const newUser = {<br/>        id: id,<br/>        username: username,<br/>        city: city,<br/>      };<br/>      Users.push(newUser);<br/>     return Users;<br/>    },<br/>  },<br/>};</span><span id="aa5c" class="mm kw in mi b gy mr mo l mp mq">module.exports = resolvers;</span></pre><h1 id="f56e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">证明</h1><p id="99c8" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">这里我们看到<em class="kt"> jsonwebtoken (jwt) </em>被用在<strong class="jx io">“登录”</strong>函数中。这将通过用户名和密码信息检查客户端发送的用户信息是否在服务器上的数组中(通常在数据库中)。这就是<strong class="jx io">认证</strong>。如果数据库中存在该用户，则使用<em class="kt"> jwt的</em> <strong class="jx io">生成一个<strong class="jx io">令牌</strong>。sign() </strong>方法并发送给客户端。这个<em class="kt">令牌</em>保存在客户端<strong class="jx io"> </strong>的<strong class="jx io"> localStorage </strong>中，当请求访问API时，这个令牌信息也会随请求一起发送。</p><p id="475b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在生成<em class="kt">令牌</em>时，我们可以在<strong class="jx io">声明</strong>时提供我们想要的信息。这里<em class="kt">用户名</em>，<em class="kt">密码</em>，以及<em class="kt">角色</em>信息我给了。还必须给出一个密钥字符串值，我们用它来签署令牌。在示例中，我使用了“<em class="kt">MY _ TOKEN _ SECRET”</em>字符串。这个密钥也将用于解码令牌。</p><p id="5ff1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们创建<strong class="jx io"> index.js </strong>文件，并添加以下代码。</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="7939" class="mm kw in mi b gy mn mo l mp mq">import { GraphQLServer } from “graphql-yoga”;<br/>import jwt from “jsonwebtoken”;<br/>import { rule, shield, and, or, not } from “graphql-shield”;<br/>import typeDefs from "./TypeDefs";<br/>import resolvers from "./resolvers";</span><span id="6f3f" class="mm kw in mi b gy mr mo l mp mq">function getClaims(req) {<br/>  let token;<br/>  try {<br/>    token = jwt.verify(req.request.headers.authorization, “MY_TOKEN_SECRET”);<br/>  } catch (e) {<br/>    return null;<br/>  }<br/>  console.log(token);<br/>  return token;<br/>}</span><span id="4376" class="mm kw in mi b gy mr mo l mp mq">// Rules<br/>const isAuthenticated = rule()(async (parent, args, ctx, info) =&gt; {<br/>  return ctx.claims !== null;<br/>});</span><span id="362c" class="mm kw in mi b gy mr mo l mp mq">const canAddUser = rule()(async (parent, args, ctx, info) =&gt; {<br/>  return ctx.claims.role === “admin”;<br/>});</span><span id="5fb8" class="mm kw in mi b gy mr mo l mp mq">// Permissions<br/>const permissions = shield({<br/>  Query: {<br/>    users: and(isAuthenticated),<br/>  },<br/>  Mutation: {<br/>    addUser: and(isAuthenticated, canAddUser),<br/>  },<br/>});</span><span id="65bd" class="mm kw in mi b gy mr mo l mp mq">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers,<br/>  middlewares: [permissions],<br/>  context: (req) =&gt; ({<br/>    claims: getClaims(req),<br/>  }),<br/>});</span><span id="9202" class="mm kw in mi b gy mr mo l mp mq">server.start({ port: 4000 }, () =&gt;<br/>  console.log(“Server is running on http://localhost:4000")<br/>);</span></pre><p id="3652" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> GraphQLServer </strong>构造函数中，我们看到除了传递<em class="kt">typedef</em>和<em class="kt">解析器</em>之外，还传递了<strong class="jx io">中间件</strong>和<strong class="jx io">上下文</strong>参数。首先我要讲一下<em class="kt">语境</em>的概念。</p><h1 id="27aa" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">GraphQL中的上下文参数</h1><p id="9dec" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated"><em class="kt">解析器</em>中的<strong class="jx io">上下文</strong>是一个特定执行的所有<em class="kt">解析器</em>共享的对象。它对于保存数据很有用，比如<em class="kt">认证</em>信息、当前用户、数据库连接、数据源以及运行业务逻辑所需的其他东西。</p><p id="187c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的上下文对象被传递给每一层的每一个解析器，所以我们可以在模式代码中的任何地方访问它。它接收的<strong class="jx io"> req </strong>对象保存请求信息。这个<em class="kt">请求</em>还包括客户端发送的<em class="kt">令牌</em>信息。由<strong class="jx io">决定。我们在上下文中定义的getClaims() </strong>函数使用<strong class="jx io">对<em class="kt">令牌</em>进行解码。验证<em class="kt"> jwt对象</em>的()</strong> <em class="kt"> </em>方法，从<em class="kt">令牌</em>中获取<em class="kt">声明</em>。</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="bdc7" class="mm kw in mi b gy mn mo l mp mq">function getClaims(req) {<br/>  let token;<br/>  try {<br/>    token = jwt.verify(req.request.headers.authorization, “MY_TOKEN_SECRET”);<br/>  } catch (e) {<br/>    return null;<br/>  }<br/>  console.log(token);<br/>  return token;<br/>}</span></pre><p id="5e39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当我们从客户端向服务器发送请求时，<strong class="jx io"> getClaims() </strong>方法运行并返回解码后的<em class="kt">令牌</em>。如上所示，您可以在控制台中看到解码后的令牌。</p><h1 id="55ac" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">批准</h1><p id="b017" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">根据我们的场景，请求附带的<em class="kt">声明</em>信息中有一个<strong class="jx io">“role”</strong>字段。根据这个角色信息，我们在<em class="kt"> graphql-shield </em>库的帮助下定义规则。比如说；我们希望用户登录后访问<strong class="jx io">“用户”</strong>功能。归档的<em class="kt">【角色】</em>是<em class="kt">【用户】</em>还是<em class="kt">【管理员】</em>并不重要。为此，我编写了以下代码。</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="a5ad" class="mm kw in mi b gy mn mo l mp mq">const isAuthenticated = rule()(async (parent, args, ctx, info) =&gt; {<br/>  return ctx.claims !== null;<br/>});</span></pre><p id="0a45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据我们用。<strong class="jx io"> rule() </strong>函数在<em class="kt"> graphql-shield </em>库中，如果<em class="kt">声明</em>不为<strong class="jx io"> null </strong>，即如果user-credentials正确，则用户有权访问<strong class="jx io">【users】</strong>函数。换句话说，使用用户凭证登录程序就足以访问<strong class="jx io">“用户”</strong>功能。</p><p id="1cf7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，根据场景，您需要成为<strong class="jx io">【admin】</strong>才能向程序添加新用户。我们用以下代码为此指定了规则:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="f5c7" class="mm kw in mi b gy mn mo l mp mq">const canAddUser = rule()(async (parent, args, ctx, info) =&gt; {<br/>  return ctx.claims.role === “admin”;<br/>});</span></pre><p id="244b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们定义了一个<strong class="jx io">屏蔽</strong>来指示这些规则将应用于哪些功能。</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="98b9" class="mm kw in mi b gy mn mo l mp mq">// Permissions<br/>const permissions = shield({<br/>  Query: {<br/>    users: and(isAuthenticated),<br/>  },<br/>  Mutation: {<br/>    addUser: and(isAuthenticated, canAddUser),<br/>  },<br/>});</span></pre><p id="7bce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，函数的类型是<strong class="jx io">查询</strong>还是<strong class="jx io">变异</strong>很重要，正如<em class="kt"> typeDefs </em>中定义的那样。</p><p id="049b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过<strong class="jx io">中间件</strong>参数将这些规则(权限)传递给服务器；</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="9bfe" class="mm kw in mi b gy mn mo l mp mq">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers,<br/>  middlewares: [permissions],<br/>  context: (req) =&gt; ({<br/>    claims: getClaims(req),<br/>  }),<br/>});</span></pre><p id="b410" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的服务器现在已经准备好测试它的<em class="kt">认证</em>和<em class="kt">授权</em>设置。最后，我将下面的代码添加到<em class="kt"> package.json </em>文件中的<strong class="jx io">脚本</strong>节点下:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="ffa2" class="mm kw in mi b gy mn mo l mp mq">“start”: “nodemon index.js — exec babel-node — presets es2015”,</span></pre><p id="0f58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在项目文件所在的终端上编写了以下命令。</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="75b1" class="mm kw in mi b gy mn mo l mp mq">npm start</span></pre><p id="9cb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以在<strong class="jx io">游乐场UI </strong>中测试代码了。(如果您的电脑上没有安装<strong class="jx io">“nodemon”</strong>，您可以通过<strong class="jx io">“NPM I nodemon”</strong>命令安装)</p><p id="1164" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，你只能在<em class="kt">游乐场</em> UI <em class="kt"> </em>显示屏上测试<strong class="jx io">“登录”</strong>功能。因为我们还没有为它设定一个<em class="kt">授权</em>规则。为了测试另外两个功能，你可以从Angular下载<a class="ae ku" href="https://github.com/azizkale/Angular-Project-for-Authentication-and-Authorization-in-GraphQL-Server" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">向这个服务器发送请求的项目</strong> </a>。或者，在控制台中，您可以获得您用<strong class="jx io">“log in”</strong>函数生成的令牌，并将它们分配给。<em class="kt"> getClaims() </em>函数同<strong class="jx io">复制/粘贴</strong>。</p><p id="25d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在未授权交易的情况下，将出现以下屏幕:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/281bd210ee083b80e62517ca631d54b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgkHZXkf3dpovNLJf8sIPg.jpeg"/></div></div></figure><p id="1d6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您下载并运行相关的客户端项目时，它将在端口<strong class="jx io"> 4200 </strong>上运行。您的服务器端项目也应该在<strong class="jx io"> 4000 </strong>端口上运行(默认情况下已经在4000上运行了。)</p><p id="cc9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">登录屏幕将向您问候:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/9eaf5e426eef0db03c2c08df36e78537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CzcnJdI3bGTL1m23lxyLQ.jpeg"/></div></div></figure><p id="f692" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们用以下用户信息来创建我们的示例请求:</p><pre class="lz ma mb mc gt mh mi mj mk aw ml bi"><span id="f0cf" class="mm kw in mi b gy mn mo l mp mq">{<br/>   id: 2,<br/>   username: “samet”,<br/>   city: “Istanbul”,<br/>   password: “123”,<br/>   role: “user”,<br/>}</span></pre><p id="4237" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您输入<em class="kt">用户名</em>和<em class="kt">密码</em>时，<strong class="jx io">用户列表按钮</strong>会起作用。因为该按钮触发服务器上的<strong class="jx io">【用户】</strong>功能，您只需登录即可使用该功能。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/e67c00fc7059b46d80a437e768f50e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dqCZAAaiGu6VGc9t-APvA.jpeg"/></div></div></figure><p id="d43b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，该用户将无法添加新用户，因为角色值不是<strong class="jx io">“admin”</strong>。如果您尝试使用左侧的<strong class="jx io">添加新用户</strong>部分添加新用户，您将得到以下警告:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/dec75a0a5daa6aa84bca6d81c92d6ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIipm0nO0ODfQohb9TGjJQ.jpeg"/></div></div></figure><p id="5d06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制台上的错误信息里写着:<strong class="jx io"> <em class="kt">“未授权！”</em>T53】。这意味着未经授权的操作。</strong></p><p id="6a25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用用户John的信息发出另一个请求，他的角色是<strong class="jx io">“admin”</strong>。</p><h1 id="8041" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">包扎</h1><p id="2c3d" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在<strong class="jx io"> Node.js </strong>中，我们已经看到了如何在使用<strong class="jx io"> GraphQL </strong>构建的服务器上创建<strong class="jx io">认证</strong>和<strong class="jx io">授权</strong>结构。然后，我们通过从预先准备好的客户端项目向该服务器发送请求来观察结果。</p><p id="e4f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以通过<a class="ae ku" href="https://github.com/azizkale/Authentication-and-Autorization-in-GraphQL-Server-with-Node.js" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">这个链接</strong> </a>到达服务器端项目。</p><h2 id="c6a2" class="mm kw in bd kx mw mx dn lb my mz dp lf kg na nb lj kk nc nd ln ko ne nf lr ng bi translated">进一步阅读</h2><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/i-built-a-serverless-live-chat-app-with-next-js-fauna-and-wundergraph-for-graphql-live-queries-b671d9646f6"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">我用Next.js、Fauna和WunderGraph为GraphQL实时查询构建了一个无服务器的实时聊天应用程序</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">使用无服务器技术创建可扩展的实时聊天应用程序的分步指南，来自…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://plainenglish.io/blog/how-to-build-a-graphql-ecommerce-app-from-scratch" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">如何从头开始构建一个GraphQL电子商务应用程序</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这就是你要建造的东西！埃森哲的一项调查(19个国家的20，000多名消费者)发现，47%的人…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">简明英语. io</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://plainenglish.io/blog/how-to-compose-and-integrate-apis-together-as-if-you-were-using-npm-for-apis" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">如何将API组合和集成在一起，就像您正在使用API的NPM一样</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">将两个API整合到一个应用程序中，该应用程序显示了历史上最大的音乐会，按国家首都排列。与……</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">简明英语. io</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny jt nk"/></div></div></a></div><p id="d236" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容看</em> <a class="ae ku" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">说白了就是</em> </strong> </a> <em class="kt">。报名参加我们的</em> <a class="ae ku" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。关注我们关于</em> <a class="ae ku" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">推特</em> </strong> </a>，<a class="ae ku" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">领英</em> </strong> </a> <em class="kt">，</em><a class="ae ku" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">YouTube</em></strong></a><em class="kt">，以及</em> <a class="ae ku" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">不和</em> </strong> </a> <em class="kt">。对增长黑客感兴趣？检查</em> <a class="ae ku" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">电路</em> </strong> </a> <em class="kt">。</em></p></div></div>    
</body>
</html>