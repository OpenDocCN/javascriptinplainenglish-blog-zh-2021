<html>
<head>
<title>Building a Pokedex with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React构建Pokedex</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-pokedex-with-react-7b7410db441a?source=collection_archive---------1-----------------------#2021-03-04">https://javascript.plainenglish.io/building-a-pokedex-with-react-7b7410db441a?source=collection_archive---------1-----------------------#2021-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="298c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">必须抓住他们！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/072852687d6f3e8f7195dcee34cc5893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EctvzSDOlwqeH13R6YBYOw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@thimo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thimo Pedersen</a> on <a class="ae kv" href="https://unsplash.com/s/photos/pokemon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗨黑客们！我决定使用Pokemon API构建一个React应用程序，只是为了好玩。我认为这将是展示React有多强大的一个很好的方式，并且对任何刚入门的人来说都是一个有趣的教程。这个博客将有多个部分，因为我也将在这个系列中包括造型。说了这么多，让我们开始把他们都抓起来。</p><h2 id="038e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">用户故事</h2><p id="ef84" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我收到的最重要的建议之一是学习如何“在反应中思考”我们希望在进入构建部分之前就获得应用程序的良好结构。对于这个个人Pokedex，我希望用户能够看到所有可用的口袋妖怪。然后，我希望他们能够导航到每个口袋妖怪的个人页面，查看更多有关它的信息，然后也能够“抓住”口袋妖怪说。最后，正如项目标题所暗示的，我希望用户能够查看他们的个人Pokedex，里面有他们所有“被抓”的口袋妖怪。</p><h2 id="faed" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">组件树</h2><p id="2c5e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">既然我们已经知道了我们的应用程序应该为用户做什么，让我们开始“反应式思考”React是基于组件的。以下是React的官方术语:</p><blockquote class="mq mr ms"><p id="9aab" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">从概念上讲，组件就像JavaScript函数。它们接受任意输入(称为“props”)并返回描述屏幕上应该显示什么的React元素。</p></blockquote><p id="8a40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要这个项目的一些不同的组件和容器。在我看来，我们需要一个<code class="fe mx my mz na b">AllPokemon.js</code>容器来负责包含名为<code class="fe mx my mz na b">PokemonCard.js</code>的单个组件。每个<code class="fe mx my mz na b">PokemonCard</code>应该有一个<code class="fe mx my mz na b">onClick</code>监听器，这将允许我们导航到他们的个人页面，这将是一个名为<code class="fe mx my mz na b">Pokemon.js</code>的组件。最后，我们将需要一个<code class="fe mx my mz na b">Pokedex.js</code>，它将是一个容器，有条件地只呈现“捕获的”<code class="fe mx my mz na b">PokemonCard</code> s。</p><h2 id="1e99" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">创建-反应-应用</h2><p id="da7d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好了，我们对这个项目应该如何运作和一个总体结构有了一个想法。我将在博客的底部分享我的代码，给那些想边写边检查的人。先从<code class="fe mx my mz na b">create-react-app</code>开始吧。这是一个让你的项目快速启动并运行的好工具。<code class="fe mx my mz na b">create-react-app</code>在引擎盖下做大量工作，帮助快速行动。关于这些工作的更多信息，你可以在这里查看文档<a class="ae kv" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="dbbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是在您想要的位置运行以下代码:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="ba8f" class="ls lt iq na b gy nf ng l nh ni">npx create-react-app personal-pokedex</span></pre><p id="ddcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，您应该会在终端中看到一条成功消息。确保你在正确的目录中。一旦你这样做了，你就可以运行<code class="fe mx my mz na b">yarn start</code>或<code class="fe mx my mz na b">npm start</code>。我将在整个项目中使用<code class="fe mx my mz na b">yarn</code>终端命令，但两者都可以，这完全是个人喜好。如果一切正常，您应该会看到这个可爱的屏幕:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/683233e54599ea2808db332e311a1f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNZ57FqFvKex-W6eiUNs3A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">create-react-app welcome screen</figcaption></figure><p id="5229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！！现在，让我们删除提供的样板文件来清理一下。在<code class="fe mx my mz na b">App.js</code>我们可以删除一堆代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b739" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以删除提供的样板文件中第6行<code class="fe mx my mz na b">div</code>之后的所有代码。我们还可以删除徽标和CSS文件的导入。您可以随意从目录中删除这两个文件，因为我们将在教程的后面编写自己的CSS。</p><p id="aff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你删除了所有的样板文件，让我们添加一个测试标题到我们的<code class="fe mx my mz na b">div</code>中，以确保一切都正确连接，我们可以看到我们有多棒。</p><p id="6424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也通过使用箭头函数将我们的<code class="fe mx my mz na b">App.js</code>函数调用转换成ES6语法。</p><p id="00d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的<code class="fe mx my mz na b">App.js</code>现在长这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="dd44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经从文件树中移除了<code class="fe mx my mz na b">App.css</code>和徽标文件。呜！现在让我们做些东西吧！</p><h2 id="cfa4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">制作我们的第一个容器</h2><p id="f81c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好的，还记得很多个月前我们讨论组件树的时候，让我们开始制作那些坏男孩吧。首先，在<code class="fe mx my mz na b">src</code>中，我将创建一个名为<code class="fe mx my mz na b">containers</code>的文件夹。是的，超级原创！在<code class="fe mx my mz na b">containers</code>里面，我会做一个名为<code class="fe mx my mz na b">AllPokemon.js</code>的文件。我将使这个容器成为一个功能性的容器。GeeksForGeeks在区分功能组件和类组件方面做得很好，这些信息可以在这里找到。下面是我的<code class="fe mx my mz na b">AllPokemon.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="05ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我知道你不能在浏览器中看到它，所以让我们把它连接起来！在<code class="fe mx my mz na b">App.js</code>中，我们可以进行第一次导入。要导入组件，请使用以下语法:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="6d70" class="ls lt iq na b gy nf ng l nh ni">import ComponentName from './containers/AllPokemon</span></pre><p id="df27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">./</code>指的是我们的文件路径。因为我们在<code class="fe mx my mz na b">App.js</code>中，它只是松散地挂在我们的<code class="fe mx my mz na b">src</code>控制器中，所以我们必须向上一级(<code class="fe mx my mz na b">./</code>)进入我们的容器文件夹并找到<code class="fe mx my mz na b">AllPokemon.js</code>。您可以将<code class="fe mx my mz na b">.js</code>从导入调用中去掉，因为React会自动计算出来。一旦导入了文件，就可以使用像这样的自结束标签在代码中引用它。</p><p id="a520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="81de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的浏览器中，“私人口袋妖怪”和“我拥有所有口袋妖怪!”！!"应该显示出来。现在我打赌你想看那些可爱的口袋妖怪！所以我们去捡吧！</p><h2 id="d92c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">获取到PokeApi</h2><p id="5431" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在<code class="fe mx my mz na b">src</code>文件夹中，我将创建一个文件夹来保存我们的服务调用，这样我们就可以在容器和组件之外进行获取。我将这个文件夹命名为<code class="fe mx my mz na b">services</code>，在里面我将有一个文件，它对于每次读取都是不同的。对于我们的<code class="fe mx my mz na b">AllPokemon</code> fetch调用，我将有一个名为<code class="fe mx my mz na b">pokemons.js</code>的文件(是的，我知道Pokemon的复数就是Pokemon，我也讨厌它，但我不知道还能叫它什么！).我首先将URL声明为文件顶部的<code class="fe mx my mz na b">const</code>,然后发出一个获取请求。获取文档真的很棒，我在这里<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">链接了那个</a>给那些想要更多信息的人。我也写了一篇关于Fetch的博客，链接<a class="ae kv" href="https://medium.com/swlh/javascript-lets-make-fetch-happen-9cfda0c40ef4" rel="noopener">这里</a>。</p><p id="f01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的第一个获取请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在导出<code class="fe mx my mz na b">getPokemons</code>获取请求，现在可以将它导入到其他组件和容器中。所以我们就这么做吧。在<code class="fe mx my mz na b">AllPokemon.js</code>中，我们需要导入一些东西来启动和获取这个容器。首先，因为这是一个功能组件，我们将使用React钩子来进行fetch调用。这是有意的，因为我打算在整个教程中使用钩子。所以让我们导入以下内容:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="d658" class="ls lt iq na b gy nf ng l nh ni">import React, { useState, useEffect } from 'react';</span></pre><p id="4866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要从我们的服务文件夹中导入我们的fetch函数，该导入如下所示:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9f06" class="ls lt iq na b gy nf ng l nh ni">import { getPokemons } from '../services/pokemons';</span></pre><p id="bb82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们就可以开始写代码了！</p><h2 id="c0e3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用我们提取的数据</h2><p id="5907" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">访问我们的数据的第一步是通过<code class="fe mx my mz na b">useEffect</code>钩子。效果挂钩允许我们处理任何可能导致副作用的事情。如果一个函数试图修改它体外的任何东西，据说它会有副作用，但是它修改的是什么呢？嗯，我们知道我们将需要访问我们所有的口袋妖怪，所以让我们<code class="fe mx my mz na b">useState</code>！有关React挂钩的更全面的文档，请访问<a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="45a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">useState</code>钩子返回一对值:当前状态和更新它的函数。在我们的例子中，当前状态是<code class="fe mx my mz na b">pokemons</code>，更新它的函数是<code class="fe mx my mz na b">setPokemons</code>。我们的<code class="fe mx my mz na b">useState</code>调用将如下所示:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="d7ee" class="ls lt iq na b gy nf ng l nh ni">const [pokemons, setPokemons] = useState([]);</span></pre><p id="26bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将一个空数组传递到<code class="fe mx my mz na b">useState</code>钩子中，为我们的<code class="fe mx my mz na b">pokemons</code>状态变量设置默认值。</p><p id="aee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要使用<code class="fe mx my mz na b">useEffect</code>钩子，从API中获取数据。如果你熟悉基于类的组件，<code class="fe mx my mz na b">useEffect</code>的操作很像<code class="fe mx my mz na b">ComponentDidMount</code>或<code class="fe mx my mz na b">ComponentDidUpdate</code>。目的是用我们从PokeApi获取的信息更新我们的状态。首先，让我们通过控制台记录来看看数据。注意在<code class="fe mx my mz na b">useEffect</code>调用之后的空数组。注意<code class="fe mx my mz na b">useEffect</code>在组件安装和更新时运行。如果你不把一个依赖数组传入<code class="fe mx my mz na b">useEffect</code>，它将不断更新。如果您将一个空的依赖数组传递到调用中，它将只在组件挂载时运行一次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我的控制台显示的内容！20个口袋妖怪嵌套在一个物体里！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/16ef1163e4b5f6163ca556e21eb63e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MeuPisLZKZixgfee4kARA.png"/></div></div></figure><p id="1f42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。我们做到了。我们有POKEMON！我们只有20个，因为PokeAPI是用分页设计的，但我认为目前20个是个不错的数字。我们可以想出以后如何访问更多的口袋妖怪。</p><p id="4681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们需要在<code class="fe mx my mz na b">useEffect</code>钩子中处理我们的获取。让我们在钩子内部调用<code class="fe mx my mz na b">setPokemons</code>并将数据传递给它。记住<code class="fe mx my mz na b">setPokemons</code>是我们传递给负责更新<code class="fe mx my mz na b">pokemons</code>状态变量的<code class="fe mx my mz na b">setState</code>钩子的函数。所以现在我们可以console.log <code class="fe mx my mz na b">pokemons</code>并且我们应该从API中看到我们的对象！太酷了。下面是迄今为止的<code class="fe mx my mz na b">AllPokemon.js</code>情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="c682" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们来渲染一下口袋妖怪吧！</h2><p id="42e6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们需要做的第一件事是制作一个我们之前讨论过的组件<code class="fe mx my mz na b">PokemonCard.js</code>。我在<code class="fe mx my mz na b">src</code>文件夹中做了一个名为<code class="fe mx my mz na b">components</code>的文件夹，并添加了<code class="fe mx my mz na b">PokemonCard.js</code>文件。这个组件的目标是，我们希望它为我们结果中的每个口袋妖怪进行渲染。组件可重用性是React的关键特性之一。</p><p id="c4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你仔细看看我们的<code class="fe mx my mz na b">console.log(pokemons)</code>的结果，你会看到我们得到了一个对象。Javascript允许我们用一个名为<code class="fe mx my mz na b">Object.entries()</code>的方法解析对象，在这个方法中，我们将把对象作为参数传入。您可以<code class="fe mx my mz na b">console.log(Object.entries(pokemons)</code>查看您现在可以访问哪些数据。您应该在控制台中看到4个数组，其中一个指向名为results的数组。那是我们想要的。它始终位于索引3处。所以让我们试试另一个console.log。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9829" class="ls lt iq na b gy nf ng l nh ni">console.log(Object.entries(pokemons)[3])</span></pre><p id="5dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们应该只看到结果数组，但是等等，口袋妖怪在数组索引1处被进一步嵌套。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="8e90" class="ls lt iq na b gy nf ng l nh ni">console.log(Object.entries(pokemons)[3][1])</span></pre><p id="4cba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可能真的得到了你想要的结果，但是刷新页面，整个事情就完了。什么鬼东西？我们看到了结果，但现在我们无法实现它们。请记住，状态更新是异步发生的，这意味着更新状态不会阻止应用程序的其余部分顺利呈现和运行。如果我们在获取口袋妖怪时整个应用程序停止工作，那就糟了。没人会想用它。所以为了修正这个错误，我们必须做一些叫做短路的事情。基本上，我们必须首先检查pokemon对象是否被填充，然后才能调用它。<a class="ae kv" href="https://dev.to/2spacemilk/short-circuit-evaluation-with-react-3dn4" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个很棒的博客，更深入地讨论了这个问题。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b2bd" class="ls lt iq na b gy nf ng l nh ni">console.log(Object.entries(pokemons)[3] &amp;&amp; Object.entries(pokemons)[3][1])</span></pre><p id="f3db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的。成功，我们终于访问了我们的口袋妖怪数组。现在我们可以使用可靠的<code class="fe mx my mz na b">.map</code>方法来呈现我们的<code class="fe mx my mz na b">PokemonCard</code>组件。下面是一个在JSX使用<code class="fe mx my mz na b">.map</code>方法实现的完整的<code class="fe mx my mz na b">AllPokemon.js</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e1f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！我们做到了，伙计们。前往<code class="fe mx my mz na b">PokemonCard.js</code>实际渲染口袋妖怪的名字。在我们的<code class="fe mx my mz na b">PokemonCard.js</code>中，我们现在可以访问<code class="fe mx my mz na b">props</code>，这是React允许我们在父组件和子组件之间动态共享信息的方式。上面我们展开了我们的口袋妖怪数组，并复制了一份作为我们组件中的道具。确保像这样将道具传入组件<code class="fe mx my mz na b">const PokemonCard = (props) =&gt; {}</code>，然后尝试一个<code class="fe mx my mz na b">console.log(props)</code>。你应该看到你的个人口袋妖怪。你可以看到我们这里有两个键，名称和url。让我们更新控制台日志:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="36be" class="ls lt iq na b gy nf ng l nh ni">console.log(props.name)</span></pre><p id="b1da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会在您的控制台中看到一个口袋妖怪名称列表。使用JSX，让我们动态渲染这些口袋妖怪。我将制作一个<code class="fe mx my mz na b">h3</code>元素来显示口袋妖怪的名字。下面是我的<code class="fe mx my mz na b">PokemonCard</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1e9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，没有可爱的口袋妖怪图片。这是站不住脚的！不幸的是，PokeAPI没有图像，但是不同的API有。我们可以将<code class="fe mx my mz na b">img</code>标签的<code class="fe mx my mz na b">src</code>设置为如下:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f08e" class="ls lt iq na b gy nf ng l nh ni">src={`https://pokeres.bastionbot.org/images/pokemon/${props.id}.png`}</span></pre><p id="326b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在等等，我们没有<code class="fe mx my mz na b">id</code>的<code class="fe mx my mz na b">prop</code>。让我们把指数作为道具传下去。对我们来说幸运的是，口袋妖怪是根据他们被揭露的顺序来给他们的id的。因此，有史以来第一批151个口袋妖怪的顺序是1-151，随后的每一个口袋妖怪都紧随其后。所以，我们可以简单地将索引作为id道具传递，并加上1，因为没有第零个口袋妖怪。通过道具后，<code class="fe mx my mz na b">AllPokemon.js</code>向我们的<code class="fe mx my mz na b">PokemonCard</code>添加另一个道具:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4b58" class="ls lt iq na b gy nf ng l nh ni">return &lt;PokemonCard key={index} {...pokemon} id={index + 1} /&gt;</span></pre><p id="4a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以创建一个<code class="fe mx my mz na b">img</code>标签并使用上面提供的<code class="fe mx my mz na b">src</code>。我们的<code class="fe mx my mz na b">PokemonCard</code>组件现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bf36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇，这么多可爱的口袋妖怪！现在，图像太大了，而且很简单。我将在下一篇博客中讨论造型。我们的目标是拥有漂亮的可点击的小口袋妖怪卡片。下周见，希望你喜欢！</p><p id="6693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个<a class="ae kv" href="https://github.com/jordles113/personal-pokedex" rel="noopener ugc nofollow" target="_blank">回购</a>的链接。这里是本教程中用到的所有<a class="ae kv" href="https://gist.github.com/jordles113" rel="noopener ugc nofollow" target="_blank">要点的链接。</a></p></div></div>    
</body>
</html>