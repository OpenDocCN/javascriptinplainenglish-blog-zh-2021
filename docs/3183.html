<html>
<head>
<title>3 Reasons NOT to Use ES6 Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不在JavaScript中使用ES6函数的3个理由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-reasons-not-to-use-es6-functions-in-javascript-9e99cc489211?source=collection_archive---------11-----------------------#2021-06-28">https://javascript.plainenglish.io/3-reasons-not-to-use-es6-functions-in-javascript-9e99cc489211?source=collection_archive---------11-----------------------#2021-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1c5f429bffecbf473970c1239463b7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJsBlEwBSAHpEdAEV3Dn3A.jpeg"/></div></div></figure><p id="48bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我看到很多媒体的帖子宣称掌握成为一名优秀程序员的秘密。这些文章经常声称使用“ES6函数”更好，除非你正在使用它们，否则你不是“JavaScript开发高手”。</p><p id="fe2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我相信<strong class="jx io">使用ES6函数而不考虑它对整个应用程序的影响是有害的</strong>。就像人们研究数学证明却不明白到底是怎么回事一样。</p><h1 id="5cda" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可读性</h1><p id="d5af" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">用写作的轻松来换取阅读的痛苦是不可取的。编码不仅仅是告诉你的计算机做什么，很明显，它是与你团队的其他成员就事情如何完成进行交流。这使得可读性成为编写程序的一个关键概念。考虑这个例子:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/ba3520081bc163f1292a6252e3679062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGmI0tWYXcT7ejoWCH0K3A.png"/></div></div></figure><p id="1ee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你看着这段代码，你会想，好吧。让我们试着理解这里发生了什么。如果我告诉你<strong class="jx io">而不是</strong>使用ES6功能会让我们的生活变得更轻松，你会怎么想？请考虑以下情况:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/ad0c22f8eb29d1bce93b3af5ed68d9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoDTsOnJ3h4tjUMqIFu2YQ.png"/></div></div></figure><p id="ed90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们给这个函数起了个名字“enrichpeoplewithpurchasesgreaterthan 10 dollars”，这当然是一个很长的单词，但是现在我们不需要重新阅读这段代码就可以知道发生了什么。我们可以浏览它，而不用投入太多的精力去检查它是否达到了我们的预期。<em class="mc">我们向我们的团队传达了意图，让他们更容易阅读</em>。</p><p id="f68b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能不是一个理想的例子，因为我们在这里脱离了上下文，但我在许多代码库中遇到过很多例子，这可能是你想在代码的某些部分应用的东西。</p><h1 id="184a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">排除故障</h1><p id="be2c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当您使用Node.js时，通常会有某种日志系统。它可以是外部服务、简单的控制台日志记录，或者将它们流式传输到文本文件。</p><p id="685b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们在代码中遇到异常时，我们想知道它们发生在哪里。无法查明问题的确切原因可能会给你和你的团队带来相当大的挫折。这就是为什么您可能要重新考虑在代码的某些部分使用ES6粗箭头函数。</p><p id="90cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您的浏览器控制台中，编写如下内容:</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="4463" class="mi ku in me b gy mj mk l ml mm">(() =&gt; { throw Error })();</span></pre><p id="c88c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们基本上是自动执行一个抛出异常的函数。结果将是这样的:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/6667e42dfbd499e3e597a55929f71784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KkVmAdfL5Hxxf7rzaFSHcg.png"/></div></div></figure><p id="7210" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了。(匿名)。想象一下这是由你的后端代码抛出的。祝你好运找到你的异常的原因。</p><p id="6c38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在您的浏览器控制台中，编写以下内容:</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="a5d1" class="mi ku in me b gy mj mk l ml mm">(function thisWillFail() { throw Error })();</span></pre><p id="2308" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将导致以下错误:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/9dca02f8bc7103421a969745a24420cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EG8li6ryWbt0he9-m_blBw.png"/></div></div></figure><p id="caf7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意到区别了吗？我们知道“thisWillFail”函数出错了。这就是为什么我提倡在调试很重要的场景中使用函数表达式。相信我，应用这个可以防止你每次遇到那些讨厌的匿名错误时用头撞墙。</p><h1 id="9bb8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">回调函数</h1><p id="7769" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在JavaScript中,<code class="fe mp mq mr me b">this</code>是一个棘手的关键字，如果你是一个JavaScript开发人员，你会遇到这个问题。<code class="fe mp mq mr me b">this</code>关键字非常强大，因为它允许我们根据调用函数的方式来改变上下文。</p><p id="b398" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，使用胖箭头函数，当你的函数被声明时，上下文是静态绑定的，并且不能被改变。有时你可能想在全局范围内使用<code class="fe mp mq mr me b">this</code>关键字，然而，对于事件回调函数来说，情况并不总是这样。</p><p id="f04b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑:</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="7e8e" class="mi ku in me b gy mj mk l ml mm">const btn = document.getElementById('example-btn');<br/>btn.addEventListener('click', () =&gt; {<br/>    this.innerHTML = 'Clicked button';<br/>});</span></pre><p id="0ad5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这没用的。在ES6函数中，如果函数在全局上下文中注册，<code class="fe mp mq mr me b">this</code>关键字指的是窗口。在这个例子中，这意味着<code class="fe mp mq mr me b">this.innerHTML</code>等于<code class="fe mp mq mr me b">window.innerHTML</code>，这并不是我们真正想要的。</p><p id="e938" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们需要使用函数表达式:</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="689e" class="mi ku in me b gy mj mk l ml mm">const btn = document.getElementById('example-btn');<br/>btn.addEventListener('click', function changeText() {<br/>    this.innerHtml = 'Clicked button';<br/>});</span></pre><p id="1715" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这能行！我们的回调函数的上下文现在指向我们的按钮<code class="fe mp mq mr me b">this</code>，运行<code class="fe mp mq mr me b">this.innerHTML</code>将导致按钮文本的改变。</p><p id="4976" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会说我们可以使用传递给我们函数的事件对象，但是，我们必须解析我们正确的目标，你可能已经注意到其他的边缘情况可能会支持。</p><h1 id="646d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3302" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在这篇文章中，我分享了为什么使用ES6功能并不总是更好的3个原因。写代码没有最好的方法。应用程序差别很大。您可能不希望在react-native中使用函数表达式进行调试，因为它们没有什么价值。但是，它在Node.js应用程序中可能有很大的价值。</p><p id="e76a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与您的团队就这些主题进行交流，并尝试找到中间立场，在这个立场上<strong class="jx io">可读性、调试和性能</strong>是关键指标。</p><p id="0f78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mc">更多内容请看</em><a class="ae ms" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>