<html>
<head>
<title>Understanding the useRef React hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解useRef React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-useref-react-hook-6771e68fc537?source=collection_archive---------10-----------------------#2021-01-21">https://javascript.plainenglish.io/understanding-the-useref-react-hook-6771e68fc537?source=collection_archive---------10-----------------------#2021-01-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2d9d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">继续我们的React hooks系列，我们将在这篇博文中了解useRef react hook。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cad61082ca53d65acb12fe3843f74db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VfysImDCgYFL_9MO.jpg"/></div></div></figure><p id="31d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">继续我们的<a class="ae lk" href="https://www.wisdomgeek.com/tag/react-hooks/" rel="noopener ugc nofollow" target="_blank"> React hooks </a>系列，我们将在这篇博文中了解useRef React hook。</p><p id="0fcb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">useRef React挂钩在以下两种情况下很有用:</p><ol class=""><li id="ceb1" class="ll lm in kq b kr ks ku kv kx ln lb lo lf lp lj lq lr ls lt bi translated">在React内部直接访问DOM元素</li><li id="500b" class="ll lm in kq b kr lu ku lv kx lw lb lx lf ly lj lq lr ls lt bi translated">存储不触发重新呈现并且在重新呈现之间保持的状态值</li></ol><p id="d40c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在看到这个钩子的这些优点之前，我们先来了解一下钩子是什么，它是做什么的。</p><h1 id="1168" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">什么是useRef React hook？</h1><p id="1c84" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">useRef React挂钩是一个返回可变Ref对象的函数。Refs是React中访问DOM节点的一种方式。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="592d" class="nb ma in mx b gy nc nd l ne nf">const refContainer = useRef(initialValue);</span></pre><p id="3964" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">的。useRef React钩子返回的对象的current属性被初始化为我们在钩子中传递的初始值。返回的对象在组件的整个生存期内都保持不变。</p><p id="8afa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">换句话说，useRef可以用作容器，我们可以在其中存储可变值。</p><p id="5f12" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要改变对象的值，我们可以将新值赋给当前属性:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="c072" class="nb ma in mx b gy nc nd l ne nf">const App = () =&gt; {<br/>   const myRef = useRef("initial value")<br/><br/>   // updating ref <br/>   myRef.current = "updated value" <br/><br/>  // myRef now will be {current: "updated value"} <br/>}</span></pre><p id="e2e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们使用<code class="fe ng nh ni mx b">&lt;div ref={myRef} /&gt;</code>将ref对象传递给DOM节点，那么。引用的当前属性将被设置为该节点。每当节点改变时，返回的引用变量也会更新。</p><p id="d71a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当分配给一个DOM节点时，我们通常在JSX这样做。因此，我们在声明期间提供给useRef React钩子的初始值将是null。</p><p id="5fab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者，如果我们不使用DOM节点，而是使用任何其他JavaScript值，那么该值将在重新呈现时保持不变。因此，这是保存可变值的一种简便方法。当以这种方式使用时，它非常类似于类中的实例字段。</p><p id="db32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是为什么不自己用. current属性({current: … })创建一个对象呢？唯一的区别是，使用useRef React钩子创建的对象将在每次渲染时返回相同的对象。如果是我们自己创造的，情况就不一样了。</p><p id="a7e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还需要注意的是，useRef没有附加通知程序。当值改变时，什么也不会发生。如果我们想要这个功能，最好使用useState钩子。如果我们想在一个DOM节点上添加/移除一个ref时执行一些代码，我们可以使用回调ref。</p><h1 id="5454" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">访问DOM节点或React元素</h1><p id="bf90" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">让我们开始进入useRef React钩子有用的场景。熟悉React的人应该已经知道我们使用Refs来访问DOM节点或React元素。正如我们上面讨论的，useRef也允许我们这样做。</p><p id="0710" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在单击按钮时聚焦于一个元素，我们可以创建一个组件:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="d3b4" class="nb ma in mx b gy nc nd l ne nf">const InputTextWithFocusButton= () =&gt; {<br/>   const inputEl = useRef()<br/><br/>   const onButtonClick = () =&gt; {<br/>      inputEl.current.focus()<br/>   }<br/><br/>   return (<br/>      &lt;&gt;<br/>         &lt;input ref={inputEl} type="text" /&gt;<br/>         &lt;button onClick={onButtonClick}&gt;Focus on Input Text&lt;/button&gt;<br/>      &lt;/&gt;<br/>   )<br/>}</span></pre><p id="efad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们能够访问子DOM节点，并使用useRef React钩子来访问它。</p><p id="8c95" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意:</strong>同样的功能也可以通过使用createRef API来实现:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="566b" class="nb ma in mx b gy nc nd l ne nf">const InputTextWithFocusButton= () =&gt; {<br/>   const inputEl = createRef()<br/><br/>   const onButtonClick = () =&gt; {<br/>      inputEl.current.focus()<br/>   }<br/><br/>   return (<br/>      &lt;&gt;<br/>         &lt;input ref={inputEl} type="text" /&gt;<br/>         &lt;button onClick={onButtonClick}&gt;Focus on Input Text&lt;/button&gt;<br/>      &lt;/&gt;<br/>   )<br/>}</span></pre><p id="ada8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那我们为什么需要useRef React钩子呢？</p><p id="d392" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">关键在于坚持。useRef的返回对象在组件的整个生命周期中都是持久的，而createRef则不是。如果要重新呈现组件，useRef创建的对象将被持久化。使用createRef创建的对象将指向一个新对象。</p><p id="3ce6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你想在一个实际的例子中查看另一个例子，你可以查看我们之前的帖子<a class="ae lk" href="https://www.wisdomgeek.com/development/web-development/react/detecting-click-outside-component-using-react-hooks/" rel="noopener ugc nofollow" target="_blank">使用useRef钩子</a>检测React组件外部的点击。</p><p id="7fe2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一件要记住的事情是避免在任何需要与DOM节点交互的地方使用useRef。仅仅因为我们能做并不意味着我们应该去做。除非需要，否则不鼓励使用useRef。围绕州的最佳实践的存在是有原因的。</p><h1 id="2448" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">存储可变变量</h1><p id="0c0a" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">因为useRef React钩子返回一个JavaScript对象，所以它不局限于存储DOM节点。我们可以用它来存储任何我们希望在重新渲染时持久化的变量。</p><p id="e1a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们创建一个组件来显示它被重新渲染的次数。</p><p id="32fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这份声明有用吗？</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="4ebf" class="nb ma in mx b gy nc nd l ne nf">const RerenderCounter = () =&gt; {<br/>  let count = 0;<br/>  count++;<br/><br/>  return (&lt;span&gt;{count}&lt;/span&gt;);<br/>}</span></pre><p id="de81" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我们在组件内部初始化计数，所以每次重新渲染时都会重新初始化。因此该组件将始终呈现1作为输出。</p><p id="2865" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们需要引用一个在重新渲染时保留的变量。因此，请参考:</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="5909" class="nb ma in mx b gy nc nd l ne nf">const RerenderCounter = () =&gt; {<br/>  const count = useRef(0);<br/>  useEffect(() =&gt; {<br/>    // Every time the component has been re-rendered,<br/>    // the counter is incremented<br/>    counter.current = counter.current + 1;<br/>  }); <br/>  return (&lt;span&gt;{count}&lt;/span&gt;);<br/>}</span></pre><p id="9419" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该实现将在重新渲染时保留count变量。由于值被保留，我们将在每次渲染时获得对相同变量的引用。因此，我们将在每次重新渲染时增加计数。因此，我们将获得组件被重新渲染的实际次数。</p><p id="7718" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以更新函数内部的计数器，而不是使用useEffect，但是React文档建议修改事件处理程序或效果中的引用。这是因为功能组件中的所有副作用都应该在生命周期的布局阶段或提交阶段完成，以避免意外。</p><p id="3f0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">关于这个功能的另一个实例，你可以查看我们的帖子，在那里我们<a class="ae lk" href="https://www.wisdomgeek.com/development/web-development/react/use-redux-like-middleware-for-usereducer-in-react/" rel="noopener ugc nofollow" target="_blank">使用useReducer </a>钩子创建了类似redux的中间件。我们使用useRef钩子存储组件的先前状态，并在每次使用<a class="ae lk" href="https://www.wisdomgeek.com/development/web-development/react/understanding-the-usereducer-hook-in-react/" rel="noopener ugc nofollow" target="_blank"> useReducer钩子</a>更新状态时更新它。</p><p id="4d50" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们希望这篇文章能帮助你对useRef React hook有更深的理解，现在你知道什么时候不应该使用它了。如果你有任何疑问，请在评论区告诉我们。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="7981" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nq">原载于2021年1月21日</em><a class="ae lk" href="https://www.wisdomgeek.com/development/web-development/react/understanding-the-useref-react-hook/" rel="noopener ugc nofollow" target="_blank"><em class="nq">【https://www.wisdomgeek.com】</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>