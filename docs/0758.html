<html>
<head>
<title>3 Hooks Every React Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个React开发人员都应该知道的3个问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-hooks-every-react-developer-should-know-a8e1bd218acc?source=collection_archive---------7-----------------------#2021-02-16">https://javascript.plainenglish.io/3-hooks-every-react-developer-should-know-a8e1bd218acc?source=collection_archive---------7-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3817" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解不同的挂钩，知道何时使用正确的挂钩</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b085bdf1a38754ca604c121e7cf5a6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmAC1y8l3N3CgHaKjKjMdg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: Author. Created with <a class="ae kv" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank">Canva</a>.</figcaption></figure><p id="03be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近使用基于类的组件组合以及使用<a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> Hooks API </a>构建了一个项目，我不禁注意到React Hooks如何更易于使用，并且也没有许多基于类的组件失败。</p><p id="ef16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React Hooks提供了对功能组件内部的状态和生命周期方法的访问。从而消除了将功能组件重构为类组件的需要。</p><p id="e113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React挂钩是一组内置函数(您也可以创建它们),支持功能组件中的状态管理和副作用。</p><p id="ae59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，知道何时使用哪个内置钩子以及该函数的确切功能有时会变得令人困惑，尤其是如果您是新手的话。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/cd14d3fb4ccd6350d4932cbf5ebeb66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*VlwyTN-4p5R60un_RkyYiw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Different React Hooks. <a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">Source</a>.</figcaption></figure><p id="b85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一些最重要的React挂钩，在你开始使用它们之前你应该知道:</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="babc" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">1.使用状态</h1><p id="8426" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">useState()</code>函数是我学到的第一个钩子，也是最常用的&amp;普通React钩子</p><p id="820b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，这个钩子处理组件的状态。换句话说，和<code class="fe mx my mz na b">this.setState</code>很像。</p><p id="1056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个钩子中传递一些本地状态，只要函数重新呈现，它就会被保留。</p><p id="a420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个钩子返回两个值:第一个是反应数据，第二个是允许您更新它的函数。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="697e" class="nf mb iq na b gy ng nh l ni nj">import React, { useState } from 'react';<br/>function Example() {<br/>  // Declare a new state variable, which we'll call "count"  const [count, setCount] = useState(0);<br/>// count is the data whereas setCount is an update function</span><span id="c2f0" class="nf mb iq na b gy nk nh l ni nj">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们将0作为参数传递给了<code class="fe mx my mz na b">useState()</code>函数，它将用值0初始化我们的常量“count”。</p><p id="61db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React hooks利用了JavaScript的析构特性，如果你不知道的话，可以看看我的博客，讨论一些现代实践。</p><div class="nl nm gp gr nn no"><a href="https://medium.com/javascript-in-plain-english/5-modern-practices-of-javascript-that-every-developer-should-know-1a61dc9a6ee0" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">每个开发人员都应该知道的JavaScript的5种现代实践</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">编写干净代码的5个最佳技巧和实践</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kp no"/></div></div></a></div><p id="6446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以传递其他参数。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="65c6" class="nf mb iq na b gy ng nh l ni nj">const [age, setAge] = useState(42);<br/>const [fruit, setFruit] = useState('banana');<br/>const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1db5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">2.使用效果</h1><p id="a306" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">useEffect()</code>是一个多功能挂钩，可以执行多达三种生命周期方法。</p><p id="b755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">componentDidMount</code>、<code class="fe mx my mz na b">componentDidUpdate</code>和<code class="fe mx my mz na b">componentWillUnmount</code>功能由这个单钩执行。</p><p id="0226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mx my mz na b">useEffect()</code>实现<code class="fe mx my mz na b">componentDidMount</code>功能非常简单，理解这一点后，你也将了解如何实现<code class="fe mx my mz na b">componentDidUpdate()</code>功能。</p><p id="169c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使解释更加清楚，我们将通过首先理解它所采用的参数来研究如何从<code class="fe mx my mz na b">useEffect()</code> API中实现这些方法。</p><p id="bd8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个钩子接受两个参数——一个函数和一个数组。</p><p id="439f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个参数指定每次更新组件时要执行的操作，而第二个参数让您控制何时更新组件。</p><p id="3ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你传递一个空数组，当组件被挂载时，<code class="fe mx my mz na b">useEffect()</code>将只运行一次，这执行了<code class="fe mx my mz na b">componentDidMount</code>方法。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4cc0" class="nf mb iq na b gy ng nh l ni nj">function Example() {<br/>  ....<br/>  useEffect(() =&gt; {<br/>    document.title = `This runs once`;<br/>  },[]);<br/>}</span></pre><p id="4ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你根本没有通过第二个参数，你实际上同时运行了<em class="od">、<code class="fe mx my mz na b">componentDidMount</code>和<code class="fe mx my mz na b">componentDidUpdate</code>方法。</em></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="af54" class="nf mb iq na b gy ng nh l ni nj">function Example() {<br/>  ....<br/>  useEffect(() =&gt; {<br/>    document.title = `This runs once`;<br/>  });<br/>}</span></pre><p id="8aa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过将数据传递到第二个参数的数组中，使<code class="fe mx my mz na b">useEffect()</code>仅在某些数据发生变化时触发重新渲染，如下所示:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0a52" class="nf mb iq na b gy ng nh l ni nj">import React, { useState, useEffect } from 'react';<br/>function Example() {<br/>  const [count, setCount] = useState(0);<br/><br/>  // Similar to componentDidMount and componentDidUpdate:  useEffect(() =&gt; {    <br/>// Update the document title using the browser API    <br/>document.title = `You clicked ${count} times`; <br/>},<br/>[count]);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="1efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的<code class="fe mx my mz na b">useEffect</code>只会在“计数”变量改变时触发重新渲染。</p><p id="e86e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在如何使用这个钩子执行<code class="fe mx my mz na b">componentDidUnmount</code>？</p><p id="9710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，您可以从作为第一个参数在<code class="fe mx my mz na b">useEffect()</code>钩子中传递的函数中返回一个函数。当您看到代码时，这将变得更加清楚:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="f4e9" class="nf mb iq na b gy ng nh l ni nj">useEffect(<br/>  () =&gt; {<br/>    const subscription = props.source.subscribe();<br/>    return () =&gt; {<br/>      subscription.unsubscribe();<br/>    };<br/>  },<br/>  [props.source],<br/>);</span></pre><p id="0ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，你可以看到我们返回了一个只有一行代码<code class="fe mx my mz na b">subscription.unsubscribe();</code>的函数。</p><p id="28d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这个函数将在组件卸载时执行。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="bef8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">3.使用上下文</h1><p id="dd15" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这个钩子使您能够实现和使用React的上下文API。</p><p id="8de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不知道上下文API，这是一个消除了传递道具需求的系统。</p><p id="b2ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大型应用程序中，将道具从顶层(父)组件向下传递到底层(子)组件可能会变得令人厌烦，因此，上下文API可能会非常有用和节省时间。</p><p id="00cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个钩子允许您使用上下文API，接受一个上下文对象，并返回那个特定上下文的最新的当前上下文值。</p><p id="6a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过一个例子来理解这一点。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="fde0" class="nf mb iq na b gy ng nh l ni nj">const message={<br/>  passed:'Congrats, you passed the test',<br/>  failed:'You failed this time, try again!'<br/>}<br/>const MessageContext=createContext(message);<br/>function App(){<br/>  return (<br/>    &lt;MessageContext.Provider value={message.passed}&gt;<br/>        &lt;DisplayMessage /&gt;<br/>    &lt;/MessageContext.Provider&gt;</span><span id="637f" class="nf mb iq na b gy nk nh l ni nj">)<br/>}<br/>function DisplayMessage (){<br/>  const result= useContext(MessageContext);<br/>      return &lt;h1&gt;result&lt;/h1&gt;<br/>}</span></pre><p id="cb18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用上下文API和<code class="fe mx my mz na b">useContext()</code>钩子将数据从父组件传递到子组件。</p><p id="fb2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当父提供程序中的值发生变化时，子组件中的值也会发生变化。</p><p id="84d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你熟悉上下文API，你一定已经注意到我们没有使用消费者方法，这是因为<code class="fe mx my mz na b">useContext()</code>钩子本质上是消费者方法的更好、更干净的替代品。</p><p id="6862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="od">但是在您开始使用这个API之前，请记住，只有当数据需要被不同嵌套层次的许多组件访问时，才使用上下文，因为这使得组件难以重用。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b843" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="8675" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">React Hooks是React框架的一个相对较新的补充，也是非常需要的。</p><p id="57fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React Hooks本质上让你“挂钩”到基于类的组件所提供的状态管理和生命周期方法，这是一种新的方式来改变我们在React中的编码习惯。</p><p id="e4a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从React版本16.8.0开始，您可以使用Hooks API并使用它构建完整的应用程序。最好的部分是类组件不会去任何地方，你也可以自由地坚持类组件。</p><p id="9b7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，值得注意的是，这种从类组件转移到功能组件的实践可能会<a class="ae kv" href="https://medium.com/better-programming/i-almost-got-fired-for-choosing-react-in-our-enterprise-app-846ea840841c" rel="noopener">让你的队友感到困惑，如果他们习惯了其他语言和框架</a>的话，正如<a class="oe of ep" href="https://medium.com/u/2f6bca23648e?source=post_page-----a8e1bd218acc--------------------------------" rel="noopener" target="_blank"> Razvan Dragomir </a>所解释的那样。</p><p id="64fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，钩子提供了一种方式，以一种非常干净、直观和快速的方式将一些最重要的React概念如道具、上下文、状态等结合起来。</p><p id="a454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢阅读这篇文章！</p></div></div>    
</body>
</html>