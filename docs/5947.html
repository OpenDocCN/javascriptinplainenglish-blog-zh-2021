<html>
<head>
<title>How To Automatically Get Props Types in Next.js and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Next.js和TypeScript中自动获取道具类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-automatically-get-props-types-in-next-js-and-typescript-4c223e962617?source=collection_archive---------1-----------------------#2021-12-21">https://javascript.plainenglish.io/how-to-automatically-get-props-types-in-next-js-and-typescript-4c223e962617?source=collection_archive---------1-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ceb9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">避免使用带有InferGetServerSidePropsType和InferGetStaticPropsType的样板代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6faa53226253f8d58f655486aecc90e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_E3pDUStmUSPV_TN"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里提到的<a class="ae kv" href="https://nextjs.org/docs/basic-features/typescript" rel="noopener ugc nofollow" target="_blank">，Next.js官方支持TypeScript。随着时间的推移，已经添加了一些功能来避免编写样板代码。其中最有用的由<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>表示。</a></p><p id="4db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些将自动推断出分别来自<code class="fe ls lt lu lv b"><a class="ae kv" href="https://nextjs.org/docs/basic-features/data-fetching#when-should-i-use-getserversideprops" rel="noopener ugc nofollow" target="_blank">getServerSideProps()</a></code>或<code class="fe ls lt lu lv b"><a class="ae kv" href="https://nextjs.org/docs/basic-features/data-fetching#when-should-i-use-getstaticprops" rel="noopener ugc nofollow" target="_blank">getStaticProps()</a></code>函数的页面组件道具的类型。尽管它们无疑代表了一个节省时间的特性，<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>有一些限制，阻止它们正确推断道具类型，导致<code class="fe ls lt lu lv b">props: never</code>错误。</p><p id="0a25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看如何使用<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code> <code class="fe ls lt lu lv b">InferGetStaticPropsType</code>并避免这些限制。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9205" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">InferGetServerSidePropsType和InferGetStaticPropsType在运行</h1><p id="9d15" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">让我们通过一个例子来看看<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>是如何工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>允许您避免将<code class="fe ls lt lu lv b">UserPage</code>组件<code class="fe ls lt lu lv b">user</code> prop声明为<code class="fe ls lt lu lv b">User</code>。如果没有<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>，用户页面函数签名将是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一种方法显然涉及到代码重复、样板代码，并且使整个代码库不太容易维护。</p><p id="7de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>与<code class="fe ls lt lu lv b">getServerSideProps()</code>一起工作。同样，<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>与<code class="fe ls lt lu lv b">getStaticProps()</code>一起工作。它们的用途和功能实际上是相同的。因此，不需要显示<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>运行的例子。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c449" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用infer-next-props-type解决了类型推断问题</h1><p id="2507" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Type_inference" rel="noopener ugc nofollow" target="_blank">类型推理</a>很棒，在某些情况下甚至像魔术一样。另一方面，它涉及可能容易失败的复杂程序。在撰写时，在Next.js ≤ 12中，<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>都有几个重大问题导致Next.js推断<code class="fe ls lt lu lv b">never</code>为道具类型。如果你想了解更多，请点击这个链接。</p><p id="7f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些限制可能会成为一个问题，并阻止您完全使用它们。考虑到使用<code class="fe ls lt lu lv b">notFound</code>时推断过程也会失败，这一点尤其正确。正如官方文档中的<a class="ae kv" href="https://nextjs.org/docs/basic-features/data-fetching" rel="noopener ugc nofollow" target="_blank">所述，<code class="fe ls lt lu lv b">notFound</code>是一个可选的布尔值，它将强制Next.js重定向到404页面。下面是它如何工作的一个例子:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dbd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，当数据检索逻辑失败时，<code class="fe ls lt lu lv b">notFound</code>布尔值被返回，结果404页被加载。</p><p id="10c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当使用该逻辑时，<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>失败并返回<code class="fe ls lt lu lv b">never</code>作为道具类型。换句话说，这种基本和常见的错误处理逻辑使得<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>不起作用，因此不可使用。</p><p id="41e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，<a class="ae kv" href="https://github.com/HaNdTriX" rel="noopener ugc nofollow" target="_blank"> HaNdTriX </a> GitHub用户发布了一个关于<a class="ae kv" href="https://www.npmjs.com/package/infer-next-props-type" rel="noopener ugc nofollow" target="_blank">infer-next-props-type</a>NPM类型脚本库的修复程序。如这里描述的<a class="ae kv" href="https://github.com/HaNdTriX/infer-next-props-type#readme" rel="noopener ugc nofollow" target="_blank"/>，使用起来非常简单。您所要做的就是用下面的代码行导入它:</p><pre class="kg kh ki kj gt nc lv nd ne aw nf bi"><span id="a553" class="ng me iq lv b gy nh ni l nj nk">import InferNextPropsType from "infer-next-props-type"</span></pre><p id="436d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并按如下方式使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="15cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，你所要做的就是用<code class="fe ls lt lu lv b">InferNextPropsType</code>替换<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>或<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>。事实上，该库以相同的<code class="fe ls lt lu lv b">InferNextPropsType</code>类型不加区分地支持<code class="fe ls lt lu lv b">getServerSideProps()</code>和<code class="fe ls lt lu lv b">getStaticProps()</code>。</p><p id="32c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读<a class="ae kv" href="https://github.com/vercel/next.js/issues/15913#issuecomment-950330472" rel="noopener ugc nofollow" target="_blank"> this </a>找到该库处理的导致标准Next.js推断过程失败的所有案例的列表。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9a90" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="7b33" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在本文中，我们学习了如何在Next.js和TypeScript中正确使用类型推断。Next.js提供了一些特性来避免样板代码，让您在使用TypeScript、<code class="fe ls lt lu lv b">InferGetServerSidePropsType</code>和<code class="fe ls lt lu lv b">InferGetStaticPropsType</code>进行开发时更加轻松。这很好，但是它确实有一些严重的限制，阻止您使用这些特性。幸运的是，社区已经采取措施来解决最棘手的问题，而了解这方面的一切正是本文的目的。</p><p id="36db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望这篇文章对你有所帮助。请随意留下任何问题、评论或建议。</p><p id="bb97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nl">说白了就是</em> </strong> </a> <strong class="ky ir"> <em class="nl">。</em> </strong> <em class="nl">报名参加我们的</em><strong class="ky ir"><em class="nl"/></strong><a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nl">免费每周简讯这里</em> </strong> </a> <strong class="ky ir"> <em class="nl">。</em> </strong></p></div></div>    
</body>
</html>