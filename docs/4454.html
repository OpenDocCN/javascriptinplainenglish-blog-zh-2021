<html>
<head>
<title>React Context is a Global Variable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应上下文是一个全局变量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-is-a-global-variable-b4b049812028?source=collection_archive---------4-----------------------#2021-09-05">https://javascript.plainenglish.io/react-context-is-a-global-variable-b4b049812028?source=collection_archive---------4-----------------------#2021-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React里没有Redux的对应词，最接近的一个叫Context。我们中有相当多的人认为，与Redux相比，上下文是本地的，而Redux对站点来说是全局的，尤其是当涉及到数据存储的位置时。</p><p id="356e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，React context并没有被设计成一个局部变量，就像纤程、钩子或者任何局限于一个工作单元的东西一样。恰恰相反，都不是。所以我们将在下面解释为什么。</p><h2 id="9a48" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">创建一个上下文</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/27b1ac47356982faf198bc571628463f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qALZRZ7THhAtoCxygg9Jg.png"/></div></div></figure><p id="f7a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文由函数<code class="fe ln lo lp lq b">createContext</code>创建，</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="0f94" class="ki kj in lq b gy lv lw l lx ly">const UserContext = createContext(defaultValue)<br/>export default UserContext</span></pre><p id="5d75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文对象是保存值的元素，</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="8c06" class="ki kj in lq b gy lv lw l lx ly">{<br/>  <strong class="lq io">_currentValue</strong>: defaultValue,<br/>  Provider: { ... },<br/>  Consumer: { ... }<br/>}</span></pre><p id="8c95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文，比如<code class="fe ln lo lp lq b">UserContext</code>，被立即导出，因为它需要被每个提供者和消费者引用。把它们放在同一个文件里不会暴露它的本质。上下文需要与消费者和提供者共享！</p><h2 id="f258" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">上下文范围</h2><p id="af44" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">在讨论上下文作用域之前，我们先来看看什么是函数作用域。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="cd9e" class="ki kj in lq b gy lv lw l lx ly">function provider1(value) {<br/>  const provider2 = (value) =&gt; {<br/>    const provider3 = (value) =&gt; {<br/>      console.log(value)  <br/>    }<br/>    provider3(3)<br/>  }<br/>  provider2(2)<br/>}<br/>provider1(1)</span></pre><p id="e9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">猜猜上面代码的输出是什么。答案是<code class="fe ln lo lp lq b">3</code>。因为我们都知道函数有一个范围。在函数范围内，输入参数中的局部变量优先。</p><p id="3ba2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文提供者以类似的方式设计，它使用一个堆栈在进入内部范围之前将旧值推入，然后在离开范围之后将旧值弹出。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="2692" class="ki kj in lq b gy lv lw l lx ly">const Branch = ({ theme1, theme2 }) =&gt; {<br/>  return (<br/>    &lt;ThemeContext.Provider value={theme1}&gt;<br/>      // <strong class="lq io">A</strong>. value = theme1<br/>      &lt;ThemeContext.Provider value={theme2}&gt;<br/>        // <strong class="lq io">B</strong>. value = theme2<br/>      &lt;/ThemeContext.Provider&gt;<br/>      // <strong class="lq io">C</strong>. value = theme1<br/>    &lt;/ThemeContext.Provider&gt; <br/>    // <strong class="lq io">D.</strong> value = defaultValue<br/>  )<br/>}</span></pre><p id="a04c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有没有想过，给定<code class="fe ln lo lp lq b">theme1</code>和<code class="fe ln lo lp lq b">theme2</code>，为什么位置<strong class="jm io"> A </strong>、<strong class="jm io"> B </strong>和<strong class="jm io"> C </strong>的上下文值不同？同一个<code class="fe ln lo lp lq b">ThemeContext</code>下的单个变量<code class="fe ln lo lp lq b">_currentValue</code>怎么可能保存一个动态值？这怎么可能？什么是<code class="fe ln lo lp lq b">_currentValue</code>？不是<code class="fe ln lo lp lq b">theme1</code>，不是<code class="fe ln lo lp lq b">theme2</code>？</p><p id="6209" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码似乎不能与代码中提到的任何本地值一起工作。</p><h2 id="0dd6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">堆栈和光标</h2><p id="0338" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">因此，原来有一个全局变量在幕后工作，称之为<code class="fe ln lo lp lq b">cursor</code>。在我们用一个<code class="fe ln lo lp lq b">value</code>进入一个内部作用域之前，我们把它推入一个堆栈。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="46ff" class="ki kj in lq b gy lv lw l lx ly">function push(cursor, value) {<br/>  index++<br/>  <br/>  valuesStack[index] = cursor.current<br/>  <br/>  cursor.current = value<br/>}</span></pre><p id="a585" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">push</code>操作将旧值放入堆栈，然后将<code class="fe ln lo lp lq b">cursor</code>的当前值替换为新的<code class="fe ln lo lp lq b">value</code>。在我们完成内部作用域后，我们将它从堆栈中弹出。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="734b" class="ki kj in lq b gy lv lw l lx ly">function pop(cursor) {<br/>  if (index &lt; 0) return<br/>  <br/>  cursor.current = valueStack[index]<br/>  valueStack[index] = null<br/>  index--<br/>}</span></pre><p id="d4cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，<code class="fe ln lo lp lq b">cursor</code>总是指向相对于作用域的最新值。堆栈用来确保它能找到返回的路。</p><h2 id="817b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">推送和弹出提供商</h2><p id="f5c6" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这就是嵌套时提供程序的工作方式。当我们开始更新一个提供商时，它会将其推入。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="8d1d" class="ki kj in lq b gy lv lw l lx ly">function updateContextProvider(current, workInProgress) {<br/>  ...<br/>  pushProvider(workInProgress, newValue)<br/>  if (oldProps !== null) { ... }<br/>  ...<br/>}</span><span id="bea1" class="ki kj in lq b gy me lw l lx ly">function pushProvider(providerFiber, nextValue) {<br/>  var context = providerFiber.type._context</span><span id="5469" class="ki kj in lq b gy me lw l lx ly">  push(valueCursor, context._currentValue)<br/>  context._currentValue = nextValue;<br/>}</span></pre><p id="9016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">pushProvider</code>函数通过属性<code class="fe ln lo lp lq b">value</code>将上下文的<code class="fe ln lo lp lq b">_currentValue</code>设置为<code class="fe ln lo lp lq b">newValue</code>。内在范围的消费者就是这样获得内在价值的。在此之前，你可以看到它如何将旧的<code class="fe ln lo lp lq b">_currentValue</code>放入堆栈，并将其与一个全局变量<code class="fe ln lo lp lq b">valueCursor</code>一起存储。</p><pre class="lc ld le lf gt lr lq ls lt aw lu bi"><span id="65b4" class="ki kj in lq b gy lv lw l lx ly">function popProvider(providerFiber) {<br/>  var currentValue = valueCursor.current<br/>  pop(valueCursor)<br/>  var context = providerFiber.type._context</span><span id="c81c" class="ki kj in lq b gy me lw l lx ly">  context._currentValue = currentValue<br/>}</span></pre><p id="a363" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当提供者完成<code class="fe ln lo lp lq b">completeWork</code>中的工作时，它调用<code class="fe ln lo lp lq b">popProvider</code>，后者将上下文的<code class="fe ln lo lp lq b">currentValue</code>设置回来自<code class="fe ln lo lp lq b">valueCursor</code>的保存值。在此之前，你可以看到它是如何从堆栈中取出旧值的。</p><h2 id="06b8" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">摘要</h2><p id="3a31" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">在任何时候，都只有一个上下文，比如<code class="fe ln lo lp lq b">UserContext</code>对象，因此<code class="fe ln lo lp lq b">_currentValue</code>确实保存一个“全局”变量，并且当它进入每个提供者的范围时，只切换到保存一个局部范围值(通过<code class="fe ln lo lp lq b">value</code> prop ),因为消费者需要从<code class="fe ln lo lp lq b">_currentValue</code>中读取。</p><p id="8b7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果您想要找到对应于所有使用者(连接在多个作用域中)的所有上下文值，您唯一可以找到的地方是堆栈，它保存每个嵌套作用域中的上下文值列表。</p><p id="64d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您可能会认为上下文值在正确的范围内将<strong class="jm io">启用</strong>到本地提供者设置中，但是我们必须承认，上下文值，例如<code class="fe ln lo lp lq b">_currentValue</code>，上下文的唯一数据存储，本质上是一个全局变量。</p><h2 id="a314" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">附录</h2><p id="7db6" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">为什么我们关心上下文是全局变量还是局部变量？如果你仍然认为上下文不能做redux所提供的事情，这很重要。因为在理论上，基于上面解释的设计，一个上下文可以做任何事情，因为它没有与任何纤程连接，它是一个全局共享变量。实际上，更好的是，当上下文进入提供者的范围时，它可以切换到本地范围版本，这应该使它比Redux提供的更通用。</p><p id="e3d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">过去的问题是如何在上下文中正确使用<code class="fe ln lo lp lq b">React.memo</code>。因为没有了<code class="fe ln lo lp lq b">memo</code>，语境就可能成为灾难性的武器。因此，为了避免这些问题，需要改进上下文，至少需要非常清楚如何更新特定的值，而不会过度渲染。也许这不是上下文的问题，因为Redux也有过多的渲染。</p><p id="a388" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文写作期间，React正在提出<code class="fe ln lo lp lq b">useContextSelector</code>，这似乎将它放在了一个光明的方向。这是<a class="ae mf" href="https://github.com/facebook/react/pull/20646" rel="noopener ugc nofollow" target="_blank">提案</a>。</p><p id="5494" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mg">更多内容尽在</em><a class="ae mf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mg">plain English . io</em></strong></a></p></div></div>    
</body>
</html>