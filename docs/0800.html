<html>
<head>
<title>Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中提升</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hoisting-in-javascript-59c4279438db?source=collection_archive---------7-----------------------#2021-02-19">https://javascript.plainenglish.io/hoisting-in-javascript-59c4279438db?source=collection_archive---------7-----------------------#2021-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0ca7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我参加奖学金项目已经有一段时间了，最近我偶然发现了这个神奇的吊装概念！在这篇文章中，我将以最简单的方式向你详细解释不同情况下的吊装。所以，喝杯咖啡，带上你的笔记本电脑，让我们一起深入起重的世界吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/65ec2a6b6c766a605807f27f789a42b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*YJA6GkbSwgDGOByy.png"/></div></figure><p id="73dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从一个基本的例子开始。我需要声明、初始化并打印一个变量。我是这样做的:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="5f2a" class="kv kw in kr b gy kx ky l kz la">var x;<br/>x = 7;<br/>console.log(`Variable x has a value ${x}`);</span></pre><p id="5136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我运行上面的代码片段时，我得到的输出如下:</p><blockquote class="lb lc ld"><p id="99f9" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">变量x的值是7</p></blockquote><p id="8a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果我改变我写上面代码的方式呢？现在我将编写这样的代码:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="10b6" class="kv kw in kr b gy kx ky l kz la">x=7;<br/>console.log(`Variable x still has a value ${x}`);<br/>var x;</span></pre><p id="4fe2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我又得到了输出。没有任何错误！</p><blockquote class="lb lc ld"><p id="f711" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">变量x的值仍然是7</p></blockquote><p id="8b53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">刚才发生的现象被称为提升。很酷，不是吗？</p><p id="4037" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以典型的形式定义提升，它是JavaScript的<strong class="jm io">行为</strong>(<strong class="jm io">不是特性</strong>而是行为)，其中JavaScript将所有声明移动到当前作用域的顶部。也就是说，无论你在哪里声明变量，你仍然可以在程序的任何地方访问它的值——甚至在声明之前！</p><p id="2252" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想强调一下术语“<strong class="jm io">变量声明</strong>”。变量初始化不被提升，但声明被提升。让我们看一个同样的例子:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="8b00" class="kv kw in kr b gy kx ky l kz la">var x;<br/>console.log(`Variable x has a value ${x}`);<br/>x=7;</span></pre><p id="2326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我没有得到正确的x值作为我的答案。相反，我得到了“未定义”。</p><blockquote class="lb lc ld"><p id="2793" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">变量x的值未定义</p></blockquote><p id="af1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我声明了变量，并在使用后初始化它，但在示例2中，我在使用前初始化它，在使用后声明它。因此，只有声明被提升，初始化没有被提升。JavaScript在执行前扫描代码中的变量声明。因此，我们得到了我们使用的变量的值。</p><p id="7896" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">干得好！现在，让我们理解提升是如何作用于变量、函数等等的，因为并不是JavaScript中的所有东西都是提升的。</p><h1 id="ec89" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.函数声明</h1><p id="241d" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">这里，我们讨论的是JavaScript中的简单函数，而不是函数表达式或箭头函数。<strong class="jm io">函数声明被提升，它们的初始值是函数的初始值。</strong>让我们看一个例子:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="bca2" class="kv kw in kr b gy kx ky l kz la">console.log(add(5, 7));<br/>function add(i, j) {<br/>    return i + j;<br/>}</span></pre><blockquote class="lb lc ld"><p id="224d" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> → 12</p><p id="ef98" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因:</strong>在这里，我甚至在声明函数之前就调用了它，并且得到了没有任何错误的输出。因此，函数声明被挂起。</p></blockquote><h1 id="d00a" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.“var”关键字</h1><p id="13ab" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">正如我们在第二个例子中看到的，我们甚至可以在声明之前使用<strong class="jm io"> x </strong>的值。<strong class="jm io">因此，用var关键字声明的变量(也称为var变量)被提升</strong>。初始值→未定义(如果初始化是在使用之后)。因此，如果变量在变量声明之前没有初始化，var变量将被提升为初始值undefined。</p><p id="a0ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="6425" class="kv kw in kr b gy kx ky l kz la">console.log(`My Github username is ${me}`);<br/>var me = "Tanmayee-07";</span></pre><blockquote class="lb lc ld"><p id="b9e8" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →我的Github用户名未定义</p><p id="d2d7" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因:</strong>变量“me”被提升了，但由于它在使用后进行了初始化，所以它被初始化为值“undefined”，因为我们知道“声明被提升，初始化没有被提升！”</p></blockquote><h1 id="5c9a" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.Let和const关键字</h1><p id="1a45" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io">用“let”和“const”声明的变量不被提升。</strong>记住这一点很重要，因为很多人可能认为let和const就像var一样被提升，因为这三者都只用于声明变量。但是，它们是<strong class="jm io">现代JavaScript</strong>(ES6版本后的JS)的一部分，它们没有被挂起！</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="e7b0" class="kv kw in kr b gy kx ky l kz la">console.log(me);<br/>console.log(blogName);<br/>let me = "Tanmayee";<br/>const blogName = "hoisting";</span></pre><blockquote class="lb lc ld"><p id="18a4" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →未捕获引用错误:初始化前无法访问‘me’；<strong class="jm io">原因</strong> → let和const变量没有被提升。所以，我不能在声明前访问它们。</p></blockquote><h1 id="a700" class="li kw in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4.函数表达式和箭头函数</h1><p id="5ad9" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">它们的提升取决于用来声明它们的关键字。如前所述，带有<strong class="jm io"> let </strong>和<strong class="jm io"> const </strong>的变量不被提升，而带有<strong class="jm io"> var </strong>的变量被提升。因此，如果我用“var”关键字声明一个函数表达式/箭头函数，<strong class="jm io">它们将被提升，但将有一个未定义的初始值。</strong>另一方面，如果我用“let”或“const”关键字声明一个函数表达式/箭头函数，它们不会被提升。让我们用例子来理解这一点。</p><h2 id="aff3" class="kv kw in bd lj mk ml dn ln mm mn dp lr jv mo mp lv jz mq mr lz kd ms mt md mu bi translated">函数表达式示例:</h2><p id="d2fb" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io"> a .用“var”关键字</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="f56a" class="kv kw in kr b gy kx ky l kz la">console.log(add(3, 5));<br/>var add = function(i, j) {<br/>    return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="6820" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →未捕获类型错误:添加不是一个函数</p><p id="e5f1" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因</strong> →是的，我的函数被提升了，但是输出并不像预期的那样是8，因为var的初始值是undefined。因此，函数被提升了，但是它的值是undefined，我们试图在第一行调用" undefined ",这是不可能的！</p></blockquote><p id="8981" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> b .用“让”关键字</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="663a" class="kv kw in kr b gy kx ky l kz la">console.log(addFuncExp(4, 5));<br/>let addFuncExp = function(i, j) {<br/>    return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="ec74" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →初始化前无法访问‘addfuncepx’</p><p id="502c" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因</strong> → let未吊起。</p></blockquote><p id="ebe0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> c .用“const”关键字</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="ebf2" class="kv kw in kr b gy kx ky l kz la">console.log(add(1, 6));<br/>const add = function(i, j) {<br/>    return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="764a" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> → script.js:2未捕获的引用错误:初始化前无法访问“add”</p><p id="c7c8" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因:</strong> const未吊起。</p></blockquote><h2 id="7c9f" class="kv kw in bd lj mk ml dn ln mm mn dp lr jv mo mp lv jz mq mr lz kd ms mt md mu bi translated">箭头函数示例:</h2><p id="e5b7" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io"> a .带“var”的</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="db61" class="kv kw in kr b gy kx ky l kz la">console.log(addArrowFunc(3, 6));<br/>var addArrowFunc = (i, j) =&gt; {<br/>    return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="f438" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →未捕获类型错误:addArrowFunc不是函数</p><p id="01e6" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因</strong> →用初始值“未定义”吊起。</p></blockquote><p id="5e4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> b .用“让”</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="856e" class="kv kw in kr b gy kx ky l kz la">console.log(add(3, 5));<br/>let add = (i, j) =&gt; {<br/>    return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="9240" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →初始化前无法访问“添加”</p><p id="616a" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因</strong> → let未吊起。</p></blockquote><p id="fcd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> c .用“const”</strong></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="e428" class="kv kw in kr b gy kx ky l kz la">console.log(add(3, 5));<br/>const add = (i, j) =&gt; {<br/>      return i + j;<br/>};</span></pre><blockquote class="lb lc ld"><p id="53df" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">输出</strong> →初始化前无法访问“添加”</p><p id="3b80" class="jk jl le jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated"><strong class="jm io">原因</strong> → const未吊装。</p></blockquote><h2 id="086d" class="kv kw in bd lj mk ml dn ln mm mn dp lr jv mo mp lv jz mq mr lz kd ms mt md mu bi translated">结论</h2><p id="c641" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">就这样了！这一切都是关于提升和隐藏在下面的概念。我希望这篇文章足够有用。谢谢你的阅读。</p></div></div>    
</body>
</html>