<html>
<head>
<title>ELI5: Bubble Sort Algorithms ️🛁</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ELI5:冒泡排序算法️🛁</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/eli5-bubble-sort-algorithms-%EF%B8%8F-78bbce018846?source=collection_archive---------14-----------------------#2021-04-07">https://javascript.plainenglish.io/eli5-bubble-sort-algorithms-%EF%B8%8F-78bbce018846?source=collection_archive---------14-----------------------#2021-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9d78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先说算法。今天，我将(像你5岁时一样)分解什么是冒泡排序算法，如何用JavaScript实现它，以及何时使用它。准备好了吗？我们走吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8d828ebc7b501e2f215ed81efc5c6a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rNldbuO-MnsgguU1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@drew_beamer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Drew Beamer</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="ec9e" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是冒泡排序算法？🛁</h1><p id="2b84" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">冒泡排序算法是对算法的完美介绍，因为它易于可视化。这不是最有效的算法。然而，这是你学习算法的第一步。</p><h1 id="ceb6" class="lg lh in bd li lj mj ll lm ln mk lp lq lr ml lt lu lv mm lx ly lz mn mb mc md bi translated">冒泡排序算法的特征📝</h1><ul class=""><li id="f66e" class="mo mp in jm b jn me jr mf jv mq jz mr kd ms kh mt mu mv mw bi translated">适合排序无序列表&gt;&gt;有序列表</li><li id="6479" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">轻松比较两个项目，并在必要时交换位置</li><li id="0a1b" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">使用循环的可靠算法</li></ul><h1 id="aab1" class="lg lh in bd li lj mj ll lm ln mk lp lq lr ml lt lu lv mm lx ly lz mn mb mc md bi translated">代码:实现冒泡排序⌨️</h1><p id="43a7" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">用JavaScript写的冒泡排序算法是什么样子的？下面我给你写出来:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="282e" class="nh lh in nd b gy ni nj l nk nl">function bubbleSortAlgo(arr) {<br/>    let swap;<br/>    let n = arr.length-1;<br/>    let x = [...arr];<br/>    do {<br/>        swap = false;<br/>        for (let i = 0; i &lt; n; i++) {<br/>            if (x[i] &gt; x[i+1]) {<br/>               let temp = x[i];<br/>               x[i] = x[i+1];<br/>               x[i+1] = temp;<br/>               swap = true;<br/>            }<br/>        } n--;<br/>    } while (swap);<br/> return x; <br/>}</span></pre><p id="156a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇，这个算法有很多进展。让我们来分解每一部分。</p><p id="6c88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我做的第一件事是创建一些变量:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0cff" class="nh lh in nd b gy ni nj l nk nl">    let swap;</span></pre><p id="0e71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当<strong class="jm io">为真时，</strong><strong class="jm io">交换</strong>变量将指示我们的数组是未排序的。这将允许我们的do/while循环运行并执行它的排序魔术。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="030d" class="nh lh in nd b gy ni nj l nk nl">    let n = arr.length-1;</span></pre><p id="415f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变量<strong class="jm io"> n </strong>代表数组的长度。你会看到，在我们完成循环的完整<strong class="jm io">后，我们将n减1。我们这样做是因为在一次遍历数组后，末尾的项被排序。在以后的通行证中没有必要检查那个项目。因此，我们可以减少数组的长度，这也将减少下一次排序所需的时间。</strong></p><p id="ce42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">公平地说，节省的时间微乎其微，把这个加进去似乎有点傻。然而，我认为这是一个很好的实践，在未来的情况下，节省时间的措施是一个平稳运行的计划至关重要。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6fb5" class="nh lh in nd b gy ni nj l nk nl">    let x = [...arr]</span></pre><p id="b744" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<strong class="jm io"> x </strong>变量，我选择使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_array_literals" rel="noopener ugc nofollow" target="_blank">扩展语法</a>创建一个全新的独立版本的<strong class="jm io"> arr </strong>参数。我这样做是为了确保原始数组(arr)保持不变。只有<strong class="jm io"> x </strong>将实现我们的冒泡排序算法的改变。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d0ac" class="nh lh in nd b gy ni nj l nk nl">do {<br/>        swap = false;<br/>        for (let i = 0; i &lt; n; i++) {<br/>            if (x[i] &gt; x[i+1]) {<br/>               let temp = x[i];<br/>               x[i] = x[i+1];<br/>               x[i+1] = temp;<br/>               swap = true;<br/>            }<br/>        } n--;<br/>    } while (swap);</span></pre><p id="4f20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们代码的主要部分是<strong class="jm io"> do/while </strong>循环。每次我们进入do/while循环时，我们都将<strong class="jm io"> swap </strong>变量设置为false。当swap为false时，表示没有对我们的数组进行任何更改。这是个好消息，因为它表明到目前为止我们的数组已经排序了。</p><p id="95d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们使用数组的当前长度<strong class="jm io"> n </strong>为循环创建一个<strong class="jm io">。在for循环中，我们检查相邻的项目对。如果项目已排序，我们什么也不做。如果它们没有被正确排序，我们就交换它们的位置，并将交换变量设置为true。</strong></p><p id="742b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将我们的交换变量设置为true，我们知道我们至少需要对数组再做一次检查。do/while循环将再次运行，因为我们的交换变量为true。</p><p id="fdf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最后一次遍历数组时，我们将永远不会进入for循环。因此，交换变量将保持设置为false。然后，我们可以退出do/while循环。最后，我们可以返回数组x。</p><p id="398a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看实际情况。下面是一个使用伪代码的示例:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5184" class="nh lh in nd b gy ni nj l nk nl">let myArray = [1, 4, 3];<br/>bubbleSortAlgo(myArray);</span><span id="615d" class="nh lh in nd b gy nm nj l nk nl">// FIRST PASS<br/>set swap to false.<br/>enter for loop.<br/>compare 1 and 4, is 1 greater than 4? no! move to the next pair.<br/>compare 4 and 3, is 4 greater than 3? yes! change places.<br/>swap is set to true.<br/>decrement n by 1.<br/>we've reached the end of our array.<br/>swap is true, continue do/while loop.</span><span id="f818" class="nh lh in nd b gy nm nj l nk nl">the array currently looks like this: [1, 3, 4]</span><span id="3733" class="nh lh in nd b gy nm nj l nk nl">// SECOND PASS<br/>set swap to false.<br/>enter for loop.<br/>compare 1 and 3, is 1 greater than 3? no!<br/>remember we decremented n? we've reached the end of our for loop.<br/>no changes made, swap is still set to false.<br/>exit do/while loop.<br/>return x.<br/>algorithm is complete!!!</span><span id="1806" class="nh lh in nd b gy nm nj l nk nl">final array: [1, 3, 4]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a9be601a5d9442791a2e050ff96714d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EI4ZngJiEAX_JTdU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@deleece?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Deleece Cook</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4daf" class="lg lh in bd li lj mj ll lm ln mk lp lq lr ml lt lu lv mm lx ly lz mn mb mc md bi translated">我们什么时候使用冒泡排序？🧐</h1><p id="a0d8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">冒泡排序是对数据列表(也称为数组)进行排序的最佳选择。尤其是在学习算法和工作面试的时候。实际上，它在工作代码中并不是不太受欢迎的，因为它是低效的。还有更快、更智能的排序算法(下一节将详细介绍)。</p><p id="1937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您需要比较相邻的项目，并在必要时交换它们的位置时，此算法非常有用。</p><h1 id="5f6e" class="lg lh in bd li lj mj ll lm ln mk lp lq lr ml lt lu lv mm lx ly lz mn mb mc md bi translated">结论💭</h1><p id="e048" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">冒泡排序算法是比较大量数据并根据您定义的条件对它们进行排序的绝佳方式。正如我在介绍中提到的，它更多的是一种教育工具，因为有更有效的排序算法(quicksort、timsort、merge sort)。</p><p id="0e53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在这里了解更多关于线性搜索数据结构<a class="ae ky" href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener ugc nofollow" target="_blank">的信息，以及它在大O符号中的时间复杂度。</a></p><h1 id="2370" class="lg lh in bd li lj mj ll lm ln mk lp lq lr ml lt lu lv mm lx ly lz mn mb mc md bi translated">ELI5算法系列📚</h1><ul class=""><li id="e23e" class="mo mp in jm b jn me jr mf jv mq jz mr kd ms kh mt mu mv mw bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-bubble-sort-algorithms-%EF%B8%8F-78bbce018846" rel="noopener"> ELI5:冒泡排序算法🛁</a></li><li id="6792" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-linear-search-algorithms-%EF%B8%8F-%EF%B8%8F-6f79cf9b3bb7" rel="noopener"> ELI5:线性搜索算法🕵️‍♀️ </a></li><li id="f9b4" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-binary-search-trees-fd560f81b553" rel="noopener"> ELI5:二分搜索法树🌲</a></li></ul></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="1502" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！我叫Halee Pagel(与Cali Bagel押韵)，是日本东京的一名软件工程师。你可以在推特上找到我，我主要用它来喜欢科技迷因和MLB的更新。✌️</p></div></div>    
</body>
</html>