<html>
<head>
<title>NestJS: Integration Tests of Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS:路由的集成测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nestjs-integration-tests-of-routes-95986cb14e00?source=collection_archive---------2-----------------------#2021-10-07">https://javascript.plainenglish.io/nestjs-integration-tests-of-routes-95986cb14e00?source=collection_archive---------2-----------------------#2021-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/da32e573ed80ed67ca033f715984f1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWACXz919362hajQunSMnQ.png"/></div></div></figure><p id="4e76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NestJS是一个令人惊奇的工具，它允许构建企业级可伸缩的服务器端应用程序。这是一个灵活的框架，有许多内置特性，可以大大简化开发过程。</p><p id="4e3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管NestJS有写得很好的文档，但我注意到，对于这个框架中的新手来说，将所有部分粘合起来以实现路由的集成测试并不容易。在这里，我们将把所有部分聚集在一起。</p><p id="839e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在继续之前，这里是我们将要开发的所有代码在GitHub中的链接:<a class="ae kt" href="https://github.com/vladimirtopolev/nestjs-user-module-with-e2e-example" rel="noopener ugc nofollow" target="_blank"> GitHub link </a>。</p><h1 id="fc4d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">安装项目</h1><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cb72" class="mb kv in lx b gy mc md l me mf">npm i -g @nestjs/cli<br/>nest new integration-test-example</span></pre><p id="9530" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将使用<code class="fe mg mh mi lx b">/src</code>和<code class="fe mg mh mi lx b">/test</code>文件夹中的样板文件创建<code class="fe mg mh mi lx b">integration-test-example</code>目录。</p><h1 id="76df" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为用户实体实现RESTfull API</h1><p id="4d3b" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">让我们为用户实体实现一些CRUD操作的路线。在这个项目中，我们将使用MongoDB和Mongoose。NestJS有专门的<code class="fe mg mh mi lx b">@nestjs/mongoose</code>模块。首先安装所需的依赖项:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c37e" class="mb kv in lx b gy mc md l me mf">npm install --save @nestjs/mongoose mongoose</span></pre><p id="ffa3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们把这个模块导入到根目录<code class="fe mg mh mi lx b">AppModule</code>:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">/src/app.module.ts</figcaption></figure><p id="30cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，在生产代码中，您不应该硬编码MongoDB URI，它应该通过配置变量进行适当设置。例如，您可以使用这个包:<a class="ae kt" href="https://www.npmjs.com/package/config" rel="noopener ugc nofollow" target="_blank"> config </a>。</p><p id="97f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要创建一个用户实体的模型。为了简洁起见，我们将创建一个包含几个字段的模型，这有助于将重点放在文章的主要目的上。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">/src/modules/users/user.schema.ts</figcaption></figure><p id="a497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们为一个具有两个字段的用户实体声明模式，并添加一些验证。</p><p id="e3ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来就是<code class="fe mg mh mi lx b">UserService</code>的实施。在<code class="fe mg mh mi lx b">UserService</code>中，我们要求NestJS通过依赖注入机制传递一个用户模型，UserService本身应该是可注入的，因为它将在我们稍后创建的控制器中使用:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">src/modules/users/user.service.ts</figcaption></figure><p id="b3f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，在这里的构造函数中，我们通过<code class="fe mg mh mi lx b">@nestjs/mongoose</code>模块的特殊装饰器<code class="fe mg mh mi lx b">@InjectModel</code>注入<code class="fe mg mh mi lx b">userModel</code>。</p><p id="f29a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是CRUD操作的实现路线，我们需要创建<code class="fe mg mh mi lx b">UserController</code>并在那里注入已经实现的<code class="fe mg mh mi lx b">UserService</code>:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">src/modules/users/user.controller.ts</figcaption></figure><p id="e8d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在构造函数中，我们通过DI注入<code class="fe mg mh mi lx b">UserService</code>并为CRUD操作定义一些路径。</p><p id="dfd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将所有实现的部分收集到一个单独的应用程序模块中，然后:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">src/modules/users/user.module.ts</figcaption></figure><p id="90d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们包括实现的<code class="fe mg mh mi lx b">UserController</code>和<code class="fe mg mh mi lx b">UserService</code>，这些组件将可用于注入。此外，我们声明在这个模块中应该使用哪个确切的MongoDB模型。</p><p id="2e15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步是将<code class="fe mg mh mi lx b">UserModule</code>模块包含在<code class="fe mg mh mi lx b">AppModule</code>中:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dd31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。我们完成了，我们可以通过Postman运行应用程序并测试开发的路线:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f8c0" class="mb kv in lx b gy mc md l me mf">npm run start</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/ad95e3c49a39812d4d41566b374eaed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uh4o8cSYEqSV-yjes5eBaw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">POST /users</figcaption></figure><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/7f1b05f4450c180f2547e5535ac7cde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFAmsEh0y0LcvM8XbnTJEQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">GET /users</figcaption></figure><h1 id="ecee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">机械综合测试</h1><p id="3005" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">你可能已经问过他们的第一个问题是我们要用MongoDB做什么。有几个选项:<br/> 1 —模拟Mongoose库方法<br/> 2 —对本地运行的MongoDB进行测试</p><p id="798d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个选项需要大量的工作来模拟所使用的Mongoose库的所有方法，第二个选项依赖于强制旋转的本地MongoDB。</p><p id="f0c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我更喜欢使用轻量级MongoDB内存服务器模拟MongoDB。从字面上看，这意味着我们甚至可以在不运行真正的MongoDB的情况下进行开发。好吧，让我们安装它:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2dca" class="mb kv in lx b gy mc md l me mf">npm i -D mongodb-memory-server</span></pre><p id="c6c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在MongooseModule中实现一个将MongoDB集成到内存中的测试助手:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">test/utils/mongodb-in-memory.ts</figcaption></figure><p id="e19c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始为我们的用户路由实现测试用例，并导入测试模块MongoDB-In-Memory和测试用户模块:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dd44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，通过DI，我们将MongoDB-In-Memory和<code class="fe mg mh mi lx b">UserModule</code>注入，我们也从<code class="fe mg mh mi lx b">TestModule</code>获得一个引用到<code class="fe mg mh mi lx b">UserModel</code>，它直接访问DB，在任何测试之前，我们可以用我们想要的方式填充DB。此外，我们创建了<code class="fe mg mh mi lx b">app</code>，它将与<code class="fe mg mh mi lx b">supertest</code>库一起用于路由测试。</p><p id="6e53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，让我们为<em class="mw"> GET </em>请求编写测试。为了正确地测试它，在请求路由之前，我们需要用一些用户填充用户集合:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="509b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在DB中填充了10个用户，因此在测试用例中，我们可以检查有多少用户获得了请求返回:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="dda8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们也为POST请求实现一个测试。在这里，我们创建用户实体，检查它是否返回响应，并再次检查它是否已保存在数据库中:</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="26d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。希望这对你有用。你可以在这里找到完整的代码库:<a class="ae kt" href="https://github.com/vladimirtopolev/nestjs-user-module-with-e2e-example" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a></p><p id="fb4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw">更多内容看</em> <a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mw">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>