<html>
<head>
<title>LeetCode Algorithm Challenges: Path Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法挑战:路径和</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-challenges-path-sum-25cab495220c?source=collection_archive---------1-----------------------#2021-07-18">https://javascript.plainenglish.io/leetcode-algorithm-challenges-path-sum-25cab495220c?source=collection_archive---------1-----------------------#2021-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="1ff2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题</h1><p id="5822" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">给定一棵二叉树的<code class="fe lg lh li lj b">root</code>和一个整数<code class="fe lg lh li lj b">targetSum</code>，如果该树有一条<strong class="kk io">根到叶的</strong>路径，使得沿着该路径的所有值相加等于<code class="fe lg lh li lj b">targetSum</code>，则返回<code class="fe lg lh li lj b">true</code>。</p><p id="e662" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">一片<strong class="kk io">叶子</strong>是一个没有孩子的节点。</p><p id="355e" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated"><strong class="kk io">例1: </strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/1cd9db8ea0a1c109b3c16102b3faa231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*85OHal8dD6-JgC77.jpg"/></div></figure><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="7e7a" class="mb jl in lj b gy mc md l me mf"><strong class="lj io">Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br/><strong class="lj io">Output:</strong> true</span></pre><p id="4165" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated"><strong class="kk io">例2: </strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/7e2804e69131ff0b082c68f083396806.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*1zBL1Rntw0iDQraD.jpg"/></div></figure><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="a86f" class="mb jl in lj b gy mc md l me mf"><strong class="lj io">Input:</strong> root = [1,2,3], targetSum = 5<br/><strong class="lj io">Output:</strong> false</span></pre><p id="c458" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated"><strong class="kk io">例3: </strong></p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="f557" class="mb jl in lj b gy mc md l me mf"><strong class="lj io">Input:</strong> root = [1,2], targetSum = 0<br/><strong class="lj io">Output:</strong> false</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="d85f" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">在这个挑战中，逻辑非常简单:</p><ol class=""><li id="ebfd" class="mo mp in kk b kl lk kp ll kt mq kx mr lb ms lf mt mu mv mw bi translated">穿过树枝</li><li id="f09c" class="mo mp in kk b kl mx kp my kt mz kx na lb nb lf mt mu mv mw bi translated">将分支的所有值相加</li><li id="fad4" class="mo mp in kk b kl mx kp my kt mz kx na lb nb lf mt mu mv mw bi translated">一旦我们到达一个叶子，即没有任何子节点的节点，检查我们从#2得到的和是否等于targetSum</li><li id="0a73" class="mo mp in kk b kl mx kp my kt mz kx na lb nb lf mt mu mv mw bi translated">如果是假的，继续检查</li></ol><p id="704e" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">递归函数将被用来解决这个问题，因为我们并不真的想检查每个节点，一旦我们有一个匹配。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="3f90" class="jk jl in bd jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh bi translated">解决办法</h1><p id="537d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我将调用我的递归函数checkTree，它将接受以下参数<code class="fe lg lh li lj b">root, targetSum, sum</code>。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="5b01" class="mb jl in lj b gy mc md l me mf">function checkTree(root, targetSum, sum) {</span><span id="b9e1" class="mb jl in lj b gy nh md l me mf">....</span><span id="bea6" class="mb jl in lj b gy nh md l me mf">}</span></pre><p id="de7f" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">首先检查<code class="fe lg lh li lj b">root</code>是否存在是有意义的，所以我们可以先抛出一个简单的if语句。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="5018" class="mb jl in lj b gy mc md l me mf">if (!root) {</span><span id="4a28" class="mb jl in lj b gy nh md l me mf">  return false;</span><span id="1bac" class="mb jl in lj b gy nh md l me mf">}</span></pre><p id="7f7e" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">现在我们可以开始为当前分支填充<code class="fe lg lh li lj b">sum</code>。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="6f93" class="mb jl in lj b gy mc md l me mf">sum += root.val;</span></pre><p id="ab3d" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">现在，我们想通过检查<code class="fe lg lh li lj b">root</code>是否有孩子来知道我们是否到达了叶子(即分支的末端)。如果<code class="fe lg lh li lj b">root</code>是叶子，那么我们应该检查<code class="fe lg lh li lj b">sum</code>是否等于<code class="fe lg lh li lj b">targetSum</code>并返回<code class="fe lg lh li lj b">true</code>或<code class="fe lg lh li lj b">false</code>。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="00db" class="mb jl in lj b gy mc md l me mf">if (root.left === null &amp;&amp; root.right === null) {</span><span id="1a6e" class="mb jl in lj b gy nh md l me mf">  return sum === targetSum;</span><span id="09ce" class="mb jl in lj b gy nh md l me mf">}</span></pre><p id="37c7" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">否则，让我们在子节点上进一步使用<code class="fe lg lh li lj b">checkTree</code>函数。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="dac7" class="mb jl in lj b gy mc md l me mf">return checkTree(root.left, targetSum, sum) || checkTree(root.right, targetSum, sum)</span></pre><p id="913d" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">请注意，我们正在使用<code class="fe lg lh li lj b">||</code>运算符，因为我们正在寻找<code class="fe lg lh li lj b">true</code>值。<code class="fe lg lh li lj b">checkTree</code>函数将返回真或假，并且<code class="fe lg lh li lj b">||</code>将选择<code class="fe lg lh li lj b">true</code>作为选项。</p><p id="d01e" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">现在让我们执行刚刚编写的函数。</p><pre class="lq lr ls lt gt lx lj ly lz aw ma bi"><span id="474e" class="mb jl in lj b gy mc md l me mf">return checkTree(root, targetSum, 0);</span></pre></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="f390" class="jk jl in bd jm jn nc jp jq jr nd jt ju jv ne jx jy jz nf kb kc kd ng kf kg kh bi translated">密码</h1><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="077d" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated">请在以下社交网络上查看我，我很乐意收到你的来信！——<a class="ae nl" href="https://www.linkedin.com/in/nick-solonyy/" rel="noopener ugc nofollow" target="_blank"><em class="nk">LinkedIn</em></a><em class="nk">，</em> <a class="ae nl" href="https://github.com/nicksolony" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> GitHub </em> </a>，<a class="ae nl" href="https://www.facebook.com/nick.solony" rel="noopener ugc nofollow" target="_blank"> <em class="nk">脸书</em> </a> <em class="nk">。</em></p><p id="259f" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb lo ld le lf ig bi translated"><em class="nk">更多内容看</em><a class="ae nl" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk io"><em class="nk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>