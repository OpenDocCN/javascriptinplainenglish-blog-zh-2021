<html>
<head>
<title>How to Correctly Use TypeScript Module Import Syntax and Settings in Various Circumstances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在各种情况下正确使用TypeScript模块导入语法和设置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-correctly-use-typescript-module-import-syntax-and-settings-in-various-circumstances-e98bfa87f70f?source=collection_archive---------2-----------------------#2021-06-24">https://javascript.plainenglish.io/how-to-correctly-use-typescript-module-import-syntax-and-settings-in-various-circumstances-e98bfa87f70f?source=collection_archive---------2-----------------------#2021-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/51a5c92c551bfc3763f985a49629f0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywkGJ-Zhohw3fsQ2iL3fwg.jpeg"/></div></div></figure><p id="7d69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将模块导入TypeScript代码，然后用Node.js编译并运行代码并不总是像听起来那么简单。事实上，结果取决于几个因素的共同作用。在某些情况下，正确设置所有这些因素并不容易使它们发挥作用。</p><p id="598e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在努力在CommonJS包中导入和使用新的esM模块，或者您被诸如<em class="kt">(模块只能使用‘esModuleInterop’标志默认导入)；“当定位ECMAScript模块时不能使用导入分配”、“ES模块范围中未定义require，您可以使用import代替”</em>之类的错误消息所迷惑，请继续阅读。</p><p id="e99f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我做了一个项目，测试了这些因素的各种设置的所有组合，以找到这个问题的简单而可靠的答案，<em class="kt">“什么时候使用这个或那个设置？”</em>我寻找的答案必须比“视情况而定”更好。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="3c7b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">影响结果的球员和因素</h1><p id="5c92" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">我们应该首先了解这个游戏中的三个玩家:TypeScript编译器tsc、Javascript运行时Node.js以及我们想要导入到代码中的模块。在这个过程中，每个玩家都有一些影响整体结果的设置或属性。</p><p id="409e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用打字稿写代码。我们的代码包括用于导入我们使用的其他模块的import语句。我们使用tsc进行类型检查，并将我们的类型脚本代码(包括导入语句)编译成Javascript。在此过程中，导入语句的语法(在TypeScript中)以及tsc选项“模块”、“allowSyntheticDefaultImports”和“esModuleInterop”会影响类型检查和生成的JavaScript，包括JavaScript文件中的结果导入语句。</p><p id="a89b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将生成的JavaScript文件放在一个包中，在包的根目录中有一个“package.json”文件，并使用Node.js来运行它们。在运行时，Node.js将我们的JavaScript文件视为CommonJS模块或es模块(但不是两者都是)，并相应地为JavaScript代码提供CommonJS或es模块系统。Node.js根据“package.json”中的“type”字段确定我们模块的类型。阅读<a class="ae me" href="https://nodejs.org/api/packages.html#packages_type" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多细节。</p><p id="8966" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个模块系统提供了非常不同的语法和实现。带有CommonJS的JavaScript可以使用“require()”导入其他CommonJS模块，但是只能使用<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports" rel="noopener ugc nofollow" target="_blank">动态导入</a>“import()”导入es模块。使用ES模块的JavaScript可以使用“导入”语句(例如<code class="fe mf mg mh mi b">import moment from “moment”</code>)和动态导入来导入CommonJS和ES模块。如果您不了解这两个模块系统的基础知识和它们的主要区别，请在此停下来，在继续之前对这两个模块系统进行一些研究。</p><p id="18d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简要回顾一下这些因素以及它们如何影响结果:</p><ul class=""><li id="e6f6" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">类型脚本代码中导入语句的语法和编译器(tsc)选项(“module”和“esModuleInterop”)一起影响类型检查，并确定最终JavaScript代码中的导入语句，</li><li id="1696" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">“package.json”中的“type”字段—确定包的类型以及system Node.js为其中的JavaScript代码提供的模块，以及</li><li id="c3a7" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">正在导入的模块的类型(CommonJS或ES模块)与上面的其他因素一起决定了结果。</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="c0b0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实验</h1><p id="7c3d" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">由于所有这些因素相互作用影响结果，在特定情况下使用的正确组合并不总是显而易见的。我开发了一个<a class="ae me" href="https://github.com/bingtimren/experiment-n-learn-typescript-module-settings/blob/main/test.sh" rel="noopener ugc nofollow" target="_blank">脚本</a>来测试这些因素的完整组合以及这些因素的每种组合的最终结果——在每种组合下，类型脚本代码是否都能成功编译和执行。项目可以在<a class="ae me" href="https://github.com/bingtimren/experiment-n-learn-typescript-module-settings" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="977a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实验中，这些因素被定义为:</p><p id="7cc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(1)PKG-类型:“package.json”中的“类型”字段确定包的类型，取值为“commonjs”(对于CommonJS)或“module”(对于es模块)</p><p id="6ecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(2)目标:要导入的模块。我选择了“<a class="ae me" href="https://www.npmjs.com/package/moment" rel="noopener ugc nofollow" target="_blank">矩</a>”作为CommonJS模块的代表，“<a class="ae me" href="https://www.npmjs.com/package/p-map" rel="noopener ugc nofollow" target="_blank"> p-map </a>”作为es模块的代表。最后，我添加了“混合”，在这种情况下，我试图导入“时刻”和“p-map”并一起使用它们</p><p id="3ee3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(3)模块:tsc设置中的“模块”选项(在tsconfig.json中设置或通过命令行参数设置)，取值为“commonjs”(指示tsc发出CommonJS导入语句，如“require()”)或“es2020”。“es2015”、“es2020”或更高设置指示tsc发出es模块导入语句。“es2015”产生的结果与“es2020”相同，但是，此选项不支持动态导入。有关该选项的更多信息，请参见tsconfig.json <a class="ae me" href="https://www.typescriptlang.org/tsconfig" rel="noopener ugc nofollow" target="_blank">参考</a>。</p><p id="fb80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(4)用例:使用不同类型脚本导入语法的测试用例。对于包“moment”(代表CommonJS包)和“p-map”(代表es模块包)，这包括:</p><ul class=""><li id="f4b8" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated">“默认导入”:例如<code class="fe mf mg mh mi b">import moment from “moment”</code></li><li id="e812" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">“名称空间导入”:例如<code class="fe mf mg mh mi b">import * as moment from “moment”</code></li><li id="cd9f" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">“import-equal”:import = require()语法，例如<code class="fe mf mg mh mi b">import moment = require(“moment”)</code></li><li id="bd55" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">“动态导入”:如<code class="fe mf mg mh mi b">import(“moment”).then()</code>或<code class="fe mf mg mh mi b">await import("moment")</code></li><li id="fd23" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated">“old-require”:旧的CommonJS require()语法，例如<code class="fe mf mg mh mi b">const moduleMoment = require(“moment”)</code></li></ul><p id="0a72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于导入混合模块(TARGET=mixing)，提供了两个测试用例，以展示和证明在CommonJS或es模块包中使用混合包的正确语法和设置。</p><p id="897b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(5)esmoduleineterop:TSC设置中的“esmoduleineterop”选项修复了在处理类似es模块的CommonJS模块时的一些不匹配问题。启用<code class="fe mf mg mh mi b">esModuleInterop</code>也会启用<code class="fe mf mg mh mi b"><a class="ae me" href="https://www.typescriptlang.org/tsconfig#allowSyntheticDefaultImports" rel="noopener ugc nofollow" target="_blank">allowSyntheticDefaultImports</a></code>。取“真”和“假”之间的值。</p><p id="ba3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae me" href="https://github.com/bingtimren/experiment-n-learn-typescript-module-settings/blob/main/test.sh" rel="noopener ugc nofollow" target="_blank">脚本</a>使用不同的tsc选项(“模块”和“esModuleInterop”)将每个测试用例——一个导入不同模块(“目标”)的. ts文件(“case”)编译成Javascript，并将其放在不同的包中(“PKG类型”)。如果编译成功，脚本将使用Node.js执行Javascript来检查最终结果。</p><h1 id="272f" class="lb lc in bd ld le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly bi translated">原始结果</h1><p id="a5a9" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">该实验生成如下所示的报告，完整的报告可以在<a class="ae me" href="https://github.com/bingtimren/experiment-n-learn-typescript-module-settings/blob/main/test.log" rel="noopener ugc nofollow" target="_blank">这里</a>找到。报告的每一行都表示一种组合下的结果。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e146c8dfa2ab37c9e28a437c2fd27f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*E20VaddPWR8UbAx7yPHZBA.png"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="b134" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简明指南</h1><p id="bf45" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">有了测试的完整组合，我们就可以回答这个问题:在某种情况下，我们应该使用什么导入语法和选项来导入一个模块？先说简单的案例。</p><h2 id="532f" class="nh lc in bd ld ni nj dn lh nk nl dp ll kg nm nn lp kk no np lt ko nq nr lx ns bi translated">当一个CommonJS模块导入另一个CommonJS模块时</h2><p id="bf8d" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">当我们的“package.json”中的“type”为“commonjs”或不存在，并且我们正在导入另一个CommonJS模块时，将tsconfig.json中的“module”选项设置为“commonjs”。然后，我们可以使用任何“默认导入”、“名称空间导入”或“import = require()”语法。但是，请注意，有时“名称空间导入”和“默认导入”语法中只有一种有效，这取决于“esModuleInterop”的设置。</p><p id="89e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以使用旧的“require()”语法。但是，该语法丢失了类型(模块作为“any”导入)。或者，如果有必要，我们可以使用动态导入。然而，如果可能的话，静态导入是更可取的，因为它更容易从静态分析工具和树抖动中受益。</p><h2 id="e038" class="nh lc in bd ld ni nj dn lh nk nl dp ll kg nm nn lp kk no np lt ko nq nr lx ns bi translated">当一个ES模块导入另一个ES模块时</h2><p id="ba6a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">当我们的“package.json”中的“type”是“module”并且我们正在导入另一个ES模块时，将tsconfig.json中的“Module”选项设置为“es2020”。然后，我们可以使用“默认导入”或“名称空间导入”语法。“esModuleInterop”并不重要。</p><p id="7f57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，我们可以使用动态导入，但只是在必要的时候。从静态分析工具和树抖动的好处来看，静态导入更好。</p><h2 id="7835" class="nh lc in bd ld ni nj dn lh nk nl dp ll kg nm nn lp kk no np lt ko nq nr lx ns bi translated">当ES模块导入CommonJS模块时</h2><p id="337c" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">当我们的“package.json”中的“type”是“module”并且我们正在导入一个CommonJS模块或混合类型的模块时，将tsconfig.json中的“module”选项设置为“es2020”并将“esModuleInterop”设置为“True”。然后，我们可以使用“默认导入”语法或动态导入来导入CommonJS模块，并使用“默认导入”、“名称空间导入”或动态导入来导入es模块。同样，仅在必要时使用动态导入。</p><p id="388e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码如下所示:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/ecc303dd781c2bc12a86818f89773b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmAADzx_XTSOEHGnR5S0cg.png"/></div></div></figure><h2 id="4855" class="nh lc in bd ld ni nj dn lh nk nl dp ll kg nm nn lp kk no np lt ko nq nr lx ns bi translated">当CommonJS模块导入ES模块时</h2><p id="a20f" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">现在是最棘手的部分。当我们的“package.json”中的“type”为“commonjs”或不存在，并且我们正在导入一个ES模块或混合类型的模块时，将tsconfig.json中的“Module”选项设置为“es2020”(！！)和“esModuleInterop”转换为“True”。然后，使用动态导入来导入ES模块，并使用旧的“require()”语法或动态导入来导入CommonJS模块。代码如下所示:</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fbbce07a227e60bbab16c832d3192e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*wNtKyaRxglJ9qgvjLe2BGw.png"/></div></figure><p id="128a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将tsc的“模块”选项设置为“es2020”很奇怪，因为我们正在处理一个CommonJS模块。原因是，Node.js在使用CommonJS模块系统时，导入ES模块的唯一方法就是使用动态导入。</p><p id="7148" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，在撰写本文时，当“模块”选项设置为“commonjs”时，tsc transpiles动态导入为“require()”(详见本<a class="ae me" href="https://github.com/microsoft/TypeScript/issues/43329" rel="noopener ugc nofollow" target="_blank">未决问题</a>)。因此，我们别无选择，只能使用“es2020”，即使我们正在构建一个CommonJS包。然后我们可以使用动态导入来导入CommonJS和ES模块。并且我们还可以使用旧的require()语法(不会被transpiled)来导入CommonJS模块。除此之外，导入会在编译时或运行时失败。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="29ff" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1f47" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">从CommonJS模块导入一个CommonJS模块或者从ES模块导入一个ES模块并不难。然而，当我们把它们混在一起时就变得棘手了。本文就如何在这种情况下设置您的项目以使其工作提供了简单的指导。</p><p id="d671" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容尽在</em><a class="ae me" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>