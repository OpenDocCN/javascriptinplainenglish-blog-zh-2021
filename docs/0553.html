<html>
<head>
<title>JavaScript Basics: call, bind, and apply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:调用、绑定和应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-basics-call-bind-and-apply-f1e425026f88?source=collection_archive---------12-----------------------#2021-02-02">https://javascript.plainenglish.io/javascript-basics-call-bind-and-apply-f1e425026f88?source=collection_archive---------12-----------------------#2021-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">控制“这个”变量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/18d2950415592062e240cdd6897f79f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ-Mdns5WCxiDTfJrwrCtw.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="db46" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本帖中，我们将讨论以下方法:<code class="fe lu lv lw lx b">call, bind, and apply</code>。但是在我们开始之前，让我们先来看看受益于这些方法的变量，<code class="fe lu lv lw lx b">this</code>。</p><h1 id="075c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">“这个”变量</h1><p id="c288" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">在JavaScript中，当一个函数被调用时，就会创建一个<code class="fe lu lv lw lx b">execution context</code>。结果，我们有了我们的<code class="fe lu lv lw lx b">variable environment</code>(函数内定义的变量)<code class="fe lu lv lw lx b">outer environment reference</code>(函数/变量或者任何可以在函数外引用的东西)，还有一个为我们设置的变量<code class="fe lu lv lw lx b">this</code>。</p><p id="7e60" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">关于<code class="fe lu lv lw lx b">execution context</code>的更多信息，我会在这篇<a class="ae mv" href="https://medium.com/javascript-in-plain-english/javascript-basics-execution-context-bd79ede1ccdd" rel="noopener">博客</a>中详细讨论。</p><p id="896d" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在某些情况下,<code class="fe lu lv lw lx b">this</code>变量可以指向<code class="fe lu lv lw lx b">global</code>对象，而在其他情况下，它可以指向包含作为属性的函数的对象。准确地确定<code class="fe lu lv lw lx b">this</code>变量最终会是什么可能很棘手。<code class="fe lu lv lw lx b">call, bind, and apply</code>方法在这个问题上派上了用场。</p><h1 id="5451" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">调用、绑定和应用</h1><p id="268c" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">函数是一种特殊的对象，它有一个隐藏的可选属性<code class="fe lu lv lw lx b">name</code>,如果不包含它，它可以是匿名的。如果没有提供名称，它可以是一个<code class="fe lu lv lw lx b">anonymous</code>函数(例如<code class="fe lu lv lw lx b">function(){console.log("anonymous")</code>)。一个函数也有一个包含代码行的<code class="fe lu lv lw lx b">code</code>属性，它是可调用的，所以我们可以运行代码。</p><p id="3983" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript中的所有函数都可以访问特殊的函数/方法。函数只是一个可以有属性和方法的对象，比如<code class="fe lu lv lw lx b">call, bind, and apply</code>方法。这三个都与<code class="fe lu lv lw lx b">this</code>变量有关。</p><h2 id="59f3" class="mw lz iq bd ma mx my dn me mz na dp mi lh nb nc mk ll nd ne mm lp nf ng mo nh bi translated">约束</h2><p id="46e1" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">让我们从<code class="fe lu lv lw lx b">bind</code>方法开始。假设我们有下面的例子:</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="d1d0" class="mw lz iq lx b gy nm nn l no np">const person = {<br/>   firstname: "Rei",<br/>   lastname: "Rey",<br/>   getFullName: function(){<br/>      let fullname = this.firstname + ' ' + this.lastname;<br/>      return fullname<br/>   }<br/>}</span><span id="6d26" class="mw lz iq lx b gy nq nn l no np">const logname = function(){<br/>   console.log('Name: ' + this.getFullName())<br/>}</span><span id="084d" class="mw lz iq lx b gy nq nn l no np">let logPersonName = logname.bind(person); <br/>logPersonname(); // Name: Rei Rey </span></pre><p id="e31c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们有一个具有特定属性和方法的<code class="fe lu lv lw lx b">person</code>对象。我们有函数表达式，<code class="fe lu lv lw lx b">logname</code>依赖于<code class="fe lu lv lw lx b">this</code>变量。但是这两个变量是相互关联的，当引用<code class="fe lu lv lw lx b">this</code>时，我们想要的是<code class="fe lu lv lw lx b">person</code>对象。如果我们立即调用<code class="fe lu lv lw lx b">logname</code>，它实际上会抛出一个类型错误。为什么？</p><p id="4457" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">函数<code class="fe lu lv lw lx b">logname</code>将从<code class="fe lu lv lw lx b">global execution context</code>中调用。<code class="fe lu lv lw lx b">this</code>变量将引用<code class="fe lu lv lw lx b">global</code>对象。默认情况下，<code class="fe lu lv lw lx b">global</code>对象没有附加一个名为<code class="fe lu lv lw lx b">getFullName</code>的方法。所以引用<code class="fe lu lv lw lx b">this.getFullName</code>会返回<code class="fe lu lv lw lx b">undefined</code>，调用它会抛出一个错误。</p><p id="0bea" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了解决这个难题，我们在调用函数之前执行了一个额外的操作。重新聚焦，我们的功能是<code class="fe lu lv lw lx b">logname</code>。快速提醒一个函数是一个特殊的对象，它有包括<code class="fe lu lv lw lx b">bind</code>在内的方法。我们用这个方法来控制这个函数中的<code class="fe lu lv lw lx b">this</code>变量指向哪里。</p><p id="26bd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">bind()</code>函数中，我们传递我们想要引用的对象。在这种情况下，我们传入<code class="fe lu lv lw lx b">person</code>对象。幕后发生的事情是，<code class="fe lu lv lw lx b">bind()</code>函数返回一个新函数，制作了<code class="fe lu lv lw lx b">logname</code>函数的新副本，并设置了这个新的函数对象，其中<code class="fe lu lv lw lx b">this</code>变量现在引用传入的参数(<code class="fe lu lv lw lx b">person</code>)。我们将这个新函数存储到一个变量<code class="fe lu lv lw lx b">logPersonName</code>中。当我们调用这个函数时，我们现在得到了我们期望的结果。</p><p id="20df" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">概括地说，在一个函数上调用<code class="fe lu lv lw lx b">bind()</code>会创建同一个函数的副本。</p><h2 id="e26c" class="mw lz iq bd ma mx my dn me mz na dp mi lh nb nc mk ll nd ne mm lp nf ng mo nh bi translated">打电话申请</h2><p id="7258" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">因为<code class="fe lu lv lw lx b">call</code>和<code class="fe lu lv lw lx b">apply</code>相似，所以我们将同时讨论它们。让我们从<code class="fe lu lv lw lx b">call</code>开始。让我们参考之前的相同示例，其中对<code class="fe lu lv lw lx b">logname</code>做了一些更改:</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="0c4a" class="mw lz iq lx b gy nm nn l no np">const person = {<br/>   firstname: "Rei",<br/>   lastname: "Rey",<br/>   getFullName: function(){<br/>      let fullname = this.firstname + ' ' + this.lastname;<br/>      return fullname<br/>   }<br/>}</span><span id="14e5" class="mw lz iq lx b gy nq nn l no np">const logname = function(greeting){<br/>   console.log(greeting + " " + this.getFullName())<br/>}</span><span id="2510" class="mw lz iq lx b gy nq nn l no np">logname.call(person,"Hello") // Hello Rei Rey<br/>logname.apply(person, ["Hello"]) // Hello Rei Rey</span></pre><p id="e01c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们调整了函数表达式<code class="fe lu lv lw lx b">logname</code>，以期待一个参数<code class="fe lu lv lw lx b">greeting</code>。类似于<code class="fe lu lv lw lx b">bind</code>,<code class="fe lu lv lw lx b">call</code>方法将允许我们控制<code class="fe lu lv lw lx b">this</code>变量在函数上下文中的位置。我们传入<code class="fe lu lv lw lx b">person</code>对象来设置引用，我们也可以用它传递参数，问候语<code class="fe lu lv lw lx b">"Hello”</code>。</p><p id="7c49" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">与创建函数副本的<code class="fe lu lv lw lx b">bind</code>不同，<code class="fe lu lv lw lx b">call</code>实际上执行函数，并决定<code class="fe lu lv lw lx b">this</code>变量应该是什么，其余的将作为通常传递给函数的参数。</p><p id="b6ce" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将介绍函数的最后一个方法是<code class="fe lu lv lw lx b">apply</code>方法。它与<code class="fe lu lv lw lx b">call</code>完全相同，但是我们只传入两个参数:指向<code class="fe lu lv lw lx b">this</code>变量的<code class="fe lu lv lw lx b">object</code>和包含我们希望传递的参数的数组。</p><p id="0e1e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<code class="fe lu lv lw lx b">bind</code>方法，我们也可以传递单个参数。由于<code class="fe lu lv lw lx b">bind</code>返回函数的副本，我们可以在传入参数后立即调用它。</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="2583" class="mw lz iq lx b gy nm nn l no np">logname.bind(person)("Hello")</span></pre><p id="739e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一个更干净的方法将涉及我们之前已经有的:</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="c732" class="mw lz iq lx b gy nm nn l no np">let logPersonName = logname.bind(person); <br/>logPersonname("Hello");</span></pre><p id="ce52" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">概括地说，<code class="fe lu lv lw lx b">call</code>和<code class="fe lu lv lw lx b">apply</code>是相似的，因为它们不创建函数的副本。相反，它们调用函数并控制<code class="fe lu lv lw lx b">this</code>指向哪里。</p><h1 id="a150" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">履行</h1><p id="6e38" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">让我们来看两个实际实现这些方法的例子。</p><h2 id="27b9" class="mw lz iq bd ma mx my dn me mz na dp mi lh nb nc mk ll nd ne mm lp nf ng mo nh bi translated">功能借用</h2><p id="8462" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">假设我们想创建另一个类似于<code class="fe lu lv lw lx b">person</code>的对象，它有自己的<code class="fe lu lv lw lx b">firstname</code>和<code class="fe lu lv lw lx b">lastname</code>属性。然而，我们不一定想要包含<code class="fe lu lv lw lx b">getFullName</code>属性。我们想借用和重用这个方法，因为它依赖于<code class="fe lu lv lw lx b">this</code>。我们可以应用(没有双关语的意思)我们所讨论的来解决这个难题。</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="0c35" class="mw lz iq lx b gy nm nn l no np">const person = {<br/>   firstname: "Rei",<br/>   lastname: "Rey",<br/>   getFullName: function(){<br/>      let fullname = this.firstname + ' ' + this.lastname;<br/>      return fullname<br/>   }<br/>}</span><span id="3f08" class="mw lz iq lx b gy nq nn l no np">const person2 = {<br/>   firstname: “Other”,<br/>   lastname: “Name”<br/>}</span></pre><p id="015a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们想调用<code class="fe lu lv lw lx b">person</code>对象上的方法，但是将<code class="fe lu lv lw lx b">this</code>变量设置为<code class="fe lu lv lw lx b">person2</code>对象。</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="7a90" class="mw lz iq lx b gy nm nn l no np">console.log(person.getFullName.apply(person2)) // Other Name </span></pre><h2 id="dfb9" class="mw lz iq bd ma mx my dn me mz na dp mi lh nb nc mk ll nd ne mm lp nf ng mo nh bi translated">函数Currying</h2><p id="6884" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">这特别涉及到<code class="fe lu lv lw lx b">bind</code>方法。有了<code class="fe lu lv lw lx b">call</code>和<code class="fe lu lv lw lx b">apply</code>，我们可以像平常一样简单地传递参数。通过<code class="fe lu lv lw lx b">bind</code>，我们正在创建该函数的新副本。如果我们决定向它传递参数会发生什么？</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="ba09" class="mw lz iq lx b gy nm nn l no np">function multiply(a,b){<br/>   return a*b<br/>}</span><span id="fe10" class="mw lz iq lx b gy nq nn l no np">const multipleByTwo = multiply.bind(this,2)</span></pre><p id="e97a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">提醒一下，<code class="fe lu lv lw lx b">bind</code>不是打电话。那么它在这种情况下做什么呢？当进行复制时，给它参数设置这些参数的永久值。通过传递值<code class="fe lu lv lw lx b">2</code>，我们说在这个函数副本中，第一个参数将始终是一个<code class="fe lu lv lw lx b">2</code></p><p id="1c46" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">函数<code class="fe lu lv lw lx b">multiply</code>中的变量<code class="fe lu lv lw lx b">a</code>将始终为<code class="fe lu lv lw lx b">2</code>。这相当于使用这个函数，然后设置<code class="fe lu lv lw lx b">this </code>关键字。</p><pre class="kg kh ki kj gt ni lx nj nk aw nl bi"><span id="ec77" class="mw lz iq lx b gy nm nn l no np">// equivalent<br/>function multipleByTwo(b){<br/>   const a = 2; <br/>   return a*b<br/>}</span><span id="a5d1" class="mw lz iq lx b gy nq nn l no np">//the first parameter is permanently set to 2. Thus this will be the //second parameter.</span><span id="4aba" class="mw lz iq lx b gy nq nn l no np">console.log(multipleByTwo(4)) // 8</span></pre><p id="32ce" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">关于<code class="fe lu lv lw lx b">function currying</code>技术的更多细节，请参考这篇<a class="ae mv" href="https://javascript.info/currying-partials" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="bd64" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="5b20" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">我们已经讨论了JavaScript中<code class="fe lu lv lw lx b">this</code>变量的基础知识，以及如何使用<code class="fe lu lv lw lx b">bind</code>、<code class="fe lu lv lw lx b">call</code>和<code class="fe lu lv lw lx b">apply</code>方法控制它指向哪里。理解这些概念有助于课堂上的高级主题和反应。</p></div></div>    
</body>
</html>