# Node.js 初学者和专家的最佳实践

> 原文：<https://javascript.plainenglish.io/node-js-best-practices-for-beginners-and-experts-alike-49a1f67318ce?source=collection_archive---------0----------------------->

![](img/2442e8f4a0b31090a47f82a7ce20179b.png)

Node JS Best Practices

Node.js 是最流行的 web 开发框架之一。

任何人都可以通过学习 Node.js 爱上 JavaScript，因为它完全基于 JavaScript。

通过在浏览器之外编写 javascript 代码，可以创建轻量级、无阻塞、可伸缩、快速且健壮的服务器端 web 应用程序。

今天，我们将讨论一些有用的 [**Node.js 最佳实践**](https://www.tatvasoft.com/blog/node-js-best-practices/) ，它们将帮助各类开发人员——初学者和专家——创建一个高效且最可持续的应用程序。

所以请继续阅读！

## **每次更改代码时借助工具重启应用**

在开发阶段，编码人员停止并重新启动应用程序来实现对代码的更改。这可能是一个麻烦，会让你在主要任务上失去注意力。

您可以使用工具作为这个问题的解决方案，这样您就不必为了反映更改而一遍又一遍地重新启动应用程序。

以下是 Node.js 最流行的代码监控包:

*   *Forever:* 它提供了自动重启功能以及额外的配置，如写日志和设置工作目录，这些将打印到一个特定的文件中。
*   Nodemon: 它还提供了一个自动重启选项，只要代码有新的变化。要初始化 nodemon，请在命令 lone 中将 node 替换为 nodemon。
*   PM2:另一个过程管理工具，与上面两个相比，它有极好的控制和特性。

永久和 PM2 罐甚至适用于生产环境。它确保代码在运行时错误后被恢复。它还可以确保应用程序在服务器停机的情况下快速重启。

## **用异步/等待替换回调**

最初，[回调](https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/)用于维护节点的异步特性，但它会导致回调在连续嵌套后失控。这是代码变得不可读的地方。

随着 async/await 的引入，开发人员已经看到这个问题有所减少。然而，为了避免回调，必须确保使用 async/await。

通过用 async 和 await 替换回调，可以很容易地防止回调。

## **采用小写**

在某些编程语言中，文件名必须与类名匹配

避免在 node.js 中这样做，坚持小写。

Node.js 是一个以 Linux 为中心的工具，支持跨平台。然而，Windows 和 OSX 会以相同的方式对待大写(' MyClass.js ')和小写(' myclass.js)，但 Linux 不会。要为跨平台编写代码，您应该满足确切的需求陈述，还要考虑大小写。

最好的方法是坚持只用小写字母。

## **应用集群**

节点运行时仅限于单个 CPU 内核，在大型服务器上部署非集群节点应用程序可能会浪费资源。

要充分利用多核和超过 1.5GB 的扩展内存，请在您的应用中添加集群支持。在集群的帮助下，即使在小型硬件上运行单个进程，您也可以获得灵活性。

通过全面的测试，您可以确定一个应用程序的集群进程的精确数量。然而，首先使用默认值总是一个好主意。

通过选择集群抽象，您可以避免反复重新发现流程管理轮。

## **避开垃圾**

节点有一个默认限制为 1.5 GB 的惰性垃圾收集器。这个垃圾收集器将等待，直到它实际上有未使用的内存需要回收。

如果内存不足，不是因为泄漏，而是垃圾收集器的懒惰行为。

但是，可以通过向 V8 提供标志来完全控制垃圾收集器。

```
web: node — optimize_for_size — max_old_space_size=920 — gc_interval=100 server.js
```

做到这一点至关重要，尤其是当您在一个少于 1.5Gb 内存的环境中运行一个节点时。

例如:

```
web: node — optimize_for_size — max_old_space_size=460 — gc_interval=100 server.js
```

上述代码可用于将节点定制为 512 MB 的容器。

## **干净的代码&易读性**

毫无疑问，整洁有助于提高代码的质量。

几乎每个代码都包含 linter 和 formatter。

Linter 搜索并警告语法和语义上的错误代码，而格式化程序的工作就像更多的样式因素一样，以确保一组格式和样式在整个项目中保持一致。

最著名的 linters 是 ESLint、JSLint 和 JSHint。

大部分 IDEs 代码编辑器如 Atom、VSCode (Visual Studio Code)等。重视质量代码，提供直观且易于设置的林挺和格式插件。

不仅如此，这些 ide 还提供了额外的特性，比如重构、智能代码完成、悬停文档支持、自动导入、调试工具、代码导航等等。

因此，强烈建议您获得这些 ide 中的一个，并设置一个流畅的编码工作流。

## **依赖注入软件**

这种软件设计提倡将依赖项或服务作为参数注入或传递给模块，而不是创建或要求它们。

这个奇特的术语使你的模块在应用中保持独立、灵活、可伸缩和可测试。

假设你有一个模块，它公开了两个函数来处理一个随机的表情类。它还使用黄色表情模块来处理黄色表情数据库。

*这里的问题是设置只服务于一组特定的表情符号——黄色。因此，如果你想使用不同的表情符号集或多个表情符号集，你可以创建单独的功能，或者修复现有的功能。*

这就是为什么创建以多种方式工作的函数是至关重要的。

通过依赖注入，您可以使您的函数更加通用和灵活。

让我们用一个例子来理解这一点

*假设你创建了一个新函数——表情服务——它将依赖关系——表情颜色——作为参数，而不是固定为一种颜色类型(黄色)。*

这就是依赖注入的工作方式。

由于这一点，该服务将有一个更通用的接口，易于使用和测试。

现在，我们可以直接向测试用例传递表情颜色依赖，而不是创建黄色表情。

为了更加完美，请遵循给定的实践:

*   不要重复你自己
*   [**单一责任原则**](https://stackify.com/solid-design-principles/)
*   保持简单
*   关注点划分
*   避免早期优化
*   依赖注入

## **使用安全、分层和环境感知配置**

无故障配置设置的标志包括:秘密放在提交的代码之外，配置遵循分层模式以便于搜索，密钥可以从环境变量和文件中读取。

rc、nconf、config、discrete 等包遵循上述。

如果您不能满足配置需求，它将会使开发人员或开发团队陷入困境，或者两者都陷入困境。

## **一些特定的插件**

有一些插件覆盖了普通的 JavaScript，比如 eslint-plugin-mocha、eslint-plugin-node 和 eslint-plugin-node-security。

然而，各种错误的节点代码模式可能会被忽略；例如，开发人员可能需要将变量作为路径的“variableAsPath”文件，这为攻击者执行任何 JavaScript 打开了大门。Linters 可以检测到这些模式，并提醒开发人员采取必要的措施。

## **使用头盔进行网络应用**

构建 Web 应用程序非常有趣。为了使您的编码更简单，首先保护您的应用程序。

使用:

*   XSS 保护
*   设置上下文安全策略头
*   确保所有连接都是 HTTPS
*   使用 X-Frame-Options 避免点击劫持
*   禁用 X-Powered-By 标头，使攻击者无法将其攻击渗透到特定的软件

如果你觉得做上面的练习有点令人生畏，简单地使用头盔，将它们都设置为合理的默认，你将能够调整所需的。

为 JavaScript 应用程序设置头盔非常简单。

你只需要使用-

```
“$ npm install helmet”
```

在你的代码中，然后添加-

```
var helmet = require(‘helmet’);app.use(helmet());
```

瞧啊。你可以走了！

## **结束**

除非你遇到某些错误，否则任何编码都不会很难；除非你找到最佳实践，否则任何语言都不会很容易。所以在你的项目中使用提到的 **Node.js 后端最佳实践**，让编码变得有趣。

使用 Node.js 构建健壮、可伸缩且灵活的应用程序或软件

*更多内容尽在*[***plain English . io***](http://plainenglish.io/)