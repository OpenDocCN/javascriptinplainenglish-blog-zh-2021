<html>
<head>
<title>Why node_modules are the Heaviest Objects in the Universe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么node_modules是宇宙中最重的对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-esm-npm-yarn-deep-dive-adda15dabce?source=collection_archive---------1-----------------------#2021-11-29">https://javascript.plainenglish.io/node-js-esm-npm-yarn-deep-dive-adda15dabce?source=collection_archive---------1-----------------------#2021-11-29</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="653e" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页开发</a></h2><div class=""/><div class=""><h2 id="cb91" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">Node.js模块系统、其解析算法及其随时间演变的演练</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/04143b7a65896799f005ef671a40fc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9s00J9jmkdl8QG18F_iIw.png"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Photo by <a class="ae lf" href="https://unsplash.com/@gferla?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guillermo Ferla</a> on <a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (edited by author, <a class="ae lf" href="https://www.reddit.com/r/ProgrammerHumor/comments/6s0wov/heaviest_objects_in_the_universe/" rel="noopener ugc nofollow" target="_blank">node_modules image from Reddit</a>)</figcaption></figure><p id="0e71" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">如果你熟悉新闻，你可能听说过TypeScript 4.5已经将对Node.js的ECMAScript (ESM)支持推迟到未来的版本，因为担心生态系统的就绪性。</p><p id="c9d0" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">但是这个特性在<a class="ae lf" href="https://levelup.gitconnected.com/features-in-the-new-typescript-release-e5ef6ebba750" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>中的存在或不存在实际上意味着什么呢？</p><p id="7052" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我对找出这个问题的答案的好奇心让我在浏览器上打开了一堆文章并阅读了它们。其中一个帖子引起了我的注意，上面有一张宇宙中最重物体的有趣图片。它显示出比太阳、中子星甚至黑洞还要重。</p><p id="2469" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">虽然这不是一个严肃的比较，但我知道这并不是完全错误的。</p><p id="0a02" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><code class="fe mc md me mf b">npm</code>库实际上是世界上最大的<a class="ae lf" href="http://www.modulecounts.com/" rel="noopener ugc nofollow" target="_blank">包库</a> <strong class="li jb"> </strong>，它的CLI的核心依赖<code class="fe mc md me mf b"><a class="ae lf" href="https://levelup.gitconnected.com/7-nodejs-vulnerabilities-149094e441c2#2f72" rel="noopener ugc nofollow" target="_blank">@npmcli/arborist</a></code>正在执行一个复杂的算法，以便管理<code class="fe mc md me mf b">node_modules</code>树，解决包之间的循环和重叠连接。</p><p id="efd1" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">但这是讽刺图片的唯一原因吗？</p><div class="kq kr ks kt gu ab cb"><figure class="mg ku mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><img src="../Images/161e46b8e448a9c41c12ca5a42b2f639.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/0*baV0ZwxZYK_tlLJh.png"/></div></figure><figure class="mg ku mm mi mj mk ml paragraph-image"><img src="../Images/c02e6c64104dea036d1bebacaa00beb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*3EITxYdbG-ONJEkF.png"/><figcaption class="lb lc gk gi gj ld le bd b be z dk mn di mo mp">left: <a class="ae lf" href="https://github.com/npm/arborist" rel="noopener ugc nofollow" target="_blank">@npmcli/arborist </a>— right: npm is the biggest package repository in the world (<a class="ae lf" href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71" rel="noopener">source</a>)</figcaption></figure></div><p id="b714" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我的Node.js之旅始于2014年——它诞生五年后，它的包管理器<code class="fe mc md me mf b">npm</code>发布四年后。当时，我对AMD和RequireJS之类的JavaScript模块系统有所了解，但结束时我提出的问题比开始时多得多:</p><ul class=""><li id="6cd4" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated">Node.js中使用了哪些不同的JavaScript模块系统？它们和我们在客户端使用的是一样的吗？</li><li id="815f" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">ESM支持为何如此重要？</li><li id="0f9d" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated"><code class="fe mc md me mf b">node_modules</code>有哪些不同的复杂性和问题让人们把它描述为宇宙中最重的物体？</li><li id="3787" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">社区<a class="ae lf" href="https://betterprogramming.pub/problem-solving-techniques-b1ed8b4c729f" rel="noopener ugc nofollow" target="_blank">如何解决</a>与<code class="fe mc md me mf b">node_modules</code>的问题？</li><li id="6192" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">这和<code class="fe mc md me mf b">yarn</code>等新的包管理器的出现有什么关系？</li></ul><p id="9204" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">如果这些问题引发了您的好奇心，并且您希望扩展您对Node.js生态系统及其与客户端的关系的了解，您将在下面找到答案和一些更令人兴奋的事实。</p><pre class="kq kr ks kt gu ne mf nf ng aw nh bi"><span id="d343" class="ni nj ir mf b gz nk nl l nm nn"><strong class="mf jb">Table of Contents</strong></span><span id="3d60" class="ni nj ir mf b gz no nl l nm nn"><a class="ae lf" href="#707f" rel="noopener ugc nofollow">Module Systems in Node.js</a><br/>   ∘ <a class="ae lf" href="#b7c4" rel="noopener ugc nofollow">CommonJS</a><br/>   ∘ <a class="ae lf" href="#99c0" rel="noopener ugc nofollow">ES Modules (Michael Jackson Scripts)</a><br/><a class="ae lf" href="#8c7e" rel="noopener ugc nofollow">Why is ES module support so important?</a><br/><a class="ae lf" href="#0b7c" rel="noopener ugc nofollow">The Challenges of Using CJS and ESM Together</a><br/>   ∘ <a class="ae lf" href="#2614" rel="noopener ugc nofollow">Introduction of new rules</a><br/>   ∘ <a class="ae lf" href="#e9ba" rel="noopener ugc nofollow">Dual-mode Support: dual ESM/CJS packages</a><br/><a class="ae lf" href="#8fb3" rel="noopener ugc nofollow">How Does Node.js Load Modules?</a><br/><a class="ae lf" href="#df98" rel="noopener ugc nofollow">Plug’n’Play: Goodbye node_modules!</a><br/><a class="ae lf" href="#f56c" rel="noopener ugc nofollow">Final Thought</a></span></pre></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><h1 id="707f" class="nw nj ir bd nx ny nz oa ob oc od oe of kg og kh oh kj oi kk oj km ok kn ol om bi translated">Node.js中的模块系统</h1><p id="978e" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">JavaScript领域已经出现了不同类型的模块化，如RequireJS和AMD。但是Node.js是建立在CommonJS (CJS)模块系统上的。</p><p id="3297" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这些模块为开发人员提供了一种更好地组织和构建他们的代码库的方式，并使他们的应用程序更易于管理。</p><h2 id="b7c4" class="ni nj ir bd nx os ot dn ob ou ov dp of lp ow ox oh lt oy oz oj lx pa pb ol ix bi translated">1.CommonJS</h2><p id="ecc1" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">CommonJS为服务器端JavaScript建立了一个模块生态系统。但是，由于浏览器不支持CJS，开发者在babel等transpilers的帮助下也在客户端使用了它。</p><p id="ca3d" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">在CommonJS中，可以使用<code class="fe mc md me mf b">module.exports</code>在普通的<code class="fe mc md me mf b">js</code>文件中定义一个模块，并使用<code class="fe mc md me mf b">require()</code>函数将其导入到另一个<code class="fe mc md me mf b">js</code>文件中:</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="pc pd l"/></div></figure><p id="a5b3" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">你可以用<code class="fe mc md me mf b">node index.js</code>运行这个例子。</p><h2 id="99c0" class="ni nj ir bd nx os ot dn ob ou ov dp of lp ow ox oh lt oy oz oj lx pa pb ol ix bi translated">2.ES模块(迈克尔·杰克逊脚本)</h2><p id="9e35" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">ECMAScript或(ES)是一种JavaScript标准，旨在确保不同web浏览器之间的web应用程序的互操作性，它也用于服务器端应用程序(Node.js)。</p><ul class=""><li id="5f1d" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated"><strong class="li jb">2015年6月</strong>，JavaScript生态系统迎来了<a class="ae lf" href="https://www.ecma-international.org/ecma-262/6.0/index.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript 6 (ES2015)规范</a>中ES模块(ESM)的定义。</li><li id="607e" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated"><strong class="li jb">2015年6月至2017年9月</strong>，各大浏览器打着开发者的旗号开始了对ESM的实验性支持。</li></ul><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj pe"><img src="../Images/34a746b785f4f719e04b3624f8bc0760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*_pjIuJnZuYCI8COe.gif"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">ECMAScript the standard for JavaScript (<a class="ae lf" href="https://medium.com/@shreyapd06/javascript-ecmascript-a18d3e688526" rel="noopener">source</a>)</figcaption></figure><p id="3381" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">与使用<code class="fe mc md me mf b">require()</code>和<code class="fe mc md me mf b">module.exports</code>的CommonJS不同，在es模块中，您可以使用<code class="fe mc md me mf b">import</code>和<code class="fe mc md me mf b">export</code>语句来实现类似的功能。</p><p id="bc12" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">要定义一个<a class="ae lf" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank"> ES模块</a>，你需要在一个扩展名为<code class="fe mc md me mf b">mjs</code>或<em class="pf">迈克尔杰克逊脚本</em>的文件中编写你的代码。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/f2b0ead534d730c070df422e0309d86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/0*Wx33j0m_2goSree6"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">mjs, or Michael Jackson Scripts (<a class="ae lf" href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71" rel="noopener">source</a>)</figcaption></figure><p id="9ed0" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这里有一个例子，<code class="fe mc md me mf b">es-module.mjs</code>:</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="pc pd l"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Defining an ES module — es-module.mjs</figcaption></figure><p id="9e07" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">要使用该模块，您需要从另一个<code class="fe mc md me mf b">mjs</code>文件导入<code class="fe mc md me mf b">mjs</code>文件:</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="pc pd l"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">import an ES module in index.mjs</figcaption></figure><h1 id="8c7e" class="nw nj ir bd nx ny ph oa ob oc pi oe of kg pj kh oh kj pk kk oj km pl kn ol om bi translated">为什么ES模块支持如此重要？</h1><p id="a966" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">JS模块可以用在客户端(浏览器)，也可以用在服务器端(<a class="ae lf" href="https://blog.logrocket.com/web-analytics-with-node-js/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>)。有时，为了兼容性，你必须把代码从一种模块格式转换成另一种模块格式。</p><p id="7d80" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">所有这些造成了混乱而复杂的JavaScript模块状态，可以通过支持Node.js中的es模块来改善这种状态，从而允许为客户端和服务器编写模块化的可重用JavaScript。</p><p id="b616" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我们称这种<strong class="li jb"> <em class="pf">同构</em> </strong> <em class="pf">或</em> <strong class="li jb"> <em class="pf">通用码</em> </strong>，这是可能的，如果:</p><ol class=""><li id="a5ea" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb pm mw mx my bi translated">你不要在代码中使用浏览器专用的方法和变量，比如<code class="fe mc md me mf b">window</code>和<code class="fe mc md me mf b">document</code>。</li><li id="bf49" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">你不使用像<code class="fe mc md me mf b">server</code>和<code class="fe mc md me mf b">fs</code>这样的只有节点的方法和变量。</li><li id="baa4" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">如果需要这样的场景，您需要向代码中添加条件，或者将它包装在一个函数中，该函数模拟替代环境中的逻辑。</li></ol><p id="0a9f" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><code class="fe mc md me mf b"><em class="pf">console.log</em></code>是一个在Node.js和浏览器中工作的例子。</p><p id="af4e" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">由于对<em class="pf">同构代码</em>和<em class="pf">浏览器兼容性</em>需求的爆炸式增长，Node.js不再是一个独立的生态系统，ESM支持成为必备。</p><h1 id="0b7c" class="nw nj ir bd nx ny ph oa ob oc pi oe of kg pj kh oh kj pk kk oj km pl kn ol om bi translated">将CJS和ESM结合使用的挑战</h1><p id="4b80" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">在能够从CJS迁移到ESM之前，第一步将是允许ES模块与CommonJS在同一个应用程序中共存，这远不是一项简单的任务。</p><p id="b48a" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">JavaScript规范区分了:</p><ul class=""><li id="c564" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated">一个“<strong class="li jb"> <em class="pf">模块</em> </strong>”，定义为“<a class="ae lf" href="https://2ality.com/2011/01/javascripts-strict-mode-summary.html" rel="noopener ugc nofollow" target="_blank">严格</a>”，是一个扩展名为<code class="fe mc md me mf b">mjs</code>的文件(一个ES模块)。</li><li id="bf7d" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">不是ES模块的“<strong class="li jb"> <em class="pf">脚本</em> </strong>”具有<code class="fe mc md me mf b">js</code>扩展名，不允许使用<code class="fe mc md me mf b">import from</code>语句。</li></ul><p id="2a06" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">遵循这个规范已经允许JavaScript引擎知道一个文件是一个<strong class="li jb"> <em class="pf">模块</em> </strong>还是一个<strong class="li jb"> <em class="pf">脚本</em> </strong>并且作为结果决定<strong class="li jb"> <em class="pf">执行</em> </strong>还是<strong class="li jb"> <em class="pf">导入</em> </strong>它。</p><p id="903a" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">也就是说，使用两种不同的扩展不仅是一个美学问题；它在ESM和CJS之间建立了一条护城河，并提出了一个问题:我们如何才能在两个模块系统之间建立互操作性？</p><h2 id="2614" class="ni nj ir bd nx os ot dn ob ou ov dp of lp ow ox oh lt oy oz oj lx pa pb ol ix bi translated">新规则的引入</h2><p id="9428" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">为了填补这个空白，我们已经看到了es模块的"<strong class="li jb"> <em class="pf">规则"</em> " </strong>和"<strong class="li jb"> <em class="pf">互操作性规则</em> " </strong>的引入，它们提供了在同一应用中使用两个模块系统的指南<strong class="li jb"> : </strong></p><ol class=""><li id="85e5" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb pm mw mx my bi translated">只有扩展名为<code class="fe mc md me mf b">mjs</code>的文件才是ESM</li><li id="162d" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">只有扩展名为<code class="fe mc md me mf b">js</code>的文件才是CJS</li><li id="012c" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">ESM可以使用<code class="fe mc md me mf b">export</code> / <code class="fe mc md me mf b">import</code>语句，但不能使用<code class="fe mc md me mf b">require</code></li><li id="9b88" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">CJS可以使用<code class="fe mc md me mf b">require</code>导入CJS</li><li id="c059" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">CJS <em class="pf">只能使用<code class="fe mc md me mf b">await import()</code>才能</em>导入ESM</li><li id="9338" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb pm mw mx my bi translated">ESM <em class="pf">只能使用<em class="pf">默认</em>T7】语句<code class="fe mc md me mf b">import .. from ..</code>才能</em>导入CJS</li></ol><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/8ed8cc7eecb526ad8ec12060f8885b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*fteN2aF9rjZfPaEV.png"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">Bridging the two module systems (<a class="ae lf" href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71" rel="noopener">source</a>)</figcaption></figure><p id="e1fa" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">下面是一个在ES模块中使用CommonJS模块的示例:</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="pc pd l"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">my-esm-module.mjs</figcaption></figure><p id="425f" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">另一个是在CommonJS脚本中使用ES模块。调用<code class="fe mc md me mf b">await import()</code>意味着做这件事的代码应该是一个<code class="fe mc md me mf b">async</code>函数:</p><figure class="kq kr ks kt gu ku"><div class="bz fq l di"><div class="pc pd l"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">my-cjs-module.js</figcaption></figure><h2 id="e9ba" class="ni nj ir bd nx os ot dn ob ou ov dp of lp ow ox oh lt oy oz oj lx pa pb ol ix bi translated">双模支持:双ESM/CJS包</h2><p id="7473" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">允许<code class="fe mc md me mf b">npm</code>封装包含两个模块系统(<em class="pf">双模</em>))对于无缝过渡到没有CommonJS的未来非常重要。</p><p id="7755" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">为了实施双模式并促进从CJS到ESM的迁移，Node.js经历了以下里程碑:</p><ul class=""><li id="dbaa" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated"><strong class="li jb">2017年9月:</strong> <a class="ae lf" href="https://nodejs.org/de/blog/release/v8.5.0/" rel="noopener ugc nofollow" target="_blank"> Node v8.5 </a>自带对ES模块的实验性支持:开发者可以使用<code class="fe mc md me mf b">--experimental-modules</code>标志运行ESM。</li><li id="e9d6" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated"><strong class="li jb">2017年9月—2018年5月:</strong> <a class="ae lf" href="https://caniuse.com/es6-module" rel="noopener ugc nofollow" target="_blank">各大浏览器开始支持</a>无开发者标志的ES模块规范。</li><li id="eb93" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated"><strong class="li jb">2018年10月:</strong> ES模块包含一个包含多个阶段的计划，用于替换实验实施。Node.js应该在不破坏现有CommonJS模块的情况下，尽可能地与浏览器类似地工作。</li><li id="2fc6" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated"><strong class="li jb">2019年10月:</strong> <a class="ae lf" href="https://blog.logrocket.com/es-modules-in-node-js-12-from-experimental-to-release/" rel="noopener ugc nofollow" target="_blank">节点12 </a>进入长期支持:没有<code class="fe mc md me mf b">--experimental-modules</code>标志也可以使用ES模块。</li></ul><h1 id="8fb3" class="nw nj ir bd nx ny ph oa ob oc pi oe of kg pj kh oh kj pk kk oj km pl kn ol om bi translated">Node.js如何加载模块？</h1><p id="0de8" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">Node.js如何加载依赖项的本质是CJS模块系统的核心。</p><p id="ffbd" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">虽然这很复杂，但是resolution <a class="ae lf" href="https://nodejs.org/api/modules.html#modules_all_together" rel="noopener ugc nofollow" target="_blank">算法</a>的本质归结起来就是在<code class="fe mc md me mf b">node_modules</code>目录中搜索包。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj po"><img src="../Images/ba0ca6fefa25c7bfc94ce2d7773b4339.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*VpD500o5kXhhoiOj.png"/></div><figcaption class="lb lc gk gi gj ld le bd b be z dk">node_modules folder (image by author)</figcaption></figure><p id="4541" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">如果我们以语句<code class="fe mc md me mf b">import _ from 'lodash'</code>为例，并且我们过度简化了算法，我们将期望Node.js在<code class="fe mc md me mf b">node_modules</code>中寻找一个<code class="fe mc md me mf b">lodash</code>目录，然后检查它的<code class="fe mc md me mf b">package.json</code>以确定要加载的文件。</p><p id="a16c" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这听起来很简单，但是算法效率非常低:</p><ul class=""><li id="ff7d" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated">它生成了包含大量文件的目录，</li><li id="ce34" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">在内存中多次实例化一些包，</li><li id="5cd7" class="mq mr ir li b lj mz lm na lp nb lt nc lx nd mb mv mw mx my bi translated">并导致磁盘使用率高于需要。</li></ul><p id="42ea" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">为了解决这些弱点并改善整体工作流程，2016年，脸书发布了一个新的包管理器:<code class="fe mc md me mf b">yarn</code>。</p><p id="671b" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">运行<code class="fe mc md me mf b">yarn install</code>可以快速生成<code class="fe mc md me mf b">node_modules</code>，比<code class="fe mc md me mf b">npm</code>所需的时间少<a class="ae lf" href="https://yarnpkg.com/features/pnp" rel="noopener ugc nofollow" target="_blank"> 70%。</a></p><p id="318d" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">但是后来，<code class="fe mc md me mf b">npm</code>团队填补了空白，并实现了他们工具中缺少的特性，比如性能改进和在安装依赖项之前检查安全漏洞。</p><h1 id="df98" class="nw nj ir bd nx ny ph oa ob oc pi oe of kg pj kh oh kj pk kk oj km pl kn ol om bi translated">即插即用:再见节点模块！</h1><p id="165e" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">在他的第二个版本中，<code class="fe mc md me mf b">yarn</code>针对上述问题提出了一个更高效的解决方案:移除<code class="fe mc md me mf b">node_modules</code>！</p><blockquote class="pp pq pr"><p id="d4ef" class="lg lh pf li b lj lk kb ll lm ln ke lo ps lq lr ls pt lu lv lw pu ly lz ma mb ik bi translated">Yarn已经知道了关于你的依赖树的所有信息——它甚至为你把它安装在磁盘上。那么，为什么由Node来查找您的包在哪里呢？<br/>相反，通知<a class="ae lf" href="https://betterprogramming.pub/compiler-vs-interpreter-d0a12ca1c1b6#6341" rel="noopener ugc nofollow" target="_blank">解释器</a>软件包在磁盘上的位置并管理软件包之间甚至软件包版本之间的任何依赖关系应该是软件包管理器的工作。”— <a class="ae lf" href="https://yarnpkg.com/features/pnp#fixing-node_modules" rel="noopener ugc nofollow" target="_blank">纱线团队</a></p></blockquote><p id="5028" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这个被称为<strong class="li jb">即插即用</strong>或<em class="pf"/><strong class="li jb">零安装</strong>的新概念让<code class="fe mc md me mf b">yarn</code>直接从缓存中读取依赖文件，这样我们就不需要再次运行<code class="fe mc md me mf b">yarn install</code>。</p></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><h1 id="f56c" class="nw nj ir bd nx ny nz oa ob oc od oe of kg og kh oh kj oi kk oj km ok kn ol om bi translated">最终想法</h1><p id="6198" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">当Node.js在2009年发布时，它通过开创一个开发者不再需要手动下载和管理项目依赖关系的新时代，将web开发推向了一个新的水平。</p><p id="91c1" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">在其开发周期中，它经历了许多障碍，尽管我在这篇文章中解决了其中的许多问题，但这还不是全部。</p><p id="6d34" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">还有更多缺点，比如<code class="fe mc md me mf b">babel</code>、<code class="fe mc md me mf b">webpack</code>、<code class="fe mc md me mf b">browserify</code>和其他捆绑器如<code class="fe mc md me mf b">parcel</code>、<code class="fe mc md me mf b">rollup</code>对CommonJS使用相同的解析算法，而对ES模块使用相同的解析算法。</p><p id="8192" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">这些工具支持在Node.js和浏览器中使用ESM。然而，他们同步加载ES模块<strong class="li jb"><em class="pf"/></strong>(CJS时尚)，而异步<strong class="li jb"><em class="pf"/></strong>加载是意料之中的。</p><p id="5722" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">但是这个伟大的活跃社区一直在努力使Node.js功能更全、更灵活，并提供像即插即用这样的创造性解决方案，这无疑改善了开发人员的体验。</p></div><div class="ab cl np nq hv nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ik il im in io"><h1 id="c882" class="nw nj ir bd nx ny nz oa ob oc od oe of kg og kh oh kj oi kk oj km ok kn ol om bi translated">想要更多吗？</h1><p id="b5ca" class="pw-post-body-paragraph lg lh ir li b lj on kb ll lm oo ke lo lp op lr ls lt oq lv lw lx or lz ma mb ik bi translated">我为一群聪明、好奇的🧠人写关于工程、技术和领导力的文章💡。<a class="ae lf" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="li jb">加入我的电子邮件简讯</strong> </a> <strong class="li jb">独家访问</strong>或在此报名媒体<a class="ae lf" href="https://rakiabensassi.medium.com/membership" rel="noopener"/>。</p><p id="94b3" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><em class="pf">可以在Udemy上查看我的</em> <strong class="li jb"> <em class="pf">视频课程</em></strong><em class="pf">:</em><a class="ae lf" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="pf">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="pf">。</em></p><div class="pv pw gq gs px py"><a href="https://betterprogramming.pub/javascript-history-and-future-71b0ceb737aa" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fp"><div class="qa ab qb cl cj qc"><h2 class="bd jb gz z fq qd fs ft qe fv fx ja bi translated">JavaScript的25年</h2><div class="qf l"><h3 class="bd b gz z fq qd fs ft qe fv fx dk translated">从简单的脚本语言到每个现代web应用程序的基础</h3></div><div class="qg l"><p class="bd b dl z fq qd fs ft qe fv fx dk translated">better编程. pub</p></div></div><div class="qh l"><div class="qi l qj qk ql qh qm kz py"/></div></div></a></div><div class="pv pw gq gs px py"><a href="https://betterprogramming.pub/angular-13-features-ef528a9ae16f" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fp"><div class="qa ab qb cl cj qc"><h2 class="bd jb gz z fq qd fs ft qe fv fx ja bi translated">Angular 13的新功能</h2><div class="qf l"><h3 class="bd b gz z fq qd fs ft qe fv fx dk translated">100% Ivy，更好的组件API，不支持IE11，等等</h3></div><div class="qg l"><p class="bd b dl z fq qd fs ft qe fv fx dk translated">better编程. pub</p></div></div><div class="qh l"><div class="qn l qj qk ql qh qm kz py"/></div></div></a></div><p id="1f6b" class="pw-post-body-paragraph lg lh ir li b lj lk kb ll lm ln ke lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><em class="pf">更多内容请看</em><a class="ae lf" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="pf">plain English . io</em></a><em class="pf">。报名参加我们的</em> <a class="ae lf" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="pf">免费周报在这里</em> </a> <em class="pf">。</em></p></div></div>    
</body>
</html>