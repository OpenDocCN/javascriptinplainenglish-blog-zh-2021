<html>
<head>
<title>Test Flow while Creating a React Application: Why Testing is So Important</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建React应用程序时的测试流程:为什么测试如此重要</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-flow-creating-react-app-21399ff25c7c?source=collection_archive---------8-----------------------#2021-06-17">https://javascript.plainenglish.io/testing-flow-creating-react-app-21399ff25c7c?source=collection_archive---------8-----------------------#2021-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/203d3dffc8aae3c67e900ebdbed5a225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qjYjgsVq0QbAm-hyf32bWw.gif"/></div></div></figure><div class=""/><div class=""><h2 id="5dc8" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">创建React应用程序时理解测试流程的指南</h2></div><p id="4d37" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">测试是编程中通常被忽视的一个领域，尤其是对初学者而言。</p><p id="bba5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">主要的误解是关于创建网站/应用程序时测试的必要性。开发人员对自己说，<em class="lj">“我可以看到它在工作，那么我为什么要测试呢？”</em></p><p id="8382" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">首先，测试可以帮助我们识别我们看不到的东西，但是更重要的是，测试可以帮助我们将新功能集成到我们的网站中，而不会破坏已经存在的功能(或者至少知道它被及时破坏并立即修复)。</p><p id="3e22" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在本文中，我将向您展示我自己在构建React网页时的测试流程(使用create-react-app设置)。我们将创建一个NavBar组件，并展示我们必须应用于它的各种测试。</p><p id="24a9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请注意——我不会教你如何设置测试环境。同样在这篇文章中，我不会教你如何做测试。我们将会看到一些简单的测试，但是这篇文章主要是关于感受不同种类的测试和工具，以及理解为什么它如此重要。</p><h1 id="428e" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">手动测试、视觉测试、快照测试—故事书</h1><p id="916c" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">让我们从我最喜欢的测试工具——故事书开始。我们将用它执行三种测试——手动测试、快照测试和视觉测试。</p><p id="79a9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">根据故事书的官方网站，故事书是:</p><blockquote class="mh mi mj"><p id="140f" class="kn ko lj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">Storybook是一个开源工具，用于构建独立的UI组件和页面。它简化了UI开发、测试和文档。</p></blockquote><p id="82e7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">简而言之，Storybook让我们构建组件，并在屏幕上实时查看它们，而无需在完整的应用程序设置中运行它们。它也有一些测试工具，让我们记录我们的组件(例如，如果我们正在构建一个组件库)。</p><p id="4449" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们要做的第一个测试是手动测试。正如可能已经猜到的，手动测试就是要看到我们的组件，并验证它看起来像我们期望的那样。如前所述，Storybook是关于查看我们的组件的，所以很明显它最适合这种测试。</p><p id="efe4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们从创建我们的NavLink组件开始:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f9da" class="mw ll iy ms b gy mx my l mz na">import * as React from 'react' ;<br/>import PropTypes from 'prop-types' ;<br/>import { NavLink as ReactRouterNavLink } from 'react-router-dom' ;<br/>import { StyledListItem } from ' ./styles' ;<br/></span><span id="afb2" class="mw ll iy ms b gy nb my l mz na">const NavLink = ({ children, page, styles, activeStyles }) =&gt; {<br/>  const [isHovering, setIsHovering] = React.useState(false);<br/>  return (<br/>    &lt; StyledListItem<br/>      onMouseEnter ={() =&gt; setIsHovering(true)}<br/>      onMouseLeave ={() =&gt; setIsHovering(false)}<br/>      isHovering={isHovering}<br/>    &gt;<br/>      &lt; ReactRouterNavLink style={styles} activeStyles={activeStyles} to={page}&gt;<br/>        {children}<br/>      &lt; /ReactRouterNavLink&gt;<br/>    &lt; /StyledListItem&gt;<br/>  );<br/>};<br/></span><span id="e1c9" class="mw ll iy ms b gy nb my l mz na">NavLink.propTypes = {<br/>  children: PropTypes.string.isRequired,<br/>  page: PropTypes.string,<br/>  styles: PropTypes.object,<br/>  activeStyles: PropTypes.object,<br/>};<br/></span><span id="7c8c" class="mw ll iy ms b gy nb my l mz na">export default NavLink;</span></pre><p id="dab0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是一个非常简单的NavLink组件，它从props对象动态接收所有属性。现在为了展示它的所有风格，我们必须创建一个父组件并传递它的所有属性。还是我们真的必须这么做？</p><h1 id="ae74" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">人工测试</h1><p id="bc69" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">有了故事书，我们就不必这么做了！我们创建一个故事，描述我们想要传递给组件的所有道具。一个组件可以有几个故事来描述它在不同情况下的样子(不同的道具)。对于这个例子，我们将只制作一种故事。故事是这样的:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7d1f" class="mw ll iy ms b gy mx my l mz na">import React from "react" <br/>import NavLink from " ../components/NavLink/NavLink" <br/></span><span id="4c13" class="mw ll iy ms b gy nb my l mz na">export default {<br/>  component: NavLink,<br/>  title: "NavBar/NavLink" ,<br/>}<br/>const defaultStyles = {<br/>  color: "white" ,<br/>  fontFamily: "Spartan" ,<br/>  fontStyle: "normal" ,<br/>  fontWeight: "  bold" ,<br/>  fontSize: "11px" ,<br/>  lineHeight: "25px" ,<br/>  letterSpacing: "1px" ,<br/>  textTransform: "uppercase" ,<br/>  textDecoration: "none" ,<br/>}<br/>const Template = args =&gt; &lt; NavLink {...args} /&gt;<br/></span><span id="83ed" class="mw ll iy ms b gy nb my l mz na">export const Default = Template.bind({})<br/>Default.args = {<br/>  styles: {<br/>    ...defaultStyles,<br/>  },<br/>activeStyle: {<br/>...defaultStyles,<br/>  page: " /Earth" ,<br/>  children: "Earth" ,<br/>}</span></pre><p id="9de8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">就是这样！现在我们可以使用Storybook预览我们的组件。故事书真正的好处是你可以随时改变道具。看下一个短视频:</p><figure class="mn mo mp mq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/ba25a7f58714c8f218e7833cf0c76968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*68ectUK3iEFLXzWRUGytDg.gif"/></div></div></figure><p id="39a9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">关于手工测试的事情是，它都是手工完成的。这非常重要，但是想想一个有数千个组件的组件库。在实现一个新特性后，手动检查每一个特性是很累人的。这就是视觉和快照测试发挥作用的地方。</p><p id="213a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">故事书里的快照测试真的是小菜一碟。你只需要激活插件-storyshots库中的一个功能，故事书就会为你做好一切。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8a8e" class="mw ll iy ms b gy mx my l mz na">import initStoryshots from ' @storybook/addon-storyshots' ;<br/></span><span id="b0e3" class="mw ll iy ms b gy nb my l mz na">initStoryshots();</span></pre><p id="dde0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在幕后，Storybook将使用Jest来执行快照测试。它真正的好处是，我们对每个组件的所有故事都自动进行快照测试，所以我们不必手动编写每个测试。</p><p id="711f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是我们组件的快照测试结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="df67" class="mw ll iy ms b gy mx my l mz na">exports[`Storyshots NavBar/NavLink Default 1` ] = ` <br/>&lt; li<br/>  className="sc-bdnxRM kqHtUy" <br/>  onMouseEnter    ={[Function]}<br/>  onMouseLeave    ={[Function]}<br/>&gt;<br/>  &lt; a<br/>    href =" /Earth" <br/>    onClick    ={[Function]}<br/>    style={<br/>      Object {<br/>        "color" : "white" ,<br/>        "fontFamily" : "Spartan" ,<br/>        "fontSize" : "11px" ,<br/>        "fontStyle" : "normal" ,<br/>        "fontWeight" : "  bold" ,<br/>        "letterSpacing" : "1px" ,<br/>        "lineHeight" : "25px" ,<br/>        "textDecoration" : "none" ,<br/>        "textTransform" : "uppercase" ,<br/>      }<br/>    }<br/>  &gt;<br/>    Earth<br/>  &lt; /a&gt;<br/>&lt; /li&gt;<br/>` ;</span></pre><p id="3d74" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">既然我们已经捕获了DOM元素，那么每次我们运行测试时，都会将它与新的快照进行比较。如果一切都一样，它就会通过，如果不一样，它就会失败并通知我们。失败的测试并不一定意味着我们有一个bug。假设我们想将字体大小改为10px。这是再次运行测试后的结果:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8f8c" class="mw ll iy ms b gy mx my l mz na">- Snapshot  - 1<br/>    + Received  + 1<br/></span><span id="a0ac" class="mw ll iy ms b gy nb my l mz na">    @@ -8,11 +8,11 @@<br/>          onClick    ={[Function]}<br/>          style={<br/>            Object {<br/>              "color" : "white" ,<br/>              "fontFamily" : "Spartan" ,<br/>    -         "fontSize" : "11px" ,<br/>    +         "fontSize" : "10px" ,<br/>              "fontStyle" : "normal" ,<br/>              "fontWeight" : "  bold" ,<br/>              "letterSpacing" : "1px" ,<br/>              "lineHeight" : "25px" ,<br/>              <br/>              "textDecoration" : "none" ,</span></pre><p id="9650" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">注意双重字体大小？它告诉我们有些事情发生了变化，测试失败了。对我们来说，这很好，因为我们知道我们是故意做出这种改变的。</p><h1 id="53d8" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">视觉测试</h1><p id="a538" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">视觉测试不是人工进行的，并且比快照测试更不容易出错，因为它不比较DOM元素，而是比较元素的实际图片。</p><p id="1c38" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">为了进行视觉测试，我们将不得不使用另一个与Storybook集成的工具，称为Chromatic。它的目的是将我们的故事书库部署到一个外部网站，它还帮助我们进行持续的部署。</p><p id="7894" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">每次我们将代码提交到git Chromatic时，都会将组件之前的可视状态与当前状态进行比较。那真是太好了！</p><h1 id="89da" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">单元测试、集成测试— Jest</h1><p id="b92e" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">单元测试是构建React应用程序时最重要的测试之一。你可以像盖大楼一样去想。如果你的收缩材料的核心构件处于良好的状态，那么你的整个建筑在未来可能会做得很好。</p><p id="dd9b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我真的喜欢用故事书里的故事进行单元测试。这样，我可以确保组件在各种情况下都能很好地与所有的道具一起工作。</p><p id="b422" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们来看一个针对NavLink组件的非常简单的单元测试:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9dd3" class="mw ll iy ms b gy mx my l mz na">import React from 'react' ;<br/>import { BrowserRouter as Router } from 'react-router-dom' ;<br/>import { Default } from ' ../stories/NavLink.stories' ;<br/>import { render, screen } from ' @testing-library/react' ;<br/>import ' @testing-library/jest-dom/extend-expect' ;<br/></span><span id="ef08" class="mw ll iy ms b gy nb my l mz na">it('renders the text of the button component' , () =&gt; {<br/>  render(<br/>    &lt; Router&gt;<br/>      &lt; Default {...Default.args} /&gt;<br/>    &lt; /Router&gt;<br/>  );<br/>  expect(screen.getByRole('navigation' )).toHaveTextContent('Earth' );<br/>});</span></pre><p id="a4f1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如您所见，我们从react测试库中导入了我们的“默认”故事和一些辅助函数。然后，我们检查组件是否用正确的文本呈现。</p><h1 id="2988" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">集成测试</h1><p id="c405" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">对于集成测试，我们将再次使用Jest库。集成测试是关于组件如何一起工作的。因此，为了进行这样的测试，我们必须创建一个新的组件— NavBar:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="5079" class="mw ll iy ms b gy mx my l mz na">const activeStyles = { borderTop: 'solid 4px #d83a34'  };<br/></span><span id="96a6" class="mw ll iy ms b gy nb my l mz na">const linksList = [<br/>  'Mercury' ,<br/>  'Venus' ,<br/>  'Earth' ,<br/>  'Mars' ,<br/>  'Saturn' ,<br/>  'Jupiter' ,<br/>  'Neptune' ,<br/>  'Uranus' ,<br/>];<br/></span><span id="e7c1" class="mw ll iy ms b gy nb my l mz na">const NavBar = () =&gt; {<br/>  return (<br/>    &lt; StyledUnorderedList&gt;<br/>      {linksList.map(link =&gt; (<br/>        &lt; NavLink<br/>          children={link}<br/>          key={nanoid()}<br/>          activeStyles={activeStyles}<br/>          styles={defaultStyles}<br/>          page={ ` /${link}` }<br/>        /&gt;<br/>      ))}<br/>    &lt; /StyledUnorderedList&gt;<br/>  );<br/>};</span><span id="bfd4" class="mw ll iy ms b gy nb my l mz na">export default NavBar;</span></pre><p id="9f47" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们想测试当我们点击一个导航链接时，它的activeStyle是否被应用。该测试将模拟点击导航链接，然后检查样式是否是预设的。看起来是这样的:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="15c8" class="mw ll iy ms b gy mx my l mz na">import React from 'react' ;<br/>import { BrowserRouter as Router } from 'react-router-dom' ;<br/>import NavBar from ' ../../components/NavBar/NabBar' ;<br/>import { render, screen, fireEvent } from ' @testing-library/react' ;<br/>import ' @testing-library/jest-dom/extend-expect' ;<br/></span><span id="4159" class="mw ll iy ms b gy nb my l mz na">it('Gives the active style when clicked' , () =&gt; {<br/>  render(<br/>    &lt; Router&gt;<br/>      &lt; NavBar /&gt;<br/>    &lt; /Router&gt;<br/>  );<br/>  const navLink = screen.getByRole(' /Earth' );<br/>  fireEvent.click(navLink);<br/>  expect(navLink).toHaveStyle('border-top: solid 4px #d83a34' );<br/>});</span></pre><p id="3d14" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这实际上是一个简单的测试，对于这个用例来说，它可能是多余的。我们实际上正在测试React-Router-DOM库中NavLink的功能。我们不想测试第三方库的功能，因为测试是他们的工作，不是我们的:)</p><p id="47b3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">无论如何，对于这个例子来说，这就足够了。</p><h1 id="e71b" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">端到端(E2E)测试— Cypress</h1><p id="c9e1" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">现在是有趣的部分了。E2E测试意味着我们将整个应用程序作为一个整体来测试。您通常希望测试用户与DOM中各种元素的交互，以及应用程序与外部API的交互。</p><p id="8ebc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Cypress测试令人愉快的部分是测试实际运行在一个真实的环境中——浏览器。您可以在浏览器中指定希望测试执行的操作，然后坐下来享受。</p><p id="0e31" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们做一个简单的测试，按下其中一个导航链接，检查它是否将我们导航到正确的页面:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a3b7" class="mw ll iy ms b gy mx my l mz na">import React from 'react';<br/>import { mount } from '@cypress/react';<br/>import App from '../App';<br/></span><span id="8174" class="mw ll iy ms b gy nb my l mz na">it('renders learn Earth link and navigates to it', () =&gt; {<br/>  mount(&lt;App /&gt;);<br/>  cy.get('ul li:last').should('be.visible').click();<br/>  cy.location('pathname').should('match', /\/Uranus$/);<br/>  cy.contains('Uranus').should('be.visible');<br/>});</span></pre><p id="7ada" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们看看它在Cypress的图形视图中是什么样子的(仔细看，它发生得真快！):</p><figure class="mn mo mp mq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/7390d32bb3af79385ac6eac0ad59ad7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fuMxeEwGaprYFg_VhmFtQw.gif"/></div></div></figure><h1 id="a9fa" class="lk ll iy bd lm ln lo lp lq lr ls lt lu ke lv kf lw kh lx ki ly kk lz kl ma mb bi translated">摘要</h1><p id="ec33" class="pw-post-body-paragraph kn ko iy kp b kq mc jz ks kt md kc kv kw me ky kz la mf lc ld le mg lg lh li ig bi translated">在本文中，我们看到了6种重要的测试:</p><ul class=""><li id="9ebb" class="nd ne iy kp b kq kr kt ku kw nf la ng le nh li ni nj nk nl bi translated">单元测试——使用Jest测试我们应用程序的核心构件。Jest模拟了浏览器的环境，并让我们检查每个组件是否都按预期工作。</li><li id="e517" class="nd ne iy kp b kq nm kt nn kw no la np le nq li ni nj nk nl bi translated">集成测试——我们正在测试我们的组件如何相互作用，以及它们是否能给我们预期的结果。我们还使用Jest进行集成测试。</li><li id="e384" class="nd ne iy kp b kq nm kt nn kw no la np le nq li ni nj nk nl bi translated">手动测试——对于手动测试，我们使用Storybook来孤立地查看每个组件，并检查它是否像我们期望的那样。</li><li id="c2d3" class="nd ne iy kp b kq nm kt nn kw no la np le nq li ni nj nk nl bi translated">快照测试——story book也用于快照测试。在快照测试中，我们获取DOM节点的快照，每次运行测试时，我们都会将它与当前快照和上一次快照进行比较。</li><li id="650b" class="nd ne iy kp b kq nm kt nn kw no la np le nq li ni nj nk nl bi translated">视觉测试——视觉测试与快照测试非常相似，但更准确。它们检查我们的元素的最后视觉外观是否与当前的相同。我们使用Storybook和Chromatic在每次提交和推送我们的更改到git时进行可视化测试。</li><li id="a3e7" class="nd ne iy kp b kq nm kt nn kw no la np le nq li ni nj nk nl bi translated">E2E测试——端到端测试是关于我们的应用程序作为一个整体是如何工作的。我们使用Cypress，它运行在一个真实的浏览器环境中，让我们做各种各样的任务，并检查它们是否被应用。E2E测试实际上是我们测试流程中最不重要的部分。</li></ul><p id="0a0a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="lj">更多内容看</em><a class="ae nr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="lj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>