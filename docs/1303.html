<html>
<head>
<title>Create a Simple Blog App with Node.js and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js和Express创建一个简单的博客应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-series-part-2-create-a-simple-blog-app-with-express-js-5449604850fa?source=collection_archive---------0-----------------------#2021-03-19">https://javascript.plainenglish.io/node-js-series-part-2-create-a-simple-blog-app-with-express-js-5449604850fa?source=collection_archive---------0-----------------------#2021-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d49e65f44cf698c84904bfcd5ed3ec0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJGgHNR7UqtwLmLhfh8Dmg.jpeg"/></div></div></figure><p id="f143" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的Node.js系列的第1部分中，我们已经学习了如何使用Node.js板载资源构建web服务器。最后，我们安装了Express模块，并将简单路由配置为响应http客户端请求的应用程序端点。在第2部分中，我想深入了解一下Express with you的最重要的功能。在这篇文章的最后，我将开发一个小的博客应用程序。这个博客应用程序使用HTTP POST请求读取数据并将数据写入数据文件，并显示数据以响应HTTP GET请求。</p><p id="d1de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用npm包管理器在本地的<em class="ku">应用程序根目录</em>中安装Express模块。</p><p id="2780" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">注意:</em> </strong> <em class="ku">你已经在你的电脑或者你的服务器上创建了一个目录，你的节点应用的所有文件都存储在这个目录中。这个目录叫做</em> <strong class="jx io"> <em class="ku">应用根目录</em> </strong> <em class="ku">。在这个应用程序根目录中，您有一个*。js文件，其中包含运行您创建的节点服务器的所有代码。这是</em> <strong class="jx io"> <em class="ku">主应用文件</em> </strong> <em class="ku">和我们这里例子中的文件</em><strong class="jx io"><em class="ku">server . js</em></strong><em class="ku">。</em></p><h2 id="f069" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><em class="lo">应用根目录</em></h2><p id="12c3" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">我们从my Node.js系列的<a class="ae kt" href="https://patrick-rottlaender.medium.com/create-a-simple-web-server-with-node-js-6db13faab0f5" rel="noopener">第1部分</a>的<em class="ku">应用程序根目录</em>的目录结构开始。清单1显示了<em class="ku">应用程序根目录</em>。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1d9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您进入应用程序根目录并运行<em class="ku"> npm install </em>。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="a0d2" class="kv kw in mb b gy mf mg l mh mi">:$ npm install express --save</span></pre><h2 id="36b1" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">主应用文件</h2><p id="dcb1" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">我们的应用程序根目录中的主应用程序文件是<em class="ku"> server.js </em>。<em class="ku"> server.js </em>文件是<em class="ku">应用主文件</em>，包含应用的代码。</p><p id="1920" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将express模块装入server.js文件，如下所示。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="0b1b" class="kv kw in mb b gy mf mg l mh mi">// server.js</span><span id="a923" class="kv kw in mb b gy mj mg l mh mi">....<br/>var express = require('express') <br/>var app = express()<br/>....</span></pre><p id="b3af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生了什么？使用require()函数从express模块导出express()函数，并引用变量<em class="ku"> express </em>。express()函数基本上是Express框架中的主要函数，在<a class="ae kt" href="https://expressjs.com/de/4x/api.html#express" rel="noopener ugc nofollow" target="_blank"> API参考</a>中有详细描述。express()函数生成一个<em class="ku">应用</em>或<em class="ku">对象</em>，存储在变量<em class="ku"> app </em>中。应用程序对象也在<a class="ae kt" href="https://expressjs.com/de/4x/api.html#app" rel="noopener ugc nofollow" target="_blank"> API参考</a>中有很好的记录，并且具有可以附加到该对象的方法，例如用于<em class="ku">路由HTTP请求</em>和配置<em class="ku">中间件</em>的方法。在本文中，我们将看到一些代码来理解路由和中间件。</p><p id="652c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> server.js </em>文件的内容如下。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9e64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> package.json </em>文件包含应用程序或项目的元数据，例如应用程序已经安装了哪些外部模块或依赖项。package-lock.json文件包含所有已安装依赖项的完整目录树，最后目录<em class="ku"> node_modules </em>包含所有已安装的依赖项、外部模块或包。</p><p id="c622" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<em class="ku"> server.js </em>文件中的代码(从上到下)执行以下操作。</p><ol class=""><li id="ab02" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated">装载模块</li><li id="46e2" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">定义路线</li><li id="c6b7" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">创建服务器</li><li id="3138" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">定义服务器正在监听的端口</li><li id="05a7" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">当所有代码顺利运行时，在控制台上记录一条成功消息</li></ol><h2 id="8518" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">快速路由</h2><p id="f185" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">路由意味着请求的转发。在我们的<em class="ku"> server.j </em> s文件的<em class="ku">清单-2 </em>中，我们在加载express模块之后，通过调用express()函数创建了一个app作为express类的实例(参见<em class="ku">清单-2 </em>中的第8行)。</p><p id="d944" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在可以使用以下符号将路由方法附加到此应用程序。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="b3ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在清单2的代码中看到的，我们定义了2个路由或应用程序端点(URIs)。将处理所有与定义的routingPath匹配的传入请求，并执行routingHandler的代码。</p><ol class=""><li id="e0f2" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated"><strong class="jx io"> routingMethod: </strong>路由方法来源于GET、POST、PUT或DELETE等HTTP方法。在我们的例子中，我们将主要处理get()和post()方法。路由方法接收两个参数:routingPath和routingHandler。</li><li id="0934" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><strong class="jx io"> routingPath: </strong>从应用程序的根目录“/”开始作为终点的路由路径。简单地说，这就是http请求传递给应用程序的路径。如果传递给应用程序的路径符合端点定义，则执行routingHandler代码。</li><li id="a904" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><strong class="jx io">routing handler:</strong>routing handler基本上是一个带参数的回调函数，处理一些代码并将http响应发送回客户端。</li></ol><p id="840a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">清单-4 </em>中的符号显示<em class="ku">T5】routing handler回调接收请求对象(req)和响应对象(res)作为参数。</em></p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="13d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">res.send()方法只是将一个字符串发送回客户端并关闭请求。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e4e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">路由处理器还可以接收函数<em class="ku"> next() </em>作为参数。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="cc27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> next() </em>函数将处理转发给回调函数中定义的下一个函数。在<em class="ku">清单-7 </em>中，显示了第一个函数在不关闭请求和不发送响应的情况下将文本记录到控制台。使用<em class="ku"> next() </em>调用下一个函数，最后一个函数使用res.send()方法向客户端发送响应并关闭请求。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="cd69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以将路由处理函数收集到一个数组中，并将该数组作为参数传递给路由方法。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="da2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面<em class="ku">清单-8 </em>的例子中，有3个路由处理器函数被收集在一个数组中。该数组作为参数传递给路由方法。r1和r2各自执行一条console.log指令，然后使用next()将路由传递给下一个路由处理函数。r3然后使用res.send()方法将响应返回给客户端。</p><h2 id="430c" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">响应对象</h2><p id="783b" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">当应用程序将HTTP响应发送回客户端时，express应用程序会创建响应对象。响应对象记录在Express <a class="ae kt" href="https://expressjs.com/de/4x/api.html#res" rel="noopener ugc nofollow" target="_blank"> API参考</a>中。响应方法有多种方法，我们在应用中使用的一种方法是<em class="ku"> res.send() </em>方法。</p><p id="2a57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> res.send(body) </em>方法可以接收body作为参数，而body可以是</p><ul class=""><li id="4e2d" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks my mq mr ms bi translated">一根绳子</li><li id="d7bb" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">一个物体</li><li id="7930" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">阵列</li><li id="8edb" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">缓冲对象</li></ul><blockquote class="mz na nb"><p id="8c89" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>浏览器使用媒体类型或MIME类型来确定如何处理来自服务器的HTTP响应。因此，服务器在HTTP响应头中发送正确的内容类型非常重要。如果配置不正确，浏览器可能会误解HTTP响应，应用程序无法正常工作。媒体类型的结构是类型/子类型。类型表示媒体类型的类别，如文本或应用程序，子类型指定数据的类型，如html或json。媒体类型在HTTP响应的content-type属性中设置。</p></blockquote><p id="9acf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面我想展示在res.send()方法中使用不同参数时不同的HTTP响应头。我的重点是内容类型属性，以及它如何使用不同的参数进行更改。</p><p id="f3dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上我在这里展示了两种不同的内容类型<em class="ku">文本</em>和<em class="ku">应用</em>。</p><ul class=""><li id="378c" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks my mq mr ms bi translated"><em class="ku">文本内容类型</em>包含任何种类人类可读的文本数据，例如源代码之类的格式化数据或html或csv之类的结构化文本数据。大多数情况下，来自我们的服务器应用程序的HTTP响应是text/html。</li><li id="f250" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated"><em class="ku">应用程序内容类型</em>是不符合任何其他类型定义的任何二进制数据。在大多数情况下，这些数据将以某种方式执行或解释。真实内容类型未知的二进制数据被设置为应用程序/八进制流。</li></ul><p id="accd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个名为<em class="ku"> curl </em>的程序使响应头在终端中可见。使用<em class="ku"> curl </em>我可以在终端中请求一个HTTP URI，并得到显示在终端中的HTTP响应。所以<em class="ku"> curl </em>必须安装在你的系统上。你可以在这里找到好的安装说明。</p><blockquote class="mz na nb"><p id="1dbd" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注</strong> : curl是一个与服务器来回传输数据的程序。curl支持包括http在内的一些协议。I选项在输出中包含HTTP响应头。HTTP响应报头包括HTTP版本、内容类型、日期等。</p></blockquote><p id="e021" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们提供res.send(body)时，其中<strong class="jx io"> body是字符串</strong>，该方法将Content-Type设置为“text/html”。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1629" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我用<em class="ku"> node server.js </em>启动服务器，在另一个终端窗口中运行<em class="ku"> curl -i localhost:3000 </em>并检查输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="b67f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们提供res.send(body)时，其中<strong class="jx io"> body是一个对象</strong>，该方法将Content-Type设置为“application/json”。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="aeca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<em class="ku"> node server.js </em>启动服务器，在另一个终端窗口中运行<em class="ku"> curl -i localhost:3000 </em>并检查输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="619d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们提供res.send(body)时，其中<strong class="jx io"> body是一个数组</strong>，该方法还将Content-Type设置为“application/json”。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="cb2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<em class="ku"> node server.js </em>启动服务器，在另一个终端窗口中运行<em class="ku"> curl -i localhost:3000 </em>并检查输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="051b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们提供res.send(body)时，其中<strong class="jx io"> body是一个缓冲区</strong>，该方法还将内容类型设置为“应用程序/八位字节流”。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9345" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用<em class="ku"> node server.js </em>启动服务器，在另一个终端窗口中运行<em class="ku"> curl -i localhost:3000 </em>并检查输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="f8bc" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">请求对象</h2><p id="94bb" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">当应用程序从客户端接收到HTTP请求时，请求对象由express应用程序创建。请求对象记录在Express <a class="ae kt" href="https://expressjs.com/de/4x/api.html#req" rel="noopener ugc nofollow" target="_blank"> API参考</a>中。</p><p id="2413" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请求对象具有可以使用的属性。您可以访问请求中提供的各种属性，并且可以在路由处理程序中处理这些数据。</p><p id="edff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">例如:</em>可以用<em class="ku"> req.path </em>和<em class="ku"> req.method </em>访问请求属性<em class="ku"> path </em>和<em class="ku"> method </em>。因此，当客户端使用HTTP GET方法请求时，即路由“/users ”,这些属性就有了可以使用的值。在这种情况下，我使用HTTP响应对象中的值。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d594" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在服务器终端中使用<em class="ku"> node server.js </em>启动服务器，然后在不同的终端中使用<em class="ku">curl-I localhost:3000/users</em>访问路由。在服务器终端中，您会看到以下输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="838d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面看到的，当您在应用程序中请求/users端点时，HTTP响应包含我创建的对象和我从请求对象接收的值。</p><p id="537f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">例如:</em>您的数据库中有许多用户，每个用户在您的web应用程序中都应该有自己的个人资料页面。要为每个用户提供这样的配置文件页面，您可以为每个用户创建一个端点或一个路由。这意味着您将拥有如此多路由，且每当有新用户加入您的用户群时，您都必须通过编程新的路由来更改您的应用程序。这是没有用的。</p><p id="b0c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可以通过使用请求参数来避免。请求参数在您的路由中定义如下。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="87a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器终端用<em class="ku"> node server.js </em>启动服务器，然后在不同的终端用<em class="ku">curl-I localhost:3000/users/Patrick</em>访问路由。在服务器终端中，您会看到以下输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d675" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的每个用户都可以通过route <em class="ku"> /users/:name </em>访问他们的个人资料页面。</p><p id="5e0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您想在没有任何其他参数的情况下访问route <em class="ku"> /users </em>，您可以预期这是可能的。不幸的是，这在当前的配置中不起作用。</p><p id="027a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器终端中保持服务器启动，然后在不同的终端中使用<em class="ku">curl-I localhost:3000/users</em>访问路由。在服务器终端中，您会看到以下输出。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="aabc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">404 HTTP状态代码告诉您路由<em class="ku">/用户</em>不存在，没有找到任何东西。</p><p id="2592" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决这个问题，您可以在路由定义中的名称后添加一个问号。这告诉Express请求参数是可选的，也可以请求路线/用户。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5b5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器终端中再次启动服务器，然后在不同的终端中再次使用<em class="ku">curl-I localhost:3000/users</em>访问路由。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="38db" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">Express中间件</h2><p id="c73e" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">中间件仅仅意味着在请求和响应之间执行代码，以便在必要时参数化响应。让我们看一下下面的路由定义，以展示中间件如何在应用程序端点中执行。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="54db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="ku"> server.js </em>文件的开头，我们定义了一个由3个函数组成的数组。每个函数将一些文本记录到控制台，并转发给下一个函数。阵列是我们在下面的应用端点定义中使用的中间件。在路由<em class="ku">/示例</em>上GET请求后的端点定义中，routingMethod首先执行函数r1、r2和r3。从r1到r3执行Console.log命令，并使用next()转发请求。在此之前，不会返回任何响应。请求由r3转发给routingHandler函数，然后请求被应答。</p><p id="318e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以将模块作为中间件加载，并在处理任何路由的请求时和响应之前始终执行中间件的代码。</p><p id="82e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们假设下面的目录结构。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="06b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">中间件模块如何工作的一个非常好但简单的例子是使用一个简单的控制台记录器。为了演示这一点，我在模块目录中创建了一个logger.js文件。</p><p id="03ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模块目录中的looger.js文件包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="cb31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> logger.js </em>文件包含一个简单的函数logger()，该函数将使用module.exports导出。每当请求任何路由时，<em class="ku"> req.method </em>和<em class="ku"> req.path </em>将被记录在终端中，然后处理将通过next()函数转发。因此，首先将请求传递给应用程序，然后执行console.log指令，然后将请求转发给相应的routingMethod。</p><p id="7f41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些路由是在我们的主应用程序文件server.js中定义的。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ce03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="ku"> server.js </em>主应用文件中，我加载模块并将logger()函数存储到变量<em class="ku"> logger </em>中。中间件集成在带有<em class="ku"> app的代码中，使用</em>挂载指定的中间件。</p><p id="18cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我用<em class="ku">节点server.js </em>启动服务器。在另一个终端窗口中，我使用curl来调用路由“/”和“/about”。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f7df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在服务器运行的第一个终端窗口中，我们看到日志记录对两条路由都有效。对于这两个请求，都执行了logger中间件模块的console.log命令。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h2 id="5fa2" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">使用Express创建一个小型博客应用程序</h2><p id="a506" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">小博客应用程序应该是一个没有任何HTML渲染和输入验证的web应用程序。它应该简单地展示我们如何利用到目前为止所学的东西。这个博客将博客和用户存储在一个数据文件中。我们将创建路由端点来添加和删除用户和博客，我们将创建包含程序逻辑的模块来操作数据。</p><blockquote class="mz na nb"><p id="fbfd" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:你<strong class="jx io">永远不要</strong>在没有输入验证的情况下在生产中实现应用程序。从安全角度来看，这是绝对不能接受的。我将在我的<a class="ae kt" href="https://patrick-rottlaender.medium.com/" rel="noopener">媒体</a>或我的博客<a class="ae kt" href="https://digitaldocblog.com/home?currpage=1" rel="noopener ugc nofollow" target="_blank"> Digitaldocblog </a>上的一篇额外的帖子中用Express 处理主题<em class="in">输入验证。</em></p></blockquote><p id="639e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在我的<a class="ae kt" href="https://github.com/prottlaender/node-part-2-express-blog-V1" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上找到本章讨论的代码。</p><p id="8251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先我们创建一个新的应用根目录<em class="ku"> express-blog </em>。在这个目录中，我们用<em class="ku"> touch </em>命令创建了主应用程序文件<em class="ku"> blog.js </em>和一个<em class="ku"> package.json </em>文件。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1c31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在编辑器中打开package.json文件，并编辑该文件，如下所示。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d68e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<em class="ku"> npm install </em>安装express，并确保我们将在最新版本中安装express，但未来安装时不会对该版本进行更新。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4faf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们创建一个data.json文件和一个模块目录。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="fdf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在已经创建了应用程序根目录的结构，我们可以开始开发博客应用程序了。</p><p id="880d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步</strong>:首先我要在<em class="ku"> blog.js </em>主应用文件中写初始代码。该代码加载我们之前安装的express模块，并在localhost的端口3000上启动服务器。此外，已经定义了一个本地路由。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="64fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了创建用户和博客数据，我应该有2个不同的模块。一个将创建用户，另一个将创建博客。因此，我在模块目录中创建了两个文件。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6978" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二步:在data.json文件中，我将存储用户和博客数据。数据文件当前为空，但将具有以下结构。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="11d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个json数据对象，带有关键字<em class="ku"> users </em>和<em class="ku"> blogs </em>。这些键都有一个以对象为元素的数组。所以data.json (users，blogs)中的每个主键都有I，j个元素代表某个用户(data.users[i])和某个博客(data.blogs[j])。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3eda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我现在将在<em class="ku"> createUsers.js </em>和<em class="ku"> createBlogs.js </em>文件中编写两个模块<em class="ku"> usersAdd </em>和<em class="ku"> blogsAdd </em>。这些文件包含最初创建用户或博客记录或将相应的用户或博客记录添加到<em class="ku"> data.json </em>文件的函数。</p><p id="0bb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> createUsers.js </em>文件包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4a5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先加载<em class="ku"> fs </em>模块。这是一个节点内部模块，用于读取文件以及将数据写入文件。然后我们创建<em class="ku"> usersAdd </em>函数，该函数将通过<em class="ku">模块导出。</em></p><p id="ad96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> usersAdd </em>函数使用fs.readFileSync读取data.json文件，并将接收到的数据存储到<em class="ku"> dataExp </em>变量中。如果<em class="ku"> dataExp </em>为空，则我们有一个空数据文件，必须首先创建空数据对象，并将其存储到变量<em class="ku"> data </em>中。然后，我们用data.users在数据对象上创建用户键，并分配一个空数组。</p><p id="1eef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从请求体接收姓名、姓氏和电子邮件，并将这些数据存储到新的用户变量中。对于初始用户条目，我们定义id 100。</p><blockquote class="mz na nb"><p id="4822" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:在本教程的后面，我们将看到应用程序主文件blog.js中的POST路由定义/createusers。这个POST路由将使用参数req和res调用usersAdd，以便我们可以访问createUsers.js中的req.body对象。我们将在后面看到。</p></blockquote><p id="0a5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用name、lastname、email、id这样的关键字创建一个新的User对象，并将从请求主体收到的新用户变量赋值给它们。然后，我们将newUser对象推入users键的数组(在开始时用data.users = [ ]创建),该数组链接到我们在开始时用data = { }创建的数据对象。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="16d5" class="kv kw in mb b gy mf mg l mh mi">data.users.push(newUser)</span></pre><p id="bad6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此之后，我们有以下JavaScript数据对象。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用JSON.stringify()我们获取JavaScript数据对象，从中创建一个JSON字符串，并将该字符串存储到dataToFile变量中。使用fs.writeFile，我们将json字符串写入到目前为止为空的data.json文件中。</p><blockquote class="mz na nb"><p id="398f" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:如果使用JavaScript开发应用程序，如果要将数据存储在数据库或数据文件中，JavaScript对象必须转换成字符串。如果您想将数据发送到API或web服务器，这同样适用。JSON.stringify()函数为我们完成了这项工作。</p></blockquote><p id="3d89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们知道了在data.json文件完全为空并且第一个if条件为true ( <em class="ku"> if(！dataExp) </em>)。现在让我们看看，如果第一个if条件为false，即data.json文件已经有数据，会发生什么，代码会做什么。如果变量<em class="ku"> dataExp </em>不为空，就是这种情况。</p><p id="a8f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们已经看到的，我们在数据文件中存储了一个JSON字符串。因此，当我们读取文件并将数据存储到变量<em class="ku"> dataExp </em>中时，我们在该变量中有JSON字符串数据。为了在我们的JavaScript代码中处理这些数据，我们必须解析这个JSON，以便从JSON字符串创建一个JavaScript对象。这就是我们用JSON.parse()函数做的事情。</p><p id="29dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们将JavaScript对象存储到变量<em class="ku">数据</em>中。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="ecdd" class="kv kw in mb b gy mf mg l mh mi">var data = JSON.parse(dataExp)</span></pre><p id="ec48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们的代码被设计为在data.json文件中只存储一个数据对象，所以变量<em class="ku"> data </em>就是我们的数据对象。因此，当我们有了数据对象后，我们可以询问用户是否已经存在。</p><p id="10d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们使用if条件来检查键<em class="ku"> data.users </em>是否存在。</p><p id="0636" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以防病情<em class="ku">如果(！data.users) </em>为真，关键的data.users不存在，这意味着<strong class="jx io">到目前为止没有可用的用户</strong>。此时，我们创建一个<em class="ku"> data.users </em>键，并分配一个空数组。在下面的代码中，一个<em class="ku"> newUser </em>对象以与上述相同的方式创建，并使用<em class="ku"> data.users.push() </em>方法插入到数组中。现在数据对象有了一个额外的键data.users，这个键有一个作为值的<em class="ku"> newUser </em>对象。现在，我们可以将整个数据对象再次转换为字符串，并完全覆盖data.json文件。</p><p id="6fc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">万一条件<em class="ku"> if(！data.users) </em>为假，关键的data.users已经存在并且<strong class="jx io">用户可用</strong>。如果用户存在，单个用户记录自然会有现有的id。所以我们首先必须创建一个算法来为新用户获取一个新的用户ID。</p><p id="b386" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先创建一个变量<em class="ku"> newID </em>和一个变量<em class="ku"> minID </em>。minID对应于至少必须被分配的userID，因为它对应于我们的第一个用户数据对象的userID。<em class="ku"> minID </em>必须是第一条用户数据对象记录的ID值。因为用户对象存储在一个数组中，所以它必须对应于零位置的用户对象。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="094e" class="kv kw in mb b gy mf mg l mh mi">var minID = data.users[0].id</span></pre><p id="a06a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">newID应该比上一次找到的用户对象的ID大100。这就是为什么我们遍历所有用户对象，将值100加到找到的最后一个用户对象的id值上。最后，我们将最后一个用户对象的id值加上100，并将这个值赋给<em class="ku"> newID </em>。</p><p id="6a7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的代码中，再次创建了一个<em class="ku"> newUser </em>对象，整个数据对象被转换成一个字符串并存储到data.json文件中。</p><p id="95ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">blogsAdd函数的代码完全按照相同的方案实现。唯一的区别是博客id只增长1。</p><p id="6c2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">createBlogs.js文件包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f954" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第三步</strong>:需要调整<em class="ku"> blog.js </em>文件。首先，我们集成了中间件，它允许我们用urlencoded有效负载解析传入的http请求。</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="4431" class="kv kw in mb b gy mf mg l mh mi">app.use(express.urlencoded({ extended: false }))</span></pre><p id="7925" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后必须用require()函数将这两个模块加载到<em class="ku"> blog.js </em>文件中。因此我们需要文件<em class="ku"> createUsers.js </em>和<em class="ku"> createBlogs.js </em>。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><blockquote class="mz na nb"><p id="78a0" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注</strong>:我想在这里再解释一下模块的require()这个话题。createBlogs.js和createUsers.js文件包含usersAdd和blogsAdd函数，这两个函数都是使用module.exports导出的。module.exports指令意味着，如果使用require()加载了createBlogs.js和createUsers.js文件，则可以在应用程序的其他文件中调用这些函数。usersAdd和blogsAdd没有返回值，因此函数本身保存在blog.js中的变量createBlogs和createUsers中。例如，如果在POST路由中调用createUsers(req，res ),则调用usersAdd函数，并将req和res作为参数传递。</p></blockquote><p id="2a51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在上面两个模块的代码中看到的，用户或博客对象的初始创建或添加的值通过请求体传递给函数<em class="ku"> usersAdd </em>或<em class="ku"> blogsAdd </em>。为此，必须在<em class="ku"> blog.js </em>文件中创建发布路径<em class="ku"> /createusers </em>和<em class="ku"> /createblogs </em>。这些POST路由通过createUsers()或createBlogs()调用函数<em class="ku"> usersAdd </em>或<em class="ku"> blogsAdd </em>。</p><p id="0894" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> blog.js </em>文件包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8fcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们能够添加博客和用户。</p><blockquote class="mz na nb"><p id="d0c1" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:在这个应用程序中，我们没有用户界面来输入用户变量，如姓名、电子邮件或博客变量，如标题、作者和日期。使用此应用程序，您不能在表单中输入数据，然后使用HTTP POST将数据传输到应用程序routes /createusers或/createblogs。这就是邮递员出现的地方。使用<a class="ae kt" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>您可以通过在HTTP POST请求的HTTP主体中手工输入这些数据来模拟一个表单。邮递员检查POST请求是否成功。在这一点上，我不想谈论邮递员。所以请。查看<a class="ae kt" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman网站</a>上的文档。</p></blockquote><p id="c35b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是仍然没有办法从<em class="ku"> data.json </em>文件中删除数据。我们现在想通过如何删除用户的例子来说明这一点。</p><p id="3ea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应该完全接管此功能的模块是usersRemove()函数，我将把它写入文件r <em class="ku"> emoveUsers.js中。</em>为此，我们首先在模块目录中创建一个空文件r <em class="ku"> emoveUsers.js </em>。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> removeUsers.js </em>文件包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="142c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先再次加载node fs模块，然后定义函数usersRemove()，然后在代码末尾使用module.exports导出该函数。函数usersRemove()接收req和res作为参数，读取<em class="ku"> data.json </em>文件，并将读取的数据解析为由变量<em class="ku"> data </em>表示的JavaScript对象。</p><p id="1158" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了向您展示数据对象，我只需运行如下脚本。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c7d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您检查您的控制台时，您可以看到我们将文件中的所有json-data保存在变量data中。我们看到一个可以在我们的代码中使用的JavaScript对象。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8df8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码中，我们从req.body中获取userID，并将其存储到变量delUserID中。req.body中的值是一个字符串。当我们在json数据文件中将userIDs作为数字操作时，我们必须将字符串转换成数字。这是用“- 0”完成的。这里我们减去数值零，告诉JavaScript delUserID是一个数字而不是一个字符串。</p><p id="f1bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们必须找到需要删除的用户对象。用户对象是data.users数组中的元素。因此，我们必须找到req.body中的userID与data.users数组中的userID相匹配的用户对象，因为这个userID标识了应该删除的用户对象，因此应该从data.users数组中删除。</p><p id="dac4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当来自rep.body的userID等于data.users数组中用户对象的userID时，回调函数elementFound返回true。</p><p id="68bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">data.users.findIndex()方法返回在data.users数组中找到的第一个用户对象的索引，其中来自rep.body的userID等于用户对象的userID。</p><p id="1e27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">data.users.splice(index，1)在索引位置删除1个用户对象。由于findIndex()方法之前返回了我们要删除的用户对象的确切位置，这里的splice()方法最终删除了用户对象。</p><p id="0c68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由博客对象和用户对象组成的完整数据对象现在减少了一个用户对象。缩减的数据对象作为一个整体转换成一个字符串，并使用fs.writeFile()方法再次写入data.json文件。</p><p id="ca0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">blogsRemove()函数的工作方式与上面解释的usersRemove()函数相同。因此，模块目录中的文件removeBlogs.js如下所示。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ec9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面两个removeUsers.js和removeBlogs.js模块的代码中，要删除的用户或博客对象的值通过请求体传递给usersRemove()或blogsRemove()函数。为此，必须在<em class="ku"> blog.js </em>文件中创建POST routes /removeusers和/removeblogs。这些发布路由调用模块removeUsers.js和removeBlogs.js中定义的函数usersRemove()或blogsRemove()。这些模块也必须用require()函数加载到<em class="ku"> blog.js </em>文件中。</p><p id="b668" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">blog.js文件现在包含以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="23f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步</strong>:我们的应用程序目前可以创建用户和博客，也可以删除博客和用户。到目前为止还不错。现在应该添加另一个功能，即博客的显示。这将通过这样一种方式实现，即一个路由的GET请求根据请求中提供的请求参数向服务器发回不同的响应。</p><p id="cde8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是什么意思？</p><p id="17d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:我们的数据文件中有各种博客，它们都是为特定日期创建的。我们希望看到所有的博客，也希望看到某年或某月的博客，或者是在特定日期创建的博客。</p><p id="3182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您希望通过此途径访问所有博客。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="7bb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而你想在2020年用这个途径访问所有的博客。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c3f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">诸如此类。</p><p id="2ba7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用请求参数更优雅地做到这一点。我们在blog.js文件中创建了以下GET route。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f51c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问号表示参数年、月和日是可选的，也可以在请求时省略。</p><p id="eeb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经定义了一个路由，它应该根据请求参数给出不同的响应。这就是为什么我们首先必须评估路由定义中的请求参数，然后定义应该如何回答不同查询的条件。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="eefb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">稍后我将回到完整的主应用程序文件blog.js。</p><p id="9b54" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的目标是显示博客文章。根据路线，我们希望显示(1)所有博客或(2)一年的所有博客或(3)一年零一个月的所有博客或(4)特定日期的所有博客帖子。</p><p id="dc5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了从我们的<em class="ku"> data.json </em>文件中收集所请求的数据，我们基本上需要4个新函数来执行这些查询。因此，我在模块目录中创建了一个新的<em class="ku">查询模块</em>。这个<em class="ku"> queryModule </em>包含所有这4个查询函数，它们都将在我们的应用程序中可用。<em class="ku"> queryModule </em>文件中的代码符号与前面的模块略有不同。</p><p id="38c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因是，我们以前在模块目录中有一个模块文件，该文件中只有一个函数。模块文件导出值是函数本身。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9666" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的主应用程序文件中，我们用require函数加载previousModule，并将值作为函数存储到变量previousModule中。然后我们可以用previousModule()直接调用主应用程序文件中的函数。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="85fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们示例中的queryModule应该查询博客，我们需要不同的函数。所以这个文件是不同的。在这个文件中，我们收集了4个函数，但是我们没有将它们作为函数导出。相反，我们使用module.exports来导出一个有4个键的对象。这些键中的每一个都只有一个值，这个值就是各自的功能。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5aaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的主应用程序文件中，我们用require函数加载queryModule，并将导出的对象存储到变量<em class="ku"> queryModule </em>中。我们现在可以通过<em class="ku"> object.key </em>符号从主应用程序文件中调用函数。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2922" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们在modules目录中查看新的<em class="ku"> queryBlogs.js </em>文件时，您会看到该文件中有一个包含4个不同键的对象，这些键包含以下函数()作为值。</p><ul class=""><li id="fabb" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks my mq mr ms bi translated">queryAllBlogs</li><li id="1f16" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">queryBlogsYear</li><li id="ba26" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">queryBlogsYearMonth</li><li id="792c" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">queryBlogsYearMonthDay</li></ul><p id="790a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与前面的模块还有一个重要的区别。<em class="ku"> queryBlogs.js </em>中的那些函数每个都返回值。这个值是查询结果，稍后可以在我们的主应用程序文件<em class="ku"> blog.js </em>中使用，以向最终用户显示请求的数据。基本上，这个值是一个博客文章的数组，当某个路由被请求时，应该显示这些博客文章。</p><p id="d889" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此<em class="ku"> queryBlogs.js </em>文件如下所示。我将详细解释<em class="ku">查询日志</em>和<em class="ku">查询日志年份</em>。另外两个功能<em class="ku"> queryBlogsYearMonth </em>和<em class="ku"> queryBlogsYearMonthDay </em>示意性相同。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f09d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的数据作为字符串存储在一个<em class="ku"> data.json </em>文件中。我们应用程序中与数据相关的每个操作都要求我们能够访问JavaScript数据对象。因此，如果我们想要搜索或选择数据，以便在应用程序中只显示其中的一部分，例如，只显示某一年的所有博客文章，仍然需要事先从数据文件中读取全部数据。在拥有大量数据的大型项目中，这种基于文件的方法并不合适。然后，您应该使用数据库。</p><blockquote class="mz na nb"><p id="da23" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:对于大量的数据，使用MongoDB这样的数据库是有意义的，因为我们可以直接在数据库中搜索特定的值，而没有必要从数据库中检索所有的数据。我将在以后的另一篇文章中向您展示MongoDB的用法。为了简单起见，在本文中让我们坚持使用基于文件的方法。</p></blockquote><p id="3de8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku"> queryAllBlogs </em>函数是我们显示博客的其他查询的基础。这个函数首先定义一个空数组<em class="ku"> allBlogs </em>。然后，如上所述，使用<em class="ku"> fs.readFileSync </em>从数据文件中完全读取数据，并使用<em class="ku"> JSON.parse </em>将其转换为JavaScript对象。现在，我们可以访问带有<em class="ku">数据的博客帖子。然而，这并不完全正确。正如我们在上面已经看到的，<em class="ku"> data.blogs </em>是数据对象中的一个键，这个键有一个数组作为值。严格地说，这个数组包含的元素是博客文章。</em></p><p id="0343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在任何情况下，通过for循环，我们使用data.blogs[i]遍历数组的所有元素，以便可以从数据文件中读取每个单独的博客数据记录，并使用<em class="ku"> allBlogs.push() </em>方法将其作为<em class="ku">数据集</em>对象附加到首先定义的<em class="ku"> allBlogs </em>数组。函数<em class="ku"> queryAllBlogs() </em>然后将<em class="ku"> allBlogs </em>返回给调用者。<em class="ku">所有博客</em>包含所有<em class="ku">数据集</em>对象。allBlogs 数组如下所示。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数<em class="ku"> queryBlogsYear </em>将<em class="ku"> allBlogs </em>数组作为参数(与模块中定义的任何其他函数queryBlogs*一样)。这是因为我们希望在<em class="ku"> queryBlogsYear </em>函数中选择其中的所有数据，因此所有的博客文章都必须在该函数范围内可用。</p><blockquote class="mz na nb"><p id="8805" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>只看queryBlogs.js文件，不明白queryBlogs*函数中的allBlogs array as参数是从哪里来的。要访问所有博客中的数据，必须首先执行返回所有博客的queryAllBlogs函数。这发生在routingMethod的应用程序主文件blog.js中。请。见下文。</p></blockquote><p id="69c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们创建空数组yearBlogs。该数组将在函数代码的末尾包含所有应该由queryBlogsYear函数稍后返回的数据。</p><p id="8078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们使用for循环遍历allBlogs数组。</p><p id="46b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在for循环中，我们首先用<em class="ku"> allblogs[i]读取blog date的值。日期</em>并将该值存储在变量<em class="ku"> blogDate </em>中。在数据文件中，日期以ISO 8601日期格式(YYYY-mm-dd)保存。强烈建议总是以这种格式保存日期，因为ISO 8601是JavaScript首选的日期格式，因此对日期的所有其他操作都更容易。为了在JavaScript中很好地处理日期字符串yyyy-mm-dd，必须首先使用<em class="ku"> Date.parse() </em>将这个字符串date转换成一个数字。然后使用<em class="ku"> new Date() </em>方法将该数字转换成一个日期对象。</p><blockquote class="mz na nb"><p id="4692" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注</strong> : Date.parse()接收ISO 8601格式的日期字符串yyyy-mm-dd，并返回一个表示UTC 1970年1月1日00:00:00之间的毫秒数。这个数字是唯一的，是使用new date()方法创建Date对象所必需的。使用这个日期对象，我们可以访问给定日期对象的年、月或日。</p></blockquote><p id="d4bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的代码<em class="ku">中，Date.parse() </em>作为参数直接传递给<em class="ku"> new Date() </em>方法，这样就可以从返回的数字中直接生成所需的日期对象。日期对象存储在变量<em class="ku"> parsedBlogDate </em>中。</p><p id="ee0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为<em class="ku"> parsedBlogDate </em>表示一个对象，所以<em class="ku">parsedBlogDate . getfullyear()</em>方法让我们能够访问日期所对应的年份。年份存储在<em class="ku">变量parsedBlogDateYear </em>中。</p><blockquote class="mz na nb"><p id="6169" class="jv jw ku jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:我使用parsedBlogDate.getMonth()从Date对象中检索月份。此方法为一月返回0，为十二月返回11。因此，有必要添加“+1”来获得通常的值1表示一月，12表示十二月。我们将使用parsedBlogDate.getDate()检索一个月中的第一天为1，每个月的最后一天为max 31。</p></blockquote><p id="8085" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们在if循环中比较请求中传递的年份(year = req.params.year，变量year在blog.js中定义)和所有博客文章的年份。我们只生成请求的年份与博客文章的年份相匹配的数据集。以这种方式创建的数组<em class="ku"> yearBlogs </em>然后作为返回值返回给调用者。</p><p id="e44b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我现在将回到主应用程序文件<em class="ku"> blog.js </em>和具体的路由定义，在这里我们评估请求参数并提供不同的响应。通过这个路由，我们根据请求参数发送以下响应。</p><ul class=""><li id="e8ab" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks my mq mr ms bi translated">所有博客帖子— res.send(所有博客)</li><li id="9abc" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">给定年份的博客帖子— res.send(blogsYear)</li><li id="019b" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">给定年份和月份的博客帖子— res.send(blogsYearMonth)</li><li id="237e" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks my mq mr ms bi translated">给定日期的博客帖子— res.send(blogsYearMonthDay)</li></ul><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="b8be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经定义了一个路由，它根据请求参数给出不同的响应。当请求url == /blog时，我们希望看到所有博客，当请求url == /blog/2019时，我们看到所有博客，即给定年份2019的博客，等等。</p><p id="6f2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们用require()函数加载<em class="ku"> queryBlogs </em>模块，并将对象保存在变量<em class="ku"> queryBlogs </em>中(记住模块queryBlogs返回一个函数对象)。</p><p id="cd42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在路由定义中，我们获取与请求一起传递的请求参数，并将它们保存在变量url、year、month和day中。然后我们用<em class="ku">queryBlogs . queryAllBlogs()</em>访问queryBlogs模块中定义的<em class="ku"> queryAllBlogs() </em>函数。这个函数返回所有的博客文章，这些博客文章存储在<em class="ku"> allBlogs </em>数组中。</p><p id="5ea5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们创建if和else if条件来定义应用程序中路由定义的响应行为。</p><p id="a705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在请求的url等于<em class="ku"> /blog </em>的情况下，如果条件为真，则首先为<strong class="jx io">。当allBlogs数组为空时，下面的if条件为true。然后，响应是no post found<em class="ku">RES . send(' no post found ')</em>。当这个if条件为false时，已经在<em class="ku"> allBlogs </em>数组中找到了博客文章。在这种情况下，来自<em class="ku"> allBlogs </em>数组的所有数据将通过<em class="ku"> res.send(allBlogs) </em>发送回调用者。</strong></p><p id="7237" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果请求的网址等于<em class="ku">/博客/年份</em>(即/博客/2019)，则条件为真，则<strong class="jx io">为先。当else if条件为真时，我们调用queryBlogs模块中的queryBlogsYear()函数，并将allBlogs数组作为参数传递。我们使用<em class="ku">query blogs . query blogs year(all blogs)</em>调用函数，并将返回值存储在数组变量<em class="ku"> blogsYear </em>中。</strong></p><p id="7cf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<em class="ku"> blogsYear </em>数组为空，下面的If条件为真。这意味着在<em class="ku">所有博客</em>中没有找到请求年份的博客帖子。那么响应是今年没有找到帖子<em class="ku">RES . send(‘今年没有找到帖子’)</em>。当if条件为false时，已经找到请求年份的博客文章，并且blogsYear数组不为空。然后来自<em class="ku"> blogsYear </em>数组的所有这些数据将被用<em class="ku"> res.send(blogsYear) </em>发送回调用者。</p><p id="979d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当请求的网址等于<em class="ku">/博客/年/月</em>(即/博客/2019/04)时，条件为真则<strong class="jx io">秒。当else if条件为真时，我们调用queryBlogs模块中的<em class="ku"> queryBlogsYearMonth() </em>函数，并将<em class="ku"> allBlogs </em>数组作为参数传递。我们使用<em class="ku">queryblogs . queryblogsyearmonth(all blogs)</em>调用函数，并将返回值存储在数组变量<em class="ku"> blogsYearMonth </em>中。</strong></p><p id="c4a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果blogsYearMonth数组为空，则下面的If条件为真。这意味着在<em class="ku">所有博客</em>中没有找到请求年份和月份的博客帖子。那么响应是今年和本月没有找到帖子<em class="ku">RES . send(‘今年和本月没有找到帖子’)</em>。当这个if条件为false时，已经为所请求的年份和月份找到了博客文章，并且<em class="ku"> blogsYearMonth </em>数组不为空。然后，blogsYearMonth数组中的所有这些数据将通过<em class="ku">RES . send(blogsYearMonth)</em>发送回调用者。</p><p id="c1bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在请求的url等于<em class="ku">/博客/年/月/日</em>(即/博客/2019/04/10)的情况下，如果条件为真，则<strong class="jx io">为第三个否则。当else if条件为真时，我们调用queryBlogs模块中的queryBlogsYearMonthDay()函数，并将allBlogs数组作为参数传递。我们使用<em class="ku">queryblogs . queryblogsyearmontday(all blogs)</em>调用函数，并将返回值存储在数组变量<em class="ku">blogsyearmontday</em>中。</strong></p><p id="c972" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果blogsYearMonthDay数组为空，则下面的If条件为真。这意味着在<em class="ku">所有博客</em>中没有找到请求日期的博客帖子。那么响应是没有找到今年和年月日的帖子<em class="ku">RES . send(‘没有找到今年和年月日的帖子’)</em>。当if条件为false时，已找到请求日期的博客文章，并且blogsYearMonth数组不为空。然后来自<em class="ku"> blogsYearMonthDay </em>数组的所有这些数据将通过<em class="ku">RES . send(blogsYearMonthDay)</em>发送回调用者。</p><p id="12a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果所有<strong class="jx io"> if和else if条件</strong>为假，则请求的url与任何已定义的请求参数(/blog/:year？/:月？/:日？).则<strong class="jx io">否则响应</strong>为<em class="ku"> res.status(404)。发送('未找到')</em>。</p><h2 id="cd6d" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">总结与展望</h2><p id="2f10" class="pw-post-body-paragraph jv jw in jx b jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko lt kq kr ks ig bi translated">在Node.js系列的第2部分中，我解释了express的一些非常重要的细节，以及如何在web应用程序开发中使用Express。基于我们在<a class="ae kt" href="https://digitaldocblog.com/webserver/nodejs-series-part-1-create-a-simple-web-server-with-nodejs/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中已经了解的关于Express的知识，我们详细地查看了Express路由，以及如何相对容易地在Express中使用中间件。利用我们学到的知识，我们构建了一个简单的博客web应用程序，并应用了这些知识。</p><p id="c3de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个博客应用程序有一个文件中的所有数据，没有HTML前端。Express非常适合使用像MongoDB这样的数据库，也适合使用HTML模板来呈现内容。在我的Node.js系列的下一篇<a class="ae kt" href="https://digitaldocblog.com/webserver/nodejs-series-part-3-the-simple-express-blog-app-with-mongodb/" rel="noopener ugc nofollow" target="_blank">第3部分</a>中，我将向您展示如何使用MongoDB数据库而不是数据文件。然后，我们将继续开发博客应用程序，并在博客应用程序上实现一个HTML前端。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><h2 id="9f83" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">进一步阅读</h2><div class="nm nn gp gr no np"><a href="https://bit.cloud/blog/how-to-build-a-composable-blog-l1jkl9f4" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">如何建立一个可组合的博客</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">从头开始创建一个博客需要很多。有许多移动的部件组合在一起形成一个…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">比特云</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jt np"/></div></div></a></div><p id="d87b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">更多内容请看</em><a class="ae kt" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">plain English . io</em></strong></a><em class="ku">。报名参加我们的</em> <a class="ae kt" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">免费周报</em> </strong> </a> <em class="ku">。关注我们关于</em><a class="ae kt" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">Twitter</em></strong></a><a class="ae kt" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">LinkedIn</em></strong></a><strong class="jx io"><em class="ku"/></strong><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">YouTube</em></strong></a><strong class="jx io"><em class="ku">，以及</em></strong><em class="ku"/><a class="ae kt" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku">不和</em> </strong> </a>  <em class="ku">对成长黑客感兴趣？检查</em> <a class="ae kt" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">电路</em> </strong> </a> <strong class="jx io"> <em class="ku">。</em> </strong></p></div></div>    
</body>
</html>