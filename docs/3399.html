<html>
<head>
<title>Coding Interviews: Solving the “Merge Sorted Arrays in Place” Problem in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码访谈:解决JavaScript中的“就地合并排序数组”问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/coding-interviews-solving-the-merge-sorted-arrays-in-place-problem-712b322f5bfe?source=collection_archive---------23-----------------------#2021-07-09">https://javascript.plainenglish.io/coding-interviews-solving-the-merge-sorted-arrays-in-place-problem-712b322f5bfe?source=collection_archive---------23-----------------------#2021-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7f695fa1bc6869161dd0160da830052c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zHX2zFjz7PQNb2Zi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lg17?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lance Grandahl</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2a0c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关于采访编码的一般说明</h1><p id="6ae0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">像往常一样，我想谈谈编码面试的本质。他们非常类似于参加SAT或GRE考试；有时候，它们不一定是你在工作中或大学里表现的最佳反映，但更多的是你的准备和资源的反映。</p><p id="4b40" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">只要公司还在使用这些类型的问题，你就需要为它们做好准备。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="0ae7" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">问题来源/灵感</h1><p id="61e0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是一个常见的面试问题。<br/> <em class="mq">提问者:亚马逊、谷歌、苹果、脸书、网飞、微软等等。</em></p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="4e5b" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">问题描述</h1><p id="a1bc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">给定两个排序后的整数数组<code class="fe mr ms mt mu b">A</code>和<code class="fe mr ms mt mu b">B</code>，将<code class="fe mr ms mt mu b">B</code>合并为<code class="fe mr ms mt mu b">A</code>作为一个排序后的数组。注意，你可以假设<code class="fe mr ms mt mu b">A</code>有足够的空间容纳来自<code class="fe mr ms mt mu b">B</code>的额外元素，并且在<code class="fe mr ms mt mu b">A</code>和<code class="fe mr ms mt mu b">B</code>中初始化的元素数量分别是<code class="fe mr ms mt mu b">m</code>和<code class="fe mr ms mt mu b">n</code>。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="62f0" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">问题解决方案</h1><p id="6d94" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">下面让我们来看一下我们的算法。通过首先将项目移动到第一个数组的末尾，我们可以最小化需要移动的单元数量(即时间复杂度)，因为额外的空间位于数组的末尾。如果我们从第一个数组的开头开始移动项，我们可能必须将第一个数组中该单元格后面的所有项移动一位。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/cb45d914fcf221c226a68afce0a87f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5wupNta5qUFMphItVugeg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A visual representation of merging to sorted arrays in place</figcaption></figure><p id="f721" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在我们来看看问题的解决方案，分解一下关键方面。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A solution to merging sorted arrays in place using pointers</figcaption></figure><p id="6462" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我选择创建三个索引变量<code class="fe mr ms mt mu b">i</code>、<code class="fe mr ms mt mu b">j</code>和<code class="fe mr ms mt mu b">k</code>来指向感兴趣的特定索引。<code class="fe mr ms mt mu b">i</code>对应第一个数组的当前项索引，从最后一项开始。<code class="fe mr ms mt mu b">j</code>对应第二个数组的当前项索引，也是从最后一项开始。最后，<code class="fe mr ms mt mu b">k</code>对应需要填充的单元格的索引，从第一个数组的最后一个索引开始。</p><p id="e958" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">确定了我们的指针之后，我们就可以开始迭代了。我们从向后遍历第一个数组开始。对于每次迭代，我们比较来自各自数组的<code class="fe mr ms mt mu b">i</code>和<code class="fe mr ms mt mu b">j</code>处的值，较大的项被分配给<code class="fe mr ms mt mu b">k</code>处的单元格。每次迭代我们都需要更新适当的指针。我们在每个循环中递减<code class="fe mr ms mt mu b">k</code>，也递减<code class="fe mr ms mt mu b">i</code>或<code class="fe mr ms mt mu b">j</code>，这取决于我们从哪个数组中取出了一个项目。我们也处理7号线的边缘案件。如果<code class="fe mr ms mt mu b">j</code>小于0，这意味着第二个数组是空的，我们只需要从第一个数组中抽取。同样，如果<code class="fe mr ms mt mu b">i</code>小于0，我们只需要从第二个数组中抽取。</p><h1 id="532e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="acc7" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个问题的主要挑战是确定将项目移动到数组后面可用空间的有用性。您可以从前端开始，但是这会使逻辑和代码变得更加复杂。花一些时间考虑这样的时间复杂性的含义将会为你节省更多的编码时间。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="10f8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mq">最初发表于</em><a class="ae kc" href="https://codingbootcampguides.com" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://codingbootcampguides.com</em></a><em class="mq">。</em></p><p id="c9dc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mq">更多内容请看</em><a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"><em class="mq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>