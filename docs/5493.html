<html>
<head>
<title>How to Download Files in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript下载文件？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-download-in-javascript-9530fdeda5f2?source=collection_archive---------4-----------------------#2021-11-14">https://javascript.plainenglish.io/how-to-download-in-javascript-9530fdeda5f2?source=collection_archive---------4-----------------------#2021-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Javascript中，您是否想过如何下载从API发送的文件？更有趣的是，有没有想过如何下载多个文件？</p><p id="15dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们学习如何！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/57c0387738fa9b080102627a7574d297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYLKej1IdpYSqaSeYH3aJg.jpeg"/></div></div></figure><h2 id="b034" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">先决条件</h2><ol class=""><li id="9502" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated">在本文中，我们将考虑以下API:“https://getmy file . com/<file id="">”</file></li><li id="e9f2" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">上面的API将返回一个八位字节流，它必须由客户端下载。</li></ol><h2 id="8e9f" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">用JavaScript下载一个文件</h2><p id="d565" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated"><strong class="jp ir">API调用</strong></p><p id="b459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用<strong class="jp ir">获取</strong>来进行所需的API调用。我们的代码将如下所示。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="ec50" class="kx ky iq mk b gy mo mp l mq mr">export const downloadSignedFile = (fileId) =&gt; {</span><span id="4355" class="kx ky iq mk b gy ms mp l mq mr">return <strong class="mk ir">fetch</strong>("https://getmyfile.com/"+fileId, requestOptions)</span><span id="d509" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="d6f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们传递要下载的文件的文件id。而且，上面的API将返回文件，该文件需要下载到客户机系统中。</p><p id="319c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">响应</strong></p><p id="3849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们调用上面的<strong class="jp ir"> API调用</strong>，传递所需的文件id。同样，这段代码是为满足我的需求和API设计而编写的。您当然可以修改API的调用方式，以适应您的应用程序。</p><p id="5ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们的API的响应是一个<strong class="jp ir"> blob </strong>。因此，我使用<strong class="jp ir">。blob() </strong>从响应中提取内容。如果您的回复是文本，您可以使用<strong class="jp ir">。text() </strong>，提取内容，同样如此。</p><p id="f7b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦从响应中提取出blob/text，您需要一个下载函数来完成操作。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="48bd" class="kx ky iq mk b gy mo mp l mq mr">downloadSignedFile(fileId).then(response =&gt; response.blob())</span><span id="66a3" class="kx ky iq mk b gy ms mp l mq mr">.then(blob =&gt; {</span><span id="9079" class="kx ky iq mk b gy ms mp l mq mr">downloadFile(blob, name)</span><span id="d9e3" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="87be" class="kx ky iq mk b gy ms mp l mq mr">.catch(error =&gt; console.log('error', error))</span></pre><p id="10df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">下载</strong></p><p id="d605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的下载功能听起来可能有点过时。主要是因为我们没有选择任何第三方库。我们试图在没有任何第三方库的帮助下实现下载。这意味着您可以使用这段代码，而不用担心EcmaScript的版本。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="8d81" class="kx ky iq mk b gy mo mp l mq mr">export const downloadFile = (blob, name="download") =&gt; {</span><span id="db23" class="kx ky iq mk b gy ms mp l mq mr">const url = window.URL.createObjectURL(blob)</span><span id="1460" class="kx ky iq mk b gy ms mp l mq mr">const a = document.createElement('a')</span><span id="7c37" class="kx ky iq mk b gy ms mp l mq mr">a.style.display = 'none'</span><span id="22ad" class="kx ky iq mk b gy ms mp l mq mr">a.href = url</span><span id="e893" class="kx ky iq mk b gy ms mp l mq mr">a.download = name+".pdf"</span><span id="535f" class="kx ky iq mk b gy ms mp l mq mr">document.body.appendChild(a)</span><span id="8dba" class="kx ky iq mk b gy ms mp l mq mr">a.click()</span><span id="5d6e" class="kx ky iq mk b gy ms mp l mq mr">window.URL.revokeObjectURL(url)</span><span id="17d1" class="kx ky iq mk b gy ms mp l mq mr">setTimeout(() =&gt; {window.close()}, 5000)</span><span id="b8ca" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="3f3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码接受<strong class="jp ir"> blob </strong>并将其作为pdf下载到客户端。</p><p id="889d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来不是很容易吗？我们可以循环运行上面的函数，一个接一个地下载任意多的文件。这里有一个如何完成循环的大纲。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="8744" class="kx ky iq mk b gy mo mp l mq mr">for(let file of selectedAttachments){</span><span id="9e35" class="kx ky iq mk b gy ms mp l mq mr">const fileId = file[id];<br/>const name = file[name];</span><span id="df60" class="kx ky iq mk b gy ms mp l mq mr">downloadSignedFile(fileId).then(response =&gt; response.blob())</span><span id="b474" class="kx ky iq mk b gy ms mp l mq mr">.then(blob =&gt; {</span><span id="7533" class="kx ky iq mk b gy ms mp l mq mr">downloadFile(blob, name)</span><span id="a1e8" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="d4aa" class="kx ky iq mk b gy ms mp l mq mr">.catch(error =&gt; console.log('error', error))</span><span id="567d" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="edd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码在selectedAttachments的数组上循环。它获取fileId，执行API调用，并最终下载文件。</p><h2 id="6c9f" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">用JavaScript下载多个文件</h2><p id="238c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在，我们希望下载多个文件并保存为<strong class="jp ir">。在客户端压缩</strong>文件。从积极的方面来说，这听起来像是一个用例，您正在努力实现它。因为，将&gt; 2个文件一个接一个地下载到客户的系统中是不成熟的(除非这是你的需求陈述)。</p><p id="3362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了下载多个文件，并将它们保存为zip文件，我们将使用两个有趣的库。</p><ol class=""><li id="cbdf" class="lq lr iq jp b jq jr ju jv jy mt kc mu kg mv kk lx ly lz ma bi translated">JSZip</li><li id="fb07" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">文件保存器</li></ol><p id="65c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装</strong></p><p id="d0f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你必须安装JSZip和FileSaver。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="5e73" class="kx ky iq mk b gy mo mp l mq mr">npm install jszip<br/>npm i file-saver@1.3.2</span></pre><p id="ac43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">API调用</strong></p><p id="4c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了支持多个文件的下载，我们必须修改API调用。为什么？在压缩和下载之前，我们必须等待所有的API调用完成。这将是整个行动中最棘手的部分。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="d239" class="kx ky iq mk b gy mo mp l mq mr">export const downloadSignedFiles = async (fileId) =&gt; {</span><span id="7e47" class="kx ky iq mk b gy ms mp l mq mr">return new <strong class="mk ir">Promise</strong>((resolve) =&gt; {</span><span id="2523" class="kx ky iq mk b gy ms mp l mq mr"><strong class="mk ir">fetch</strong>("https://getmyfile.com/"+fileId, requestOptions)</span><span id="bb24" class="kx ky iq mk b gy ms mp l mq mr">.then((response) =&gt; response.blob())</span><span id="ba6f" class="kx ky iq mk b gy ms mp l mq mr">.then((blob) =&gt; {</span><span id="10e4" class="kx ky iq mk b gy ms mp l mq mr"><strong class="mk ir">resolve</strong>(blob)</span><span id="6d10" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="c346" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="f8bb" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="4c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们利用了JavaScript中“承诺”这个有趣的概念。</p><p id="4d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据定义，<strong class="jp ir">承诺在执行下一行代码之前，</strong>可以用来等待所有的<strong class="jp ir">异步</strong>调用完成。它有两个属性:<strong class="jp ir">状态</strong>和<strong class="jp ir">结果。承诺仍然是热切的，为了行动的成功完成。它总是有一个操作没有完成的原因。或者说，为什么这次行动，成功地完成了。</strong></p><p id="e303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修改后的app调用返回一个<strong class="jp ir">承诺</strong>。一旦接收到blob响应，它就得到<strong class="jp ir">解析</strong>。然后，将承诺返回给调用方。</p><p id="9a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">响应</strong></p><p id="a7c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下载多个文件的逻辑中，响应被推送到一个数组中。这个数组将存储所有的承诺，这些承诺将包含要下载的blob。</p><p id="8a38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦所有的承诺都被接收并存储在<strong class="jp ir"><em class="mw">download requests</em></strong>中，我们必须在完成下载之前完成更多的步骤。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="9c7d" class="kx ky iq mk b gy mo mp l mq mr">const getAllBlobs = async (downloadArray = selectedAttachments) =&gt; {</span><span id="c5a9" class="kx ky iq mk b gy ms mp l mq mr">let <strong class="mk ir">downloadRequests </strong>= []<strong class="mk ir">;</strong></span><span id="31d6" class="kx ky iq mk b gy ms mp l mq mr">for(let file of downloadArray){</span><span id="2edf" class="kx ky iq mk b gy ms mp l mq mr">const fileId = file[id];</span><span id="45f4" class="kx ky iq mk b gy ms mp l mq mr">let name = file[name];</span><span id="5594" class="kx ky iq mk b gy ms mp l mq mr">downloadRequests.push({name:name, blob:downloadSignedFiles(fileId)})</span><span id="3c8f" class="kx ky iq mk b gy ms mp l mq mr">}</span><span id="ddea" class="kx ky iq mk b gy ms mp l mq mr">return <strong class="mk ir">downloadRequests</strong></span><span id="a48c" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="5c3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">下载</strong></p><p id="2146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要完成下载。为此，我们必须处理存储在downloadRequest数组中的所有承诺。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="7c12" class="kx ky iq mk b gy mo mp l mq mr">const <strong class="mk ir">getMegatronZip</strong> = async (downloadArray) =&gt; {</span><span id="eec1" class="kx ky iq mk b gy ms mp l mq mr">var zip = new <strong class="mk ir">JSZip</strong>();</span><span id="67ee" class="kx ky iq mk b gy ms mp l mq mr">var <strong class="mk ir">folder</strong> = zip.<strong class="mk ir">folder</strong>("download");</span><span id="daad" class="kx ky iq mk b gy ms mp l mq mr">let downloadRequests = <strong class="mk ir">getAllBlobs</strong>(downloadArray);</span><span id="adba" class="kx ky iq mk b gy ms mp l mq mr"><strong class="mk ir">Promise</strong>.<strong class="mk ir">all</strong>(downloadRequests).then((response) =&gt; {</span><span id="ac42" class="kx ky iq mk b gy ms mp l mq mr">response.forEach((item) =&gt; {</span><span id="caeb" class="kx ky iq mk b gy ms mp l mq mr"><strong class="mk ir">folder</strong>.<strong class="mk ir">file</strong>(item.name, item.blob);</span><span id="6320" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="5193" class="kx ky iq mk b gy ms mp l mq mr">})</span><span id="f8dc" class="kx ky iq mk b gy ms mp l mq mr">return zip;</span><span id="4e3b" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="62de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Promise.all 的作用是接受一组承诺，处理它们，并返回一个承诺。最终的承诺将是一个数组，其中包含它处理的每个承诺的结果。如果任何一个承诺被拒绝，Promise.all将拒绝整个操作。</p><p id="eca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，downloadRequests中的每个承诺都有下载的blob。因此，如果您选择三个文件，将有三个已解决的承诺，有三个blobs。我们现在要做的是将blob存储在一个文件中，在zip文件夹中。这是第一步，我们为所有要下载的文件创建一个zip文件。并且，我们使用<strong class="jp ir"> JSZip </strong>，来实现这一点。</p><p id="84d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名开发人员，我坚信不要重新发明轮子。当然，您可以编写自己的库来创建zip，但是，为什么要这样做呢？当您已经有了JSZip来做必要的事情时。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="57cf" class="kx ky iq mk b gy mo mp l mq mr"><strong class="mk ir">import { saveAs } from 'file-saver';</strong></span><span id="04c0" class="kx ky iq mk b gy ms mp l mq mr">const downloadAll = async () =&gt; {</span><span id="4e5f" class="kx ky iq mk b gy ms mp l mq mr">let megatronBlob = await <strong class="mk ir">getMegatronZip</strong>();</span><span id="9fd0" class="kx ky iq mk b gy ms mp l mq mr">megatronBlob.<strong class="mk ir">generateAsync</strong>({type:"blob"})</span><span id="4e2e" class="kx ky iq mk b gy ms mp l mq mr">.then(function(content) {</span><span id="d2ef" class="kx ky iq mk b gy ms mp l mq mr"><strong class="mk ir">saveAs</strong>(content, "download.zip");</span><span id="2346" class="kx ky iq mk b gy ms mp l mq mr">});</span><span id="6ef3" class="kx ky iq mk b gy ms mp l mq mr">}</span></pre><p id="18a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们利用<strong class="jp ir">文件保护程序</strong>，在系统中保存zip文件。请记住，您也可以使用同一个库在客户端保存单个文件。不过，我们正在尝试所有可能的实现方式，<strong class="jp ir">用JavaScript下载。我想让你试试，如何使用文件保护程序下载一个文件，并在这篇文章中分享你的评论。</strong></p><p id="9259" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">generatesync</strong>，是JSZip中的一个函数，创建所需的Zip文件。</p><p id="0c05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> saveAs </strong>，是一个函数，使用来自JSZip的Zip内容，并将zip保存在客户端。</p><h1 id="98f0" class="mx ky iq bd kz my mz na lc nb nc nd lf ne nf ng li nh ni nj ll nk nl nm lo nn bi translated">下载愉快！</h1><p id="7efe" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">现在，我们已经学习了两种下载文件到客户端的方法。您可以下载单个文件，或压缩多个文件并保存。上述功能可以在任何React、普通JS或Angular项目中实现，没有任何麻烦或争论。</p><p id="f0e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">如果你喜欢这个帖子，请关注并分享，继续学习！</em></p><p id="9e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mw">更多内容尽在</em><a class="ae no" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>