<html>
<head>
<title>Big O Performance of Arrays and Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中数组和对象的高性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/performance-of-arrays-and-objects-in-javascript-through-the-lens-of-big-o-5a7c5891a43f?source=collection_archive---------3-----------------------#2021-04-15">https://javascript.plainenglish.io/performance-of-arrays-and-objects-in-javascript-through-the-lens-of-big-o-5a7c5891a43f?source=collection_archive---------3-----------------------#2021-04-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9b5b2f107db53aea8f45d61554578429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QEzIcNmQqphqXi91"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Performance</figcaption></figure><p id="a263" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们处理大量数据来执行搜索、排序、访问、插入和删除元素等操作时，程序的效率将直接依赖于<strong class="kb io">时间复杂度</strong>。</p><p id="235c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以根据增强性能的需要有选择地使用对象和数组。我们借助Big-O符号来比较和对比数组和对象的运行时，以便清楚地理解它们。</p><p id="95d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们从时间复杂性的角度快速理解Big-O符号的概念。</p><p id="b74a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Big-0符号有助于正式计算算法的效率。</p><p id="92c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了比较算法，我们不应该考虑:</p><ul class=""><li id="e272" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><strong class="kb io">执行时间</strong>——因为它们是特定于特定计算机的。</li><li id="020a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">执行的语句数量</strong> —因编程语言而异。</li></ul><p id="55d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ll">比较算法的理想方式是根据输入的大小计算计算机必须执行的运算次数。</em></p><p id="6c82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们看一个简单的例子。计算从1到某个数字<em class="ll"> n </em>的所有数字的和。</p><p id="b134" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">低效解决方案:</strong></p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/9d747101c7e8989e7c7b8c71526979bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqlIjwUmZfDjpS740x_Ktw.jpeg"/></div></div></figure><p id="02f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，操作的数量随着输入(n)大小的增加而增加。</p><p id="d24a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">高效解决方案:</strong></p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/5c9a2ad4452c7a0a26a0c74f9f9e2d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*7i19siMbEXwILe8vEpaoEw.jpeg"/></div></figure><p id="23cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，无论输入大小如何，操作的数量保持不变。</p><p id="f554" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们可以这样定义Big-0符号:随着<strong class="kb io"> n </strong>的增加，如果计算机必须做的简单运算的数量最终小于一个常数乘以<strong class="kb io"> f(n) </strong>，则算法为<strong class="kb io">O(f(n)】</strong>。</p><p id="fa42" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">f(n)可以是线性的(f(n) = n)。</p><pre class="ln lo lp lq gt ls lt lu lv aw lw bi"><span id="6c5a" class="lx ly in lt b gy lz ma l mb mc">function addUpTo(n) {<br/>let total = 0;<br/>for (let i = 1; i &lt;= n; i++) {  // O(n)<br/> total += i;<br/>}<br/>return total;<br/>}</span></pre><p id="514d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">f(n)可以是常数(f(n) = 1)。</p><pre class="ln lo lp lq gt ls lt lu lv aw lw bi"><span id="df5d" class="lx ly in lt b gy lz ma l mb mc">function addUpTo(n) {<br/>return n * (n + 1) / 2; // O(1)<br/>}</span></pre><p id="8a1c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">f(n)可以是二次的(f(n) = n)。参见下面的例子。这里，当输入大小增加时，操作的数量将二次增加，就像循环<strong class="kb io"> O(n) </strong>中的循环<strong class="kb io"> 0(n) </strong>一样。O(f(n)) * O(f(n)) = O(f(n))</p><pre class="ln lo lp lq gt ls lt lu lv aw lw bi"><span id="d8a1" class="lx ly in lt b gy lz ma l mb mc">function printAllPairs(n) {<br/> for (var i = 0; i &lt; n; i++) {  // O(n)<br/>  for (var j = 0; j &lt; n; j++) { // O(n)*O(n)<br/>  console.log(i, j);<br/>  }<br/> }<br/>}</span></pre><p id="8bf9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们通过Big-O的镜头来理解对象和数组是如何工作的。</p><p id="9b25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们需要快速访问、插入和移除元素时，将使用对象，因为在插入和移除元素时，对象比数组快得多。</p><p id="025f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">物体的大O:</p><ul class=""><li id="8ad5" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">插入— <strong class="kb io"> O(1) </strong></li><li id="ef6d" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">移除— <strong class="kb io"> O(1) </strong></li><li id="77cb" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">访问— <strong class="kb io"> O(1) </strong></li><li id="893f" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">正在搜索— <strong class="kb io"> O(n) </strong></li></ul><p id="7b3c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对象方法的大O:</p><ul class=""><li id="ee86" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">Object.keys — <strong class="kb io"> O(n) </strong></li><li id="0bd7" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">Object.values — <strong class="kb io"> O(n) </strong></li><li id="ca7e" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">Object.entries — <strong class="kb io"> O(n) </strong></li><li id="8e19" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">hasOwnProperty — <strong class="kb io"> O(1) </strong></li></ul><p id="eb19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们需要订单时，就会用到数组。但是使用数组的代价很高，因为在开始插入元素和移除元素并不容易，因为索引必须为整个数组重置。假设一个数组的大小是1000，那么在开始插入后需要做1000次操作来重置索引。有更有效的数据结构和算法。</p><p id="e996" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大规模阵列:</p><ul class=""><li id="f997" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">插入——视情况而定。最后插入的是<strong class="kb io"> O(1) </strong>。但是开头插入的是<strong class="kb io"> o(n) </strong></li><li id="51b5" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">移除——视情况而定。结尾的移除是<strong class="kb io"> O(1) </strong>。但在中间或开始时是<strong class="kb io"> o(n) </strong></li><li id="1db0" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">访问— <strong class="kb io"> O(1) </strong></li><li id="47f0" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">搜索— <strong class="kb io"> O(n) </strong></li></ul><p id="b666" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">数组方法的大O:</p><ul class=""><li id="5f3d" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">push，pop — <strong class="kb io"> O(1) </strong></li><li id="51d7" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">移位、取消移位、拼接、切片、拼接— <strong class="kb io"> O(n) </strong></li><li id="3e66" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">forEach/map/filter/reduce/etc。— <strong class="kb io"> O(n) </strong></li></ul><p id="c3ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们用一个简单的例子来理解它。编写一个接受两个数组的函数，如果数组中的每个值在第二个数组中都有对应的平方值，则返回true。值的频率必须相同。<br/> <em class="ll"> frequency_function([1，2，3]，[4，1，9])</em><em class="ll">//返回真</em><br/><em class="ll">frequency _ function([1，2，3]，[1，9])//返回假</em></p><p id="a8d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是基于阵列的方法。</p><pre class="ln lo lp lq gt ls lt lu lv aw lw bi"><span id="e27f" class="lx ly in lt b gy lz ma l mb mc">function frequency_function(arr1, arr2){  <br/>   <br/> if(arr1.length !== arr2.length) return false;</span><span id="e56a" class="lx ly in lt b gy md ma l mb mc"> for(let i = 0; i &lt; arr1.length; i++){         <br/>  let correctIndex = arr2.indexOf(arr1[i] ** 2)    <br/>  if(correctIndex === -1) {             <br/>   return false;         <br/>  }         <br/>  arr2.splice(correctIndex,1)      <br/> }     <br/> return true;<br/>}</span></pre><p id="08cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里<strong class="kb io"> O(f(n))是n </strong>因为在循环<strong class="kb io"> (O(n)) </strong>中<strong class="kb io"> </strong>方法的索引是<strong class="kb io"> O(n) </strong>，因为它将从头开始搜索，拼接方法也是<strong class="kb io"> O(n) </strong>，因为它必须重置索引。也就是说，对于arr1 <strong class="kb io">中的每个元素，必须对arr2进行n </strong>次操作。如果数组大小为100，那么将执行100*100*100次操作，等于1000000次操作。所以这里当<strong class="kb io"> n </strong>增加时，操作次数<strong class="kb io">二次增加</strong>。</p><p id="ce68" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">下面是基于对象的方法:</strong></p><pre class="ln lo lp lq gt ls lt lu lv aw lw bi"><span id="a7bc" class="lx ly in lt b gy lz ma l mb mc">function same(arr1, arr2){     <br/> if(arr1.length !== arr2.length){         <br/>  return false;     <br/> }     <br/> let frequencyCounter1 = {}     <br/> let frequencyCounter2 = {}     <br/> for(let val of arr1){         <br/>  frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1     <br/> }     <br/> for(let val of arr2){         <br/>  frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1   <br/> }<br/> for(let key in frequencyCounter1){         <br/> if(!(key ** 2 in frequencyCounter2)){             <br/>   return false         <br/> }          <br/> if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){  <br/>   return false<br/>  }     <br/> }      <br/> return true;<br/>}</span></pre><p id="193b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里我们将两个数组转换成两个对象，然后检查相应的平方值。我们有三个独立的操作。也就是说，如果输入数组的大小是100，那么100+100+100等于300次操作将被执行。所以这里当<strong class="kb io"> n </strong>增加时，操作数<strong class="kb io">线性增加</strong>。</p><h2 id="ba59" class="lx ly in bd me mf mg dn mh mi mj dp mk kk ml mm mn ko mo mp mq ks mr ms mt mu bi translated">结论</h2><p id="e2a1" class="pw-post-body-paragraph jz ka in kb b kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw ig bi translated">所以你可以看到，当我们不需要命令时，工作对象比数组要快得多。</p><p id="3090" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望你已经发现这是有用的。如果有，请务必在评论中让我知道。编码快乐！</p><p id="3d98" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ll">更多内容看</em><a class="ae na" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ll">plain English . io</em></strong></a></p></div></div>    
</body>
</html>