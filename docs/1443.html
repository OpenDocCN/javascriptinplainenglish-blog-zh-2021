<html>
<head>
<title>Publish a Scoped Package to NPM using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript将限定范围的包发布到NPM</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/publish-a-scoped-package-to-npm-using-typescript-b36f2f7475c9?source=collection_archive---------9-----------------------#2021-03-27">https://javascript.plainenglish.io/publish-a-scoped-package-to-npm-using-typescript-b36f2f7475c9?source=collection_archive---------9-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/db1f8d8a4c94e403fcee5364d3123fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ1FTZoboVGSi9x_YcgRqg.png"/></div></div></figure><p id="f29c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我是npm注册表的忠实粉丝。对于许多开发者来说，尤其是那些来自训练营的开发者，被介绍到Node和NPM是一个关键时刻。</p><p id="f92c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如何使用Node.js和TypeScript向NPM添加一个<em class="kt">范围的包</em>。</p><h2 id="78d7" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">这个计划</h2><p id="3193" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这里的想法是能够在您的npm用户名范围内安装和使用我们自己的npm包。例如<code class="fe ls lt lu lv b">npm install @user/package</code></p><p id="8dc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以很容易地配置一个现有的项目。然而，如果这对你来说是新的，为了熟悉起见，在一个干净的目录中测试这个概念可能会更有好处。</p><h1 id="b1fb" class="lw kv in bd kw lx ly lz kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm bi translated">设置新项目</h1><p id="f0af" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">首先，我们可以创建一个新目录，并使用TypeScript作为依赖项初始化节点。我们给这个文件夹起的名字也将是我们发布包的名字。参见<a class="ae mn" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#name" rel="noopener ugc nofollow" target="_blank">官方文件</a>了解命名约定的最佳实践。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="80f6" class="ku kv in lv b gy mw mx l my mz">mkdir once &amp;&amp; cd once<br/>npm init -y &amp;&amp; npm i typescript <br/>npm i @types/node -D</span></pre><p id="a6f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们使用Git，我们也应该马上忽略<code class="fe ls lt lu lv b">node_modules</code>目录。</p><p id="c7d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">另请注意，</em> <code class="fe ls lt lu lv b"><em class="kt">.gitignore</em></code> <em class="kt">文件中被忽略的任何内容在npm部署中也会被自动忽略。为了覆盖这种行为，我们可以创建一个空的</em> <code class="fe ls lt lu lv b"><em class="kt">.npmignore</em></code> <em class="kt">文件。</em></p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="ca81" class="ku kv in lv b gy mw mx l my mz">touch .gitignore &amp;&amp; echo "node_modules" &gt;&gt; .gitignore</span></pre><h1 id="be75" class="lw kv in bd kw lx ly lz kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm bi translated">配置TypeScript</h1><p id="afef" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">在最后一步中，我们安装了TypeScript作为项目的依赖项。让我们配置这种依赖性，以更好地满足我们的需求。</p><p id="3581" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在根目录下创建一个名为<strong class="jx io"> tsconfig.json </strong>的新文件，内容如下:</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">TypeScript configs</figcaption></figure><p id="d2ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们在<strong class="jx io"> tsconfig.json </strong>文件中所写内容的大致要点。</p><ul class=""><li id="f096" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"outDir": “dist"</code> —发射<strong class="jx io">。js </strong>、<strong class="jx io"> .d.ts </strong>和<strong class="jx io"> .js.map </strong>文件到这个目录</li><li id="f6d5" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"noImplicitAny": true</code> —发出不存在类型注释的错误</li><li id="16b3" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"module": "CommonJS"</code> —设置程序的模块系统</li><li id="fb6d" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"target": "es6"</code> —现代浏览器支持</li><li id="d976" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"allowJs": true</code> —允许<strong class="jx io">。目录中的js </strong>文件</li><li id="9834" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"declaration": true</code> —生成<strong class="jx io"> d.ts </strong>文件</li><li id="1e75" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"sourceMap": true</code> —生成源地图文件</li><li id="6b6c" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"strict": true</code> —实施更强的类型检查行为</li><li id="3f97" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"esModuleInterop": true</code> —解决es6相关问题</li><li id="6524" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">"moduleResolution": "node"</code> —指定模块解析策略</li></ul></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><h1 id="471f" class="lw kv in bd kw lx ob lz kz ma oc mc lc md od mf lf mg oe mi li mj of ml ll mm bi translated">创建模块</h1><p id="a02f" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">一旦我们获得了TypeScript的配置设置，我们就可以开始编写代码了！让我们创建我们在<strong class="jx io"> tsconfig.json </strong>文件中指定的<code class="fe ls lt lu lv b">src</code>目录。在这样做的同时，让我们也向这个目录添加一个新的typescript文件。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="67e3" class="ku kv in lv b gy mw mx l my mz">mkdir src<br/>touch ./src/index.ts</span></pre><p id="ba01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Npm依赖关系可以通过模块访问，模块是基本级别的可重用功能。这是您将实现代码库的地方，稍后将在npm注册表中编译和访问该代码库。我将创建一个只执行一次的函数，但是不要觉得有义务使用我的代码。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Creating the Module</figcaption></figure><p id="6742" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至此我们已经准备好编译了！从终端，我们可以运行命令<code class="fe ls lt lu lv b">npx tsc</code>，我们应该看到一个新的子目录出现标题为<strong class="jx io">。/dist </strong>。这个目录将包含我们可以在Node中实际执行的代码的内容。</p><p id="c463" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们花点时间将这个命令作为脚本添加到我们的<strong class="jx io"> package.json </strong>中。我更喜欢去掉<strong class="jx io">。/dist </strong>目录，以消除任何重叠的可能性。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Adding a “build” script to the package.json</figcaption></figure></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><h2 id="84b5" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">用Jest测试模块</h2><p id="55a1" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">此时，我们应该确认我们的代码按预期工作。毕竟如果现在不行，部署的时候很可能也不行。让我们安装我们需要的Jest。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="504e" class="ku kv in lv b gy mw mx l my mz">npm i jest @types/jest ts-jest -D <br/>touch jest.config.js</span></pre><p id="1fb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要创建另一个配置文件来解释Jest，我们可以把这个文件叫做<strong class="jx io"> jest.config.js </strong></p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">jest.config.js</figcaption></figure><p id="4dd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要牵扯进来。让我们快速浏览一遍。记住，配置文件的存在是有原因的。即使它们看起来令人生畏，理解我们告诉代码做什么也是很重要的。</p><ul class=""><li id="f63d" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">transform: { '^.+\\.ts?$': 'ts-jest' }</code> —这里我们使用ts-jest包来允许jest测试用TypeScript编写的文件。</li><li id="811e" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">testEnvironment: 'node'</code> —指定用于测试的环境。</li><li id="b108" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">testRegex: '/test/.*\\.(test|spec)?\\.(ts|tsx|js)$'</code> —用于检测测试文件的模式。</li><li id="53ee" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated"><code class="fe ls lt lu lv b">moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node']</code> —使用的文件扩展名数组。</li></ul></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><p id="b7fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了，现在我们对相关的配置有了更好的理解，让我们为之前创建的模块创建一个新的测试套件。首先，我们需要根据我们在<strong class="jx io"> jest.config.js </strong>文件中指定的搜索模式创建测试文件。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="41bc" class="ku kv in lv b gy mw mx l my mz">mkdir test &amp;&amp; touch test/index.test.js</span></pre><p id="b611" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在做你自己的项目，那么就相应地测试你的模块。如果你正在跟随我和我的execute once函数，我们将想要在同一个声明上运行2个测试来验证我们实际上只执行了一次。在类似这样的代码中</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Test suite for module</figcaption></figure><p id="59ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们应该能够在本地测试我们的模块。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="e4d4" class="ku kv in lv b gy mw mx l my mz">npx jest</span></pre><p id="7120" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了，我已经通过了两项测试。我希望你也一样，如果你的测试没有通过，我会鼓励你现在花时间调试这个错误。同样，如果代码不能在本地工作，我们也不能期望构建能够工作。</p><p id="c7b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还应该利用这个机会更新<strong class="jx io"> package.json </strong>中的<code class="fe ls lt lu lv b">"test"</code>脚本。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Updating test script in package.json</figcaption></figure><p id="4061" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从现在开始，我们可以通过简写的<code class="fe ls lt lu lv b">npm t</code>或<code class="fe ls lt lu lv b">npm run test</code>来访问我们刚刚运行的<code class="fe ls lt lu lv b">jest</code>命令，这被视为团队间合作的通用命令。</p><h1 id="65eb" class="lw kv in bd kw lx ly lz kz ma mb mc lc md me mf lf mg mh mi li mj mk ml ll mm bi translated">发布到国家预防机制</h1><p id="365a" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">我们期待已久的时刻到了！让我们更新<strong class="jx io"> package.json </strong>中的<code class="fe ls lt lu lv b">"main"</code>入口点，指向我们编译的代码。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Updating the “main” script of the package.json</figcaption></figure><p id="bbb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们应该能够在本地测试这个包。但是在此之前，让我们将这个项目配置为“用户范围的”。我们可以在最初创建项目时就这样做。但是为了保持有组织性，我们将把整个过程组合在一起。</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="8695" class="ku kv in lv b gy mw mx l my mz">npm init --scope=@npm-username -y</span></pre><p id="c069" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">如果这是您第一次登录npm注册表，您需要在</em><a class="ae mn" href="https://npmjs.com" rel="noopener ugc nofollow" target="_blank"><em class="kt">npmjs.com</em></a><em class="kt">创建一个帐户，并使用</em> <code class="fe ls lt lu lv b"><em class="kt">npm login</em></code> <em class="kt">终端命令登录npm。</em></p><p id="6e04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这个命令成功，我们应该在<strong class="jx io"> package.json的<code class="fe ls lt lu lv b">"name"</code>字段中看到我们的npm用户名。</strong>这是我们在一个作用域包下的确认。</p><h2 id="c730" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">在本地测试用户范围的包</strong></h2><p id="a221" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">在这一点上，我们几乎准备好部署，但在此之前，我们可能应该在本地测试这个包，以确保一切按预期工作。为此，我们需要获得该目录的绝对文件路径。</p><p id="81fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过<code class="fe ls lt lu lv b">pwd</code>终端命令访问这个目录的绝对路径。然后我们可以使用<code class="fe ls lt lu lv b">npm install /absolute/path/to/folder</code>运行npm包的本地安装</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="bed4" class="ku kv in lv b gy mw mx l my mz">pwd<br/>mkdir ../test-scoped-package &amp;&amp; cd ../test-scoped-package<br/>touch index.js<br/>npm init -y &amp;&amp; npm install /absolute/path/to/scoped-repo</span></pre><p id="4bfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">参考上面的命令，我使用<code class="fe ls lt lu lv b">pwd</code>来收集当前工作目录的绝对路径。<em class="kt">然后我们使用</em> <code class="fe ls lt lu lv b"><em class="kt">mkdir</em></code> <em class="kt">命令创建一个全新的存储库，仅用于测试目的</em>，从那里我们创建一个index.js文件并安装包！</p><p id="ad5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的工作目录现在应该如下所示</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">npm package &amp; local test repo</figcaption></figure><p id="12c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们向npm发布我们的代码时，这就是我们将访问的内容。在我的例子中，它看起来像这样，但是这个包的范围应该在你的用户范围之下，而不是<code class="fe ls lt lu lv b">@hi-matbub</code>👍</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Testing the package in the testing-scoped-package directory</figcaption></figure><p id="ce59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为优秀的开发人员，我们也可以使用这段代码作为README文件的预览。让我们在这里也处理一下基本问题。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Creating a readme for the package</figcaption></figure><p id="10bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们已准备好发布到npm注册表。让我们添加一个预防性脚本，它将在我们发布之前执行，以确保我们的代码符合质量标准。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Adding “prepack” script</figcaption></figure><p id="915d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们发布到npm时，<code class="fe ls lt lu lv b">"prepack"</code>脚本将自动执行。如果这里有任何失败，这个包将不会发布。在这一点上，我们准备发布！</p><pre class="mo mp mq mr gt ms lv mt mu aw mv bi"><span id="f8e3" class="ku kv in lv b gy mw mx l my mz">npm publish --access public</span></pre><h2 id="8650" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">结论</h2><p id="47dd" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">祝贺您，您刚刚在npm注册表上发布了您的第一个用户范围的包。庆祝的时间到了！</p><p id="e139" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我真的希望这是有见地的。如果你想查看这个项目的源代码，你可以在npm注册中心的<a class="ae mn" href="https://www.npmjs.com/package/@hi-matbub/once" rel="noopener ugc nofollow" target="_blank"> @hi-matbub/once </a>找到它。</p><p id="5009" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">祝你愉快👋</p></div></div>    
</body>
</html>