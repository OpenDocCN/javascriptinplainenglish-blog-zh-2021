<html>
<head>
<title>Exploring React 18, The Alpha Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索React 18，Alpha版本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-react-18-the-alpha-version-7a8bb8260fbd?source=collection_archive---------16-----------------------#2021-07-12">https://javascript.plainenglish.io/exploring-react-18-the-alpha-version-7a8bb8260fbd?source=collection_archive---------16-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53dad57f639dd30194c201b53aa5fd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs3ZE1Q1_yiJOpBlsilnCQ.png"/></div></div></figure><p id="33ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React核心团队已经公布了React 18 alpha版本。稳定版的发布还有几个月的时间。该团队已经邀请社区成员加入GitHub讨论工作组(WG ),以获得下一个主要版本的第一感觉。</p><p id="cf26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于React爱好者来说，这是一个令人高兴的消息，当有许多功能推出时，这一消息更令人高兴。对于那些一直关注React v17的人来说，React v 17没有为开发人员带来新的特性，但是进行了内部改进，提高了库的效率。</p><h2 id="80c5" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">新的改进和并发模式</h2><p id="c3cb" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">显然，React 18附带了新功能，但请注意，这些功能目前正在开发中，目前并不打算供开发人员在生产应用中使用，而是在遵循工作组讨论的同时进行实验。测试版仍然需要几个月才能发布。但是，在为稳定版本做准备时，熟悉一下新特性是有好处的。</p><p id="d34e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React 18带有“并发功能”，基本上启用了一种选择加入机制，允许开发人员升级到React 18，而不中断他们的应用程序。当前版本设计为运行不同版本的React。这是通过在多个版本中多次呈现UI来实现的。</p><h2 id="2cbd" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">升级到React v18</h2><p id="9450" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">安装(或升级)React 18是显而易见的。我试图将我正在开发的两个现有的React应用程序升级到React 18。结果是17.0.2版本能够升级到React 18，而16.14.0版本没有成功。它一直抛出:<em class="lu">错误:无法在未安装的组件</em>上找到节点</p><p id="205e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于某种原因(我仍在研究)，我无法升级到与我们心爱的NPM反应18。在尝试升级React 16和17应用程序时出现了一周的错误。无法在GitHub上评论工作组的讨论来强调这一差距，因为我不是被选中的人之一(lol)。工作组讨论仅限受邀者参加。</p><p id="e8ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，yarn完成了这项工作。我们简单地添加了React和ReactDom 18个alpha版本。如果你想开始一个新项目。很简单。` ` yarn create react-app app-18 ```。它将创建React v17.0.2应用程序。然后用yarn add运行升级。对于现有的应用程序，只需运行命令。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="992b" class="kw kx iq ma b gy me mf l mg mh">yarn add react@alpha react-dom@alpha</span></pre><p id="b73d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新建根API</p><p id="2545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照上述步骤，您的应用程序将会启动，但如果您在浏览器开发工具上检查您的应用程序，则会发出如下警告。</p><p id="eafb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lu"> index.js:1警告:React 18中不再支持ReactDOM.render。请改用createRoot。在你切换到新的API之前，你的应用会表现得像运行React 17一样。了解更多:</em><a class="ae mi" href="https://reactjs.org/link/switch-to-createroot" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a></p><p id="e0f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们继续将应用程序的顶层更新为:</p><p id="7d98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老路:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6ac1" class="kw kx iq ma b gy me mf l mg mh">`import React from ‘react’;<br/>import ReactDOM from ‘react-dom’;<br/>import App from ‘./App’;</span><span id="b4a9" class="kw kx iq ma b gy mj mf l mg mh">ReactDOM.render(&lt;App /&gt;, document.getElementById(‘root’));&lt;/code&gt;</span></pre><p id="e58e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新方法:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="731f" class="kw kx iq ma b gy me mf l mg mh"> import React from ‘react’;<br/>import ReactDOM from ‘react-dom’;<br/>import App from ‘./App’;</span><span id="ceeb" class="kw kx iq ma b gy mj mf l mg mh">const root = ReactDOM.createRoot(document.getElementById(‘root’));<br/>root.render(<br/>&lt;App /&gt; );&lt;/code&gt;</span></pre><blockquote class="mk ml mm"><p id="c8b6" class="jy jz lu ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">与旧方法不同的是，呈现从根开始，而不是从React DOM呈现。这一变化对ReactDOM.hydrate有影响，它用于SSR以加快页面加载和SEO优化。正如React核心团队所解释的，ReactDOM上有一个新的hydrateRoot API。它不需要单独的渲染调用。我们可以看到它接受了第二个论点，即JSX。</p></blockquote><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5bc8" class="kw kx iq ma b gy me mf l mg mh">const root = ReactDOM.hydrateRoot(document.getElementById(“root”), &lt;App /&gt;);</span></pre><p id="c23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以在根组件中添加渲染回调函数。这些是新的根API中的一些变化。现在，我们在探索React 18附带的新功能方面处于领先地位。</p><p id="f1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React 18的顶级功能包括开箱即用的改进，如自动批处理、startTransition API、内置React Lazy支持的SSR。</p><h2 id="67f2" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">较少渲染的自动批处理</h2><p id="83cf" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">前端开发人员知道，我们处理的一个主要问题是屏幕为用户更新了多少次。渲染越少，用户体验越好。以前的自动批处理是手动完成的，但在这个版本中，它是默认完成的，以提供内置的改进。批处理基本上是将我们的更新组合成一个单独的重新渲染。</p><h2 id="1288" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">startTransition API</h2><p id="6f35" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">是一个令人兴奋的特性，它支持开发流畅且响应迅速的UI。它使我们能够包装非紧急更新，这样当我们在UI上执行其他操作时，我们可以向用户显示更紧急的更新。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="51eb" class="kw kx iq ma b gy me mf l mg mh"> import { startTransition } from ‘react’;</span><span id="c5e0" class="kw kx iq ma b gy mj mf l mg mh">// Urgent: Show what was typed<br/>setInputValue(input);</span><span id="8f6e" class="kw kx iq ma b gy mj mf l mg mh">// Mark any state updates inside as transitions</span><span id="f5cd" class="kw kx iq ma b gy mj mf l mg mh">startTransition(() =&gt; {<br/>// Transition: Show the results<br/>setSearchQuery(input);<br/>}); &lt;/code&gt;</span></pre><p id="8ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有其他功能，如<em class="lu"> useDeferredValue </em>让我们推迟更新屏幕上不太重要的部分，<em class="lu">&lt;suspendelist&gt;</em>让我们协调加载指示器出现的顺序，以及带有选择性水合的SSR。</p><p id="9c5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些特性在工作组关于GitHub的讨论中都有很好的概述。在我们等待稳定版本的时候，请注意，在React 18的第一个稳定版本发布之前，这些功能可能会进行调整以适应社区的意见。</p><p id="5dfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lu">更多内容尽在</em><a class="ae mi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="lu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>