<html>
<head>
<title>Replacing Lifecycle methods with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React挂钩替换生命周期方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replacing-lifecycle-methods-with-react-hooks-3dc293d2e73a?source=collection_archive---------22-----------------------#2021-01-04">https://javascript.plainenglish.io/replacing-lifecycle-methods-with-react-hooks-3dc293d2e73a?source=collection_archive---------22-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5737998aec90286e818f627dd22f7201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MNLeQ6fgZQw9KugS.png"/></div></div></figure><h2 id="2aad" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">什么是React钩子？</strong></h2><blockquote class="kr ks kt"><p id="61c7" class="ku kv kw kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">“钩子是React 16.8中的新特性。它们让你不用写类就能使用状态和其他React特性。”—反应文档</p></blockquote><p id="db81" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">非常简单的定义。但是为什么我们不想在React中使用类呢？许多开发人员感兴趣的最大原因之一是关键字<code class="fe lt lu lv lw b">this</code>的用法。围绕着<code class="fe lt lu lv lw b">this</code>的东西太多了，与其他OOP语言相比，很难完全理解它是如何工作的。</p><h2 id="0606" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">组件生命周期</strong></h2><p id="59c6" class="pw-post-body-paragraph ku kv in kx b ky lx la lb lc ly le lf ke lz li lj ki ma lm ln km mb lq lr ls ig bi translated">我们将看看<code class="fe lt lu lv lw b">componentDidMount()</code>、<code class="fe lt lu lv lw b">componentDidUpdate()</code>和<code class="fe lt lu lv lw b">componentWillUnmount()</code>。在React 17中，所有其他生命周期方法都将被弃用。</p><p id="f8e9" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">下图显示了生命周期方法及其使用方式。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/5a8a01513a2a9a286f48d9588c35855d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uw79TFPHnBvyFvnI.png"/></div></div></figure><p id="5a0e" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">有一点需要注意，你<strong class="kx io"> <em class="kw">不能</em> </strong>在类组件内部使用钩子。</p><p id="8326" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">让我们来看看在类组件中使用这些方法与在带有react钩子的功能组件中使用这些方法的区别。</p><h1 id="892f" class="mh jw in bd jx mi mj mk ka ml mm mn kd mo mp mq kh mr ms mt kl mu mv mw kp mx bi translated"><code class="fe lt lu lv lw b">componentDidMount()</code></h1><p id="e561" class="pw-post-body-paragraph ku kv in kx b ky lx la lb lc ly le lf ke lz li lj ki ma lm ln km mb lq lr ls ig bi translated"><em class="kw">类组件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7294" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated"><em class="kw">带挂钩的功能部件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="07ba" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">请注意功能组件中的空数组。这通知<code class="fe lt lu lv lw b">useEffect</code>我们只需要运行一次。当组件完成安装阶段时。</p><h1 id="6dd7" class="mh jw in bd jx mi mj mk ka ml mm mn kd mo mp mq kh mr ms mt kl mu mv mw kp mx bi translated">componentDidUpdate()</h1><p id="5944" class="pw-post-body-paragraph ku kv in kx b ky lx la lb lc ly le lf ke lz li lj ki ma lm ln km mb lq lr ls ig bi translated"><em class="kw">类组件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="57ff" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated"><em class="kw">带挂钩的功能部件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2f57" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">这看起来与<code class="fe lt lu lv lw b">componentDidMount</code>挂钩非常相似，不是吗？有一个小小的改变改变了行为。这并没有给<code class="fe lt lu lv lw b">useEffect</code>第二个论点。这将在每次重新渲染时触发<code class="fe lt lu lv lw b">useEffect</code>。</p><p id="ce96" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">如果我们想在特定属性发生变化时调用钩子怎么办？很简单，我们传递第二个参数，<code class="fe lt lu lv lw b">[]</code>并传递一个值，即属性。<code class="fe lt lu lv lw b">[someProperty]</code>每当<code class="fe lt lu lv lw b">someProperty</code>改变时，挂钩将触发并更新。</p><h1 id="c431" class="mh jw in bd jx mi mj mk ka ml mm mn kd mo mp mq kh mr ms mt kl mu mv mw kp mx bi translated">componentWillUnmount()</h1><p id="42c1" class="pw-post-body-paragraph ku kv in kx b ky lx la lb lc ly le lf ke lz li lj ki ma lm ln km mb lq lr ls ig bi translated"><em class="kw">类组件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b2a7" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated"><em class="kw">带挂钩的功能部件:</em></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8a47" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">此方法将在组件被卸载时调用，并且在其生命周期中只调用一次。为了复制类组件中的行为，我们需要在<code class="fe lt lu lv lw b">useEffect</code>中返回一个回调函数，并传递第二个参数<code class="fe lt lu lv lw b">[]</code>。这与<code class="fe lt lu lv lw b">componentDidMount</code>非常相似，所以一定要记住你需要在<code class="fe lt lu lv lw b">useEffect</code>中返回一个回调。</p><p id="b3ef" class="pw-post-body-paragraph ku kv in kx b ky kz la lb lc ld le lf ke lh li lj ki ll lm ln km lp lq lr ls ig bi translated">感谢阅读这篇文章。快乐挂钩！</p><h2 id="09a4" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">资源:</h2><div class="na nb gp gr nc nd"><a href="https://reactjs.org/docs/hooks-effect.html" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">使用效果钩-反应</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">reactjs.org</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://medium.com/javascript-in-plain-english/lifecycle-methods-substitute-with-react-hooks-b173073052a" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">用React挂钩替代生命周期方法</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">当你有钩子的时候为什么要使用类组件🤩🧨</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jt nd"/></div></div></a></div></div></div>    
</body>
</html>