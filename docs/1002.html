<html>
<head>
<title>Unit Testing Node.js + Mongoose Using Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest单元测试node . js+mongose</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-node-js-mongoose-using-jest-106a39b8393d?source=collection_archive---------0-----------------------#2021-03-03">https://javascript.plainenglish.io/unit-testing-node-js-mongoose-using-jest-106a39b8393d?source=collection_archive---------0-----------------------#2021-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d5490c70db4be7f663c5e453f99a018f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BFklk0QyI9b1PSQscUTkjA.png"/></div></div></figure><div class=""/><p id="ddd2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单元测试不是所有事情的答案，但是它确实可以避免一些尴尬和麻木的情况。有时候，无论你在编程时多么小心，有些错误还是会被忽视，而在其他人之前发现它们的最简单的方法就是单元测试。</p><p id="925f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本指南中，我将向您展示如何使用Jest对MERN堆栈的后端进行单元测试。具体来说就是Node.js和Mongoose。</p><p id="894e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对Node.js有经验，那么你可以跳到第2步，这一步详细描述了如何测试你的函数。</p><h1 id="1862" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第一步。设置快递后端</strong></h1><p id="29cd" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对大多数人来说，这一步应该很简单。你真正需要做的就是设置<code class="fe lw lx ly lz b">npm</code>，安装几个包，确保你可以成功启动你的服务器。我正在使用<code class="fe lw lx ly lz b">nodemon</code>，但也可以随意使用<code class="fe lw lx ly lz b">npm</code>。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="833d" class="mi ku iy lz b gy mj mk l ml mm">npm init -y<br/>npm i express mongoose nodemon</span></pre><p id="bae3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，您的项目应该是这样的:</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mn"><img src="../Images/63b8a6bce164741a99a21ec0fb7a831b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6w80JrdHIarIu7CQ-8s6Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">basic set up in index.js</figcaption></figure><p id="630e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们只关心应用程序的测试，我们只需要一个非常简单的API，既然每个人都喜欢食物，我想为什么不制作另一个<em class="ms">餐馆API呢！</em></p><p id="01a7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">餐厅模式</strong></p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mt"><img src="../Images/5a294d6ee6f270c7dcc2f1f53874c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGs4P9zZx6a9wK396A9lig.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Restaurant model in model/Restaurant.js</figcaption></figure><p id="d918" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该不是什么新鲜事，但是成本的枚举可能会让一些人感到困惑。</p><p id="5e53" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">enum的简单设置是为每个餐馆对象添加一个额外的验证步骤，这与它们的成本属性有关。这意味着“餐馆的成本必须是一个字符串，并且只能是值“$”、“$$”和“$$”中的一个。如果没有提供值，则给餐馆一个成本' $$ '。很简单，对吧？</p><p id="3a13" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的一个测试将涵盖这样一种情况，即传入的cost字符串不是enum中的一个字符串。此时，数据库将无法保存新对象，我们将看到如何处理这种错误。</p><h2 id="ec27" class="mi ku iy bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated"><strong class="ak">创建餐厅功能</strong></h2><p id="7ad3" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们的第一个功能将是创建一个给定名称，位置和预算的餐厅。</p><p id="eaf1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了数据库错误之外，创建餐馆失败的唯一原因是另一家餐馆已经有了给定的名称(参见第10-11行)，或者餐馆的成本不是前面提到的枚举中的字符串之一(参见model/Restaurant.js)。</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nf"><img src="../Images/59534ffb7629611a88d94b19338bba80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6celQRmisliyUwVgyhbtLw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">helper function to create a new restaurant in controller/createRestaurant.js</figcaption></figure><p id="551e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果成功，它将返回新创建的餐馆的id。</p><h2 id="1df9" class="mi ku iy bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated"><strong class="ak">创建餐厅过帐方法</strong></h2><p id="88b7" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这一步对于测试来说是不必要的，但是以防你不习惯使用帮助函数，我想包括你如何将它们融入到你的代码中。</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/ed4e8b061648ca4c93912ca65646cae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvw2nTMpumVyHN5g4Gmf2A.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">controller/index.js</figcaption></figure><p id="0a82" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面的图片中看到的，我们之前创建的<code class="fe lw lx ly lz b">createRestaurant(name, loc, cost)</code>在post请求中被调用，所有这些都被包装在一个try catch语句中，这样如果出现错误(例如，相同的名称使用了两次),我们就可以处理它。</p><h1 id="f75e" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第二步。安装Jest和mongodb-memory-server </strong></h1><p id="0520" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如文章标题中提到的，我们将使用Jest来运行我们的测试。</p><p id="7c13" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jest提供了创建、组织和运行测试的方法。它是最受欢迎的测试框架之一，因为它关注简单性，所以您可以关注测试背后的逻辑。</p><blockquote class="nh ni nj"><p id="0e98" class="jv jw ms jx b jy jz ka kb kc kd ke kf nk kh ki kj nl kl km kn nm kp kq kr ks ig bi translated">" Jest是一个令人愉快的JavaScript测试框架，专注于简单性."</p></blockquote><p id="cc56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须安装的第二个包是<code class="fe lw lx ly lz b">mongodb-memory-server</code>。如果你已经熟悉mongo的工作方式，你会知道你创建了一个集群来存储你所有的应用数据。大多数应用程序都会定期写入/查询/更新数据库，因此，确保您与数据库的交互产生预期的结果是很重要的。</p><blockquote class="nh ni nj"><p id="03bf" class="jv jw ms jx b jy jz ka kb kc kd ke kf nk kh ki kj nl kl km kn nm kp kq kr ks ig bi translated">mongodb-memory服务器创建一个“集群”,它只存在于设备的主内存中，并没有物理存储到磁盘上。</p></blockquote><p id="8b24" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，一旦应用程序终止，数据库实例将不再存在。这种方法也比模拟与数据库的交互要快。</p><p id="e4b1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经了解了这个理论，让我们安装两个包:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="df0c" class="mi ku iy lz b gy mj mk l ml mm">npm i mongodb-memory-server jest</span></pre><h1 id="b86d" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第三步。处理内存服务器</strong></h1><p id="ad5b" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了确保我们不重复代码并保持良好的风格，最好创建并导出用于处理内存数据库的函数，然后调用这些导出的函数，因为项目的其余部分都需要它们。</p><p id="5e5e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们之前安装的mongodb-memory-server包有一个非常有用的github页面，解释了如何连接和创建一个db实例:</p><div class="im in gp gr io nn"><a href="https://github.com/nodkz/mongodb-memory-server#simple-server-start" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iz gy z fp ns fr fs nt fu fw ix bi translated">nodkz/MongoDB-内存-服务器</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在内存中运行mongod进行快速测试。如果您并行运行测试，这个库有助于提升专用的mongodb…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob iu nn"/></div></div></a></div><p id="14ef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不想通读文档，那么下面的代码将足以让您开始单元测试。</p><p id="6917" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">特别感谢<a class="ae oc" href="https://dev.to/paulasantamaria" rel="noopener ugc nofollow" target="_blank"> Paula Santamaría </a>在她的文章中提供了这个模块。我将在本教程的最后链接到她的文章。</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi od"><img src="../Images/f3cca9ec4f0da76715920f2a37d5da51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2yWnnOaXrzXReHBk-ofHQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Handling interactions with in-memory database: tests/db.js</figcaption></figure><p id="16d7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">connect和closeDatabase方法应该很容易解释，但是，您可能想知道为什么我们还需要一个clearDatabase函数。</p><p id="5e74" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说到单元测试，每个测试都应该在一个空白的画布上开始，这意味着当我们开始一个新的测试时，数据库中应该没有现有的数据。所以每次测试结束，我们都会调用clearDatabase函数。</p><h1 id="dd4e" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第四步。设置测试文件</strong></h1><p id="6f2b" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">首先，在我们的测试文件夹中，我们将保存包括测试在内的所有文件。在命名文件时，确保以这种方式命名是很重要的:<code class="fe lw lx ly lz b">fileName.test.js</code></p><p id="f0d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在运行任何测试之前，我们需要连接到内存数据库。幸运的是，我们已经在<code class="fe lw lx ly lz b">tests/db.js</code>中创建和导出了一个方法。类似地，一旦所有测试运行完毕，我们需要断开连接并删除数据库。最后，在每次单独测试之后，我们必须清空数据库。</p><p id="977b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要做的就是将它添加到每个测试文件的顶部:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="1d1a" class="mi ku iy lz b gy mj mk l ml mm">const db = require('./db')</span><span id="59d9" class="mi ku iy lz b gy oe mk l ml mm">beforeAll(async () =&gt; await db.connect())</span><span id="57dc" class="mi ku iy lz b gy oe mk l ml mm">afterEach(async () =&gt; await db.clearDatabase())</span><span id="1247" class="mi ku iy lz b gy oe mk l ml mm">afterAll(async () =&gt; await db.closeDatabase())</span></pre><h1 id="796f" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第五步。剖析一个玩笑式的测试</strong></h1><p id="4f7a" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">设置好一切后，我们现在可以专注于对<code class="fe lw lx ly lz b">createRestaurant</code>函数的第一次测试。</p><p id="4ae7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jest提供了一种组织测试的方法。考虑以下测试异步函数的示例，该函数接收整数并以整数和字符串的形式返回数字:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="676a" class="mi ku iy lz b gy mj mk l ml mm">describe('First Group Of Tests', () =&gt; {</span><span id="f0a1" class="mi ku iy lz b gy oe mk l ml mm">    it('First Test', async done =&gt; {<br/>        const result = await numberFunc(10)<br/>        expect(result.word).toBe("ten")<br/>        expect(result.number).toBeGreaterThan(10)<br/>        done()</span><span id="5002" class="mi ku iy lz b gy oe mk l ml mm">    })<br/>    it('Second Test', async done =&gt; {<br/>        const result = await numberFunc()<br/>        expect(result).toBeNull()<br/>        done()</span><span id="18e8" class="mi ku iy lz b gy oe mk l ml mm">    })</span><span id="47e2" class="mi ku iy lz b gy oe mk l ml mm">})</span></pre><p id="d9ee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中的要点是:</p><ul class=""><li id="338b" class="of og iy jx b jy jz kc kd kg oh kk oi ko oj ks ok ol om on bi translated"><code class="fe lw lx ly lz b">describe</code>块是一种将相似的测试放在一起的方法。例如，如果您正在测试<code class="fe lw lx ly lz b">createRestaurant</code>函数，并希望确保它能够处理各种名称长度，那么您可以将所有这些测试放在同一个describe块中。</li><li id="268f" class="of og iy jx b jy oo kc op kg oq kk or ko os ks ok ol om on bi translated"><code class="fe lw lx ly lz b">it </code>块代表每个单独的测试。</li><li id="42f4" class="of og iy jx b jy oo kc op kg oq kk or ko os ks ok ol om on bi translated">对于异步测试来说，<code class="fe lw lx ly lz b">it</code>块最重要的部分是确保在测试结束时包含<code class="fe lw lx ly lz b">done()</code>。否则，测试将在任何异步调用完成之前完成，您的测试将会失败。Jest解释异步函数中<code class="fe lw lx ly lz b">done()</code>重要性的方式是:</li></ul><blockquote class="nh ni nj"><p id="0c15" class="jv jw ms jx b jy jz ka kb kc kd ke kf nk kh ki kj nl kl km kn nm kp kq kr ks ig bi translated">" Jest会等到<code class="fe lw lx ly lz b">done</code>回调函数被调用后才完成测试."</p></blockquote><ul class=""><li id="5ea8" class="of og iy jx b jy jz kc kd kg oh kk oi ko oj ks ok ol om on bi translated"><code class="fe lw lx ly lz b">expect</code>和其他语言的<code class="fe lw lx ly lz b">assert</code>很像。这是我们可以检查的方法，以确保我们的函数正在检索/创建我们希望它们检索/创建的对象。虽然有许多不同的方式来使用<code class="fe lw lx ly lz b">expect</code>，我在这里只显示了3个选项。更多信息，请查看<a class="ae oc" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/expect</a></li></ul><h1 id="1765" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第六步。测试</strong> <code class="fe lw lx ly lz b">createRestaurant()</code></h1><p id="f81c" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">由于测试是自顶向下运行的，所以最好将最简单/基本的测试放在文件的顶部。我的意思是这样的:</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f87ef11f4959f39998e9406593780b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIF-oznv8cr9HcGAd8QHUw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">example test suite to show order of tests running in Jest</figcaption></figure><p id="32fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，文件中测试的顺序很重要。</p><p id="919d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在进入更复杂的情况之前，最好从测试一个函数的最基本需求开始，以确保它能正常工作。</p><p id="77ab" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以回到测试<code class="fe lw lx ly lz b">createRestaurant()</code>，最基本的测试用例是创建一个具有有效名称、位置和预算的餐馆。</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ot"><img src="../Images/ddfa099c4409474e4075ab900ff98b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvAELehwbsJnhUC96TkKgw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">example unit test for a success case in tests/createRestaurant.test.js</figcaption></figure><p id="980d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们第一次测试的测试文件！如果这三个<code class="fe lw lx ly lz b">except()</code>中的任何一个失败了，那么测试就会失败，我们就会知道函数中的某些东西被破坏了。现在，让我们运行测试，看看它是否会工作。</p><h1 id="4529" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第七步。运行测试</strong></h1><p id="e3ea" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在您的<code class="fe lw lx ly lz b">package.json</code>中，添加一个测试脚本:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="479d" class="mi ku iy lz b gy mj mk l ml mm">"scripts": {<br/>    "test": "jest --testEnvironment=node --runInBand ./tests"<br/>}</span></pre><p id="cbaf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lw lx ly lz b">--runInBand</code>是为了让测试一个接一个地运行。</p><p id="4da4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lw lx ly lz b">--testEnvironment=node</code>就在那里，因为我们处在一个节点环境中。</p><p id="497a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里真正重要的是给出测试文件夹的正确路径。对我来说，那就是<code class="fe lw lx ly lz b">./tests</code>。</p><p id="ebae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当您在终端中运行<code class="fe lw lx ly lz b">npm test</code>时，您应该会看到类似这样的内容:</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ou"><img src="../Images/1787ed1b0d8a4620a4e4dfe76c16dd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hh-Eh1nAd4EKEntb8ATNw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Successful jest test</figcaption></figure><p id="1d56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个成功测试的例子。我将向您展示如何编写错误测试。</p><h2 id="f527" class="mi ku iy bd kv mu mv dn kz mw mx dp ld kg my mz lh kk na nb ll ko nc nd lp ne bi translated"><strong class="ak">错误测试</strong></h2><p id="7628" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在同一个文件中，您可以创建一个新的describe块，以防我们无法创建新的餐馆。回头看看我们的模式和函数，只有在名称重复或者与餐馆相关的成本不在枚举值中时，它才会失败。</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ov"><img src="../Images/1b444cd590f833f59d66e4db3d022652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqzW9RMU1ul6v4Pz-TS3Mg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">example testing for exceptions in tests/createRestaurant.js</figcaption></figure><p id="d809" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一个测试中，我们检查如果名称重复，是否会抛出错误。我们已经成功测试了一家餐厅的案例，因此我们可以放心，33号线将顺利运行。</p><p id="b6e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，第35行应该抛出一个错误，因为名称“First”已经属于另一个餐馆。由于这是一个异步函数，意味着抛出一个错误，我们需要在expect后面添加<code class="fe lw lx ly lz b">rejects.toThrow()</code>。</p><p id="3ae5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第二个测试中，我们检查当第三个参数<code class="fe lw lx ly lz b">createRestaurant()</code>不是cost enum中的字符串值时是否抛出了错误。</p><p id="5800" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您再次运行测试，您应该会看到以下内容:</p><figure class="ma mb mc md gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ow"><img src="../Images/2ced12720a266fd3363229537951091b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*je3wMbG_KA0BoRo8iJkIpQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Running all tests successfully</figcaption></figure><p id="925c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜你！您已经使用Jest成功地对Node.js和Mongoose后端进行了单元测试。</p><p id="3b46" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，如果您有任何不确定的地方，请留下您的评论。这是我的第一篇文章，所以我可能做得不完美，所以如果你发现任何问题，请让我知道😌</p><p id="eda5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想用<code class="fe lw lx ly lz b">jest</code>做更多的事情，比如用<strong class="jx iz">模仿</strong>外部函数的行为，请阅读<a class="ae oc" href="https://yasaminkamali.medium.com/jest-mock-for-unit-testing-mern-backend-983c1e3fef83" rel="noopener">🥳的博客</a></p><h1 id="8d18" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><p id="3165" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><a class="ae oc" href="https://dev.to/paulasantamaria/testing-node-js-mongoose-with-an-in-memory-database-32np" rel="noopener ugc nofollow" target="_blank">https://dev . to/paulasantamaria/testing-node-js-mongose-with-an-in-memory-database-32np</a></p></div></div>    
</body>
</html>