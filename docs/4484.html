<html>
<head>
<title>How To Keep Component State Across Pages in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Next.js中跨页面保持组件状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-keep-state-7eb68984c54e?source=collection_archive---------0-----------------------#2021-09-07">https://javascript.plainenglish.io/next-js-keep-state-7eb68984c54e?source=collection_archive---------0-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eba3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用会话存储&amp; useLayoutEffect</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e0e9255e2965d4ae2ff7069d97250af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXsCHAHPN7xFAWuuWjE6-Q.png"/></div></div></figure><p id="5263" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Next使得将我们的应用分成服务器端呈现的页面变得容易。在不同的页面上使用相同的组件也不是问题，但是保持状态是问题。默认情况下，当打开不同的页面时，组件的状态被重置。我们来看一个小例子。</p><p id="9a95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定这个小按钮组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="b7f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将它包含在两个不同的页面中，可通过<code class="fe lp lq lr ls b">next/link</code>相互访问:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="908a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">about.js</code>基本上是同一个文件，所以我将留给您一个片段。</p><p id="1cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当把所有的东西放在一起时，我们注意到以下几点:递增按钮工作正常。但是当切换到另一个页面时，状态丢失。在一些应用程序中，这不是我们想要的——相反，我们想要的是以某种方式保持状态。下面是如何轻松做到的。</p><h1 id="87d1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">会话存储简介</h1><p id="ac6b" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">Web存储API应该在每个开发人员的工具箱中。它包含两个存储数据的特性:第一，更流行的localStorage，它在浏览器中永久保存一个键值对。第二个是sessionStorage，它在会话期间保存一个键值对。<br/>会话？让我澄清这一点。</p><p id="a391" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你打开<code class="fe lp lq lr ls b">youtube.com</code>，你的会话开始。当您点击按钮并导航至<code class="fe lp lq lr ls b">youtube.com/feed/subscriptions</code>时，您的会话仍在进行。当您关闭窗口时，会话就完成了。</p><p id="f252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在会话期间保持状态是一个常见的用例，例如，当您有一个搜索栏，并且希望在用户被导航到的结果站点上保持它的输入时。</p><p id="e1eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">提示:</strong>有针对持久状态优化的库。我只想向您展示持久化状态通常是如何工作的——使用会话存储。在大多数情况下，使用库是更好的选择。</p><h1 id="8aa6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">代码</h1><p id="e057" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">当想要跨页面保持状态时，我们需要做两件事:</p><ul class=""><li id="77fa" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated">保存当前状态</li><li id="f4b3" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">从存储器接收当前状态以将其写入反应状态</li></ul><p id="093e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">两者都是React钩子的很好的用例，更准确地说，是<code class="fe lp lq lr ls b">useEffect</code>钩子。每当当前状态改变时，将当前状态保存到sessionStorage是<code class="fe lp lq lr ls b">useEffect</code>监听单个状态的一个例子。每当我们的计数器状态改变时，我们将这些改变提交给会话存储:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="687d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">获取会话存储并利用它来调整组件状态是<code class="fe lp lq lr ls b">useEffect</code>配置的一个例子，它的工作方式类似于<code class="fe lp lq lr ls b">componentDidMount</code>——一旦组件被挂载。</p><p id="f553" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这将导致每次我们切换页面时出现小的闪烁。为什么？因为<code class="fe lp lq lr ls b">useEffect</code>中的代码是在我们的组件在屏幕上可见之后执行的。</p><p id="bd59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，当DOM发生变异时，我们可以使用<code class="fe lp lq lr ls b">useLayoutEffect</code>作为<code class="fe lp lq lr ls b">useEffect</code>的替代。除了名字，语法几乎和<code class="fe lp lq lr ls b">useEffect</code>一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="b683" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果会话存储键值对已经存在，我们将它的数据复制到状态中。如果会话存储中还不存在这个条目，我们就创建它。</p><p id="ee42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于不是全黑白的，所以<code class="fe lp lq lr ls b">useLayoutEffect</code>有一个缺点:相比经典的useEffect，它的另类延迟了浏览器绘画。然而，在我们的例子中，这不是一个大问题。</p><p id="7178" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将所有这些放在一起:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="311b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们现在增加按钮并切换页面时，状态将被保留——因为使用了<code class="fe lp lq lr ls b">useLayoutEffect</code>,这是一个平滑的过渡，在水合状态时没有闪烁。</p><p id="e6b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p><p id="ac46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于Next.js的更多信息:</p><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-preact-f993c95a3f93"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">想让你的Next.js App更快？启用预先支持(方法如下)</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">如何在你的Next.js应用上启用Preact支持，并几乎免费节省几千字节。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-tricks-6dd97ee66c7c"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">添加到工具箱中的5个有用的Next.js技巧</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">构建脚本、加载外部JavaScript、重定向等等。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv kp nh"/></div></div></a></div><h2 id="6483" class="nx lu iq bd lv ny nz dn lz oa ob dp md la oc od mf le oe of mh li og oh mj oi bi translated">进一步阅读</h2><div class="ne nf gp gr ng nh"><a href="https://blog.bitsrc.io/next-js-13-what-do-the-new-bleeding-edge-features-actually-do-d3e5fd418563" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Next.js 13:新的前沿特性实际上是做什么的？</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">你听说过Next.js 13是一个游戏改变者，但是为什么？让我们看看有哪些新功能，有哪些变化，以及它们…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nq l"><div class="oj l ns nt nu nq nv kp nh"/></div></div></a></div><p id="e02b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ok">更多内容看</em> <a class="ae ol" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ok">说白了就是io </em> </strong> </a> <em class="ok">。报名参加我们的</em> <a class="ae ol" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ok">免费周报</em> </strong> </a> <em class="ok">。关注我们关于</em><a class="ae ol" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ok">Twitter</em></strong></a>，<a class="ae ol" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ok">LinkedIn</em></strong></a><em class="ok">，</em><a class="ae ol" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ok">YouTube</em></strong></a><em class="ok">，</em> <a class="ae ol" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ok">不和</em> </strong> </a> <em class="ok">。对增长黑客感兴趣？检查</em> <a class="ae ol" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ok">电路</em> </strong> </a> <em class="ok">。</em></p></div></div>    
</body>
</html>