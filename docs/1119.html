<html>
<head>
<title>Testing React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试反应挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-react-hooks-1fee0bfdbf42?source=collection_archive---------2-----------------------#2021-03-09">https://javascript.plainenglish.io/testing-react-hooks-1fee0bfdbf42?source=collection_archive---------2-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9cb0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React钩子测试库使用指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/239b2c21ad565fb8e80e9e8e03cc3d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WjpHzyuX3g3UkToC"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ca0c" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="e222" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">随着我越来越多地使用钩子，我也开始创建自己的钩子来将功能归纳到公共代码中。自然，下一个合乎逻辑的步骤将是测试。但是，我很快发现这个过程并不像我想象的那么简单。在测试中直接调用一个钩子会触发这个错误:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="7dc4" class="mm ku in mi b gy mn mo l mp mq">Invalid hook call. Hooks can only be called inside of the body of a function component.</span></pre><p id="ff4e" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">但是我如何在测试中做到这一点呢？</p><h1 id="8931" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">React钩子测试库</h1><p id="2180" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://react-hooks-testing-library.com/" rel="noopener ugc nofollow" target="_blank">反应钩子测试库</a>来救援。它提供了一个<code class="fe mw mx my mi b">renderHook</code> API，将钩子包装在一个函数组件中来解决错误。这个API将返回有用的实用程序，使您能够完全测试您的钩子。</p><h1 id="2fe7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">例子</h1><p id="5480" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">让我们以一个连接React和localStorage的<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/connecting-react-with-localstorage-ad590d4e4fa1">简单钩子</a>为例:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="e764" class="mm ku in mi b gy mn mo l mp mq">import { useCallback, useState } from 'react';</span><span id="ecc6" class="mm ku in mi b gy mz mo l mp mq">export default function useLocalStorage(key, initialState) {<br/>  const [value, setValue] = useState(localStorage.getItem(key) ?? initialState);<br/>  const updatedSetValue = useCallback(<br/>    newValue =&gt; {<br/>      if (newValue === initialState || typeof newValue === 'undefined') {<br/>        localStorage.removeItem(key);<br/>      } else {<br/>        localStorage.setItem(key, newValue);<br/>      }<br/>      setValue(newValue ?? initialState);<br/>    },<br/>    [initialState, key]<br/>  );<br/>  return [value, updatedSetValue];<br/>}</span></pre><p id="f8fe" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">这个简单的钩子就像React的本机<code class="fe mw mx my mi b">useState</code>钩子一样，将状态与localStorage同步。</p><p id="7749" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">现在，使用React Hooks测试库，让我们首先从一些简单的测试开始，以确保输出是正确的。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="2a3c" class="mm ku in mi b gy mn mo l mp mq">import { act, renderHook } from '<a class="ae ks" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react-hooks';</span><span id="088c" class="mm ku in mi b gy mz mo l mp mq">import useLocalStorage from './useLocalStorage';</span><span id="668a" class="mm ku in mi b gy mz mo l mp mq">beforeEach(() =&gt; localStorage.clear());<br/>afterEach(() =&gt; localStorage.clear());</span><span id="3b45" class="mm ku in mi b gy mz mo l mp mq">const key = 'KEY';</span><span id="69c3" class="mm ku in mi b gy mz mo l mp mq">test('should return localStorage value', () =&gt; {<br/>  localStorage.setItem(key, 'value');<br/>  const { result } = renderHook(() =&gt; useLocalStorage(key));<br/>  expect(result.current).toStrictEqual(<br/>    ['value', expect.any(Function)]<br/>  );<br/>});</span><span id="37ee" class="mm ku in mi b gy mz mo l mp mq">test('should return the default value', () =&gt; {<br/>  const initialState = 'default';<br/>  const { result } = renderHook(<br/>    () =&gt; useLocalStorage(key, initialState)<br/>  );<br/>  expect(result.current).toStrictEqual(<br/>    ['default', expect.any(Function)]<br/>  );<br/>});</span></pre><p id="1a2d" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated"><code class="fe mw mx my mi b">renderHook</code>接受一个调用钩子的函数。这将返回一个包含钩子返回值的<code class="fe mw mx my mi b">result.current</code>。然后对这个值进行测试，以确保它符合我们的预期。很简单，对吧？</p><h1 id="3ac8" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">相互作用</h1><p id="348e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mw mx my mi b">useLocalStorage</code>钩子也返回一个更新状态值的setter。使用React Hooks测试库与这个setter交互也很简单。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="5f93" class="mm ku in mi b gy mn mo l mp mq">import { act, renderHook } from '<a class="ae ks" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react-hooks';</span><span id="483c" class="mm ku in mi b gy mz mo l mp mq">const key = 'KEY';</span><span id="3c5c" class="mm ku in mi b gy mz mo l mp mq">test('should update when set is called', () =&gt; {<br/>  const initialState = 'default';<br/>  const { result } = renderHook(<br/>    () =&gt; useLocalStorage(key, initialState)<br/>  );<br/>  expect(result.current).toStrictEqual(<br/>    ['default', expect.any(Function)]<br/>  );<br/>  const [, setValue] = result.current;<br/>  act(() =&gt; {<br/>    setValue('value');<br/>  });<br/>  expect(localStorage.getItem(key)).toEqual('value');<br/>  expect(result.current).toStrictEqual(<br/>    ['value', expect.any(Function)]<br/>  );<br/>});</span></pre><p id="b99f" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">这里，用新值调用<code class="fe mw mx my mi b">setValue</code>，并检查localStorage和<code class="fe mw mx my mi b">result.current</code>以确保状态被正确更新。<code class="fe mw mx my mi b">setValue</code>被包装在一个<code class="fe mw mx my mi b">act</code>调用中，因此状态更新可以发生。</p><p id="57fc" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">注意:React测试库只是用更新后的值从<code class="fe mw mx my mi b">renderHook</code>调用中变异出原始的<code class="fe mw mx my mi b">result.current</code>。因此，执行以下操作将不起作用:</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="acf7" class="mm ku in mi b gy mn mo l mp mq">const [value, setValue] = result.current;<br/>act(() =&gt; {<br/>  setValue('value');<br/>});<br/>expect(value).toEqual('value');</span></pre><h1 id="4629" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">RenderHook API</h1><h2 id="d987" class="mm ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">投入</h2><p id="e240" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mw mx my mi b">renderHook</code>函数也支持选项对象作为第二个参数。</p><p id="2427" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated"><strong class="ln io">包装器</strong>用于在附加的React组件中包装钩子。这是用来给你的钩子提供它需要的额外的上下文。例如，如果你的钩子需要Redux的<code class="fe mw mx my mi b">dispatch</code>，你可以将Redux的<code class="fe mw mx my mi b">Provider</code>作为包装器传递，这样<code class="fe mw mx my mi b">useDispatch</code>就可以工作了。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="9b2a" class="mm ku in mi b gy mn mo l mp mq">import { createStore } from 'redux';<br/>import { Provider, useDispatch } from 'react-redux'</span><span id="2e2c" class="mm ku in mi b gy mz mo l mp mq">function hook() {<br/>  const dispatch = useDispatch();<br/>  ...<br/>}</span><span id="5aa6" class="mm ku in mi b gy mz mo l mp mq">test('should work', () =&gt; {<br/>  const wrapper = ({ children }) =&gt; (<br/>    &lt;Provider store={createStore()}&gt;<br/>      {children}<br/>    &lt;/Provider&gt;<br/>  );<br/>  const { result } = renderHook(() =&gt; hook(), { wrapper });<br/>});</span></pre><p id="65ee" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated"><strong class="ln io"> initialProps </strong>用于设置初始挂钩值。它通常与<code class="fe mw mx my mi b">renderHook</code>的<strong class="ln io">重新渲染</strong>结合使用，以模拟道具变化。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="6872" class="mm ku in mi b gy mn mo l mp mq">function hook(value) {<br/>  ...<br/>  return value;<br/>}</span><span id="0448" class="mm ku in mi b gy mz mo l mp mq">test('should return updated value', () =&gt; {<br/>  const { rerender, result } = renderHook(<br/>    ({ value }) =&gt; hook(value),<br/>    { initialProps: { value: 'initial' }}<br/>  );<br/>  expect(result.current).toEqual('initial');<br/>  rerender({ value: 'updated' });<br/>  expect(result.current).toEqual('updated');<br/>});</span></pre><h2 id="35d1" class="mm ku in bd kv na nb dn kz nc nd dp ld lu ne nf lf ly ng nh lh mc ni nj lj nk bi translated">输出</h2><p id="de3e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe mw mx my mi b">renderHook</code>函数输出一个对象。你已经熟悉了<code class="fe mw mx my mi b">result</code>，但是还有其他有用的方法可以帮助测试钩子的整个生命周期。</p><p id="37b7" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated">rerender 是一个可以被调用的函数，用新的道具重新渲染钩子，新的道具作为参数传入。参见上面的<code class="fe mw mx my mi b">initialProps</code>示例。</p><p id="51f9" class="pw-post-body-paragraph ll lm in ln b lo mr jo lq lr ms jr lt lu mt lw lx ly mu ma mb mc mv me mf mg ig bi translated"><strong class="ln io"> unmount </strong>是一个函数，可以被调用来模拟组件被从DOM中移除。它用来触发<code class="fe mw mx my mi b">useEffect</code>清理效果。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="2cd4" class="mm ku in mi b gy mn mo l mp mq">import { useEffect } from 'react';</span><span id="9f30" class="mm ku in mi b gy mz mo l mp mq">function hook() {<br/>  ...<br/>  useEffect(() =&gt; {<br/>    console.log('mounted');<br/>    return () =&gt; console.log('unmounting');<br/>  }, []);<br/>};</span><span id="037a" class="mm ku in mi b gy mz mo l mp mq">test('should trigger cleanup effect', () =&gt; {<br/>  jest.spyOn(console, 'log');<br/>  const { unmount } = renderHook(() =&gt; hook());<br/>  expect(console.log).toHaveBeenCalledWith('mounted');<br/>  unmount();<br/>  expect(console.log).toHaveBeenCalledWith('unmounting');<br/>});</span></pre></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h1 id="2011" class="kt ku in bd kv kw ns ky kz la nt lc ld jt nu ju lf jw nv jx lh jz nw ka lj lk bi translated">最后的想法</h1><p id="448e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">React hooks测试库提供了一个简单的框架来全面测试你定制的React Hooks并实现完整的测试覆盖。有了它，您可以轻松地测试一个钩子从挂载到更新再到卸载的整个生命周期。既然你已经学会了这一点，那就出去确保你的React钩子没有bug！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h1 id="8494" class="kt ku in bd kv kw ns ky kz la nt lc ld jt nu ju lf jw nv jx lh jz nw ka lj lk bi translated">资源</h1><ul class=""><li id="5a76" class="nx ny in ln b lo lp lr ls lu nz ly oa mc ob mg oc od oe of bi translated"><a class="ae ks" href="https://react-hooks-testing-library.com/" rel="noopener ugc nofollow" target="_blank">官方React钩子测试库文档</a></li><li id="1f36" class="nx ny in ln b lo og lr oh lu oi ly oj mc ok mg oc od oe of bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/testing-hooks" rel="noopener ugc nofollow" target="_blank">本文Github回购</a></li><li id="e149" class="nx ny in ln b lo og lr oh lu oi ly oj mc ok mg oc od oe of bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/testing-hooks?file=/src/useLocalStorage.test.js" rel="noopener ugc nofollow" target="_blank">本文的code sandbox</a></li></ul></div></div>    
</body>
</html>