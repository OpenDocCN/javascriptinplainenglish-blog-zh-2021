<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个MERN Stack电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73?source=collection_archive---------0-----------------------#2021-01-28">https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73?source=collection_archive---------0-----------------------#2021-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="481e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:构建身份验证和项目路由及控制器</h2></div><p id="a4a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第三部分，我们将构建这个项目中身份验证和项目处理所需的REST APIs。我们还将构建一些我们将在项目中使用的定制中间件功能。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/f385d3cfaedd0fb115cfa76b49337302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L30C7V6BETSf0oc3"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="47ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">朋友们，你们好！这是我们最近开始的MERN堆栈系列的第三部分。在第一部分，我们都学会了如何建立这个项目，并对我们将在这个项目中使用的各种东西进行了解释。在第二部分，我们在<strong class="kh ir">猫鼬</strong>和<strong class="kh ir">猫鼬</strong>的帮助下，为这个项目开发了我们所有的模型。</p><p id="0f67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您尚未阅读前两部分，以下是前两部分的链接:-</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们构建一个MERN Stack电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第一部分:项目设置</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们构建一个MERN Stack电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第二部分:模型设计</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj ll lv"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="579e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在第三部分，我们将构建后端部分，它将通过在Express Router的帮助下构建API来处理web应用程序中的身份验证和项目，我们还将定义一个定制的中间件功能来检查用户是否通过身份验证。</p><p id="e3d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了保持简单明了，我们会在根文件夹中创建一个名为<strong class="kh ir"> <em class="ms"> routes </em> </strong>的新文件夹。这个文件夹将包含我们这个项目需要的所有路线。</p><p id="6024" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将创建一个名为<strong class="kh ir"> <em class="ms">控制器</em> </strong>的文件夹，一旦我们遇到一个应用编程接口端点，我们将在其中放置我们将要调用的所有函数。因此，我们会将该函数放在不同的文件夹中，然后将它们导入到routes文件夹中使用。</p><p id="9726" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="ms">路线</em>文件夹中，我们会创建四个文件-<strong class="kh ir">授权、项目、购物车</strong>和<strong class="kh ir">订单。</strong>这四个文件分别包含与认证相关的路径、物品、购物车和订单。</p><p id="55c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们会在<em class="ms">控制器的</em>文件夹中创建四个文件，每个文件对应于<em class="ms">路由</em>文件夹中的一个文件。这些将分别是-<strong class="kh ir">身份控制器、项目控制器、cart controller</strong>和<strong class="kh ir">订单控制器</strong>。</p><p id="c197" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们现在开始构建我们的Routes文件夹，这很简单，因为我们将把所有的逻辑放在<em class="ms">控制器的</em>文件夹中，而不是直接放在<em class="ms"> routes </em>文件夹中。</p><blockquote class="mt mu mv"><p id="36b1" class="kf kg ms kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><strong class="kh ir">注意</strong>:本教程只处理与身份验证和项目相关的路由和控制器，下一教程将处理购物车和订单。</p></blockquote><h1 id="ab56" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">路线</h1><h2 id="9910" class="nr na iq bd nb ns nt dn nf nu nv dp nj ko nw nx nl ks ny nz nn kw oa ob np oc bi translated">授权路由</h2><p id="5e7a" class="pw-post-body-paragraph kf kg iq kh b ki od jr kk kl oe ju kn ko of kq kr ks og ku kv kw oh ky kz la ij bi translated">该文件将包含我们在web应用程序中验证用户身份所需的所有路由。</p><p id="f311" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="ms">当我们谈论认证时，您会想到什么？</em> </strong></p><p id="258a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ms">注册用户，登录和注销。此外，我们需要不断检查用户当前是否登录。</em></p><p id="a9ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们将在应用程序中使用的身份验证路由的代码。首先，检查代码，然后我会详细解释代码中每一行的用途。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Auth Routes</figcaption></figure><p id="c604" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，首先，我们从要求文件中的<em class="ms"> express </em>的<strong class="kh ir"> <em class="ms">路由器</em> </strong>开始。我们将使用快速路由器来建立所有的路由。我们还从控制器文件夹中引入了<em class="ms"> authControllers </em>，并从中间件文件夹中引入了我们的定制中间件函数<em class="ms"> auth </em>。我们稍后将构建这些文件。</p><p id="6f4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们有三个路径— <strong class="kh ir">注册、登录</strong>和<strong class="kh ir">用户。让我们来看看每一个是如何运作的。</strong></p><ol class=""><li id="52bf" class="ok ol iq kh b ki kj kl km ko om ks on kw oo la op oq or os bi translated"><strong class="kh ir"> register </strong> —这个路由处理一个<em class="ms"> post </em>请求，在这个请求中，一个用户提供他的名字、电子邮件和密码，以便在我们的系统中注册。</li><li id="8284" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir">登录</strong> —这个路由处理网站的用户登录部分。它允许用户登录并检查凭证是否正确。</li><li id="58fd" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir">用户</strong> —该路由是一个<em class="ms"> get </em>请求，我们试图检索用户是否使用该路由登录。</li></ol><blockquote class="mt mu mv"><p id="e1cc" class="kf kg ms kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">注意:现在，你可能想知道我们错过了注销路径，但是我们不需要它。我们将使用<strong class="kh ir">本地存储</strong>来存储我们的<strong class="kh ir"> JWT </strong>令牌，它在客户端处理它，所以我们将直接在客户端处理用户的注销。为此，我们不需要与服务器打交道。</p></blockquote><h2 id="6993" class="nr na iq bd nb ns nt dn nf nu nv dp nj ko nw nx nl ks ny nz nn kw oa ob np oc bi translated">项目路线</h2><p id="f21e" class="pw-post-body-paragraph kf kg iq kh b ki od jr kk kl oe ju kn ko of kq kr ks og ku kv kw oh ky kz la ij bi translated">该文件包含与项目相关的所有路由—获取项目、添加新项目、更新项目和删除项目。所以，让我们先检查代码，然后再深入研究更多的细节。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Item Routes</figcaption></figure><p id="58f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有四条路线。正如我们在上面看到的，它们各自处理特定的功能。</p><ol class=""><li id="d0ca" class="ok ol iq kh b ki kj kl km ko om ks on kw oo la op oq or os bi translated"><strong class="kh ir"> get_items </strong> —这个路由是一个<em class="ms"> get </em>请求，这个路由的目的是从服务器获取所有的项目。</li><li id="5d45" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> post_item </strong> —此路由是一个<em class="ms"> post </em>请求，用于向数据库添加一个新项目。</li><li id="d124" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> update_item </strong> —该路线是一个<em class="ms"> put </em>请求。其目的是更新数据库中的现有项目。</li><li id="06b4" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> delete_item </strong> —该路由是一个<em class="ms"> delete </em>请求，用于从数据库中删除一个项目。</li></ol><blockquote class="mt mu mv"><p id="59f3" class="kf kg ms kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><strong class="kh ir">注意</strong> : delete_item和update_item都有一个参数字段<strong class="kh ir">‘id’</strong>，它也是和URL一起传递的。它包含我们想要删除或更新的项目的id。然后，我们使用id在数据库中搜索该商品。</p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="72d3" class="mz na iq bd nb nc oy ne nf ng oz ni nj jw pa jx nl jz pb ka nn kc pc kd np nq bi translated">控制器</h1><h2 id="1fd2" class="nr na iq bd nb ns nt dn nf nu nv dp nj ko nw nx nl ks ny nz nn kw oa ob np oc bi translated">授权控制器</h2><p id="b389" class="pw-post-body-paragraph kf kg iq kh b ki od jr kk kl oe ju kn ko of kq kr ks og ku kv kw oh ky kz la ij bi translated">这个控制器文件将处理注册、登录和获取用户的所有逻辑，以检查用户是否经过身份验证。</p><p id="2e2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将由三个函数组成，每个函数对应我们拥有的三条路线，每条路线处理一个特定的目的。</p><p id="1fde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将详细讨论这三个功能。但在此之前，我们需要在这个文件中要求一些东西。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="6056" class="pi na iq pe b be pj pk l pl pm">const User = require('../models/User');<br/>const jwt = require('jsonwebtoken');<br/>const config = require('config');<br/>const bcrypt = require('bcrypt');</span></pre><p id="0756" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，我们需要四样东西。让我们讨论一下每个人的责任</p><ol class=""><li id="5221" class="ok ol iq kh b ki kj kl km ko om ks on kw oo la op oq or os bi translated"><strong class="kh ir">用户</strong> —我们需要我们在之前的教程中创建的用户模型。既然我们要和用户打交道，我们就需要它。</li><li id="0497" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> jwt </strong> —我们需要文件中的<em class="ms"> jsonwebtoken </em>来创建JSON Web令牌，我们需要存储这些令牌来验证用户是否已经过身份验证。</li><li id="4255" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> config </strong> —这是引入config包所必需的，以便我们访问存储在config文件夹中的JSON。它能让我们储存JWT密码。</li><li id="adf8" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated"><strong class="kh ir"> bcrypt </strong> —在将密码保存到数据库之前，需要使用bcrypt库来散列密码。</li></ol><p id="22f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以开始构建我们的函数了。所以，我们将从注册开始。</p><p id="0e1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是注册函数的代码，我们将其命名为<em class="ms">‘sign up’。</em></p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="04ad" class="pi na iq pe b be pj pk l pl pm">module.exports.signup = (req,res) =&gt; {<br/>    const { name, email, password } = req.body;<br/><br/>    if(!name || !email || !password){<br/>        res.status(400).json({msg: 'Please enter all fields'});<br/>    }<br/><br/>    User.findOne({email})<br/>    .then(user =&gt; {<br/>        if(user) return res.status(400).json({msg: 'User already exists'});<br/><br/>        const newUser = new User({ name, email, password });<br/><br/>        // Create salt and hash<br/>        bcrypt.genSalt(10, (err, salt) =&gt; {<br/>            bcrypt.hash(password, salt, (err, hash) =&gt; {<br/>                if(err) throw err;<br/>                newUser.password = hash;<br/>                newUser.save()<br/>                    .then(user =&gt; {<br/>                        jwt.sign(<br/>                            { id: user._id },<br/>                            config.get('jwtsecret'),<br/>                            { expiresIn: 3600 },<br/>                            (err, token) =&gt; {<br/>                                if(err) throw err;<br/>                                res.json({<br/>                                    token,<br/>                                    user: {<br/>                                        id: user._id,<br/>                                        name: user.name,<br/>                                        email: user.email<br/>                                    }<br/>                                });<br/>                            }<br/>                        )<br/>                    });<br/>            })<br/>        })<br/>    })<br/>}</span></pre><p id="ac5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，在箭头函数中有一个请求和响应。首先，我们从请求体中分解出名称、电子邮件和密码字段，这些字段通过API请求传递给我们。</p><p id="2518" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将检查任何字段是否为空；如果是，我们会发送一条消息，告诉用户填写所有字段。</p><p id="fee8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们尝试使用提供的电子邮件来搜索用户。如果我们在数据库中找到使用该电子邮件的用户，我们会向用户返回一个响应，告诉他该电子邮件id已经存在于我们的系统中，用户应该使用不同的电子邮件或使用该电子邮件登录，而不是注册。</p><p id="c472" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们使用从请求主体收到的名称、电子邮件和密码创建一个新的用户实例。我们不会将它保存到数据库中，因为我们需要在保存之前对密码进行哈希运算。</p><p id="6b0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们生成一个salt，然后使用该salt散列密码。然后，我们将散列值设置为密码，然后将<em class="ms"> newUser </em>实例保存在数据库中。</p><p id="c5a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在数据库中保存用户后，我们需要创建一个签名的JWT令牌，并将其存储在本地存储中。我们通过提供用户id、JWT秘密和到期时间来创建令牌。然后，我们发送令牌作为响应，同时发送不带密码的用户详细信息。</p><p id="6cad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这就是在我们的系统中注册一个新用户。</p><p id="4c6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们转到登录部分。它允许已经注册的用户登录我们的应用程序。</p><p id="1045" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是登录函数的代码，我们将其命名为<em class="ms">‘log in’。</em></p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="a903" class="pi na iq pe b be pj pk l pl pm">module.exports.login = async (req,res) =&gt; {<br/>    const { email, password } = req.body;<br/>    if(!email || !password){<br/>        res.status(400).json({msg: 'Please enter all fields'});<br/>    }<br/>    User.findOne({email})<br/>        .then(user =&gt; {<br/>            if(!user) return res.status(400).json({msg: 'User does not exist'});<br/><br/>            // Validate password<br/>            bcrypt.compare(password, user.password)<br/>                .then(isMatch =&gt; {<br/>                    if(!isMatch) return res.status(400).json({ msg: 'Invalid credentials'});<br/><br/>                    jwt.sign(<br/>                        { id: user._id },<br/>                        config.get('jwtsecret'),<br/>                        { expiresIn: 3600 },<br/>                        (err, token) =&gt; {<br/>                            if(err) throw err;<br/>                            res.json({<br/>                                token,<br/>                                user: {<br/>                                    id: user._id,<br/>                                    name: user.name,<br/>                                    email: user.email<br/>                                }<br/>                            });<br/>                        }<br/>                    )<br/>                })<br/>        })<br/>}</span></pre><p id="6ca2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与注册类似，我们从解构请求体开始，从中获取电子邮件和密码值。</p><p id="d44f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果两者中的任何一个缺失，我们会向用户发送一条消息，说明他们需要输入电子邮件和密码。</p><p id="1789" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用电子邮件id搜索用户。如果用户不存在，我们将向用户发送一个响应，声明该用户在数据库中不存在，他们应该在登录前首先注册。</p><p id="051d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将把提供的密码与数据库中的用户密码进行比较。您可能想知道我们将如何比较它们，因为我们在数据库中有散列密码。</p><p id="8b59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了进行比较，我们需要使用bcrypt的compare函数。它获取提供的密码，然后对其进行哈希处理，并将其与数据库中保存的哈希密码进行比较。如果它们不匹配，我们将返回一条消息，声明凭据无效。</p><p id="dc52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们以与注册函数中相同的方式创建一个签名的JWT令牌。然后，我们返回令牌以及用户的详细信息，但不提供密码。</p><p id="e2d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将处理<em class="ms"> get_user </em>函数。它通过id找到一个用户，然后返回不带密码的用户作为JSON响应。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="868a" class="pi na iq pe b be pj pk l pl pm">module.exports.get_user = (req,res) =&gt; {<br/>    User.findById(req.user.id)<br/>        .select('-password')<br/>        .then(user =&gt; res.json(user));<br/>}</span></pre><p id="8f07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是身份验证控制器文件的完整代码。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Auth controllers</figcaption></figure><h2 id="0872" class="nr na iq bd nb ns nt dn nf nu nv dp nj ko nw nx nl ks ny nz nn kw oa ob np oc bi translated">项目控制器</h2><p id="5724" class="pw-post-body-paragraph kf kg iq kh b ki od jr kk kl oe ju kn ko of kq kr ks og ku kv kw oh ky kz la ij bi translated">这个控制器文件将处理与项目相关的所有逻辑——添加项目、获取所有项目、删除项目或修改项目。</p><p id="18c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将由四个函数组成，我们拥有的四条路线各有一个函数，每个函数处理一个特定的目的。</p><p id="4d2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将详细讨论这四个功能中的每一个。我们只需要这个文件中的项目模型。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="3a49" class="pi na iq pe b be pj pk l pl pm">const Item = require('../models/Item');</span></pre><p id="74db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将从从数据库中获取所有项目的函数开始。我们将得到所有的项目，并按添加日期降序排列。然后，我们以JSON格式返回这些项目。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="3cdf" class="pi na iq pe b be pj pk l pl pm">module.exports.get_items = (req,res) =&gt; {<br/>    Item.find().sort({date:-1}).then(items =&gt; res.json(items));<br/>}</span></pre><p id="5be0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将处理向购物车添加新商品。我们将使用请求体作为新条目的输入，因为我们从前端发送请求体，格式与我们的模型相同。我们可以解构请求体，然后在为用户创建新项目时提供数据，但这是一种更干净的方式。</p><p id="fd50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将项目保存在数据库中，并以JSON格式发送新项目作为响应。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="60bd" class="pi na iq pe b be pj pk l pl pm">module.exports.post_item = (req,res) =&gt; {<br/>    const newItem = new Item(req.body);<br/>    newItem.save().then(item =&gt; res.json(item));<br/>}</span></pre><p id="d12b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将处理更新项目。我们通过请求体接收更新的信息，通过参数接收条目id。我们将使用函数<em class="ms"> findByIdAndUpdate </em>来搜索商品，并用新信息更新它。然后，我们发送更新的项目作为响应。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="15e6" class="pi na iq pe b be pj pk l pl pm">module.exports.update_item = (req,res) =&gt; {<br/>    Item.findByIdAndUpdate({_id: req.params.id},req.body).then(function(item){<br/>        Item.findOne({_id: req.params.id}).then(function(item){<br/>            res.json(item);<br/>        });<br/>    });<br/>}</span></pre><p id="7fba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们处理从数据库中删除项目。我们通过参数接收商品id。接下来，我们找到该项目，并使用<em class="ms"> findByIdAndDelete </em>函数删除它。然后我们返回一个成功的响应。</p><pre class="lc ld le lf gt pd pe pf bn pg ph bi"><span id="6d12" class="pi na iq pe b be pj pk l pl pm">module.exports.delete_item = (req,res) =&gt; {<br/>    Item.findByIdAndDelete({_id: req.params.id}).then(function(item){<br/>        res.json({success: true});<br/>    });<br/>}</span></pre><p id="deb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将总结我们的项目控制器部分。这是项目控制器的完整代码。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Item Controller</figcaption></figure><p id="d390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将处理一个定制的中间件函数来验证用户是否登录。</p><p id="9750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先需要文件中的配置和jwt。然后，我们开始制作认证中间件功能。</p><p id="5b94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从名为<em class="ms">‘x-auth-token’的请求头部分获得令牌。</em>如果没有令牌，那么我们将验证令牌，然后发送解码后的变量作为响应。</p><p id="99fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<em class="ms"> next() </em>函数，它允许我们继续下一个中间件函数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Auth middleware function</figcaption></figure><p id="0349" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是关于中间件功能的全部内容。我们已经涵盖了第三部分想要涵盖的所有内容。在第四部分，我们将处理购物车和订单的路线和控制器。在本系列的下一部分中，我们将使用Stripe Checkout来处理支付。</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">让我们建立一个MERN堆栈电子商务网络应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">第4部分:构建购物车并订购路线和控制器</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="me l"><div class="pn l mg mh mi me mj ll lv"/></div></div></a></div><p id="d6b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想访问这个项目的完整代码，请访问这个项目的<a class="ae lr" href="https://github.com/shubham1710/MERN-E-Commerce" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="b103" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢大家阅读这篇文章。希望你今天获得了一些真正的知识，学到了一些新东西。</p><p id="07fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成本系列后，还有更多的文章可供阅读:</p><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，以了解DRF和REST APIs是如何工作的，以及我们如何添加…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="po l mg mh mi me mj ll lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://towardsdatascience.com/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Django构建一个社交媒体网站——设置项目(第1部分)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在第一部分中，我们集中在设置我们的项目和安装所需的组件，并设置密码…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="pp l mg mh mi me mj ll lv"/></div></div></a></div></div></div>    
</body>
</html>