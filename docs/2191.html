<html>
<head>
<title>Make your own Storage Engine for Multer in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中为Multer创建自己的存储引擎</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/custom-storage-engine-for-multer-in-typescript-613ebd35d61e?source=collection_archive---------2-----------------------#2021-05-08">https://javascript.plainenglish.io/custom-storage-engine-for-multer-in-typescript-613ebd35d61e?source=collection_archive---------2-----------------------#2021-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/14ef703e2fbf6a75f261be1e60c142e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vpNeCukQIm-HH6rV"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danial Igdery</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="154f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在开始制作自己的存储引擎之前，让我们先讨论一下为什么我们需要它，以及它的一些应用。</p><blockquote class="lf lg lh"><p id="d68b" class="kh ki li kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le ig bi translated">下面是GitHub repo的<a class="ae jz" href="https://github.com/Aryaman1706/storage-engine-multer" rel="noopener ugc nofollow" target="_blank">链接</a>,用于下面的教程。</p></blockquote><p id="5e11" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">至此，我假设您已经清楚multer是什么以及它的用途。这里是对multer的“开箱即用”形式的快速介绍</p><p id="e4ca" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">所以基本上multer用于解析来自HTTP请求的数据，其中<br/> <code class="fe lm ln lo lp b">Content-Type</code>头设置为<code class="fe lm ln lo lp b">multipart/formdata</code>。HTTP请求中的Content-Type头描述了网络上共享的资源类型。这些资源需要特殊的中间件来解析并在服务器端应用程序中可用。<code class="fe lm ln lo lp b">application/json, application/x-form-www-urlencoded, text/html</code>的内容类型头可以通过<a class="ae jz" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank">主体解析器</a>解析，但是<code class="fe lm ln lo lp b">multipart/formdata</code>需要不同的中间件，即<a class="ae jz" href="https://www.npmjs.com/package/multer" rel="noopener ugc nofollow" target="_blank"> multer </a>。<code class="fe lm ln lo lp b">mutipart/formdata</code> Content-Type意味着除了JSON或纯文本数据之外，资源还可能有Blob或文件类型字段。没有这些中间件，我们将无法使用用户发送的资源。如果没有这些中间件，我们在express应用程序中如此随意使用的<code class="fe lm ln lo lp b">req.body</code>将总是返回一个空对象。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="123c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在我们对multer有了一个合理的想法，让我们讨论一下定制存储引擎的需求，并使用TypeScript制作一个。</p><h2 id="5e38" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">Multer中的存储引擎。</h2><p id="d203" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">存储引擎基本上是在文件被解析后对其进行处理的类，包括存储、删除和修改原始文件。默认情况下，multer附带2个存储引擎，DiskStorage和MemoryStorage。DiskStorage将文件存储在磁盘上的给定位置，而MemoryStorage将文件内容作为缓冲区存储在应用程序的内存中。</p><h2 id="662f" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">需要定制存储引擎。</h2><p id="4b09" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">multer附带的两个存储引擎对于一般情况很有用，但请想一想，您会将大型应用程序的文件存储在服务器的内存或磁盘中，还是宁愿使用Google Cloud Storage或Amazon S3这样的云存储选项？或者，您可能只想读取文件并将相关数据存储在数据库中，而不是保存整个文件。这就是为什么人们可能需要为multer编写自己的存储引擎。</p><p id="42e5" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，大多数东西可以通过内置的存储引擎本身来实现，但这种解决方案是乏味的，并增加了应用程序的负载。例如，你可能会在磁盘上保存一个文件，然后将其上传到云存储，然后删除该文件，但这就像是左转3次而不是右转，可能只有我一个人这样做，但这听起来像是太多的承诺和责任。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h2 id="a388" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">空谈不值钱，给我看看代码。</h2><p id="d148" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">希望现在您已经认识到multer中自定义存储引擎的重要性和使用案例，并准备好创建自己的存储引擎。我假设您对TypeScript有一个很好的想法，所以没有任何进一步的麻烦，让我们直接进入它。在本教程中，我们将制作一个存储引擎，将文件直接上传到Google云存储中。</p><h2 id="d016" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">项目设置</h2><p id="d873" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">创建一个文件夹，并在文件夹中运行以下命令来初始化package.json和typescript配置文件。</p><pre class="mo mp mq mr gt ms lp mt mu aw mv bi"><span id="4d76" class="lq lr in lp b gy mw mx l my mz"><strong class="lp io">$ npm</strong> init --y &amp;&amp; <strong class="lp io">tsc</strong> --init</span></pre><p id="67b1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">通过简单地编辑<code class="fe lm ln lo lp b">tsconfig.json</code>来配置您的typescript编译器，并按照配置中的指定创建根目录。我将把这个<code class="fe lm ln lo lp b">src</code>作为我的rootDir，<code class="fe lm ln lo lp b">lib</code>作为outDir。<a class="ae jz" href="https://github.com/Aryaman1706/storage-engine-multer/blob/main/tsconfig.json" rel="noopener ugc nofollow" target="_blank">这里的</a>是我的<code class="fe lm ln lo lp b">tscconfig.json</code>。</p><h2 id="9474" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">配置存储引擎</h2><p id="c9b5" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">现在，在<code class="fe lm ln lo lp b">src</code>里面添加一个新文件夹“config”和一个新文件“GcsEngine.ts”。存储引擎是具有两个负责操作文件的函数的类，这两个函数是<code class="fe lm ln lo lp b">_handleFile</code>和<code class="fe lm ln lo lp b">_removeFile</code>。<code class="fe lm ln lo lp b">_handleFile</code>负责操作/上传文件。这基本上是沉重的升降机和大部分工作将在这个功能只完成。另一方面<code class="fe lm ln lo lp b">_removeFile</code>负责删除文件，以防将来出现任何错误。</p><p id="b43a" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们的CustomStorageEngine将<a class="ae jz" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses" rel="noopener ugc nofollow" target="_blank">实现</a> multer的StorageEngine接口。所以基本上CustomStorageEngine应该匹配下面给出的<code class="fe lm ln lo lp b">multer.StorageEngine</code>的类型签名:-</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="aec7" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，让我们定义我们自己的实现上述接口的类。请记住，我们的类中定义的函数的类型签名也需要与上述类型相匹配。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4e2f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在继续之前，你应该知道的一件事是，在<code class="fe lm ln lo lp b">_handleFile</code>函数中，<code class="fe lm ln lo lp b">file</code>有一个属性<code class="fe lm ln lo lp b">stream</code>，它是node.js ReadableStream，这是我们将用来读取上传的文件并进一步处理它。</p><p id="98c2" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，我们需要定义这个类的一些成员。这些成员将有助于我们的文件处理。那么，让我们看看我们需要什么。<br/>首先，我们需要一种上传<code class="fe lm ln lo lp b">file</code>的方法，如前所述，我们可以通过<code class="fe lm ln lo lp b">file.stream</code>访问上传文件的数据，这是一个可读取的流，但是我们要在哪里以及如何将它上传到云存储呢？</p><p id="b270" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">为了上传<code class="fe lm ln lo lp b">file</code>，我们将首先使用云存储桶创建一个文件，然后使用这个在云上新创建的文件，我们将创建一个node.js WritableStream，此外，我们将通过管道将数据从<code class="fe lm ln lo lp b">file.stream</code>(一个ReadableStream)传输到新创建的WritableStream。迷茫？关于<a class="ae jz" href="https://cloud.google.com/storage/docs/how-to" rel="noopener ugc nofollow" target="_blank"> Google云存储</a>、<a class="ae jz" href="https://googleapis.dev/nodejs/storage/latest/" rel="noopener ugc nofollow" target="_blank"> Node.js云存储客户端</a>、<a class="ae jz" href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="noopener ugc nofollow" target="_blank">节点</a>中可读可写流的详细介绍，请参考这些链接。</p><p id="973c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">所以，现在很明显，我们需要云存储桶来处理文件的上传。但是，我们还需要上传文件的名称，以及创建可写流时所需的一些配置选项，这些选项在<a class="ae jz" href="https://googleapis.dev/nodejs/storage/latest/global.html#CreateWriteStreamOptions" rel="noopener ugc nofollow" target="_blank">此处</a>可用。好了，废话少说，让我们开始填充我们的自定义类。</p><h2 id="d626" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">构造函数</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a7ab" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在这里，我们已经完成了我们的类的构造函数，它需要一个类型为<code class="fe lm ln lo lp b">Options</code>的选项对象(opts)，这包括云存储桶、<code class="fe lm ln lo lp b">bucket </code>(必需的)、用于创建可写流的选项、<code class="fe lm ln lo lp b">options</code>(可选的)，以及一个文件命名函数、<code class="fe lm ln lo lp b">nameFn</code>(可选的)。<br/> <code class="fe lm ln lo lp b">nameFn</code>会拿请求(request)和文件(Express。Multer.File)作为参数，以便用户可以决定如何构造并返回文件的唯一名称。如果用户不提供自己的命名功能，那么我们将使用<code class="fe lm ln lo lp b">defaultNameFn</code>。现在让我们开始完成<code class="fe lm ln lo lp b">_handleFile</code>功能。</p><h2 id="5d18" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">_handleFile函数</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e963" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe lm ln lo lp b">_handleFile</code>函数中的回调函数(<code class="fe lm ln lo lp b">cb</code>)带两个参数，<code class="fe lm ln lo lp b">error</code>和<code class="fe lm ln lo lp b">info</code>。这里的<code class="fe lm ln lo lp b">info</code>是一个对象，包含关于文件的额外信息(在我们的例子中，是bucket中文件的名称)，需要添加到文件的元数据中，并通过<code class="fe lm ln lo lp b">req.file/req.files</code>提供给管道中的下一个请求处理程序。根据multer的类型定义。StorageEngine，这个<code class="fe lm ln lo lp b">info</code>对象必须扩展<code class="fe lm ln lo lp b">Partial&lt;Express.Multer.File&gt;</code>。<br/>除此之外，在<code class="fe lm ln lo lp b">_handleFile</code>函数中，我们首先使用<code class="fe lm ln lo lp b">nameFn</code>为文件获取一个唯一的名称，在桶中创建一个同名的新文件，从该文件获取可写流，并将数据从<code class="fe lm ln lo lp b">file.stream</code>通过管道传输到<code class="fe lm ln lo lp b">fileWriteStream</code>，如果出现错误，则关闭可写流并删除文件(如果文件存在)。如果数据写入成功，我们只需在上传文件的元数据中添加一个新字段<code class="fe lm ln lo lp b">name</code>。</p><h2 id="4c37" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">_removeFile函数</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e039" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe lm ln lo lp b">_removeFile</code>函数负责在将来出现错误时删除/移除文件。这个函数将接收到带有我们在<code class="fe lm ln lo lp b">_handleFile</code>(在我们的例子中是name)中添加的所有属性的<code class="fe lm ln lo lp b">file</code>。因此，简单地说，如果在桶中找到了这个文件，我们就用<code class="fe lm ln lo lp b">name = file.name</code>删除它。</p><h2 id="1fed" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">正在包装GcsEngine.ts</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="da75" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">最后，我们将导出一个接收类型为<code class="fe lm ln lo lp b">Options</code>的<code class="fe lm ln lo lp b">opts</code>的函数，该函数将用于创建并返回我们类的一个新对象。</p><h2 id="15c1" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">最后，这是我们的定制存储引擎:-</h2><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="baa4" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">Express服务器示例</h2><p id="d0ac" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">在<code class="fe lm ln lo lp b">src</code>中创建一个名为“example”的新文件夹，并将以下代码写入新文件“server.ts”。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="1b92" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">测试</h2><p id="c18e" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">打开终端，进入“src”中的“example”文件夹，运行以下命令启动服务器:-</p><pre class="mo mp mq mr gt ms lp mt mu aw mv bi"><span id="4f78" class="lq lr in lp b gy mw mx l my mz"><strong class="lp io">$ npx</strong> ts-node server.ts</span></pre><p id="f1fd" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">向<code class="fe lm ln lo lp b">http://localhost:5000/upload</code>发送post请求，并在名为“file”的字段中附加一个文件。我正在使用postman进行测试，这里有一个相同的快照</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/2a422ad39ff15cac924291a8851eb43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyq3KADOjAQ_p259n7DVog.png"/></div></div></figure><h2 id="be6d" class="lq lr in bd ls lt lu dn lv lw lx dp ly ks lz ma mb kw mc md me la mf mg mh mi bi translated">包扎</h2><p id="8442" class="pw-post-body-paragraph kh ki in kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ig bi translated">就是这样。我们为multer做了一个简单的自定义存储引擎，可以直接上传文件到Google云存储。这里是包含所有代码的GitHub repo的<a class="ae jz" href="https://github.com/Aryaman1706/storage-engine-multer" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><blockquote class="lf lg lh"><p id="f639" class="kh ki li kj b kk kl km kn ko kp kq kr lj kt ku kv lk kx ky kz ll lb lc ld le ig bi translated"><a class="ae jz" href="https://github.com/Aryaman1706/storage-engine-multer" rel="noopener ugc nofollow" target="_blank">在这个repo中，</a>我添加了一个验证器，在上传文件之前运行，以防止req.body无效时不必要的上传。我希望本教程简短而精确，因此我只在回购中做了一点额外的工作。</p></blockquote><p id="a43f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">此外，查看multer的官方指南，创建一个定制的存储引擎<a class="ae jz" href="https://github.com/expressjs/multer/blob/master/StorageEngine.md" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="bbd3" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">感谢您的阅读。祝您愉快！</p><p id="db21" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="li">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="li">plain English . io</em></a></p></div></div>    
</body>
</html>