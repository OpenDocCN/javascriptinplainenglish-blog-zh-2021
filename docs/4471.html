<html>
<head>
<title>Interview Question: The Principle of Implementing the Array Flat Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:阵列扁平化方法的实现原理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/interviewer-the-principle-of-implementing-the-flat-array-method-a3e776d48069?source=collection_archive---------11-----------------------#2021-09-06">https://javascript.plainenglish.io/interviewer-the-principle-of-implementing-the-flat-array-method-a3e776d48069?source=collection_archive---------11-----------------------#2021-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前段时间面试的时候，面试官问:如何实施扁平化方法？当时实现还不完善，后来发现有不少面试官要求手写数组的扁平化方法。其中包括小米、美团、滴滴、Shopee等。</p><p id="3c8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">手写平码法是一个很基础的面试题，通常在笔试或者第一轮面试中，主要考察基本的手写编码能力。今天，我们将重新学习array flat方法，从了解flat特性到实现flat，然后抓住面试官的一系列问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b691bc56cf2186e13eb906c884feff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEy-SbjAqrlJJ6jw7AodDQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Javascript array flat method</figcaption></figure><h1 id="fd70" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码摘要<code class="fe lw lx ly lz b">Array.prototype.flat()</code>功能</h1><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="c21a" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> animals = ["🐷", ["🐶", "🐂"], ["🐎", ["🐑", ["🐲"]], "🐛"]];</span><span id="b5df" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// default "flatten" once if no parameters are passed</em><br/>animals.flat();<br/><em class="mk">// ["🐷", "🐶", "🐂", "🐎", ["🐑", ["🐲"]], "🐛"]</em></span><span id="3d23" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// pass in an integer parameter, the number of "flattenings"</em><br/>animals.flat(2);<br/><em class="mk">// ["🐷", "🐶", "🐂", "🐎", "🐑", ["🐲"], "🐛"]</em></span><span id="e4af" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// The Infinity keyword is converted to a one-dimensional array when used as an argument, no matter how many levels of nesting</em><br/>animals.flat(Infinity);<br/><em class="mk">// ["🐷", "🐶", "🐂", "🐎", "🐑", "🐲", "🐛"]</em></span><span id="4c5f" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// passing in an integer &lt;= 0 will return the original array, not "flattened"</em><br/>animals.flat(0);<br/>animals.flat(-10);<br/><em class="mk">// ["🐷", ["🐶", "🐂"], ["🐎", ["🐑", ["🐲"]], "🐛"]];</em></span><span id="7f72" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// If the original array has empty space, the flat() method will skip the empty space.</em><br/>["🐷", "🐶", "🐂", "🐎",,].flat();<br/><em class="mk">// ["🐷", "🐶", "🐂", "🐎"]</em></span></pre><h1 id="3b1b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe lw lx ly lz b">Array.prototype.flat()</code>功能概述</h1><ul class=""><li id="bf4b" class="ml mm in jm b jn mn jr mo jv mp jz mq kd mr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">Array.prototype.flat()</code>用于将嵌套数组“展平”成一维数组。该方法返回一个新数组，对原始数据没有影响。</li><li id="b662" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">当没有传递参数时，默认是“展平”一个级别，可以传递一个整数来表示要“展平”的级别数。</li><li id="60a4" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">传递一个整数<code class="fe lw lx ly lz b">&lt;=0</code>将返回原始数组，而不会“展平”它。</li><li id="6dc4" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">当<code class="fe lw lx ly lz b">Infinity</code>关键字用作参数时，它将被转换为一维数组，而不管嵌套层数</li><li id="736f" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">如果原数组有空位，<code class="fe lw lx ly lz b">Array.prototype.flat()</code>将跳过这个空位。</li></ul><h1 id="ef6a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">面试官抓住了问题的核心</h1><h1 id="67d6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一个问题:实现简单的数组展平<code class="fe lw lx ly lz b">flat</code>函数</h1><p id="f69b" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">首先，我们将花一点时间探索如何实现一个简单的数组展平<code class="fe lw lx ly lz b">flat</code>函数，详细说明各种实现选项，然后尝试抓住面试官接二连三的问题。</p><h2 id="d8a2" class="me kz in bd la ne nf dn le ng nh dp li jv ni nj lm jz nk nl lq kd nm nn lu no bi translated">实施理念</h2><p id="c830" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">这个想法非常简单:用一个数组平面函数实现一个<code class="fe lw lx ly lz b">flat</code>函数，我们所要做的就是找到数组中数组类型的元素并扩展它们。这是实现<code class="fe lw lx ly lz b">flat</code>方法背后的关键思想。</p><p id="1f58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到这个想法，我们需要解决实施这个想法需要克服的困难。</p><ul class=""><li id="be7b" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated">要解决的第一个问题是遍历数组的每个元素；</li><li id="afc9" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">第二个问题是确定元素是否是数组；</li><li id="5f5b" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">第三个要解决的是将数组的元素扩展一层；</li></ul><h2 id="9cd8" class="me kz in bd la ne nf dn le ng nh dp li jv ni nj lm jz nk nl lq kd nm nn lu no bi translated">遍历数组的解决方案</h2><p id="7e7d" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">有很多方法可以迭代一个数组并获得它的元素，<strong class="jm io">包括但不限于下面的</strong>。</p><ul class=""><li id="ef7f" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">for loop</code></li><li id="d147" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">for.... .of</code></li><li id="5589" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">for... .in</code></li><li id="bd8f" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">forEach()</code></li><li id="0fc5" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">entries()</code></li><li id="9c7a" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">keys()</code></li><li id="4a4b" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">values()</code></li><li id="e08c" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">reduce()</code></li><li id="a8eb" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">map()</code></li></ul><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="6ebf" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }];</span><span id="b852" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// There are too many ways to iterate through an array, so this article will only enumerate the common ones</em></span><span id="9958" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// for loop</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> i = 0; i &lt; arr.length; i++) {<br/>  console.log(arr[i]);<br/>}</span><span id="2750" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// for...of</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> value <strong class="lz io">of</strong> arr) {<br/>  console.log(value);<br/>}</span><span id="0538" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// for...in</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> i <strong class="lz io">in</strong> arr) {<br/>  console.log(arr[i]);<br/>}</span><span id="fbd0" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// forEach loop</em><br/>arr.forEach(value =&gt; {<br/>  console.log(value);<br/>});</span><span id="6cd7" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// entries（）</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> [index, value] <strong class="lz io">of</strong> arr.entries()) {<br/>  console.log(value);<br/>}</span><span id="94a3" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// keys()</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> index <strong class="lz io">of</strong> arr.keys()) {<br/>  console.log(arr[index]);<br/>}</span><span id="a7aa" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// values()</em><br/><strong class="lz io">for</strong> (<strong class="lz io">let</strong> value <strong class="lz io">of</strong> arr.values()) {<br/>  console.log(value);<br/>}</span><span id="bfa5" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// reduce()</em><br/>arr.reduce((pre, cur) =&gt; {<br/>  console.log(cur);<br/>}, []);</span><span id="3441" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// map()</em><br/>arr.map(value =&gt; console.log(value));</span></pre><p id="abda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">任何可以遍历数组以获取数组中每个元素的方法都是可行的解决方案。</p><h2 id="378c" class="me kz in bd la ne nf dn le ng nh dp li jv ni nj lm jz nk nl lq kd nm nn lu no bi translated">判断元素是否为数组的一种方法</h2><ul class=""><li id="8a32" class="ml mm in jm b jn mn jr mo jv mp jz mq kd mr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">instanceof</code></li><li id="9a1b" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">constructor</code></li><li id="54e3" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">Object.prototype.toString</code></li><li id="0d8c" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">isArray</code></li></ul><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="54f5" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }];</span><span id="ef2e" class="me kz in lz b gy mj mg l mh mi">arr <strong class="lz io">instanceof</strong> Array<br/><em class="mk">// true</em></span><span id="5d88" class="me kz in lz b gy mj mg l mh mi">arr.constructor === Array<br/><em class="mk">// true</em></span><span id="23ca" class="me kz in lz b gy mj mg l mh mi">Object.prototype.toString.call(arr) === '[object Array]'<br/><em class="mk">// true</em></span><span id="dc38" class="me kz in lz b gy mj mg l mh mi">Array.isArray(arr)<br/><em class="mk">// true</em></span></pre><p id="a93b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">描述</strong>。</p><ul class=""><li id="be2c" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">instanceof</code>操作符假设只有一个全局环境。如果页面包含具有多个全局环境的多个框架，并且如果您将一个数组从一个框架传递到另一个框架，则传入的数组将拥有自己的独立构造函数，该构造函数来自第二个框架中本机创建的数组。(所以这种情况下会不准确)</li><li id="84ca" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">typeof</code>操作符接受数组的类型并返回<code class="fe lw lx ly lz b">object</code>。</li><li id="c765" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">因为<code class="fe lw lx ly lz b">constructor</code>可以被覆盖，所以不能保证它是一个数组。</li></ul><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="1aca" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> str = 'abc'; <br/>str.constructor = Array; <br/>str.constructor === Array  <em class="mk">// true</em></span></pre><h2 id="2c99" class="me kz in bd la ne nf dn le ng nh dp li jv ni nj lm jz nk nl lq kd nm nn lu no bi translated">将数组元素扩展一级的方案</h2><ul class=""><li id="6921" class="ml mm in jm b jn mn jr mo jv mp jz mq kd mr kh ms mt mu mv bi translated">扩展运算符+ <code class="fe lw lx ly lz b">concat</code></li></ul><p id="ea4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lw lx ly lz b">concat()</code>方法用于合并两个或多个数组，在串联中添加扩展运算符会将数组扩展一层。有关详细信息，请参见以下代码。</p><ul class=""><li id="ea1a" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">concat</code> + <code class="fe lw lx ly lz b">apply</code></li></ul><p id="77a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要使用<code class="fe lw lx ly lz b">apply</code>绑定作用域，第二个参数是一个数组或类似数组的对象，其中数组元素作为单独的参数传递给<code class="fe lw lx ly lz b">func</code>函数。也就是在调用<code class="fe lw lx ly lz b">apply</code>函数的过程中，传入的数组被一个一个的传入要执行的函数，相当于数组的一层扩展。</p><ul class=""><li id="a6f7" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">toString</code> + <code class="fe lw lx ly lz b">split</code></li></ul><p id="c240" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不推荐使用<code class="fe lw lx ly lz b">toString</code> + <code class="fe lw lx ly lz b">split</code>方法，因为操作字符串是一件危险的事情。如果数组中的所有元素都是数字，<code class="fe lw lx ly lz b">toString</code> + <code class="fe lw lx ly lz b">split</code>就可以了，而且是一步到位的过程。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b274" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }];</span><span id="1014" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// Expansion operator + concat</em><br/>[].concat(...arr)</span><span id="b921" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, "string", { name: "Bouncing iron eggs" }];</em></span><span id="c640" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// concat + apply</em><br/>[].concat.apply([], arr);<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, "string", { name: "Bouncing iron eggs" }];</em></span><span id="7b0b" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// toString  + split</em><br/><strong class="lz io">const</strong> arr2 =[1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]]]<br/>arr2.toString().split(',').map(v=&gt;parseInt(v))<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3]</em></span></pre><p id="116f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总结了要解决的三大难点之后，我们就可以非常容易地实现一个版本的<code class="fe lw lx ly lz b">flat</code>函数了。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="c824" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }];</span><span id="3cb6" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// concat + recursive</em><br/><strong class="lz io">function</strong> <strong class="lz io">flat</strong>(arr) {<br/>  <strong class="lz io">let</strong> arrResult = [];<br/>  arr.forEach(item =&gt; {<br/>    <strong class="lz io">if</strong> (Array.isArray(item)) {<br/>      arrResult = arrResult.concat(arguments.callee(item));   <br/>      <em class="mk">// recursive</em><br/>      <em class="mk">// or use the extended operator</em><br/>      <em class="mk">// arrResult.push(...arguments.callee(item));</em><br/>    } <strong class="lz io">else</strong> {<br/>      arrResult.push(item);<br/>    }<br/>  });<br/>  <strong class="lz io">return</strong> arrResult;<br/>}</span><span id="9805" class="me kz in lz b gy mj mg l mh mi">flat(arr)<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><p id="90e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至此，恭喜你成功获得面试官对你手撕代码能力的基本认可🎉。但是面试官往往会超越这一点，会继续看面试官的各种能力。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="e728" class="ky kz in bd la lb nz ld le lf oa lh li lj ob ll lm ln oc lp lq lr od lt lu lv bi translated">问题2:用<code class="fe lw lx ly lz b">reduce</code>实现<code class="fe lw lx ly lz b">flat</code>功能</h1><p id="733d" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">我见过很多面试官喜欢指名道姓，要求面试官直接用<code class="fe lw lx ly lz b">reduce</code>实现<code class="fe lw lx ly lz b">flat</code>功能。想知道为什么吗？当我们考虑空数组的情况时，我们将在本文后面看到原因。其实想法是一样的。</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="4080" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }]</span><span id="481b" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// First use reduce to expand a layer</em><br/>arr.reduce((pre, cur) =&gt; pre.concat(cur), []);<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, "string", { name: "Bouncing iron eggs" }];</em></span><span id="33d7" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// Expanding a layer with reduce + recursion</em><br/><strong class="lz io">const</strong> flat = arr =&gt; {<br/>  <strong class="lz io">return</strong> arr.reduce((pre, cur) =&gt; {<br/>    <strong class="lz io">return</strong> pre.concat(Array.isArray(cur) ? flat(cur) : cur);<br/>  }, []);<br/>};<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><h1 id="0d02" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题3:使用堆栈思想实现<code class="fe lw lx ly lz b">flat</code>函数</h1><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="cd99" class="me kz in lz b gy mf mg l mh mi"><em class="mk">// Stack Ideas</em><br/><strong class="lz io">function</strong> <strong class="lz io">flat</strong>(arr) {<br/>  <strong class="lz io">const</strong> result = []; <br/>  <strong class="lz io">const</strong> stack = [].concat(arr);  <br/>  <em class="mk">// Copy the array elements to the stack, direct assignment will change the original array</em><br/>  <em class="mk">// If the stack is not empty, the loop traverses</em><br/>  <strong class="lz io">while</strong> (stack.length !== 0) {<br/>    <strong class="lz io">const</strong> val = stack.pop(); <br/>    <strong class="lz io">if</strong> (Array.isArray(val)) {<br/>      stack.push(...val); <br/>      <em class="mk">// If the array is on the stack again, and a layer is expanded</em><br/>    } <strong class="lz io">else</strong> {<br/>      result.unshift(val); <br/>      <em class="mk">// If it's not an array, take it out and put it in the result array</em><br/>    }<br/>  }<br/>  <strong class="lz io">return</strong> result;<br/>}</span><span id="2ab5" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }]</span><span id="d065" class="me kz in lz b gy mj mg l mh mi">flat(arr)<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><h1 id="70c3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四个问题:通过传入整数参数来控制“调平”层的数量</h1><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="78d7" class="me kz in lz b gy mf mg l mh mi"><em class="mk">// reduce + recursive</em><br/><strong class="lz io">function</strong> <strong class="lz io">flat</strong>(arr, num = 1) {<br/>  <strong class="lz io">return</strong> num &gt; 0<br/>    ? arr.reduce(<br/>        (pre, cur) =&gt;<br/>          pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),<br/>        []<br/>      )<br/>    : arr.slice();<br/>}</span><span id="7d51" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }]</span><span id="80a3" class="me kz in lz b gy mj mg l mh mi">flat(arr, Infinity);<br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><h1 id="43c6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题5:使用<code class="fe lw lx ly lz b">Generator</code>实现<code class="fe lw lx ly lz b">flat</code>功能</h1><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="347a" class="me kz in lz b gy mf mg l mh mi"><strong class="lz io">function</strong>* <strong class="lz io">flat</strong>(arr, num) {<br/>  <strong class="lz io">if</strong> (num === undefined) num = 1;<br/>  <strong class="lz io">for</strong> (<strong class="lz io">const</strong> item <strong class="lz io">of</strong> arr) {<br/>    <strong class="lz io">if</strong> (Array.isArray(item) &amp;&amp; num &gt; 0) {   <em class="mk">// num &gt; 0</em><br/>      <strong class="lz io">yield</strong>* flat(item, num - 1);<br/>    } <strong class="lz io">else</strong> {<br/>      <strong class="lz io">yield</strong> item;<br/>    }<br/>  }<br/>}</span><span id="aa9f" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }]</span><span id="1278" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// When the Generator function is called, it does not execute and returns not the result of the function run, but a pointer object to the internal state.</em></span><span id="b799" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// That is, the Iterator Object. So we have to use the extension operator once to get the result</em></span><span id="5f50" class="me kz in lz b gy mj mg l mh mi">[...flat(arr, Infinity)]    <br/><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><h1 id="2be0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题6:在原型链上实现重写<code class="fe lw lx ly lz b">flat</code>函数</h1><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="356a" class="me kz in lz b gy mf mg l mh mi">Array.prototype.fakeFlat = <strong class="lz io">function</strong>(num = 1) {<br/>  <strong class="lz io">if</strong> (!Number(num) || Number(num) &lt; 0) {<br/>    <strong class="lz io">return</strong> this;<br/>  }<br/>  <strong class="lz io">let</strong> arr = this.concat();    <br/>      <em class="mk">// Get an array of calls to the fakeFlat function</em><br/>  <strong class="lz io">while</strong> (num &gt; 0) {           <br/>    <strong class="lz io">if</strong> (arr.some(x =&gt; Array.isArray(x))) {<br/>      arr = [].concat.apply([], arr);	<br/>      <em class="mk">// If there are still array elements in the array and num &gt; 0, continue to expand the array by one level </em><br/>    } <strong class="lz io">else</strong> {<br/>      <strong class="lz io">break</strong>; <br/>      <em class="mk">// Stops the loop if there are no array elements in the array and regardless of whether num is still greater than 0.</em><br/>    }<br/>    num--;<br/>  }<br/>  <strong class="lz io">return</strong> arr;<br/>};</span><span id="213e" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "Bouncing iron eggs" }]</span><span id="8783" class="me kz in lz b gy mj mg l mh mi">arr.fakeFlat(Infinity)</span><span id="a221" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "Bouncing iron eggs" }];</em></span></pre><h1 id="bd0d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题7:考虑空数组的情况</h1><p id="9708" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">从我们在开头总结的<code class="fe lw lx ly lz b">flat</code>特性我们知道，<code class="fe lw lx ly lz b">flat</code>函数是通过跳过空值来执行的，大多数处理空值的ES5数组方法都选择跳过，包括:<code class="fe lw lx ly lz b">forEach()</code>、<code class="fe lw lx ly lz b">filter()</code>、<code class="fe lw lx ly lz b">reduce()</code>、<code class="fe lw lx ly lz b">every()</code>和<code class="fe lw lx ly lz b">some()</code>。</p><p id="5b1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们可以用上面的方法来实现平面跳空特性</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="f1f8" class="me kz in lz b gy mf mg l mh mi"><em class="mk">// reduce + recursive</em><br/>Array.prototype.fakeFlat = <strong class="lz io">function</strong>(num = 1) {<br/>  <strong class="lz io">if</strong> (!Number(num) || Number(num) &lt; 0) {<br/>    <strong class="lz io">return</strong> this;<br/>  }<br/>  <strong class="lz io">let</strong> arr = [].concat(this);<br/>  <strong class="lz io">return</strong> num &gt; 0<br/>    ? arr.reduce(<br/>        (pre, cur) =&gt;<br/>          pre.concat(Array.isArray(cur) ? cur.fakeFlat(--num) : cur),<br/>        []<br/>      )<br/>    : arr.slice();<br/>};</span><span id="1a03" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, [3, 4], , ,];<br/>arr.fakeFlat()<br/><em class="mk">// [1, 3, 4]</em></span><span id="7f6b" class="me kz in lz b gy mj mg l mh mi"><em class="mk">// foEach + recursive</em><br/>Array.prototype.fakeFlat = <strong class="lz io">function</strong>(num = 1) {<br/>  <strong class="lz io">if</strong> (!Number(num) || Number(num) &lt; 0) {<br/>    <strong class="lz io">return</strong> this;<br/>  }<br/>  <strong class="lz io">let</strong> arr = [];<br/>  this.forEach(item =&gt; {<br/>    <strong class="lz io">if</strong> (Array.isArray(item)) {<br/>      arr = arr.concat(item.fakeFlat(--num));<br/>    } <strong class="lz io">else</strong> {<br/>      arr.push(item);<br/>    }<br/>  });<br/>  <strong class="lz io">return</strong> arr;<br/>};</span><span id="6b3b" class="me kz in lz b gy mj mg l mh mi"><strong class="lz io">const</strong> arr = [1, [3, 4], , ,];<br/>arr.fakeFlat()<br/><em class="mk">// [1, 3, 4]</em></span></pre><h1 id="6c88" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">延伸阅读:由于处理空格的规则非常不一致，建议避开。</h1><p id="99f0" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">ES5在处理空位时非常不一致，大多数情况下会忽略它们。</p><ul class=""><li id="a8c5" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">forEach()</code>、<code class="fe lw lx ly lz b">filter()</code>、<code class="fe lw lx ly lz b">reduce()</code>、<code class="fe lw lx ly lz b">every()</code>、<code class="fe lw lx ly lz b">some()</code>均跳过空位。</li><li id="7b31" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">map()</code>会跳过空格，但会保留值。</li><li id="35ad" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">join()</code>和<code class="fe lw lx ly lz b">toString()</code>将空位视为<code class="fe lw lx ly lz b">undefined</code>，而<code class="fe lw lx ly lz b">undefined</code>和<code class="fe lw lx ly lz b">null</code>则视为空字符串。</li></ul><p id="f875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ES6将空位显式转换为<code class="fe lw lx ly lz b">undefined</code>。</p><ul class=""><li id="9bf2" class="ml mm in jm b jn jo jr js jv np jz nq kd nr kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">entries()</code>、<code class="fe lw lx ly lz b">keys()</code>、<code class="fe lw lx ly lz b">values()</code>、<code class="fe lw lx ly lz b">find()</code>、<code class="fe lw lx ly lz b">findIndex()</code>会把空的位当作<code class="fe lw lx ly lz b">undefined</code>。</li><li id="6316" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">for... . of</code>循环将在空白空间中迭代。</li><li id="3db1" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">fill()</code>将空白视为正常的数组位置。</li><li id="b354" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">copyWithin()</code>会将空位一起复制。</li><li id="1f5b" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">扩展运算符(<code class="fe lw lx ly lz b">... </code>)也会将空白转换成<code class="fe lw lx ly lz b">undefined</code>。</li><li id="094d" class="ml mm in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><code class="fe lw lx ly lz b">Array.from</code>方法获取数组的空位，并将其转换为<code class="fe lw lx ly lz b">undefined</code>。</li></ul><h1 id="ede1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="53df" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">面试官看的是一个写代码的题目，但不仅仅是写代码，还有各种知识点和代码边界案例。虽然大多数情况下面试官不会变态到<code class="fe lw lx ly lz b">flat</code>实现来连续追面试官撕几个版本，但是面试官会要求根据你写的版本写一个更完美的代码版本是常有的事。无论面试官问多少问题，只有我们埋头于基本问题，我们才会回答得舒服。<code class="fe lw lx ly lz b">flat</code>的实现绝对不是文中列出的唯一版本，敲出自己的代码才是最好的进步，在评论区写自己的版本吧！</p><blockquote class="oe of og"><p id="59c2" class="jk jl mk jm b jn jo jp jq jr js jt ju oh jw jx jy oi ka kb kc oj ke kf kg kh ig bi translated"><em class="in">觉得有用就跟我来❤ </em></p></blockquote><p id="920a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">更多内容请看</em><a class="ae ok" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>