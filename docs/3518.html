<html>
<head>
<title>How Do Closures and Hoisting Work in JavaScript Under the Hood?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包和提升是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-do-closures-and-hoisting-work-in-javascript-under-the-hood-dabbc17c8897?source=collection_archive---------7-----------------------#2021-07-15">https://javascript.plainenglish.io/how-do-closures-and-hoisting-work-in-javascript-under-the-hood-dabbc17c8897?source=collection_archive---------7-----------------------#2021-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bae2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">精通闭包和吊装，擅长JavaScript面试准备。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ba49e9cf86c53c0f387cad6caad477c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*gg3maLFZdaoMej_fU4jWmA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 1: Crushing JS Interview by understanding Closure and Hoisting</figcaption></figure><p id="17e4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在技术面试中被问到的最重要的问题之一是关于关闭和提升。关于关闭和提升有一些相当棘手的问题；因此，这篇文章将涵盖从基础到高级的<strong class="ku io">关闭和提升，</strong>这样下次你在技术面试中被问到这些话题时，你就能毫无停顿地表现出色。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/7a15727df0e809870347667e9e456135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UDzgsQXxvWyJ0NQ8xp27ZA.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 2: You may have heard about it, or even used it, but wasn’t sure about the concept</figcaption></figure><h1 id="eab1" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">我们开始吧！什么是终结？</strong></h1><p id="be5d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">简单来说，我们举一个大圈里面的小圈的例子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/cc712967672d18f8fb25cf3cd5f8f9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*py6WSdlvRGwsi5ycLbvDlA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 3: Nested Circles / Nested Functions</figcaption></figure><p id="d9cd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在上图中，圆1，即圆2中的嵌套圆。Circle 1可以访问Circle 2中定义的所有元素/属性，因为Circle 2是其父Circle。闭包基于相同的概念。<strong class="ku io"> <em class="mn">内部函数可以访问父函数中定义的作用域(可以是变量或其他属性)。</em> </strong>我们来看下面的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="88ac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上述代码的预期结果是什么？</p><p id="5631" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> Ans。</strong>是的！你一定是猜对了；输出为<strong class="ku io"> 2。</strong>这就是闭包的概念。在上面的例子中,`<strong class="ku io"> innerFunction </strong>`(在第3行)可以访问在<strong class="ku io"> outerFunction </strong>中定义的所有属性。</p><p id="3f20" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">outerFunction可以访问innerFunction中的所有属性吗？让我想想…</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1739" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">好的，上面代码的结果是:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="7584" class="mv lq in mr b gy mw mx l my mz">ReferenceError: anotherOuterVariable is not defined</span></pre><p id="4c74" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由此可见，innerFunction可以访问外层函数/父函数的属性/变量，但父函数/外层函数不能访问嵌套函数的属性。</p><p id="5e7c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，我们知道了这个概念，但是闭包是如何在引擎盖下工作的呢？JavaScript如何处理这个问题？</p><blockquote class="na nb nc"><p id="bbaa" class="ks kt mn ku b kv kw jo kx ky kz jr la nd lc ld le ne lg lh li nf lk ll lm ln ig bi translated">根据Mozilla文档中给出的定义，闭包让您可以访问外部函数的作用域。</p></blockquote><p id="60e7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们在浏览器开发工具中看到这一点:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9abc00cf76573c6b835813dbadde31a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*ufBNUoGqw-w3Q3BE-ibphw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 4: Developer Tool in Source Tab</figcaption></figure><p id="b795" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如您在上面的图片中所看到的，闭包就像是在作用域(词法环境)中定义的另一个函数。它包含父函数的所有变量值。</p><p id="561a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">您可能在日常的Javascript编程中使用过它，比如当一个函数通过点击按钮(onClick)或任何其他基于事件的调用而被触发时。闭包在前端和后端开发中都有很多应用。它还有助于封装(在本文中我不会深入讨论它的用法)。</p><p id="d15f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是另一种情况，对<strong class="ku io"> <em class="mn">外部函数</em> </strong>进行了两次不同的函数调用。</p><p id="635a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">外部变量</strong>的期望值应该是多少？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d2fe" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">行号(11)的输出可以是<strong class="ku io"> 3 </strong>吗？</p><p id="b210" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">不，</strong>每个函数调用都有它的词法环境。简单来说，每个函数调用都有自己的作用域，每个作用域都有不同的闭包；第二个函数调用(即第11行)有不同的闭包，因此<strong class="ku io">外部变量</strong>的值也不同。因此，第一和第二控制台的输出都是<strong class="ku io"> 2。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2eef2f60de46c3e5d42518c28aff50f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*iZn2U2wHFHHkZUKPBh_UUQ.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 5: Vola, you got the Closures.</figcaption></figure></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><h1 id="d2f8" class="lp lq in bd lr ls np lu lv lw nq ly lz jt nr ju mb jw ns jx md jz nt ka mf mg bi translated">到目前为止，一切顺利！现在，什么是提升？</h1><p id="2335" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><strong class="ku io">吊装这个词是什么意思？</strong></p><blockquote class="na nb nc"><p id="17ae" class="ks kt mn ku b kv kw jo kx ky kz jr la nd lc ld le ne lg lh li nf lk ll lm ln ig bi translated">根据谷歌搜索:提高或拖走。</p></blockquote><p id="b884" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是等等！和JavaScript中的提升有什么关系？</p><p id="d60a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="mn">在JavaScript中，提升意味着将变量或函数声明拉到作用域的顶部。但是，JavaScript只提升声明，不提升初始化。</em>T11】</strong></p><p id="d744" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们来看看实际情况:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="02fb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在上面的代码中，输出应该是什么？</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="3842" class="mv lq in mr b gy mw mx l my mz">Testing Hoisting</span></pre><p id="0bca" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">相当简单！现在，下面的代码会有什么结果呢？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c760" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上述代码的输出是:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="2aed" class="mv lq in mr b gy mw mx l my mz">Undefined</span></pre><p id="f002" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">那么为什么输出<strong class="ku io">未定义</strong>而不是<strong class="ku io">引用错误:测试未定义？</strong></p><p id="78a7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">答案是，在JavaScript中，代码执行分两个阶段完成:</p><p id="a78a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第一个阶段是变量声明，它将内存分配给变量；然而，它并没有给变量赋值，变量<em class="mn">声明</em>在任何代码执行之前被处理。</p><p id="55b9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第二阶段是变量赋值；在这个阶段，值被分配给变量。</p><p id="3717" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">记住，所有变量和函数声明都被提升到JavaScript代码的调用堆栈跟踪的顶部。因此，在上面的代码中，它给出了<strong class="ku io"> <em class="mn">未定义的</em> </strong>输出，因为在函数的调用堆栈中，它已经将内存分配给了那个变量；但是，没有给它赋值。这就是为什么它没有给出引用错误，但给出了未定义的错误。</p><p id="652c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以在浏览器的开发者工具中的全局窗口的源代码选项卡中看到这一点:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/bc6fcbebf9474a25a5ef228634918835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Il_Cfp3td04Lg1GbwQZi0A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 6: Developers Tool: Global Window</figcaption></figure><p id="65a2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，让我们通过添加一个命名函数调用来修改上面的例子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fa9b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在上面的代码中，我已经在第<strong class="ku io"> 2 </strong>行添加了命名函数调用<strong class="ku io"> test </strong>，那么上面代码的预期结果应该是什么呢？</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="a803" class="mv lq in mr b gy mw mx l my mz">Inside the Function<br/>Testing Hoisting</span></pre><p id="1a38" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">简单！首先打印变量，然后打印函数调用的返回值。现在让我们看看下面代码中棘手的部分:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="52b5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你能猜出上面代码的结果吗？</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="f531" class="mv lq in mr b gy mw mx l my mz">Undefined<br/>Inside the Function</span></pre><p id="7f23" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">哇哦。为什么函数调用被正确执行并返回了值，即使变量返回了undefined？</p><p id="8a97" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">嗯！你知道第一个的原因。如上所述，第1行返回未定义的<br/>。但是，函数调用，即第2行返回“函数内部”，因为命名函数声明作为完整的函数存储在内存中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/98937adf658cbc7300ed7324ca5b0706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79VrlP8XxgmbUljiZHTEhQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 7: Developers Source Tool</figcaption></figure><p id="8f9f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">上面的图像是运行脚本时从浏览器开发人员控制台获取的全局窗口；可以看到，在箭头1上，有一个包含函数调用的<strong class="ku io"> test </strong>属性，然而对于箭头2，即<strong class="ku io"> test_variable函数</strong>，它包含<strong class="ku io"> undefined </strong>值，就像在JavaScript中一样，它将所有声明提升或拉到顶部，然而不是赋值，因为test_variable是赋值，所以它没有被提升。这就是函数返回值，但变量返回未定义的原因。</p><p id="717f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，如果你将使用一个箭头函数或将一个函数赋给一个变量，那么它也将返回<strong class="ku io"> <em class="mn"> undefined。</em>T9】</strong></p><p id="15c9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> #带“let”和“const”的边缘格</strong></p><p id="6c81" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">虽然当使用let和const时，输出会有所不同。</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="e00b" class="mv lq in mr b gy mw mx l my mz">let and const</span></pre><p id="2322" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看下面的实际情况:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/d9a349e024ec623c66b654e98f814988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3jCpJDO2S2EkhBihljTRA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Developers Tool Source “let” variable</figcaption></figure><p id="da4d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果对变量使用let或const，那么它会给出<strong class="ku io">引用错误</strong>而不是未定义的<strong class="ku io">。</strong>在我们的示例中,‘test _ variable’将仅在评估行号(4)时被初始化。对于<strong class="ku io">变量</strong>，情况并非如此。</p><h2 id="5b87" class="mv lq in bd lr nx ny dn lv nz oa dp lz lb ob oc mb lf od oe md lj of og mf oh bi translated">吊装总结:</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fec09025bf8ce5dd3442c6cac6de759b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*RtbNqulcdbu__hLFGSy46g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image 8: Hoisting in JS (Variable vs Named Function Comparison)</figcaption></figure></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="b952" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">总结！</strong></p><p id="6744" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">封闭和提升都是重要的基本概念，都有一些边缘情况。我尝试用JavaScript演示了闭包和提升的基本工作流程，这可能会在面试过程中和使用JavaScript开发项目时对你有所帮助。</p><p id="dd2a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我希望你从这篇文章中学到了一些东西。请留下同样的反馈。享受编码，享受JS！</p><p id="cb65" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">参考文献:</strong></p><p id="4262" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">图像1、2、5:图像生成工具来源:<a class="ae oj" href="https://imgflip.com/" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/</a></p><p id="33b2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="mn">更多内容请看</em><a class="ae oj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="mn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>