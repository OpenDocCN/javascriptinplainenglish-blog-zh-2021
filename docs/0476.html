<html>
<head>
<title>Using the useCallback React hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用useCallback React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-usecallback-react-hook-1145e957518c?source=collection_archive---------8-----------------------#2021-01-28">https://javascript.plainenglish.io/using-the-usecallback-react-hook-1145e957518c?source=collection_archive---------8-----------------------#2021-01-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fd2dfc2c97c2499e4933e8eef7dd0d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eyoEX74SAjIXGa0P.png"/></div></div></figure><p id="42ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">useCallback React挂钩是一个有用的挂钩，可以帮助优化我们的函数式React组件的呈现性能。它用于记忆函数，这意味着它缓存给定一组输入参数的函数的返回值。</p><h1 id="83ab" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">语法</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1523" class="ma ku in lw b gy mb mc l md me">const memoizedCallback = useCallback(<br/>  () =&gt; {<br/>    functionToBeMemoized(arg);<br/>  },<br/>  [arg],<br/>);</span></pre><p id="ac02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，useCallback React钩子接受一个内联函数及其依赖项作为参数，并返回该函数的一个记忆版本。只有当传递的依赖项之一发生变化时，返回的记忆化函数才会发生变化。因此，如果输入参数相同，则保证具有相同的参考值。</p><p id="205c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们希望将回调作为道具传递给子组件，并希望优化组件以避免重新渲染时，这很有用，因为React依赖于道具的引用相等性。对于给定的一组参数，记忆化的函数将具有相同的引用，从而避免重新呈现。</p><p id="fc06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们进入useCallback React钩子的应用之前，我们应该知道React本身是相当快的，我们应该避免任何过早的优化，并且只在我们需要的时候使用这个钩子。</p><p id="6960" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与<a class="ae mf" href="https://www.wisdomgeek.com/development/web-development/react/understanding-the-useref-react-hook/" rel="noopener ugc nofollow" target="_blank"> useEffect </a>依赖项一样，如果我们传入一个空的依赖项数组，那么记忆化的函数只计算一次。它将在组件的整个生命周期中存储相同的引用。</p><h1 id="6159" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用useCallback React挂钩</h1><p id="a2cf" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">让我们考虑这样一个组件，它涉及大量的计算，并且重新渲染的成本很高:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8799" class="ma ku in lw b gy mb mc l md me">const ExpensiveToComputeComponent = () =&gt; {<br/> // expensive computation<br/>};</span></pre><p id="7463" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这个组件接受一个处理函数作为道具，并且父组件在处理函数中提供给它:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6925" class="ma ku in lw b gy mb mc l md me"> const App = () =&gt; {<br/>  const handler = () =&gt; {<br/>  // do something<br/>  };<br/>  return &lt;ExpensiveToComputeComponent handler = {handler} /&gt;;<br/>}<br/>const ExpensiveToComputeComponent = ({handler}) =&gt; {<br/> // expensive computation<br/>};</span></pre><p id="a9db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任何时候应用程序被重新渲染，那么昂贵的计算组件也会被重新渲染。这是因为我们以处理程序的形式提供了回调函数。每次重新呈现应用程序时，对它的引用都会改变。</p><p id="ee2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使我们使用<a class="ae mf" href="https://www.wisdomgeek.com/development/web-development/react/using-react-memo-in-react-16-6/" rel="noopener ugc nofollow" target="_blank"> React.memo </a>来记忆昂贵的组件:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7c9f" class="ma ku in lw b gy mb mc l md me">const ExpensiveToComputeComponent = React.memo(({handler}) =&gt; {<br/> // expensive computation<br/>});</span></pre><p id="1173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果会是一样的。重新呈现发生是因为处理函数在改变，而memo不会改变它。为了保持处理程序回调函数不变，我们需要使用useCallback React钩子。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="22a8" class="ma ku in lw b gy mb mc l md me">const App = () =&gt; {<br/>  const handler = useCallback(() =&gt; {<br/>  // do something<br/>  }, [dependencies]);<br/>  return &lt;ExpensiveToComputeComponent handler = {handler} /&gt;;<br/>}</span></pre><p id="8667" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样需要注意的是，如果依赖项也是动态的(引用类型)，那么useCallback React钩子的返回值也将是动态的。所以我们要么想让它们成为值类型，要么再次对它们使用useCallback。尽管建议避免嵌套回调，并且有更好的方法来处理这个问题。还建议安装<a class="ae mf" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-react-hooks插件</a>以避免此类问题并实施最佳实践。</p><p id="2809" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，useCallback React钩子在记忆函数中是有用的。获得性能增益是有用的，但应该明智地使用。在开始优化之前，我们应该使用分析器。正如我们所看到的，当与React Memo API结合使用时，它会大放异彩。</p><p id="c7d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您有任何疑问，或者对我们接下来应该涵盖的内容有任何建议，请在下面留言，让我们知道！</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="1014" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ms">原载于2021年1月28日</em><a class="ae mf" href="https://www.wisdomgeek.com/development/web-development/react/using-the-usecallback-react-hook/" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p></div></div>    
</body>
</html>