<html>
<head>
<title>Vanilla Hooks (outside React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">香草挂钩(外部反应)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vanilla-hooks-outside-react-860471e5f95c?source=collection_archive---------9-----------------------#2021-01-04">https://javascript.plainenglish.io/vanilla-hooks-outside-react-860471e5f95c?source=collection_archive---------9-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/feb13b2f804d5814a9f8f6f4d84c993b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9aLpt7mLTUnnwHQ1saISw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@vishu_2star?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Vishal Jadhav</a> on <a class="ae jz" href="https://unsplash.com/s/photos/hook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0f0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">钩子是一种模式，而不是只能在React库中使用的东西，这篇文章将解释并介绍一些有趣的可能性。</p><h1 id="0f1f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是钩子？</h1><p id="7373" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">钩子不多也不少，就是一个通用回调的包装。回调本身不是一个钩子，除非它被一个钩子助手处理，在这种情况下是由<a class="ae jz" href="https://github.com/WebReflection/uhooks#readme" rel="noopener ugc nofollow" target="_blank">钩子</a>库提供的，这是我所知道的最小、最快的库，并且“<em class="mb">它只是工作</em>”。</p><p id="2533" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举例来说，这是一个内部使用一些钩子辅助程序的通用回调，但是它不会像预期的那样工作，除非它被钩子库辅助程序所包装。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6222" class="ml kz in mh b gy mm mn l mo mp">// not a hook until wrapped<br/>const callback = (initial) =&gt; {<br/>  const [value, update] = useState(initial);<br/>  console.log(value);<br/>  setTimeout(update, 1000, value + 1);<br/>};</span></pre><p id="1c11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是要记住，除非作为助手本身使用，回调不能受益于钩子助手，因为这些回调需要被编排。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3fa0" class="ml kz in mh b gy mm mn l mo mp">import {hooked, useState} from '//unpkg.com/uhooks?module';</span><span id="649c" class="ml kz in mh b gy mq mn l mo mp">// this is now a hook<br/>const incrementalState = hooked(callback);</span><span id="5a7d" class="ml kz in mh b gy mq mn l mo mp">// and it can be initialized as such<br/>incrementalState(0);</span></pre><p id="0394" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个<a class="ae jz" href="https://codepen.io/WebReflection/pen/rNMdJom?editors=0011" rel="noopener ugc nofollow" target="_blank"> CodePen示例</a>中读取控制台日志，会显示一个从<em class="mb"> 0 </em>到<em class="mb"> N </em>的递增计数器，这正是我们所期望的。</p><h2 id="2cdb" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">它是如何工作的？</h2><p id="821c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这个故事的简短版本是，每次由<code class="fe nc nd ne mh b">useState</code>助手提供的<code class="fe nc nd ne mh b">update</code>函数执行时，被挂钩的回调被再次调用，并且<code class="fe nc nd ne mh b">useState</code>助手将知道，在运行时，返回的最后更新的值是什么，忽略第一次这样的挂钩被执行时提供的<code class="fe nc nd ne mh b">initial</code>值。</p><p id="c379" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个极简的钩子实现和解释也可以在这个要点中找到。</p><p id="2936" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">故事的长版本是在我的旧帖子中描述的<a class="ae jz" href="https://webreflection.medium.com/demystifying-hooks-f55ad885609f" rel="noopener">，但是没有必要理解所有的内部机制，但是有必要记住每个钩子都需要被处理一部分，这样从零开始并行记录，例如，我们不能再次调用<code class="fe nc nd ne mh b">incrementalState(0)</code>，因为我们需要通过同一个助手创建一个新的钩子。</a></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="11a1" class="ml kz in mh b gy mm mn l mo mp">const parallelState = hooked(callback);</span></pre><p id="4d2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数学很简单:一个钩子等于一个回调包装，而且只有一个。</p><p id="fef8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以手动调用钩子任意多次，但是初始化的状态将总是反映它们的当前值，因此调用<code class="fe nc nd ne mh b">incrementalState(123)</code>将不会记录、重置或启动当前计数或它的值，它只会创建一个新的<code class="fe nc nd ne mh b">setTimeout</code>，因此现在每件事每秒记录两次。</p><p id="94fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以随便玩之前的CodePen自己测试一下。</p><h1 id="bd5f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">钩子和DOM元素</h1><p id="3ee9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我很确定用一个愚蠢的计数器来展示钩子很容易让人厌烦，但是这已经是钩子工作方式的"<em class="mb"> ABC </em>"了，我们可以探索一些其他的助手来创建独立的DOM元素，在本例中，<code class="fe nc nd ne mh b">useRef</code>:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fe22" class="ml kz in mh b gy mm mn l mo mp">const useElement = (name, attributes = {}) =&gt; {<br/>  const ref = useRef(null);<br/>  return ref.current || (ref.current = Object.assign(<br/>    document.createElement(name),<br/>    attributes<br/>  ));<br/>};</span></pre><p id="0f2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne mh b">useRef</code>是我们一次创造任何需要的好帮手。它的初始值将被存储到一个总是相同的对象引用中，并作为<code class="fe nc nd ne mh b">current</code>属性。</p><p id="7081" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这是一个助手，而不是一个<em class="mb">钩子</em>本身，所以没有必要将其包装为<em class="mb">钩子</em>函数，因为它将在钩子函数中使用:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="da03" class="ml kz in mh b gy mm mn l mo mp">const Button = attributes =&gt; hooked(text =&gt; {<br/>  const element = useElement('button', attributes);<br/>  const [count, update] = useState(0);<br/>  element.textContent = `${text} clicked ${count}`;<br/>  element.onclick = () =&gt; update(count + 1);<br/>  return element;<br/>});</span><span id="651c" class="ml kz in mh b gy mq mn l mo mp">const simple = Button({className: 'simple'});<br/>const complex = Button({className: 'complex'});</span><span id="198e" class="ml kz in mh b gy mq mn l mo mp">document.body.append(<br/>  simple('simple button'),<br/>  complex('complex button')<br/>);</span></pre><p id="3fa9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次的<a class="ae jz" href="https://codepen.io/WebReflection/pen/MWjVVeo?editors=0010" rel="noopener ugc nofollow" target="_blank">现场演示</a>展示了两个计数器(<em class="mb">我知道，还是很无聊…请原谅我</em>)，需要理解的重要一点是，一旦创建了一个元素，它将始终是完全相同的元素:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fdc9" class="ml kz in mh b gy mm mn l mo mp">console.log(<br/>  simple('simple button') ===<br/>  simple('simple button')<br/>); // true</span></pre><p id="b049" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过<code class="fe nc nd ne mh b">simple('just simple')</code>更新它的前缀内容，它仍然是完全相同的元素。</p><h1 id="61de" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">反应状态</h1><p id="7e11" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">由于我们已经通过钩子引入了组件定义，并且由于计数甚至还不是真实世界的用例，我们已经可以找到一种方法来避免为每个单独的状态写满<code class="fe nc nd ne mh b">useState</code>,而是处理一个提供状态细节的对象，它能够轻松地更新当前状态:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3962" class="ml kz in mh b gy mm mn l mo mp">const {defineProperties} = Object;<br/>const useReactive = object =&gt; {<br/>  const properties = {};<br/>  for (const key in object) {<br/>    const [value, set] = useState(object[key]);<br/>    properties[key] = {get: () =&gt; value, set};<br/>  }<br/>  return defineProperties({}, properties);<br/>};</span></pre><p id="ff19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了上面的助手，<code class="fe nc nd ne mh b">Button</code>组件工厂可以以更易读的方式进行简化，这也可以扩展到其他属性:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6025" class="ml kz in mh b gy mm mn l mo mp">const Button = attributes =&gt; hooked(text =&gt; {<br/>  const element = useElement('button', attributes);<br/>  const state = useReactive({count: 0});<br/>  element.textContent = `${text} clicked ${state.count}`;<br/>  element.onclick = () =&gt; state.count++;<br/>  return element;<br/>});</span></pre><p id="5db2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://codepen.io/WebReflection/pen/abmYYQX?editors=0010" rel="noopener ugc nofollow" target="_blank">查看这个现场演示</a>来玩这个模式。</p><h1 id="1e5f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">处理事件</h1><p id="94db" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">类似地，由于我们可以轻松地处理更多的状态，我们也可以处理更多的事件，这里有一个小问题:</p><ul class=""><li id="89aa" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated">DOM级事件既容易设置，如<code class="fe nc nd ne mh b">element.onclick = thingy</code>，也容易处理，因为每个元素只能设置一个0级事件，所以我们的组件很容易泄漏它的侦听器，或者由于一些其他脚本事件覆盖而从不反应</li><li id="9f61" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">跟踪以前的侦听器，以便在每次状态更新时删除和替换这些侦听器，这是一项繁琐且容易出错的工作</li></ul><p id="0e33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了帮助解决这些痛点，有一个伟大的<a class="ae jz" href="https://webreflection.medium.com/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38" rel="noopener"> <em class="mb"> handleEvent </em> </a>标准，它将允许我们永远不用关心跟踪以前的侦听器，因为如果处理程序总是相同的，不会发生两次或更多次:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6aba" class="ml kz in mh b gy mm mn l mo mp">const {defineProperties} = Object;<br/>const useHandler = (element, handler) =&gt; {<br/>  const ref = useRef(null);<br/>  // update the user handler each time<br/>  if (ref.current)<br/>    ref.current._ = handler;<br/>  // but create the real handler once<br/>  else<br/>    ref.current = {<br/>      _: handler,<br/>      handleEvent(e) {<br/>        this._[e.type](e);<br/>      }<br/>    };<br/>  // so that adding it N times won't result in N events<br/>  for (const key in handler)<br/>    element.addEventListener(key, ref.current);<br/>};</span></pre><p id="172e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了上面的助手，<code class="fe nc nd ne mh b">Button</code>工厂现在看起来会是这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e1ca" class="ml kz in mh b gy mm mn l mo mp">const Button = attributes =&gt; hooked(text =&gt; {<br/>  const state = useReactive({count: 0});<br/>  const element = useElement('button', attributes);<br/>  useHandler(element, {<br/>    click() {<br/>      state.count++;<br/>    }<br/>  });<br/>  element.textContent = `${text} clicked ${state.count}`;<br/>  return element;<br/>});</span></pre><p id="ed0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请随意<a class="ae jz" href="https://codepen.io/WebReflection/pen/abmYYrM?editors=0010" rel="noopener ugc nofollow" target="_blank">播放相关的现场演示</a>。</p><h1 id="2bad" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">组合助手</h1><p id="c92f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果经常使用两个助手，并且有办法消除它们的意图的歧义，那么将这些助手放在一起可能是一个好的解决方案，这样可以避免每次都重复相同的代码。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="04dc" class="ml kz in mh b gy mm mn l mo mp">const {defineProperties} = Object;<br/>const useReactiveHandler = (element, object) =&gt; {<br/>  const ref = useRef(null);<br/>  // create the real handler once<br/>  if (!ref.current)<br/>    ref.current = {<br/>      _: {},<br/>      handleEvent(e) {<br/>        _[`on${e.type}`](e);<br/>      }<br/>    };<br/>  const {_} = ref.current;<br/>  const properties = {};<br/>  for (const key in object) {<br/>    // listeners prefixed via on<br/>    if (/^on/.test(key)) {<br/>      element.addEventListener(key.slice(2), ref.current);<br/>      _[key] = object[key];<br/>    }<br/>    // methods simply copied over<br/>    else if (typeof object[key] === 'function')<br/>      _[key] = object[key];<br/>    // properties made reactive<br/>    else {<br/>      const [value, set] = useState(object[key]);<br/>      properties[key] = {<br/>        configurable: true,<br/>        get: () =&gt; value,<br/>        set<br/>      };<br/>    }<br/>  }<br/>  return defineProperties(_, properties);<br/>};</span></pre><p id="4e2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了上面的助手，我们现在可以同时定义处理程序和反应属性，使我们的<code class="fe nc nd ne mh b">Button</code>工厂看起来像:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9e13" class="ml kz in mh b gy mm mn l mo mp">const Button = attributes =&gt; hooked(text =&gt; {<br/>  const element = useElement('button', attributes);<br/>  const {count} = useReactiveHandler(element, {<br/>    count: 0,<br/>    onclick(event) {<br/>      this.count++;<br/>    }<br/>  });<br/>  element.textContent = `${text} clicked ${count}`;<br/>  return element;<br/>});</span></pre><p id="4c32" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次，<a class="ae jz" href="https://codepen.io/WebReflection/pen/gOwezOL?editors=0010" rel="noopener ugc nofollow" target="_blank">查看现场演示</a>来看看这是如何工作的。</p><h2 id="0a53" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">到目前为止，我们学到了什么</h2><p id="705b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">到目前为止，主要的收获是，钩子只是能够很好地组合在一起的原语，因此为我们的案例创建特别的助手应该是直接的，只要我们为任务选择正确的钩子。</p><p id="e222" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们只探索了<code class="fe nc nd ne mh b">useState</code>和<code class="fe nc nd ne mh b">useRef</code>，这只是对钩子可能做的事情的皮毛，但是我希望很清楚，我们已经可以用这两个原语做很多事情了。</p><p id="1b44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在休息一下，散散步，或者再玩一次我们已经做过的，这样一旦你回来，我们就可以讨论更复杂的例子😉</p><h1 id="2097" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">“待办事项”应用程序</h1><p id="a1b8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我知道这对许多人来说不会太激动，但是<em class="mb"> X-App </em>的要点是将内部组件与整个<em class="mb"> App </em>本身联系起来，因为每个组件更新也可能需要一个<em class="mb"> App </em>更新，并且拥有嵌套钩子也是值得讨论的事情，因为有各种解决方案可以考虑来组成这个模式。</p><p id="1976" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，到目前为止描述的每个按钮都是一个独立的组件，也能够隐式地将一个<code class="fe nc nd ne mh b">click</code>事件分派给任何外部组件，但是知道如何在钩子内处理委托事件，以及如何共享数据，可能值得这个额外的例子。</p><h2 id="dc4a" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">简而言之…</h2><p id="f29c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们要创建的是一个非常简单的结构，允许用户键入一些项目，通过输入添加它，能够标记每个项目完成，或没有。</p><p id="4bd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个应用的第一个版本是CodePen 中的<a class="ae jz" href="https://codepen.io/WebReflection/pen/qBaogzY?editors=0010" rel="noopener ugc nofollow" target="_blank"> live，所以让我们看看它做了什么。</a></p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/3d2624c081811c6249f1d9e2734057ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRw3OuGptCi0wLeOSei1Yw.png"/></div></div></figure><h1 id="59d7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">该结构</h1><p id="7845" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们不会过多关注这种结构的正确性(事实并非如此)，而是关注它的功能性。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ae31" class="ml kz in mh b gy mm mn l mo mp">&lt;div&gt;<br/>  &lt;input&gt;<br/>  &lt;ul&gt;<br/>    &lt;li&gt;<br/>      &lt;label&gt;<br/>        {{value}}<br/>        &lt;input type=checkbox&gt;<br/>      &lt;/label&gt;<br/>    &lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;</span></pre><p id="0a36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像任何其他动态应用程序一样，我们将处理一些数据，在这种情况下表示一个任务或项目的列表，其中每个任务携带最相关的信息:<code class="fe nc nd ne mh b">value</code>和<code class="fe nc nd ne mh b">done</code>。</p><h1 id="a911" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">任务/项目挂钩</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b684" class="ml kz in mh b gy mm mn l mo mp">const Item = () =&gt; hooked(item =&gt; {<br/>  const {value, done} = item;<br/>  const li = useElement('li', {<br/>    // class name based on the item state<br/>    className: done ? 'done' : ''<br/>  });<br/>  const label = useElement('label');<br/>  const span = useElement('span', {<br/>    // item value can be edited/updated<br/>    textContent: value + ' '<br/>  });<br/>  const checkbox = useElement('input', {<br/>    // the checked state is handled reactively<br/>    type: 'checkbox'<br/>  });<br/>  useReactiveHandler(checkbox, {<br/>    checked: done,<br/>    onclick() {<br/>      // update the current task/item state<br/>      item.done = !done;<br/>      this.checked = !done;<br/>    }<br/>  });<br/>  // initialize this component once<br/>  if (!li.hasChildNodes()) {<br/>    label.append(span, checkbox);<br/>    li.append(label);<br/>  }<br/>  return li;<br/>});</span></pre><p id="d5a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们理解了本文的前一部分，希望这是不言自明的,<em class="mb"> Item </em>组件是一个独立的<code class="fe nc nd ne mh b">&lt;li&gt;</code>元素，每当它的状态改变时，它就会改变它的<code class="fe nc nd ne mh b">className</code>,在更新它的引用值之后，简单地更新它的反应<code class="fe nc nd ne mh b">checked</code>属性。</p><h2 id="8fa0" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">与前面的例子不同</h2><p id="4269" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">之前给出的<code class="fe nc nd ne mh b">useElement</code>只设置了一次元素属性，但是这里的帮助器应该能够在每次发生变化时更新这些属性。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="12d0" class="ml kz in mh b gy mm mn l mo mp">const useElement = (name, attributes = {}) =&gt; {<br/>  const ref = useRef(null);<br/>  if (!ref.current)<br/>    ref.current = document.createElement(name);<br/>  // update properties each time<br/>  return Object.assign(ref.current, attributes);<br/>};</span></pre><h1 id="ce1e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">待办事项应用程序</h1><p id="23ea" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">此时，我们需要的是一个能够呈现这些项目并创建新项目的容器。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2dee" class="ml kz in mh b gy mm mn l mo mp">const Todo = () =&gt; hooked(items =&gt; {<br/>  // lazy way to have always same WeakMap ... not ideal<br/>  const {current: references} = useRef(new WeakMap);<br/>  // basic structure<br/>  const app = useElement('div');<br/>  const input = useElement('input');<br/>  const list = useElement('ul');<br/>  // update the list whenever a new task/item is added<br/>  useReactiveHandler(input, {<br/>    count: items.length,<br/>    onkeypress({key}) {<br/>      if (key === 'Enter') {<br/>        const value = input.value.trim();<br/>        if (value &amp;&amp; !items.find(({value: v}) =&gt; v === value)) {<br/>          // place new tasks on top<br/>          items.unshift({value, done: false});<br/>          input.value = '';<br/>          this.count++;<br/>        }<br/>      }<br/>    }<br/>  });<br/>  // lazy way to update this view ...<br/>  // just re-append everything<br/>  app.append(input, list);<br/>  items.forEach(item =&gt; {<br/>    // create new tasks/items once via reference<br/>    if (!references.has(item)) {<br/>      const hook = Item();<br/>      references.set(item, hook(item));<br/>    }<br/>    list.append(references.get(item));<br/>  });<br/>  return app;<br/>});</span><span id="b6a0" class="ml kz in mh b gy mq mn l mo mp">const App = Todo();</span></pre><p id="d289" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">概括一下:</p><ul class=""><li id="a39a" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated"><code class="fe nc nd ne mh b">App</code>是一个钩子，它通过一个输入字段处理一系列任务/项目，当<em class="mb"> Enter </em>键发生时，它能够添加新的任务/项目</li><li id="d1e6" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">每次创建新任务时，<code class="fe nc nd ne mh b">App</code>都会更新其内容，并且它会将每个项目与用作<em class="mb">弱</em>键的唯一数据点相关联。</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="aff1" class="ml kz in mh b gy mm mn l mo mp">// create a new App with an empty list<br/>document.body.append(App([]));</span></pre><h2 id="6da7" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">丑陋的部分…</h2><ul class=""><li id="67b9" class="nf ng in kc b kd lw kh lx kl nu kp nv kt nw kx nk nl nm nn bi translated">项目通过数据突变泄漏其状态，并且这种变化在其闭包之外无法被检测到，除非每个项目也是反应性的，但这种情况很少发生(想想<em class="mb"> JSON </em>请求，等等)。如果我们想显示任务的总量，以及已完成任务的数量，改变项目状态而不更新整个视图是不容易缩放的。</li><li id="c54f" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">与React和它的<em class="mb"> JSX </em>特殊语法相比，很容易让人觉得组件的创建和初始化相当冗长且容易出错</li><li id="33f9" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">每次都无缘无故地创建<code class="fe nc nd ne mh b">WeakMap</code>，这很容易修复，通过<code class="fe nc nd ne mh b">useRef</code>使用<code class="fe nc nd ne mh b">.current</code>技巧，但也更冗长，收益很少</li></ul><p id="7325" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可能还有其他丑陋的部分，但是这三个让我已经想要重写，或者重构这个<em class="mb"> Todo </em>项目…但是怎么做呢？</p><h1 id="abc7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">引入土地</h1><p id="7b10" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/WebReflection/uland#readme" rel="noopener ugc nofollow" target="_blank"> land </a>模块是一个基于<em class="mb"> hooks </em>的库，它试图通过以下方式改进普通hooks状态:</p><ul class=""><li id="83d9" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated">它是声明性的，这要感谢通过其核心暴露的html</li><li id="3cac" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">它提供了帮助者来协调开箱即用的容器/组件</li><li id="68cf" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">它需要更少的样板文件、助手</li></ul><p id="8182" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<a class="ae jz" href="https://codepen.io/WebReflection/pen/vYXRMXK?editors=0010" rel="noopener ugc nofollow" target="_blank">新版本的App </a>确实会减少到45 <em class="mb"> LOC </em>，其中的<em class="mb"> Item </em>组件现在看起来会是这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2755" class="ml kz in mh b gy mm mn l mo mp">const Item = Component(item =&gt; {<br/>  const {value, done} = item;<br/>  // used to notify updates, no value needed<br/>  const [_, update] = useState();<br/>  return html`<br/>    &lt;li class=${done ? 'done' : ''}&gt;<br/>      &lt;label&gt;<br/>        ${value}<br/>        &lt;input<br/>          type=checkbox<br/>          .checked=${done}<br/>          onclick=${() =&gt; {<br/>            item.done = !done;<br/>            update();<br/>          }}<br/>        &gt;<br/>      &lt;/label&gt;<br/>    &lt;/li&gt;<br/>  `;<br/>});</span></pre><p id="c53e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此不再需要以前的助手，因为定义元素、它们的属性、事件或特性，使用<code class="fe nc nd ne mh b">.propName</code>约定，被集成到基于模板文字的引擎中。</p><p id="a82e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不仅<em class="mb">项目</em>组件更简单，而且<em class="mb">待办事项</em>组件现在也更短，更易于阅读:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e918" class="ml kz in mh b gy mm mn l mo mp">const Todo = Component(items =&gt; {<br/>  const [count, update] = useState(items.length);<br/>  const done = items.filter(({done}) =&gt; done).length;<br/>  return html`<br/>    &lt;div data-info=${`Total: ${count} - Done: ${done}`}&gt;<br/>      &lt;input onkeypress=${({currentTarget: input, key}) =&gt; {<br/>        if (key === 'Enter') {<br/>          const value = input.value.trim();<br/>          if (value &amp;&amp; !items.find(({value: v}) =&gt; v === value)) {<br/>            items.unshift({value, done: false});<br/>            input.value = '';<br/>            update(count + 1);<br/>          }<br/>        }<br/>      }}&gt;<br/>      &lt;ul&gt;<br/>        ${items.map(Item)}<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>});</span></pre><p id="3afc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mb"> Todo </em>的<code class="fe nc nd ne mh b">update(count + 1)</code>将在添加最后一个条目后重新呈现项目列表，而<em class="mb"> Item </em>的<code class="fe nc nd ne mh b">update()</code>将通过最上面的呈现元素传播，因此现在完成的任务也将作为<code class="fe nc nd ne mh b">data-info</code>反映在主容器中。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fc23" class="ml kz in mh b gy mm mn l mo mp">// bootstrap the Todo App<br/>render(document.body, Todo([]));</span></pre><p id="a69e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义在哪里呈现我们的新应用程序的元素，然后<a class="ae jz" href="https://codepen.io/WebReflection/pen/vYXRMXK?editors=0010" rel="noopener ugc nofollow" target="_blank">查看它的实况</a>。</p><h2 id="8fef" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">键控与非键控</h2><p id="3c1f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果我们仔细观察当前的演示，会发现有一些问题需要考虑:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6406" class="ml kz in mh b gy mm mn l mo mp">${items.map(Item)}</span></pre><p id="af21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板文字引擎足够智能，每次更新所有属性，但是没有引用，我们工作在<em class="mb">无键</em>模式。</p><p id="4807" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">检查当前的DOM，我们会看到更改可能会应用到多个项目，但是如果我们想确保单个项目代表一个特定的组件，我们仍然需要在<em class="mb"> Todo </em>应用程序和每个<em class="mb">项目</em>中使用一个引用。</p><p id="14c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了做到这一点，我们可以使用另一个钩子助手:<code class="fe nc nd ne mh b">useMemo</code></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="54fe" class="ml kz in mh b gy mm mn l mo mp">const Todo = Component(items =&gt; {<br/>  const tasks = useMemo(() =&gt; new WeakMap, items);<br/>  // ...<br/>  return html`<br/>    &lt;div data-info=${`Total: ${count} - Done: ${done}`}&gt;<br/>      ...<br/>      &lt;ul&gt;<br/>        ${items.map(item =&gt; {<br/>          if (!tasks.has(item))<br/>            tasks.set(item, Item(item));<br/>          return tasks.get(item);<br/>        })}<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>});</span></pre><p id="01f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种助手仅在其保护改变时执行回调，在这种特定情况下仅创建一个<code class="fe nc nd ne mh b">WeakReference</code>，与以前每次更新都创建它相反。</p><p id="12d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，dance可以使用这样的引用，只在需要的时候创建新的组件，并重新排序其他组件，而不是每次都更新整个列表。</p><p id="bfda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一点上，另一个变化是以一种独特的方式将这样的条目与它所代表的DOM片段相关联:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="035b" class="ml kz in mh b gy mm mn l mo mp">const Item = Component(item =&gt; {<br/>  const {value, done} = item;<br/>  const [_, update] = useState();<br/>  return html.for(item, 'todo-item')`<br/>    ...<br/>  `;<br/>});</span></pre><p id="37b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne mh b">html.for(ref[, id])</code>就是要走的路，本例中的<code class="fe nc nd ne mh b">id</code>帮助我们在页面中重用同一个<code class="fe nc nd ne mh b">item</code>，而不需要移动同一个节点。</p><p id="8e61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请随意使用这个应用程序的最新版本。</p><h2 id="624e" class="ml kz in bd la mr ms dn le mt mu dp li kl mv mw lm kp mx my lq kt mz na lu nb bi translated">仍然失踪…</h2><p id="219c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们目前的应用程序仍然在从内部变异物品，我已经可以想象所有的“<em class="mb">不可变-数据</em>”粉丝发誓…</p><p id="1718" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样值得考虑的是，空的<code class="fe nc nd ne mh b">useState</code>，仅仅为了传播状态变化而被调用，与其说是一个解决方案，不如说是一个黑客。</p><p id="2f3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，我们可以做的是传递应用程序<em class="mb">上下文</em>，这使得任何组件都能够触发更新，使用相同上下文的其他组件都会收到通知。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="74ce" class="ml kz in mh b gy mm mn l mo mp">const Todo = Component(context =&gt; {<br/>  const items = useContext(context);<br/>  // no need to useMemo, as items are always new anyway<br/>  // ...<br/>  return html`<br/>    &lt;div data-info=${`Total: ${count} - Done: ${done}`}&gt;<br/>      ...<br/>      &lt;ul&gt;<br/>        ${items.map(item =&gt; Item({context, item}))}<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>});</span></pre><p id="c011" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而在<em class="mb"> React </em>中，上下文通常被表示为另一个<em class="mb"> JSX </em>节点，在<em class="mb"> uhooks </em>中，因此在<em class="mb"> uland </em>中，也有一个工具来创建一个:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0b1e" class="ml kz in mh b gy mm mn l mo mp">render(document.body, Todo(createContext([])));</span></pre><p id="82dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne mh b">useContext(context)</code>将返回上下文携带的任何<em class="mb">值</em>，但是上下文本身也提供了一种更新其值的方式，自动在应用程序中传播，导致全局更新:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8e14" class="ml kz in mh b gy mm mn l mo mp">const Item = Component(({context, item}) =&gt; {<br/>  const items = useContext(context);<br/>  const {value, done} = item;<br/>  return html`<br/>    &lt;li class=${done ? 'done' : ''}&gt;<br/>      &lt;label&gt;<br/>        ${value}<br/>        &lt;input<br/>          type=checkbox<br/>          .checked=${done}<br/>          onclick=${() =&gt; {<br/>            const i = items.indexOf(item);<br/>            // provide a new list of items<br/>            // with a new item instead of mutating<br/>            context.provide([<br/>              ...items.slice(0, i),<br/>              {value, done: !done},<br/>              ...items.slice(i + 1);<br/>            ]);<br/>          }}<br/>        &gt;<br/>      &lt;/label&gt;<br/>    &lt;/li&gt;<br/>  `;<br/>});</span></pre><p id="0b8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个<a class="ae jz" href="https://codepen.io/WebReflection/pen/bGwvydQ?editors=0010" rel="noopener ugc nofollow" target="_blank">最后一个例子也是活的</a>，这里最重要的要注意的是:</p><ul class=""><li id="f59e" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated">没有必要使用<code class="fe nc nd ne mh b">html.for(...)</code>因为每一项改变都会变成一个新的参考，所以我们只会麻烦一个<code class="fe nc nd ne mh b">WeakMap</code>来获得不多的收益</li><li id="1630" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">意图比以前更清晰了，但是节点现在又变得无密钥了</li></ul><p id="97d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于最后一点，不仅它不应该真正重要，除非键控结果是绝对强制性的，但如果我们仔细观察，我们最终可以将每个组件关联到它自己的值，并使用这样的值作为唯一的键，因为逻辑不允许我们添加两次相同的任务。</p><p id="60ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，一个简单的<code class="fe nc nd ne mh b">Map</code>会更好，如果应用程序被扩展到移除已经完成的项目，唯一需要记住的是，键也应该从这个<code class="fe nc nd ne mh b">Map</code>中移除，但是我将把这部分留给读者作为练习。</p><h1 id="adde" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="736c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我希望你喜欢这个一步一步的Todo应用程序创建过程，使用普通的DOM和天生的小助手来轻松解决这些任务，所以现在应该很清楚，使用钩子不一定局限在React生态系统中，但是通过任何其他标准来说也是一件令人愉快的事情。</p></div></div>    
</body>
</html>