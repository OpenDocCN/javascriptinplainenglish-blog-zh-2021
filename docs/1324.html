<html>
<head>
<title>Create Your Own React State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的反应状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-your-own-state-management-1f0c894039d7?source=collection_archive---------5-----------------------#2021-03-20">https://javascript.plainenglish.io/creating-your-own-state-management-1f0c894039d7?source=collection_archive---------5-----------------------#2021-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f75" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解"<strong class="ak"> <em class="kf">"使用Context" </em> </strong>"和"<strong class="ak"><em class="kf">" create context</em></strong>" API创建自定义状态管理。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c2890dc853cb37cbe1907011fb9ccacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CChESkNxMhX3Ehmj3A7hEw.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk"><a class="ae kw" href="http://ihatereading.in/creativity" rel="noopener ugc nofollow" target="_blank">iHateReading</a></figcaption></figure><p id="59e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Redux是一个很大的包，有时它会降低应用程序的性能。您可以通过使用build命令构建下一个JavaScript存储库来自己测试它，并查看Redux包在所有其他包中占据了多少空间。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="d992" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">yarn run build</strong></span></pre><h1 id="654c" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">背景</strong></h1><p id="44e3" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">Redux是由Don Abromov在2015年准备React Europe会议时开发的，当时他试图与Flux store一起玩。我相信，redux出现的一个坚实的原因是在深度嵌套的子组件之间和直接兄弟组件之间共享的公共属性和值。我个人在谷歌搜索一些模糊和随机的单词后，在直系兄弟姐妹之间传递更新的值时面临很多困难😁大约2/3个小时，我最终到达了所谓的“<strong class="kz ir"><em class="na">【Redux】</em></strong>字。</p><p id="2627" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢地球上的某个人，他清楚地提到了下面的评论—</p><blockquote class="nb nc nd"><p id="d389" class="kx ky na kz b la lb jr lc ld le ju lf ne lh li lj nf ll lm ln ng lp lq lr ls ij bi translated">“你需要一种叫做<strong class="kz ir">国家管理的东西</strong>我的朋友”</p></blockquote><p id="16d8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这就是为什么有时候阅读评论是有意义的😁。</p><h1 id="415a" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak"> React上下文API </strong></h1><p id="80e6" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">现在你可以对上述主张提出反驳。是的，我们可以把道具从父母传给孩子。但是这个选项是不可行的，因为节点树的最深和最低的子节点的道具数量将是最大的，并且该节点处理它的道具变得很麻烦。</p><p id="95d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，React确实提供了另一种方法来将公共值传递给嵌套很深的子节点或兄弟节点。React提供与API名为“<strong class="kz ir"> <em class="na">”的React上下文API。</em> </strong>您可以从链接中了解更多</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="a81d" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">React Context API =&gt; </strong><a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/context.html</a></span></pre><p id="6af7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">了解上下文API </strong> <br/>反应上下文在幕后做两件事:</p><p id="f829" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">1.它为您创建一个上下文对象，这是一个高阶组件(HOC)，如果您不知道react中的HOC是什么，那么简单地说，HOC是一个包装器组件，它返回另一个组件，而不是返回值。</p><p id="224e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.创建的HOC有两种方法:<strong class="kz ir"> <em class="na">【提供者】</em></strong><strong class="kz ir"><em class="na">【消费者】</em> </strong>。顾名思义，提供者是向消费者提供应用程序全局状态的人，而消费者是读取和写入全局状态的人。</p><p id="a89d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">回到React context HOC，这个上下文包装器然后被包装到应用程序的根。React Context API创建了一个上下文特设，我从现在开始将这个上下文特设称为<strong class="kz ir"> MyContext，因为它更容易键入。</strong></p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="f5bd" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">MyContext = React.createContext(defaultValue)<br/>React Context HOC = &lt;MyContext /&gt;</strong></span></pre><p id="0244" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以创建多个<strong class="kz ir"> <em class="na">消费者&amp;</em></strong><strong class="kz ir"><em class="na">供应商</em> </strong>。MyContext Component接受“<strong class="kz ir"><em class="na">global state”</em></strong>作为道具，接受“<strong class="kz ir"><em class="na">value”</em></strong>作为密钥。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="7e42" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">&lt;MyContext.Provider value={globalState}&gt; // this is the Provider <br/>   &lt;Component {...pageProps} /&gt; // this is the Consumer <br/>&lt;/MyContext.Provider&gt;</strong></span></pre><p id="4cf9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nh ni nj lu b">&lt;Component /&gt;</code>组件将成为我们的globalState的消费者，并且它可以有多个深度嵌套的子组件。每个孩子都能进入全球之州。&lt;组件/ &gt;的每个子组件本身都被称为消费组件。另一个<strong class="kz ir">加分点</strong>是，当任何消费者组件编辑、更新或删除globalState的任何键值对时，所有其他消费者组件将获得globalState的最新值，并自动重新渲染。就像我们通过调度一个动作来使用减速器更新商店一样。</p><p id="cb37" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，每当globalState对象的任何值发生变化时，订阅globalState get的每个组件都会被重新呈现。要停止这种重新渲染，请使用“<strong class="kz ir"><em class="na">reaction . usememo()”</em></strong>方法，并围绕该组件创建记忆。反应时使用<strong class="kz ir"><em class="na">object . is</em></strong>方法的JavaScript来检测<strong class="kz ir"><em class="na">global state</em></strong>的变化。一旦通过<strong class="kz ir"><em class="na">object . is</em></strong>方法跟踪/记录了更改，该<strong class="kz ir"><em class="na">global state</em></strong>的所有订阅者都会获得最新的值，从而重新呈现。</p><h1 id="e82d" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">应用</strong></h1><p id="5a93" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">我们将把<strong class="kz ir"> MyContext </strong>包装在我们的<strong class="kz ir"><em class="na">app . js</em></strong>中，因为我们需要将我们的globalState传递给应用程序的每一页。<strong class="kz ir"> <em class="na"> useContext() </em> </strong>方法采用默认值和参数，在我们的例子中，默认值是我们的<strong class="kz ir"> globalState </strong>。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="3d53" class="ly lz iq lu b gy ma mb l mc md">const globalState = {<br/>       dark: {<br/>            background: '',<br/>            foreground: ''<br/>       },<br/>       light:{ <br/>            background:'', <br/>            foreground: '' <br/>       },<br/>       userLoggedIn: true<br/>};<br/>const MyContext = React.createContext(globalState);</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nk"><img src="../Images/30bf765315d0fe3d2528c5f29aeefb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPTABiBf3m-T2Qx_68RThA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">theme.js file for creating Context HOC using Context API</figcaption></figure><p id="cd45" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">出于开发目的，我们的globalState将由一对键值组成，这对键值是“<strong class="kz ir"> <em class="na"> userLoggedIn </em> </strong>”，其值是“<strong class="kz ir">Boolean”</strong>数据类型。这背后的主要议程是在其子组件中访问我们的根应用程序的全局状态，然后切换它。</p><p id="67dd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将把这个全局状态对象作为上下文API的默认值，它将返回一个上下文特设(MyContext)。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="4ae6" class="ly lz iq lu b gy ma mb l mc md">import { ThemeContext, Theme } from 'theme.js'<br/>&lt;MyContext value={theme}&gt;<br/>   &lt;Component {...pageProps} /&gt;<br/>&lt;/MyContext&gt;</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nl"><img src="../Images/eee72923bae4c236bc1f039630678831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG1c4dMh0J5Tj-9or-2IWA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">_app.js</figcaption></figure><p id="8b8a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下一步是通过子组件或消费者组件子组件读取该全局状态，然后切换其中一个全局状态值(userLoggedIn)。</p><p id="b70a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在任何消费者组件中访问这个globalState对象也很容易，您只需要使用由React提供的Context钩子，并在消费者组件中将您的MyContext对象传递给它。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="3f28" class="ly lz iq lu b gy ma mb l mc md">import React, { useContext } from 'react';<br/>import { ThemeContext} from 'theme.js'</span><span id="1a55" class="ly lz iq lu b gy nm mb l mc md">const theme = useContext(ThemeContext);<br/>&lt;MyContext.Consumer value={theme}&gt;<br/>   &lt;p&gt;{theme.userLoggedIn }&lt;/p&gt;<br/>&lt;/MyContext.Consumer&gt;</span></pre><p id="4ebb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">执行<br/> </strong>我已经创建了2个子组件(名为Home和Profile)，Home组件正在切换userLoggedIn值，而Profile组件正在读取globalState的最新值。在切换了userLoggedIn值之后，配置文件组件将重新呈现。例如，如果userLoggedIn为真，则将文本显示为“用户已登录”，因此将文本显示为“用户已注销”。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nn"><img src="../Images/616b4edca3242a60f6acb6dda97599cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRtIlwboyRDk6efHVBmV9g.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Home Component toggling the globalState <strong class="bd no">userLoggedIn</strong> value</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi np"><img src="../Images/e2993b4ed5554ea388e670934cb70a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ7tTduMAxegdiI3KJs5pg.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Profile Component reading the <strong class="bd no">userLoggedIn</strong> value from globalState</figcaption></figure><h1 id="4e65" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">自定义状态管理系统流程</strong></h1><p id="2d91" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">同样，在<strong class="kz ir"> Redux </strong>中，我们可以创建调度函数来更新全局状态，或者在我们的自定义状态管理中更新所谓的应用程序存储。</p><p id="2070" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以根据需要扩展整个体系结构。我将创建一个名为CustomRedux的单独文件夹，其中包含action和store。我的商店将从"<strong class="kz ir"><em class="na">【create context "</em></strong>API导出globalState对象，该操作将更新商店。</p><p id="d58e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，我还可以创建reducer，这是一种中间件功能，但在本例中，我将跳过它。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="08f9" class="ly lz iq lu b gy ma mb l mc md">-- Custom Redux <br/> |-- action.js<br/> |-- store.js</span></pre><p id="3f90" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将从创建第一个定制动作开始，这是一个切换主题对象的布尔值“userLoggedIn”的简单动作。在我们的例子中，该操作将获取数据并简单地更新store对象。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="46a4" class="ly lz iq lu b gy ma mb l mc md">// action.js <br/>import { ThemeContext, Theme } from CustomRedux/store'<br/>export const toggleUserLoggedInState = (loggedInState) =&gt; {<br/>  return theme.userLoggedIn = loggedInState<br/>}</span></pre><p id="b990" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将使用此操作作为dispatcher函数来更新全局状态。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="c8ac" class="ly lz iq lu b gy ma mb l mc md">// store.js<br/>const theme = {<br/>       dark: {<br/>            background: '',<br/>            foreground: ''<br/>       },<br/>       light:{ <br/>            background:'', <br/>            foreground: '' <br/>       },<br/>       userLoggedIn: true<br/>};<br/>const MyContext = React.createContext(theme);</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nq"><img src="../Images/4363cd5dcb4cfbb0bc4a914afc61b7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gn-Z6jdy-ksCigu0Qih7gQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Home Component using our Custom Redux</figcaption></figure><h1 id="ff6a" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">更换冗余</strong></h1><p id="2322" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">我们真的可以取代redux提出这种架构，我认为这不是一个正确的时间来回答，如果是这样的话，它会取代redux。但是这里肯定有一个问题，如果您在任何子组件中控制我们的globalState对象，我们将获得最新的状态，但是如果我们刷新浏览器，我们将返回到主题对象的原始状态，因此我们的"<strong class="kz ir"><em class="na">user logged in "</em></strong>将始终保持"<strong class="kz ir"> <em class="na"> true </em> </strong>"一旦用户刷新页面，忽略它被切换的时间。Redux也有这个问题，redux确实提供了一个"<strong class="kz ir"><em class="na">redux-persist "</em></strong>或<strong class="kz ir"><em class="na">redux-storage</em></strong>NPM包来保存最新的redux store或globalState，因此即使在刷新之后，您也只能获得持久状态。</p><p id="904d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Redux-storage或Redux-persist作为中间件，将全局状态对象存储在<strong class="kz ir"> <em class="na"> RAM </em> </strong>(随机存取存储器)中。我不确定，但是如果我们可以在我们的"<strong class="kz ir"><em class="na"/></strong>动作中添加一个中间件函数，使用插件/扩展将最新的全局状态存储到浏览器<strong class="kz ir"> <em class="na"> RAM </em> </strong>中，那么我们可以很容易地解决这个问题，而不需要使用"<strong class="kz ir"><em class="na">【Redux-Storage】</em></strong>和"<strong class="kz ir"><em class="na">Redux-Persist "</em></strong>。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="a825" class="ly lz iq lu b gy ma mb l mc md">// action.js <br/>import { ThemeContext, Theme } from CustomRedux/store'<br/>export const toggleUserLoggedInState = (loggedInState) =&gt; {<br/>  // add and middleware function which will store the updated theme      in browser RAM or cache <br/>  return theme.userLoggedIn = loggedInState<br/>}</span></pre><p id="2921" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有另一个解决方案，将更新后的globalState存储到我们的数据库中，并且只能使用头中带有令牌的安全API端点来访问它。但是这也暴露了一个边缘情况，即离线模式，一旦用户离线，用户就不能访问状态，只能在本地显示数据。</p><h1 id="7a62" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">结论</strong></h1><p id="4bc6" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">我仍在测试这整个想法，但我对这种方法相当乐观，我已经完全完成了“<strong class="kz ir"><em class="na">【Redux】</em></strong>的工作，因为一旦我们创建更多的动作，它的大小就会不断增加。我将尝试添加更多使用"<strong class="kz ir"> <em class="na"> useContext" </em> </strong>和"<strong class="kz ir"><em class="na">create context</em></strong>" API的教程。最后，也许我应该试试这个新的状态管理，叫做<strong class="kz ir"><em class="na">【X-State】</em></strong>，到目前为止，对大多数开发人员来说，这听起来很有前途。</p><p id="c613" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下次再见，祝大家愉快。</p><pre class="kh ki kj kk gt lt lu lv lw aw lx bi"><span id="8f47" class="ly lz iq lu b gy ma mb l mc md">Here is the code repository =&gt; <a class="ae kw" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/BasicsReactContext" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/BasicsReactContext</a></span></pre></div></div>    
</body>
</html>