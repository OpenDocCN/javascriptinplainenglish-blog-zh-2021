<html>
<head>
<title>I Created the Exact Same App in JavaScript (with Web Components)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用JavaScript创建了完全相同的应用程序(带有Web组件)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vanilla-javascript-todo-app-160eba391a3d?source=collection_archive---------2-----------------------#2021-09-14">https://javascript.plainenglish.io/vanilla-javascript-todo-app-160eba391a3d?source=collection_archive---------2-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比较React、Vue和带有Web组件的普通JavaScript中内置的应用程序之间的差异</h2></div><p id="cdac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我读了苏尼尔·桑德胡写的一篇相当不错的文章，这篇文章比较了在<a class="ae lb" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae lb" href="https://vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vue </a>中编写todo应用程序。在这篇文章中，Sunil出色地描述了每个代码块，React和Vue之间的区别，以及它们工作的原因。如果您对这些技术中的任何一种都不熟悉，一定要读一读他的文章。</p><p id="db1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我读Sunil的文章时，我开始怀疑一个普通的JavaScript版本是否会如此不同。我最近迷上了“香草JS ”,并且一直对JavaScript及其在浏览器中的支持所取得的进步印象深刻。</p><p id="d1a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这篇文章中，我将用普通的JavaScript和CSS构建一个小的todo应用程序。你可以在这里找到这篇文章的代码。在我们开始之前，让我们看看React、Vue和Vanilla JS版本是什么样子的。<em class="lc">剧透预警，他们应该都是一个样子，一个行为！</em></p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/d8fa385e4e0edeebc23985ac99515a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_y7lfVMDJ7T3PGsgUIixQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of React todo application</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/4311dce90f655312de5dd6180e692fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzJZGz6e6AvA6oAst1-kXA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of Vue todo application</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/66cb8a3573742b27218ecb1da84f8f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bahc4oWugIlD0jtktLmoQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of Vanilla JavaScript todo application</figcaption></figure><p id="c7b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，它们看起来几乎一模一样。这个标志是唯一可以识别的区别。事实上，我从Sunil的React版本的应用程序中取出CSS，并简单地使用它！谢谢Sunil！现在让我们来看看文件结构。下面你会看到React、Vue和我们的普通JS版本生成的文件结构的对比。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lt"><img src="../Images/6de56535434aa03858d713b77187c91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bf3MAmnArZu5M7t5MaKoog.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><strong class="bd lu">Left</strong>: React, <strong class="bd lu">Middle</strong>: Vue, <strong class="bd lu">Right</strong>: Vanilla JS</figcaption></figure><p id="bd83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由各自的app生成器生成的React和Vue结构非常相似。最大的区别可能是React创建单独的CSS文件，而Vue将CSS包含在单个文件组件中。应用程序的普通JS版本也有一个CSS文件。我选择将所有的CSS合并到一个文件中。</p><p id="f4ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续看代码，让我们从最合理的地方开始，HTML文件<strong class="kh ir">index.html</strong>。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7c0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这里没有什么值得兴奋的。这是一个非常无聊的HTML文件，上面有一个图片和标题。至少在到达<em class="lc"> ToDo-Container </em> div之前，它是很无聊的。查看div内部，您可能会注意到一些定制元素:<strong class="kh ir"> todo-list </strong>、<strong class="kh ir"> new-todo-item </strong>和<strong class="kh ir"> error-messager </strong>。再往下看，您会看到与这些新元素相对应的脚本。您可能还注意到那些脚本包含了一个名为<strong class="kh ir"> type </strong>的属性，其值为<strong class="kh ir"> module </strong>。<em class="lc">那个</em>是告诉你的浏览器像现代ES6 JavaScript一样加载和解析JavaScript文件的秘方。我们将逐一检查。</p><p id="dc61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入每个JavaScript文件之前，我想先说这些JavaScript文件包含了<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>。对于未入门的Web组件，JavaScript类可以让您构建定制的、可重用的HTML元素。而且……他们很酷。所以我们先来看看<strong class="kh ir"> ErrorMessager </strong>组件。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="de61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web组件有四个部分(主要):扩展什么元素，构造函数，元素初始化时的函数，元素销毁时的函数。Web组件基本上是定制的HTML元素，因此您实际上可以扩展任何现有的HTML元素(比如div或select)。在上面的例子中，我们只是扩展了<strong class="kh ir"> HTMLElement </strong>来制作一个基本的自定义元素。</p><p id="c60d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个需求是构造函数。要求你在构造函数中调用<em class="lc"> super() </em>，仅此而已。在构造函数中，你可以初始化一些变量，甚至可以接受参数。</p><p id="60f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web组件需要一个名为<strong class="kh ir"> connectedCallback() </strong>的函数。这是您需要做任何渲染和事件监听器的地方。在我们的函数中，你会注意到我们做了两件事。首先，我们通过调用<code class="fe lx ly lz ma b">this.classList.add()</code>向自定义元素添加一个CSS类。然后我们调用另一个函数，我们在顶部导入了这个函数，来监听一个告诉我们想要显示错误消息的事件。稍后我会谈到活动的内容。</p><p id="04a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您将看到一个名为<strong class="kh ir"> disconnectedCallback() </strong>的函数。这里是您需要执行任何关闭活动的地方。如果你的元素从DOM中移除，这个函数会自动被调用，所以这是一个分离事件监听器的好地方，这就是我们正在做的。</p><p id="f54b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，回到我们设置事件监听器的第13行，你会看到我们引用了一个名为<strong class="kh ir"> _display() </strong>的函数。当一个自定义事件触发时，这个函数被调用。在这个函数中，我们做两件事。首先，我们创建一个段落元素，包含我们想要显示的消息，并将它作为子元素添加到我们的自定义元素中。然后我们设置一个超时，3秒钟后删除该段落。</p><p id="b8ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到的最后一件事是，我们在这个JavaScript文件的底部注册了自定义元素。这告诉浏览器我们的新元素的名称，现在我们可以在我们的HTML中使用它。</p><p id="a4cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果您还记得，我提到过我们正在触发一些自定义事件(见第13行，我们正在监听这个自定义事件)。让我们来看看这段代码。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="19c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个文件非常简单。我们已经设置了函数来调度一个自定义事件，监听该事件，并删除该事件。注意，我们正在调度和监听<em class="lc">窗口</em>对象。我这样做是为了简化我的生活。您也可以从Web组件调度事件。</p><p id="1cb0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看一个表示todo的组件。todo基本上是一个包含todo文本和用于删除todo项的按钮的段落。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8171" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于结构相同，我不会像前面的组件那样详细介绍。在<strong class="kh ir"> connectedCallback() </strong>函数中，我们设置我们的元素并渲染东西。在其中，我们创建了段落元素，并将todo文本分配给它。然后我们制作一个按钮用来删除这个待办事项。对于该按钮的click事件，我们希望首先调度一个事件，告诉其他人我们删除了自己。然后我们调用<code class="fe lx ly lz ma b">this.remove()</code>从DOM中删除整个todo项目定制元素。</p><p id="f991" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看一个创建新todo的组件。新的todo基本上是一个文本框和一个按钮。当这个按钮被点击时，我们将从组件调度一个事件来提醒我们的父节点我们想要创建一个新的todo。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="41f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是你所期望的。我们创建元素，然后将它们作为子元素添加到自定义元素中。我们还设置了事件侦听器，当添加按钮被按下时，它将调度一个事件，并将todo文本作为事件的详细信息。</p><p id="4592" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看最后一个组件，<strong class="kh ir"> ToDoList </strong>。这是将呈现待办事项列表并跟踪该列表的组件。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ada5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来分析一下。我想指出的第一件事是，我们设置了一个项目数组来组成我们的todo列表，你可能会注意到它已经有两个项目了。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/b3515a92333b2944ba87b0c6bba4744a.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*UcCZ-6nHB7uaA9l1y1V5dw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of the list array</figcaption></figure><p id="ed93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Sunil的React和Vue例子用两个todos初始化app，所以我也这样做了。每个待办事项都有一个ID和文本。</p><p id="24ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir"> connectedCallback() </strong>函数中，我们将遍历该列表并创建新的<strong class="kh ir"> ToDoItem </strong>元素(hurray Web Components！)并将它们添加为我们的todo list组件的子组件。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/c92ca6f4c6d17a9c6b7df771deb630e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*Dk6BXSjlYuBoF3s6qqaIyg.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of creating initial todo items</figcaption></figure><p id="9f5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们有一个名为<strong class="kh ir"> addTodo </strong>的函数，它完全按照你的想法来做。它首先生成一个ID，创建todo对象并将其添加到我们的内部列表中。然后，它创建一个<strong class="kh ir"> ToDoItem </strong>元素，并将其添加到我们的组件DOM中。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/43ab7cfc5eca25416c70f2815bb7232a.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*yTJ3bIVkdDaIE4rmtNXJwQ.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Screen shot of the function to add a todo</figcaption></figure><p id="d194" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果你回头看看index.html的<strong class="kh ir">，你会注意到我们还包含了一个<em class="lc"> main.js </em>。让我们看看那个。</strong></p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0260" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这最后一段代码中，我们希望监听<strong class="kh ir">new doitem</strong>元素触发的<em class="lc"> new-todo </em>事件。当该事件触发时，我们获取对<strong class="kh ir"> ToDoList </strong>元素的引用，然后调用<em class="lc"> addTodo </em>方法，向其传递自定义事件的详细信息，这恰好是Todo文本。</p><p id="4908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们设置一个监听器，用于删除todo。在那个监听器中，我们做同样的事情。我们获取对<strong class="kh ir"> ToDoList </strong>元素的引用，并调用<em class="lc"> deleteTodo </em>方法。</p><h1 id="668d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">比较起来怎么样？</h1><p id="1f8a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">那么，这一切与React或Vue版本相比如何？React和Vue都有一些初始化组件和设置状态的概念。Web组件不具有与框架相同的状态管理概念，但是Web组件具有基本的生命周期功能，用于处理组件被呈现和销毁的情况。</p><p id="58a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，因为Web组件没有真正内置状态管理系统，所以您需要负责手动添加和删除DOM元素。例如，在Vue和React版本中，当列表数组改变时，DOM会自动为该部分重新呈现。在普通的JS版本中，我们必须手动删除和添加DOM元素。</p><p id="825b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个区别是事件侦听器的处理方式。在React和Vue事件中，侦听器被附加在标记中并引用一个函数。在Vanilla JS中，我们在创建和添加元素时在JavaScript中附加那些处理程序。</p><h1 id="6956" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后🎉</h1><p id="0cf9" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我希望这种对普通JavaScript的研究能有所启发。现代浏览器变得比以往更加强大，并提供了复杂的JavaScript和CSS特性。框架很棒，可以节省很多时间，但是我相信随着web技术的发展，老式的JavaScript将会继续发展，成为你工具箱中的一个有价值的工具。</p><p id="4e87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯，编码快乐！</p><h1 id="c634" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">作为题外话</h1><p id="adf3" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我拍了几张传递给浏览器的有效载荷大小的截图。尺寸当然不是一切，但我忍不住注意到香草版本是多么小。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/27228d9abb79b7aa595d67f8d4f9e427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dm6QF5oOzr7vSFZ5vcBWLw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">React payload size</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/1a8de0d6b97d99a68764058aeba159e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heHL75R61-FF-E9esJRViw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Vue payload size</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/199292aacde43fce2d322ab0452a5a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aU9m2MgkJ6NCxRHTMavmog.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Vanilla payload size</figcaption></figure><h1 id="a3a9" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">链接</h1><p id="8add" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">此存储库:</p><div class="na nb gp gr nc nd"><a href="https://github.com/adampresley/vanilla-todo-2021" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">GitHub-adampresley/vanilla-todo-2021:Medium上的一篇文章的代码，该文章介绍了如何在…</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">我写这篇文章是为了回应苏尼尔·桑德胡的一篇关于媒介的文章。在这篇文章中，他在比较如何写作方面做得非常出色…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ln nd"/></div></div></a></div><p id="2b6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Sunil的文章:</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2021-edition-a7ebfc19a9d"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2021版]</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">React vs Vue。Vue和React的并列代码对比！🎉</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nm l"><div class="ns l no np nq nm nr ln nd"/></div></div></a></div></div></div>    
</body>
</html>