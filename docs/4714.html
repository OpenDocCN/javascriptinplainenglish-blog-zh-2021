<html>
<head>
<title>How to Enforce Referential Integrity with Prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Prisma实施参照完整性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-enforce-referential-integrity-with-prisma-1d921b8ff296?source=collection_archive---------8-----------------------#2021-09-20">https://javascript.plainenglish.io/how-to-enforce-referential-integrity-with-prisma-1d921b8ff296?source=collection_archive---------8-----------------------#2021-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bec9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是Prisma系列介绍文章的第四部分。如果你还没有看过以前的文章，你可以在下面找到它们。</p><ul class=""><li id="4461" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><a class="ae kr" rel="noopener ugc nofollow" target="_blank" href="/simplifying-backend-development-with-prisma-564200f31943">使用Prisma简化后端开发</a></li><li id="c20c" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" rel="noopener ugc nofollow" target="_blank" href="/diving-into-prisma-schema-b278e92dff8b">深入探究Prisma模式</a></li><li id="81ce" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" rel="noopener ugc nofollow" target="_blank" href="/data-modeling-with-prisma-5c4c37f31d8c">用Prisma进行数据建模</a></li></ul><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/fd3c8bb2d461561f575c4975781c3851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dz0dbyDCDUHlHfKUK6gflA.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Photo by <a class="ae kr" href="https://unsplash.com/@flyd2069?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">FLY:D</a> on <a class="ae kr" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f838" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前面的部分中，虽然我们创建了表和记录之间的关系，但是我们没有考虑这些关系之间的行为。我们没有考虑<a class="ae kr" href="https://en.wikipedia.org/wiki/Referential_integrity" rel="noopener ugc nofollow" target="_blank">参照完整性</a>。我们需要确保当这些相关父记录之一被更新或删除时，数据库引擎将如何反应。</p><p id="77ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将看看如何通过Prisma模式实现这一点。</p><h1 id="31d7" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">让我们在🤿潜水吧</h1><p id="775a" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">现在想象一下，如果从用户表中删除一条用户记录，会发生什么情况。或者如果应用于post记录的标签被更新，需要发生什么。SQL系统有适当处理这种情况的机制。</p><p id="22b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在MySQL中，可以在更新或删除时通过引用操作来执行这些操作。</p><h2 id="1fc2" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated"><strong class="ak">上删除级联</strong> &amp; <strong class="ak">上更新级联</strong></h2><p id="9d30" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">在删除父表记录时，如果在删除级联上设置为<strong class="jm io"/>将自动删除子表中的匹配行。</p><p id="b734" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，for <strong class="jm io"> ON UPDATE CASCADE </strong>告诉数据库，当父表中发生更新时，子表中的匹配记录必须用新值映射。</p><h2 id="88dd" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated"><strong class="ak">删除集合上的空值&amp;更新集合上的空值</strong></h2><p id="3c9e" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">像<strong class="jm io">级联</strong>一样，我们可以在删除和更新操作中使用<strong class="jm io"> SET NULL </strong>。当父记录被更新或删除时，子表(books)的外键列将被设置为空值。</p><h2 id="df96" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated"><strong class="ak">限制&amp;不动作</strong></h2><p id="53e1" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">设置<strong class="jm io">限制</strong>与删除时省略<strong class="jm io">或更新</strong>子句时省略<strong class="jm io">效果相同。如果父实体有关联的子记录，它会拒绝应用删除或更新操作。</strong></p><p id="111f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">无动作</strong>在不同的SQL数据库引擎中有一定的差异。但在MySQL中，几乎等同于<strong class="jm io">限制</strong>。<strong class="jm io">无动作</strong>如果子表中有相关的外键值，则拒绝父表的删除或更新操作。</p><p id="1d93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们如何用Prisma模式设置这些呢？</p><p id="1315" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是Prisma 模式中的<a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions" rel="noopener ugc nofollow" target="_blank">引用动作发挥作用的地方。</a></p><p id="1d08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们搬进来之前，首先我们需要更新我们的Prisma版本。因为引用动作是从Prisma v.2.26.0开始定义的。</p><p id="89a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将把它更新到最新的版本(3.0.2 ),在这个版本中引用行为是普遍可用的。你可以通过手工修改<strong class="jm io"> <em class="nc"> package.json </em> </strong>中的版本或者直接点击，</p><pre class="ky kz la lb gt nd ne nf ng aw nh bi"><span id="d45e" class="mq lo in ne b gy ni nj l nk nl">npm install prisma@latest --save-dev</span></pre><p id="4e84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将把Prisma CLI版本更新到最新版本。</p><p id="8179" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，您也需要更新Prisma客户端版本。</p><pre class="ky kz la lb gt nd ne nf ng aw nh bi"><span id="2daf" class="mq lo in ne b gy ni nj l nk nl">npm install @prisma/client@latest</span></pre><blockquote class="nm nn no"><p id="de74" class="jk jl nc jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated">如果您在更新Prisma版本时遇到错误，您可以清除node_modules目录和/或npm_cache，然后重试。</p></blockquote><p id="8361" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在可以在<code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#relation" rel="noopener ugc nofollow" target="_blank">@relation</a></code>属性中定义引用动作。</p><p id="3d9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等…在最初的几篇文章中，帖子记录是如何以级联方式被删除的？🤔</p><p id="1743" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Prisma 2.25.0之前，会发生以下默认引用操作。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nv"><img src="../Images/8191e33f836f8727ed57d8374a75db74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*932fyDcLGdRD75wE3G5Elw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Resource: <a class="ae kr" href="https://www.prisma.io/docs/guides/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-2x-default-referential-actions" rel="noopener ugc nofollow" target="_blank">Default referential actions prior to v.2.25.0</a></figcaption></figure><p id="d8bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最新的Prisma版本中，我们使用了以下默认设置。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nw"><img src="../Images/1efa85f032473b00d51d391feebb622d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thbPYTPoWSB4sxZPM2Ffag.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Resource: <a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions/#referential-action-defaults" rel="noopener ugc nofollow" target="_blank">Default referential actions after v.2.26.0</a></figcaption></figure><p id="4711" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让这些默认值反映在我们的数据库中，我们需要运行一个迁移或者执行一个<code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-migrate/db-push" rel="noopener ugc nofollow" target="_blank">prisma db push</a></code>。</p><p id="e0ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们做一个迁移来跟踪数据库模式的变化。</p><pre class="ky kz la lb gt nd ne nf ng aw nh bi"><span id="5ebf" class="mq lo in ne b gy ni nj l nk nl">npx prisma migrate dev --name referential_default_update</span></pre><p id="970d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您试图删除一个用户，将会抛出一个错误。让我们通过Prisma Studio来实现这一点。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nx"><img src="../Images/e2fd87b1a7fae0721b7a7441e3085b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4oNRwxedSDzfWYNV3Tnwcw.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">This ensures that ON DELETE RESTRICT has taken effect between User &amp; Post tables</figcaption></figure><p id="b4ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，为了保持我们在删除相关用户记录后以级联方式删除或更新帖子记录的旧行为，我们需要如下更新帖子模型。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="787e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似于在1-m关系中实施参照完整性，我们也可以将它应用到我们之前构建的显式m-n关系中。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6ee8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着这些变化，</p><ul class=""><li id="282f" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">如果您删除创建帖子的用户，相关的帖子记录将被删除</li><li id="42eb" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">如果您删除一个标签或发布相关的标签分配，TagsOnPosts表中的记录将被删除。</li></ul><blockquote class="nm nn no"><p id="394d" class="jk jl nc jm b jn jo jp jq jr js jt ju np jw jx jy nq ka kb kc nr ke kf kg kh ig bi translated"><em class="in">如果我们在标签&amp;帖子之间使用了隐含的多对多关系，我们将无法使用引用动作。因为m-n关系中的引用操作必须应用于连接表。</em></p></blockquote><p id="0015" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他可用的参考动作有:</p><ul class=""><li id="f7d5" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#restrict" rel="noopener ugc nofollow" target="_blank">Restrict</a></code>:如果应用onDelete防止删除。如果应用于更新，引用字段将无法更新。</li><li id="94cd" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#noaction" rel="noopener ugc nofollow" target="_blank">NoAction</a></code>:与<code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#restrict" rel="noopener ugc nofollow" target="_blank">Restrict</a>.</code>相似，但不同之处在于使用的数据库不同。</li><li id="a80c" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#setnull" rel="noopener ugc nofollow" target="_blank">SetNull</a></code>:如果应用于Delete或onUpdate，引用的标量字段将被设置为空。</li><li id="cbed" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><code class="fe ns nt nu ne b"><a class="ae kr" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions#setdefault" rel="noopener ugc nofollow" target="_blank">SetDefault</a></code>:如果应用于Delete或onUpdate，引用的标量字段将被设置为默认值。</li></ul><p id="0c93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据应用程序域的用例，您将需要使用一个或几个这样的引用操作来提高存储数据的一致性和可靠性。</p><p id="c444" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nc">更多内容尽在</em><a class="ae kr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="nc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>