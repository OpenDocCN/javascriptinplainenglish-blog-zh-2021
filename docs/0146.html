<html>
<head>
<title>13 Concepts/Tips You Should Know in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中你应该知道的13个概念/技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-should-know-these-13-concepts-tips-in-javascript-9592cc0d89c1?source=collection_archive---------16-----------------------#2021-01-08">https://javascript.plainenglish.io/you-should-know-these-13-concepts-tips-in-javascript-9592cc0d89c1?source=collection_archive---------16-----------------------#2021-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8399" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提升等级的基本概念和技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6f66db7dea3aadc0d2009ebe23735416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2YBLjDlw5R6iCuOOluSwQ.jpeg"/></div></div></figure><p id="57db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript有它的批评者和追随者，但很明显它是当今使用最广泛的语言之一，而且，我要说的是，它很有趣，因为你可以对它应用大量的技巧。在这篇文章中，我收集了一些你应该知道的基础知识和一些技巧和提示。</p><h1 id="5d67" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">简而言之，基本概念</h1><ol class=""><li id="03b3" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">创建一个对象构造函数。</li><li id="af15" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">创建一个生命(立即调用函数表达式)。</li><li id="16b8" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">原型。</li><li id="071a" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">范围。</li><li id="e25d" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">关闭。</li></ol><h1 id="d62d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">方便的提示</h1><ol class=""><li id="8817" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">得到一个介于x和y之间的随机数。</li><li id="1fa1" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">将arguments对象转换为数组。</li><li id="f558" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">获取数字数组中的最大值或最小值。</li><li id="a630" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">避免使用eval()。</li><li id="f2e7" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">避免使用函数构造函数。</li><li id="47df" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">避免与()一起使用。</li><li id="e946" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">将超时设置为XMLHttpRequests。</li><li id="3826" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">使用普通JS来加快操作速度。</li></ol><h1 id="94eb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">简而言之，基本概念</h1><h2 id="af83" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">1.创建对象构造函数</h2><p id="b3a4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">构造函数类似于常规函数，但是我们用new关键字来使用它们。如果您想用相同的方法和属性创建相似的对象，构造函数很有用。按照惯例，我们将构造函数的名字大写，以区别于常规函数。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="08d3" class="mv lo iq nl b gy np nq l nr ns">function Person(first, last, age) {<br/>  this.firstName = first;<br/>  this.lastName = last;<br/>  this.age = age;<br/>}</span><span id="2c77" class="mv lo iq nl b gy nt nq l nr ns">let  kesk = new Person("Kesk", "Noren", 37);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e8294d9477076bf948471f84645e82f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*udeqknS-3rLjpNtpCyAaMQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><p id="21e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在构造函数中，这没有值。它是新对象的替代对象。当创建新对象时，此的值将成为新对象。</p><h2 id="41bd" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">2.创建一个<strong class="ak">生命</strong>(立即调用函数表达式)</h2><p id="9e69" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">IIEF是一种一旦创建就立即执行函数的方法。它们很有用，因为它们不会污染全局对象，并且是隔离变量声明的一种方式。</p><p id="4384" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语法:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9891" class="mv lo iq nl b gy np nq l nr ns">(function () {<br/>    statements<br/>})();</span></pre><p id="2b37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="1718" class="mv lo iq nl b gy np nq l nr ns">let myIIEF= (function () {<br/>    var name = "Kesk";<br/>    return name;<br/>})();</span><span id="c9d0" class="mv lo iq nl b gy nt nq l nr ns">//Immediately creates the output.<br/>myIIEF;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/7cbe7dfe1f177bd39414129278263e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*wn4u1jNlJoowlUSMTcmMSA.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><h2 id="8494" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">3.原型</h2><p id="54fb" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">原型是JavaScript对象相互继承特性的机制。所有JavaScript对象都从原型继承属性和方法。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6894" class="mv lo iq nl b gy np nq l nr ns">function Car(model,color){<br/>   this.model = model,<br/>   this.color = color,<br/>  <br/>   this.getDescription= function(){<br/>     return this.model+' car is of the color '+this.color;<br/>   }<br/>}</span><span id="4179" class="mv lo iq nl b gy nt nq l nr ns">var car1 = new Car('Ford','Grey');</span><span id="0324" class="mv lo iq nl b gy nt nq l nr ns">console.log(car1.getDescription());<br/>//Ford car is of the color Grey</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f2da574d83c03a573f056e0ca4920010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*_k6CnM6d201YItICmtnPTQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><p id="319c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向“汽车”原型添加一个新方法:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6dcd" class="mv lo iq nl b gy np nq l nr ns">Car.prototype.getColor = function(){ return this.color };</span><span id="7131" class="mv lo iq nl b gy nt nq l nr ns">car1.getColor();</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cb797179d15960d9073681d155b6945c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*cLzuUVOk2ofq5nu0IztL0A.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="8ced" class="mv lo iq nl b gy np nq l nr ns">console.log(car1.__proto__ === Car.prototype );<br/>//true</span></pre><p id="503c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“prototype”是在用new创建对象时用来构建__proto__的对象。</p><p id="c8e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">__proto__是查找链中用于解析方法、属性等的实际对象。</p><h2 id="8916" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">4.范围</h2><p id="1814" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">JavaScript中的函数为使用var、let和const声明的变量定义了作用域。</p><p id="d8e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在函数体内声明一个var变量:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="4421" class="mv lo iq nl b gy np nq l nr ns">function sum(a, b) {<br/>  //"sum" function scope<br/>  var result = a + b; <br/>  console.log("The result is:" + result); <br/>  //The result is: 3<br/>}</span><span id="dc9e" class="mv lo iq nl b gy nt nq l nr ns">sum(1,2);<br/>//3</span><span id="a165" class="mv lo iq nl b gy nt nq l nr ns">console.log(result); <br/>//throws ReferenceError</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e45a5bdc13af2456cef36588bbf56b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*kEK535u20oBlA2lNLX79lw.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><p id="c229" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">sun()函数体创建了一个作用域。变量“result”在函数范围内是可访问的，但在函数范围外是不可访问的。</p><h2 id="cc66" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">5.关闭</h2><p id="4d5f" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated"><em class="od">闭包是与对其周围状态(词法环境)的引用捆绑在一起(封闭)的函数。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</em></p><p id="b0e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当内部函数可以访问其外部函数变量和参数时，就创建了闭包。内部函数可以访问:<br/> 1。自身的变数。<br/> 2。外部函数的变量和参数。<br/> 3。全局变量。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="0570" class="mv lo iq nl b gy np nq l nr ns">//Our outher function<br/>function counter() {<br/>  let count = 0;<br/>  //Our inner function  <br/>  return function() {<br/>    return count++;<br/>  };<br/>}</span><span id="720e" class="mv lo iq nl b gy nt nq l nr ns">const myCounter = counter();<br/>myCounter(); // 0<br/>myCounter(); // 1</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0ec91ecda5a21e354660b75aabc79212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*pXk0fEyNqa7SHQFjpBo5Uw.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><h1 id="2868" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">方便的提示</h1><h2 id="5b1d" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">1.获取x和y之间的一个随机数</h2><p id="be0c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">要获得0到1之间的随机数，请使用Math.random函数:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3613" class="mv lo iq nl b gy np nq l nr ns">console.log(Math.random());</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9254a936b2d0922ec205110e292673bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*5Th1bOgGEYhqmkRQCHwb9w.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><p id="cda5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想要一个1到10之间的随机数，我们必须将数学结果相乘。随机乘以10，然后向上或向下取整:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="28e2" class="mv lo iq nl b gy np nq l nr ns">console.log(Math.ceil(Math.random() * 10));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dca15149ccc6fad1ec3a3bf2a24762fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*yQ5orIcpezla-xP-ECUKDg.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><h2 id="0c35" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">2.将arguments对象转换为数组</h2><p id="1b97" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">JavaScript中的arguments对象在大多数情况下就像一个数组，但它实际上不是一个数组对象。因为它完全是另外一个东西，它没有Array.prototype中有用的函数，比如forEach、sort或filter。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="5d5a" class="mv lo iq nl b gy np nq l nr ns">function sortArgs(...args) {<br/>  return args.sort(function (a, b) { return a - b; });<br/>}</span><span id="63a2" class="mv lo iq nl b gy nt nq l nr ns">sortArgs(1,2,3,4,5);<br/>//[1,2,3,4,5]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2d0eff0e83a1a7704a55eae8a8580e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*60i8OPdhxUKnHhJPXJu2eQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><h2 id="e490" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">3.获取数字数组中的最大值或最小值</h2><p id="b9b0" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">使用这个技巧可以很容易地得到一系列数字的“最小值”和“最大值”:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="aa94" class="mv lo iq nl b gy np nq l nr ns">let andArray = [1, 2, 3, 10, 30, -10, -100]; <br/>let max= Math.max.apply(Math, andArray);<br/>let min= Math.min.apply(Math, andArray);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/134f3c8b0d6051c54cd2bfceae11637e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*UwEV5MCBlnrSDMKtTLHgeQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Result in the Google Chrome dev console.</figcaption></figure><h2 id="f3cc" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">4.避免使用eval()</h2><p id="84d2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">您应该避免使用它的主要原因不仅是性能问题，而且主要是安全问题。从字符串中评估JavaScript代码是危险的，因为该字符串可能包含将在用户机器上运行的恶意代码。</p><p id="b5ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您试图评估用户的输入，可能会导致无限循环或删除文件。在Node.js中这样做会删除当前目录中的所有文件！</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="647e" class="mv lo iq nl b gy np nq l nr ns">const userInput = `require("child_process").exec('rm -rf ./*')`;</span><span id="0a3f" class="mv lo iq nl b gy nt nq l nr ns">eval(`console.log("User input: ${userInput}")`);</span></pre><p id="22b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有安全字符串评估的第三方备选方案，或者我们可以使用全局函数()来编写我们自己的自定义评估函数。</p><h2 id="e0b4" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">5.避免使用函数构造函数</h2><h2 id="be8b" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">6.避免使用with()</h2><p id="c27f" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">with语句为一组语句设置默认对象。</p><p id="ae3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语法:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="be46" class="mv lo iq nl b gy np nq l nr ns">with (expression)<br/>  statement</span></pre><p id="8dba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们应该避免使用with()主要有三个原因:</p><p id="ade8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">意外行为</p><p id="df0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的例子中，由于对象中不存在属性“color ”,所以创建了一个与之无关的新全局变量。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="a69a" class="mv lo iq nl b gy np nq l nr ns">with(document.getElementById('el').style) {<br/>    colors = '#'; <br/>}</span></pre><p id="9728" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">表演</p><p id="6f72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当涉及到大对象的迭代时，这个函数的代价是很重要的。这里的主要缺点是我们不能优化对“arg”的访问，因为我们不知道它是引用一个实变量还是要覆盖的对象的一个属性。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="fa52" class="mv lo iq nl b gy np nq l nr ns">function foo(arg) {<br/>  with(arg) {<br/>    console.log("The arg: "+arg)<br/>  }<br/>}</span></pre><p id="5364" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安全性</p><p id="88d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是不赞成使用这种方法的主要原因。我们不能通过查看代码来确定函数标识符指的是什么，因为它是一个词法环境。</p><h2 id="a378" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">7.将超时设置为XMLHttpRequests</h2><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6e50" class="mv lo iq nl b gy np nq l nr ns">xhrRequest = new XMLHttpRequest();</span><span id="a6b9" class="mv lo iq nl b gy nt nq l nr ns">xhrRequest.onreadystatechange = () = {  <br/>  if (this.readyState == 4) {  <br/>     clearTimeout(timeout);  <br/>     //do some stuff with response.<br/>  }  <br/>}</span><span id="3c21" class="mv lo iq nl b gy nt nq l nr ns">let timeout = setTimeout( () =&gt; {  <br/>    xhr.abort(); <br/>}, 60*5000);<br/> <br/>//timeout after five minutes<br/>xhrRequest.open('GET', url, true);</span><span id="ab21" class="mv lo iq nl b gy nt nq l nr ns">xhrRequest.send();</span></pre><h2 id="422c" class="mv lo iq bd lp mw mx dn lt my mz dp lx la na nb lz le nc nd mb li ne nf md ng bi translated">8.使用普通JS来加快操作速度。</h2><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="af03" class="mv lo iq nl b gy np nq l nr ns">var min = Math.min(a , b);</span></pre><p id="d69a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最好使用</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="6c64" class="mv lo iq nl b gy np nq l nr ns">var min = a &lt; b ? a : b; <br/>A[A.length] = v;</span></pre><p id="fb0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只有在代码的可读性没有下降时才这样做，因为通常使代码易于阅读和维护比使用技巧使代码更快更重要。</p><p id="c2f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢你读给我听。我希望你喜欢这个汇编。在这难得的艰难时刻保重！</p><h1 id="6ab0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">参考</h1><p id="8174" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated"><a class="ae oj" href="https://developer.mozilla.org/es/" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></div></div>    
</body>
</html>