<html>
<head>
<title>How I Created an Event-Driven Backend with RxJS, Server-Sent Events, Express, and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用rjs、服务器发送事件、Express和Node.js创建事件驱动后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-created-an-event-driven-backend-with-rxjs-server-sent-events-and-expressjs-9f8be1ffc123?source=collection_archive---------1-----------------------#2021-05-29">https://javascript.plainenglish.io/how-i-created-an-event-driven-backend-with-rxjs-server-sent-events-and-expressjs-9f8be1ffc123?source=collection_archive---------1-----------------------#2021-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d58f66e8f7211b35861ef1f40b9c0da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-T7KT9J-5JplHXJ1nhPQg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Monke Cafe</figcaption></figure><p id="dc0b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大约一个月前，我和一个朋友想出了一个小网站的主意，并决定在几天内创建一个MVP来尝试一下。这个想法很简单；一个迷因驱动的聊天室和每种密码货币的实时价格图表。我被分配为这个项目创建后端，我的朋友会制作网络客户端。</p><p id="fbc8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在开始使用服务器之前，我为自己设定了三个要求。首先也是最重要的一点，我想尽快得到MVP。其次，我想让服务器尽可能的轻量级，让它运行在一个便宜的虚拟机上。最后，我想设计一个架构，以便在投资者决定做出另一个愚蠢的决定并使用我们的应用程序时，可以轻松扩展。</p><p id="29e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一步是将整个服务器视为一个管道。基本上，整个过程是一个管道，它消耗一组事件，处理它们，然后将它们流式传输到许多客户端。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kx"><img src="../Images/3d9d9039a6137bb5a1aae66748ec24d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9nnGZs_yqZfPxam8buiow.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Pipeline Architecture</figcaption></figure><p id="d848" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">任何传入的数据都可以被视为某种事件。例如，我们有用户加入或离开房间，发布或删除评论，以及股票价格更新。另一方面，任何消费这些事件的东西都可以被认为是客户；我们的数据库、缓存和所有连接的浏览器。</p><p id="a98e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">仔细考虑之后，我首先想到的是<a class="ae lc" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">rjs</a>和<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" rel="noopener ugc nofollow" target="_blank">服务器发送事件</a>的组合。我从来没有写过服务器端的javascript项目，因为我主要使用Golang和Python，但是我真的很想在服务器端尝试rjs，这似乎是尝试的最佳时机。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kx"><img src="../Images/2efcf080d05bc58e980938b6d3b23502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H08fb-5QAjCxXVn8o5DQyA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Server-Sent Events (SSE) + RxJS</figcaption></figure><p id="5ec2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了更详细地解释实现，我将逐步实现一个非常简单的股票/密码货币实时价格流端点。首先，我们需要一个<a class="ae lc" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank"> RxJS </a>主题，它是一个可观察到的多播。我们的主题将负责向我们的所有客户(订户)流式传输股票报价事件。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="1056" class="li lj in le b gy lk ll l lm ln">import { Subject } from 'rxjs';<br/>import { filter, map } from 'rxjs/operators';</span><span id="739f" class="li lj in le b gy lo ll l lm ln">// our RxJS subject<br/>const TickerSubject = new Subject();</span></pre><p id="1534" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要一个入口点，将我们的事件推送到我们的流中。我们可以直接向我们的主题发出，或者创建一个包装函数作为抽象层，并在发出新事件之前清理和检查我们的数据。</p><p id="b981" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，让我们定义一个名为<strong class="kb io"> <em class="lp"> EmitTickerPrice的函数。</em> </strong>每当我们得到一个新的股票价格数据时，我们会用适当的参数调用这个方法，它会向我们的股票主体发出一个新的事件。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="15cf" class="li lj in le b gy lk ll l lm ln">/**<br/> * Emit a new ticker price<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} symbol: ticker symbol<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} price: ticker price<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} currency: ticker currency<br/> */<br/>const EmitTickerPrice = async (symbol, price, currency) =&gt; {<br/>    const ticker = {<br/>        symbol, price, currency,<br/>        createdAt: Math.floor(new Date() / 1000),<br/>    };<br/>    TickerSubject.next(ticker);<br/>    return ticker;<br/>};</span></pre><p id="50d0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于我们的项目，我使用PostgreSQL来保存历史股价信息。我还使用Redis作为缓存存储，以减少当客户请求数据来呈现价格图表时的数据库负载。如我之前所述，每一个都被视为客户，并独立订阅我们的<a class="ae lc" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">rjs</a>受试者。我们可以在我们的跑马灯主题上调用subscribe，并传递一个回调方法来观察和处理每个传入的事件。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="0e16" class="li lj in le b gy lk ll l lm ln">TickerSubject.subscribe(ticker =&gt; {})</span></pre><p id="5562" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很容易，对吧？嗯，不完全是。看，在我们的网站上，我们每隔五秒钟就为每个受支持的股票和隐币股票推出一个新的股票报价事件。这些事件也不是同步的，并且以不同的时间间隔出现，这意味着我们每秒钟都会收到几十个ticker事件。问题在于，我们不想在每次发出新事件时调用我们的Redis和PostgreSQL订阅者回调。相反，我们希望在我们的管道中实现一些额外的逻辑来减少这些服务的负载。</p><h2 id="e97d" class="li lj in bd lq lr ls dn lt lu lv dp lw kk lx ly lz ko ma mb mc ks md me mf mg bi translated"><strong class="ak"> PostgreSQL观察者</strong></h2><p id="c1de" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">让我们从PostgreSQL开始；每次发出新的股票价格时单独插入一行是不理想的。这可能因不同的项目而不同，因为在某些情况下，我们可能需要原子插入。然而，对于该项目，30秒的插入延迟可以忽略不计。幸运的是，<a class="ae lc" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">rjs</a>通过提供管道和几十个操作员使得实现这个功能变得非常容易。对于我们的情况，我们可以创建一个管道，并使用<strong class="kb io"><em class="lp">buffer times</em></strong>运算符将我们的事件缓冲30，000毫秒。然后，我们可以订阅新定义的管道。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="2ca3" class="li lj in le b gy lk ll l lm ln">import { bufferTime } from 'rxjs/operators';</span><span id="08c8" class="li lj in le b gy lo ll l lm ln">TickerSubject.TickerSubject.pipe(<br/>    bufferTime(30000),<br/>).subscribe(tickers =&gt; {})</span></pre><p id="c2c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的订阅者每30秒钟被调用一次，取而代之的是它得到过去缓冲期内的缓冲事件列表。</p><h2 id="ee84" class="li lj in bd lq lr ls dn lt lu lv dp lw kk lx ly lz ko ma mb mc ks md me mf mg bi translated">Redis观察者</h2><p id="e171" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">有了Redis，我们的问题变得更有趣了。正如我之前提到的，Redis主要用于缓存生成网站上显示的价格图表所需的价格点。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/5834ca108502c8bc29c7bf93d55b2e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xrC4C1vjpyi3TuJ6.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Monke Cafe Price Chart</figcaption></figure><p id="e17a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此图表是为不同的时间间隔创建的，例如过去5分钟、1小时或1天。正如您现在所知，我们的24小时图表不需要每5秒钟就有一个数据点；相反，每30分钟甚至一小时一个数据点就可以完成这项工作。</p><p id="89c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的Redis观察员应在致电订户前将每个唯一的股票代码限制30分钟。为了实现这一点，我们需要创建一个比我们之前为PostgreSQL观察者创建的管道更复杂的管道。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kx"><img src="../Images/df7cd023e52fbe2fd96f14b52557bcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cjkZuvUXEusrvXUyy3IgA.png"/></div></div></figure><p id="521d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们必须根据事件的代码对其进行分组。为此，我们可以使用由<a class="ae lc" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank"> RxJS </a>提供的<strong class="kb io"> <em class="lp"> groupBy </em> </strong>操作符，并提供一个箭头函数来指定我们如何对这些事件进行分组。我们希望我们的事件组基于他们的股票代码；因此，我们从arrow函数中返回股票代码值。</p><p id="b7ad" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们将限制每个组每30分钟发射一次，最后将所有组合并到一个管道中。我们可以使用<strong class="kb io"> <em class="lp"> mergeMap </em> </strong>操作符，通过每组映射来添加<strong class="kb io"> <em class="lp"> throttleTime </em> </strong>操作符，间隔30分钟。最后，我们可以订阅管道并将数据插入Redis服务器。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="4529" class="li lj in le b gy lk ll l lm ln">import { groupBy, mergeMap, throttleTime } from 'rxjs/operators';</span><span id="c95b" class="li lj in le b gy lo ll l lm ln">TickerSubject.pipe(<br/>    groupBy((ticker) =&gt; ticker.symbol),<br/>    mergeMap((group) =&gt; group.pipe(<br/>        throttleTime(30 * 60 * 1000),<br/>    )),<br/>).subscribe(ticker =&gt; {})</span></pre><p id="f4a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们甚至可以更进一步，缓冲这些事件以利用Redis管道，但我将跳过这一部分，因为它看起来几乎与我们对PostgreSQL管道所做的一样。</p><p id="e7b2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你已经走了这么远，拍拍自己的背，深呼吸，然后去喝点咖啡，免得我们被服务器发送的事件弄脏了手。</p><h2 id="947c" class="li lj in bd lq lr ls dn lt lu lv dp lw kk lx ly lz ko ma mb mc ks md me mf mg bi translated">服务器发送的事件端点</h2><p id="e137" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">对于我们的网站，我正在使用<a class="ae lc" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae lc" href="https://www.npmjs.com/package/@awaitjs/express" rel="noopener ugc nofollow" target="_blank"> @awaitjs/express </a>库在我的路由器中使用async/await。通过GET方法在我们的express服务器上注册路径<strong class="kb io"><em class="lp">/ticker/:symbol/event</em></strong>来创建我们的服务器发送事件路径。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="0972" class="li lj in le b gy lk ll l lm ln">Router.getAsync('/ticker/:symbol/event', async (req, res) =&gt; {})</span></pre><p id="1a14" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了启用SSE，我们需要将几个头刷新回我们的客户端。我们要将<strong class="kb io"> <em class="lp">【连接】</em> </strong>设置为<strong class="kb io"> <em class="lp">【保活】</em></strong><strong class="kb io"><em class="lp">【缓存-控制】</em> </strong>设置为<strong class="kb io"> <em class="lp">【无缓存】</em> </strong>和<strong class="kb io"> <em class="lp">【内容-类型】</em> </strong>设置为<strong class="kb io"> <em class="lp"> </em> </strong>到<strong class="kb io"> <em class="lp">【正文/文</em></strong></p><p id="a210" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，我还为CORS添加了<strong class="kb io"><em class="lp">‘访问-控制-允许-起源’</em></strong>，并将<strong class="kb io"><em class="lp">‘X-加速-缓冲’</em></strong>设置为<strong class="kb io"><em class="lp">‘否’</em></strong>，以避免<a class="ae lc" href="https://www.nginx.com" rel="noopener ugc nofollow" target="_blank"> Nginx </a>打乱这条路线。最后，我们可以将标头刷新回我们的客户端，以启动事件流。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="37f2" class="li lj in le b gy lk ll l lm ln">Router.getAsync('/ticker/:symbol/event',<br/>    async (req, res) =&gt; {<br/>        res.setHeader('Cache-Control', 'no-cache');<br/>        res.setHeader('Content-Type', 'text/event-stream');<br/>        res.setHeader('Connection', 'keep-alive');<br/>        res.setHeader('Access-Control-Allow-Origin', '*');<br/>        res.setHeader('X-Accel-Buffering', 'no');<br/>        res.flushHeaders();<br/>});</span></pre><p id="1346" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们可以通过在响应中写入一些内容来开始传输数据。SSE提供了一个基于文本的协议，我们可以用它来帮助我们的客户区分事件类型。我们的每一个事件应该如下所示:</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="5b0b" class="li lj in le b gy lk ll l lm ln">event: ${event name}\n<br/>data: ${event data}\n\n</span></pre><p id="cd5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了让我们的生活变得简单一点，我创建了一个助手函数来为我们处理序列化。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="e6bd" class="li lj in le b gy lk ll l lm ln">/**<br/> * SSE message serializer<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} event: Event name<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Object} data: Event data<br/> * <a class="ae lc" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {string}<br/> */<br/>const EventSerializer = (event, data) =&gt; {<br/>    const jsonString = JSON.stringify(data);<br/>    return `event: ${event}\ndata: ${jsonString}\n\n`;<br/>};</span></pre><p id="fbc1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们的网站上，我们有半打类似于我们到目前为止已经创建的主题。为了能够区分这些事件，我们必须为每个事件指定一个名称。让我们使用“<strong class="kb io"> <em class="lp"> price_update </em> </strong>”作为股票主题。此外，我们需要根据客户端订阅的动态路径来过滤这些事件。比如在<strong class="kb io"><em class="lp">/ticker/DOGE/event</em></strong>上，我们只想要与Dogecoin相关的事件。为了实现这两个特性，让我们在ticker subject周围创建一个新的包装器来过滤管道，并将我们的事件名称添加到事件中。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="38eb" class="li lj in le b gy lk ll l lm ln">import { filter, map } from 'rxjs/operators';</span><span id="2c06" class="li lj in le b gy lo ll l lm ln">/**<br/> * Event stream for ticker price update<br/> * <a class="ae lc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} symbol: ticker symbol<br/> * <a class="ae lc" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {Observable&lt;{data: *, name: string}&gt;}<br/> */<br/>function EventTickerStream(symbol) {<br/>   return TickerSubject<br/>      .pipe(<br/>         filter((ticker) =&gt; ticker.symbol === symbol),<br/>         map((ticker) =&gt; {<br/>            return { data: ticker, name: 'price_update' };<br/>         }<br/>      ),<br/>   );<br/>}</span></pre><p id="ed24" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">剩下要做的就是将这些事件合并到一个管道中，并创建一个新的订阅者来将它们写入SSE连接。我们可以使用 操作符的<strong class="kb io"> <em class="lp">从我们所有的主题创建一个管道。然后，我们使用<strong class="kb io"> <em class="lp"> mergeAll </em> </strong>操作符来收集并合并我们所有的可观测值到一个单独的可观测值中。然后，我们可以订阅可观察对象，序列化我们的数据并将其写入我们的响应。最后，当SSE连接关闭时，我们必须确保取消订阅我们的观察者。将所有这些放在一起，我们应该有如下内容</em></strong></p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="d635" class="li lj in le b gy lk ll l lm ln">import { of } from 'rxjs';<br/>import { mergeAll } from 'rxjs/operators';</span><span id="0760" class="li lj in le b gy lo ll l lm ln">Router.getAsync('/ticker/:symbol/event',<br/>    async (req, res) =&gt; {</span><span id="32cf" class="li lj in le b gy lo ll l lm ln">        res.setHeader('Cache-Control', 'no-cache');<br/>        res.setHeader('Content-Type', 'text/event-stream');<br/>        res.setHeader('Connection', 'keep-alive');<br/>        res.setHeader('Access-Control-Allow-Origin', '*');<br/>        res.setHeader('X-Accel-Buffering', 'no');<br/>        res.flushHeaders();</span><span id="c82e" class="li lj in le b gy lo ll l lm ln">        const symbol = req.params.symbol.toUpperCase();</span><span id="6771" class="li lj in le b gy lo ll l lm ln">        const stream$ = of(<br/>            EventTickerStream(symbol),<br/>            // other events ...<br/>        ).pipe(<br/>            mergeAll(),<br/>        ).subscribe((event) =&gt; {<br/>            res.write(EventSerializer(event.name, event.data));<br/>        });</span><span id="830b" class="li lj in le b gy lo ll l lm ln">        req.on('close', () =&gt; {<br/>            stream$.unsubscribe();<br/>        });<br/>});</span></pre><p id="08e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Aaannddd…就是这样！我们完成了后端服务器。这是我们到目前为止所创造的东西的一个总体视图。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kx"><img src="../Images/08f3add629080cef6a19b95bf3f115cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YN4_jsUOIr0OGnSAZETXg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">RxJS and Server-Sent Events (SSE) Backend Architecture</figcaption></figure><h2 id="47c9" class="li lj in bd lq lr ls dn lt lu lv dp lw kk lx ly lz ko ma mb mc ks md me mf mg bi translated">服务器发送的事件客户端</h2><p id="0adf" class="pw-post-body-paragraph jz ka in kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ig bi translated">为了订阅SSE路由，我们可以创建EventSource接口的新实例，并将端点传递给构造函数。一旦有了实例，我们就可以为特定的事件名称添加事件处理程序来处理传入的数据。在我们的例子中，我们可以为Dogecoin订阅<strong class="kb io"><em class="lp">【price _ update】</em></strong>事件，并使用该数据更新我们的UI。</p><pre class="ky kz la lb gt ld le lf lg aw lh bi"><span id="0ff1" class="li lj in le b gy lk ll l lm ln">const eventSource = new EventSource("/ticker/DOGE/event");</span><span id="f639" class="li lj in le b gy lo ll l lm ln">eventSource.addEventListener(<br/>   "price_update", (event) =&gt; {<br/>       const data = JSON.parse(event.data);<br/>       // use the data to update the UI<br/>    }, false<br/>);</span><span id="7abb" class="li lj in le b gy lo ll l lm ln">// close the connection when needed<br/>eventSource.close();</span></pre></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="13a4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我对这个架构很满意，因为它满足了我对这个项目的大部分需求。与命令式模型相比，采用反应式设计使我能够更有效地实现许多复杂的特性，并且不容易出错。RxJS提供的更高级的函数，比如throttleTime和bufferTime，很快就解决了我的很多问题，也为我节省了很多开发时间。完成MVP的第一次迭代花了我们大约4天的时间。</p><p id="6700" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我还想将我们的服务部署在最小的虚拟机上，以降低成本并测试服务器端性能。因此，我选择了每月5美元的数字海洋水滴。在过去的一周里，我们的服务器服务了超过370万个请求和超过1.2亿个事件，在某一点上，我们有超过500个并发客户端，我认为这是一个非常好的基准。</p><p id="c5ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在可扩展性方面，我们仍有很大的垂直增长空间，可以增加虚拟机上的可用资源。但是如果我们想要水平增长，当前的架构允许我们部署订阅我们的管道的代理，或者通过我们的SSE端点或者通过网络订阅主题，然后将事件复用到更多的客户端。</p><p id="256b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">关于我如何为我们的项目实现事件驱动服务器的讨论到此结束。</p><p id="df05" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢您的阅读；如果你想聊天，你可以在Twitter <a class="ae lc" href="https://twitter.com/ImSh4yy" rel="noopener ugc nofollow" target="_blank"> @imsh4yy </a>或通过这里的回复找到我。</p><p id="3f65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更新:我最近开始了一个新项目，并且一直在使用相同的架构设计向我的用户推送信息。我很想听到你对这个项目的反馈:【logsnag.com<a class="ae lc" href="https://logsnag.com" rel="noopener ugc nofollow" target="_blank"/></p><p id="0c74" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="lp">更多内容尽在</em><a class="ae lc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lp">plain English . io</em></a></p></div></div>    
</body>
</html>