<html>
<head>
<title>Enhance Your Front-End State Management with View Models — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用视图模型增强您的前端状态管理—第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/enhance-your-frontend-state-management-with-view-models-part2-5a9384bd863c?source=collection_archive---------6-----------------------#2021-04-22">https://javascript.plainenglish.io/enhance-your-frontend-state-management-with-view-models-part2-5a9384bd863c?source=collection_archive---------6-----------------------#2021-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/90c71cc8f31cb7ad788692e629872ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*owmjHh8NV0Y0eLdI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florian Olivo</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8283" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">引擎盖下:</em> </strong> <em class="ky">设计目标并实现基于</em> <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> <em class="ky">模板文字</em> </a> <em class="ky">的视图模型。</em></p><p id="3c60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这个名字听起来没有印象，模板文字以前被称为模板字符串。从语法上来说，它们看起来像一个字符串，只是包装在``中。</p><p id="fb83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:<code class="fe kz la lb lc b">`&lt;button&gt;${myButtonText}&lt;/button&gt;`</code></p><p id="282e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板文字在给定的范围内直接解析像<code class="fe kz la lb lc b">${myButtonText}</code>这样的变量。</p><p id="0793" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用它们做更多的事情！</p><p id="ed48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">欢迎来到第2部分！</strong></p><blockquote class="ld le lf"><p id="87f5" class="ka kb ky kc b kd ke kf kg kh ki kj kk lg km kn ko lh kq kr ks li ku kv kw kx ig bi translated"><strong class="kc io">旁注— </strong>本文是对“使用模板文字创建绑定引擎”的扩展重写。对于neo.mjs第2版，关于如何使用绑定格式化程序的语法从字符串转换为函数，这在以前的文章中没有反映出来。如果你已经读过，看看新的内容部分3 &amp; 4。</p></blockquote><h1 id="4cc3" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">内容</h1><ol class=""><li id="2c99" class="mh mi in kc b kd mj kh mk kl ml kp mm kt mn kx mo mp mq mr bi translated">介绍</li><li id="4443" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">如何使用视图模型改进前端架构的示例</li><li id="b46a" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">如何从字符串中提取数据变量？</li><li id="0aa4" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">如何从模板文本中提取数据变量？</li><li id="1c9e" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">在哪里存储绑定格式化程序中使用的数据属性？</li><li id="c28f" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">我们如何获取嵌套数据属性的变更事件？</li><li id="e9d4" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">如何在内部保存绑定？</li><li id="94cb" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">源代码位置</li><li id="d379" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">支持绑定格式化程序中的方法</li><li id="840a" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">最后的想法</li></ol><h1 id="e778" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">附录</h1><ol class=""><li id="bc36" class="mh mi in kc b kd mj kh mk kl ml kp mm kt mn kx mo mp mq mr bi translated">neo.mjs是什么？</li></ol><h1 id="db3e" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.介绍</h1><p id="3a0f" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">对于<a class="ae jz" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>视图模型实现，我的目标是支持模板引擎的通用特性，而根本不构建或使用模板引擎。</p><p id="82d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">阅读本文不需要任何使用neo.mjs的经验。</p><p id="3846" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模板文字是一个完美的选择，因为在这一点上浏览器的支持是惊人的:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/b7c96f8658744483abf84747c6083efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sn_Z4QdiYNvKhdOt.png"/></div></div></figure><p id="6ec6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们确实希望手动解析绑定格式化程序，以确定包含哪些变量。我们需要在使用的变量和组件配置之间建立绑定，组件配置使用绑定格式化程序来动态更新值，以防任何使用的变量发生变化。</p><p id="d72c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于模板文字的本质是立即解析变量，所以我们不能使用``来定义格式化程序。</p><p id="2228" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="860d" class="nj lk in lc b gy nk nl l nm nn">`Hello ${1+2} ${data.button1Text + data.button2Text}`</span></pre><p id="eaa2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不会包含任何关于所用变量的信息。</p><p id="fc14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，我们将文字包装到函数中，以防止直接执行:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="2a0d" class="nj lk in lc b gy nk nl l nm nn">data =&gt; `Hello ${1+2} ${data.button1Text + data.button2Text}`</span></pre><p id="8a6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以使用箭头函数来获得更好的可读性，real函数的性能稍好一些，因为我们是在离绑定组件最近的视图模型的范围内执行它们的。</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="fc38" class="nj lk in lc b gy nk nl l nm nn">data: function(data) {<br/>    return `Hello ${1+2} ${data.button1Text + data.button2Text}`<br/>};</span></pre><h1 id="2313" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.如何通过使用视图模型来改进前端架构的示例</h1><p id="3246" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">如果您对查看视图模型实现的实例(代码、视频、在线演示)感兴趣，我强烈推荐您阅读本文的第1部分:</p><div class="no np gp gr nq nr"><a href="https://tobiasuhlig.medium.com/enhance-your-frontend-state-management-with-view-models-7bf49e1a0991" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">使用视图模型增强您的前端状态管理</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">您很可能使用过MobX、Redux或React上下文API。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">tobiasuhlig.medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jt nr"/></div></div></a></div><p id="ceb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显而易见的答案:<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">正则表达式</a>。</p><p id="b884" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于neo.mjs上下文，所有变量都存储在一个<code class="fe kz la lb lc b">data</code>属性中。</p><p id="8c9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我去了:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="3913" class="nj lk in lc b gy nk nl l nm nn">/(data|[a<strong class="lc io">-</strong>z])((?!(\.[a<strong class="lc io">-</strong>z_]\w*\(\)))\.[a<strong class="lc io">-</strong>z_]\w*)+/gi</span></pre><p id="4cfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我肯定不是regex方面的专家，所以我使用了一个在线工具来测试和修改它:</p><div class="no np gp gr nq nr"><a href="https://regex101.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">regex101:构建、测试和调试regex</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">正则表达式测试器，语法高亮，解释，PHP/PCRE，Python，GO，JavaScript的备忘单…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">regex101.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of jt nr"/></div></div></a></div><p id="45dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需将“风味”更改为ECMAScript，就可以开始了:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/705b8232b96664a1a2d5bc367a70d8ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLQB15hobIdgZqj-yoz_Hw.png"/></div></div></figure><ol class=""><li id="32ed" class="mh mi in kc b kd ke kh ki kl oi kp oj kt ok kx mo mp mq mr bi translated">我们确实想支持嵌套变量</li><li id="d033" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">变量可能以一个类似于<code class="fe kz la lb lc b">toLowerCase()</code>的函数结束，我们确实想忽略它(这是负前瞻的原因)。</li></ol><p id="d529" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于那些读过本文前一版本的读者:</p><p id="4cda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正则表达式的开始已被更改:</p><p id="2ffc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以前是<code class="fe kz la lb lc b">data</code>，现在是<code class="fe kz la lb lc b">(data|[a-z)])</code>。</p><p id="a39f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然旧的正则表达式在dev模式和dist/development中工作得很好，但在字符串到文字的fn更改之后，它不再在dist/production中工作。</p><p id="53c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因很简单:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="1818" class="nj lk in lc b gy nk nl l nm nn">bind: {<br/>    value: <strong class="lc io">data</strong> =&gt; `${<strong class="lc io">data</strong>.button3Text}`<br/>}</span></pre><p id="235e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">功能确实变小了。</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="fcc2" class="nj lk in lc b gy nk nl l nm nn">bind:{value:<strong class="lc io">e</strong>=&gt;`${<strong class="lc io">e</strong>.button3Text}`}</span></pre><p id="f773" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此正则表达式还需要支持起点的任何1个字符长的变量名。模型。组件逻辑得到了增强，仍然可以将找到的数据属性映射到<code class="fe kz la lb lc b">this.data</code>。</p><h1 id="bf2f" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">4.如何从模板文本中提取数据变量？</h1><p id="4955" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">简而言之:不可能。</p><p id="2154" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么<strong class="kc io">以前的</strong>视图模型版本使用模板文本格式的字符串，解析这些字符串，然后将它们转换成文本。</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="34bc" class="nj lk in lc b gy nk nl l nm nn">const fn = new <strong class="lc io"><em class="ky">Function</em></strong>('data', 'return `' + formatter + '`;');</span></pre><p id="a9ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">忘记你已经看过这个把戏，因为它是一个安全问题。</p><p id="c3e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe kz la lb lc b">new Function()</code>在幕后调用<code class="fe kz la lb lc b">eval()</code>,你可以利用这一点来添加“卑鄙的”代码。</p><p id="7c95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">好消息:</strong>有一个优雅的解决方案。</p><p id="1869" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们将格式化程序定义为函数，我们可以选择调用function.toString()。</p><p id="3034" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您的控制台中尝试:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="8efd" class="nj lk in lc b gy nk nl l nm nn">let bind = {<br/>    value: data =&gt; `${data.button3Text}`<br/>};<br/><br/>bind.value.toString();</span><span id="9983" class="nj lk in lc b gy ol nl l nm nn">// logs: "data =&gt; `${data.button3Text}`"</span></pre><p id="0330" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这绝对足以用作正则表达式解析的输入。</p><p id="fa95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之前的<code class="fe kz la lb lc b">resolveFormatter()</code>方法被替换为:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ba38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将在绑定组件<br/> (scope → this)的最近视图模型上被调用。</p><h1 id="6497" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">5.在哪里存储绑定格式化程序中使用的数据属性？</h1><p id="4618" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">在neo.mjs中，您现在可以使用视图模型来存储数据属性。您可以简单地将它们定义为组件内部的对象，或者扩展<code class="fe kz la lb lc b">model.Component</code>。<a class="ae jz" href="https://tobiasuhlig.medium.com/enhance-your-frontend-state-management-with-view-models-7bf49e1a0991" rel="noopener">本文的第1部分</a>涵盖了这一点。</p><p id="7311" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个简单的例子:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="005e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在“现实生活”的应用程序中，你很可能有一个深度嵌套的视图结构。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/963091fd005c0984929584d2a62c1b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/0*j5x3CDU6iKw8UIYL.png"/></div></figure><ol class=""><li id="70d6" class="mh mi in kc b kd ke kh ki kl oi kp oj kt ok kx mo mp mq mr bi translated">每个视图都可以有一个视图模型</li><li id="9e85" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">我们需要访问父模型中的数据属性</li><li id="b825" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">绑定格式化程序可以同时包含不同视图模型的数据属性</li></ol><h1 id="1de9" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">6.我们如何获取嵌套数据属性的变更事件？</h1><p id="26a3" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">在我们的视图控制器中，我们希望能够直接分配一个新值，比如:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="418b" class="nj lk in lc b gy nk nl l nm nn">this.getModel().data.button1Text = value;</span></pre><p id="8d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还希望能够一次更改多个数据属性:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="01c8" class="nj lk in lc b gy nk nl l nm nn">this.getModel().setData({<br/>    button1Text: value1,<br/>    button2Text: value2<br/>});</span></pre><p id="b245" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe kz la lb lc b">model.Component</code>正在使用一个<code class="fe kz la lb lc b">data_</code>配置。多亏了类系统的增强(config system)，尾随的下划线使我们能够使用一个<code class="fe kz la lb lc b">afterSet()</code>方法:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="c248" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在模型类或实例定义中为<code class="fe kz la lb lc b">data</code>赋值，就会触发这个事件。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8987" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们递归解析嵌套的数据属性。</p><p id="2a7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果任何级别的属性尚未转换，我们将调用<code class="fe kz la lb lc b">createDataProperty()</code></p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="c10e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这已经是了:我们正在通过<code class="fe kz la lb lc b">get()</code>和<code class="fe kz la lb lc b">set()</code>转换任何级别的每个属性。这些值以一个前导下划线存储，现在我们已经有了我们的变更处理方法→ <code class="fe kz la lb lc b">onDataPropertyChange()</code>。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0f47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果模型数据属性发生变化，我们解析存储的绑定来获取所有被绑定的组件。然后我们访问组件最接近的模型并调用<code class="fe kz la lb lc b">getHierarchyData()</code>，这给了我们一个组件父模型链中所有数据属性的合并对象。</p><p id="3beb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">组件可以有多个配置绑定，包括更改的数据属性，所以我们调用<code class="fe kz la lb lc b">component.set(config)</code>来一次分配所有的更改。这样，我们将只触发虚拟dom引擎一次。</p><h1 id="ad94" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">7.如何在内部保存绑定？</h1><p id="45c2" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">每个<code class="fe kz la lb lc b">component.Base</code>的构造器(包括所有的类扩展)将检查最接近的模型，如果在这个模型上有匹配调用<code class="fe kz la lb lc b">parseConfig()</code>。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0055" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在按钮定义中，您可以添加:</p><pre class="nb nc nd ne gt nf lc ng nh aw ni bi"><span id="3d0a" class="nj lk in lc b gy nk nl l nm nn">bind: {<br/>    text: data =&gt; `${data.button2Text.toLowerCase()}`<br/>}</span></pre><p id="78b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们调用<code class="fe kz la lb lc b">createBindings()</code>并立即在每个配置上设置解析值。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a1e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们没有绑定<code class="fe kz la lb lc b">Neo.data.Store</code>，我们将调用<code class="fe kz la lb lc b">createBindingByFormatter()</code>。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a616" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于格式化程序可以包含多个变量，我们正在做(前面在3。)正则表达式解析，并为它们中的每一个调用<code class="fe kz la lb lc b">createBinding()</code>。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2fcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们以下列格式存储绑定:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/ce63368a010fc0e54b7032be32c1ec97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*en1QYRx_ahaHnhFrSKCb8Q.png"/></div></div></figure><p id="4dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">data property path→componentId→configName:formatter</p><p id="a10b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe kz la lb lc b">createBinding()</code>将始终使用模型父链中最接近的数据属性匹配(您可以在父模型中使用相同的名称)。</p><p id="2991" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，一个组件将ping最近的模型，以防它被破坏，从而删除模型父链中的所有绑定。我们不想发生内存泄漏。</p><h1 id="43cf" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">8.源代码位置</h1><p id="da14" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">您可以在此查看完整的源代码:</p><div class="no np gp gr nq nr"><a href="https://github.com/neomjs/neo/blob/dev/src/model/Component.mjs" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">近地天体</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="oq l oc od oe oa of jt nr"/></div></div></a></div><p id="b8a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，全视图模型实现只需要600行代码。</p><p id="a9e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果不使用模板文字，它将会是很多(！)更多。</p><h1 id="4a48" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">9.支持绑定格式化程序中的方法</h1><p id="8949" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">我在这里开始了这个话题的新讨论:</p><div class="no np gp gr nq nr"><a href="https://github.com/neomjs/neo/discussions/1754" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">模型。组件:支持绑定格式化程序内部的方法讨论#1754 neomjs/neo</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="or l oc od oe oa of jt nr"/></div></div></a></div><p id="09c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的反馈！</p><h1 id="0af6" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">10.最后的想法</h1><p id="b32c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">模板文字使我们能够做伟大的事情，如果我们想一点点的话。</p><p id="c50d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章不会太超前。我意识到代码不容易理解，即使对于有经验的Javascript开发人员来说也是如此。</p><p id="fd0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过，我尽量保持逻辑简单。</p><p id="df16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了视图模型的实现，你现在可以完全遵循MVVM设计模式，如果你想的话。</p><p id="9d35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次感谢您的反馈！</p><p id="f6e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><p id="0ce7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="ky">PS:neo . mjs第二版发布公告将于明天发布！</em> </strong></p><h1 id="7ac1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">附录</h1><h1 id="d9fa" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.neo.mjs是什么？</h1><p id="74a5" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">neo.mjs是一个麻省理工学院许可的开源项目，它使您能够构建多线程前端，而无需考虑工人设置或通信层。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/c05e22d49424d689eab2d6edfe203fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gl--YjXm23XW7ZQW.png"/></div></div></figure><p id="f7fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个扩展的ES8+类配置系统帮助你在专业水平上创建JavaScript驱动的UI代码。</p><p id="4e64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个独特的方面是，开发模式直接在浏览器中运行，没有任何构建或转换。对于调试来说，这可以节省大量时间。</p><p id="7cb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需更改一个顶级框架配置，就可以切换到SharedWorkers模式。这种模式使您能够创建下一代ui，否则这将是非常难以实现的。</p><p id="be00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在以下位置找到存储库:</p><div class="no np gp gr nq nr"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">近地天体</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ot l oc od oe oa of jt nr"/></div></div></a></div><p id="9eaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ky">plain English . io</em></a></p></div></div>    
</body>
</html>