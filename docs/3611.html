<html>
<head>
<title>Closures in JavaScript Made Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包变得简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/closures-in-javascript-made-simple-afb0c7dab5f1?source=collection_archive---------15-----------------------#2021-07-20">https://javascript.plainenglish.io/closures-in-javascript-made-simple-afb0c7dab5f1?source=collection_archive---------15-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="111d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你知道JavaScript在执行后保持你的函数作用域活动吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/00ce3d76696992efef32b2753565b71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9RvYzZFfTweM8LqE"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@juanjodev02?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Juanjo Jaramillo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中的闭包意味着内部函数可以访问外部函数的变量。这也适用于外部函数执行完毕的情况。</p><h1 id="712a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JavaScript中的常规函数是如何工作的</h1><p id="c5c5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们简单看看JavaScript中的常规函数是如何工作的。</p><p id="5b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript函数创建了一个新的作用域。在该范围内定义的变量不能从外部访问。</p><p id="7e6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个函数示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="584b" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">function</strong> hello() {<br/>  <strong class="mq ir">const</strong> word = "Hello";<br/>  console.log(word);<br/>}</span><span id="80ba" class="mu lt iq mq b gy mz mw l mx my">hello();</span></pre><p id="e526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="246b" class="mu lt iq mq b gy mv mw l mx my">Hello</span></pre><p id="76e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用<code class="fe na nb nc mq b">hello()</code>时，花括号之间的代码运行。在此期间，函数<code class="fe na nb nc mq b">hello()</code>可以访问和使用它的变量<code class="fe na nb nc mq b">word</code>。</p><p id="30a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试图访问函数外部的<code class="fe na nb nc mq b">hello</code>不起作用:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fbd1" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">function</strong> hello() {<br/>  <strong class="mq ir">const</strong> word = "Hello";<br/>}</span><span id="0fa5" class="mu lt iq mq b gy mz mw l mx my">console.log(word);</span></pre><p id="4861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2f5b" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">Uncaught ReferenceError: word is not defined</strong></span></pre><h1 id="7605" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JavaScript中的闭包</h1><p id="416c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JavaScript中的闭包使得访问函数外部的变量成为可能。每次运行一个函数时，都会创建一个闭包。</p><p id="99e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">闭包让您可以从内部函数访问外部函数的作用域。</p><p id="793c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们检查这个脚本的行为，其中一个外部函数有一个内部函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="ba70" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe na nb nc mq b">outer()</code>函数返回<code class="fe na nb nc mq b">inner()</code>函数。这意味着您可以将<code class="fe na nb nc mq b">inner()</code>函数存储到一个变量中:</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="faa3" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">const</strong> greet = outer()</span></pre><ul class=""><li id="1852" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">之后，您可以调用<code class="fe na nb nc mq b">greet()</code>来执行<code class="fe na nb nc mq b">inner()</code>函数的代码:</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="da97" class="mu lt iq mq b gy mv mw l mx my">greet()</span></pre><p id="6f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b05d" class="mu lt iq mq b gy mv mw l mx my">Hello world</span></pre><p id="a4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等……<code class="fe na nb nc mq b">greet()</code>只执行<code class="fe na nb nc mq b">inner()</code>函数的代码，看起来像这样:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5cda" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">function</strong> inner() {<br/>     <strong class="mq ir">const</strong> b = "World"; <br/>     console.log(a+b);<br/>}</span></pre><p id="7cb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这难道不意味着当只定义了<code class="fe na nb nc mq b">b</code>时，它会尝试记录<code class="fe na nb nc mq b">a+b</code>吗？但是你刚刚看到它工作了。这意味着<code class="fe na nb nc mq b">greet()</code>仍然需要知道<code class="fe na nb nc mq b">a</code>的值。</p><p id="1f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于JavaScript的封闭性，事实确实如此。闭包意味着即使在执行之后，内部函数也可以访问外部函数的变量。</p><p id="fc88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看看<code class="fe na nb nc mq b">outer()</code>功能:</p><ul class=""><li id="f1ce" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe na nb nc mq b">inner()</code>函数自动知道它在一个名为<code class="fe na nb nc mq b">outer()</code>的函数中。因此，它“保存”属于<code class="fe na nb nc mq b">outer()</code>功能的变量以备后用。这就是为什么<code class="fe na nb nc mq b">greet()</code>仍然可以访问值<code class="fe na nb nc mq b">a</code>的原因。</li></ul><p id="e575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干得好。现在您已经了解了JavaScript中闭包的基础知识。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="e82b" class="ls lt iq bd lu lv nv lx ly lz nw mb mc jw nx jx me jz ny ka mg kc nz kd mi mj bi translated">闭包的真实例子</h1><p id="48a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们设置一个简单的计数器来跟踪点击次数，例如:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3b5f" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">var</strong> counter = 0;</span><span id="f489" class="mu lt iq mq b gy mz mw l mx my"><strong class="mq ir">function</strong> increment() {<br/>  counter++;<br/>}</span></pre><p id="d612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe na nb nc mq b">increment()</code>有效。但是有一个问题:变量<code class="fe na nb nc mq b">counter</code>可以在<code class="fe na nb nc mq b">increment()</code>之外进行调整。它可能会被意外地设置为例如代码中其他地方的<code class="fe na nb nc mq b">1000</code>。这是不好的做法。</p><p id="eefb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了构建一个可靠的计数器，你需要配置<code class="fe na nb nc mq b">increment()</code>函数，使得代码的其他部分不会弄乱<code class="fe na nb nc mq b">counter</code>变量。</p><p id="85e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是闭包派上用场的地方。让我们通过在函数中创建一个函数来重新实现计数器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b6a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码的工作方式与您之前看到的<code class="fe na nb nc mq b">outer()</code> <code class="fe na nb nc mq b">inner()</code>函数组合相同。它利用了JavaScript的封闭性:</p><ul class=""><li id="9821" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe na nb nc mq b">createCounter()</code>是外层功能。它将变量<code class="fe na nb nc mq b">counter</code>设置为<code class="fe na nb nc mq b">0</code>并返回内部函数<code class="fe na nb nc mq b">increment()</code>。</li><li id="ade9" class="nf ng iq ky b kz oa lc ob lf oc lj od ln oe lr nk nl nm nn bi translated"><code class="fe na nb nc mq b">increment()</code>函数负责给<code class="fe na nb nc mq b">counter</code>加值。</li><li id="24db" class="nf ng iq ky b kz oa lc ob lf oc lj od ln oe lr nk nl nm nn bi translated">即使在<em class="of"> </em>调用<code class="fe na nb nc mq b">createCounter()</code>之后，<code class="fe na nb nc mq b">increment()</code>函数也可以访问<code class="fe na nb nc mq b">createCounter()</code>的变量。这是由于JavaScript的封闭性。</li></ul><p id="4eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用这段代码。</p><ul class=""><li id="d70e" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">首先，调用<code class="fe na nb nc mq b">createCounter()</code>来设置计数器:</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="35ec" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">let</strong> add = createCounter();</span></pre><ul class=""><li id="5aaa" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">现在可以调用<code class="fe na nb nc mq b">add()</code>来增加<code class="fe na nb nc mq b">counter</code>的值。让我们做三次，看看会发生什么:</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9135" class="mu lt iq mq b gy mv mw l mx my">add();<br/>add();<br/>add();</span></pre><p id="adee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d8bd" class="mu lt iq mq b gy mv mw l mx my">1<br/>2<br/>3</span></pre></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="fcd9" class="ls lt iq bd lu lv nv lx ly lz nw mb mc jw nx jx me jz ny ka mg kc nz kd mi mj bi translated">结论</h1><p id="99e3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JavaScript中，闭包是一个使函数能够访问其作用域之外的变量的特性——即使在外部作用域被破坏之后。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/3a8456da50ca0d5fd5ddb82f12aeac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkRWCvHFUkPEBj1Uz4qopQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The variable counter can be accessed in the inner function increment.</figcaption></figure><p id="6ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望你觉得有用</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="cd01" class="ls lt iq bd lu lv nv lx ly lz nw mb mc jw nx jx me jz ny ka mg kc nz kd mi mj bi translated">也阅读</h1><div class="oh oi gp gr oj ok"><a href="https://www.codingem.com/50-buzzwords-of-web-development-and-design-in-2021/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">2021年网络开发和设计的50多个流行语</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">学习创业公司使用的网页开发和网页设计语言。这篇文章是关于…的很好的入门读物</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">www.codingem.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/geekculture/20-javascript-snippets-to-code-like-a-pro-86f5fda5598e" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">20个JavaScript代码片段，让您像专业人士一样编写代码</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">提升您的JavaScript技能</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy kp ok"/></div></div></a></div></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="cfff" class="ls lt iq bd lu lv nv lx ly lz nw mb mc jw nx jx me jz ny ka mg kc nz kd mi mj bi translated">参考</h1><div class="oh oi gp gr oj ok"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">闭包- JavaScript | MDN</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">闭包是捆绑在一起(封闭的)的函数与对其周围状态的引用的组合</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">developer.mozilla.org</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy kp ok"/></div></div></a></div><p id="c51e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="of">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="of">plain English . io</em></strong></a></p></div></div>    
</body>
</html>