<html>
<head>
<title>Async Error Handling in Node.js + Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js + Express中的异步错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-express-async-error-handling-e12aa693d84d?source=collection_archive---------2-----------------------#2021-02-10">https://javascript.plainenglish.io/node-express-async-error-handling-e12aa693d84d?source=collection_archive---------2-----------------------#2021-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f9b9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用异步/等待，避免<code class="fe kc kd ke kf b">UnhandledPromiseRejection</code>和崩溃</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/3d256bc63fe9a50714954757a72e0034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QBv6bINVXKgSqs0H"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f54b" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">概观</h1><p id="1c7c" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">您应该在Node.js Express APIs中使用<code class="fe kc kd ke kf b">async</code>和<code class="fe kc kd ke kf b">await</code>关键字。但是您知道Express对完全同步代码和异步代码的错误处理是不同的吗？</p><p id="12bb" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">Express确实有些魔力，可以将错误路由到错误处理中间件，但是任何异步调用都会遇到问题。你见过可怕的<code class="fe kc kd ke kf b">UnhandledPromiseRejection</code>错误吗？请继续阅读，了解其中的区别，并找到避免这些问题的简单解决方案。</p><p id="1951" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated"><em class="mq">注意:这里已经表达了关于错误处理的坚实的</em> <a class="ae kw" href="https://expressjs.com/en/guide/error-handling.html" rel="noopener ugc nofollow" target="_blank"> <em class="mq">文档</em> </a> <em class="mq"> —在本文中我们将重点介绍</em> <code class="fe kc kd ke kf b"><em class="mq">async</em></code> <em class="mq"> / </em> <code class="fe kc kd ke kf b"><em class="mq">await</em></code> <em class="mq">关键字，这与它们的</em> <code class="fe kc kd ke kf b"><em class="mq">Promise </em></code> <em class="mq">例子的思路完全相同。</em></p><p id="761b" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">最终代码可以在我的回购协议中找到，在这里:</p><div class="mr ms gp gr mt mu"><a href="https://github.com/neightjones/express-async-errors" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">邻居/快速异步错误</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">这个repo与我的关于使用async / await进行快速错误处理的博文一起发布。相关代码在…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kq mu"/></div></div></a></div><p id="e3a3" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">这个代码库非常简单，只是为了这些例子而制作的——所有相关的代码都在<code class="fe kc kd ke kf b">src/app.js</code>中。在现实生活中，一个项目将包含一个更复杂的结构来分离不同的关注点。</p><p id="dc21" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">我在这里构建了我的<a class="ae kw" href="https://github.com/neightjones/node-babel-template" rel="noopener ugc nofollow" target="_blank">模板，其中设置了Babel和其他工具。我在这里写了设置</a><a class="ae kw" href="https://medium.com/javascript-in-plain-english/a-minimal-node-js-express-babel-setup-part-1-6be7b3f3bb55" rel="noopener">这里写了</a>和<a class="ae kw" href="https://medium.com/javascript-in-plain-english/a-minimal-node-js-setup-part-2-eslint-prettier-vs-code-7963768dbb30" rel="noopener">这里写了</a>。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="181e" class="kx ky in bd kz la nq lc ld le nr lg lh jt ns ju lj jw nt jx ll jz nu ka ln lo bi translated">快速同步与异步错误处理</h1><p id="d72a" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">正如<a class="ae kw" href="https://expressjs.com/en/guide/error-handling.html" rel="noopener ugc nofollow" target="_blank"> Express提到的</a>，同步和异步代码产生的错误是有区别的:</p><p id="d7b1" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">对于同步:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="2eb1" class="nz ky in kf b gy oa ob l oc od">"Errors that occur in synchronous code inside route handlers and middleware require no extra work. If synchronous code throws an error, then Express will catch and process it."</span></pre><p id="3f20" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">但是，对于异步:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="dd23" class="nz ky in kf b gy oa ob l oc od">"For errors returned from asynchronous functions invoked by route handlers and middleware, you must pass them to the <!-- -->next()<!-- --> function, where Express will catch and process them."</span></pre><p id="f1dc" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">所以……在异步情况下，Express不会神奇地为我们做任何事情——我们需要确保捕捉到任何错误，并将它们传递给<code class="fe kc kd ke kf b">next()</code>函数。</p><h1 id="72b8" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">我们的错误处理器</h1><p id="70da" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">在Express APIs中，错误处理中间件与其他中间件非常相似，但是它有4个参数。第一个参数代表一个错误，所以我们称之为<code class="fe kc kd ke kf b">err</code>。</p><p id="42c0" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">重要的是，错误处理器中间件应该放在路由处理器和其他中间件的 之后的<strong class="lr io"> <em class="mq">。您可以有多个错误处理程序来捕捉类似于<code class="fe kc kd ke kf b">404</code>的事件，并处理其他特定的情况，但是出于讨论的目的，我们将坚持使用一个无所不包的错误处理程序。</em></strong></p><p id="da13" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">它看起来像这样，放在<code class="fe kc kd ke kf b">app.js</code>文件的末尾:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="3ffe" class="nz ky in kf b gy oa ob l oc od">app.use((err, req, res, next) =&gt; {<br/>  // Simple error handling here... in real life we might<br/>  // want to be more specific<br/>  console.log(`I'm the error handler. '${err.message}'`);<br/>  res.status(500);<br/>  res.json({ error: err.message });<br/>});</span></pre><h1 id="335e" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">我们的模拟异步函数</h1><p id="8867" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">对于我们下面的异步例子，我们想要一个<code class="fe kc kd ke kf b">async</code>函数，我们可以在我们的路由中<code class="fe kc kd ke kf b">await</code>。这个函数将模拟现实生活中的异步调用，如网络调用或数据库调用。我们称它为<code class="fe kc kd ke kf b">asyncFn</code>:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="e7cb" class="nz ky in kf b gy oa ob l oc od">const asyncFn = () =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      reject(new Error('Async Fn error!'));<br/>    }, 1000);<br/>  });<br/>};</span></pre><p id="311c" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">注意，这总是一个被拒绝的承诺(等待1秒钟后)。因为我们正在测试错误处理，所以我们将总是从这里用<code class="fe kc kd ke kf b">new Error</code>拒绝。</p><h1 id="564c" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">同步端点测试</h1><p id="6e93" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">在我们的异步测试之前，让我们做一个简单的同步例子。我们的第一个端点看起来像这样:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="2569" class="nz ky in kf b gy oa ob l oc od">/**<br/> * I throw an error in simple, synchronous code.<br/> * Express will automatically pass this error to our<br/> * error handler middleware (down at bottom).<br/> */<br/>app.get('/sync-test', (req, res) =&gt; {<br/>  throw new Error('Error from synchronous code!');<br/>});</span></pre><p id="f26e" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">使用以下工具对此进行测试:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="892b" class="nz ky in kf b gy oa ob l oc od">curl localhost:3000/sync-test</span></pre><p id="ed1a" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">由于这是导致错误的同步代码<code class="fe kc kd ke kf b">throw</code>，我们可以确认Express会自动将错误传递给我们的错误处理程序。确实如此，所以<code class="fe kc kd ke kf b">curl</code>从状态为<code class="fe kc kd ke kf b">500</code>的错误处理程序获得预期的JSON响应:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="af42" class="nz ky in kf b gy oa ob l oc od">{"error":"Error from synchronous code!"}</span></pre><p id="d0f0" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">对于Express来说，同步错误很容易发生。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="ec36" class="kx ky in bd kz la nq lc ld le nr lg lh jt ns ju lj jw nt jx ll jz nu ka ln lo bi translated">测试1。</h1><p id="bc8b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">让我们试试异步端点:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="6264" class="nz ky in kf b gy oa ob l oc od">/**<br/> * I'm an async route handler (see my 'async' keyword).<br/> * When I try awaiting asyncFn defined above, what'll happen<br/> * with that error? Express WON'T automatically pass the error<br/> * to our error handler defined below! :0<br/> * This leads to the fateful UnhandledPromiseRejection.<br/> */<br/>app.get('/async-test-1', async (req, res) =&gt; {<br/>  await asyncFn();<br/>  res.json({ well: `We're not going to reach this line.` });<br/>});</span></pre><ol class=""><li id="085e" class="oe of in lr b ls ml lv mm ly og mc oh mg oi mk oj ok ol om bi translated"><code class="fe kc kd ke kf b">async</code>关键字用于处理函数中。</li><li id="178f" class="oe of in lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">处理函数<code class="fe kc kd ke kf b">await</code>是我们的测试<code class="fe kc kd ke kf b">asyncFn()</code>——我们已经知道它会一直失败/拒绝。</li></ol><p id="ccfa" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">试一试:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="55d4" class="nz ky in kf b gy oa ob l oc od">curl localhost:3000/async-test-1</span></pre><p id="fb43" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">这不好…你会在服务器日志中看到<code class="fe kc kd ke kf b">Timeout</code>或<code class="fe kc kd ke kf b">UnhandledPromiseRejection</code>问题，以及来自客户端服务器的空回复。您的服务器可能会崩溃。</p><p id="81a9" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">由于这个端点会导致一个异步错误，Express <strong class="lr io">不会自动将这个错误传递给我们的错误处理程序！</strong></p><p id="a489" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">我们必须小心避免这些。代码看起来非常类似于sync的情况，但是结果却非常不同。</p><h1 id="5651" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">测试2。</h1><p id="2c9b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">如果您熟悉<code class="fe kc kd ke kf b">async</code> / <code class="fe kc kd ke kf b">await</code>语法，您可能已经使用过<code class="fe kc kd ke kf b">try</code> / <code class="fe kc kd ke kf b">catch</code>来处理错误。让我们将其添加到下一个端点:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="9050" class="nz ky in kf b gy oa ob l oc od">/**<br/> * This is like the async test above, but now we're using the<br/> * try...catch syntax to catch the async error. Then, we<br/> * can call 'next' to forward the error to our error handler.<br/> * We need to do this for async errors!<br/> */<br/>app.get('/async-test-2', async (req, res, next) =&gt; {<br/>  try {<br/>    await asyncFn();<br/>    res.json({ well: `We're not going to reach this line, either.` });<br/>  } catch (e) {<br/>    // This time, we'll catch the error and pass it along<br/>    // to our error handler, below.<br/>    next(e);<br/>  }<br/>});</span></pre><p id="9d7b" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">尝试一下:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="7772" class="nz ky in kf b gy oa ob l oc od">curl localhost:3000/async-test-2</span></pre><p id="b55d" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">太好了！现在，您将看到错误在我们的错误处理程序中间件中得到正确处理，并且JSON被传播到客户端。</p><p id="634c" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">由对<code class="fe kc kd ke kf b">asyncFn()</code>的注定调用导致的错误被捕获。我们只需要用<code class="fe kc kd ke kf b">next(e)</code>显式地将错误(名为<code class="fe kc kd ke kf b">e</code>)传递给我们的错误处理程序。</p><h1 id="5f71" class="kx ky in bd kz la lb lc ld le lf lg lh jt li ju lj jw lk jx ll jz lm ka ln lo bi translated">测试3。</h1><p id="7cd1" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">我们在之前的测试中修复了我们的异步问题，但是我不喜欢为每一个路由处理器编写<code class="fe kc kd ke kf b">try</code> / <code class="fe kc kd ke kf b">catch</code>语法。看看这个名为<a class="ae kw" href="https://www.npmjs.com/package/express-async-handler" rel="noopener ugc nofollow" target="_blank"> express-async-handler </a>的包。这是一个很好的简单的包，为我们处理错误。看看我们的最终路线:</p><pre class="kh ki kj kk gt nv kf nw nx aw ny bi"><span id="179d" class="nz ky in kf b gy oa ob l oc od">/**<br/> * The last code works pretty well, but do you really want<br/> * to wrap every route handler in a try...catch?<br/> * The express-async-handler package takes care of that for us!<br/> * So this code works equally as well as the above.<br/> * Look how we wrap our handler -<br/> */<br/>app.get(<br/>  '/async-test-3',<br/>  asyncHandler(async (req, res) =&gt; {<br/>    await asyncFn();<br/>    res.json({ well: `We're *still* not going to reach this line.` });<br/>  }),<br/>);</span></pre><p id="275d" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">这与上面的测试#2基本上是相同的代码，但是我们抽象出了<code class="fe kc kd ke kf b">try</code> / <code class="fe kc kd ke kf b">catch</code>和<code class="fe kc kd ke kf b">next</code>调用。您甚至可以在这里看到包中的<a class="ae kw" href="https://github.com/Abazhenov/express-async-handler/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">主代码</a> —它使用Promise语法来<code class="fe kc kd ke kf b">catch</code>一个错误，并根据需要将其传递给<code class="fe kc kd ke kf b">next</code>。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="3c22" class="kx ky in bd kz la nq lc ld le nr lg lh jt ns ju lj jw nt jx ll jz nu ka ln lo bi translated">结论</h1><p id="04c1" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx ly lz ma mb mc md me mf mg mh mi mj mk ig bi translated">错误处理是Express API中的一个关键部分。除了避免崩溃和<code class="fe kc kd ke kf b">UnhandledPromiseRejection</code>错误之外，您还需要让您的错误处理变得清晰和有洞察力，以了解用户遇到了什么问题。</p><p id="a319" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated">如果你喜欢你在这里看到的，你可以考虑看看我的高级产品<a class="ae kw" href="https://sapling.dev/" rel="noopener ugc nofollow" target="_blank"> Sapling </a>，它为你生成了一个全栈应用。您将获得的代码处理本文中概述的错误处理代码，以及处理CRUD功能、Auth0和Stripe集成等。</p><p id="e21f" class="pw-post-body-paragraph lp lq in lr b ls ml jo lu lv mm jr lx ly mn ma mb mc mo me mf mg mp mi mj mk ig bi translated"><em class="mq">这篇文章最初是</em> <a class="ae kw" href="https://sapling.dev/blog/express-async-error-handling" rel="noopener ugc nofollow" target="_blank"> <em class="mq">发表在我的博客上，是关于sapphire</em></a><em class="mq">的，一个启动JS项目的工具。</em></p></div></div>    
</body>
</html>