<html>
<head>
<title>You don’t know the classNames library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您不知道类名库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-dont-know-the-classnames-library-6b54ca4294d4?source=collection_archive---------12-----------------------#2021-03-11">https://javascript.plainenglish.io/you-dont-know-the-classnames-library-6b54ca4294d4?source=collection_archive---------12-----------------------#2021-03-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7515cdfaf322091fca8cc139532c7c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsghBCIYlnidhChNaFQIQA.png"/></div></div></figure><p id="a909" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我从一开始就反驳这篇文章的标题，说你可能非常了解<code class="fe kt ku kv kw b">classNames</code>图书馆。</p><p id="e9d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初由<a class="ae kx" href="https://github.com/JedWatson" rel="noopener ugc nofollow" target="_blank">杰德沃森</a>创建的这个小小的<a class="ae kx" href="https://github.com/JedWatson/classnames" rel="noopener ugc nofollow" target="_blank">开源</a>库不过是一个多用途的字符串<em class="ky">“连接符”。</em>目前每周下载超过<strong class="jx io">600万次</strong>，它和最常用的用户界面库React一起流行起来。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/3b67cd4e390da79baf842648bb290ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvgplrEyHKgdyiEkVYcobw.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">classNames and React popularity growth</figcaption></figure><p id="0a0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顾名思义，它主要用于处理CSS类名(在React和任何其他基于<strong class="jx io"> JSX的</strong> UI框架中非常常见)，尽管您可以将其用于任何类型的字符串连接。</p><h1 id="985e" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">小巧的NPM包装的新奇之处</h1><p id="b792" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">但你很可能什么都知道。毕竟，考虑到类名和React的受欢迎程度，你很有可能以前使用过它。但是是的关于这种流行。</p><p id="7681" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在NPM，看到小包装有高得离谱的下载数据并不罕见。你很可能<a class="ae kx" href="https://www.google.com/search?q=tiny%20package%20breaks%20npm" rel="noopener ugc nofollow" target="_blank">已经听说过NPM包的故事</a>甚至只有不到20行代码，因为最微小的改变就破坏了互联网。以<a class="ae kx" href="https://www.npmjs.com/package/is-promise" rel="noopener ugc nofollow" target="_blank"> is-promise </a>为例——每周下载量约为1000万次(主要来自其高度受欢迎的依赖者)——其最大的CJS版本有5行代码(LOCs):</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3b5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，这种依赖可能看起来很可怕，这是理所当然的。关于黑洞<code class="fe kt ku kv kw b">node_modules</code>文件夹的笑话是真实的，这是有原因的。即使您可能不直接依赖这样的包，您依赖的包也可能这样做，一个，或者更可能是多个级别。</p><p id="d7eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类名并没有那么小，它的“核心”版本大约有50个LOCs，总数在200到300之间(所有版本+类型脚本类型)。这就是我认为的包依赖的“合理”阈值。此外，该图书馆非常稳定，多年来证明了自己。</p><h1 id="6902" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类名语法</h1><p id="aff8" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">类名库的有用性来自它的语法。它只不过是一个函数，将不同类型的值作为参数，并基于它们输出一个字符串。</p><p id="c20c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自述文件很好地展示了这种多功能性:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="21e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个库的简单性和多功能性可能是你没有真正考虑过的事情——你只是使用它，让它在你的项目中运行数千甚至数百万次。</p><h2 id="0ebb" class="mn lj in bd lk mo mp dn lo mq mr dp ls kg ms mt lw kk mu mv ma ko mw mx me my bi translated">表演</h2><p id="cc91" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这可能会导致对性能的一些担忧。</p><p id="a28d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作者意识到了这一点，这在自述文件中有明确说明:</p><p id="3758" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ky">“我们非常重视这个软件包的稳定性和性能，因为它每天在世界各地的浏览器中运行数百万次。更新在发布前会经过彻底的性能影响审查，我们有一套全面的测试套件。”</em></p><p id="5e25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，很明显，函数调用永远不会比一个简单的字符串更快，尽管这看起来像是一个微优化，但这也是代码可读性的问题。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7418" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，重要的是不要陷入一个循环洞，并且知道何时以及如何负责任地使用这个库。在更简单的情况下，看看普通字符串、ES6模板文字或条件操作符是否能完成这项工作。不要浪费性能，也不要过度优化。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="279b" class="mn lj in bd lk mo mp dn lo mq mr dp ls kg ms mt lw kk mu mv ma ko mw mx me my bi translated">多才多艺</h2><p id="e79e" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">除了在必要的时候使用类名之外，正确使用它还有很多好处。这里最大的因素是<strong class="jx io">多功能性</strong>，这通常会导致您在给定的场景中采用次优的方式。</p><p id="5c53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上所述，您可以提供任意多的参数，忽略这些参数中的假值，连接字符串，递归地展平和处理数组，如果对象的值为真，则连接对象的键。</p><p id="c911" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用这些属性不一定是为了提高<strong class="jx io">性能</strong>，而是为了提高代码的可读性<em class="ky">“编写舒适性”</em>(也就是<em class="ky">“开发体验”</em>)。至于一些建议:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5ae2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上只是我自己想出来的几个小技巧，我个人用的。通常使用不必要的数组，或者将基类放入右边带有难看的<code class="fe kt ku kv kw b">true</code>的对象属性名中，或者通过属性值类似于<code class="fe kt ku kv kw b">condition</code>、<code class="fe kt ku kv kw b">!condition</code>的对象在类集合之间切换。这些问题都不是特别令人不安，但值得记住的是，还有一些改进的空间。</p><h1 id="50f2" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类名替代版本</h1><p id="1553" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">您可能不知道，classNames本身有两个不同的版本。两者都服务于相同的一般目的，但也提供了额外的功能。</p><h2 id="50f1" class="mn lj in bd lk mo mp dn lo mq mr dp ls kg ms mt lw kk mu mv ma ko mw mx me my bi translated">重复数据删除</h2><p id="4236" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">顾名思义，<em class="ky">重复数据删除</em>版本处理生成的字符串中的重复项。它删除重复的子字符串，并且只考虑最后为特定子字符串提供的设置。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5989" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于重复数据删除的复杂性，这个版本据说比慢了<strong class="jx io">5倍。正因为如此，我不建议你把它用在你的<code class="fe kt ku kv kw b">className</code>上，除非你有非常具体的理由。但是，它对于一般的字符串连接仍然很有用。</strong></p><h2 id="ed99" class="mn lj in bd lk mo mp dn lo mq mr dp ls kg ms mt lw kk mu mv ma ko mw mx me my bi translated">约束</h2><p id="4b38" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">第二个版本面向<strong class="jx io"> CSS模块</strong>的用户。当导入CSS类的对象时，这个版本允许您“绑定”它们，这样您就可以通过它们的自定义名称而不是真实名称来引用它们。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="dfb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法可以为您节省一些输入—不需要总是从导入的对象中访问属性。然而，它确实引入了一些额外的性能损失(尽管确实很小)，会使新来者感到困惑，需要创建一个新的类名函数的“实例”，并且会导致您失去潜在的自动完成和其他类型的编辑器支持(<a class="ae kx" href="https://github.com/JedWatson/classnames/blob/master/bind.d.ts" rel="noopener ugc nofollow" target="_blank">包含的类型脚本类型</a>非常通用)。</p><p id="983e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也就是说，你应该只在有很多CSS模块导入的类需要处理的时候才使用这个版本(顺便说一下，这不符合“人体工程学”)</p><h1 id="8472" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">只需使用<a class="ae kx" href="https://www.npmjs.com/package/clsx" rel="noopener ugc nofollow" target="_blank"> clsx </a></h1><p id="8d01" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">现在，作为一个免费的提示，在你可能拨打的数千次<code class="fe kt ku kv kw b">classNames</code>电话中，至少有2次的性能，只要切换到<code class="fe kt ku kv kw b">clsx</code>就可以了。这是一个类似于<code class="fe kt ku kv kw b">classNames</code>的图书馆，但是更加新鲜，而且loc更少。</p><p id="84d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该API与<code class="fe kt ku kv kw b">classNames</code>相同，但是没有额外的版本(反正你可能也不需要)。虽然性能提升可能并不明显，但这仍然意味着速度仍然存在，大量的调用可以很快增加更多。</p><h1 id="1552" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">想法？</h1><p id="44fd" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">写一整篇关于单功能实用程序库的文章感觉有点疯狂。然而，考虑到<code class="fe kt ku kv kw b">classNames</code>有多受欢迎，它被使用的频率有多高，以及它是多么的不引人注意，我认为它值得深入研究一下。这样的小型库和开源工具推动了今天的Web，因此，不断尝试您的依赖项、充分了解它们并知道如何优化它们是非常重要的。</p><p id="59b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">反正就是这样了！我希望你喜欢这次疯狂的旅程，也许——只是也许——今天学到了一些新东西。如果是这样，请在评论中告诉我。请务必在<a class="ae kx" href="https://twitter.com/areknawo" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae kx" href="https://www.facebook.com/areknawoblog" rel="noopener ugc nofollow" target="_blank">脸书</a>上<strong class="jx io">关注我</strong>，或者通过我的<a class="ae kx" href="https://areknawo.com#newsletter" rel="noopener ugc nofollow" target="_blank">时事通讯</a>了解更多像这样疯狂的网络开发者故事和一些更理智的故事！哦，也许<strong class="jx io">开始用<a class="ae kx" href="https://codewrite.io" rel="noopener ugc nofollow" target="_blank">代码编写自己的</a></strong>！</p><p id="5e66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢你的阅读，祝你命名愉快。</p></div></div>    
</body>
</html>