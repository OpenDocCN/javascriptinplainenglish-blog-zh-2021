<html>
<head>
<title>Optimize the Dockerfile in your Node.js TypeScript Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Node.js TypeScript项目中的docker文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/optimize-the-dockerfile-in-your-node-js-project-53acbe1eb859?source=collection_archive---------8-----------------------#2021-03-28">https://javascript.plainenglish.io/optimize-the-dockerfile-in-your-node-js-project-53acbe1eb859?source=collection_archive---------8-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f793acbf9a7a0231139ce8f46415d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bA7eHx59hxoMD51euIaC2A.jpeg"/></div></div></figure><p id="7504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，从积极的方面开始，如果你尝试复制一些基本的Dockerfile示例来构建基于Node.js的微服务容器，那就没问题了。如果你需要一些小而便携的东西，你可以使用node:lts-alpine docker基本映像，并通过构建这种简单的docker文件来使用它:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a3de" class="lf lg iq lb b gy lh li l lj lk">FROM node:lts-alpine<br/>ADD . /app<br/>WORKDIR /app</span><span id="7389" class="lf lg iq lb b gy ll li l lj lk">RUN yarn &amp;&amp; yarn build</span><span id="d7b1" class="lf lg iq lb b gy ll li l lj lk">ENV NODE_ENV=production</span><span id="d81e" class="lf lg iq lb b gy ll li l lj lk">CMD ['node', './dist']</span></pre><p id="b45c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有一个Node.js TypeScript项目，就像我这里的<a class="ae lm" href="https://github.com/tigranbs/node-typescript-starter-kit" rel="noopener ugc nofollow" target="_blank">https://github.com/tigranbs/node-typescript-starter-kit</a>这将工作得非常好，特别是如果<code class="fe ln lo lp lb b">alpine</code>本身是一个非常小的基本映像，你必须获得的唯一存储是你的node_modules，当然，如果你的依赖项中有20多个包，它可能会增长到几GB。</p><p id="aec0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在微服务领域，使用小型Docker映像来加快服务器端的部署和正常运行时间被认为是一种很好的做法。这也意味着，如果你有一个运行自动化测试的登台环境或Github动作，如果你有一个较小的映像和较少的构建时间，它将花费更少的时间。因此，优化Docker图像的想法可以归结为以下两点</p><ul class=""><li id="55f2" class="lq lr iq ka b kb kc kf kg kj ls kn lt kr lu kv lv lw lx ly bi translated">保持图像尺寸尽可能小</li><li id="7362" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">确保保留唯一的Docker图像层，以便在稍有变化时不要总是重建整个图像层</li></ul><p id="0ec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于第一点，我们已经很好地匹配了最少的Docker映像，这意味着我们可能可以从Dockerfile中删除一些不必要的文件，如<code class="fe ln lo lp lb b">README.md, .git, etc...</code>，但总体来说，这不会使匹配有所不同。</p><p id="ed15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的主要思想是保持你的Docker图像与相同的独特的图像层，以便只有改变层将被上传到注册表，只有改变层将从那里下载。这归结于我们的Node.js TypeScript项目有这样的东西</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="228c" class="lf lg iq lb b gy lh li l lj lk">FROM node:lts-alpine<br/><br/>ADD package.json /app/package.json<br/>ADD yarn.lock /app/yarn.lock<br/><br/>WORKDIR /app<br/><br/># Installing packages<br/>RUN yarn<br/><br/>ADD . /app<br/><br/>ENV NODE_ENV=production<br/><br/># Building TypeScript files<br/>RUN yarn build<br/><br/>CMD ['node', './dist']</span></pre><p id="a0fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与原始Docker文件的主要变化是必须将<code class="fe ln lo lp lb b">yarn install</code>和<code class="fe ln lo lp lb b">yarn build</code>分开，这确保了如果您更改了<code class="fe ln lo lp lb b">yarn.lock</code>或<code class="fe ln lo lp lb b">package.json</code>，我们将重建Docker图像层，负责拥有<code class="fe ln lo lp lb b">node_modules</code>，否则它将保持不变，如果我们已经有了，我们不必上传或从注册表下载。</p><p id="ed7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以承认，在80%的情况下，当你进行常规开发过程时，你不会接触到<code class="fe ln lo lp lb b">yarn.lock</code>或<code class="fe ln lo lp lb b">package.json</code>文件，只是当你需要新的包或将某些包升级到新版本时，你的<code class="fe ln lo lp lb b">node_modules</code>层才会在这种情况下构建，否则Docker图像层将保持不变，使其在注册表和你的服务器或本地环境之间移动的构建时间非常快，网络流量/存储更少。</p><p id="71c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种技术通常被称为多阶段构建，在这种情况下，您可以根据图像名称分配特定的图像层，并通过构建多个图像来引用它。例如，如果您必须构建<code class="fe ln lo lp lb b">staging, test and production</code> docker映像，并且您有一些特定的基于代码的差异。对于像Go、Java或Rust这样的编译语言来说，这是很常见的，在这些语言中，您可能会使用不同的优化标志编译稍有不同的库或处于调试或生产模式，但对于Node.js TypeScript项目来说，这是相同的代码库，只是改变了环境变量。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="54b9" class="lf lg iq lb b gy lh li l lj lk">FROM node:lts-alpine AS packages<br/><br/>ADD package.json /app/package.json<br/>ADD yarn.lock /app/yarn.lock<br/><br/>WORKDIR /app<br/><br/># Installing packages<br/>RUN yarn<br/><br/># Staging Image<br/>FROM packages <br/><br/>ADD . /app<br/><br/>ENV NODE_ENV=staging<br/><br/># Building TypeScript files<br/>RUN yarn build<br/><br/>CMD ['node', './dist']</span></pre><p id="63aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这主要是关于同时构建多个映像，但不确定它对基于Node.js的项目是否有用。我以前在Go项目中看到过这种情况，根据环境使用不同的编译标志构建Go项目是有意义的，但这也是一个特定的用例。事情是，你只需要记住，关键是保持你的独特的图像层不变，当你不断建立你的Docker图像，这将节省你很多时间。</p><h1 id="8d9b" class="me lg iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">结论</h1><p id="fef1" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">这是一个非常简单的概念，即无论你何时构建你的映像，都要保持Docker映像不变，但是这会为你节省大量的时间和资源。</p><p id="9f76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这是有帮助的，请考虑订阅我的时事通讯并关注/订阅！</p><p id="4b3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源—<a class="ae lm" href="https://tigran.tech/optimized-dockerfile-for-node-typescript-project/" rel="noopener ugc nofollow" target="_blank">https://tigran . tech/optimized-docker file-for-node-typescript-project/</a></p></div></div>    
</body>
</html>