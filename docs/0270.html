<html>
<head>
<title>Bubble Sort — But Make it Bridgerton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冒泡排序——但要让它成为布里奇顿</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/bubble-sort-but-make-it-bridgerton-f2ad776078f3?source=collection_archive---------7-----------------------#2021-01-15">https://javascript.plainenglish.io/bubble-sort-but-make-it-bridgerton-f2ad776078f3?source=collection_archive---------7-----------------------#2021-01-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2e6a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript算法演练</h2></div><p id="a9e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">阿尔戈斯，阿尔戈斯，阿尔戈斯！有趣的东西！不，我不是在讽刺，我非常喜欢这种逻辑！不过，当我碰到二叉树和其他数据结构时，请随意@我，因为我可能会唱不同的调子。目前，我仍在研究更简单的算法，所以一切都很顺利！</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/c5b419f3a9fe816b887b94ef52c67edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4AOMjzPptCsA0FI9EPdIA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">yasss kween! yaaaas</figcaption></figure><p id="4fdb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与摄政时代的大多数伦敦上流社会不同，冒泡排序是最低效的算法之一。其低效的运行时间O(n)只有Daphne和Anthony Bridgerton无法点燃一个炉子来加热他们的牛奶。你不希望Bridgerton兄弟出现在厨房里，就像你不希望对更大的数组使用冒泡排序一样(如果你最终要使用它的话)。就像有更适合厨房的人一样，也有更适合排序列表的算法。在我们进一步发展之前，必须先解决这个问题。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lo"><img src="../Images/6a8d6872f34a55a94d0d953c595d4986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcwkMLqtNb0TUTh1HymOxQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">#winning</figcaption></figure><p id="564b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">冒泡排序的要点是比较数组中每对相邻的值。在遍历数组时，必须检查每一对数字。如果第一个值大于第二个值，那么你们交换位置。每次迭代后，最大值存放在最右边。</p><p id="f144" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">布里奇顿崩溃:如果我们有一系列的羽毛长筒大衣摆在女王面前，按照社会地位进行分类，而普鲁登斯意外地摔倒了，她的社会地位也直线下降(她现在是与她的姐妹们相比价值最低的羽毛长筒大衣)。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lp"><img src="../Images/7ca2bbfad9d5031ce5fb4c5f1eb7202d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53HUot1QnnsV6MmoOMKrDA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">a Featherington faux pas, indeed!</figcaption></figure><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="f2b6" class="lv lw in lr b gy lx ly l lz ma">let Featheringtons = ["Philipa","Prudence","Penelope"]</span><span id="10ed" class="lv lw in lr b gy mb ly l lz ma">if (Philipa &gt; Prudence), then we will swap their positions. </span></pre><p id="a788" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当比较Philipa和Prudence的前两个值时，Prudence的值较低，因此将与Philipa交换位置，Philipa在问候女王时设法保持直立。这将是新的数组。</p><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="971e" class="lv lw in lr b gy lx ly l lz ma">let Featheringtons = ["Prudence", "Philipa","Penelope"]</span></pre><p id="77cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了清楚起见，如果我们对一个数组进行升序排序，算法将从比较第一对值Philipa和Prudence开始。由于菲丽帕的地位比普律当丝高，他们将交换位置，而普律当丝现在在列表的最前面——我们想要最低的值。然后我们进入下一对，菲利帕和佩内洛普。它将对它们进行比较，并相应地对它们进行排序，如此等等，直到数组排序完毕。</p><p id="f5ab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">布里奇顿迭代:[ <strong class="ke io">菲丽帕，普律当丝</strong>，佩内洛普]→[普律当丝，<strong class="ke io">菲丽帕，佩内洛普</strong>→[普律当丝，佩内洛普，菲丽帕]</p><p id="4239" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数值迭代:[ <strong class="ke io"> 5，3 【T5，4】→[3<strong class="ke io">，5，4</strong>→[3，4，5]</strong></p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="268b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经了解了要点，那就让我们进入实质吧。</p><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="c854" class="lv lw in lr b gy lx ly l lz ma">let array = [95, 31, 19, 7]<br/><br/>function bubbleSort(arr){<br/>  let swap = (arr, a, b) =&gt; ([arr[a], arr[b]] = [arr[b], arr[a]])<br/>  let swapped<br/>  for(let i = arr.length; i &gt; 0; i --){<br/>    swapped = false<br/>    for(let j = 0; j &lt; i - 1; j++){<br/>      if(arr[j] &gt; arr[j+1]){<br/>        swap(arr, j, j+1)<br/>        swapped = true<br/>      }<br/>    }<br/>    if(!swapped)break<br/>  }<br/>  return arr<br/>}</span></pre><ol class=""><li id="3d6e" class="mj mk in ke b kf kg ki kj kl ml kp mm kt mn kx mo mp mq mr bi translated">在编写冒泡排序函数时，我喜欢做的第一件事是立即定义一个“交换”函数来交换数组中的元素。交换函数接受3个参数:数组、索引1和索引2。</li></ol><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="b14b" class="lv lw in lr b gy lx ly l lz ma">let swap = (arr, a, b) =&gt; ([arr[a], arr[b]] = [arr[b], arr[a]])</span></pre><p id="011d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将采用index1和index2的原始顺序并交换它们，如上所示。</p><p id="84df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我选择将我的交换函数封装在我的冒泡排序函数中的一个变量中，但是你也可以编写一个单独的助手函数，在你的冒泡排序函数中调用，如果这样对你更有意义的话。</p><p id="ffd4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.接下来，我创建一个<em class="ms">交换的</em>变量，以便以后在我的代码中使用。这将被设置为一个布尔值，以检查在完成内部循环后是否已经交换了数字。</p><p id="2b0c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.现在我们开始我们的外环。这个循环将向后遍历数组<strong class="ke io">。我们从末尾开始，因为如前所述，数组[3](数组的最后一个索引)是我们的最大值95将在内部循环的第一次迭代结束时结束的位置。我们最初设定<em class="ms">将</em>换成假。(我们稍后会再讨论这个问题。)</strong></p><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="ad61" class="lv lw in lr b gy lx ly l lz ma">let array = [95, 31, 19, <strong class="lr io">7</strong>]<br/><br/>function bubbleSort(arr){<br/>  let swap = (arr, a, b) =&gt; ([arr[a], arr[b]] = [arr[b], arr[a]])<br/>  let swapped<br/>  <strong class="lr io">for(let i = arr.length; i &gt; 0; i --){<br/>    swapped = false<br/>  }</strong><br/>}</span></pre><p id="e6b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.接下来是我们的内部循环，它从数组的开头开始迭代，意在使用条件语句比较每对值。如果currentElement &gt; nextElement，我们将调用方便的交换函数。请记住，普律当丝让女王做了一个不悦的鬼脸，她的值最低，所以她和她姐姐被交换到了阵的最前面。这也适用于此。由于交换已经被执行，我们现在更新我们的<em class="ms">交换的</em>变量为真。在下面的例子中，95和31将在内部循环的第一次迭代后互换。</p><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="3464" class="lv lw in lr b gy lx ly l lz ma">let array = [<strong class="lr io">95, 31</strong>, 19, 7]<br/><br/>function bubbleSort(arr){<br/>  let swap = (arr, a, b) =&gt; ([arr[a], arr[b]] = [arr[b], arr[a]])<br/>  let swapped<br/>  for(let i = arr.length; i &gt; 0; i --){<br/>    swapped = false<br/>    <strong class="lr io">for(let j = 0; j &lt; i - 1; j++){<br/>      if(arr[j] &gt; arr[j+1]){<br/>        swap(arr, j, j+1)<br/>        swapped = true<br/>      }<br/>    }</strong><br/>  }<br/>  return arr<br/>}</span></pre><p id="65cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.在这里，如果数组已经按升序排序，我们会尽最大努力打破内部循环，为这个极其复杂的时间算法增加一些效率。通过使用bang运算符检查<em class="ms">是否交换了</em>，我们是说如果<em class="ms">没有交换</em>，就脱离这个内环。请记住，我们只交换if current tele&gt;next ele，所以如果这个条件从未得到满足，那是因为数组已经按升序排序了。因此，我们不再需要循环，可以脱离它。</p><pre class="kz la lb lc gt lq lr ls lt aw lu bi"><span id="c954" class="lv lw in lr b gy lx ly l lz ma">let array = [95, 31, 19, 7]<br/><br/>function bubbleSort(arr){<br/>  let swap = (arr, a, b) =&gt; ([arr[a], arr[b]] = [arr[b], arr[a]])<br/>  let swapped<br/>  for(let i = arr.length; i &gt; 0; i --){<br/>    swapped = false<br/>    for(let j = 0; j &lt; i - 1; j++){<br/>      if(arr[j] &gt; arr[j+1]){<br/>        swap(arr, j, j+1)<br/>        swapped = true<br/>      }<br/>    }<br/>    <strong class="lr io">if(!swapped)break</strong><br/>  }<br/>  <strong class="lr io">return arr</strong><br/>}</span></pre><p id="d04d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将数组返回到for循环的外部，以确保所有迭代都已完成，并且您已经完成了！</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mt"><img src="../Images/4ffba4f8dac716a4207bb96d1da46e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJF2UWem_BQ8-PcpDL2hcg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Splendid!</figcaption></figure></div></div>    
</body>
</html>