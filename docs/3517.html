<html>
<head>
<title>4 Ways to Improve React Component Rendering Speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React组件渲染速度的4种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-faster-component-rendering-f18aabb46442?source=collection_archive---------6-----------------------#2021-07-15">https://javascript.plainenglish.io/react-hooks-faster-component-rendering-f18aabb46442?source=collection_archive---------6-----------------------#2021-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a3e1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何提高React组件渲染速度和性能</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5a38f77cda2603afad2413a2eaf4e653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*71qOMG73c-bxaLy5"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@hikeshaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bofu Shaw</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="77c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在构建面向用户的软件时，性能优化已经成为一个重要的考虑因素。我想不出有多少次我失去了兴趣，关闭了手机上的一个应用程序或一个网站，因为页面——甚至是我最感兴趣的组件——加载时间太长。<a class="ae ks" href="https://www.nngroup.com/articles/how-long-do-users-stay-on-web-pages" rel="noopener ugc nofollow" target="_blank">显然</a>，一般用户在一个网页上只会停留10-20秒，除非有一个清晰的价值主张能够吸引他们的注意力。一个高性能的页面/应用程序应该尽可能快地显示这些重要信息。</p><p id="9757" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像React这样的前端JavaScript框架已经将这一概念融入其中，您可能会对较小的应用程序中提供的现成内容感到满意。React已经在尝试最小化更新UI所需的昂贵的DOM操作。事实上，这里的主要租户是DOM/虚拟DOM比较，以决定哪些组件需要重新呈现。</p><p id="0c18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，更大规模的系统可能会受益于加速组件呈现的附加工具，从而加快应用程序的速度。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="3331" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将关注功能组件和React挂钩，因为这是我最近的写作方式，尽管这些概念也可以在基于类的组件中重用。</p><h1 id="96a9" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">1.使用备忘录()</h1><p id="d895" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">这个钩子实质上缓存了它所传递的函数值。当考虑提高React组件的性能时，一个重要的考虑因素是尽可能少地运行消耗CPU的操作。</p><p id="bca5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如在<a class="ae ks" href="https://medium.com/@df.eporwei/react-hooks-usememo-ace8e81782b1" rel="noopener">之前的文章</a>中所讨论的那样，<code class="fe mt mu mv mw b">useMemo</code>使用了一个叫做记忆化的计算机科学概念。这描述了一个操作，它存储一个昂贵操作的结果，并在使用相同的参数再次调用该函数时简单地返回缓存的值。</p><p id="fbb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">useMemo</code>的函数签名看起来和<code class="fe mt mu mv mw b">useEffect</code>非常相似。看起来是这样的:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="b3d7" class="nb lx in mw b gy nc nd l ne nf">const <!-- -->memoizedValue<!-- --> =<br/>    useMemo(() =&gt; computeSomethingExpensive(a, b), [a, b]);</span></pre><p id="7624" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与<code class="fe mt mu mv mw b">useEffect</code>类似，在初始渲染后，<code class="fe mt mu mv mw b">useMemo</code>不会再次计算<code class="fe mt mu mv mw b">memoizedValue</code>，除非其中一个依赖关系<code class="fe mt mu mv mw b">[a,b]</code>发生变化。</p><p id="efa4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的例子中，我们假设的昂贵函数是<code class="fe mt mu mv mw b">expFunction</code>，我们在<code class="fe mt mu mv mw b">useMemo</code>中调用它，并获取和缓存<code class="fe mt mu mv mw b">resCount</code>作为结果。这里，<code class="fe mt mu mv mw b">useMemo</code>只有在<code class="fe mt mu mv mw b">count</code>改变时才会被重新计算。因此，我们最终得到的是这样一种情况，如果我们在输入字段中键入相同的数字，我们将看到缓存的<code class="fe mt mu mv mw b">resCount</code>值，而不是重新计算的值。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="21c6" class="nb lx in mw b gy nc nd l ne nf">function App() {<br/>    const [count, setCount] = useState(0);<br/>    <br/>    const expFunction = (count) =&gt; {<br/>        return count * 90;<br/>    }    <br/>    <br/>    const resCount = useMemo(()=&gt; {<br/>        return expFunction(count);<br/>    }, [count])    <br/>    <br/>    return (<br/>        &lt;&gt;<br/>            Count: {resCount}<br/>            &lt;input type="number" onChange={(e)=&gt; setCount(e.target.value)} placeholder="Set Count" /&gt;<br/>        &lt;/&gt;<br/>    )<br/>}</span></pre><p id="0482" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于<code class="fe mt mu mv mw b">useMemo</code>需要注意的是，它是在渲染期间运行的，所以正常情况下不应该出现在渲染阶段的东西不应该出现在这里。这意味着副作用属于<code class="fe mt mu mv mw b">useEffect</code>而不是<code class="fe mt mu mv mw b">useMemo</code>。</p><p id="c0f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一件事是，如果依赖列表为空，将在每次渲染时计算<code class="fe mt mu mv mw b">memoizedValue</code>，这违背了本练习的目的😕。</p><h1 id="df25" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><strong class="ak"> 2。使用回拨</strong></h1><p id="9f74" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">这里也发生了记忆化，但不是像<code class="fe mt mu mv mw b">useMemo</code>那样返回记忆化的值，<code class="fe mt mu mv mw b">useCallback</code>返回一个记忆化的函数，该函数只在它的一个依赖关系改变时才改变。</p><p id="61c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个钩子的主要用途是当我们需要在渲染之间维护同一个函数实例的时候。</p><p id="7d39" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请记住，在JS中，在函数和对象上使用<code class="fe mt mu mv mw b">==</code>或<code class="fe mt mu mv mw b">===</code>只执行引用相等。这意味着即使它们共享相同的源，函数实例对解释器来说也是不同的对象:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4643" class="nb lx in mw b gy nc nd l ne nf">function adds() {<br/>   return (a, b) =&gt; a + b;<br/>}</span><span id="1e87" class="nb lx in mw b gy ng nd l ne nf">const sum1 = adds();<br/>const sum2 = adds();</span><span id="3f17" class="nb lx in mw b gy ng nd l ne nf">sum1(2, 4);   //- 6<br/>sum2(2, 4);   //- 6</span><span id="7162" class="nb lx in mw b gy ng nd l ne nf">sum1 == sum2   //- False<br/>sum1 == sum1   //- True</span><span id="9e8c" class="nb lx in mw b gy ng nd l ne nf">sum1 === sum2   //- False<br/>sum1 === sum1   //- True</span></pre><p id="2de6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">举个例子，假设我们想要显示一个很长的列表，并且希望当我们点击列表中的每一项时发生一些事情。作为优化组件的第一步，我们将它包装在<code class="fe mt mu mv mw b">React.memo</code>中，以防止不必要的重新渲染。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4424" class="nb lx in mw b gy nc nd l ne nf">import useSearch from './fetch-items';<br/><br/>function MyBigList({ term, onItemClick }) {<br/>  const items = useSearch(term);<br/>  const map = item =&gt; &lt;div onClick={onItemClick}&gt;{item}&lt;/div&gt;;<br/><br/>  return &lt;div&gt;{items.map(map)}&lt;/div&gt;;<br/>}<br/><br/>export default React.memo(MyBigList);</span></pre><p id="05ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当列表中的每一项被点击时，我们要调用<code class="fe mt mu mv mw b">onItemClick</code>。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4d45" class="nb lx in mw b gy nc nd l ne nf">function ListRenderer({ term }) {<br/><br/>  return (<br/>    &lt;MyBigList<br/>      term={term}<br/>      onItemClick={event =&gt; { <br/>        console.log('You clicked ', event.currentTarget); }<br/>      }<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="b909" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的问题是，传递给<code class="fe mt mu mv mw b">onItemClick</code>的匿名函数在每次渲染时都获得一个新的实例，所以当React比较下一个和上一个道具以决定是否重新渲染<code class="fe mt mu mv mw b">MyBigList</code>时，它没有通过相等性检查。因此，即使函数没有改变，<code class="fe mt mu mv mw b">MyBigList</code>——及其所有项目——得到了不必要的重新渲染🥲.</p><p id="52b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">useCallback</code>在这种情况下很有用:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="e189" class="nb lx in mw b gy nc nd l ne nf">function ListRenderer({ term }) {<br/>  const onItemClick = useCallback(event =&gt; {<br/>    console.log('You clicked ', event.currentTarget);<br/>  }, [term]);<br/><br/>  return (<br/>    &lt;MyBigList<br/>      term={term}<br/>      onItemClick={onItemClick}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="7319" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mt mu mv mw b">onItemClick</code>被记忆，这样即使<code class="fe mt mu mv mw b">ListRenderer</code>被重新渲染，只要<code class="fe mt mu mv mw b">term</code>不变，<code class="fe mt mu mv mw b">useCallback</code>返回相同的函数，<code class="fe mt mu mv mw b">MyBigList</code>不重新渲染。</p><p id="656f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">需要注意的是，如果子组件很轻，并且可以重新渲染而不会出现性能问题，那么调用<code class="fe mt mu mv mw b">useCallback</code>是不必要的。<em class="nh">性能优化的成本可能比一开始就不优化要高。</em></p><h1 id="2054" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">3.React.memo()</h1><p id="8c6e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">根据记忆化的概念，也可以记忆整个功能组件，这样如果传递的属性没有改变，它就可以跳过重新渲染。这种技术可用于优化经常渲染的组件，当传递相同的属性时，这些组件具有相同的输出。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="ba58" class="nb lx in mw b gy nc nd l ne nf">function SomeOtherComponent(props) {<br/>   ...<br/>}<br/>const MyComponent = React.memo(SomeOtherComponent);</span></pre><p id="e052" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">默认情况下<code class="fe mt mu mv mw b">React.memo()</code>会对道具做一个浅显的比较，但是如果你需要更深入的比较，可以传递第二个参数:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="6cf8" class="nb lx in mw b gy nc nd l ne nf">function SomeOtherComponent(props) {<br/>   ...<br/>}</span><span id="3489" class="nb lx in mw b gy ng nd l ne nf">function compareProps(prevProps, nextProps) {<br/>  <!-- -->/*<br/>   return true if passing nextProps to render would return<br/>   the same result as passing prevProps to render,<br/>   otherwise return false<br/>  */<br/>}</span><span id="7a63" class="nb lx in mw b gy ng nd l ne nf">const MyComponent = React.memo(SomeOtherComponent, compareProps);</span></pre><p id="7638" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，React.memo只检查适当更改；如果您的组件使用useState或useContext，则当状态或上下文发生变化时，该组件将正常重新呈现。</p><h1 id="3371" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">4.开窗术</h1><p id="403b" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">这是docs中建议的一种技术，它可以极大地减少创建的DOM节点以及渲染很长的列表所需的时间。使用这种方法，一次只装载列表中项目的一个子集——显示给用户的项目。两个著名的库提供了使用这种技术帮助显示列表、表格和网格的组件，它们是<a class="ae ks" href="https://react-window.vercel.app/#/examples/list/fixed-size" rel="noopener ugc nofollow" target="_blank"> react-window </a>和<a class="ae ks" href="https://bvaughn.github.io/react-virtualized/#/components/List" rel="noopener ugc nofollow" target="_blank"> react-virtualized </a>。</p><h1 id="069a" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">其他优化方法</h1><h2 id="cb5d" class="nb lx in bd ly ni nj dn mc nk nl dp mg lc nm nn mi lg no np mk lk nq nr mm ns bi translated"><strong class="ak">使用生产版本</strong></h2><p id="513e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">它将缩小你的代码库，并尽可能地减少它。</p><h2 id="2565" class="nb lx in bd ly ni nj dn mc nk nl dp mg lc nm nn mi lg no np mk lk nq nr mm ns bi translated"><strong class="ak">尽可能避免渲染中的匿名函数</strong></h2><p id="6980" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">因为没有向匿名函数传递标识符，所以它们不会在呈现之间持久化。这意味着在每次渲染中，解释器都会为这些函数分配一块新的内存(即使它们没有改变)，而不是通过调用对方法的引用来分配一次。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="12eb" class="nb lx in mw b gy nc nd l ne nf">//- Don't do this ❌<br/>function Component() {<br/>    return (<br/>      &lt;button onClick={<br/>           () =&gt; console.log('Unnamed; new instance each render.')}<br/>      &gt;Unnamed<br/>      &lt;/button&gt;<br/>    );<br/>}</span><span id="72c9" class="nb lx in mw b gy ng nd l ne nf">//- Do this ✅<br/>function Component() {<br/>    const handleClick = () =&gt; console.log('Call me by my name');       </span><span id="3d8a" class="nb lx in mw b gy ng nd l ne nf">    return (<br/>      &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;<br/>    );<br/>}</span></pre><h2 id="dc6f" class="nb lx in bd ly ni nj dn mc nk nl dp mg lc nm nn mi lg no np mk lk nq nr mm ns bi translated"><strong class="ak">安装和卸载可能非常昂贵</strong></h2><p id="0049" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">使用条件来安装和卸载组件将导致浏览器重画和重排。这种方法通常是昂贵的，而且根据组件和生成的DOM节点的复杂性，可能会更贵。这是因为当节点被删除和追加时，周围HTML元素的位置和几何形状需要重新计算。一个可选的解决方法是使用CSS可见性/不透明性来隐藏元素。</p><h1 id="89af" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="bdc6" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">最后一个我认为绝对值得一提的工具是Chrome Timeline Devtools，它可以在Performance选项卡中找到。该工具在可视化过度重新渲染的组件时特别有用。通过显示哪些组件被不必要地重新渲染以及重新渲染的频率，它可以很好地概述组件的“健康状况”,从而帮助快速确定应用程序中潜在的问题区域。Chidume Nnamdi已经写了一篇详细的文章，介绍了它的工作原理以及如何使用它。</p><p id="df48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有很多方法可以提高React应用程序的性能，但这是我发现最常用的几种方法。欢迎在评论中提供更多建议。</p><p id="9b41" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">快乐编码。</p><h2 id="dc82" class="nb lx in bd ly ni nj dn mc nk nl dp mg lc nm nn mi lg no np mk lk nq nr mm ns bi translated">参考</h2><ul class=""><li id="99c3" class="nt nu in kv b kw mo kz mp lc nv lg nw lk nx lo ny nz oa ob bi translated"><a class="ae ks" href="https://dmitripavlutin.com/dont-overuse-react-usecallback/" rel="noopener ugc nofollow" target="_blank">不要过度使用useCallback </a></li><li id="4d8b" class="nt nu in kv b kw oc kz od lc oe lg of lk og lo ny nz oa ob bi translated"><a class="ae ks" href="https://dmitripavlutin.com/how-to-compare-objects-in-javascript/" rel="noopener ugc nofollow" target="_blank">如何在JavaScript中比较对象</a></li><li id="c697" class="nt nu in kv b kw oc kz od lc oe lg of lk og lo ny nz oa ob bi translated"><a class="ae ks" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo </a></li><li id="4a2a" class="nt nu in kv b kw oc kz od lc oe lg of lk og lo ny nz oa ob bi translated"><a class="ae ks" href="https://www.smashingmagazine.com/2020/07/methods-performance-react-apps/" rel="noopener ugc nofollow" target="_blank">优化和提高React应用程序性能的方法</a></li></ul><h2 id="8711" class="nb lx in bd ly ni nj dn mc nk nl dp mg lc nm nn mi lg no np mk lk nq nr mm ns bi translated">进一步阅读</h2><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/5-tools-practices-to-help-you-develop-faster-in-react-b884c1b20fc2"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">帮助您在React中更快开发的5种工具和实践</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">React工具、技巧和最佳实践将帮助您更快地构建应用</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy km ok"/></div></div></a></div><p id="cc0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nh">更多内容请看</em><a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">plain English . io</em></strong></a><em class="nh">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="nh">免费周报</em> </strong> </a> <em class="nh">。关注我们关于</em><a class="ae ks" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">Twitter</em></strong></a><a class="ae ks" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">LinkedIn</em></strong></a><em class="nh"/><a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">YouTube</em></strong></a><em class="nh"/><a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">不和</em> </strong> </a> <em class="nh">。</em></p></div></div>    
</body>
</html>