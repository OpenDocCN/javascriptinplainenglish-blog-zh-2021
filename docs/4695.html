<html>
<head>
<title>How to Integrate ESLint into a Legacy Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将ESLint集成到遗留代码库中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-integrate-eslint-into-a-legacy-codebase-f56c59961bd?source=collection_archive---------11-----------------------#2021-09-18">https://javascript.plainenglish.io/how-to-integrate-eslint-into-a-legacy-codebase-f56c59961bd?source=collection_archive---------11-----------------------#2021-09-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1e93f0e8ec8eaba5f4c9deab78558deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9dDfyGa44iUG3Gy-M9cwA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae jz" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e933" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于一个新的JavaScript项目，我通常做的第一件事就是设置和配置<a class="ae jz" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>。ESLint是一个静态代码分析器。它很棒，有两个原因:首先，它帮助你在一个开发团队中或作为一个单独的开发人员实施一致的编码风格——这不仅仅是关于代码美学，而是关于使代码更具可读性。第二，它可以在你写代码的时候发现代码中的错误，这样就不用花太多时间去绞尽脑汁、调试和挖掘堆栈跟踪了。软件开发是复杂的，ESLint是可以让你的生活变得更简单的工具之一。但是ESLint是我首先设置的东西之一的主要原因是，随着你向项目中添加每一行代码，它变得越来越困难。</p><p id="89b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近不得不将ESLint整合到一个两年前的项目中，这是返回的报告:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d8ae" class="lh li in ld b gy lj lk l ll lm">✖ 5549 problems (3726 errors, 1823 warnings) <br/>  3130 errors and 1472 warnings potentially fixable with the `--fix` option.</span></pre><p id="5d6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，我的脑海中闪过一个想法:不值得花力气去整合ESLint。当然，我不想花几个小时手动检查代码来修复一切。我本可以忽略这些错误，希望能够随着时间的推移一点一点地清除它们。但我无法忍受屏幕上的红色曲线，不确定团队中的每个人是否都会像我一样下定决心与它们抗争，尤其是在没有CI对它们指指点点的情况下。</p><p id="817a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我需要一种方法来确保代码风格会随着每次新的提交而逐渐改进。如果我能确保我们接触的每个文件都被清理干净呢？当然，有一种方法，在Git的帮助下，这是可能的:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ea0e" class="lh li in ld b gy lj lk l ll lm">git diff main --name-only --diff-filter=ACM \<br/>  | grep -E '\.(vue|js)$' \<br/>  | xargs node_modules/.bin/eslint</span></pre><p id="fea9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该脚本将只lint主分支中已更改的文件。让我们一行一行地研究这个命令:</p><ul class=""><li id="b1ed" class="ln lo in kc b kd ke kh ki kl lp kp lq kt lr kx ls lt lu lv bi translated">将列出所有与主文件相比被添加、复制或修改的文件的名称。</li><li id="8f2a" class="ln lo in kc b kd lz kh ma kl mb kp mc kt md kx ls lt lu lv bi translated"><code class="fe lw lx ly ld b">grep -E '\.(vue|js)$'</code>将过滤列表中以<code class="fe lw lx ly ld b">.vue</code>或<code class="fe lw lx ly ld b">.js</code>结尾的文件。您必须对此进行调整，以匹配您在ESLint设置中定义的文件模式。</li><li id="710e" class="ln lo in kc b kd lz kh ma kl mb kp mc kt md kx ls lt lu lv bi translated">最后，<code class="fe lw lx ly ld b">xargs node_modules/.bin/eslint</code>将把文件作为参数传递给ESLint。</li></ul><p id="e29e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将此作为脚本保存在<code class="fe lw lx ly ld b">package.json</code>文件中，并将其添加到<a class="ae jz" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github Actions </a>的工作流中。现在，每当有人接触项目中的文件时，他必须在它通过CI之前清理它。随着时间的推移，我们正在实施积极的变革！</p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><p id="05d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">原载于2021年9月18日</em><a class="ae jz" href="https://stricker.digital/posts/integrating-eslint-into-a-legacy-codebase/" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://stricker . digital</em></a><em class="ml">。</em></p><p id="786e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ml">plain English . io</em></strong></a></p></div></div>    
</body>
</html>