<html>
<head>
<title>JWT Authentication in JavaScript in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的JWT认证只需5分钟</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-minutes-to-jwt-authentication-in-javascript-6cc4551494a3?source=collection_archive---------3-----------------------#2021-08-31">https://javascript.plainenglish.io/5-minutes-to-jwt-authentication-in-javascript-6cc4551494a3?source=collection_archive---------3-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ad0923ef57a082e4e30c8764b50809e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j_2zq5YwOaRhey1m"/></div></div></figure><div class=""/><div class=""><h2 id="80a5" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">如何使用JWTs对用户进行身份验证—快速JWT中间件、Node.js Crypto &amp; React</h2></div><p id="e2fe" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">身份验证是一个复杂且经常被分裂的话题，有些人更喜欢有状态会话Cookies方法，而其他人则选择无状态jwt。我是后者中的一员，因为我喜欢实现JWT认证的快捷和有效。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/321c42c5c94767dda8aec8b730741427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*rGl7cBuJPAU1gBNK"/></div></figure><p id="c0e0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每当我们创建应用程序时，我们都需要了解一些重要的安全方面:</p><h1 id="3bb8" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">1.密码</h1><p id="5e9e" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">密码不应该以纯文本的形式存储在数据库中，因为这可能是一个巨大的漏洞。</p><p id="f4d7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设攻击者(黑客)访问了我们的数据库，这已经是一个巨大的安全问题，我们的应用程序因此受到了威胁。如果我们以纯文本形式存储登录信息，攻击者可以重复使用电子邮件和密码组合来访问用户可能使用的其他常见网站，如谷歌甚至在线银行。</p><p id="f0a4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">是的，大多数这些平台需要<a class="ae mo" href="https://authy.com/what-is-2fa/" rel="noopener ugc nofollow" target="_blank"> 2FA </a>或其他额外的步骤来进行身份验证，但这并不是故意暴露客户凭证的理由。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/67a6b060155de2cbcfe9d8e764d41f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPKYszQDkKIDn-sw"/></div></div></figure><p id="d9e2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">幸运的是，解决方案相当简单，那就是在数据库中存储一个散列而不是普通的密码。</p><p id="e0f3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">哈希是加密函数的结果，该函数接收输入并始终返回该特定输入的唯一固定大小(SHA256为256位)。</p><h1 id="d017" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">生成<a class="ae mo" href="https://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/" rel="noopener ugc nofollow" target="_blank"> SHA256 </a></h1><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/0490a011283679552a6d5b0ee41925f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jk1gagrQ8R-cUHyOZslaLQ.png"/></div></div></figure><h1 id="032a" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">2.认证(<a class="ae mo" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>)</h1><p id="5f43" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">JWT (JSON Web Tokens)是一种存储用户凭证并以安全的方式在双方(前端客户端和后端服务器)之间传递凭证的全球标准化方法。</p><p id="3ab2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">基本上，JWT是一个字符串，它应该在后端生成并存储在前端，随每个请求一起发送。</p><blockquote class="mr ms mt"><p id="21ef" class="kq kr mu ks b kt ku kc kv kw kx kf ky mv la lb lc mw le lf lg mx li lj lk ll ij bi translated">但是，我们如何生成这个令牌，以及我们将令牌存储在客户端的什么位置呢？</p></blockquote><p id="a181" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们看看如何在Express应用程序中使用JWTs对用户进行身份验证:</p><p id="add1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我将使用<a class="ae mo" href="https://www.npmjs.com/package/express-jwt" rel="noopener ugc nofollow" target="_blank"> express-jwt </a>中间件库，因为它非常简单明了，注意还有其他可能更健壮的包，如<a class="ae mo" href="https://www.npmjs.com/package/passport" rel="noopener ugc nofollow" target="_blank"> passport </a>。</p><h1 id="d83e" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">生成JWT</h1><p id="d106" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">我们首先必须使用以下命令创建我们的示例项目:</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/5efa80b64ef0ccd23a5de519ea2ff779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z13KA7qzkJnuPheWaB5Fdg.png"/></div></div></figure><p id="bc83" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">之后，只需创建一个<code class="fe mz na nb nc b">index.js</code>文件，并向package.json添加一个启动脚本，如下所示<code class="fe mz na nb nc b">"start": "node index"</code></p><p id="bf76" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们需要公开2个端点，一个用于用户注册，另一个用于登录。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/f948faf95173529309aee12b14eb4452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvW9Y9Tyq8bO7pUipx31qw.png"/></div></div></figure><h1 id="17de" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">注册</h1><p id="489f" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">在这里，我们必须生成散列密码，并将其与提供的电子邮件一起插入数据库。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/7dd4f2b86220e2a6760283d398d25e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QMrl93KS3XoEBgbunuUyQ.png"/></div></div></figure><h1 id="a530" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">注册</h1><p id="ece0" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">与注册类似，我们需要密码的哈希值，并使用它来检查数据库中是否存在email和hashedPassword对。使用用户对象，我们对JWT令牌进行签名，并在公开的授权响应头中返回它。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/245b947be9b11aa36bd639299cf5592b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D42eSniNoFC7l0pbpXMv2Q.png"/></div></div></figure><h1 id="1046" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">商店JWT</h1><p id="7882" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">在客户端保持jwt持久化有两种常见的方法:</p><ul class=""><li id="fdbb" class="nf ng jb ks b kt ku kw kx kz nh ld ni lh nj ll nk nl nm nn bi translated">饼干</li><li id="7bc9" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">局部存储器</li></ul><p id="ada9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">两者都存在安全问题，比如XSS、T2、CSRF、T4和XST，因此这两种存储方式都不完全安全。</p><p id="c88c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我更喜欢将jwt存储在cookies中，因为这可能比本地存储IMOP稍微安全一点。</p><p id="dc85" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们假设我们的客户机是一个SPA，更准确地说是一个React-powered应用程序，客户机经常使用Axios客户机向API发出请求。</p><p id="3c97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们创建一个自定义的Axios客户端类，我们称之为request.js。</p><p id="ba75" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将使用<a class="ae mo" href="https://www.npmjs.com/package/react-cookie" rel="noopener ugc nofollow" target="_blank"> react-cookie </a>，因为它提供了一个简单的钩子API来操作cookie。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/d878d064a939cf670b4ac6b8111d8b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Fq4IfXRg9Y1ie3hqLQE5g.png"/></div></div></figure><h1 id="97b4" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">包扎</h1><p id="0bd2" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">安全性是一个棘手的领域，身份验证通常更棘手，因为保护用户数据是应用程序最重要的目标。</p><p id="32aa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你想检查这里的代码是<a class="ae mo" href="https://codesandbox.io/s/express-jwt-example-ln0og?file=/index.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>链接。</p><p id="9340" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mu">在</em><a class="ae mo" href="https://www.alexstreza.dev/" rel="noopener ugc nofollow" target="_blank"><em class="mu">alexstreza . dev</em></a><em class="mu">查看更多我的作品。</em></p><p id="1495" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我希望您喜欢这个简短的JavaScript JWT认证展示，如果您给它一个👏！</p><p id="ad40" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mu">更多内容请看</em><a class="ae mo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ks jc"><em class="mu">plain English . io</em></strong></a></p></div></div>    
</body>
</html>