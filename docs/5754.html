<html>
<head>
<title>Generators and Iterators in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的生成器和迭代器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generators-and-iterators-in-javascript-115bb94ed4f6?source=collection_archive---------7-----------------------#2021-12-06">https://javascript.plainenglish.io/generators-and-iterators-in-javascript-115bb94ed4f6?source=collection_archive---------7-----------------------#2021-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="81e6" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">代码速赢</h2><div class=""/><div class=""><h2 id="700e" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">什么是发电机功能？我应该在乎吗？</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1ac9ae6927093fcd39829172b2bed7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BnjMQYO04Vw5sGKe"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@gregwillson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Greg Willson</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="889d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">是否应该关心生成器函数是有争议的。在我的第一份开发工作中，我一次也没有使用过它们，我的同事也没有使用过。我在那里待了将近三年。</p><p id="95cf" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">然而，我确实认为生成器函数值得理解，原因有二:</p><ol class=""><li id="0d96" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">避免在技术面试中被暗算。</li><li id="e25b" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">作为开发人员，不断学习应该是你的目标之一。</li></ol><p id="228c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">老实说，第一个原因是最初迫使我深入挖掘的原因。但是我很高兴我这么做了，因为我发现这很有趣。幸运的是，我现在在一个使用生成器函数的地方工作，旁边是一个名为<a class="ae lb" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>的库。所以它实际上让我受益匪浅！</p><p id="3c22" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">那么什么是生成器函数呢？为了回答这个问题，我首先想谈谈:</p><h1 id="f599" class="mm mn in bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">迭代器和迭代器，天啊。</h1><p id="2353" class="pw-post-body-paragraph lc ld in le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ig bi translated">iterable对于任何JavaScript对象来说都是一个有趣的词，它为自己定义了在被循环(迭代)时的行为。</p><p id="8148" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">MDN 是这样说的:</p><blockquote class="nj nk nl"><p id="adc8" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated">如果一个对象定义了它的迭代行为，比如什么值在一个<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a></code>结构中循环，那么它就是<strong class="le ix">可迭代的</strong>。一些内置类型，如<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">Array</a></code>或<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">Map</a></code>，有默认的迭代行为，而其他类型(如<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">Object</a></code>)没有。</p></blockquote><p id="bfd8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">那么我如何创建自己的可迭代对象呢？为此，我需要实现<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix">可迭代协议</strong> </a>。</p><p id="9afd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">iterable protocol (protocol只是一个时髦的词，表示一种约定好的做事方式)只是要求您向自定义对象添加一个名为<code class="fe nq nr ns nt b">Symbol.iterator</code>的属性。就是这样。</p><p id="46a4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="57b1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">你可能会问，<code class="fe nq nr ns nt b">Symbol.iterator</code>的值需要是多少？</p><p id="ca59" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><code class="fe nq nr ns nt b">Symbol.iterator</code>的值需要实现另一个协议(🤦‍♂️)，称为<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix">的迭代器协议</strong> </a>。</p><p id="8035" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">根据<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterators" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="nj nk nl"><p id="c26d" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated">具体来说，迭代器是通过使用一个返回具有两个属性的对象的<code class="fe nq nr ns nt b">next()</code>方法来实现<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>的任何对象:</p><p id="fc72" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated"><code class="fe nq nr ns nt b">value</code></p><p id="34e0" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated">迭代序列中的下一个值。</p><p id="9650" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated"><code class="fe nq nr ns nt b">done</code></p><p id="6277" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated">如果序列中的最后一个值已经被消耗，这就是<code class="fe nq nr ns nt b">true</code>。如果<code class="fe nq nr ns nt b">value</code>出现在<code class="fe nq nr ns nt b">done</code>旁边，它就是迭代器的返回值。</p></blockquote><p id="d927" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我给你一个图像。</p><p id="b856" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">对于下一个例子，让我们假设我已经提前创建了一个名为<code class="fe nq nr ns nt b">generateMonster</code>的函数。每调用一次，就从零开始吐出一个不同程序生成的怪物。太棒了。</p><p id="401f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们现在也假设<code class="fe nq nr ns nt b">generateMonster</code>是同步的。</p><p id="0ccd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="92c0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">一旦我们在自定义对象上定义了<code class="fe nq nr ns nt b">Symbol.iterator</code>属性的值(使用迭代器协议)，我们就可以在<code class="fe nq nr ns nt b">for...of</code>循环中使用它。上面代码的日志输出将是五个独特的怪物。</p><p id="d47b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们也可以手动迭代我们的<code class="fe nq nr ns nt b">monsterList</code>，就像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f0a1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这为我们提供了一种按照自己的节奏逐步完成<code class="fe nq nr ns nt b">monsterList</code>的方法。例如，我们可能想得到第一个怪物，但随后做一些其他的事情，然后再回来得到其他的怪物。迭代器协议允许我们这样做。</p><p id="1449" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">大获成功！我们现在已经创建了自己的定制对象，它符合iterable和iterator协议。</p><p id="a57d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">你知道还有什么符合iterable和iterator协议吗？</p><p id="98cb" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">猜猜看。</p><h1 id="f1bc" class="mm mn in bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">发电机(最终)</h1><p id="19ee" class="pw-post-body-paragraph lc ld in le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ig bi translated">现在我们有了一些背景知识，我们可以对什么是<code class="fe nq nr ns nt b">Generator</code>有一个更清晰的理解，以及如何产生一个具有生成器功能的。</p><p id="fad1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">根据<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="nj nk nl"><p id="2af8" class="lc ld nm le b lf lg jx lh li lj ka lk nn lm ln lo no lq lr ls np lu lv lw lx ig bi translated"><code class="fe nq nr ns nt b"><strong class="le ix">Generator</strong></code>对象由<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">生成器函数</a>返回，它符合<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol" rel="noopener ugc nofollow" target="_blank">可迭代协议</a>和<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>。</p></blockquote><p id="2d65" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">简单地说，一个生成器函数给了我们一个<code class="fe nq nr ns nt b">Generator</code>对象。该对象为我们处理<strong class="le ix">可迭代</strong>和<strong class="le ix">迭代器</strong>协议的实现。</p><p id="b83c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">使用一个生成器函数，下面是<code class="fe nq nr ns nt b">monsterList</code>可能的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0ac8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">上面的代码将会以与之前完全相同的方式运行。</p><p id="e7bb" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">以下是新的东西:</p><ol class=""><li id="f93b" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated"><code class="fe nq nr ns nt b">function*</code>。在<code class="fe nq nr ns nt b">function</code>关键字旁边的星号就是指定它作为一个生成器函数的原因。</li><li id="6002" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated"><code class="fe nq nr ns nt b">yield</code>。这个关键字相当于像我们前面做的那样返回一个带有<code class="fe nq nr ns nt b">value</code>和<code class="fe nq nr ns nt b">done</code>属性的对象，除了它简化了事情，只让您返回一个值。</li></ol><p id="690b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在每个<code class="fe nq nr ns nt b">yield</code>、<strong class="le ix">之后，发生器函数的迭代完成</strong>。在这一点上，生成器功能实际上暂停了。</p><p id="840d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">该函数将不会继续执行，直到下一次调用<code class="fe nq nr ns nt b">.next()</code>，无论是手动完成还是在<code class="fe nq nr ns nt b">for...of</code>循环中完成，就像我们前面的例子一样。</p><p id="d085" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">一旦函数中不再有<code class="fe nq nr ns nt b">yield</code>，生成器函数将在终止前返回未定义，因此<code class="fe nq nr ns nt b">.next()</code>的最终值将是<code class="fe nq nr ns nt b">{value: undefined, done: true}</code>。</p><p id="735b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">然而，上面的例子实际上只使用了<code class="fe nq nr ns nt b">Generator</code>对象的一半值。我们目前只使用它来实现<strong class="le ix">迭代器</strong>协议。我们仍然在实现我们自己的<strong class="le ix"> iterable </strong>协议，因为我们仍然在创建我们自己的自定义对象并为<code class="fe nq nr ns nt b">Symbol.iterator</code>赋值。</p><p id="9d8b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我们想充分利用生成器函数，我们可以进一步简化代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1fcf" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在我们充分利用了生成器函数语法。</p><h1 id="829d" class="mm mn in bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">异步发电机</h1><p id="61d4" class="pw-post-body-paragraph lc ld in le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ig bi translated">现在让我们假设我的<code class="fe nq nr ns nt b">generateMonster</code>函数返回一个<code class="fe nq nr ns nt b">Promise</code>。幸运的是，我们仍然可以使用生成器函数异步获得一群怪物。</p><p id="a54c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e060" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果你想在一个异步的<code class="fe nq nr ns nt b">for...of</code>循环中运行它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cf6c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">新的东西是:</p><ol class=""><li id="a6e8" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">我们在生成器函数<code class="fe nq nr ns nt b">monsterList</code>之前使用了<code class="fe nq nr ns nt b">async</code>关键字。</li><li id="1c92" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">我们在调用<code class="fe nq nr ns nt b">generateMonster</code>之前使用<code class="fe nq nr ns nt b">await</code>关键字。</li><li id="1d81" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">如果我们想使用<code class="fe nq nr ns nt b">.next()</code>手动迭代我们的<code class="fe nq nr ns nt b">Generator</code>，我们需要抓取<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator" rel="noopener ugc nofollow" target="_blank">Symbol.asyncIterator</a></code>而不是<code class="fe nq nr ns nt b">Symbol.iterator</code>。</li><li id="3fbf" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">如果我们想通过一个循环运行我们的<code class="fe nq nr ns nt b">Generator</code>对象，我们使用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" rel="noopener ugc nofollow" target="_blank">for await...of</a></code>来完成。此外，我们必须在异步环境中包装循环。在这个例子中，我选择将它包装在一个异步的生命周期中。</li></ol><h1 id="9878" class="mm mn in bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">有什么意义？</h1><p id="4a9d" class="pw-post-body-paragraph lc ld in le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ig bi translated">一个生成器函数可以让你遍历正在创建的值，这很酷。这可以带来更好的性能，因为它比在内存中保存一个巨大的数据结构，然后在其上循环更便宜。</p><p id="ed9c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为了形象化，想象你因为某种原因需要收集一英里长的绳子。</p><p id="5bda" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">有了发电机功能，就像从魔术帽中拉出绳子一样。<strong class="le ix">你不需要整根绳子就可以开始收集</strong>。你可以拉绳子，当你继续拉的时候，你可以神奇地得到更多的绳子。</p><p id="1e38" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">相反，你旁边有一根很长的绳子，占据了空间，然后你抓住绳子的一端，开始从地板上收集它。</p><p id="6178" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">生成器函数的这种特性是它们能够很好地表达数据流的原因之一。当数据到达时，你可以增量地获取一些数据并对其进行处理。</p><h1 id="4100" class="mm mn in bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">离别的思绪</h1><p id="e078" class="pw-post-body-paragraph lc ld in le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ig bi translated">说到底，我不认为存在一个只有生成器函数才能解决的问题。但是编码的部分乐趣在于有这么多创造性的方法来解决同一个问题！知道了如何使用生成器函数，您的工具箱中就多了一个这样的工具。</p><p id="1631" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">而且，这表明你可能知道你在用JavaScript做什么。</p><p id="bd14" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">感谢阅读！😄看看我在quickwinswithcode.com的一些早期文章。</p><p id="01a6" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="nm">如果这篇文章中关于异步编程的任何内容令人困惑，请查看我的另一篇文章:</em></p><div class="nw nx gp gr ny nz"><a href="https://codeburst.io/quick-wins-with-code-promises-in-javascript-4a5b09bd95c5" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ix gy z fp oe fr fs of fu fw iw bi translated">代码速赢:JavaScript中的承诺</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">快速浏览在JavaScript中处理异步代码。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">codeburst.io</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kv nz"/></div></div></a></div></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><p id="14af" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">资源:</strong></p><ul class=""><li id="04b0" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx ov me mf mg bi translated"><a class="ae lb" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-saga </a></li><li id="1790" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">迭代协议</a></li><li id="2d7f" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">迭代器和生成器</a></li><li id="db4e" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">发电机</a></li><li id="ea00" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator" rel="noopener ugc nofollow" target="_blank"> Symbol.asyncIterator </a></li><li id="b842" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" rel="noopener ugc nofollow" target="_blank">用于</a>的wait……</li><li id="2854" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx ov me mf mg bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生活</a></li></ul><p id="9c29" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="nm">更多内容请看</em><strong class="le ix"><em class="nm"/></strong><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nm">说白了. io </em> </strong> </a> <strong class="le ix"> <em class="nm">。</em> </strong> <em class="nm">报名参加我们的</em> <a class="ae lb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> <em class="nm">免费每周简讯这里</em> </strong> </a> <strong class="le ix"> <em class="nm">。</em>T47】</strong></p></div></div>    
</body>
</html>