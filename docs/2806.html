<html>
<head>
<title>How to Create Tree Control in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中创建树控件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-tree-control-8896e63f04a?source=collection_archive---------10-----------------------#2021-06-08">https://javascript.plainenglish.io/angular-tree-control-8896e63f04a?source=collection_archive---------10-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="69bc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这篇文章将向你展示如何使用角度模板和内容投影来编写一个可定制的树控件。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6fe2fe2e8b3dda9999d36b6095818222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SB83plbJ5lfJQNCB_VNWig.jpeg"/></div></div></figure><h1 id="9f1b" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">设置</h1><p id="7f7e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们首先定义组件使用的模型。</p><pre class="kd ke kf kg gt mc md me mf aw mg bi"><span id="f7fb" class="mh kp in md b gy mi mj l mk ml">export interface TreeItem {<br/>  children?: TreeItem[];<br/>  expanded?: boolean;<br/>}</span></pre><p id="d24a" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">接下来，让我们定义我们的组件</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dba7" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">如上所述，我们在TypeScript中使用泛型来定义我们的组件与任何扩展<code class="fe mt mu mv md b">TreeItem</code>接口的数据结构一起工作。</p><p id="f762" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">它还期望我们投射一个<code class="fe mt mu mv md b">TemplateRef</code>。在我们的html中，这不过是<code class="fe mt mu mv md b">ng-template</code>。</p><h1 id="7cb4" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">让我们构建模板</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a6c2" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">这看起来有点棘手，但实际上非常简单。<code class="fe mt mu mv md b">treeTemplate</code>模板只是定义了树的一个层次。如果它有孩子，它会重复自己，但是上下文设置为<code class="fe mt mu mv md b">item.children</code></p><p id="3090" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated"><code class="fe mt mu mv md b">nodeTemplate</code>是模板的消费者传入的模板。这使得用户可以完全控制每个节点的外观。</p><p id="fde1" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">如果您以前没有使用过带有<code class="fe mt mu mv md b">let</code>语法的<code class="fe mt mu mv md b">ng-template</code>，这里有一个快速概述。</p><ol class=""><li id="c727" class="mw mx in li b lj mm lm mn lp my lt mz lx na mb nb nc nd ne bi translated">您可以使用<code class="fe mt mu mv md b">*ngTemplateOutlet</code>结构指令实例化一个<code class="fe mt mu mv md b">ng-template</code>。</li><li id="c496" class="mw mx in li b lj nf lm ng lp nh lt ni lx nj mb nb nc nd ne bi translated">这样做时，您可以使用<code class="fe mt mu mv md b">context</code>对象将数据传递给模板。</li><li id="9cda" class="mw mx in li b lj nf lm ng lp nh lt ni lx nj mb nb nc nd ne bi translated">要访问上下文中传递的任何属性，必须使用let语法。因此，如果您的上下文是<code class="fe mt mu mv md b">{name: 'John'}</code>，要访问模板中的<code class="fe mt mu mv md b">name</code>，您必须这样做<code class="fe mt mu mv md b">&lt;ng-template let-firstname="name"&gt;{{firstname}}&lt;/ng-template&gt;</code></li><li id="9869" class="mw mx in li b lj nf lm ng lp nh lt ni lx nj mb nb nc nd ne bi translated">您可以删除正在访问的<code class="fe mt mu mv md b">$implicit</code>属性。所以如果上下文是<code class="fe mt mu mv md b">{$implicit: 'John'}</code>，那么你可以使用<code class="fe mt mu mv md b">&lt;ng-template let-firstname&gt;{{firstname}}&lt;/ng-template&gt;</code></li></ol><h1 id="1ce2" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">让我们看看如何消费这个组件。</h1><p id="6c6a" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">首先让我们定义我们的应用程序组件</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ef94" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">接下来，我们将使用应用程序组件html中的组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6c95" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">这里，我们定义了自己的接口，它扩展了我们在一开始定义的<code class="fe mt mu mv md b">TreeItem</code>接口。</p><p id="8a1d" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">在app组件中，我们只是将节点的<code class="fe mt mu mv md b">treeData</code>和<code class="fe mt mu mv md b">ng-template</code>传递给树组件。它负责递归地呈现你传入的模板。</p><h1 id="9ed2" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">工作样本(Stackblitz)</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk ms l"/></div></figure><h1 id="60ca" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">额外小费</h1><p id="84d2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果你想支持一个包含大量条目的树控件，那么你可以用自定义的<code class="fe mt mu mv md b">*ngxtFor</code>指令替换树控件中的<code class="fe mt mu mv md b">*ngFor</code>，我在<a class="ae nl" href="https://sanjaybhavnani.medium.com/advanced-angular-structural-directive-to-render-long-lists-db1575d761ce" rel="noopener">这篇文章</a>中展示了这个指令。它使用渐进渲染概念。</p><p id="49f2" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated">你也可以尝试将它与cdk虚拟滚动结合起来，但我没有尝试过，所以我不能说实现它有多容易或多困难。</p><p id="a60a" class="pw-post-body-paragraph lg lh in li b lj mm jo ll lm mn jr lo lp mo lr ls lt mp lv lw lx mq lz ma mb ig bi translated"><em class="nm">更多内容尽在</em><a class="ae nl" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>