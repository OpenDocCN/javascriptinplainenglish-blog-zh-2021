<html>
<head>
<title>Four Sequelize Associations You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该了解的四种Sequelize关联</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/four-sequelize-associations-you-should-know-415d8d413e1e?source=collection_archive---------0-----------------------#2021-05-10">https://javascript.plainenglish.io/four-sequelize-associations-you-should-know-415d8d413e1e?source=collection_archive---------0-----------------------#2021-05-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ed141c576d3dcaeac3e46d3504b0168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bMcQcLAE-fPjVEhnY5xsQ.png"/></div></div></figure><p id="c28a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Sequelize是Postgres、MySQL、MariaDB、SQLite和Microsoft SQL Server的基于承诺的Node.js ORM。它具有可靠的事务支持、关系、急切和惰性加载、读复制等特性。数据库表中的联接对于将所有相关信息集合在一起非常常见。在前一篇文章中，我们已经介绍了Sequelize 的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/save-time-learn-sequelize-in-7-mins-part-1-3e4fde67d037">基础知识。</a></p><p id="c07f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在今天的帖子中，我们将学习Sequelize关联，热切加载和懒惰加载。但在此之前，让我们了解一下什么是SQL中的联接。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="40d7" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">SQL联接</h2><p id="92fa" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">SQL中的联接用于在查询结果中组合两个或多个表。因为不可能把所有东西都放在一张桌子上。使用联接，您可以使用外键和主键的概念来连接表。有4种类型的连接，</p><ul class=""><li id="bd74" class="lz ma in jx b jy jz kc kd kg mb kk mc ko md ks me mf mg mh bi translated">内部联接:返回两个表中具有匹配值的记录</li><li id="9b91" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">LEFT OUTER JOIN:返回左(from)表中的所有记录，以及右(JOIN)表中的匹配记录&amp;如果未找到，则为Null</li><li id="7137" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">右外连接:返回右(连接)表中的所有记录，以及左(来自)表中的匹配记录&amp;如果未找到，则为空</li><li id="9bf9" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">完全外部联接:当左表或右表中有匹配项时，返回所有记录</li></ul><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/744aefca231459f30302d73190bf53f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsWmiKVD-tp6MSkZHssuow.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Joins in SQL</figcaption></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="f39f" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">Sequelize协会</h2><p id="f8ea" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">Sequelize中的关联是指两个表之间的关系。有4种类型的关联，</p><ul class=""><li id="99c7" class="lz ma in jx b jy jz kc kd kg mb kk mc ko md ks me mf mg mh bi translated">“HasOne”协会</li><li id="2d56" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">“归属”协会</li><li id="4eeb" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">“哈斯多”协会</li><li id="652f" class="lz ma in jx b jy mi kc mj kg mk kk ml ko mm ks me mf mg mh bi translated">“BelongsToMany”协会</li></ul><p id="cfb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始联想之前，让我们考虑一下有3张表<br/> 1。用户(存储用户信息，如姓名、性别、国家、电子邮件、uId、UUID等。)<br/> 2。帖子(店铺帖子信息)<br/> 3。账户(存储账户信息，如付费、免费、每月、年度用户等。)</p><p id="bdda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建关联，表之间应该存在某种关系。表1之间基本上存在三种类型的关系。<em class="mw">一对一</em> 2。<em class="mw">一对多</em> &amp; 3。<em class="mw">多对多</em>。现在每个关系定义了表之间的关联，如<br/> 1。<strong class="jx io">一对一</strong>关系总是有<em class="mw">有</em> &amp; <em class="mw">到</em>的联想。<br/> 2 .<strong class="jx io">一对多</strong>关系总是有<em class="mw">有很多</em> &amp; <em class="mw">隶属于</em>关系。<br/> 3 .<strong class="jx io">多对多</strong>关系总是有两种<em class="mw">到</em>的关联。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/05761af266a2d5a2af9365156c902174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXbVq0f6zLOpqWCBfaNKUg.jpeg"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">one to one/many relationship diagram</figcaption></figure><h2 id="9ba4" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">一对一的关系:</h2><p id="b2ba" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">假设一个用户只能有一个账户。为了识别哪个表将有<strong class="jx io"> <em class="mw">有一个</em> </strong> &amp;哪个表将有<strong class="jx io"> <em class="mw">属于</em> </strong>关联，问一个问题:一个帐户是否存在而没有用户/用户是否存在而没有帐户？答案是用户可以在没有帐户的情况下存在，这意味着用户充当父表&amp;帐户充当子表。首先创建用户简档&amp;，然后基于计划创建账户。<br/>这意味着帐户表将保存用户表的主键作为外键，例如<em class="mw"> uId </em>是用户表中的主键。所以关联将是<br/><em class="mw">User . hasone(Account)&amp;Account . belongs to(User)</em></p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="5e6f" class="lb lc in mz b gy nd ne l nf ng">const User = sequelize.define('User', { name: DataTypes.STRING }); const Account = sequelize.define('Account', { packageType: DataTypes.STRING }); <br/>User.hasOne(Account); <br/>Account.belongsTo(User);</span></pre><h2 id="9198" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">一对多关系:</h2><p id="6332" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">假设一个用户可以发布多篇文章。为了识别哪个将有<strong class="jx io"> <em class="mw">有多个</em> </strong> &amp;哪个表将有<strong class="jx io"> <em class="mw">属于</em> </strong>关联，问一个问题:一个帖子是否存在而没有用户/用户是否存在而没有帖子？答案是用户可以在没有帖子的情况下存在，这意味着用户充当父表&amp;帖子充当子表。首先创建用户简档&amp;，然后用户可以发布帖子。<br/>这意味着post表将保存用户表的主键作为外键，例如<em class="mw"> uId </em>是用户表中的主键。所以联想将<br/><em class="mw">User . has many(Post)&amp;Post . belongs to(User)</em></p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="5a89" class="lb lc in mz b gy nd ne l nf ng">const User = sequelize.define('User', { name: DataTypes.STRING }); const Post = sequelize.define('Post', { title: DataTypes.STRING }); <br/>User.hasMany(Post); <br/>Post.belongsTo(User);</span></pre><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/aff024c627ddcb4c294439da3f57aa53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*9yNt1IKJd8L4HMFLijjaDg.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">many to many relationship diagram</figcaption></figure><p id="aee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">多对多关系:<br/> </strong>多对多关联将一个源与多个目标连接起来，而所有这些目标又可以连接到第一个源之外的其他源。这不能像其他关系那样通过向其中一个表添加一个外键来表示。相反，使用了<a class="ae kt" href="https://en.wikipedia.org/wiki/Associative_entity" rel="noopener ugc nofollow" target="_blank">连接模型</a>的概念。这将是一个额外的模型(和数据库中的额外表)，它将有两个外键列，并将跟踪关联。连接台有时也称为<em class="mw">连接台</em>或<em class="mw">直通台</em>或<em class="mw">枢纽台</em>。</p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="c19c" class="lb lc in mz b gy nd ne l nf ng">const User = sequelize.define('User', { name: DataTypes.STRING }); const Project = sequelize.define('Project', { name: DataTypes.STRING }); <br/>User.belongsToMany(Project, { through: 'UserProjects' }); Project.belongsToMany(User, { through: 'UserProjects' });</span></pre><p id="f9cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，一个用户可以是多个项目的一部分&amp;一个项目可以有多个用户。</p><p id="d353" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">获取关联:<br/> </strong>获取关联有两种方式1。<em class="mw">急切装载</em> &amp; 2。<em class="mw">懒加载</em>。急切加载意味着关联包含在主查询中，所以所有内容都被提取一次。而延迟加载仅在需要时才引用获取关联。</p><p id="ade2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，急于装货</p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="0947" class="lb lc in mz b gy nd ne l nf ng">const userDetail = await User.findOne({<br/>   where: {     <br/>    email: "testuser@example.co"   <br/>   },<br/>   include: Account<br/> });</span></pre><p id="fabc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，延迟装载</p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="99de" class="lb lc in mz b gy nd ne l nf ng">const userDetail = await User.findOne({<br/>   where: {     <br/>    email: "testuser@example.co"   <br/>   },<br/> });<br/>const userAccount = await userDetail.getAccount();</span></pre><ul class=""><li id="6f81" class="lz ma in jx b jy jz kc kd kg mb kk mc ko md ks me mf mg mh bi translated"><em class="mw">注意:上面使用的</em> <code class="fe ni nj nk mz b">getAccount<em class="mw">()</em></code> <em class="mw">实例方法是Sequelize自动添加到</em> <code class="fe ni nj nk mz b"><em class="mw">User</em></code> <em class="mw">实例的方法之一。</em></li></ul><p id="d875" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mw">为什么在父&amp;子表中指定关联很重要？</em> </strong> <em class="mw"> <br/> </em>当两个模型之间定义了一个顺序关联时，只有“源<strong class="jx io">”</strong>模型知道。例如，在上面的例子中，当定义User.hasOne(Account)时，用户是源模型，只有用户表知道与帐户的关系，而没有定义Account.belongsTo(User)帐户表不知道与用户的关系。如果您没有在两个表中定义一个关系，并试图用一个Account表获取用户信息，Sequelize将给出一个错误“SequelizeEagerLoadingError:用户没有关联到Account！”。这就是为什么有必要成对定义关系</p><p id="2a3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看在急切加载时如何生成SQL查询。</p><pre class="mo mp mq mr gt my mz na nb aw nc bi"><span id="9b43" class="lb lc in mz b gy nd ne l nf ng">// Inner where, with default `required: true`<br/>await User.findAll({<br/>  include: {<br/>    model: <!-- -->Post<!-- -->,<br/>    as: '<!-- -->Posts<!-- -->',<br/>    where: {<br/>      status: { [Op.ne]: 'draft' }<br/>    }<br/>  }<br/>});</span><span id="9a17" class="lb lc in mz b gy nl ne l nf ng">SELECT * FROM `users` AS `user`<br/>INNER JOIN `p<!-- -->osts<!-- -->` AS `<!-- -->Posts<!-- -->` ON<br/>  `user`.`<!-- -->uId<!-- -->` = `<!-- -->Posts<!-- -->`.`<!-- -->uId<!-- -->`<br/>  AND `<!-- -->Posts<!-- -->`.`status` != 'draft';</span><span id="af67" class="lb lc in mz b gy nl ne l nf ng">// Inner where, `required: false`<br/>await User.findAll({<br/>  include: {<br/>    model: <!-- -->Post<!-- -->,<br/>    as: '<!-- -->Posts<!-- -->',<br/>    where: {<br/>      status: { [Op.ne]: 'draft' }<br/>    },<br/>    required: false<br/>  }<br/>});</span><span id="87ed" class="lb lc in mz b gy nl ne l nf ng">SELECT * FROM `users` AS `user`<br/>LEFT OUTER JOIN `p<!-- -->osts<!-- -->` AS `<!-- -->Posts<!-- -->` ON<br/>  `user`.`<!-- -->uId<!-- -->` = `<!-- -->Posts<!-- -->`.`<!-- -->uId<!-- -->`<br/>  AND `<!-- -->Posts<!-- -->`.`status` != 'draft';</span><span id="1034" class="lb lc in mz b gy nl ne l nf ng"><br/>// Top-level where, with default `required: false`<br/>await User.findAll({<br/>  where: {<br/>    '$<!-- -->Posts<!-- -->.status$': { [Op.ne]: 'draft' }<br/>  },<br/>  include: {<br/>    model: <!-- -->Post<!-- -->,<br/>    as: '<!-- -->Posts<!-- -->'<br/>  }<br/>});</span><span id="3ea6" class="lb lc in mz b gy nl ne l nf ng">SELECT * FROM `users` AS `user`<br/>LEFT OUTER JOIN `p<!-- -->osts<!-- -->` AS `<!-- -->Posts<!-- -->` ON<br/>  `user`.`<!-- -->uId<!-- -->` = `<!-- -->Posts<!-- -->`.`<!-- -->uId<!-- -->`<br/>WHERE `<!-- -->Posts<!-- -->`.`status` != 'draft';</span><span id="11c6" class="lb lc in mz b gy nl ne l nf ng">// Top-level where, `required: true`<br/>await User.findAll({<br/>  where: {<br/>    '$<!-- -->Posts<!-- -->.status$': { [Op.ne]: 'draft' }<br/>  },<br/>  include: {<br/>    model: <!-- -->Post<!-- -->,<br/>    as: '<!-- -->Posts<!-- -->',<br/>    required: true<br/>  }<br/>});</span><span id="ae2d" class="lb lc in mz b gy nl ne l nf ng">SELECT * FROM `users` AS `user`<br/>INNER JOIN `p<!-- -->osts<!-- -->` AS `<!-- -->Posts<!-- -->` ON<br/>  `user`.`<!-- -->uId<!-- -->` = `<!-- -->Posts<!-- -->`.`<!-- -->uId<!-- -->`<br/>WHERE `<!-- -->Posts<!-- -->`.`status` != 'draft';</span><span id="36a3" class="lb lc in mz b gy nl ne l nf ng">User.findAll({   <br/> include: [{    <br/>  model: Post,     <br/>  where: { <br/>   <!-- -->status<!-- -->: { <br/>    [Op.ne]: '<!-- -->draft<!-- -->' <br/>   } <br/>  },     <br/>  required: false     <br/>  right: true // will create a right join   <br/> }] <br/>});</span></pre><p id="bd65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Sequelize自动将“必需”选项设置为“真”。这意味着执行的不是“外部连接”,而是“内部连接”,只返回至少有一个匹配子模型的父模型。还要注意，所使用的where选项被转换为内部连接的on子句的条件。</p><p id="082a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个表包含同一个父表的两个外键，则可以定义与别名的关联。并且在包含模型时使用相同的别名。</p><p id="77d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样，这是Sequelize中关联如何工作的基础。你可以在官方文档<a class="ae kt" href="https://sequelize.org/master/manual/assocs.html" rel="noopener ugc nofollow" target="_blank"> <em class="mw">这里</em> </a>了解更多。</p><p id="22a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mw">感谢阅读。</em>T24】</strong></p><p id="ae9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mw">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a></p></div></div>    
</body>
</html>