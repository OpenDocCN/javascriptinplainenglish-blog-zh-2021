<html>
<head>
<title>Build a Blockchain REST Server with Node.js, TypeScript, and Hyperledger Iroha</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js、TypeScript、Hyperledger Iroha搭建一个区块链REST服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-blockchain-rest-server-with-hyperledger-iroha-using-nodejs-and-typescript-bef3f483c191?source=collection_archive---------4-----------------------#2021-05-18">https://javascript.plainenglish.io/build-a-blockchain-rest-server-with-hyperledger-iroha-using-nodejs-and-typescript-bef3f483c191?source=collection_archive---------4-----------------------#2021-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/8fea719397d7c1dabd8ffd6919cf60ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*Od7IdmHyGe1AEWhOTgex8g.png"/></div></figure><p id="5eb8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在当前的空间里，区块链正变得风靡一时。我觉得区块链真正的魅力来自于将区块链应用到不同的行业和领域所带来的众多可能性。</p><p id="bf62" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Hyperledger Foundation一直在创建一个平台，其中包括一系列开源工具、库和服务，以帮助构建可扩展的有形区块链解决方案，尤其是在企业领域。</p><p id="6745" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在本教程中，我们将了解区块链框架Hyperledger Iroha，它自称为:</p><blockquote class="kp kq kr"><p id="6f01" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated">…一个简单的区块链平台，您可以使用它来创建可信、安全和快速的应用程序，方法是将基于权限的区块链的力量与崩溃容错共识结合起来——Hyperledger Iroha文档(【https://iroha.readthedocs.io/en/main/】T4)</p></blockquote><p id="70d6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们将使用Node.js、TypeScript和一个名为<strong class="jt io"> iroha-helpers </strong>的特殊npm库构建一个REST服务器，以便与iroha区块链平台进行交互。</p><p id="8771" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您想在阅读本教程之前先看看代码，可以在下面找到这个库:</p><div class="kx ky gp gr kz la"><a href="https://github.com/dominic-pa/iroha-rest-server" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd io gy z fp lf fr fs lg fu fw im bi translated">dominic-pa/iroha-rest-server</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">与Hyperledger Iroha区块链平台交互的REST服务器。该REST服务器使用TypeScript构建，用于…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jp la"/></div></div></a></div><h1 id="5332" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">先决条件</strong></h1><p id="8219" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">首先，您应该能够在本地机器上安装Iroha区块链平台。我用的是Mac OS X，运行的是Mojave。</p><p id="05f5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要设置Iroha，您可以遵循其文档中的快速入门指南:<a class="ae kw" href="https://iroha.readthedocs.io/en/main/getting_started/index.html" rel="noopener ugc nofollow" target="_blank">https://Iroha . readthedocs . io/en/main/getting _ started/index . html</a></p><p id="b885" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你应该在你的机器上安装Docker。您还应该安装Node.js，以便我们开始编写代码。</p><p id="65da" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果在阅读入门指南时没有发现任何问题，那么现在应该有两个docker容器在运行:一个用于运行PostgreSQL数据库，另一个用于运行Iroha守护进程服务。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ms"><img src="../Images/da2376cbb1823b197cf1fd43f5c9649c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0yqEtlt5YmwHYwaBMltwA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">List the running docker containers</figcaption></figure><h1 id="a44a" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 1。</strong>设置我们的项目</h1><p id="536b" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我们将初始化一个新的TypeScript项目来编写我们的Node.js REST服务器，以便与我们正在运行的Iroha区块链网络进行交互。</p><p id="1c1a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以下是设置新项目的命令:</p><p id="d312" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">npm init</code> : <strong class="jt io"> </strong>创建新项目</p><p id="1169" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">npm install typescript</code>:安装打字稿</p><p id="0390" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">npx tsc - -init</code>:通过创建tsconfig.json创建TypeScript项目</p><p id="8752" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">npm install express @types/express</code>:安装Express framework的类型脚本定义</p><h1 id="ec56" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">2.安装依赖项</h1><p id="5c2c" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">Hyperledger Iroha服务正在运行一个守护程序，可以通过gRPC协议发送消息与之交互。我们可以构建一个gRPC客户端来直接与Iroha进行交互，但是Hyperledger Iroha背后的团队已经提供了一个客户端库来与它进行交互，该库名为<strong class="jt io"> iroha-helpers </strong>，使用多种语言。我们将使用JavaScript客户端库来帮助我们与Iroha区块链服务进行交互。</p><p id="57c8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这个例子中，你会看到，我实际上使用的是importing<strong class="jt io">iroha-helpers-ts</strong>，它本质上是一个克隆的<strong class="jt io"> iroha-helpers </strong>库，但是我添加了一些日志，还稍微编辑了响应(如果事务成功提交，就返回散列)。使用原始库就可以了，或者您可以使用这个编辑过的版本。</p><p id="118b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">npm install iroha-helpers-ts</code></p><p id="6baf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">除了这个库之外，我们还将导入一些其他的库，这是使用iroha-helpers库所必需的，因为它使用gRPC协议来发送/接收请求:</p><p id="03ab" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">grpc</code></p><p id="dc3c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">@improbable-eng/grpc-web-node-http-transport</code></p><h1 id="a7a6" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">3.构建我们的知识库</h1><p id="4927" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">现在，我们将花一些时间来设置我们的存储库的结构。这将有助于我们在开发代码时保持组织性。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nj"><img src="../Images/2d066900f45ba28c37e7eb56bcff8078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHaG8rbeQvwSL4MbEr1qnQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Repository folder structure</figcaption></figure><p id="7328" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">配置— </strong>与配置REST服务器相关的设置，以便连接到Iroha区块链服务</p><p id="2b5e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">控制器— </strong>接受特定路线的请求，并调用适当的服务</p><p id="68bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">拦截器— </strong>在每个请求之前运行的代码(我们在这里没有开发任何东西，但是拥有它通常是很好的实践)</p><p id="8490" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">接口— </strong>保存服务中使用的各种数据模型</p><p id="93af" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">路由器— </strong>定义每个控制器使用的基本路由</p><p id="ec16" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">服务— </strong>保存我们所有的业务逻辑，在本例中，是完成向Iroha后端发送请求的逻辑</p><p id="ace5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">实用程序— </strong>实用程序功能有助于整个服务中的数据处理</p><p id="358d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">既然我们已经有了如何构建我们的存储库的想法，让我们开始定义我们的控制器来接收客户端发送的请求。</p><h1 id="0547" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 4。编写我们的控制器</strong></h1><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nk"><img src="../Images/84b11ef0b1b434d4d9e7dcc61a216a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUBjOw9SdTJDf9SamURZLQ.png"/></div></div></figure><p id="0e67" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里，我们正在创建一个新的控制器，名为<strong class="jt io"> DomainController。</strong>这将负责获取对<strong class="jt io"> /createDomain </strong> API调用的请求，并将其路由到Iroha命令服务方法<strong class="jt io"> createDomain </strong>。</p><p id="825c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">编写控制器文件时，主要关注的是确保我们定义了正确的路由来处理请求，调用适当的服务来进一步服务请求，然后根据服务的响应向客户端返回适当的HTTP状态代码。</p><p id="f6fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里的大部分魔法发生在服务文件中，但是在查看服务之前，让我们先看看我们需要使用的配置。</p><h1 id="4e80" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 5。编写我们的配置</strong></h1><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nl"><img src="../Images/dd48708076d077231c258e0f379e2104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps0l3tIVrwQ9jzsNz6erOw.png"/></div></div></figure><p id="6cde" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这个文件中，我们定义了一堆常量。这些常量充当连接到Iroha服务的配置:</p><p id="d226" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> IROHA_PEER_ADDR — </strong>运行IROHA服务的地址。</p><p id="0e3c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> IROHA_DEFAULT_PRIM_KEY — </strong>这是IROHA在快速入门中设置的默认主键。如果更改，此密钥可以替换任何适当的密钥。</p><p id="f48e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> IROHA_ACCOUNT_ID_HEADER，IROHA_ACCOUNT_KEY_HEADER — </strong>这些是请求头名称，其值用于签署请求中创建并发送给IROHA的事务。</p><p id="b8cc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> IROHA_QUERY_SERVICE_TIMEOUT，IROHA _ COMMAND _ SERVICE _ time out—</strong>发送到IROHA的查询和命令的超时值。</p><p id="397d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">IROHA _ COMMAND _ DEFAULT _ QUORUM—</strong>提交给区块链的交易所需的签名数量。</p><p id="2397" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，在编写服务逻辑时，我们可以看到这些是如何使用的。</p><h1 id="360d" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 6。编写我们的服务</strong></h1><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nm"><img src="../Images/ef18cc9cdf2eb8414266136c5360058b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVYwo2rgMfSdIfJi25tjRw.png"/></div></div></figure><p id="1ca6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里，我们使用iroha-helpers库来帮助我们与它进行交互。</p><p id="b531" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这很大程度上直接来自库的文档(<a class="ae kw" href="https://www.npmjs.com/package/iroha-helpers" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/iroha-helpers</a>)，但本质上，我们在这里所做的是为将要发送的命令消息(COMMAND_OPTIONS)定义参数，并创建和初始化一个新的命令服务。</p><p id="765a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我们可以为这个IrohaCommandService创建一个方法，该方法使用适当的命令选项向Iroha服务发送创建域请求。</p><h1 id="f671" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 7。编写我们的路由器</strong></h1><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nn"><img src="../Images/ad04045dd55ad43c38a85a09bee5ccce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELkbhPwb13gGQtP_eFiP0g.png"/></div></div></figure><p id="16e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们使用路由器为所有控制器定义基本路由。然后，我们将路由连接并配置到相应的控制器。</p><p id="93a9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">采用我们在<strong class="jt io"> DomainController、</strong>中定义的路由部分，并采用我们的路由器文件中定义的基本路由，我们的API调用创建域的路由当前应该是:<strong class="jt io"> /domain/createDomain </strong>。要查看完整的路线，并了解服务器最终是如何启动的，我们将查看<strong class="jt io"> app.ts </strong>文件。</p><h1 id="27b9" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">8.启动我们的服务器</h1><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi no"><img src="../Images/996ee23dd08a88cf67dd68388809f639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOcypDDho5yXdfU2Gn_C6g.png"/></div></div></figure><p id="f869" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了让服务器运行，我们将配置我们的基本express服务器。</p><p id="553f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这个文件中，你会发现我们配置我们的服务器使用<strong class="jt io">摩根，</strong>，这只是一个npm库，有助于彩色编码日志。</p><p id="df13" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们配置我们的服务器来接收和返回JSON内容类型。</p><p id="a90f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们为这个服务器配置基本路由，从<strong class="jt io"> /api/v1开始。</strong>我们还将服务器配置为在端口5000上运行(如果未设置环境变量port ),那么现在，按照API调用创建域的路由示例，我们将得到:</p><p id="4d83" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kw" href="http://localhost:5000/api/v1/domain/createDomain" rel="noopener ugc nofollow" target="_blank">T7】http://localhost:5000/API/v1/domain/create domainT9】</a></p><p id="42ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要现在运行服务器，我们可以运行命令:</p><p id="e720" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b"><em class="ks">npm run dev</em></code></p><p id="42b1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它是在我们的package.json文件中配置的，运行以下命令:</p><p id="f423" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe nf ng nh ni b">LOG_LEVEL=debug nodemon src/app.ts | ./node_modules/.bin/pino-pretty”</code></p><p id="0666" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们使用<strong class="jt io"> pino </strong>来帮助记录我们的请求，使用<strong class="jt io"> nodemon </strong>来让我们的服务器在我们修改代码时自动重启。</p><p id="0e99" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果运行成功，您应该会看到终端打印出以下内容:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi np"><img src="../Images/3511b97c3509dde7812ec2bf473420de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vM5hOJZUTmNj7FRNXEIRfQ.png"/></div></div></figure><p id="b24d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">至此，我们已经完成了REST服务器与Hyperledger Iroha交互的代码！</strong></p><h1 id="a99a" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">9.测试我们的REST服务器</h1><p id="e074" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">现在，我们可以测试我们的REST服务器，看看它是否如我们预期的那样工作。</p><p id="4d4f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当然，您可以从命令行使用一个基本的curl命令，但是使用<strong class="jt io"> Postman </strong>测试API要容易得多。我创建了一个swagger文件，它定义了我们在这里创建的路线。因此，您可以将这个文件导入到Postman中，您将获得一个定义服务中可用的所有路由的文件。</p><p id="1973" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了测试请求，我们设置了适当的头，以便事务可以由正确的事务创建者签名。并在请求中发送适当的主体。请确保这是一个POST请求。如果它能够成功连接到Iroha，您应该得到一个响应，要么说事务被提交到Iroha区块链网络，要么说一个错误，为什么事务没有被提交(拒绝，状态验证失败，等等。)</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nq"><img src="../Images/5e73f8a494e4b3e9c081ad984178fe00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeK8K98T2EDQdlTvmMSLBg.png"/></div></div></figure><p id="95b2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您还可以将相同的swagger文档粘贴到editor.swagger.io上，以查看所有可用的API、示例请求和响应等。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nq"><img src="../Images/82cdd2e98fdca52413ed62d4ac6cd638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGjswUf-paondm_Dvk3gFg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">The swagger file on editor.swagger.io</figcaption></figure><h1 id="a298" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="7193" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我们的教程到此结束。我们能够创建一个整洁的小型REST服务器，它接受我们的HTTP、JSON请求，并使用gRPC消息通过<strong class="jt io"> iroha-helpers </strong>库向Iroha发送适当的请求。</p><p id="1c67" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以访问此处的代码以进一步了解、派生项目并对其进行更改，或者如果您已经在使用Hyperledger Iroha，则按原样使用并试用它。</p><div class="kx ky gp gr kz la"><a href="https://github.com/dominic-pa/iroha-rest-server" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd io gy z fp lf fr fs lg fu fw im bi translated">dominic-pa/iroha-rest-server</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">与Hyperledger Iroha区块链平台交互的REST服务器。该REST服务器使用TypeScript构建，用于…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jp la"/></div></div></a></div><p id="80ae" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望你喜欢这个指南！</p><p id="3f81" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="ks">更多内容看</em><a class="ae kw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="ks">plain English . io</em></strong></a></p></div></div>    
</body>
</html>