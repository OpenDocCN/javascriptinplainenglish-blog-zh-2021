<html>
<head>
<title>How to Manage Multiple Threads in Node JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何管理Node JS中的多线程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/managing-multiple-threads-in-node-js-9ebc374d2f68?source=collection_archive---------7-----------------------#2021-03-31">https://javascript.plainenglish.io/managing-multiple-threads-in-node-js-9ebc374d2f68?source=collection_archive---------7-----------------------#2021-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0b24ec3da4c07a4413d0093c8bbcde67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNwXw3G65kb1SfYEs9zXeg.jpeg"/></div></div></figure><p id="730c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将向你展示如何通过管理多线程来潜在地将你的<a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>应用的性能提高三倍。这是一个重要的教程，其中显示的方法和示例将为您提供设置生产就绪线程管理所需的内容。</p><h1 id="f49e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">请观看下面这篇文章的视频:</h1><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="e9b3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">子进程、集群和工作线程</h1><p id="54e7" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在很长一段时间里，Node拥有多线程的能力，通过使用<a class="ae kw" href="https://nodejs.org/dist/latest-v14.x/docs/api/child_process.html" rel="noopener ugc nofollow" target="_blank">子进程</a>、<a class="ae kw" href="https://nodejs.org/dist/latest-v14.x/docs/api/cluster.html" rel="noopener ugc nofollow" target="_blank">集群</a>，或者更近期的一个叫做<a class="ae kw" href="https://nodejs.org/dist/latest-v14.x/docs/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">工作线程</a>的模块的首选方法。</p><p id="951d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">子进程是为应用程序创建多线程的最初方式，从0.10版开始就已经存在。这是通过为您想要创建的每个额外线程生成一个节点进程来实现的。</p><p id="9e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">集群，从版本4开始就是一个稳定的版本，允许我们简化子进程的创建和管理。当与PM2结合时，它工作得非常出色。</p><p id="c1a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们开始对我们的应用进行多线程处理之前，有几点您需要完全理解:</p><p id="c30a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。I/O任务的多线程已经存在</strong></p><p id="7352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一层节点已经是多线程的，那就是<a class="ae kw" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> libuv </a>线程池。文件和文件夹管理、TCP/UDP事务、压缩和加密等I/O任务都交给libuv，如果本质上不是异步的，就在libuv的线程池中处理。</p><p id="039f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。子进程/工作线程仅适用于同步JavaScript逻辑</strong></p><p id="7930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用子进程或工作线程实现多线程仅对执行繁重操作(如循环、计算等)的同步JavaScript代码有效。例如，如果您尝试将I/O任务卸载到工作线程，您将不会看到性能的提高。</p><p id="7e84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。创建一个线程很容易。动态管理多线程很难</strong></p><p id="17f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的应用程序中创建一个额外的线程是很容易的，因为有大量的教程教你如何做。然而，创建与您的机器或虚拟机正在运行的逻辑核心数量相当的线程，并管理这些线程的工作分配是一种更高级的方式，并且编写这种逻辑超出了我们的大多数工资级别😎。</p><p id="0f76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢天谢地，我们处在一个开源和Node社区杰出贡献的世界里。也就是说，已经有一个模块可以让我们根据机器或虚拟机的CPU可用性动态创建和管理线程。</p><h1 id="d74e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工人池</h1><p id="8161" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们今天要学习的模块叫做<a class="ae kw" href="https://github.com/josdejong/workerpool" rel="noopener ugc nofollow" target="_blank">工人池</a>。由<a class="ae kw" href="http://josdejong.com/" rel="noopener ugc nofollow" target="_blank"> Jos de Jong </a>创建的Worker Pool提供了一种简单的方法来创建一个工人池，用于动态卸载计算以及管理一个专用工人池。它基本上是Node JS的线程池管理器，支持基于浏览器的实现的工作线程、子进程和Web工作线程。</p><p id="6ca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在我们的应用程序中使用Worker Pool模块，需要执行以下任务:</p><ul class=""><li id="f59b" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">安装工人池</strong></li></ul><p id="d5a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要安装工人池模块— npm安装工人池</p><ul class=""><li id="ab69" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">初始化工人池</strong></li></ul><p id="bc3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要在应用程序启动时初始化工人池</p><ul class=""><li id="b93a" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">创建中间件层</strong></li></ul><p id="fc09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要在我们的重载JavaScript逻辑和管理它的工作池之间创建一个中间件层</p><ul class=""><li id="15c8" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">更新现有逻辑</strong></li></ul><p id="0636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要更新我们的应用程序，以便在需要时将繁重的任务移交给工人池</p><h1 id="8ff2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用工作池管理多线程</h1><p id="8b31" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">此时，你有两个选择:使用自己的NodeJS app(并安装<a class="ae kw" href="https://www.npmjs.com/package/workerpool" rel="noopener ugc nofollow" target="_blank"> workerpool </a>和<a class="ae kw" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> bcryptjs </a>模块)，或者从GitHub下载<a class="ae kw" href="https://github.com/bleedingcode/nodejs-performance-optimizations" rel="noopener ugc nofollow" target="_blank">源代码</a>用于本教程和我的<a class="ae kw" href="https://www.youtube.com/watch?v=ol56smloW2Q&amp;list=PLISqeoHsXJYAIfu4-mgNY0tloWz2uut1t" rel="noopener ugc nofollow" target="_blank"> NodeJS性能优化</a>视频系列。</p><p id="8bd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果选择后者，本教程的文件将存在于文件夹<strong class="ka ir">06-多线程</strong>中。下载后，进入根项目文件夹并运行npm install。之后，进入<strong class="ka ir">06-多线程</strong>文件夹跟随。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/89f29393cb9d3e00cfe9a84719e98bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*kDqukAU8oni4KuYj4fnkWw.png"/></div></figure><p id="9bfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> worker-pool </strong>文件夹中，我们有2个文件:一个是worker池的控制器逻辑(controller.js)。另一个包含将由线程触发的功能，也就是我前面提到的中间件层(thread-functions.js)。</p><h2 id="9ced" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">worker-pool/controller.js</h2><pre class="lv lw lx ly gt nc nd ne nf aw ng bi"><span id="7334" class="mq ky iq nd b gy nh ni l nj nk">'use strict'<br/><br/>const WorkerPool = require('workerpool')<br/>const Path = require('path')<br/><br/>let poolProxy = null<br/><br/>// FUNCTIONS<br/>const init = async (options) =&gt; {<br/>  const pool = WorkerPool.pool(Path.join(__dirname, './thread-functions.js'), options)<br/>  poolProxy = await pool.proxy()<br/>  console.log(`Worker Threads Enabled - Min Workers: ${pool.minWorkers} - Max Workers: ${pool.maxWorkers} - Worker Type: ${pool.workerType}`)<br/>}<br/><br/>const get = () =&gt; {<br/>  return poolProxy<br/>}<br/><br/>// EXPORTS<br/>exports.init = init<br/>exports.get = get</span></pre><p id="bfa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">controller.js是我们需要<strong class="ka ir"> workerpool </strong>模块的地方。我们还导出了两个函数，分别叫做<strong class="ka ir"> init </strong>和<strong class="ka ir"> get </strong>。在加载我们的应用程序期间，将执行一次<strong class="ka ir"> init </strong>函数。它用我们将提供的选项和对<strong class="ka ir"> thread-functions.js </strong>的引用实例化了工人池。它还创建了一个代理，只要我们的应用程序在运行，这个代理就会一直保存在内存中。<strong class="ka ir"> get </strong>函数只是返回内存中的代理。</p><h2 id="c81c" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">worker-pool/线程-函数. js</h2><pre class="lv lw lx ly gt nc nd ne nf aw ng bi"><span id="1e88" class="mq ky iq nd b gy nh ni l nj nk">'use strict'<br/><br/>const WorkerPool = require('workerpool')<br/>const Utilities = require('../2-utilities')<br/><br/>// MIDDLEWARE FUNCTIONS<br/>const bcryptHash = (password) =&gt; {<br/>  return Utilities.bcryptHash(password)<br/>}<br/><br/>// CREATE WORKERS<br/>WorkerPool.worker({<br/>  bcryptHash<br/>})</span></pre><p id="cc2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> thread-functions.js </strong>文件中，我们创建了将由工人池管理的工人函数。对于我们的例子，我们将使用<strong class="ka ir"> BcryptJS </strong>来散列密码。这通常需要大约10毫秒来运行，这取决于一个人的机器的速度，并且当涉及到重型任务时，这是一个很好的用例。在<strong class="ka ir"> utilities.js </strong>文件中是散列密码的函数和逻辑。我们在线程函数中所做的就是通过workerpool函数执行这个<strong class="ka ir"> bcryptHash </strong>。这允许我们保持代码集中，避免重复或混淆某些操作存在的位置。</p><h2 id="b140" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">2-utilities.js</h2><pre class="lv lw lx ly gt nc nd ne nf aw ng bi"><span id="9ba2" class="mq ky iq nd b gy nh ni l nj nk">'use strict'<br/><br/>const BCrypt = require('bcryptjs')<br/><br/>const bcryptHash = async (password) =&gt; {<br/>  return await BCrypt.hash(password, 8)<br/>}<br/><br/>exports.bcryptHash = bcryptHash</span></pre><h2 id="e8cd" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">。包封/包围（动词envelop的简写）</h2><pre class="lv lw lx ly gt nc nd ne nf aw ng bi"><span id="b038" class="mq ky iq nd b gy nh ni l nj nk">NODE_ENV="production"<br/>PORT=6000<br/>WORKER_POOL_ENABLED="1"</span></pre><p id="8348" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">的。env文件保存端口号，并将<strong class="ka ir"> NODE_ENV </strong>变量设置为“生产”。这也是我们通过将<strong class="ka ir"> WORKER_POOL_ENABLED </strong>设置为“1”或“0”来指定是否要启用或禁用工作池的地方。</p><h2 id="88e3" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">1-app.js</h2><pre class="lv lw lx ly gt nc nd ne nf aw ng bi"><span id="8d4e" class="mq ky iq nd b gy nh ni l nj nk">'use strict'<br/><br/>require('dotenv').config()<br/><br/>const Express = require('express')<br/>const App = Express()<br/>const HTTP = require('http')<br/>const Utilities = require('./2-utilities')<br/>const WorkerCon = require('./worker-pool/controller')<br/><br/>// Router Setup<br/>App.get('/bcrypt', async (req, res) =&gt; {<br/>  const password = 'This is a long password'<br/>  let result = null<br/>  let workerPool = null<br/><br/>  if (process.env.WORKER_POOL_ENABLED === '1') {<br/>    workerPool = WorkerCon.get()<br/>    result = await workerPool.bcryptHash(password)<br/>  } else {<br/>    result = await Utilities.bcryptHash(password)<br/>  }<br/><br/>  res.send(result)<br/>})<br/><br/>// Server Setup<br/>const port = process.env.PORT<br/>const server = HTTP.createServer(App)<br/><br/>;(async () =&gt; {<br/>  // Init Worker Pool<br/>  if (process.env.WORKER_POOL_ENABLED === '1') {<br/>    const options = { minWorkers: 'max' }<br/>    await WorkerCon.init(options)<br/>  }<br/><br/>  // Start Server<br/>  server.listen(port, () =&gt; {<br/>    console.log('NodeJS Performance Optimizations listening on: ', port)<br/>  })<br/>})()</span></pre><p id="02ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的<strong class="ka ir"> 1-app.js </strong>保存了将在我们的应用程序启动时执行的代码。首先我们初始化<strong class="ka ir">中的变量。env </strong>文件。然后，我们设置一个<a class="ae kw" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>服务器，并创建一个名为<strong class="ka ir"> /bcrypt </strong>的路由。当此路由被触发时，我们将检查工作池是否已启用。如果是，我们在Worker Pool代理上获得一个句柄，并执行我们在<strong class="ka ir"> thread-functions.js </strong>文件中声明的<strong class="ka ir"> bcryptHash </strong>函数。这将依次执行<strong class="ka ir">实用程序</strong>中的<strong class="ka ir"> bcryptHash </strong>函数，并将结果返回给我们。如果工人池被禁用，我们只需直接在<strong class="ka ir">实用程序</strong>中执行<strong class="ka ir"> bcryptHash </strong>函数。</p><p id="01f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们<strong class="ka ir"> 1-app.js </strong>的底部，你会看到我们有一个自我调用功能。我们这样做是为了支持async/await，这是我们在与Worker池交互时使用的。如果启用了工作池，我们就在这里初始化它。我们想要覆盖的唯一配置是将<strong class="ka ir"> minWorkers </strong>设置为“最大”。这将确保工作线程池将生成与我们机器上的逻辑核心一样多的线程，只有一个逻辑核心除外，它用于我们的主线程。在我的例子中，我有6个支持超线程的物理内核，这意味着我有12个逻辑内核。因此，当<strong class="ka ir"> minWorkers </strong>设置为“max”时，工作线程池将创建并管理11个线程。最后，最后一段代码是我们启动服务器并监听端口6000的地方。</p><h1 id="3f10" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试工作池</h1><p id="942e" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">测试工作池就像启动应用程序一样简单，在它运行时，向<code class="fe nl nm nn nd b">http://localhost:6000/bcrypt</code>执行一个get请求。如果你有一个像<a class="ae kw" href="https://www.npmjs.com/package/autocannon" rel="noopener ugc nofollow" target="_blank">auto canon</a>这样的负载测试工具，当工作池被启用/禁用时，你可以看到性能的不同。AutoCannon非常容易使用。</p><h1 id="eb8c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="96f7" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我希望本教程能够让您深入了解如何在节点应用程序中管理多线程。本文顶部的嵌入式视频提供了测试Node应用程序的现场演示。</p><p id="995a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下次见，干杯:)</p></div></div>    
</body>
</html>