<html>
<head>
<title>JavaScript 2021: New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 2021:新特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-2021-new-features-429bc050f4e8?source=collection_archive---------0-----------------------#2021-05-24">https://javascript.plainenglish.io/javascript-2021-new-features-429bc050f4e8?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6c5d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">今天，我们将讨论JavasScript的一些非常有用的新特性，它们可以帮助我们通过编写更少的代码来实现更多的功能。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/51d6d0642df8b4b12614712ec5550d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eb40xJDoXqs8wYI3"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fae3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是一种简单易学的编程语言，适合初学者。这些年来，它进化得如此之快，几乎无处不在。我们在前端(React，Angular，或者Vue.js)，后端(Node.js)，用ElectronJS创建桌面应用等都见过。</p><p id="e5b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript在2021年提供了一些新特性，这在很多方面帮助了开发者。2021年JavaScript的一些新特性是:</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="2dd3" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">1)新的逻辑运算符</h2><p id="6bd3" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">JavaScript向现有集合中添加了三个新的逻辑运算符。这三个运算符是，I) <code class="fe mu mv mw mx b">&amp;&amp;=</code>，II) <code class="fe mu mv mw mx b">||=</code>，&amp; III) <code class="fe mu mv mw mx b">??=</code>。让我们详细讨论这些运算符:</p><p id="79c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> a) </strong> <code class="fe mu mv mw mx b"><strong class="kv io">&amp;&amp;=</strong></code> <strong class="kv io">操作员:</strong></p><p id="99ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在深入解释之前，先看一下下面给出的示例代码:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="e816" class="lw lx in mx b gy nc nd l ne nf">let a = 1;<br/>let b = 2;<br/>a &amp;&amp;= b;<br/>console.log(a) // output for variable 'a' would be 2.</span></pre><p id="8e2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">行<code class="fe mu mv mw mx b">a&amp;&amp;= b</code>类似于下面给出的代码块:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="f65f" class="lw lx in mx b gy nc nd l ne nf">if(a) {<br/>  a = b;<br/>}</span></pre><p id="031c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个逻辑运算符是说，如果变量<code class="fe mu mv mw mx b">a</code>有真值(因为它保存了一个非零值)，那么变量<code class="fe mu mv mw mx b">a</code>应该被赋予变量<code class="fe mu mv mw mx b">b</code>的值。这就是为什么当我们做<code class="fe mu mv mw mx b">console.log(a)</code>时，变量<code class="fe mu mv mw mx b">a</code>的值计算为2而不是1。</p><p id="936b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> b) </strong> <code class="fe mu mv mw mx b"><strong class="kv io">||=</strong></code> <strong class="kv io">运算符:</strong></p><p id="6583" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑下面给出的代码块:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="5daf" class="lw lx in mx b gy nc nd l ne nf">let a = 1;<br/>let b = 2;<br/>a ||= b;<br/>console.log(b); // output for variable 'a' would be 1.</span></pre><p id="e2fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该操作符与<code class="fe mu mv mw mx b">&amp;&amp;=</code>操作符相反。在这种情况下，变量<code class="fe mu mv mw mx b">a</code>将仅等于变量<code class="fe mu mv mw mx b">b</code>，且仅当变量<code class="fe mu mv mw mx b">a</code>具有假值时。上面的代码块等效于下面给出的代码:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="a32d" class="lw lx in mx b gy nc nd l ne nf">if (!a) {<br/>  a = b;<br/>}</span></pre><p id="801e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> c) </strong> <code class="fe mu mv mw mx b"><strong class="kv io">??=</strong></code> <strong class="kv io">运算符:</strong></p><p id="4ca3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该操作符检查一个值是<strong class="kv io">空</strong>还是<strong class="kv io">未定义</strong>。考虑下面的例子:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="52aa" class="lw lx in mx b gy nc nd l ne nf">let a;<br/>let b = 2;<br/>a ??= 1;<br/>console.log(a) // output for variable 'a' would be 1.</span><span id="a82c" class="lw lx in mx b gy ng nd l ne nf">// this code block is similar to the code given above.<br/>// if(a === null || a === undefined) {<br/>//   a = 1<br/>// }</span></pre><p id="d731" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在给出的例子中，变量“a”的值评估为<strong class="kv io">未定义的</strong>，因此<code class="fe mu mv mw mx b">if</code>条件评估为<code class="fe mu mv mw mx b">true</code>，并且“a”被赋值为1。</p><h2 id="7ea8" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">2)字符串“replaceAll”方法</h2><p id="65e9" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我们都曾使用string <code class="fe mu mv mw mx b">replace</code>方法用我们指定的元素替换字符串中的一个字符或单词。但是它有一个限制，这个方法只替换我们想要替换的字符或单词的第一次出现，字符串中其余的出现保持不变。要替换所有的字符或单词，我们必须使用正则表达式。</p><p id="974b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="fd07" class="lw lx in mx b gy nc nd l ne nf">// without regex<br/>let str = 'JS is everywhere. JS is amazing!';<br/>console.log(str.replace('JS', 'JavaScript')); // the output would be 'JavaScript is everywhere. JS is amazing!'</span><span id="ff2c" class="lw lx in mx b gy ng nd l ne nf">// with regex<br/>let str = 'JS is everywhere. JS is amazing!';<br/>console.log(str.replace(/JS/g, 'JavaScript')); // the output would be 'JavaScript is everywhere. JavaScript is amazing!'.</span></pre><p id="6287" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe mu mv mw mx b">replaceAll</code>方法，不再需要正则表达式。考虑下面的代码:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="2e0f" class="lw lx in mx b gy nc nd l ne nf">let str = 'JS is everywhere. JS is amazing!';<br/>console.log(str.replaceAll('JS', 'JavaScript')); // the output would be 'JavaScript is everywhere. JavaScript is amazing!'.</span></pre><p id="bb85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">方法<code class="fe mu mv mw mx b">replaceAll</code>用我们指定的元素替换所有出现的指定字符或单词。</p><h2 id="6521" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">3)使用下划线作为整数的分隔符</h2><p id="f5b2" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">整数是字符串、数组等数据类型中的一种。有时，整数变得如此之大，以至于几乎很难计算存在的元素的数量，或者计算出这个数字是一百万还是十亿。</p><p id="1b91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过引入这个特性，我们可以提高整数的可读性。我们可以使用下划线来分隔数字，而无需将数据类型转换为字符串。示例:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="bb70" class="lw lx in mx b gy nc nd l ne nf">let number = 1_000_000_000; // one billion<br/>console.log(number) // 1000000000 (the number would remain an integer)</span></pre><h2 id="d279" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">4) 'Promise.any()'</h2><p id="2f5e" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">如果你不知道什么是<code class="fe mu mv mw mx b">promises</code> JavaScript，那你就先看这里的<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1c8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mu mv mw mx b">Promise.any()</code>是一个新特性，它接受几个可重复的承诺，并返回最先实现的承诺。一个例子会让你明白:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="8eee" class="lw lx in mx b gy nc nd l ne nf">const p1 = new Promise(resolve =&gt; setTimeout(resolve, 500, 'First'));<br/>const p2 = new Promise(resolve =&gt; setTimeout(resolve, 800, 'Second'));<br/>const p3 = Promsie.reject(1);</span><span id="c251" class="lw lx in mx b gy ng nd l ne nf">const promises = [p1, p2, p3];</span><span id="aee3" class="lw lx in mx b gy ng nd l ne nf">Promise.any(promises)<br/>.then(result =&gt; {<br/>   console.log(result);<br/>}) // the result would be 'First' because that's the promise, that is fulfilled first.<br/>.catch(e =&gt; {<br/>    console.log(e);<br/>})</span></pre><p id="186d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">万一没有一个承诺实现，那么我们将得到一个<code class="fe mu mv mw mx b">AggregateError</code>。为了处理<code class="fe mu mv mw mx b">AggregateError</code>，我们将在<code class="fe mu mv mw mx b">then</code>语句之后定义一个<code class="fe mu mv mw mx b">catch</code>语句。如果你不知道<code class="fe mu mv mw mx b">then</code> &amp; <code class="fe mu mv mw mx b">catch</code>块是什么，可以在这里了解一下<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="82ec" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">5)弱引用和终结符</h2><p id="b9f5" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated"><code class="fe mu mv mw mx b">WeakRef</code>是‘弱引用’的简称。<code class="fe mu mv mw mx b">WeakRef</code>允许持有一个对象的弱引用。被持有的弱引用被称为“目标”。弱引用不会阻止垃圾收集器回收该对象。</p><p id="0d78" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">垃圾收集是一种收集不再需要的变量的方法，因此可以释放计算机的内存。要了解有关垃圾收集的更多信息，请单击此处的链接<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a461" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="nh">注意:</em> </strong> <code class="fe mu mv mw mx b"><em class="nh">WeakRef</em></code> <em class="nh">只应在特定情况下使用，尽可能避免使用。</em></p><p id="a8fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面我们通过一个例子来理解:</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="8fab" class="lw lx in mx b gy nc nd l ne nf">const weakRefFunc = () =&gt; {<br/>    const obj = new WeakRef({<br/>       name: 'JavaScript'<br/>    });<br/>    console.log(obj.deref().name);<br/>}<br/>const test = () =&gt; {<br/>    new Promise(resolve =&gt; {<br/>     setTimeout(() =&gt; {<br/>       weakRefFunc();<br/>        resolve();<br/>      }, 3000)<br/>    })<br/>    new Promise(resolve =&gt; {<br/>     setTimeout(() =&gt; {<br/>       weakRefFunc();<br/>        resolve();<br/>      }, 5000)<br/>    })<br/>}<br/>test();</span></pre><p id="48e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mu mv mw mx b">deref</code>方法返回被持有的目标，如果目标被垃圾回收，则返回<strong class="kv io">未定义的</strong>。</p><p id="6679" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，变量<code class="fe mu mv mw mx b">obj</code>是被持有的弱引用。</p><p id="2f27" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一次在<code class="fe mu mv mw mx b">test</code>函数中调用<code class="fe mu mv mw mx b">weakrefFunc</code>时，可以保证‘JavaScript’会被打印出来，但是第二次调用时，不能保证‘JavaScript’会被打印出来，因为变量<code class="fe mu mv mw mx b">obj</code>可能会因为作为弱引用而被垃圾收集。</p><p id="bb2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">最终确定者</strong></p><p id="08b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">终结器通常与<code class="fe mu mv mw mx b">WeakRef</code>一起使用，但也可以单独使用。终结器告知对象何时被垃圾回收。让我们通过一个例子来理解这一点:</p><p id="8b0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">→首先，我们将使用<code class="fe mu mv mw mx b">FinalizationRegistry</code>方法创建一个终结器。</p><pre class="kd ke kf kg gt my mx mz na aw nb bi"><span id="d8a8" class="lw lx in mx b gy nc nd l ne nf">const registerFinalizer = new FinalizationRegistry(data =&gt; console.log(data));</span><span id="65df" class="lw lx in mx b gy ng nd l ne nf">const obj = {'name': 'JavaScript'};<br/>registerFinalizer.register(obj, 'obj is collected now!')</span></pre><p id="497d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，变量<code class="fe mu mv mw mx b">registerFinalizer</code>是一个包含我们将要使用的<code class="fe mu mv mw mx b">register</code>方法的对象。</p><p id="a5d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mu mv mw mx b">registerFinalizer.register</code>带2个参数。第一个是垃圾收集要监视的对象，第二个是当对象被垃圾收集时我们希望显示给控制台的消息。</p><p id="bfc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当变量<code class="fe mu mv mw mx b">obj</code>将被垃圾收集器收集时，会出现一条消息“obj现在被收集了！”会被打印到控制台上。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="8adf" class="ni lx in bd ly nj nk nl mb nm nn no me jt np ju mh jw nq jx mk jz nr ka mn ns bi translated">结论</h1><p id="a580" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">总的来说，JavaScript是一门非常值得学习的语言，其中一个主要原因是它无处不在。我发现上面讨论的这些新特性非常有用。JavaScript 2021的特性非常惊人，我预计明年也会如此。</p><p id="f322" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望你学到了新的东西。如果你喜欢这篇文章，最近我写了一篇关于如何在Google sheets中使用Node.js的文章。你可以在这里看到那个帖子<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-node-js-with-google-sheets-c256c26e10fc"/>。感谢大家抽出时间阅读这篇文章。</p><p id="7626" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nh">更多内容请看</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>