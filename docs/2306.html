<html>
<head>
<title>Demonstrating S.O.L.I.D Principles with JavaScript Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript示例演示S.O.L.I.D原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/s-o-l-d-with-javascript-examples-e8a071345c8a?source=collection_archive---------1-----------------------#2021-05-14">https://javascript.plainenglish.io/s-o-l-d-with-javascript-examples-e8a071345c8a?source=collection_archive---------1-----------------------#2021-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d730cf6b7d42f00ef07fed59034aef99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzwARbvHUg1RlZ7LYyLCrg.png"/></div></div></figure><h1 id="9ca4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">固体原理是什么？</h1><p id="bb8e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在这一部分，我将向你介绍<strong class="kv io">固体</strong>原理。S.O.L.I.D是一个助记首字母缩写词，代表:</p><ul class=""><li id="a803" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="kv io">S</strong></code>——单一责任原则。</li><li id="f50e" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="kv io">O</strong></code> -开闭原理。</li><li id="6c26" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="kv io">L</strong></code>——利斯科夫——替代原理。</li><li id="4bf0" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="kv io">I</strong></code> -界面分离原理。</li><li id="e8a9" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="kv io">D</strong></code><strong class="kv io"/>——依存倒置原则。</li></ul><p id="736b" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">南O.L.I.D，我现在称之为<strong class="kv io"> SOLID </strong>，是面向对象编程中非常流行的一个基本设计原则。每个开发人员都应该理解所有这些原则，因为这对任何软件工程师来说都是一个关键概念。</p><p id="845c" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">所有的设计模式和原则不仅有助于编写好的代码，也有助于编写干净的代码。然而，如果你只是学习其中的两个，那就用<code class="fe mc md me mf b"><strong class="kv io">S</strong></code> -单一责任原则和<code class="fe mc md me mf b"><strong class="kv io">O</strong></code> -开闭原则。SOLID可能是使用最广泛的原则，也是构建健壮和可维护软件最有效的原则。</p><p id="0380" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">好了，现在你已经知道了什么是坚实的原则，让我们开始学习它们。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="7017" class="jv jw in bd jx jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks bi translated">单一责任原则</h1><p id="7df1" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">本节将介绍单一责任原则或简称为<strong class="kv io"> SRP </strong>。SRP适用于类别、组件和微服务。</p><p id="ceda" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">SRP的主要规则是:<em class="na">“类应该有一个</em> <strong class="kv io"> <em class="na">单一责任</em> </strong> <em class="na"> —一个类不应该因为一个以上的原因</em>  <em class="na">而</em> <strong class="kv io"> <em class="na">改变。”</em></strong></p><p id="aaa0" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">SRP允许更小的班级。一个责任意味着当我们遇到新问题时，我们需要调整代码的可能原因更少。</p><p id="af6c" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">让我们来回顾一下我从freecodecamp.org中找到的一个例子:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="0072" class="jv jw in bd jx jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks bi translated">开闭原则</h1><p id="8dbc" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">开闭原则或简称OCP指出:<em class="na">“一个(类、模块、函数等)应</em> <strong class="kv io"> <em class="na">打开</em> </strong> <em class="na">进行扩展而</em> <strong class="kv io"> <em class="na">关闭</em> </strong> <em class="na">进行修改。”</em></p><p id="b811" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">这意味着我们不需要修改我们的代码来让它为进一步的功能工作。每一个类都应该有一个基本的功能集，并针对每一个用例进行精简。</p><p id="c6e0" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">下面我们有一个视频游戏平台的课程。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ba86" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">我们在这里的问题是，一些功能将不得不被修改，以使所有方法在所有平台上工作，这将违反SRP和OCP。这就是我们使用子类的原因。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1c2d" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">这样，我们就不必修改任何类方法来为我们的类引入新的功能。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="f953" class="jv jw in bd jx jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks bi translated">利斯科夫替代原理</h1><p id="b29e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">利斯科夫替代原理指出。</p><p id="b48b" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><em class="na">“对象应该是</em> <strong class="kv io"> <em class="na">用</em> <strong class="kv io"> <em class="na">替换了</em> </strong> <em class="na">的子类的实例而不改变行为</em> </strong> <em class="na">。”</em></p><p id="6095" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">这意味着，如果我们有一个基类，它不应该将方法扩展到不能或不愿接受其父类方法的类。</p><p id="e0c2" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">我在Academind找到了一个很好的例子:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="bb8a" class="jv jw in bd jx jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks bi translated">界面分离原理</h1><p id="fa14" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">接口隔离原则(ISP)规定:</p><p id="8c2a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><em class="na">许多特定于客户端的接口比一个通用接口要好。</em></p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="9c2a" class="jv jw in bd jx jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks bi translated">依存倒置原则</h1><p id="d088" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这个原则的一般思想既简单又重要:提供复杂逻辑的高级模块应该易于重用，并且不受提供实用功能的低级模块的变化的影响。为了实现这一点，您需要引入一个抽象，将高级和低级模块相互分离。</p><p id="a162" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><em class="na">“你应该</em> <strong class="kv io"> <em class="na">依靠抽象，而不是集中。”</em> </strong></p><p id="0515" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">基于这一思想，罗伯特·c·马丁对依存关系倒置原则的定义由两部分组成:</p><ol class=""><li id="a3be" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq nh lz ma mb bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="3e88" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq nh lz ma mb bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li></ol><p id="dcbd" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">这个定义的一个重要细节是，高层<strong class="kv io">和低层</strong>模块依赖于抽象。设计原则不仅仅是改变依赖关系的方向，当你第一次读到它的名字时，你可能已经预料到了。它通过在高级和低级模块之间引入抽象来分离它们之间的依赖关系。所以最后，你会得到两个依赖关系:</p><ol class=""><li id="a0c4" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq nh lz ma mb bi translated">高级模块依赖于抽象，并且</li><li id="8330" class="lr ls in kv b kw mg la mh le mi li mj lm mk lq nh lz ma mb bi translated">底层依赖于相同的抽象。</li></ol><p id="4a9c" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><em class="na">更多内容请看</em><a class="ae ni" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="na">plain English . io</em></strong></a></p></div></div>    
</body>
</html>