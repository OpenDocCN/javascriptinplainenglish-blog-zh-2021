<html>
<head>
<title>How to Get Started with Maps in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始使用JavaScript中的地图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-maps-in-javascript-f940d0083454?source=collection_archive---------18-----------------------#2021-06-07">https://javascript.plainenglish.io/getting-started-with-maps-in-javascript-f940d0083454?source=collection_archive---------18-----------------------#2021-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fa4a373d699176a3fdad45c9ff96dd6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WLWhi0YNnVu0tpDz"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@iambrettzeck?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Zeck</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="91b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">什么是JavaScript中的地图？映射是一个键值存储，其中保存了由键引用的值。当我们想要检索一个值时，我们引用该键，然后我们收到返回的值。如果你花了任何时间写JavaScript，你可能会立即意识到地图的描述和物体非常相似，如果不是完全相同的话(至少到目前为止我已经揭示了)。根据MDN文档，地图的定义如下:</p><blockquote class="ky kz la"><p id="464a" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">Map对象保存键值对，并记住键的原始插入顺序。任何值(对象和基元值)都可以用作键或值。</p></blockquote><p id="d961" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这给我们带来了两个我们可以从这个描述中收集到的区别。第一，地图记得插入顺序，物体没有这种能力。要获取一个对象的所有键，我们将调用<code class="fe lf lg lh li b">Object.Keys</code>。<code class="fe lf lg lh li b">Object.Keys</code>和<code class="fe lf lg lh li b">Map.Keys</code>之间有一个微妙的区别，那就是秩序。让我们看看在使用<code class="fe lf lg lh li b">Object.keys</code>时，我们是如何被骗相信维持了订单的。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="e660" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是令人困惑的，因为实际上如果你做了相当多的例子，它看起来保持了键插入时的顺序。实际上，如下所述，这是不正确的。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2825" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以从MDN文档中进一步了解到<code class="fe lf lg lh li b">Object.keys</code>以同样的顺序遍历键，就像它们被循环一样。这里的参考是一个<code class="fe lf lg lh li b">for in</code>循环，它允许我们在一个物体的按键上循环。如果我们为此查看MDN上的文档，我们会发现以下内容:</p><blockquote class="ky kz la"><p id="eab7" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">for...in</code>循环以任意顺序迭代对象的属性</p></blockquote><p id="e802" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想了解更多信息，可以继续讨论查看关于<code class="fe lf lg lh li b">delete</code>运算符的文档。我不认为这需要任何进一步的讨论，因为根据文档，为了适当地支持删除，返回的键的顺序可能会受到影响。任何更深入的解释都不在本文的讨论范围之内。否则，这应该是足够的知识来证明，当试图迭代键时，我们不能依赖于我们将键添加到对象中的顺序。</p><p id="f2ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从地图描述中获得的第二个认识是，我们不再仅仅需要原始值作为关键字。在一个对象中，除了使用字符串之外，实际上没有其他方法来分配键(我们也可以选择使用符号，但是这些也被认为是基元值)。有了地图，我们也可以使用对象、数组和函数作为键。让我们开始深入探讨特定的API。</p><h1 id="8135" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在地图中设置值</h1><p id="a3d8" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在我们能够在地图中设置值之前，我们必须知道如何创建一个值。这非常简单，因此它不值得拥有自己的部分。我们可以简单地使用Map构造函数来创建一个新的Map。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9be5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了开始向我们的地图添加值，我们提供了方便的<code class="fe lf lg lh li b">set</code>方法。设置值很简单，提供一个键作为第一个参数，一个值作为第二个参数。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="431c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们能够用两个参数调用<code class="fe lf lg lh li b">set</code>，正如您在控制台日志中看到的，第一个参数成为我们映射中的键，第二个参数成为我们映射中的值。值得注意的是，<code class="fe lf lg lh li b">set</code>方法返回当前的<code class="fe lf lg lh li b">this</code>上下文，这也允许将多个set调用链接在一起。此外，我们可以在最后一个例子中看到，我们不再使用原始值作为键。事实上，我们正在使用一个对象，您在第16行看到的控制台日志向我们显示了这是添加到我们的地图中的内容。</p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/657dab9f39aa5f252fa77790de6e9110.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*PwrEI8beNzBa2pTCgJ-9Dg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Shows What It Looks Like To Use A Non-Primitive Value Key On A Map, Screenshot By Author.</figcaption></figure><p id="49b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，在这里我们可以看到我们使用了一个对象作为键，这是一个简洁的概念，如果不先将它转换成字符串，就无法用对象来实现。最后要注意的是，正如我们在第26行看到的，我们可以通过传入一个数组的数组来初始化一个带有起始值的map。每个内部数组表示一个键-值对，第一个位置是键，第二个位置是值。</p><h1 id="eaf4" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">获取地图中的值</h1><p id="da6d" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">获取地图中的值也非常方便和容易。我们已经向我们展示了<code class="fe lf lg lh li b">get</code>方法，它接受一个键作为它的唯一参数，如果它存在就返回存储在那个键上的值，如果不存在就返回未定义的值。下面我们来看一些例子。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7b4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中需要注意一些非常重要的事情。请注意，在地图中，字符串为“1”的键和数字为1的键是有区别的。此外，看看当试图获取userId为1的对象的值时的结果，但是当我们在<code class="fe lf lg lh li b">get</code>方法中直接使用对象而不是引用变量时。这是一个需要注意的重要区别，因为对于传统的哈希表，关键字通过哈希算法处理，该哈希算法的结果会影响值的放置。在这种情况下，使用这种技术，我们将能够以上图所示的方式查找值。</p><p id="3978" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于非原始值，映射使用内存中对非原始值的引用来查找并返回值。您可能会得到一些奇怪的行为，像这样做，而没有注意到引用中的一些东西已经改变。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="e5b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要确保当使用非原始值作为键时，我们不会改变那些引用，并期望仍然能够使用那些引用从我们的地图中获取项目。为了纠正上面的问题，您可以修改<code class="fe lf lg lh li b">updateEmail</code>来做如下的事情。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1e7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里微妙的变化是我们更新了用户对象，而不是创建一个新的引用。要知道<code class="fe lf lg lh li b">Array.Map</code>返回一个新的引用，但只针对外部数组，内部对象本身实际上是同一个引用，所以这无论如何都没有影响。如果不希望改变原始引用，那么在不使用原始值作为键的情况下，需要同时更新地图中的引用。</p><h1 id="6bfd" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在地图中查找值</h1><p id="a59c" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在地图中查找值非常简单，因为我们提供了<code class="fe lf lg lh li b">has</code>方法。该方法接收一个键，并根据该键是否存储在映射中返回true或false。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3a96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为这非常简单，但也非常有用。我们已经详细讨论过这个问题，所以我不会在这个问题上纠缠太久，但是对于检索键不是原始值的值，这里也存在同样的警告。如果您用一个匹配的对象调用<code class="fe lf lg lh li b">has</code>方法，但是它有一个不同的引用，它将返回false。我们需要应用相同的模式，将引用存储到变量中，并在不改变引用的情况下更新引用，否则<code class="fe lf lg lh li b">has</code>方法也会出现意外的结果。</p><h1 id="ffaf" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">删除地图中的值</h1><p id="3bec" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">删除映射中的值与检索映射中的值是相同的API。我们公开了<code class="fe lf lg lh li b">delete</code>方法，它接受一个参数，这个参数是您希望删除的键。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1958" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用<code class="fe lf lg lh li b">delete</code>方法并传入一个有效的键会导致返回true并修改地图。正如您在示例中看到的，当我们传入一个不在Map中的键时，将返回false，Map保持不变。因为我们返回了该项是否被移除的指示，所以我们不能像处理<code class="fe lf lg lh li b">set</code>调用一样将<code class="fe lf lg lh li b">delete</code>调用链接在一起。这表明要删除一个值列表，我们需要反复调用<code class="fe lf lg lh li b">delete</code>方法来遍历它们。如果我们要从一个映射中移除所有的条目，我们就公开了<code class="fe lf lg lh li b">clear</code>方法，它从一个映射中移除所有的键和值。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9151" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是清除任何键值对映射的简单方法。</p><h1 id="6bb1" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">遍历地图</h1><p id="391b" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我们基本上有4种不同的方法来遍历地图。我想把它们分成两类。在迭代器类别中，我们有<code class="fe lf lg lh li b">Map.Values</code>、<code class="fe lf lg lh li b">Map.Entries</code>和<code class="fe lf lg lh li b">Map.Keys</code>。这三个方法虽然返回不同的数据，但都返回迭代器，并且以相同的方式使用。接下来，我们将探索<code class="fe lf lg lh li b">Map.ForEach</code>方法，这是一种更传统的循环方式来迭代地图。让我们开始吧。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="dbed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来像很多代码，但是每个例子实际上是完全一样的，不同的是你从迭代器得到什么。让我们以一种简单的方式来分解它。迭代器允许我们调用<code class="fe lf lg lh li b">next</code>方法。我们接收回一个带有value属性的对象，该属性包含一个基于您调用的迭代方法的值，还有一个done属性，让您知道是否有其他项要迭代。您还可以看到带有while循环的模式，它允许我们使用循环来遍历项目。这要有用得多，当<code class="fe lf lg lh li b">done</code>变为真时跳出循环，使用value键执行一些逻辑。</p><p id="28fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<code class="fe lf lg lh li b">Map.Values</code>方法，我们只获得值本身作为值属性。对于<code class="fe lf lg lh li b">Map.Keys</code>，我们将只获取迭代器对象的value属性中的键。最后，对于<code class="fe lf lg lh li b">Map.Entries</code>，我们为value属性获取一个数组，其中第一个位置是键，第二个位置是值。每种方法都有不同的用例，但是关键的因素是理解迭代器的模式，然后决定是否需要键、值或者两者都需要。如果我们想使用更类似于for循环的东西呢？这就是<code class="fe lf lg lh li b">Map.ForEach</code>发挥作用的地方。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="f99d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们能够调用<code class="fe lf lg lh li b">forEach</code>并传递一个回调函数，该函数作为第一个参数传递，即来自映射的值，第二个参数将是来自映射的键，最后一个参数是映射本身。如果您对<code class="fe lf lg lh li b">Array.ForEach</code>很熟悉，那么当您需要访问键和值，或者出于某种原因需要访问映射本身时，这将是一种很好的遍历映射的方式。</p><h1 id="71ad" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后一个方法</h1><p id="79d3" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">没有一个好的地方来放置这个，它是所有方法中最简单的一个，但也是非常重要的。这是<code class="fe lf lg lh li b">size</code>方法。当我们调用这个方法时，它返回Map中条目的长度。</p><figure class="lj lk ll lm gt jo"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="3aa1" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="d6ba" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">与使用对象相比，在JavaScript中使用地图是一种奇妙的体验。当您处于需要维护排序的场景中时，这尤其有用，就像传统的数组一样，但是您需要在恒定的时间内提高查找的性能。如果您发现自己需要使用一个对象，但又想使用非原始键，那么地图是有意义的。</p><p id="6ee9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据这篇<a class="ae jz" href="https://medium.com/@bretcameron/how-javascript-maps-can-make-your-code-faster-90f56bf61d9d" rel="noopener">中的文章</a>(该文章试图提供一些关于地图与对象的性能测试)，在地图中查找项目要快2.6倍，添加条目要快45.8倍，删除一个项目要快31倍。根据这篇文章，它失败的地方是用一个慢了5倍的for循环向Map添加项目。当您考虑使用Map是否适合您的用例时，需要考虑一些有趣的结果。</p><p id="495c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更内容于</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5</a></p></div></div>    
</body>
</html>