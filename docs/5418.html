<html>
<head>
<title>How To Mock A React Component In Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在笑话中模仿React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-mock-a-react-component-in-jest-1fed64768b47?source=collection_archive---------8-----------------------#2021-11-09">https://javascript.plainenglish.io/how-to-mock-a-react-component-in-jest-1fed64768b47?source=collection_archive---------8-----------------------#2021-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53fe42930f5c8fc02aa7603650c7f29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8OA2seD1ON-iXfoA7Li3w.png"/></div></div></figure><p id="312c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试是反应开发最重要的方面之一。没有测试，你就不能相信你的代码会像预期的那样工作。出于测试目的，模拟React组件可能是相关的。本文将向您展示如何使用Jest在不同的场景中模拟React组件。使用这些信息，您将知道如何模仿默认的导出组件、命名的导出组件、来自ES6模块的组件以及它们所包含的属性。</p><h1 id="9093" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">默认导出</h1><p id="7236" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要模仿React组件，最直接的方法是使用<code class="fe lz ma mb mc b">jest.mock</code>函数。您模仿导出组件的文件，并用自定义实现替换它。因为组件基本上是一个函数，所以mock也应该返回一个函数。实现将如下所示。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a224" class="ml kx iq mc b gy mm mn l mo mp">jest.mock("./AwesomeComponent", () =&gt; () =&gt; {<br/>  const MockName = "default-awesome-component-mock";<br/>  return &lt;MockName /&gt;;<br/>});</span><span id="6ea9" class="ml kx iq mc b gy mq mn l mo mp">// Tests</span></pre><p id="8dc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这假设您模仿的组件是文件的默认导出。除此之外，它还为测试环境中的组件创建了一个自定义名称。这将简化生成的DOM结构，这在快照测试中很有用。</p><h1 id="68e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">命名出口</h1><p id="8740" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如上所述，前面的实现是针对默认导出文件的组件的。但是，如何模拟一个作为文件的命名导出的React组件呢？为此，实现应该模拟文件的整个导出，而不仅仅是默认导出。看起来应该是这样的。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="fcdf" class="ml kx iq mc b gy mm mn l mo mp">jest.mock("./AwesomeComponent", () =&gt; ({<br/>  AwesomeComponent: () =&gt; {<br/>    const MockName = "named-awesome-component-mock";<br/>    return &lt;MockName /&gt;;<br/>  },<br/>}));</span></pre><p id="26e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mock没有返回函数，而是返回一个对象来替换文件的导出。在对象内部，我们声明需要替换的属性。然后，我们可以为它指定替换代码，这与我们之前使用的函数相同。</p><p id="34d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在处理ES6模块，您将需要一些额外的配置来使它工作。具体来说，您需要将<code class="fe lz ma mb mc b">__esModule</code>属性添加到导出的对象中，并将其设置为true。这表明您正在处理ES6模块，并使一切正常工作。实现将如下所示。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cbbc" class="ml kx iq mc b gy mm mn l mo mp">jest.mock("./AwesomeComponent", () =&gt; ({<br/>	__esModule: true,<br/>  AwesomeComponent: () =&gt; {<br/>    const MockName = "named-awesome-component-mock";<br/>    return &lt;MockName /&gt;;<br/>  },<br/>}));</span></pre><h1 id="1251" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">包括道具</h1><p id="78dd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们现在知道了如何为一个组件创建一个模拟，它可以是一个文件的默认或命名导出。但是问题是当前的mock覆盖了组件的所有内容，包括DOM结构和props。在某些场景中，我们想要模仿与组件相关的一切，但仍然保留用于测试目的的道具。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="22fb" class="ml kx iq mc b gy mm mn l mo mp">jest.mock("./AwesomeComponent", () =&gt; ({<br/>  AwesomeComponent: (props) =&gt; {<br/>    const MockName = "named-awesome-component-mock";<br/>    return &lt;MockName {...props} /&gt;;<br/>  },<br/>}));</span></pre><p id="55c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，将道具添加回我们的模拟实现并不需要太多的努力。类似于如何为一个普通的React组件定义props，我们需要捕获函数参数并将它们传递给呈现的元素。这样做将包括传递给模拟组件的道具，并允许我们在测试中使用它们。</p><h1 id="3a16" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后的想法</h1><p id="8bc9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">出于测试目的，模拟某个React组件可能是相关的。本文向您展示了如何在不同的场景中模拟React组件。这包括默认的导出组件、命名的导出组件、来自ES6模块的组件，以及它们所包含的属性。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="4acf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，可以考虑查看一下<a class="ae my" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">不常见的React </a>时事通讯、我的<a class="ae my" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank"> Twitter </a>的其他条目，以便将来更新，或者我的其他(React)关于Medium的工作。</p><p id="8416" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">更多内容尽在</em><a class="ae my" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>