<html>
<head>
<title>The Ultimate Way to Store Authentication Tokens in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中存储身份验证令牌的最终方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-ultimate-way-to-store-authentication-tokens-in-javascript-41900756c1ae?source=collection_archive---------1-----------------------#2021-03-25">https://javascript.plainenglish.io/the-ultimate-way-to-store-authentication-tokens-in-javascript-41900756c1ae?source=collection_archive---------1-----------------------#2021-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">像专业人士一样处理认证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/74336524c4625343675f3b8106ef430c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SnMwCHdW2CS6brwL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@imattsmart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">iMattSmart</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2c6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在从事一个项目时，我遇到了一些关于存储身份验证令牌的问题。我不知道如何在前端安全地保存身份验证令牌，这样用户在刷新后就不会注销。经过几天的头痛，我已经学会了在用户浏览器中存储身份验证令牌的最终方法。今天，我将分享我关于如何存储和保护认证令牌的想法。首先，我们将讨论为什么我们不应该在客户端代码中存储认证令牌。然后，我们将看到推荐的选项，我们可以应用这些选项来存储我们的身份验证令牌。</p><h1 id="2622" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么我们不应该使用客户端代码来处理认证令牌呢？</h1><p id="9cac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">作为初学者，我们可能不知道除了使用客户端代码存储身份验证令牌之外，是否还有其他方法。通常，使用客户端JavaScript代码存储数据有两种方式:cookies和本地存储。如果您在本地存储中处理认证令牌，您很容易受到<a class="ae kv" href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="noopener ugc nofollow" target="_blank"> XSS攻击</a>。另一方面，如果你试图将你的认证令牌放在cookies中，你的项目就有可能受到<a class="ae kv" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> CSRF攻击</a>。从这两个角度来看，很明显，在前端存储和管理身份验证令牌对于您的项目来说可能会变得很危险。</p><h1 id="0814" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">那么有哪些选择呢？</h1><p id="0d0f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一种方法是使用内存。如果您正在开发一个高度安全的系统，这是最好的选择。但是它对用户不友好，因为每当用户刷新页面时就会被注销。</p><p id="3eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是使用<a class="ae kv" href="https://owasp.org/www-community/HttpOnly" rel="noopener ugc nofollow" target="_blank"> HttpOnly Cookie </a>。每当用户成功登录web应用程序时，服务器都会向web浏览器发送一个HttpOnly cookie。使用HttpOnly cookie的好处是它不能通过任何客户端JavaScript代码访问。因此没有客户端脚本能够检索这个cookie。每当客户端请求授权内容时，服务器从浏览器获取cookie，验证它，并响应请求。</p><p id="8555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止CSRF攻击，您可以将<code class="fe mp mq mr ms b">SameSite=Lax</code>属性添加到cookies中，尽管大多数现代浏览器都默认这样做。如果您的前端域不同于您的服务器域，浏览器将不会存储这些cookies。为此，您需要将属性更改为<code class="fe mp mq mr ms b">SameSite=None</code>，并向cookies添加另一个名为<code class="fe mp mq mr ms b">Secure</code>的属性。它需要为您的web应用程序启用HTTPS。</p><p id="f2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，我们现在通过服务器向浏览器发送cookies。但是为什么浏览器没有存储cookies呢？嗯。要解决这个问题，首先启用<code class="fe mp mq mr ms b">Access-Control-Allow-Credentials: true</code>。之后，将属性<code class="fe mp mq mr ms b">credentials: “include”</code>添加到客户端JavaScript的HTTP客户端配置中(如果使用Axios或Ajax，则为<code class="fe mp mq mr ms b">withCredentials: true</code>)。此外，在<code class="fe mp mq mr ms b">Access-Control-Allow-Origin</code>中提供准确的原点，以修复其他与CORS相关的问题。</p><h1 id="5936" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们看一个例子</h1><p id="8817" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想恰当地教授一些东西，举例子总是更好的。在这个例子中，我展示了我的项目中的一些代码片段。我们使用React JS，Redux作为前端，Django作为后端。我们在系统中使用了JWT认证。我们在Django中使用的身份验证包在我们成功登录系统时会在浏览器中自动发送一个HttpOnly cookie，所以我们现在不会关注后端。相反，我们将看到如何在React JS中管理我们的访问令牌和刷新令牌。如果你之前没有用过React或者Redux，我想你还是会理解这个例子的。</p><p id="06a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来看看HTTP客户端。在这个项目中，我们使用Axios向API发送请求并获得响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0cf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在<code class="fe mp mq mr ms b">defaultOptions</code>的结尾，我们用了<code class="fe mp mq mr ms b">withCredentials: true</code>。然后我们用那个<code class="fe mp mq mr ms b">defaultOptions</code>实例化一个Axios对象。</p><p id="d83b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看授权操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="be10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们关注一下<code class="fe mp mq mr ms b">authLogin</code>和<code class="fe mp mq mr ms b">authSignup</code>方法。在认证用户之后，我们将访问令牌附加到我们的<code class="fe mp mq mr ms b">apiClient</code>的授权头。对于我们的前端，我们不需要访问令牌和刷新令牌。后端服务器会自动为我们设置cookie。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/d1cb427bb7f5f5ca108562f78689415e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-JI3ylTQezcMLjhBexNnw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Response Header Sent from the Backend after Successful Login</figcaption></figure><p id="07a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要查看红色下划线的属性。将<code class="fe mp mq mr ms b">Access-Control-Allow-Credentials</code>设置为<code class="fe mp mq mr ms b">true</code>。我们还在<code class="fe mp mq mr ms b">Access-Control-Allow-Origin</code>中提供了前端原点。其中一个重要的属性是<code class="fe mp mq mr ms b">Set-Cookie</code>属性。后端正在我们的网络浏览器中设置cookies。看，我们在<code class="fe mp mq mr ms b">Set-Cookie</code>属性中有了<code class="fe mp mq mr ms b">HttpOnly</code>和<code class="fe mp mq mr ms b">SameSite</code>属性(用蓝色下划线标记)。</p><p id="50f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mp mq mr ms b">logout</code>方法中，我们请求一个登出后端的请求，然后后端从浏览器中删除cookies。然后我们从<code class="fe mp mq mr ms b">apiClient</code>中删除授权头。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/abefa2409aad00591c12f397b503f88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HspI3yf-_6xDyJITOyF-Kg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Response Header Sent from the Backend after Logout</figcaption></figure><p id="6dbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到，令牌在注销后已被设置为空字符串。</p><p id="d269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经成功登录并将令牌存储在cookies中。是时候保持登录状态了。我们有<code class="fe mp mq mr ms b">authCheckState</code>方法获取当前登录的用户，有<code class="fe mp mq mr ms b">refreshToken</code>方法在访问令牌到期前及时刷新访问令牌。在<code class="fe mp mq mr ms b">refreshToken</code>方法中，当我们向后端发送请求时，服务器会自动从浏览器中获取cookie，所以我们不需要担心共享刷新令牌。如果我们没有得到任何刷新令牌，我们调度<code class="fe mp mq mr ms b">logout</code>方法。然后我们在React <strong class="ky ir"> App.js </strong>文件中调用这些方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="032a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="921d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在任何状态下，前端都不负责将访问令牌和刷新令牌存储在浏览器cookies或本地存储中。cookies仅由后端发送到浏览器。它保护我们用户的隐私，强化我们应用程序的安全性。</p><p id="b50e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，<strong class="ky ir">不处理前端的任何敏感信息</strong>。</p><p id="b48a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mx">多内容于</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mx">中</em></strong></a></p></div></div>    
</body>
</html>