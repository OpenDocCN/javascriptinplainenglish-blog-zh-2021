<html>
<head>
<title>How to Optimize Your Node.js Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化Node.js Web应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-optimize-your-node-js-web-application-d5284f8a487?source=collection_archive---------16-----------------------#2021-02-14">https://javascript.plainenglish.io/how-to-optimize-your-node-js-web-application-d5284f8a487?source=collection_archive---------16-----------------------#2021-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a564" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果最终用户认为你的网站表现不佳，他们的下一次点击将会是your-competition.com</h2></div><p id="d70e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当我们开发一个web应用程序时，基本上都有两个性能目标。</p><ol class=""><li id="fc79" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">任务完成(用户体验)</li><li id="a81a" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">吞吐量(规模)</li></ol><p id="6a54" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们所说的任务完成是指任务及时完成，吞吐量是指每秒的请求数。</p><p id="16ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在设计和实际编码时，我们必须考虑这两个目标，以便我们的系统具有最高的性能和最低的延迟。</p><p id="c8f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何优化Node.js应用程序。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/34f7866f772ea0fd0c5241ad13034d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVDAuZzLPmS4mpAepm4siQ.jpeg"/></div></div></figure><h1 id="a1f7" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak">加速数据库查询</strong></h1><p id="705f" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">让我们看看我们能做些什么来加速我们的数据库查询</p><h2 id="82dc" class="mv lz in bd ma mw mx dn me my mz dp mi kl na nb mk kp nc nd mm kt ne nf mo ng bi translated">索引</h2><blockquote class="nh ni nj"><p id="9a98" class="kc kd nk ke b kf kg jo kh ki kj jr kk nl km kn ko nm kq kr ks nn ku kv kw kx ig bi translated">索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。</p></blockquote><p id="4311" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该扫描索引，而不是扫描整个集合，因为这样更快。一个或多个字段的集合可用于建立索引，称为查询索引，以提高查询的性能。</p><p id="8311" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的等式匹配和基于范围的查询操作。此外，MongoDB可以通过使用索引中的排序返回排序的结果。</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="f83c" class="mv lz in np b gy nt nu l nv nw">db.employee.createIndex({ employee_email: 1})</span></pre><p id="f9a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您的查询是这样的，可以减少查询时间</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="23e2" class="mv lz in np b gy nt nu l nv nw">db.employee.find().sort({ employee_name: 1})</span></pre><blockquote class="nh ni nj"><p id="2f87" class="kc kd nk ke b kf kg jo kh ki kj jr kk nl km kn ko nm kq kr ks nn ku kv kw kx ig bi translated">在创建集合的过程中，MongoDB在_id字段上创建一个惟一的索引。_id索引防止客户端插入两个具有相同_id字段值的文档。</p></blockquote><p id="395e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">复合指数</strong></p><p id="eb26" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">复合索引中列出的字段顺序很重要。例如，如果一个复合索引由{ userid: 1，score: -1 }组成，则该索引首先按userid排序，然后在每个userid值中按分数排序。</p><p id="6b51" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于复合索引和排序操作，索引键的排序顺序(即升序或降序)可以确定索引是否支持排序操作。</p><p id="f594" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑一个包含带有用户名和日期字段的文档的事件集合。</p><p id="6b5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应用程序可以发出查询，返回首先按用户名值升序排序，然后按日期值降序排序的结果，例如:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="7e95" class="mv lz in np b gy nt nu l nv nw">db.events.find().sort( { username: 1, date: -1 } )</span></pre><p id="9ae4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者返回首先按用户名值降序排序，然后按日期值升序排序的结果的查询，例如:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="054b" class="mv lz in np b gy nt nu l nv nw">db.events.find().sort( { username: -1, date: 1 } )</span></pre><p id="4b16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下索引可以支持这两种排序操作:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="7897" class="mv lz in np b gy nt nu l nv nw">db.events.createIndex( { “username” : 1, “date” : -1 } )</span></pre><p id="94a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，上述索引不支持先按用户名值升序排序，然后按日期值升序排序，如下所示:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="5a32" class="mv lz in np b gy nt nu l nv nw">db.events.find().sort( { username: 1, date: 1 } )</span></pre><blockquote class="nh ni nj"><p id="547f" class="kc kd nk ke b kf kg jo kh ki kj jr kk nl km kn ko nm kq kr ks nn ku kv kw kx ig bi translated">如果MongoDB不能使用一个或多个索引来获得排序顺序，那么MongoDB必须对数据执行阻塞排序操作。阻塞排序表示MongoDB必须在返回结果之前消耗和处理排序的所有输入文档。阻塞排序不会阻塞集合或数据库上的并发操作。</p></blockquote><p id="979f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">稀疏索引</strong></p><p id="238a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">索引的稀疏属性确保索引只包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。</p><p id="51c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以将稀疏索引选项与唯一索引选项结合使用，以防止插入索引字段具有重复值的文档，并跳过对缺少索引字段的文档进行索引。</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="cb2d" class="mv lz in np b gy nt nu l nv nw">db.restaurants.createIndex({ “rating”: 1 }, { sparse: 1 })</span></pre><p id="5163" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">提示</strong></p><p id="4bed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用$hint选择特定的索引–<br/>在大多数情况下，查询优化器为特定的操作选择最佳的索引；但是，您可以使用hint()方法强制MongoDB使用特定的索引。</p><p id="acb3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">獴瘦()法</strong></p><p id="d9d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，mongose查询返回mongose文档类的一个实例。文档比普通的JavaScript对象要重得多，因为它们有许多内部状态用于变更跟踪。猫鼬允许你添加。通过返回普通的JSON对象而不是Mongoose文档，lean()极大地提高了查询的性能。</p><p id="69c1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">预测</strong></p><p id="410c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您只需要文档中字段的子集时，可以通过只返回您需要的字段来获得更好的性能:</p><p id="4de4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="e2bd" class="mv lz in np b gy nt nu l nv nw">db.employee.find({ email: 1 , lastName: 1 , firstName: 1 })</span></pre><p id="9384" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">聚合</strong></p><p id="1971" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">聚合操作处理数据记录并返回计算结果。聚合操作将多个文档中的值组合在一起，并可以对分组的数据执行各种操作以返回单个结果。</p><h1 id="1f51" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak"> Node.js集群模块</strong></h1><p id="325e" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">Node.js的一个重要特性就是可伸缩性。每个Node.js进程都在一个线程中运行，默认情况下，它在32位系统上的内存限制是512MB，在64位系统上是1GB。尽管内存限制在32位系统上可以达到约1GB，在64位系统上可以达到约1.7GB，但内存和处理能力仍然会成为各种进程的瓶颈。</p><p id="d372" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js为扩展应用程序提供的优雅解决方案是将单个流程拆分成多个流程或<em class="nk">工作器</em>，这可以通过集群模块来实现。集群模块允许您创建子进程(workers)，这些子进程与主节点进程(master)共享所有服务器端口。</p><h1 id="a712" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak"> GZIP压缩</strong></h1><p id="b616" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">打开gzip压缩会极大地影响您的web应用程序的性能。当gzip兼容的浏览器请求某些资源时，服务器可以在将响应发送给浏览器之前对其进行压缩。如果你不使用gzip来压缩你的静态资源，浏览器可能需要更长的时间来获取它。</p><p id="4d41" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Express应用程序中，您可以使用内置的express.static()中间件来提供静态内容。此外，您可以使用压缩中间件来压缩和提供静态内容。下面是一个片段，展示了如何做到这一点:</p><pre class="ln lo lp lq gt no np nq nr aw ns bi"><span id="37b8" class="mv lz in np b gy nt nu l nv nw">var compression = require(‘compression’);</span><span id="5422" class="mv lz in np b gy nx nu l nv nw">app.use(compression()); //use compression <br/>app.use(express.static(path.join(__dirname, ‘public’)));</span></pre><h1 id="e93c" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">避免内存泄漏</h1><p id="6d96" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">在Node.js中，每个进程都有1.5 GB内存堆的容量，而不考虑可用的总内存。但是，Node.js中的V8引擎有一个内置的垃圾收集器(GC)，它会自动清理不活动的内存，以便使其可供使用。</p><p id="9526" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，有时内存中过期很长时间的数据会逃过垃圾收集器，导致内存泄漏。</p><p id="437c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，很多时候内存使用量不断增加，而垃圾收集器却无法清理内存。这需要紧急解决。</p><p id="1b2a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，跟踪内存泄漏比您想象的要困难。在Node.js应用程序中跟踪内存泄漏的最佳方式是通过获取内存堆快照并分析它们来识别稳步增长的对象和类。</p><p id="3cc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，如果未能诊断出内存泄漏，Node.js应用程序很有可能会耗尽内存并被关闭。</p><p id="4f2e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果发生这种情况，您总是可以雇佣Node js开发人员来帮助您在内存使用阈值接近定义的限制时设置自动警报。</p><p id="cb23" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，您还应该考虑评估您的应用基础设施，并收集英特尔的性能信息，以检测是否有任何可用的资源，并准备好进行扩展以进行优化。</p><h1 id="9bc5" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak">避免同步功能</strong></h1><p id="35fb" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">在使用同步函数之前要小心，因为对同步函数的单个调用可能会在几毫秒内返回。在高流量网站的情况下，这样的请求会降低应用程序的性能。确保避免在生产中使用同步函数。在初始启动时，同步功能是值得证明的。</p><h1 id="2766" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated"><strong class="ak">使用反向代理</strong></h1><p id="4099" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">通常，反向代理在web应用程序前面对请求执行支持操作，而不是将请求定向到应用程序，它具有处理压缩、错误页面、服务文件、缓存和负载平衡等功能。处理任务不需要应用程序的熟练知识来反转代理释放以执行特定的应用程序任务。这就是为什么，我想建议，你在制作中使用像HAProxy或Nginx这样的反向代理。</p><h1 id="96aa" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">结论</h1><p id="6605" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">我们参观了如何通过使用某些方法优化Node.js应用程序的性能，尽管到目前为止还没有设计出被称为<strong class="ke io">完美</strong>的系统。所以现在我们可以注意到一件事:<em class="nk">“如果不首先创新你制造产品的方式，你就不能创新产品”。</em></p><p id="4376" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nk">更多内容请看</em><a class="ae ny" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>