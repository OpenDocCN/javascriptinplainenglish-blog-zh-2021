<html>
<head>
<title>Reactive Programming — Using RxJS Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式编程—使用RxJS运算符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactive-programming-using-rxjs-operators-6b803c0ed7de?source=collection_archive---------10-----------------------#2021-04-12">https://javascript.plainenglish.io/reactive-programming-using-rxjs-operators-6b803c0ed7de?source=collection_archive---------10-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c89" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">RxJS操作符可以帮助简化您的web应用程序开发。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05c76230dba368b1ddb8f67e6e675968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jx2VyIPdihLUfQqKxRFTcw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by <a class="ae kv" href="https://pixabay.com/users/1137303-1137303/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=835340" rel="noopener ugc nofollow" target="_blank">Pashminu Mansukhani</a> from <a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=835340" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="58fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我目前的工作中，我一直在使用反应式编程范式进行编码——我从中获得了很多乐趣。我已经知道这个范例是基于观察者设计模式的。然而，在我旅程的早期，我经历了一个陡峭的学习曲线。诚然，在阅读了文档之后，我的收获是如何创建一个可观察对象(主体)和一个观察者。我在通读操作员之后不知何故迷路了。</p><p id="d2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用的可用运算符的数量可能会非常多。文档写得很好。然而，我认为这是你需要付诸实践才能更深入理解的概念之一。或者更好的是，找到可以用RxJS操作符解决的现有问题。</p><p id="70b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将带你浏览到目前为止我认为有用的RxJS操作符。代码示例将使用用TypeScript编写的RxJS版本6.6.7。</p><p id="a70a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到，我故意让我的示例代码尽可能地详细:</p><ul class=""><li id="4c87" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我正在指定可观察的类型。指定类型使我们在初始化一个可观察对象时变得清晰。</li><li id="d144" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在箭头函数中明确使用了return语句。JSFiddle中似乎有一个bug，使用arrow函数快捷方式进行return语句不起作用。</li><li id="e677" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">有一些我们可能不需要做的变量赋值。然而，我将一些可观察的变量赋值给一个变量，这样它们更容易理解。</li><li id="2055" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我将美元符号($)附加到可观测量上，这是标准做法。</li></ul><h1 id="14c1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">RxJS的基础</h1><p id="324f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在我们跳到操作符之前，让我们快速回顾一下基础知识。</p><p id="4044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经知道如何在RxJS中使用Observable、Observer和Subject，你可以跳过这一节。</p><h2 id="adc3" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">可观察的和观察者</h2><p id="ad20" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">来自<a class="ae kv" href="https://rxjs-dev.firebaseapp.com/guide/overview" rel="noopener ugc nofollow" target="_blank"> RxJS单据</a>。</p><blockquote class="nq nr ns"><p id="1093" class="kw kx nd ky b kz la jr lb lc ld ju le nt lg lh li nu lk ll lm nv lo lp lq lr ij bi translated">可观察的:表示未来值或事件的可调用集合的概念。</p><p id="26e3" class="kw kx nd ky b kz la jr lb lc ld ju le nt lg lh li nu lk ll lm nv lo lp lq lr ij bi translated">Observer:是一个回调集合，它知道如何监听可观察对象传递的值。</p></blockquote><p id="468b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先创建一个用一组值和一个<em class="nd"> setTimeout </em>函数初始化的<em class="nd">可观察对象</em>。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="82bb" class="ne mh iq nx b gy ob oc l od oe">const observable$: rxjs.Observable = new rxjs.Observable(observer =&gt; {<br/>  observer.next(1);<br/>  observer.next(2);<br/>  observer.next(3);<br/>  observer.next(3.5);<br/>  setTimeout(() =&gt; {<br/>    observer.next(4);<br/>    observer.complete();<br/>  }, 1000);<br/>});</span></pre><p id="dd1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将为一个观察者订阅<em class="nd">可观察的</em>。Observable中的下一个调用将执行我们的observer中的回调函数。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="fc86" class="ne mh iq nx b gy ob oc l od oe">observable$.subscribe({<br/>  next(x): void { console.log('got value ' + x); },<br/>  error(err): void { console.error('something wrong occurred: ' + err); },<br/>  complete(): void { console.log('complete'); }<br/>});</span></pre><p id="c283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当观察者执行完可观察集合中的内容后，就会调用<em class="nd"> complete </em>函数。</p><p id="2cad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码示例将按如下方式运行:</p><ol class=""><li id="5cd4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr of ly lz ma bi translated">按顺序打印“获得值”——1、2、3和3.5。</li><li id="f228" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">打印“仅在订阅后”</li><li id="f1fd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">打印“获得值4”</li><li id="13ae" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">打印“完成”</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><p id="cad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码示例让我们了解了可观察对象和观察者的概念。在反应式编程中，任何东西都可以是流。让我们探索几个例子，看看如何在我们的Web UI中实现这些概念。</p><h2 id="f49c" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">科目</h2><p id="3fd2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">简单来说，<em class="nd">主题</em>是<em class="nd">可观察对象</em>和<em class="nd">观察者</em>的包装。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="3215" class="ne mh iq nx b gy ob oc l od oe">const subject$ = new rxjs.Subject();</span></pre><p id="efc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以方便地使用<em class="nd">主题</em>同时创建一个<em class="nd">可观察的</em>和<em class="nd">观察者</em>。然后通过实例化的<em class="nd">主题</em>对象在代码中的任何地方访问它们。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="069b" class="ne mh iq nx b gy ob oc l od oe">subject$.subscribe(x =&gt; console.log('Subscriber A: ' + x));<br/>subject$.next(1);<br/>subject$.next(2);</span></pre><p id="0ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们运行该代码时，它将打印出以下内容。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7bce" class="ne mh iq nx b gy ob oc l od oe">"Subscriber A: 1"<br/>"Subscriber A: 2"</span></pre><p id="d169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以为我们的<em class="nd">可观察对象</em>订阅另一个<em class="nd">观察对象</em>，该观察对象打印“订户b”</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="ee01" class="ne mh iq nx b gy ob oc l od oe">subject$.subscribe(x =&gt; console.log('Subscriber B: ' + x));<br/>subject$.next(3);</span></pre><p id="a62b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这条线开始，我们现在有两个可用的观察者。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b246" class="ne mh iq nx b gy ob oc l od oe">"Subscriber A: 1"<br/>"Subscriber A: 2"<br/>"Subscriber A: 3"<br/>"Subscriber B: 3"</span></pre><p id="8050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想阻止新订阅我们的可观察对象，我们可以使用<em class="nd">完成</em>方法<em class="nd">来阻止新订阅方法的静默调用</em>。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="40cc" class="ne mh iq nx b gy ob oc l od oe">subject$.complete();</span></pre><p id="cb44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们可以使用<em class="nd">取消订阅</em>来抛出错误。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="30a3" class="ne mh iq nx b gy ob oc l od oe">subject$.unsubscribe();</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="e2f8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">1.拿</h1><p id="83cc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">它从一系列发射值中取出<em class="nd"> n </em>个值。</p><p id="5dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们有一系列发射值时，我们可以使用take，我们只想取第一个<em class="nd"> n个</em>发射值。该方法对于捕获前几个单击事件或从值列表中取样非常有用。</p><p id="a755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一系列发射值1、2、3、4和5。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="80a7" class="ne mh iq nx b gy ob oc l od oe">const emittedValues$: rxjs.Observable = rxjs.of(1, 2, 3, 4, 5);</span></pre><p id="cf6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<em class="nd"> take </em>运算符，通过取第一个<em class="nd"> n个</em>值来转换可观察对象的发射值。</p><p id="4fbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何将<em class="nd"> take </em>操作符传递给<em class="nd"> pipe </em>方法的。</p><blockquote class="nq nr ns"><p id="e3a8" class="kw kx nd ky b kz la jr lb lc ld ju le nt lg lh li nu lk ll lm nv lo lp lq lr ij bi translated">可管道操作符是一个函数，它将一个可观察值作为其输入，并返回另一个可观察值。这是一个纯粹的操作:之前的可观察值保持不变。— <a class="ae kv" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank"> rxjs-dev </a></p></blockquote><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="5303" class="ne mh iq nx b gy ob oc l od oe">const takeValues$: rxjs.Observable = emittedValues$.pipe(rxjs.operators.take(2));</span></pre><p id="3888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以使用转换后的发射值订阅该可观察值。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="6d47" class="ne mh iq nx b gy ob oc l od oe">takeValues$.subscribe(x =&gt; {console.log(x)});</span></pre><p id="ee4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的代码将打印前两个发出的值。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="3af0" class="ne mh iq nx b gy ob oc l od oe">1<br/>2</span></pre><p id="aa78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">使用下面的示例代码试验take操作符。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="e872" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">2.过滤器</h1><p id="806d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当我们希望根据我们设定的条件过滤掉由我们的可观察对象发出的值时，我们可以使用filter操作符。一个简单的例子是过滤出偶数或奇数的值。</p><p id="cea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重用上一个例子中相同的发射值。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="198c" class="ne mh iq nx b gy ob oc l od oe">const emittedValues$: rxjs.Observable = rxjs.of(1, 2, 3, 4, 5);</span></pre><p id="65fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用带有回调的<em class="nd">过滤器</em>操作符来过滤模2等于零的数字，从而过滤出偶数。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="32f9" class="ne mh iq nx b gy ob oc l od oe">// filter even numbers<br/>const evenNumbers$: rxjs.Observable = emittedValues$.pipe(<br/> rxjs.operators.filter(x =&gt; {return x % 2 == 0})<br/>);</span><span id="b0f6" class="ne mh iq nx b gy oi oc l od oe">console.log('even numbers');<br/>evenNumbers$.subscribe(x =&gt; {console.log(x)});</span></pre><p id="0117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将回调改为只过滤奇数— <em class="nd">模二不等于零</em>。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="63fa" class="ne mh iq nx b gy ob oc l od oe">// filter odd numbers<br/>const oddNumbers$: rxjs.Observable = emittedValues$.pipe(<br/> rxjs.operators.filter(x =&gt; {return x % 2 != 0})<br/>);</span><span id="493b" class="ne mh iq nx b gy oi oc l od oe">console.log('odd numbers');<br/>oddNumbers$.subscribe(x =&gt; {console.log(x)});</span></pre><p id="1d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试你能想到的其他过滤操作回调。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="6dcc" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">3.地图</h1><p id="9dbd" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">给定一系列从可观察对象发出的值，如果我们想为每个发出的值附加字符串“take:”会怎么样？我们可以使用<em class="nd">映射</em>操作符将函数应用于每个来自可观测值的发射值。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="9f89" class="ne mh iq nx b gy ob oc l od oe">const emittedValues$: rxjs.Observable = rxjs.of(1, 2, 3, 4, 5);</span></pre><p id="55d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用一个map操作符函数，该函数接受一个回调，该回调将字符串“take:”附加到每个值上。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b04f" class="ne mh iq nx b gy ob oc l od oe">const mappedValues$: rxjs.Observable = emittedValues$.pipe(<br/> rxjs.operators.map(x =&gt; {return 'take: ' + x})<br/>);</span></pre><p id="d7d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们给我们的<em class="nd"> $mappedValues </em>订阅一个回调。回调将打印我们的map函数返回的值。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b353" class="ne mh iq nx b gy ob oc l od oe">mappedValues$.subscribe(x =&gt; {console.log(x)});</span></pre><p id="1f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将获得以下输出。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="0a83" class="ne mh iq nx b gy ob oc l od oe">"take: 1"<br/>"take: 2"<br/>"take: 3"<br/>"take: 4"<br/>"take: 5"</span></pre><p id="469d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">使用你能想到的其他map operator回调。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="6ea3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">4.合并地图</h1><p id="0f53" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当我们想同时处理两个不同的观测值时,<em class="nd"> mergeMap </em>操作符很有用。</p><p id="5b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个具体的例子是，如果我们希望执行一个API调用来检索用户id，并执行另一个API调用来检索每个用户id的用户配置文件信息。</p><p id="ad5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">被模仿的API调用来检索用户id。</em></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7916" class="ne mh iq nx b gy ob oc l od oe">// mock a userIDs API call<br/>const getUserIds$: rxjsObservable = () =&gt; { <br/> const userIds$: rxjs.Observable = rxjs.of(1, 2, 3, 4, 5);<br/>  return userIds$;<br/>}</span></pre><p id="4062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">被模仿的API调用来检索用户配置文件。</em></p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="3140" class="ne mh iq nx b gy ob oc l od oe">// mock a user profile API call<br/>const getUserProfile$: rxjs.Observable = (userId) =&gt; {<br/> const userProfiles$: rxjs.Observable = rxjs.of('a', 'b', 'c', 'd', 'e');<br/>  return userProfiles$;<br/>};</span></pre><p id="f688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检索用户ID的API调用将是我们的“外部可观察对象”，检索每个用户ID的用户配置文件的API调用将是我们的“内部可观察对象”我们可以将这个示例应用于任何数据集，而不仅仅是用户，也就是说，您必须从一个API中检索id或键，然后使用它们或键从另一个API中检索另一条信息。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="1af6" class="ne mh iq nx b gy ob oc l od oe">const retrievedUsers$: rxjs.Observable = getUserIds$().pipe(<br/>  rxjs.operators.mergeMap(userId =&gt; {<br/>    return getUserProfile$(userId).pipe(rxjs.operators.map(userProfile =&gt; {<br/>      return userId + userProfile;<br/>    }))<br/>  }),<br/>);</span><span id="1ca2" class="ne mh iq nx b gy oi oc l od oe">retrievedUsers$.subscribe(x =&gt; { console.log('retrieved user: ' + x) });</span></pre><p id="9f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个例子中，我们可以看到<em class="nd"> mergeMap </em>如何帮助组合两个不同的结果集，或者将外部可观察的结果映射到内部可观察的结果。</p><p id="e271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">使用下面的示例代码作为参考，自己尝试不同的数据集。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="4c9e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">5.开关图</h1><blockquote class="nq nr ns"><p id="23f0" class="kw kx nd ky b kz la jr lb lc ld ju le nt lg lh li nu lk ll lm nv lo lp lq lr ij bi translated"><code class="fe oj ok ol nx b">switchMap</code>和其他展平算子的主要区别是抵消效果。在每次发射时，先前的内部可观测值(您提供的函数的结果)被取消，新的可观测值被订阅。你可以通过短语<strong class="ky ir">切换到一个新的可观察对象</strong>来记住这一点。- <a class="ae kv" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap" rel="noopener ugc nofollow" target="_blank"> learnrxjs.io </a></p></blockquote><p id="03bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd"> switchMap </em>操作符有助于typeahead实现。例如，在用户在我们的typeahead搜索的文本输入中输入一个新字符后，我们希望放弃前面的API请求。</p><p id="6ffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将点击事件作为我们的“外部可观察”和将<em class="nd">间隔</em>作为我们的“内部可观察”来证明这一点点击事件观察将发出点击事件，当然，当它被点击时。可观测区间每秒会发出一个从零开始的数字。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="47dd" class="ne mh iq nx b gy ob oc l od oe">const clickEvent$: rxjs.Observable = rxjs.fromEvent(document, 'click');</span></pre><p id="1a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将我们的<em class="nd"> clickEvent$ </em>作为我们的“外部可观察”，将<em class="nd"> interval </em>可观察作为我们的“内部可观察”</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="513a" class="ne mh iq nx b gy ob oc l od oe">rxjs.interval(1000)</span></pre><p id="c514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个可观测区间将重置为零，因为我们每次点击按钮都会切换到一个新的可观测区间。“外部可观察的”是包裹着我们的“内部可观察的”</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="14ad" class="ne mh iq nx b gy ob oc l od oe">clickEvent$.pipe(<br/>  rxjs.operators.switchMap(() =&gt; { <br/>    return rxjs.interval(1000)<br/>  })<br/>).subscribe(console.log);</span></pre><p id="1557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面输出中的零表示按钮被单击的时间；因此，它切换到一个新的可观测区间。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="c6b5" class="ne mh iq nx b gy ob oc l od oe">5<br/>6<br/>0<br/>1<br/>2<br/>0<br/>1</span></pre><p id="50d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用下面的示例代码，尝试切换到不同类型的可观察对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code snippet by the author.</figcaption></figure><h1 id="aba8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="6acf" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">您可以学习许多其他的操作符。到目前为止，这些是我发现有帮助的几个。随着我逐渐使用更多RxJS将提供的东西，我使用的运算符工具箱可能会增加。您的学习之旅将与我的不同，因此我建议尝试您可以在RxJS文档中找到的新操作符。</p><p id="9cad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">更多内容看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nd">plain English . io</em></strong></a></p></div></div>    
</body>
</html>