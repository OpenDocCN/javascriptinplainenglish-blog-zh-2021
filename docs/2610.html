<html>
<head>
<title>useResponsive: Writing Your Own React Hook for Handling Responsive Display Sizes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">useResponsive:编写自己的React钩子来处理响应显示尺寸</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useresponsive-writing-your-own-react-hook-for-handling-responsive-display-sizes-5fe36cc0c067?source=collection_archive---------4-----------------------#2021-05-29">https://javascript.plainenglish.io/useresponsive-writing-your-own-react-hook-for-handling-responsive-display-sizes-5fe36cc0c067?source=collection_archive---------4-----------------------#2021-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/61c2938a42c0d60c8a94f3cec39eb4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0q9DCaxh2IrL1DJg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@christiankaindl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Kaindl</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8e26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然大多数响应式设计都是使用CSS中的媒体查询来实现的，但通常有些部分必须使用JavaScript来实现。</p><p id="328b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用React，这并不总是像看起来那样简单，而且每当调整屏幕大小时，很容易陷入使用太多函数调用的陷阱。</p><p id="fc49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">诚然，用户在站点访问期间调整大小是一个比大多数开发人员认为的要少得多的问题，所以这不是一个很大的实际问题，但是我认为使用这个场景是一个很好的机会，可以有效地创建自定义的React挂钩。</p><p id="40e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给出的代码示例将使用TypeScript，但是因为只使用了相对简单的TypeScript特性，所以将其移植到JavaScript应该没什么问题。</p><p id="9438" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还要注意，我们假设<strong class="kc io">屏幕尺寸</strong>和<strong class="kc io">显示尺寸</strong>在本文中有稍微不同的含义:<strong class="kc io">屏幕尺寸</strong>将是用户的实际窗口尺寸，而<strong class="kc io">显示尺寸</strong>指的是一组预先确定的尺寸。<strong class="kc io">用户的显示尺寸将是最接近其屏幕尺寸的尺寸，向下取整。</strong></p><p id="7d1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从打基础开始。</p><h2 id="0de3" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">DisplaySize.enum.ts</h2><p id="9815" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们希望有预先确定的显示尺寸设置为灵活的可用性枚举。</p><p id="5282" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还手动设置它们的数值，以匹配适用于每个尺寸的最小屏幕宽度。以下是我使用的定义(多年来我发现的共同价值观的组合)，所以请随意使用相同的或定义你自己的。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">DisplaySize.enum.ts</figcaption></figure><h2 id="cc30" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">determineddisplaysize . ts</h2><p id="c8df" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">接下来，我们想要一个函数，给定一个特定的屏幕尺寸，它将返回相应的<code class="fe mc md me mf b">DisplaySize</code>。对于这种逻辑，我们认为从一个阈值开始的值直到但不包括该范围内的下一个值。例如，<code class="fe mc md me mf b">320</code>、<code class="fe mc md me mf b">380</code>和<code class="fe mc md me mf b">420</code>的屏幕尺寸都应该被认为是<code class="fe mc md me mf b">MobileS</code>，而<code class="fe mc md me mf b">425</code>应该是<code class="fe mc md me mf b">MobileM</code>。</p><p id="f1ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">热切的算法艺术家可能已经知道，对于给定的屏幕尺寸，确定显示尺寸的最有效方法是使用二分搜索法(半间隔搜索)。因为所有的大小都是已知的，所以我冒昧地将整个搜索算法输入如下:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">determineDisplaySize.ts</figcaption></figure><p id="440b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最大深度为3，最小深度为2。在变化的<code class="fe mc md me mf b">DisplaySize </code>定义的情况下，键入一个二分搜索法可能是优先的，只要记住我们是通过至少等于显示大小阈值的值<strong class="kc io">对节点分类进行分类。</strong></p><h2 id="0674" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">用户响应. ts</h2><p id="105e" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">好了，终于有人反应过来钩子的动作了！</p><p id="cbb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望钩子传递给使用它的组件的是组件应该适应的当前显示大小。也就是说，组件根本不关心实际的屏幕大小，只关心屏幕显示大小类别。</p><p id="1c5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们不希望钩子在必要的时候触发重注册。我们将使用<code class="fe mc md me mf b">useMemo</code>来限制钩子的输出，但是，没有办法在每次调整窗口大小时重新计算显示大小。</p><p id="b645" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们具体实施<code class="fe mc md me mf b">useResponsive </code>如下:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">useResponsive.ts</figcaption></figure><p id="daa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是怎么回事？让我们从头开始，一路走来。</p><p id="535d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们使用<code class="fe mc md me mf b">useState</code>来跟踪我们已经计算过的当前显示大小，我们从启动挂钩时根据窗口大小立即计算显示大小开始。</p><p id="d44f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，逻辑应该相当简单。</p><p id="00fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们使用<code class="fe mc md me mf b">useEffect</code>做两件事:</p><ol class=""><li id="8783" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx ml mm mn mo bi translated">在使用我们的钩子挂载任何组件时，我们设置了处理程序和侦听器。我们正在收听窗口大小调整，我们通过用新的计算值更新<code class="fe mc md me mf b">currentDisplaySize </code>状态字段来作出反应。我们通过使用空数组作为依赖列表来实现装载时的计时。</li><li id="8ce2" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">在卸载时，我们删除事件侦听器。我们通过让它成为<code class="fe mc md me mf b">useEffect</code>返回的一个函数来实现这一点。</li></ol><p id="e137" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，根据我们上面的定义，我们已经设置了一个保存当前显示大小的值，以及一个在调整窗口大小时自动更新该值的系统。</p><p id="39cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们返回用useMemo包装的<code class="fe mc md me mf b">displaySize</code>，其<code class="fe mc md me mf b">dependencyList</code>仅由<code class="fe mc md me mf b">displaySize</code>组成。这样，我们确保钩子只在计算出的<code class="fe mc md me mf b">displaySize</code>值实际改变时通知组件，而不会在屏幕尺寸调整没有导致设置新的<code class="fe mc md me mf b">DisplaySize</code>时通知组件。</p><p id="94d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，这种挂钩是在任何给定时间确定当前显示大小的一种性能化和反应性实现。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/d12aca7ce3e07277c0ea5da1ee7603cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bRc3pESZvFr2rpID"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b880" class="mv kz in bd la mw mx my ld mz na nb lg nc nd ne lj nf ng nh lm ni nj nk lp nl bi translated">使用</h1><p id="8568" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在组件中，我们像大多数其他钩子(不是数组)一样实例化:</p><pre class="lw lx ly lz gt nm mf nn no aw np bi"><span id="3c02" class="ky kz in mf b gy nq nr l ns nt">const displaySize = useResponsive();</span></pre><p id="4863" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用它来确定要返回的内容:</p><pre class="lw lx ly lz gt nm mf nn no aw np bi"><span id="7cbe" class="ky kz in mf b gy nq nr l ns nt">if (displaySize &lt; DisplaySize.MobileS) {<br/>  return &lt;div&gt;Size not supported&lt;/div&gt;;<br/>}</span></pre><p id="3d48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JSX直接使用:</p><pre class="lw lx ly lz gt nm mf nn no aw np bi"><span id="d514" class="ky kz in mf b gy nq nr l ns nt">&lt;div&gt;<br/>  { displaySize &gt;= DisplaySize.MobileM<br/>    ? &lt;div&gt;BIG TEXT!&lt;/div&gt;<br/>    : &lt;div&gt;small text :( &lt;/div&gt;<br/>  }<br/>&lt;/div&gt;</span></pre><p id="f4e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们将枚举值设置为预定的阈值，因此在计算中使用<code class="fe mc md me mf b">displaySize</code>作为数字是没有问题的。</p><p id="2b79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">但要注意的是</strong> <code class="fe mc md me mf b">displaySize !== screenSize</code> <strong class="kc io">！</strong></p><p id="a7ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际屏幕尺寸值始终等于或大于<code class="fe mc md me mf b">displaySize</code>！这是因为我们返回的数字总是立即低于我们的<code class="fe mc md me mf b">DisplaySize</code>列表中的屏幕尺寸。</p><p id="86ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还可以通过确定当前显示大小是否在两个阈值之间的函数来扩展用法，但是这种用法有点超出了本文的范围。请随意在评论中分享其他巧妙的用法！:)</p><p id="b39e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nu">更内容于</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5</a></p></div></div>    
</body>
</html>