<html>
<head>
<title>Meet Snabbdom: A Low-Level Library for Building Virtual DOMs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认识Snabbdom:一个用于构建虚拟dom的低级库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/snabbdom-8a1fa7f9105d?source=collection_archive---------3-----------------------#2021-10-01">https://javascript.plainenglish.io/snabbdom-8a1fa7f9105d?source=collection_archive---------3-----------------------#2021-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67a3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Snabbdom入门:渲染、更新、钩子等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbe5804262f1277d2c4a4bfc06905148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBrSW1uhzBMcnBPyh7FTXQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Credits: <a class="ae kv" href="https://github.com/snabbdom/snabbdom" rel="noopener ugc nofollow" target="_blank">Snabbdom on GitHub</a></figcaption></figure><p id="4f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Snabbdom是一个非常小但功能强大的虚拟dom。另一个虚拟DOM？React和其他的还不够吗？</p><p id="e516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然像React这样的库的方法是提供一种随时可用的体验，但这并不是Snabbdom的初衷。你马上就会在语法中看到它。</p><p id="b685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Snabbdom更像一个虚拟dom，提供了在其上构建的选项。比如Vue.js，就是建立在Snabbdom之上的。在官方的GitHub repo中，列出了许多其他使用Snabbdom的库和框架。</p><p id="161f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Snabbdom之上进行构建是可能的，因为它具有非终结化、简单和可扩展的代码编写方式。准备好学习这个迷人的底层虚拟DOM的基础知识了吗？</p><h1 id="1dc7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="2c1f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于Snabbdom是一个库，而不是一个像React或Vue那样具有CLI的完整生态系统，我们将构建一个普通的JS设置。我会用Vite，因为它超级快而且容易使用。之前不需要安装任何东西。</p><p id="a92e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是如何开始:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7428" class="mu lt iq mq b gy mv mw l mx my">yarn create vite virtual-dom --template vanilla</span><span id="ef1f" class="mu lt iq mq b gy mz mw l mx my">// or: </span><span id="6091" class="mu lt iq mq b gy mz mw l mx my">// NPM 6.x: </span><span id="3be9" class="mu lt iq mq b gy mz mw l mx my">npm init vite@latest my-vue-app --template vue</span><span id="e1b3" class="mu lt iq mq b gy mz mw l mx my">// NPM 7.x: </span><span id="216c" class="mu lt iq mq b gy mz mw l mx my">npm init vite@latest virtual-dom -- --template vue</span></pre><p id="993e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NPM的双破折号并不是一个错误。创建的目录将被称为“虚拟dom”。一旦Vite完成了设置，你就可以进入并安装需要的东西了。</p><p id="d690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在index.html，我们只有最简单的设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0bc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe na nb nc mq b">npm run dev</code>或<code class="fe na nb nc mq b">yarn run dev</code> Vite的开发服务器默认应该是链接的。所以，一定要运行它。</p><p id="f536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们编写一个最小的组件并将其呈现给DOM。<br/>我先给你看代码，然后给你解释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2157" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们忽略补丁函数的导入和初始化。这只是默认的东西。</p><p id="fec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个有趣的部分是容器变量。几乎在所有使用虚拟DOM的库中，我们都需要DOM中的根元素。这是我们的组件安装的地方。变量<code class="fe na nb nc mq b">container</code>正是这个根。</p><p id="bc0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Snabbdom中DOM中的所有元素都是使用一个名为“h”的函数创建的。你可能从Preact中知道这个函数。我们的组件实际上由两个DOM元素组成。对于每一个，我们称之为“h”函数。该函数采用以下参数:</p><ul class=""><li id="ee92" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">HTML标签或与CSS选择器结合的标签(为元素提供类或id)</li><li id="d6dc" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">可选项:包含对象的对象，例如事件或内联样式。</li><li id="9463" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">可选:更多DOM元素的数组，每个元素作为一个“h”函数调用。</li></ul><p id="33f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们的div有一个子元素——段落。</p><p id="feab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了挂载DOM中的每个组件，我们需要将它放入patch函数中(仍然在上面的代码示例中)。</p><p id="5091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您应该在DOM中看到呈现的组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/8aac615a0ee9fbb6c31b01c51a338cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0khb6OzeMEhj4kUiyvLFA.png"/></div></div></figure><p id="e64d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经涵盖了绝对的基础知识。让我们更详细地讨论一下</p><h1 id="9431" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理事件</h1><p id="3d74" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">提供应该触发的事件很容易。如前所述，事件属于Snabbdom组件的options对象。在这个对象中，我们可以定义一个新的对象，作为“on”的子对象，也就是说，我们希望监听这个元素上的动作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，每当单击这个按钮时，就会执行函数“clickHandler”。</p><p id="aaef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，我们希望在事件处理函数中传递参数。然而，<code class="fe na nb nc mq b">click: clickHandler(argument)</code>将立即执行该功能。您可能从React中知道这个“问题”。</p><p id="a342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要做的是传递一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您单击按钮时，传递参数并记录下来就可以了。</p><h1 id="c7ad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更新DOM</h1><p id="ac86" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们刚刚学习了处理事件，我们可以用它来更新我们的DOM。正如你从Vue、React或Angular中所知，有一种东西我们称之为状态。每当这种状态改变时(例如，计数器变量)，依赖于它的UI组件会自动更新。这也是我们想要实现的目标。</p><p id="e0f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新一些DOM元素很容易——我们使用“补丁”功能。<br/>我们以前用过这个功能。是时候了解它是如何工作的了。</p><p id="9337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mq b">patch</code>需要两个参数:</p><ul class=""><li id="d8e5" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第一个是VDOM节点，代表当前视图</li><li id="0ae3" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第二个是代表更新视图的VDOM节点</li></ul><p id="a8f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还记得我们通过Snabbdom在DOM中呈现一个div并检查它在浏览器中的外观吗？</p><p id="2d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的HTML文件中硬编码的原始div容器不见了:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="455d" class="mu lt iq mq b gy mv mw l mx my">&lt;div id="container"&gt;&lt;/div&gt;</span></pre><p id="25b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在它上面使用了补丁，VDOM节点没有被附加，而是替换了容器。</p><p id="d488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，如果我们想要更新一个值已经改变的DOM元素，我们用patch替换当前的元素。为了生成刷新的组件，我们可以使用一个函数——它返回我们的VDOM节点。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="61b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的函数“component”生成一个div，包装一个按钮和一个p标签，显示“counter”变量。当我们点击按钮时，计数器增加。然后，新视图生成并存储在变量<code class="fe na nb nc mq b">newVnode</code>中。为了更新可见的DOM，我们覆盖了现有的容器并用新的组件视图修补它。</p><h2 id="e844" class="mu lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">使用事件值更新</h2><p id="63ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们刚刚学习了处理事件，我们可以用它来更新我们的DOM——使用事件目标值。这对于更新文本很有效。<br/>除了对DOM节点中的点击事件做出反应，我们还可以处理用户输入——至少在像<code class="fe na nb nc mq b">&lt;input /&gt;</code>这样的元素中。</p><p id="e4dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用事件处理函数时，默认情况下，事件对象作为参数传递。例如，它包含输入字段的当前状态。您可能从React中了解到它，我们也可以在这里使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您在浏览器中打开它时，应该可以正常工作。如果您在浏览器开发工具中打开elements-inspector，您可以看到一些有趣的东西。每当您在输入字段中输入内容时，整个组件都不会重新呈现。只有必要的部分，在我们的情况下，段落，是。</p><h1 id="41b3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从DOM中移除我们的元素</h1><p id="162c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与挂载一样，卸载也使用补丁功能。<br/>让我们将它应用于DOM中现有的组件。</p><p id="c53e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了查看从DOM中删除它的操作，我将卸载代码设置为超时，耗时3秒:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d4a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。我们用“！”来修补DOM中现有的组件这使得Snabbdom明白我们想要卸载我们的元素。</p><h1 id="f6ea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">钩住</h1><p id="d952" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">就像在React中一样，从你可能知道的地方，钩子正在钩入一些组件进程。例如安装、更新或卸载。</p><p id="3555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，Snabbdom中有10个钩子可用。因为它们都以几乎相同的方式工作，所以我们现在关注其中的一个:更新钩子。</p><p id="685e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们的组件更新时，就会触发更新挂钩。我们知道，更新是通过补丁函数提交的。为了实现钩子，我们重用了输入字段的例子。我们需要添加的只是组件选项中的<code class="fe na nb nc mq b">hook</code>对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ef27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当您在文本字段中键入内容时，我们之前编写的输入处理程序都会通过重新运行组件函数来更新DOM。因为Snabbdom很聪明，所以它只更新必要的内容——段落。</p><p id="5e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经进入了更新过程，所以每当文本字段中的输入发生变化时，就会运行console.log。</p><p id="4592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>