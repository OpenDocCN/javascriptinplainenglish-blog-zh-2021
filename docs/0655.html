<html>
<head>
<title>Immer.js 101 — Making Redux state updates in React predictable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Immer.js 101 —使React中的Redux状态更新可预测</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/immer-js-101-making-redux-state-updates-in-react-predictable-62efe93e03dc?source=collection_archive---------8-----------------------#2021-02-10">https://javascript.plainenglish.io/immer-js-101-making-redux-state-updates-in-react-predictable-62efe93e03dc?source=collection_archive---------8-----------------------#2021-02-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1d6bfdc9237f3fe9cf780c7f1a8862d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dH4K-dV1gGVREGGYCLmW7A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@altumcode" rel="noopener ugc nofollow" target="_blank">Altum</a> on <a class="ae jz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1393" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为什么是Redux？为什么是Immer？</h1><p id="9c2b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你要么恨，要么爱Redux。我绝对是一个热爱Redux的人，但老实说，在每个项目中都使用它是没有必要的。如果你只是在做一个原型或者一个小的app——最好用钩子和状态。</p><p id="10e2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">虽然，从我的经验来看，每一个商业化的产品都会成长。新功能意味着需要管理更大的州。在设计应用程序架构时，最好记住你最终将拥有一个大的状态。例如，我们的主要React应用程序有超过90k行代码，使用API调用，WebSockets和state拥有包含数百个对象的数组。我甚至无法想象没有Redux该如何处理这件事。</p><p id="b7fe" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">也就是说——如果由没有经验的开发人员使用，Redux可能是危险的。最大的问题之一是在Redux中管理状态不变性。但是一个更复杂的问题是，由于reducers中的错误，导致组件不必要的重新渲染。一个简单的解决方案是Immer。让我们深入探讨一下不变性/重渲染的问题，然后我将向你展示我个人如何利用Immer的方法。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="0fcf" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">Redux中常见的不变性问题</h1><p id="2397" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们把重点放在reducers上，因为这应该是状态改变的唯一地方。Reducers非常简单——不改变状态，返回一个新状态。</p><h2 id="24e8" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">直接突变状态</h2><p id="96c8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个很明显。不对状态进行任何操作，例如:</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Don’t do this!</figcaption></figure><p id="de79" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">因为我们是对原始状态进行变异，然后再返回它— Redux不会识别任何变化。因此，连接到商店<strong class="la io">这一部分的组件不会</strong>更新。Redux将新状态与旧状态进行比较(reducer函数中的第一个参数)。所以，减速器的功能必须永远是一个<strong class="la io">的纯功能。为了避免任何类似的错误，你也应该在reducer </strong>函数中使用<strong class="la io">纯函数。下面是一个纯函数的例子。</strong></p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Just to be sure we are on the same page with pure functions</figcaption></figure><h2 id="dc89" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">不必要的重新渲染</h2><p id="a40d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个不那么明显，这个错误我看了很多次。我在无数的React教程里见过。有坏的，也有好的！让我们看看下面的例子:</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">This is really a common mistake!</figcaption></figure><p id="5a0b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，明确一点，使用过滤函数完全没问题。它创建并返回状态的副本。但是状态的<strong class="la io">副本导致了一个问题。Redux每次都做<strong class="la io">浅</strong>比较。简单来说，这些是<strong class="la io">不同的对象，因为过滤器正在复制</strong>。同样的道理也适用于贴图，还原等等。</strong></p><p id="a97c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">那为什么要肤浅的比较呢？嗯，Redux团队认为，每次进行深度比较都会对资源提出很高的要求。这是合乎逻辑的，我对此没有异议。</p><p id="ebd4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">此外，如果您的应用程序很小，这可能不是一个大问题(也许这就是为什么教程有这个错误？你怎么想呢?)但是在有数百个组件连接到Redux和更新状态的API调用的应用程序中，这变得很严重。对于大规模应用程序，你不能承担无用的重新渲染。这在<strong class="la io"> React原生应用中尤其令人沮丧，可能会大幅降低性能。</strong></p><p id="a492" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，为了解决这个问题，我们可以使用一些简单的重构:</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Some defensive programming in action</figcaption></figure><p id="d615" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">没什么极端的，对吧？通过一些规则和防御性编程，我们确保状态只在必要时更新。现在是介绍Immer的好时机。</p><h1 id="031f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">伊梅尔来了！</h1><p id="85b5" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">Immer已经是一个完善的库了。每周近600万次下载(根据NPM—2021年1月)，100%的代码覆盖率，+100名贡献者，19k GitHub明星。这些数字令人印象深刻。更令人印象深刻的是，Immer被评为2019年JavaScript开源“最具影响力贡献”和“年度突破”React开源奖。</p><h2 id="9e42" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">Immer真的是React的突破吗？</h2><p id="eb72" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">不要误解我——我爱Immer。然而，它不是一个可以毫不费力地解决所有问题的魔法库。它需要遵循一些模式——如果不小心使用的话，不会让你免于不必要的状态更新。不需要额外的库，你自己也可以达到同样的效果。然而，Immer提倡最佳实践、干净的代码并减少代码重复。在我看来，它是任何React+Redux app中的必备。</p><h2 id="3789" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">Immer如何工作</h2><p id="e856" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">出奇的简单。Immer中的主要功能是<strong class="la io">产生</strong>。<strong class="la io">T5有两个参数，<strong class="la io">状态</strong>和回调函数，回调函数有<strong class="la io">草稿</strong>(状态的)。在回调函数中，我们直接对草稿</strong>进行修改<strong class="la io">。然后，Produce比较差异并生成<strong class="la io"> nextState </strong>。</strong></p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/b2532e9c88842ef8bafd7a4a3829b356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jlmsx2doan2aDLYTkCxrPw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://immerjs.github.io/immer/img/immer.png" rel="noopener ugc nofollow" target="_blank">https://immerjs.github.io/immer/img/immer.png</a></figcaption></figure><p id="803f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们看看Immer是如何用于减速器的:</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8011" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在关注<strong class="la io"> myReducer </strong>函数。我们在这里使用的概念叫做<a class="ae jz" href="https://javascript.info/currying-partials" rel="noopener ugc nofollow" target="_blank">逢迎</a>。这不是必须的，有其他的使用Immer的方法——但是我更喜欢这个。它清楚地显示了正在发生的事情。我们用<strong class="la io">扩展一个减速器产生</strong>功能。在produce中，我们使用回调函数直接对草稿进行操作。我喜欢把我的减速器限制在简单的开关箱使用。在每种情况下，我都会返回在草稿上做必要工作的函数。重要的是——我们不必退回汇票！因此，我不使用默认大小写，尽管添加了:</p><pre class="mz na nb nc gt ng nh ni nj aw nk bi"><span id="5b2f" class="mn kb in nh b gy nl nm l nn no">default: return draft; / return;</span></pre><p id="c4eb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这很好——但没有必要。我将在文章的最后讨论大多数场景。</p><h2 id="7c84" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">奖励:为Immer调整商店</h2><p id="98d9" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在深入实际场景之前，让我和音麦分享我的经验。我认为Immer最适合使用 <a class="ae jz" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" rel="noopener ugc nofollow" target="_blank"> <strong class="la io">正常化状态</strong> </a> <strong class="la io">或者简单的地图。</strong>在一系列复杂的API对象上使用Immer是可能的，但有时会令人沮丧。尤其是对于嵌套的对象数组。标准化状态解决了我们在生产质量反应应用中面临的许多问题(复制、容易访问和更新对象等)。).然而，这不是必须的，我将涵盖数组和对象(地图)。</p><h1 id="2dd0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用Immer的减速器中最常见的场景</h1><h2 id="4038" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">沉浸在标准化状态/对象中</h2><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Immer with normalized state</figcaption></figure><p id="f4f2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">该守则相当不言自明。方法清晰易懂。我喜欢保持减速器尽可能小。</p><p id="e505" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">updateObject</strong>——在他的方法中我们有点懒惰，我们不检查对象是否真的改变了——我们覆盖它。归一化状态有一个显著的优势，访问/写入/删除有<a class="ae jz" href="https://dev.to/adafia/brief-performance-analysis-of-arrays-and-objects-through-the-lens-of-big-o-notation-4id3" rel="noopener ugc nofollow" target="_blank">大O(1) </a>。这取决于您是否需要一些工具来检查对象是否不同。</p><p id="93e4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">updateObjectStatus</strong>——也许hasObject是不必要的，但是我添加了这个以便于理解。首先，我们检查这个对象是否已经处于状态。如果是，我们会更新状态属性。酷的是，Immer会将草稿与状态进行比较——如果状态是相同的(比如说“完成”)，它就不会更新状态。</p><p id="ce6e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io"> deleteObject </strong> —这个很明显:)delete非常有用，我们不需要检查state是否有这个id。</p><p id="4173" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">AT病例。RESET _ OBJECT</strong>——我已经说过了，我们不需要返回草稿，生产函数也不需要它。但是，如果我们想重置或使状态为空呢？然后，我们退回新的汇票。在这种情况下，初始状态。</p><p id="a3e0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">replacewwithinnewobjects</strong>——现在假设我们从API接收到了全新的状态。也许很少有项目是相同的，但是我们已经决定，通过这个特别的行动，我们将取代国家。在这种情况下，使用我的utils函数，我们创建一个新的状态(与规范化状态一致)并返回它。因为我们没有对草稿进行任何操作，所以我只将有效载荷传递给replaceWithNewObjects函数。</p><h2 id="676c" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">带阵列的Immer</h2><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Immer with array of objects</figcaption></figure><p id="6b3d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">乍一看，我们可以看到标准化状态相对于对象数组的优势。我们几乎每次都需要对大O(n)进行操作，以检查对象是否处于状态。我认为代码很清楚，不需要额外的解释。:)如果您不这么认为，有一些问题——请留言评论！我会更新这篇文章。</p><h1 id="5e9e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">包扎</h1><p id="2b0e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">使用Immer一开始可能是违反直觉的——因为我们改变了draft。从我的经验来看，使用带有规范化状态的Immer，在代码简洁、可读性和控制状态方面效果最好。</p><p id="a1b2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">没有Immer我们能有同样的效果吗？当然可以！这取决于你。然而，它是添加到项目中的另一个库和依赖项。</p></div></div>    
</body>
</html>