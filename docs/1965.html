<html>
<head>
<title>How to Run the useEffect React Hook Callback Only on State Update?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何只在状态更新时运行useEffect React钩子回调？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-run-the-useeffect-react-hook-callback-only-on-state-update-9062be0b6bcc?source=collection_archive---------11-----------------------#2021-04-24">https://javascript.plainenglish.io/how-to-run-the-useeffect-react-hook-callback-only-on-state-update-9062be0b6bcc?source=collection_archive---------11-----------------------#2021-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a479d761d5d2825ef480dfc7a126ce85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2kVZ66RzIxvrldE8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@magnetme?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Magnet.me</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="463f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">钩子让我们观察状态和道具的值，并根据它们的值做一些事情。</p><p id="12e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时我们可能只想在状态值更新后运行<code class="fe lb lc ld le b">useEffect</code>回调。</p><p id="ffcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何仅在状态值更新时运行<code class="fe lb lc ld le b">useEffect</code>钩子回调。</p><h1 id="7b5e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">仅在状态更新时运行useEffect React挂钩回调</h1><p id="14b7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了只在状态更新时运行<code class="fe lb lc ld le b">useEffect</code>钩子回调，我们可以创建一个ref来跟踪状态更新的时间。</p><p id="d546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1d99" class="mq lg iq le b gy mr ms l mt mu">import { useEffect, useRef, useState } from "react";</span><span id="51e6" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const isInitialMount = useRef(true);<br/>  const [count, setCount] = useState(0);</span><span id="8d44" class="mq lg iq le b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    if (isInitialMount.current) {<br/>      isInitialMount.current = false;<br/>    } else {<br/>      console.log(count);<br/>    }<br/>  });</span><span id="9dad" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;form&gt;<br/>      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;increment&lt;/button&gt;<br/>    &lt;/form&gt;<br/>  );<br/>}</span></pre><p id="d59b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用最初设置为<code class="fe lb lc ld le b">true</code>的<code class="fe lb lc ld le b">useRef</code>钩子创建<code class="fe lb lc ld le b">isInitialMount</code> ref。</p><p id="45b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了<code class="fe lb lc ld le b">count</code>状态，我们只希望在<code class="fe lb lc ld le b">count</code>更新时记录它。</p><p id="8a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">useEffect</code>回调中，我们检查的是<code class="fe lb lc ld le b">isInitialMount.current</code>是<code class="fe lb lc ld le b">true</code>。</p><p id="cbb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是<code class="fe lb lc ld le b">true</code>，那么我们将<code class="fe lb lc ld le b">initialMount.current</code>设置为<code class="fe lb lc ld le b">false</code>。</p><p id="6875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">引用是非反应性的，因此不会导致组件的重新渲染。</p><p id="ee9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而,<code class="fe lb lc ld le b">current</code>值在渲染中持续存在。</p><p id="c464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe lb lc ld le b">isIninitialMount.current</code>为<code class="fe lb lc ld le b">false</code>时，我们记录<code class="fe lb lc ld le b">count</code>的值。</p><p id="7d40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那下面，我们有一个按钮，当我们点击它时，它调用<code class="fe lb lc ld le b">setCount</code>来更新<code class="fe lb lc ld le b">count</code>值。</p><p id="414a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们单击增量按钮时，我们看到<code class="fe lb lc ld le b">count</code>从1开始记录，这意味着它的更新超过了初始值。</p><p id="13e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将逻辑提取到它自己的钩子中。</p><p id="9ee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0a93" class="mq lg iq le b gy mr ms l mt mu">import { useEffect, useRef, useState } from "react";</span><span id="8177" class="mq lg iq le b gy mv ms l mt mu">const useUpdateEffect = (effect, dependencies = []) =&gt; {<br/>  const isInitialMount = useRef(true);</span><span id="02ac" class="mq lg iq le b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    if (isInitialMount.current) {<br/>      isInitialMount.current = false;<br/>    } else {<br/>      effect();<br/>    }<br/>  }, dependencies);<br/>};</span><span id="898d" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  const [count, setCount] = useState(0);</span><span id="fc45" class="mq lg iq le b gy mv ms l mt mu">  useUpdateEffect(() =&gt; {<br/>    console.log(count);<br/>  }, [count]);</span><span id="0b47" class="mq lg iq le b gy mv ms l mt mu">  return (<br/>    &lt;form&gt;<br/>      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;increment&lt;/button&gt;<br/>    &lt;/form&gt;<br/>  );<br/>}</span></pre><p id="bcd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有接受<code class="fe lb lc ld le b">effect</code>函数的<code class="fe lb lc ld le b">useUpdateEffect</code>钩子，当<code class="fe lb lc ld le b">dependencies</code>数组中的任何内容发生变化时，我们希望运行这个钩子。</p><p id="caf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lb lc ld le b">isInitialMount</code> ref移动到钩子上。</p><p id="9ebd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们在<code class="fe lb lc ld le b">useUpdateEffect</code>钩子中调用<code class="fe lb lc ld le b">useEffect</code>而不是<code class="fe lb lc ld le b">App</code>组件。</p><p id="9635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以轻松地在任何地方重用逻辑。</p><h1 id="8332" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2504" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以添加一个ref来跟踪一个组件何时被更新，当它更新时，运行我们想要的回调代码。</p><p id="7313" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们只在组件更新时运行<code class="fe lb lc ld le b">useEffect</code>回调。</p><p id="c28a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容尽在</em><a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>