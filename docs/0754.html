<html>
<head>
<title>Vector rendering of SVG content with PixiJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PixiJS对SVG内容进行矢量渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vector-rendering-of-svg-content-with-pixijs-6f26c91f09ee?source=collection_archive---------3-----------------------#2021-02-16">https://javascript.plainenglish.io/vector-rendering-of-svg-content-with-pixijs-6f26c91f09ee?source=collection_archive---------3-----------------------#2021-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e6cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍基于WebGL的最丰富、最快速的SVG解决方案之一</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d69081a10d8462fcaa338c00df099045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VY2ml6cfuQ9T2D1LHJxJBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">By Jooja — This file was derived from: Fonalgrafika virag minta hurok varras.jpg:, CC BY-SA 3.0, <a class="ae kv" href="https://commons.wikimedia.org/w/index.php?curid=96183982" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=96183982</a></figcaption></figure><p id="000b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SVG是存储矢量内容的实际解决方案，能够在2D WebGL内容中使用它非常有用。这是渲染设计中所需的小图标的最佳解决方案！在这里，我将介绍一个新的SVG库，它支持更广泛的特性集，并针对高性能渲染进行了调整。</p><h1 id="84d7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍@pixi-essentials/svg</h1><p id="36d4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/SukantPal/pixi-essentials/tree/master/packages/svg" rel="noopener ugc nofollow" target="_blank"> @pixi-essentials/svg </a>提供了一个简单易用的API，用于在PixiJS中构建svg场景:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8264" class="mu lt iq mq b gy mv mw l mx my">import { SVGScene } from '@pixi-essentials/svg';</span><span id="593b" class="mu lt iq mq b gy mz mw l mx my">const svgMarkup = await fetch("&lt;svg_url&gt;")<br/>  .then((data) =&gt; data.json());<br/>const svgDOM = new DOMParser().parseFromString(svgMarkup, "image/svg+xml");<br/>const svgEl = svgDOM.documentElement;</span><span id="7b1d" class="mu lt iq mq b gy mz mw l mx my">// Here's the fun<br/>const scene = new SVGScene(svgEl);</span></pre><p id="8abc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个SVG场景是一个简单的<code class="fe na nb nc mq b">DisplayObject</code>,可以安装在应用程序主场景的任何地方。</p><p id="d73b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前的解决方案，如pixi-svg、pixi-svg-graphics、pixi5-svg和svgatlas都是较小的库，具有较少的功能集支持或更多的错误。我需要完整的SVG原生规范和更好的性能——这正是@pixi-essentials/svg所能提供的。</p><p id="992e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大的特点是变换、文本、蒙版、渐变、<use>和<image>。这个库也被设计成可扩展的SVGScene保存了一个显示对象图，这些对象与每个SVG元素有一对一的映射。这允许您覆盖每个SVG元素的建模方式。</image></use></p><p id="105a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">@pixi-essentials/svg中使用的关键优化是内置剔除和共享纹理。当在可平移和可缩放的相机中使用时，SVGScene可以比基于DOM的解决方案快得多。这是因为浏览器不会针对DOM上使用的任意转换进行优化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Rendering a diagram from Wikipedia using @pixi-essentials/svg</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="0967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">一个人在家无聊的编码？检出一个</em> <a class="ae kv" href="https://www.kumospace.com/blog/virtual-workspace" rel="noopener ugc nofollow" target="_blank"> <em class="nm">虚拟工作区</em> </a> <em class="nm">并聚在一起。</em></p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="a65a" class="ls lt iq bd lu lv nn lx ly lz no mb mc jw np jx me jz nq ka mg kc nr kd mi mj bi translated">场景结构</h1><p id="efed" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">1.0版本以同步方式立即填充场景图形。每个SVG元素都被映射并“嵌入”到一个SVG呈现“节点”中。</p><p id="8782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在自定义场景图形之前，您需要了解它是如何生成的:</p><ul class=""><li id="64f6" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated"><code class="fe na nb nc mq b">populateScene</code> —这是整个过程开始的地方。如果需要的话，它将拆除场景图形的任何先前状态。</li><li id="924e" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe na nb nc mq b">populateSceneRecursive</code> —这最初是对根<code class="fe na nb nc mq b">SVGSVGElement</code>的调用，随后贯穿整个SVG DOM。</li><li id="d4b9" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe na nb nc mq b">createNode</code>为传递的元素创建一个节点，然后<code class="fe na nb nc mq b">embedIntoNode</code>将调用适当的特定于节点的API来嵌入元素。</li></ul><p id="cedc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">灵活性最大的点是<code class="fe na nb nc mq b">createNode</code>。对于特定的元素，您可以覆盖它并返回您的自定义节点。当您想要添加交互或动画时，这可能会很有用。</p><p id="4d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下示例旋转图标元素，并使用<a class="ae kv" href="https://api.pixijs.io/@pixi-essentials/transformer/Transformer.html" rel="noopener ugc nofollow" target="_blank">变形器</a>使其可拖动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Customizing a SVG scene graph to add animations and interactivity</figcaption></figure><h1 id="16de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">特征</h1><h2 id="4cc7" class="mu lt iq bd lu og oh dn ly oi oj dp mc lf ok ol me lj om on mg ln oo op mi oq bi translated">梯度</h2><p id="5fc8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">渐变被实现为“画图服务器”，它懒洋洋地为纹理提供栅格化的渐变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="bcad" class="mu lt iq bd lu og oh dn ly oi oj dp mc lf ok ol me lj om on mg ln oo op mi oq bi translated">面具</h2><p id="2283" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">遮罩被实现为“渲染服务器”，这是绘画服务器的一个更一般化的变体。该场景在顶层保留了一个可以由节点共享的“服务器场”。</p><p id="2551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遮罩服务器通过L2R滤镜过滤嵌入遮罩的内容，该滤镜将输入的亮度存储到输出的红色通道中。生成的纹理被用作带有像素的精灵遮罩滤镜。</p><p id="7c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我不得不承认，面具现在有点参差不齐。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="0e87" class="mu lt iq bd lu og oh dn ly oi oj dp mc lf ok ol me lj om on mg ln oo op mi oq bi translated">文本</h2><p id="cfc5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><text>和<tspan>元素被排除在SVG本地规范之外。但是，@pixi-essentials/svg仍然支持它们，因为它们被广泛使用。</tspan></text></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Hello world! svg</figcaption></figure><p id="9b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内置的文本引擎使用Canvas2D API来栅格化字形。您可以通过实现<a class="ae kv" href="https://api.pixijs.io/@pixi-essentials/svg/SVGTextEngine.html" rel="noopener ugc nofollow" target="_blank"> SVGTextEngine </a>接口并将其设置为<a class="ae kv" href="https://api.pixijs.io/@pixi-essentials/svg/SVGTextNode.html#defaultEngine" rel="noopener ugc nofollow" target="_blank"> defaultEngine </a>来插入您自己的文本解决方案。</p><h1 id="32a9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最佳化</h1><p id="59ce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">@pixi-essentials/svg采用了三大优化，使其速度超快:</p><ul class=""><li id="e655" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">剔除:内部场景图形剔除每一帧，这样屏幕外的任何内容都不会被渲染。这对于较大的SVG文件非常重要。</li><li id="8b06" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">纹理图集:节点共享一个<a class="ae kv" href="https://api.pixijs.io/@pixi-essentials/texture-allocator/CanvasTextureAllocator.html" rel="noopener ugc nofollow" target="_blank">canvastexturelocator</a>来存储静态光栅化内容。当您的SVG文件中有多个&lt;图像&gt;元素时，这很有用。</li><li id="873c" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">惰性转换更新:默认情况下，PixiJS在所有显示对象上调用<code class="fe na nb nc mq b">updateTransform</code>。然而，SVG场景图对此是“屏蔽的”,只有在转换无效时才会更新。这发生在一个节点触发一个<code class="fe na nb nc mq b">nodetransformdirty</code>事件时(这又在场景本身上触发一个<code class="fe na nb nc mq b">transformdirty</code>事件)。</li></ul><p id="e38b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为SVG场景图是相对静态的，所以它的边界随着它的变换而更新。这意味着你可以依赖<code class="fe na nb nc mq b">node._bounds</code>有效，完全跳过<code class="fe na nb nc mq b">getBounds()</code>！这在对SVG场景进行自定义点击测试时非常有用。</p><h1 id="74c3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进一步发展</h1><p id="64ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">@pixi-essentials/svg还很年轻，在很多情况下可能会产生不正确的结果。请随意在<a class="ae kv" href="https://github.com/SukantPal/pixi-essentials/issues" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上报告这些。</p><p id="a196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">未来的版本可能还包括在空闲期间异步填充场景图形，更好的遮罩和文本质量。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="7ac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文展示的也是一个SVG！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="127f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">嘿大家好，我是</em><a class="ae kv" href="https://github.com/SukantPal/pixi-essentials" rel="noopener ugc nofollow" target="_blank"><em class="nm">PixiJS Essentials Kit</em></a><em class="nm">的作者，也是pix ijs项目的维护者。在Twitter上关注我，获取更多我的内容！</em></p><p id="d21d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://twitter.com/ShukantP" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ShukantP</a></p></div></div>    
</body>
</html>