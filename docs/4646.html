<html>
<head>
<title>A react-hook-form TypeScript Ready Hook with Yup Validator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个带有验证器的react-hook-form类型脚本就绪钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-react-hook-form-typescript-ready-hook-with-yup-validator-3e5b9e0bd90e?source=collection_archive---------2-----------------------#2021-09-16">https://javascript.plainenglish.io/a-react-hook-form-typescript-ready-hook-with-yup-validator-3e5b9e0bd90e?source=collection_archive---------2-----------------------#2021-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e18e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">代码片段</h2><div class=""/><div class=""><h2 id="68ef" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">厌倦了每次导入yup并定义与验证模式匹配的接口吗？用这个特殊的钩子</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/cc9237a5bdc8f086ba14f70f6b4ef7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McS8n3EnHE39vlelH8Zdcw.png"/></div></div></figure><p id="b581" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">React hook form是React和react native构建表单的最具性能和灵活性的框架之一。尽管yup是验证数据结构的最简单和最好的库之一，但是通过将两者结合起来，你会得到一个很好的工作流程，我强烈建议你尝试一下。</p><p id="375c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在意识到我每次都在复制相同的代码后，我最终创建了这两个挂钩，以便在react应用程序中快速创建一个带有验证的表单。</p><p id="dd3c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我在想:</p><ul class=""><li id="8332" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">为什么我必须在表单的每个组件中导入<code class="fe mf mg mh mi b">yup</code>？除了<code class="fe mf mg mh mi b">yup</code>自动导入跟TS相当破。</li><li id="b820" class="lw lx iq lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated">如何才能少写代码，利用TypeScript类型推断？</li></ul><p id="99b1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后，我编写了那些受益于TypeScript类型推断的代码片段，以提供自动完成和类型安全。</p><h1 id="11ba" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">代码片段</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="f261" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">用法示例</h1><p id="bdaa" class="pw-post-body-paragraph la lb iq lc b ld ni ka lf lg nj kd li lj nk ll lm ln nl lp lq lr nm lt lu lv ij bi translated">没有什么真正复杂的，所以只是复制上面的片段并尝试使用它，它有两种不同的格式，每一个都有自己的目的。</p><p id="141a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请注意，您不需要向“useform”参数传递解析器，因为如您所见，它将被代码片段覆盖。</p><p id="2920" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里真正的价值在于Typescript类型推断，它提供了很好的自动完成和类型安全性</p><h2 id="6fcd" class="nn mp iq bd mq no np dn mu nq nr dp my lj ns nt na ln nu nv nc lr nw nx ne iw bi translated">使用已经存在的模式</h2><pre class="kp kq kr ks gt ny mi nz oa aw ob bi"><span id="cede" class="nn mp iq mi b gy oc od l oe of">import * as yup from "yup";</span><span id="7519" class="nn mp iq mi b gy og od l oe of">const schema = yup.object({<br/>  quantity: yup.number().min(props.minQuantityDynamic)<br/>})</span><span id="05ba" class="nn mp iq mi b gy og od l oe of">const MyComponent: React.FC = () =&gt; {<br/>  const { register } = useFormWithSchema(formSchema);</span><span id="f41d" class="nn mp iq mi b gy og od l oe of">// …<br/>}</span></pre><h2 id="247d" class="nn mp iq bd mq no np dn mu nq nr dp my lj ns nt na ln nu nv nc lr nw nx ne iw bi translated">使用构建器</h2><p id="ad6e" class="pw-post-body-paragraph la lb iq lc b ld ni ka lf lg nj kd li lj nk ll lm ln nl lp lq lr nm lt lu lv ij bi translated">如果您还没有一个模式，并且不想到处导入，请使用factory builder函数。此外，这允许玩动态验证。</p><p id="7c37" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样做的性能代价很小，因为每次都要重新渲染，所以每次都要构建一个新的模式。你可以考虑另一种方法。</p><pre class="kp kq kr ks gt ny mi nz oa aw ob bi"><span id="1477" class="nn mp iq mi b gy oc od l oe of">const { register } = useFormWithSchemaBuilder((yup) =&gt; yup.object({<br/>  quantity: yup.number().min(props.minQuantityDynamic)<br/>}));</span></pre></div></div>    
</body>
</html>