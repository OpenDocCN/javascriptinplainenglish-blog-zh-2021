# 如何避免纯函数在 JavaScript 中的副作用

> 原文：<https://javascript.plainenglish.io/how-to-avoid-side-effects-using-pure-functions-in-javascript-366acaafb60c?source=collection_archive---------0----------------------->

![](img/94aa3b738513cfb2d4e2fc725552eb16.png)

Photo by [Dan Hadley](https://www.pexels.com/@dan-hadley-360599) from [Pexels](https://www.pexels.com/photo/wood-light-sun-park-5971210/)

*想象我们写一个程序，保存关于用户购买历史的信息，比如用户通过移除一个项目来修改数据，如果部分信息丢失，我们就改变了数据。大家好，我把这篇文章放在一起是为了帮助我们编写更好的程序，避免主要由副作用引起的突变。*

# 这篇文章是给谁的？

本文是为任何至少对编程，特别是 JavaScript 有基本了解的人准备的。如果不是你，你一定要查看那里的免费资源。话虽如此，让我们玩得开心点。

# 入门指南

我们将从理解副作用开始，然后继续了解为什么纯函数是避免它们的常见解决方案。

# JavaScript 的副作用是什么？

当我们修改某些东西时，在 JavaScript 中，我们会引起副作用，这仅仅意味着修改或改变我们的代码，导致它具有不可预测的行为和[可变性](https://developer.mozilla.org/en-US/docs/Glossary/Mutable)。让我们通过查看这个简单的代码片段来更好地理解这一点。

```
//side effectconst fruits = ['pineapple','orange','pawpaw','kiwi']function removeData(dataArr){return dataArr.pop()}removeData(fruits)
```

在这段代码中，我们所做的就是从任何提供的数组中移除最后一个元素，然而，结果将会改变原始数组，如果我们必须编写一个更好的程序，这是不好的，想象我们有非常有用的数据，我们需要在将来重用，这将使我们不可能这样做，显然我们可以在这里看到副作用，这是我们的代码被修改后，我们从数组中移除一个元素。

此外，考虑这个例子，想象一个用户购买了一些物品，如果购买的物品有一些问题，有一个购买物品的历史将会很方便，即使用户通过丢弃一个物品对他们的购物车进行了一些修改，也不应该丢弃整个购物车。

让我们看看最后一个例子:

```
function sayHello(){console.log('Hello')}sayHello()
```

这段代码也会引起副作用，原因是 console.log()属于 window 对象，我们总是想编写可预测的程序。即输入应该总是等于函数产生的输出。

# 良好功能的质量

在下一个主题中，我将讨论纯函数以及它们是如何补救编写好的程序的，但是理解好的函数的特性也是非常重要的，所以我把几个要点放在一起，以帮助您更好地理解。

*   **1** **任务**:一个好的功能应该一次完成一项任务，它应该专注于一件事并且做得最好。
*   **可预测性**:一个好的函数应该是可预测的，这样我们总是期望相同的输入和输出。
*   **可组合性**:在程序中进行组合，我们关心的是处理组件之间关系的系统设计原则
*   **不变性**:这意味着不改变数据或状态，而是复制并返回新数据。
*   **返回语句**:一个好的函数必须有一个返回语句。
*   **纯**:在不产生副作用的情况下功能还是不错的。
*   **无共享状态**:要写一个好的函数，我们要避免状态共享。

# 我们如何避免程序中的副作用？

在我们的程序中，避免副作用的最好方法之一是使用纯函数，记得当我们谈论一个好函数的质量时，我们说过一个函数必须是纯的，以满足质量函数的要求。但是什么是纯函数呢？

# 纯函数，是什么？

纯函数是这样的函数，无论给它什么输入，它都返回相同的输出，而不会引起任何副作用。因为我们的目标是避免副作用，理解纯函数有助于我们做到这一点。

```
// remedy for side effectsconst arr = [1,2,3]function removeItem(item){const newArr = [].concat(item);newArr.pop()return newArr}// console.log(removeItem(arr));// console.log(arr);
```

在上面的代码中，我们所做的只是从数组中移除一个项目，`concat()`方法确保我们不会通过复制来改变所提供的数组。

我们还避免了全局变量，而是使用局部变量，这将防止“外部世界”的访问，即变量不能在代码块之外被调用。在 JavaScript 中我们称之为作用域，但是我不打算在这里谈论它，因为它超出了本文的范围。

# 为什么纯函数是 JavaScript 中副作用的最佳解决方案？

为了更好地理解这一点，我们来看看使用纯函数的一些意义。

# 意义

*   **可预测性**:当我们编写纯函数时，我们总是知道会发生什么，因为它对外部变量没有影响。
*   **测试**:使功能易于测试。
*   **组合**:组合是使用较小的代码片段创建较大代码的行为`compose()`方法就是一个例子。纯函数使这成为可能。
*   **不变性**:意味着无法改变数据或状态，通过编写纯函数，我们制作副本而不是改变原始数据，例如

```
const obj = {name: 'iggy'}function clone(obj){return {...obj} // immutability (making copies)}function updateName(obj){const obj2 = clone(obj);obj2.name = 'sewa'return obj2}const updateObj = updateName(obj)
```

这里，更改名称-值不会改变对象，因为通过使用 spread 操作符，我们复制了对象中包含的所有内容。

最后，纯函数帮助我们最小化程序中的错误。

我们已经知道为什么纯函数是编写没有副作用的程序的最佳解决方案，因为它们有许多好处，

重要的是要知道纯函数是[函数式编程](https://www.freecodecamp.org/news/functional-programming-principles-in-javascript-1b8fc6c3563f/)的概念，我只需要在这里提一下，因为谈论纯函数而不谈论函数式编程是不可能的，函数式编程就是关注点的分离，它是一种确保我们的代码做它擅长的事情并确保数据不会变异的方法，这使它成为大多数开发人员的选择。

这背后的总体思想是最小化副作用，这在修复程序中的错误时是有益的，因为我们确切地知道去哪里。

# 结论

副作用不一定是不好的，但这里的目标是以一种将事物相互隔离的方式组织代码。如果你想了解更多—副作用和纯功能。我推荐你去看看这个[资源](https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/)。

就这样了，伙计们，我希望你们在阅读这篇文章时都很开心，希望这能帮助你们在纯函数的帮助下写出更好的程序，如果你们不是 100%清楚，请不要犹豫问我任何问题，我也欢迎反馈，所以请随时让我知道你们认为我应该改进的地方。

编码快乐，感谢您的阅读！

*更多内容尽在*[***plain English . io***](http://plainenglish.io)