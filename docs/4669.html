<html>
<head>
<title>The Perilous Journey of an HTTP Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求的危险旅程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-perilous-journey-of-an-http-request-9aa7ea6f00cb?source=collection_archive---------7-----------------------#2021-09-17">https://javascript.plainenglish.io/the-perilous-journey-of-an-http-request-9aa7ea6f00cb?source=collection_archive---------7-----------------------#2021-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8160" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这是一个孤独的HTTP请求在浩瀚的互联网海洋中航行的故事。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2154b8590f5a933c12a402611778ce93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A2lLL0SLtn__ppvO"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jplenio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Johannes Plenio</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="56da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一切都是从一双疲惫的人类眼睛在可爱的猫图像中寻找平静开始的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/751b4ed870091fff402e8e4b04197723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQO3m6hoIiIeM3PmQT0Siw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Google Search for “cute cat images”</figcaption></figure><p id="4798" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是一个<em class="lq"> HTTP请求</em>的诞生:一个由一些必要信息组成的文本消息，这些信息是按照<strong class="kv io">超文本传输协议(HTTP) </strong>命令的方式构建的。出生地:<em class="lq">应用</em>层。</p><p id="8bb9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它看起来像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/a24d73072699a61c1d52489fbe34ff3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*0xQPPgUhi-uhv9fvuVhurQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The HTTP Request</figcaption></figure><p id="c7f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第1行是<em class="lq">请求行</em>。它包括<em class="lq"> HTTP方法</em>，该方法将告诉目的主机，当它到达那里时，它应该如何处理它。这是一个<code class="fe ls lt lu lv b">GET</code>请求:它请求服务器获取一个资源(“可爱的猫图片”的搜索结果页面)，并将它们发送回<em class="lq">客户端</em>:我们的浏览器。</p><p id="787d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它还包括<em class="lq">请求-URI </em>，又名<em class="lq">路径</em>，这将让服务器知道它需要获取哪个资源。我们的请求路径包括一个<em class="lq">查询字符串</em> <code class="fe ls lt lu lv b">?q=cute%20cat%20images</code>，它向服务器传递一些关于所请求资源的附加信息。</p><p id="2d58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里暂停一下，讨论一下查询字符串——这个<code class="fe ls lt lu lv b">q</code>是什么，为什么我们在搜索框中输入的单词之间会有一些奇怪的字符分隔？</p><p id="9597" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe ls lt lu lv b">q</code>是我们填写的输入字段的名称。我们可以在这里看到:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lw"><img src="../Images/07417792f0599e0c5b06477d939bc7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMtEPIjgO6jKtkWDNM5-zw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Notice the `name` attribute of the input element</figcaption></figure><p id="71a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“奇怪”的字符，特别是<code class="fe ls lt lu lv b">%20</code>，是因为我们不能在URL中有空格。因此，我们使用<a class="ae ks" href="https://www.rapidtables.com/code/text/ascii-table.html" rel="noopener ugc nofollow" target="_blank"> ASCII十六进制代码</a>来表示前面有<code class="fe ls lt lu lv b">%</code>的空格(数字20)，这只是一个保留字符，用于在URL中输入ASCII代码来编码不允许或不安全使用的字符。</p><p id="a6e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">右括号。</p><p id="bb35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后指定使用中的<em class="lq"> HTTP版本</em>:<code class="fe ls lt lu lv b">HTTP/2</code>。</p><p id="6d2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在请求行下面是一个必要的<em class="lq">头</em>，它标识接收主机<code class="fe ls lt lu lv b"><a class="ae ks" href="http://www.google.com." rel="noopener ugc nofollow" target="_blank">www.google.com</a></code>、<a class="ae ks" href="http://www.google.com." rel="noopener ugc nofollow" target="_blank">。</a>我们不会进入以下两个标题。</p><p id="d6e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们都准备好去旅行了吗？绝不可能。HTTP请求在准备好踏上危险的旅程之前，必须经历一次转换。</p><h2 id="86b7" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">成为TCP段</h2><p id="c69e" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">它现在进入<em class="lq">运输</em> <em class="lq">层</em>。这一层的指挥者通常是<strong class="kv io">传输控制协议(TCP) </strong>。TCP非常认真地对待自己的工作，希望确保发送的每个数据段都能被接收到，并且顺序正确。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="3197" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们在这里稍作休息，简单地讨论一下TCP如何实现这些特性，以确保在客户机和服务器之间建立可靠的连接。</p><p id="5dfe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，它遵循一个被称为<em class="lq"> TCP三次握手</em>的过程。在“握手”期间，客户机和服务器交换几条消息。</p><ol class=""><li id="fc60" class="nc nd in kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">客户端主机发送一个设置了<code class="fe ls lt lu lv b">SYN</code>标志的数据段。</li><li id="ecf9" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">服务器用带有<code class="fe ls lt lu lv b">SYN</code> — <code class="fe ls lt lu lv b">ACK</code>标志的数据段来响应。</li><li id="c1a1" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">客户端发送带有<code class="fe ls lt lu lv b">ACK</code>标志的最后一个数据段。</li></ol><p id="9a4e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦握手完成，HTTP请求就可以安全地传输了。</p><p id="e9e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，为了确保请求确实到达了目的地，一个<em class="lq">确认</em>消息从服务器发送回我们计算机的网络接口。如果没有收到确认，则重新传输该数据段。</p><p id="f93f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，如果一个消息太大而不能一次发送，它会被分成几个片段，每个片段都有自己的<em class="lq">序列</em> <em class="lq">编号</em>(也位于报头字段中)。这样，当它们到达目的地时，它们将按正确的顺序被处理。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="559c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">HTTP请求被封装在TCP数据段中。该数据段有一个报头和一个数据有效载荷(HTTP请求现在所在的位置)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/65495549a4fc95169497640698207f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51JXdcLceZIXip3DwpHkPQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The TCP Segment (outlined in black) encapsulates the HTTP Request</figcaption></figure><p id="39c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么头里面是什么呢？</p><p id="edf0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">传输层负责将数据段从发出请求的应用程序(在本例中是web浏览器)发送到Google服务器中的正确进程(HTTP请求在这里被处理)。它通过使用<em class="lq">端口</em>来实现:0–65535范围内的整数，作为主机中特定应用程序或进程的标识符。</p><p id="d990" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的TCP段的报头将包含(除了其他信息之外)由我们的操作系统分配给该应用程序的<em class="lq">源端口</em>和<em class="lq">目的端口。</em>HTTP的默认端口是80。</p><p id="a759" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样，当片段到达谷歌的服务器时，它将被定向到端口80，在那里服务器<em class="lq">监听</em>HTTP请求<em class="lq">。</em></p><p id="cfc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是它如何到达谷歌的服务器呢？</p><h2 id="e279" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">成为一个IP包</h2><p id="b180" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">向上，向下，到<em class="lq">互联网层</em>。</p><p id="fc13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，TCP数据段被<strong class="kv io">互联网协议(IP) </strong>转换成<em class="lq"> IP </em> <em class="lq">数据包</em>。</p><p id="a525" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">互联网协议是一种能使数据包从你家传送到世界另一端的服务器的协议。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/4bad393a3c8f76bcefd5609a33a28680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkGOHMPiVOLHave2-BXBTg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The IP Packet (outlined in blue) encapsulates the TCP Segment</figcaption></figure><p id="9746" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TCP数据段会自动跳到数据包中。IP把它封上，并在上面写上回邮地址和邮寄地址。寄件人地址或<em class="lq">来源</em>地址是我电脑的<em class="lq"> IP地址</em>(需要可爱猫咪图片的是我)。收件人或目的地是谷歌服务器的IP地址:在互联网上识别该计算机的唯一数字序列。</p><p id="5579" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">IP地址可能看起来像这样:<code class="fe ls lt lu lv b"><a class="ae ks" href="http://207.126.144.100/" rel="noopener ugc nofollow" target="_blank">207.126.144.10</a>0</code>，表示IPv4，或者这样:<code class="fe ls lt lu lv b">2a02:687:1211:7500:c8cb:bcf9:7acb:a966</code>，表示IPv6。</p><p id="d9cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">(<em class="lq">注:</em> IPv4和IPv6都是IP协议的版本，IPv6是最新版本，可以容纳比IPv4多大约10倍⁷的IP地址)。</p><p id="d2ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一切就绪；下一层，也就是最后一层。</p><h2 id="f8f1" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated">成为以太网帧</h2><p id="5926" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">我们的请求已经正式到达了它的最后准备阶段:数据<em class="lq">链路层</em><em class="lq"/>。以太网协议负责这一层。</p><p id="17ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以太网将包含TCP段的IP数据包(包含HTTP请求)打包成一个<em class="lq">帧。帧头上的</em>是源和目的地<em class="lq"> MAC地址</em>。除了，在这种情况下，目的地还不是谷歌的服务器，位于数英里之外，而是队列中的下一个节点。所谓节点，我指的是信息将首先传输到的最近的联网设备——通往谷歌的下一个“跳”。现在，它可能是我的路由器。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/f8fbc84d7afb4f366a8e9e0c61501ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1DBGvR2d0oZupIRKxIUAQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The Ethernet Frame (outlined in green) encapsulates the IP Packet</figcaption></figure><p id="8875" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是以太网的作用:它负责将帧送到网络中的下一个“跳”。一旦它到达那里，目的MAC地址将改变指向下一个节点。这很像真实的包裹如何在世界各地旅行:每个快递员(节点)处理包裹(帧)，并将其分派给下一个快递员，直到它到达最终目的地。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/23001d139d43493ec633028959da458b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GLnaRRjL3oZJAfld"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@danielsfalcao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Falcao</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8af3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在怎么办？混乱，电缆和电线。帧采取最终的形式:它成为一个比特流，以电信号(或光信号或无线电波)的形式向目的MAC地址传输——路由器将充当通往外部世界的网关。</p><p id="986a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以同样的方式，HTTP响应将在谷歌的服务器上准备好，并一路传回我的家，我的电脑，最终从我的浏览器传到我疲惫的眼睛。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/0644cb8879892dfd710ecb1f92a18cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jF55Kbz39O2TOg7V57igKg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The HTTP Response message interpreted as a web page</figcaption></figure></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h2 id="4b38" class="lx ly in bd lz ma mb dn mc md me dp mf lc mg mh mi lg mj mk ml lk mm mn mo mp bi translated"><em class="nv">总结</em></h2><ol class=""><li id="ebd6" class="nc nd in kv b kw mq kz mr lc nw lg nx lk ny lo nh ni nj nk bi translated">出于本文的目的，使用了<a class="ae ks" href="https://en.wikipedia.org/wiki/Internet_protocol_suite" rel="noopener ugc nofollow" target="_blank"> TCP/IP模型</a>。</li><li id="246d" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">每一层都可以使用不止一种协议。例如，在传输层，UDP可能被一些应用程序用来代替TCP。</li><li id="c5e1" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">在google.com实际使用的HTTPS的例子中，HTTP请求首先由TLS协议加密，这样就可以安全地传输。</li><li id="7817" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">不幸的是，还有比本文提到的更多的事情在发生。</li></ol><p id="dabe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lq">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>