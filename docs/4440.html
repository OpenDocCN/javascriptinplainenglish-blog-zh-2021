<html>
<head>
<title>Why All React Developers Should Try Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么所有的React开发者都应该尝试Next.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-all-react-developers-should-try-next-js-a7db2b0eb838?source=collection_archive---------7-----------------------#2021-09-04">https://javascript.plainenglish.io/why-all-react-developers-should-try-next-js-a7db2b0eb838?source=collection_archive---------7-----------------------#2021-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章引起了你的兴趣，那么很有可能你已经知道如何使用React，并且听说过Next.js是什么。如果这个图书馆适合你，你还是犹豫不决。</p><p id="8367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我将试着向你们展示为什么Next.js如此神奇！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d2a74c8e126317ffe150bcce54b79f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHlXt-tfrwMvpWsj8f5v7Q.png"/></div></div></figure><h1 id="1b64" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">是关于什么的？</h1><p id="6fc2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Next.js是由<a class="ae ma" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>创建的React库。如果你有使用Vue的经验，那么你可以和Nuxt.js比较一下。它提供了标准的React体验和许多额外的特性。</p><p id="ac59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js的一些<strong class="jp ir">关键特性</strong>是:</p><ul class=""><li id="c929" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">最佳化</li><li id="c453" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">内置API</li><li id="0ce6" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">内置路由器</li><li id="0765" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">服务器端渲染</li></ul><h1 id="9d34" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Next.js优化了哪些部分？</h1><p id="bb48" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">更好的问题是“哪些部分没有优化？”。</p><p id="8c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，js设法将已经很快的React库带到另一个层次。如果我不得不选择一个优化的组件放在聚光灯下，它肯定是下一个图像组件<a class="ae ma" href="https://nextjs.org/docs/basic-features/image-optimization" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">！</strong></a></p><p id="ffdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像组件是常规HTML <code class="fe mp mq mr ms b">img</code>组件的扩展。如果您在Next.js中使用优化的图像，您的图像将自动被<strong class="jp ir">延迟加载</strong>。这意味着它们只在需要时才被加载和渲染。这样你的页面性能就不会受到影响！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/bdbc59280d84b2598f76d562a31f1bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrU-MaEiUU5Md8apfrH1_g.png"/></div></div></figure><h1 id="18e1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内置API？</h1><p id="217d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">是的，你没看错！Next.js是一个前端库，内置了<a class="ae ma" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank"> API-routes </a>。这意味着，从技术上来说，你可以在一个项目中编写<strong class="jp ir">你的整个应用</strong>、前端和后端<strong class="jp ir">。</strong></p><p id="3239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过要小心这一点，因为API-routes确实缺少一些您可能需要的基本特性。例如，API-routes只接受来自相同来源的请求，这意味着您不能从应用程序外部访问它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/daf6a10173d0a4604251c9232cfbae53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abd1bL2AoZ0SewE5Sbn5Wg.png"/></div></div></figure><h1 id="6dd7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内置路由器</h1><p id="c8c2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果您以前使用过regular React，那么您就会知道管理路由和路径名是多么痛苦。Next.js通过给你一个自动生成的路由器来解决这个问题！当你创建一个新的Next.js项目时，会有一个名为<code class="fe mp mq mr ms b">pages/</code>的<strong class="jp ir">特殊目录</strong>。你放在那个文件夹<strong class="jp ir">里的每一个<code class="fe mp mq mr ms b">.jsx</code>或者<code class="fe mp mq mr ms b">.txs</code>T22文件</strong>都会变成一个新的路径！</p><p id="3869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您有一个路径为<code class="fe mp mq mr ms b">/pages/hello.jsx</code>的文件。Next.js会在<code class="fe mp mq mr ms b">/hello</code>自动新建一条路线。你可以用<strong class="jp ir">路线参数</strong>、<strong class="jp ir">子路线</strong>和更多的参数建立非常复杂的设置！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/54d0b11170c0d786a8e39549f68a2d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPJaNrjXhTeBiJrRpHu6AQ.png"/></div></div></figure><h1 id="b090" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务器端呈现</h1><p id="bf46" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这个功能花了我一些时间来理解，但是一旦你掌握了它，它就是一个惊人的功能！</p><p id="434b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Regular React是客户端渲染的</strong>意味着客户端需要获取所有数据并显示出来。这有一些优点和警告。</p><p id="8771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次加载你的页面会更快，因为没有任何数据要加载，但它也会破坏你的搜索引擎优化，因为搜索引擎的爬虫不能确定你的页面内容。</p><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，Next.js使得从服务器端呈现页面变得非常容易。虽然<strong class="jp ir">初始加载可能会花费更长一点的时间</strong>，但是你不会用难看的框架加载器来打扰用户，而且<strong class="jp ir">对</strong>你的<strong class="jp ir"> SEO </strong>也很好！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/878db4b491ac36b3ccd8d791ef4f4e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pa3-KfOFlOx1j4Yvzn__IQ.png"/></div></div></figure><p id="2508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js为此提供了三种方法。</p><h2 id="52ee" class="mw ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated">getStaticProps</h2><blockquote class="ni nj nk"><p id="6901" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">在以下情况下，您应该使用<code class="fe mp mq mr ms b">getStaticProps</code>:</p><p id="7c0f" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">呈现页面所需的数据在用户请求之前的构建时就可用。</p><p id="4614" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">数据来自一个无头CMS。</p><p id="eccf" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">数据可以公开缓存(不是特定于用户的)。</p><p id="45c7" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">页面必须预先渲染(用于SEO)并且非常快— <code class="fe mp mq mr ms b">getStaticProps</code>生成HTML和JSON文件，这两个文件都可以由CDN缓存以提高性能。</p></blockquote><p id="eb88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，对于需要从外部源加载但对每个用户都一样的数据，使用<code class="fe mp mq mr ms b">getStaticProps</code>，这意味着它可以被缓存。</p><h2 id="b8e5" class="mw ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated">getStaticpaths</h2><blockquote class="ni nj nk"><p id="5979" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">如果你在静态预渲染使用动态路径的页面，你应该使用<code class="fe mp mq mr ms b">getStaticPaths</code>。</p></blockquote><p id="94fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，当您需要在页面上呈现动态路径时，请使用<code class="fe mp mq mr ms b">getStaticPaths</code>。</p><h2 id="4142" class="mw ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated">getServerSideProps</h2><blockquote class="ni nj nk"><p id="c208" class="jn jo nl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">只有当您需要预先呈现一个页面，并且该页面的数据必须在请求时获取时，您才应该使用<code class="fe mp mq mr ms b">getServerSideProps</code>。首字节时间(TTFB)将比<code class="fe mp mq mr ms b">getStaticProps</code>慢，因为服务器必须计算每个请求的结果，如果没有额外的配置，CDN无法缓存结果。</p></blockquote><p id="669f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b">getServerSideProps</code>很容易和<code class="fe mp mq mr ms b">getStaticProps</code>混淆。<br/>简而言之，对每个用户不同的数据使用<code class="fe mp mq mr ms b">getServerSideProps</code>，对每个人相同的数据使用<code class="fe mp mq mr ms b">getStaticProps</code>！</p><h1 id="4e01" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">完成</h1><p id="68ab" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我看来，这4个特点使它完全值得进行转换！你觉得我错过了什么或者还有什么问题吗？欢迎<strong class="jp ir">在评论中告诉我</strong>！</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="7591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你有创意的一天！💙</p></div></div>    
</body>
</html>