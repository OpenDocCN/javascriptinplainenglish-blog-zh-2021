<html>
<head>
<title>Optimize Performance of React Application with Lazy Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过延迟加载优化React应用程序的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/optimize-performance-of-react-application-with-lazy-loading-a6c83926ed1e?source=collection_archive---------11-----------------------#2021-06-22">https://javascript.plainenglish.io/optimize-performance-of-react-application-with-lazy-loading-a6c83926ed1e?source=collection_archive---------11-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进React中的页面加载时间，减少暂停和延迟，并确保React应用程序优化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da0a3ea6fdab1d3d2277b5c4839bd477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiC1gf3x3Ia_2PBYqfkLBg.jpeg"/></div></div></figure><p id="55d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://medium.com/technofunnel" rel="noopener"> Technofunnel </a>展示了另一篇文章，通过在执行过程中使用<strong class="kt ir">组件的惰性加载</strong>来提高React应用程序的性能。我们会明白<strong class="kt ir">懒</strong>和<strong class="kt ir">悬疑</strong>的概念。</p><p id="7db0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，React应用程序的所有组件都捆绑在一个<strong class="kt ir">中。js" </strong>文件并加载到浏览器上。由于所有应用程序组件都在捆绑文件中，因此，创建的JavaScript的大小相对较大。由于我们要加载一个更大的JavaScript文件，这可能会影响应用程序的初始加载时间。</p><h1 id="63db" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">React应用程序捆绑流程</h1><p id="0472" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><strong class="kt ir">捆绑</strong>是将多个文件导入并合并成一个文件的过程，这样应用程序就不必导入大量外部文件。如果每个组件都驻留在一个单独的文件中，我们将需要在初始页面加载期间加载许多“JavaScript”。每个请求都将在网络上传输，消耗网络带宽，HTML解析器将不得不等待来自网络的大量文件。</p><p id="00db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ml">将组件捆绑成一个文件的问题:</em> </strong></p><p id="31c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，React编译器会将所有主要组件和外部依赖项合并到一个文件中，并通过网络发送该文件以启动和运行web应用程序。这节省了大量的网络调用，但也导致了一个问题，即这个单个文件变成了一个大文件，消耗了大量的网络带宽。应用程序一直在等待这个大文件的加载和执行，因此这个文件在网络上传输的延迟会导致应用程序的渲染时间更长。</p><p id="8599" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ml">进一步理解问题:</em> </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><a class="ae ln" href="https://gist.github.com/Mayankgupta688/fa7cb362028b8a512f4902d80edc663d" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/fa7cb362028b8a512f4902d80edc663d</a></figcaption></figure><p id="64e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，基于从“props”接收的“name”属性，我们决定呈现哪个组件。用户可以呈现“GuestLogin”或“MemberLogin”组件。在任何时候，这些组件中只有一个会被渲染。</p><p id="6df3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当React捆绑应用程序时，它将这两个组件组合成一个JavaScript文件。然后在浏览器中加载该文件，虽然其中一个组件是必需的，但是我们在JavaScript中加载了这两个组件，这使得它很大，很难加载。这会导致应用程序的加载时间增加。</p><p id="67ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">违约行为问题:</strong></p><ul class=""><li id="31c7" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">第一个问题是JavaScript代码变得太大，会延迟应用程序的页面加载</li><li id="ab24" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">即使没有在屏幕上加载，组件也会被加载</li></ul><h2 id="a937" class="ng lp iq bd lq nh ni dn lu nj nk dp ly la nl nm ma le nn no mc li np nq me nr bi translated">解决延迟加载的问题:</h2><p id="2879" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了解决这个问题，我们可以引入<strong class="kt ir"> <em class="ml">代码拆分</em> </strong>的概念。我们可以将文件分成多个小的JavaScript输入。每个JavaScript文件可能包含某些组件，这些组件可以根据需要加载，而不是将所有内容绑定到一个文件中。</p><p id="6794" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照上面给出的例子，我们可以在运行时根据“props”值决定加载哪个组件。如果用户名是“Mayank ”,我们可以加载“MemberLogin ”,否则我们可以加载包含“GuestLogin”的文件。我们可以在执行过程中动态加载这些文件。</p><p id="2ec2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用惰性加载React组件的好处</strong>:</p><ol class=""><li id="50ac" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm ns my mz na bi translated">主JavaScript文件将包含所有组件</li><li id="8047" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm ns my mz na bi translated">组件可以根据需求在运行时加载</li><li id="3317" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm ns my mz na bi translated">所需的子组件将装入单独的小包装中</li><li id="bf81" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm ns my mz na bi translated">更快的加载时间，因为主JavaScript相对较小</li></ol><p id="c8eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像<a class="ae ln" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">web pack</strong></a><strong class="kt ir"/>这样的捆绑器支持代码拆分的概念，它们可以为应用程序创建多个捆绑包，并且可以在运行时动态加载。我们以某种方式分解包，以便最初没有加载到应用程序中的组件可以推迟到以后需要时再加载。</p><p id="5fac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将减小主包的大小，并减少应用程序的加载时间。为此，我们使用<strong class="kt ir">反应悬念</strong>和<strong class="kt ir">懒惰</strong>。让我们寻找下面的代码来理解这个概念的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c92b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们将“name”值作为“Mayank”传递，因此它应该在一个单独的组件中加载“MemberLogin”组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/5f896388293a8e24a585b6076dca2dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny25yYnYDtooWEJ9CSF93Q.png"/></div></div></figure><p id="cb72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在执行下面的代码时，它加载一个文件“1.chunk.js ”,该文件单独加载这个“MemberLogin”组件，从而使主JavaScript文件更小，加载和执行更快。</p><p id="8c34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">更多优化技巧，可以参考以下网址:</strong></p><div class="nu nv gp gr nw nx"><a href="https://medium.com/technofunnel/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">22反应性能优化技术</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">React编程的最佳优化技术。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><p id="748c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">更多内容请看</em><a class="ae ln" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ml">plain English . io</em></strong></a></p></div></div>    
</body>
</html>