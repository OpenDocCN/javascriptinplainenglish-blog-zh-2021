<html>
<head>
<title>A Complete Guide to React Native Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本地导航的完整指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-navigation-8ccea9e14523?source=collection_archive---------3-----------------------#2021-01-08">https://javascript.plainenglish.io/react-native-navigation-8ccea9e14523?source=collection_archive---------3-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9b75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个好的app都需要一个好的导航仪。就像越野旅行一样，一个好的导航员会在我们的应用程序中带我们从一个地方到另一个地方，确保我们到达我们想去的地方。一个坏的导航员带我们…嗯，导航员想去的地方。我们感到沮丧，就把应用程序放下了，降低了用户参与度。</p><p id="d614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我相信我们都记得Android的早期，使用后退按钮可能会把你带到…上一个屏幕，一个导航菜单，上一个应用程序，或者任何地方！这很有趣——你可以点击它，然后看到你结束的地方，就像你的朋友为你安排的随机约会。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="0234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React Native提供了构建在React导航之上的导航。他们在这里有很好的文件来源:<a class="ae kp" href="https://reactnavigation.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/getting-started</a></p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="2d84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数应用都有非常标准的用例:</p><ol class=""><li id="7f4d" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">将用户带到应用程序的不同屏幕。</li><li id="1e4b" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">允许后退按钮将用户带回到上一个屏幕。</li><li id="afea" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">在屏幕之间传递信息，可能是为了在导航后过滤或更新屏幕。</li><li id="7340" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">显示子导航器或其他导航堆栈，以便在子屏幕上有更多选择。</li></ol><p id="ca2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，React导航很容易满足所有这些用例。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="6128" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了React原生项目，就很容易开始了。按照这里的指示去做——https://reactnavigation.org/docs/getting-started<a class="ae kp" href="https://reactnavigation.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank"/>。我们需要确保我们有所有合适的包装。和往常一样，最好是在packager \ Metro不运行，模拟器不运行的情况下进行。让它们运行会导致奇怪的错误。</p><p id="0991" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了基本的react-native导航设置之外，您还需要为您的设置安装特定的包，这取决于您想要使用的导航器。</p><p id="8a96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要测试所有导航器，请运行以下命令:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="750f" class="ln lo in lj b gy lp lq l lr ls">npm install <a class="ae kp" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/native  react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context <a class="ae kp" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-native-community/masked-view  <a class="ae kp" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/stack  <a class="ae kp" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/drawer  <a class="ae kp" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/bottom-tabs </span></pre><p id="fe0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们这样做了，我们需要将我们的顶级App.js包装在一个导航容器中。</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2381" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里没什么特别的。</p><ol class=""><li id="1388" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">在第1行——我们添加了手势处理程序。这是一个新的库，取代了底层的React本机手势处理程序。它修复了底层React原生响应系统的一些问题——这里可以看到一段对话:【https://www.youtube.com/watch?v=V8maYc4R2G0<a class="ae kp" href="https://www.youtube.com/watch?v=V8maYc4R2G0" rel="noopener ugc nofollow" target="_blank"/>。请注意，这个新的库不能在Windows或Web上运行，所以您可能需要旧的库，这取决于您的长期目标。</li><li id="5203" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">第4行—我们导入新的导航容器。</li><li id="1e81" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">第11行——我们将当前的应用程序包装在一个导航容器中。需要一个导航容器——它设置屏幕保持所需的状态，跟踪你在哪个屏幕上，对于Android，提供后退按钮API。由于这里没有指定导航器，我们不会在我们的应用程序中看到任何不同，但它会运行。</li></ol><figure class="le lf lg lh gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/6f7d11e20a9c7f6f476572dd897be431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDLGsmmfgmmtg9gNcrLeyg.png"/></div></div></figure></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="1fa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们来谈谈导航仪的类型。</p><p id="80af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将构建3个屏幕来显示差异。</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="62a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且，在更改第17行以显示<ScreenOne/>之后，我们得到了:</p><figure class="le lf lg lh gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/51a1cb5a0bbf7c64c0d4407da11441b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6_j1ypVK4JYtRnknnveBg.png"/></div></div></figure><p id="7ad3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们快速看一下不同的基本导航器类型。我们今天将讨论3种类型:</p><ul class=""><li id="34b6" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated">堆栈导航器</li><li id="12d5" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">抽屉导航器</li><li id="eb45" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">底部选项卡导航器</li></ul><p id="85e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将不会看到:</p><ul class=""><li id="a7fd" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated">本机堆栈导航器——老实说，这是一个很好的导航器，完全模拟了本机导航API的工作方式。然而，它在这一点上并不适用于Web，所以它只能在您想要部署到Android和iOS时使用。</li><li id="6efd" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">两个材料导航器，底部选项卡和顶部选项卡-这些是react-native-paper组件的扩展，而这些组件又是react导航的底部选项卡导航器的扩展。这些与上面的选项卡导航器非常相似。</li></ul><p id="40f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，您可能认为导航器非常相似，并且是可扩展的。没错，您可以通过轻松定制每个导航器中的行为来制作更多的导航器。每个导航器都有相同的基本组件:</p><ul class=""><li id="743d" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated">路线—这些是用户将看到的已配置屏幕。当用户在应用程序中导航时，导航器会保存每个屏幕的不同状态，以及用户去过的地方。这样就可以使用后退按钮。</li><li id="f7d9" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">组件-导航到路径时将显示的配置屏幕或其他React组件。路由可以传递属性，但是组件只是组件。如果组件不知道如何处理路由的属性…它会忽略它们。</li><li id="c47f" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">属性——沿着组件链传递给将处理它们的各种组件的属性。在真正的React Native方式中，高阶组件将这些传递给较低的组件进行渲染。</li></ul></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="bf7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们要讨论的第一个导航器是堆栈导航器。</p><p id="0e0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个导航器就像它听起来的那样——一个堆栈。它提供了听起来一模一样的东西——一堆导航。第一个项目显示在顶部，之后的每个项目都被添加到堆栈顶部。</p><p id="e556" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过如下代码轻松做到这一点:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="b772" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该代码将显示以下内容:</p><figure class="le lf lg lh gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mf"><img src="../Images/a13054848688184064e1ef38af1d5ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkqt3YlKa8OgA3Ka7Qtb-w.png"/></div></div></figure><p id="722e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您运行该代码时，您可能会发现该代码实际上并没有提供您在导航场景中所期望的东西——没有在路线之间移动的控件。</p><p id="11f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而是显示初始屏幕，如此而已。</p><p id="cbf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，对于Stack Navigator，我们需要创建自己的导航元素，在屏幕之间移动。</p><p id="5616" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们更改屏幕定义，以包含一个从一条路线导航到另一条路线的按钮:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a856" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们将在第7，19，31行使用调用“navigation.navigate”。这个API将接受一个文本字符串(一个路由名),这是我们之前使用Stack配置的。屏幕名称=XXX '。XXX是名字。</p><p id="44b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您最初会注意到没有导航元素，只有屏幕顶部的标题。(屏幕一，为我们的初始屏幕。)</p><figure class="le lf lg lh gt lt gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/8ff6b746d421e56d5c42c6cfbcbc887b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ryulw4ranYi6xd5_VvCdfA.gif"/></div></figure><p id="08e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们从一个元素移动到另一个元素时，标题栏会发生变化，并在适当的位置放置一个</p><p id="3efa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在将为每个屏幕添加一个新功能:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9063" class="ln lo in lj b gy lp lq l lr ls">console.log(navigation.dangerouslyGetState());</span></pre><p id="5c0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在不同的屏幕中移动时，这个函数将打印出导航器的状态。</p><p id="9b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">屏幕一:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d2fd" class="ln lo in lj b gy lp lq l lr ls">01–05 14:42:16.776 4884 19212 I ReactNativeJS: index: 0,<br/>01–05 14:42:16.776 4884 19212 I ReactNativeJS: routeNames: [ ‘One’, ‘Two’, ‘Three’ ],<br/>01–05 14:42:16.776 4884 19212 I ReactNativeJS: routes:<br/>01–05 14:42:16.776 4884 19212 I ReactNativeJS: [ { key: ‘One-W6–8fHZHIQHKWTVDe5pHj’,<br/>01–05 14:42:16.776 4884 19212 I ReactNativeJS: name: ‘One’,<br/>01–05 14:42:16.776 4884 19212 I ReactNativeJS: params: undefined } ] }</span></pre><p id="5b29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，此时仅定义了一条路线。按下按钮移至屏幕二会显示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7e2f" class="ln lo in lj b gy lp lq l lr ls">01–05 14:46:17.233 4884 19212 I ReactNativeJS: routes:<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: [ { key: ‘One-W6–8fHZHIQHKWTVDe5pHj’,<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: name: ‘One’,<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: params: undefined },<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: { key: ‘Two-Ij1hKIRjwMgqqekKtjt4B’,<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: name: ‘Two’,<br/>01–05 14:46:17.233 4884 19212 I ReactNativeJS: params: undefined } ] }</span></pre><p id="6927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移动到屏幕二会将另一个屏幕添加到堆栈中。</p><p id="c835" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，回到屏幕一…不会打印任何东西。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="69db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想知道为什么？</p><p id="41e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我们需要讨论React的渲染模型。</p><p id="b765" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React使用延迟渲染方法，具有两个特征:</p><ol class=""><li id="07ee" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">仅渲染已更改的组件。这允许屏幕快速显示。</li><li id="4027" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">仅渲染显示的屏幕。</li></ol><p id="8e06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React生命周期有显示这些的方法—我们感兴趣的2个是componentDidMount()和componentWillUnmount()。</p><p id="a267" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，由于我们使用功能组件，新的热点，我们必须为此使用一个useEffect钩子。</p><p id="daa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们将在每个函数中添加与此类似的代码:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f155" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将打印出我们在堆栈导航器中移动时的路线。</p><p id="8573" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看这里的调试输出，您可以很容易地看到，每当我们弹出导航堆栈的顶部时，我们都会看到一个屏幕卸载。例如，当我们使用后退箭头从屏幕三移动到屏幕二时，会显示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="44b0" class="ln lo in lj b gy lp lq l lr ls">[Info] 01-05 16:29:47.151  4884  4212 I ReactNativeJS: Screen 3 Unmount:<br/>[Info] 01-05 16:29:47.155  4884  4212 I ReactNativeJS: { stale: false,<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:   type: 'stack',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:   key: 'stack-vo35QL6onuHzaoVKRkcLn',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:   routeNames: [ 'One', 'Two', 'Three' ],<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:   index: 1,<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:   routes:<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:    [ { key: 'One-YQJCh-OSey7sY3F8g8LjH',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:        name: 'One',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:        params: undefined },<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:      { key: 'Two-KTzPjo4zblaJ2NnwFuwlR',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:        name: 'Two',<br/>01-05 16:29:47.155  4884  4212 I ReactNativeJS:        params: undefined } ] }</span></pre><p id="8379" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，当我们点击屏幕3上的按钮移至屏幕1时，屏幕2和屏幕3都被卸载，因为它们不再位于路由堆栈上。</p><p id="baf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有屏幕一不卸载，因为它总是在堆栈的底部。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="778a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者是？我们能强迫它卸载吗？</p><p id="821a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">stackAction引用API显示了一个“替换”调用——替换当前路线。</p><p id="1ba9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加一个新按钮…</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d044" class="ln lo in lj b gy lp lq l lr ls">&lt;Button<br/>         title="Replace with Three"<br/>         onPress={() =&gt; navigation.replace('Three')}<br/>/&gt;</span></pre><p id="eb36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后嘣！现在，当我们单击该按钮时，我们看到当前屏幕1已卸载，堆栈上的唯一路径是屏幕3:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8104" class="ln lo in lj b gy lp lq l lr ls">[Info] 01–05 16:53:01.220 4884 12243 I ReactNativeJS: Screen 1 Unmount:<br/>[Info] 01–05 16:53:01.221 4884 12243 I ReactNativeJS: { stale: false,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: type: ‘stack’,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: key: ‘stack-4NIFPEcHeiA1UQFsqkUwF’,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: index: 0,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: routeNames: [ ‘One’, ‘Two’, ‘Three’ ],<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: routes:<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: [ { key: ‘Three-XvOAF4N-eo8FbBDz981TA’,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: name: ‘Three’,<br/>01–05 16:53:01.221 4884 12243 I ReactNativeJS: params: undefined } ] }</span></pre><p id="7de9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈函数还有其他组件，包括push和pop例程。我会让你探索这些。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="9ed7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我们在堆栈的生命周期上花了这么多时间？</p><p id="cc67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为每个航海家都有自己的生命周期。这将是理解导航器的重要部分——知道组件何时被安装和卸载。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="3160" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们转到抽屉导航器！</p><p id="f80a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先要做的是导入库:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0462" class="ln lo in lj b gy lp lq l lr ls">import { createDrawerNavigator } from '@react-navigation/drawer';</span></pre><p id="8c1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单，容易完成。</p><p id="02c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成后，我们将使用现有的屏幕，并将它们包装在我们刚刚创建的导航器中。但是我们仍然需要保持导航容器可用——所以我们要做的就是将导航定义更改为drawer。</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="le lf lg lh gt lt gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/ea05ce76d69aa4b6de2416da2359ffc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1gGt3ybtwIH65jiNQ098gQ.gif"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk">I’m really bad at pulling the drawer out on the emulator. I’m also bad at Halo and Call of Duty.</figcaption></figure><p id="07b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么——当处理抽屉导航器时，我们的路线看起来像什么？请记住，使用堆栈导航器，只有当您导航到路线时，路线才会被添加到路线中——它是一个<em class="ml">堆栈。我知道…很疯狂。</em></p><p id="6eb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了抽屉，所有的导航路线都已经定义好了…但是为了与惰性挂载React范例保持一致…</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3756" class="ln lo in lj b gy lp lq l lr ls">[Info] 01–06 15:33:57.861 4884 8036 I ReactNativeJS: { stale: false,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: index: 0,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: routeNames: [ ‘One’, ‘Two’, ‘Three’ ],<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: history: [ { type: ‘route’, key: ‘One-TTViLKdH1xlcJHU4EW07q’ } ],<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: routes:<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: [ { name: ‘One’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: key: ‘One-TTViLKdH1xlcJHU4EW07q’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: params: undefined },<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: { name: ‘Two’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: key: ‘Two-ibrPGdV3D4cz3XsTNczLq’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: params: undefined },<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: { name: ‘Three’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: key: ‘Three-k8FbMgqZ8b6Ks17GF7q_S’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: params: undefined } ],<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: type: ‘drawer’,<br/>01–06 15:33:57.861 4884 8036 I ReactNativeJS: key: ‘drawer-eljOWlZef — CmBSQuUt1p’ }</span></pre><p id="d7d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，所有路由都是完全定义的。这里没有“back ”,这将弹出一个离开堆栈的路由。</p><p id="4923" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以随时导航到路线列表中的任何项目。</p><p id="d532" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击我们预先存在的按钮在屏幕之间移动仍然有效…但是如果你点击“用三个替换”按钮…你会得到…一个红色的死亡屏幕！</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a4db" class="ln lo in lj b gy lp lq l lr ls">[Info] 01-06 15:46:16.879  4884  8036 E ReactNativeJS: TypeError: navigation.replace is not a function. (In 'navigation.replace('Three')', 'navigation.replace' is undefined)</span></pre><p id="b412" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是堆栈导航器，因此您不能用其他路线替换任何路线。</p><p id="4f59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，我们可以清楚地看到安装工作正常:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="59d3" class="ln lo in lj b gy lp lq l lr ls">[Info] 01-06 15:46:14.429  4884  8036 I ReactNativeJS: Screen 2 Mount:<br/>[Info] 01-06 15:46:15.233  4884  8036 I ReactNativeJS: Screen 3 Mount:</span></pre><p id="5d11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里一个重要的区别是我们有历史而不是路线。这样我们可以看到用户是如何在屏幕之间移动的:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="71d9" class="ln lo in lj b gy lp lq l lr ls">01-06 15:46:15.234  4884  8036 I ReactNativeJS:   history:<br/>01-06 15:46:15.234  4884  8036 I ReactNativeJS:    [ { type: 'route', key: 'One-TTViLKdH1xlcJHU4EW07q' },<br/>01-06 15:46:15.234  4884  8036 I ReactNativeJS:      { type: 'route', key: 'Two-ibrPGdV3D4cz3XsTNczLq' },<br/>01-06 15:46:15.234  4884  8036 I ReactNativeJS:      { type: 'route', key: 'Three-k8FbMgqZ8b6Ks17GF7q_S' } ] }</span></pre><p id="17e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在这里的时候把那个什么都不用的按钮藏起来。</p><p id="4cfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，从@react-navigation/native导入useNavigationState:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="03be" class="ln lo in lj b gy lp lq l lr ls">import {<br/>   NavigationContainer,<br/>   useNavigationState,<br/>} from ‘@react-navigation/native’;</span></pre><p id="20ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，将屏幕一变成:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8a1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用“替换”的按钮不见了——发生在第12行——我们使用导航类型来显示或隐藏该按钮。</p><p id="59cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得注意的一件有趣的事情是——抽屉导航器不会卸载屏幕。如果您按下按钮在所有屏幕间循环，它们将保持安装状态。</p><p id="abc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抽屉屏幕对于整体上下文导航非常有用，可以设置为不同的宽度。例如，在平板电脑上，它可以有一个永久的导航标签，而在手机上，需要拉开抽屉才能导航。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="2575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的最后一种屏幕是选项卡式屏幕。</p><p id="2c19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续将以下内容添加到我们的应用程序中:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a9b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在我们的应用程序中创建了一个简单的选项卡屏幕。</p><p id="f1e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用底部选项卡导航器，但同样的事情也适用于材料顶部或底部选项卡，或任何自定义选项卡导航器。</p><figure class="le lf lg lh gt lt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/d577ca4ff318a023a336aa9a09b7a4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/1*ulwSqOCn6aJF950TVEv3Zw.gif"/></div></figure><p id="465c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像抽屉导航器一样，不会调用任何卸载操作——但是只有当选项卡被实际呈现时，屏幕才会被装载。因此，在点击所有选项卡之后，所有选项卡屏幕都被安装，但是只有最上面的一个在呈现更改。事实上，就像抽屉导航器一样，因为我们的选项卡没有任何变化的数据，所以它们只被渲染一次——它们的渲染在那一点上是静态的。</p><p id="eaf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也像抽屉导航器一样，所有的路线都被定义，并且随着用户在选项卡中导航，历史记录也在增长。</p><p id="dc51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该历史被用于“返回”导航。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="e750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要讨论的下一件事是在屏幕之间传递数据。</p><p id="9d82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们将使用一些简单的数据，将其从屏幕一传递到屏幕二。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="9baf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来我们需要做的是在屏幕上传递数据。总的来说，在这样做的时候，我们需要谈一谈我们在传递什么，为什么传递。</p><p id="af8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不同类型的应用对传递数据有不同的需求。</p><p id="b3e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在分层的导航显示中，可能存在以下情况:</p><p id="ebf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">项目列表-&gt;项目详细信息-&gt;要完成的项目活动</p><p id="d96a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，沿着导航路径传递信息(就像在堆栈导航器中一样)可能是正确的做法。</p><p id="4bcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请考虑更像这样的事情:</p><p id="885b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">屏幕一-&gt;新闻提要</p><p id="b460" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">屏幕二-&gt;登录的用户配置文件</p><p id="c6b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，将信息从屏幕一传递到屏幕二是不值得的。为登录用户创建全局上下文或全局数据库是值得的。</p><p id="a7f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦屏幕二被安装，它将保持安装。当信息重新成为焦点时，将由单独的屏幕来刷新信息。我们可以使用<em class="ml"> useIsFocused </em>钩子来重新触发这样场景的信息收集和显示。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="136c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，让我们将一些数据从屏幕一传递到屏幕四！这将模拟第一个场景——数据通过一系列组件传递。</p><p id="daad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们需要首先设置导航来传递参数。</p><p id="25bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很容易做到—让我们添加第四个屏幕:</p><figure class="le lf lg lh gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="354f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在这里维护了基本的useEffect钩子——这将让我们看到什么时候装载和卸载了东西。</p><p id="1dce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还将{navigation，route}传递给ScreenFour函数，添加route将让我们获得路线的参数。我们稍后将在屏幕中使用它。</p><p id="beaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">屏幕将在第14行使用{route.params.number}打印出这个简单的信息。实际上，您可以将任何想要的东西传递给它，并显示任何东西。也许它是一个itemID来显示关于项目本身的更多信息，或者是一个URL来查询信息。</p><p id="b8eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在屏幕一中，我们将添加这个调用:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ba4b" class="ln lo in lj b gy lp lq l lr ls">&lt;Button<br/>    title="Display Screen Four Info"<br/>    onPress={() =&gt; {<br/>      var rand = Math.random();<br/>      navigation.navigate('Four', {number: rand});<br/>     }}<br/>/&gt;</span></pre><p id="4eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许我们将一个随机数传递给新标签。只有当数字改变时，它才会改变数值——只有在使用这个按钮时才会发生。使用选项卡导航器(或另一个导航器)不会改变这里的任何值——它只会显示屏幕呈现的最后一个值。</p><figure class="le lf lg lh gt lt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c8ec897417878eee1e28c3e0e1e2c877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/1*oUohdCR5sRxwpxvYU84rlA.gif"/></div></figure><p id="ef7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该值成为路由的一部分:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="458e" class="ln lo in lj b gy lp lq l lr ls">01-07 15:34:41.024  4884  4110 I ReactNativeJS:      { name: 'Four',<br/>01-07 15:34:41.024  4884  4110 I ReactNativeJS:        key: 'Four-0leyCbrbFyqXwhsLaSfKr',<br/>01-07 15:34:41.024  4884  4110 I ReactNativeJS:        params: { number: 0.6732985766145677 } } ],</span></pre><p id="0300" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，使用按钮，我们传递一个新的参数，React navigation触发一个新的屏幕卸载和装载。React导航保存旧状态，并理解参数已经改变，因此屏幕需要重新呈现。</p><p id="d040" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您会发现一个函数set params——这对于在您所在的屏幕上更改参数非常有用。</p><p id="5a3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，您可能会传递一个标题或用户ID —这个屏幕允许用户更改它。使用setParams将更新您的导航路线参数，以立即显示新信息，并更新您的路线，以便在返回屏幕时，会有更新的信息。否则，React不会再次渲染屏幕，因为参数不会改变。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="2a4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为本文的结束语，显示子导航器很容易，但是有几个问题。因为这篇文章已经很长了，所以我将指向文档来帮我解决这个问题。</p><div class="mn mo gp gr mp mq"><a href="https://reactnavigation.org/docs/nesting-navigators" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">嵌套导航器|反应导航</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">嵌套导航器意味着在另一个导航器的屏幕内呈现一个导航器，例如:在上面的例子中…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">reactnavigation.org</p></div></div></div></a></div></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="9b29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><p id="781f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密码</p><ul class=""><li id="4e50" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated"><a class="ae kp" href="https://dev.azure.com/allangraves/Public%20React%20Native%20Code/_git/ReactNativeNavigation" rel="noopener ugc nofollow" target="_blank">https://dev . azure . com/Allan graves/Public % 20 react % 20 native % 20 code/_ git/reactnationaviation</a></li></ul><p id="0f16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反应本地文档</p><ul class=""><li id="efa0" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated">【https://reactnavigation.org/docs/getting-started T4】</li><li id="ac1a" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/bottom-tab-navigator/" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/bottom-tab-navigator/</a></li><li id="d18f" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/drawer-navigator/" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/drawer-navigator/</a></li><li id="fa49" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/stack-navigator/" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/stack-navigator/</a></li><li id="5fb5" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/material-bottom-tab-navigator/" rel="noopener ugc nofollow" target="_blank">https://react navigation . org/docs/material-bottom-tab-navigator/</a></li><li id="a6d9" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/material-top-tab-navigator/" rel="noopener ugc nofollow" target="_blank">https://react navigation . org/docs/material-top-tab-navigator/</a></li><li id="734d" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://github.com/software-mansion/react-native-gesture-handler" rel="noopener ugc nofollow" target="_blank">https://github . com/software-mansion/react-native-gesture-handler</a></li><li id="f19a" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/use-is-focused" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/use-is-focused</a></li><li id="32c7" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/navigation-lifecycle" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/navigation-lifecycle</a></li><li id="278a" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://itnext.io/the-intricacies-of-nesting-navigators-in-react-native-using-react-navigation-fef52ca72964" rel="noopener ugc nofollow" target="_blank">https://it next . io/the-intrinciencies-of-nesting-navigators-in-react-native-using-react-navigation-fef 52 ca 72964</a></li></ul><p id="34e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">常规工艺路线文档</p><ul class=""><li id="6b64" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated"><a class="ae kp" href="https://medium.com/building-with-react-native/routing-in-react-native-apps-and-how-to-configure-your-project-with-react-navigation-library-d8d58005bfe9" rel="noopener">https://medium . com/building-with-react-native/routing-in-react-native-apps-and-how-to-configure-your-project-with-react-navigation-library-d8d 58005 bfe 9</a></li><li id="3d64" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/use-navigation-state/" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/use-navigation-state/</a></li><li id="7b74" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://rossbulat.medium.com/introduction-to-react-navigation-and-navigators-in-react-native-3efcf7239a43" rel="noopener">https://Ross bulat . medium . com/introduction-to-react-navigation-and-navigators-in-react-native-3 efcf 7239 a 43</a></li></ul><p id="9389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">功能组件</p><ul class=""><li id="dbd1" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated"><a class="ae kp" href="https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/hooks-FAQ . html # how-do-life cycle-methods-comment-to-hooks</a></li><li id="f74f" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated">【https://reactjs.org/docs/react-component.html T4】</li></ul><p id="09a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">性能</p><ul class=""><li id="73ff" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/navigation-prop/" rel="noopener ugc nofollow" target="_blank">https://reactnavigation.org/docs/navigation-prop/</a></li><li id="0ac3" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh me kw kx ky bi translated"><a class="ae kp" href="https://reactnavigation.org/docs/hello-react-navigation#passing-additional-props" rel="noopener ugc nofollow" target="_blank">https://react navigation . org/docs/hello-react-navigation # passing-additional-props</a></li></ul></div></div>    
</body>
</html>