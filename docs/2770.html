<html>
<head>
<title>How to Resolve Callback Hells with Lovely JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用可爱的JavaScript承诺解决回调问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/kinda-lovely-js-promises-6818f784633c?source=collection_archive---------14-----------------------#2021-06-06">https://javascript.plainenglish.io/kinda-lovely-js-promises-6818f784633c?source=collection_archive---------14-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e28a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">许下你的诺言……</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/5d45aae4be95260cbba7141c73ac125b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44eX7U1x0CzWM_CSmJo6Pg.png"/></div></div></figure><p id="7da2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的上一篇文章中，我们已经看到了带有Node.js的JavaScript如何执行异步操作。还记得<strong class="jm io"> <em class="ki">回调</em> </strong>吗？</p><p id="43be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回调是Javascript中异步编程的基础。我们在编程中使用回调时面临两个主要问题:</p><p id="2634" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 1。回调地狱</strong></p><p id="4d6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有些情况下，我们在回调函数内部进行回调(称为嵌套回调函数)。它会导致代码可读性和理解方面的问题。</p><p id="4003" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。处理错误的难度</strong></p><p id="f5a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当异步函数或异步调用的回调抛出异常时，该异常无法传播回异步操作的发起者。它破坏了异常处理。</p><blockquote class="kv"><p id="b5d1" class="kw kx in bd ky kz la lb lc ld le kh dk translated">所以，最简单的解决办法就是使用我们可爱的承诺<strong class="ak">。</strong></p></blockquote><p id="0f14" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">承诺是建立在回调上的对象，它代表异步计算的结果。结果可能准备好了，也可能没有准备好。Promise只能异步工作。没有办法通过同步调用来获取值。你只能要求承诺在值准备好的时候调用一个回调函数。</p><p id="9a50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">承诺通过以承诺链的形式重新表达嵌套回调，为嵌套回调提供解决方案。通过承诺，我们可以在承诺链中以适当的方式处理错误。</p><blockquote class="lk ll lm"><p id="1483" class="jk jl ki jm b jn jo jp jq jr js jt ju ln jw jx jy lo ka kb kc lp ke kf kg kh ig bi translated">承诺可以“遵守”也可以“违背”。</p></blockquote><p id="bd4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用同样的逻辑，在JavaScript中，承诺可以被“履行”或“拒绝”。</p><p id="395a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有另一种状态，即“待定”。当一个承诺处于既没有实现也没有被拒绝的状态时，它就是待定的。一旦承诺被实现或拒绝，它就成立了。</p><p id="67a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Promise只有一个自变量，它是两个参数的函数:<strong class="jm io"> resolve </strong>和<strong class="jm io"> reject </strong>。如果一个承诺被实现或解决，我们承诺的异步代码的结果将是resolve参数中的值。否则，如果它被拒绝，错误对象将是reject参数中的值。当承诺被返回时，resolve或reject将具有值，而另一个将是未定义的。</p><blockquote class="lk ll lm"><p id="f60b" class="jk jl ki jm b jn jo jp jq jr js jt ju ln jw jx jy lo ka kb kc lp ke kf kg kh ig bi translated">Promise对象有实例方法。我们经常使用then()和catch()。</p></blockquote><h2 id="f767" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">如何创造一个承诺？</h2><p id="af69" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">通过承诺构造器，我们可以创建一个承诺。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/49c17402552896f00c84916e8654db77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ1pawNp6NKxE3JFIs6ljw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">How function works through callback</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/ffdfe9246cefc7fc77b693faa3fb3135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*vgovaGSMVkdb4GC76dcUmA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">How function works through promise</figcaption></figure><p id="8063" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，在第一张图中，我拿一个简单的函数，让你明白一个功能需求是如何通过回调和承诺来完成的。</p><p id="ce0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二张图中，我们可以看到addPositive()正在返回一个承诺，而不是接受一个回调参数。</p><p id="5fe5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两秒钟后，这个函数将返回一个Promise对象。我们没有将回调函数直接传递给addPositive()，而是将其传递给<strong class="jm io"> then() </strong>作为<strong class="jm io">的第一个参数</strong>。因此，返回值将被传递给我们在then()中传递的回调函数。</p><p id="2d58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果出现错误，它将被传递给在<strong class="jm io"> catch() </strong>中传递的回调函数。或者错误也可以传递给回调函数，我们在<strong class="jm io"> then() </strong>中将其作为<strong class="jm io">第二个参数</strong>传递。当承诺被拒绝时，就会调用这个函数。通常，我们使用catch()方法调用，而不是向then()方法传递两个回调。</p><h2 id="5e51" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">连锁承诺</h2><p id="1a78" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">承诺是可以连锁的。怎么会？。</p><p id="e612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以将一系列异步操作表示为一个线性的then()调用链。这是针对上述回调地狱的解决方案。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1333144503d15ce39deb3e2c714fe8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*B4jVf2wcXjyfs1d_Pz2vQQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Example for Promise chaining</figcaption></figure><p id="2136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Promise链中，正如我所说的，可以看到不止一个方法调用，它们被顺序调用。</p><ul class=""><li id="3792" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh na nb nc nd bi translated">addPositive()函数返回Promise1对象。</li><li id="7977" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated">之后，我们调用Promise1的then()方法，并传递‘result’回调函数，该函数将在Promise1兑现时被调用。</li><li id="a7e6" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated">then()方法将我们的“结果”回调存储在某个地方，并返回一个新的Promise2。</li><li id="74ed" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated">之后，下一个任务将在调用“结果”回调时开始(意味着Promise1现在已履行)，我们调用Promise2的then()方法并传递“结果2”回调，该回调将在Promise2履行且此时不再调用进一步的promises时调用。</li><li id="5cd2" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh na nb nc nd bi translated">所以现在，我们的承诺结束了，我们的计算也结束了。</li></ul><blockquote class="lk ll lm"><p id="62ab" class="jk jl ki jm b jn jo jp jq jr js jt ju ln jw jx jy lo ka kb kc lp ke kf kg kh ig bi translated">在ES2018中，Promise对象还定义了一个<strong class="jm io">。finally() </strong>方法，它在功能上相当于异常处理机制中的finally子句。</p></blockquote><h2 id="8842" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">更多关于承诺的信息</h2><h2 id="2a2d" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">Promise.all()</h2><p id="2a6d" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">我们可以并行运行多个承诺。Promise.all()函数就是这样做的。它接受一组Promise对象作为输入，并返回一个承诺。如果任何输入承诺被拒绝，返回的承诺将被拒绝。否则，它将通过每个输入承诺的已实现值的数组来实现。</p><h2 id="8cd6" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">Promise.allSettled()</h2><p id="207f" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">这个函数接受一个承诺数组作为输入，并像Promise.all()函数一样返回一个承诺。但是有很大的不同:</p><ol class=""><li id="d792" class="mv mw in jm b jn jo jr js jv mx jz my kd mz kh nj nb nc nd bi translated">这个函数永远不会拒绝返回的承诺。</li><li id="9bb3" class="mv mw in jm b jn ne jr nf jv ng jz nh kd ni kh nj nb nc nd bi translated">直到所有输入承诺都已结算，这才履行返回的承诺。</li></ol><p id="5a39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">承诺解析为一个对象数组，其中每个对象都是每个输入承诺的一个结果(如果输入承诺得到解析，则该结果可能具有实现值，否则，如果输入承诺被拒绝，则该结果可能具有错误值或拒绝值)。</p><h2 id="2839" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">承诺.竞赛()</h2><p id="21b4" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">如果我们想要运行多个承诺，但是我们只关心第一个承诺的结果，那么我们可以使用这个函数。当输入数组中的第一个承诺被履行或拒绝时，返回一个履行或拒绝的承诺。</p><p id="ef04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望您现在对JavaScript中的承诺有了更好的理解。</p><p id="6ffe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的下一篇文章再见！</p><p id="6b20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容尽在</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">plain English . io</em></a></p></div></div>    
</body>
</html>