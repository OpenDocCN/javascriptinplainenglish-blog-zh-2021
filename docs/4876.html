<html>
<head>
<title>How to Dynamically Update a React Component whilst Computing like a Maniac</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在疯狂计算的同时动态更新反应组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-dynamically-update-a-react-component-whilst-computing-like-a-maniac-8198b59f8a21?source=collection_archive---------1-----------------------#2021-10-01">https://javascript.plainenglish.io/how-to-dynamically-update-a-react-component-whilst-computing-like-a-maniac-8198b59f8a21?source=collection_archive---------1-----------------------#2021-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3f65dac70a17003954855c6f44042c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9WMS7M2joFAvqE56"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sammywilliams?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sammy Williams</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c5b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近遇到了一个问题，我正在执行一个连续的计算，返回中间结果，我想实时显示在反应组件中。不管我怎么尝试，组件只会在计算的<em class="ky">结束</em>时更新，只有那时中间结果才会同时出现。</p><p id="a3c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起初，我认为我错过了一些关于反应状态管理的东西，但是在遇到几个死胡同之后，我想到了在后台进行的密集处理不允许组件更新发生。幸运的是，我可以用几个非常简单的例子来说明这个问题(和一个解决方案)。</p><h1 id="5afd" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">它应该如何工作</h1><p id="4102" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">通常，人们通过内置于反应中的<code class="fe mc md me mf b">useState()</code>机制来更新组件。让我们从一个显示列表的简单应用程序开始:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="0c6d" class="mo la in mf b gy mp mq l mr ms">function App() {<br/>  const [items, setItems] = useState(['x', 'y']);</span><span id="161e" class="mo la in mf b gy mt mq l mr ms">  useEffect(() =&gt; {<br/>    itemsGenerator(setItems);<br/>  }, [])<br/></span><span id="5a3f" class="mo la in mf b gy mt mq l mr ms">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header &gt; HOWDY<br/>        &lt;MyList {...{ items }} /&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="0918" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用一个数组初始化一个名为<code class="fe mc md me mf b">items</code>的状态，组件MyList(未显示)显示<code class="fe mc md me mf b">items</code>中的内容。这是基本的反应材料。</p><p id="aef9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当组件被加载时<code class="fe mc md me mf b">useEffect</code>钩子从我的项目“生成器”开始。我使用引号是因为它不是一个生成器<em class="ky">函数</em>(我在后面会讲到)。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1cb1" class="mo la in mf b gy mp mq l mr ms">const itemsGenerator = (setItems) =&gt; {<br/>  arr.forEach((item) =&gt; {<br/>    setTimeout(() =&gt; setItems((prevState) =&gt; prevState.concat(item)), 1000 * delayCt++)<br/>  })<br/>}</span></pre><p id="d787" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成器使用<code class="fe mc md me mf b">setTimeout()</code>以递增的时间间隔更新项目状态。当我运行这个程序时，我看到<code class="fe mc md me mf b">MyList</code>每隔一秒钟一次添加一个新项目。太好了。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="0ed4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">如何打破它</h1><p id="af56" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">正如我之前所说的，在后台运行一个计算密集型的操作，这并不那么简单。可以创建一个生成器来连接JavaScript的单个事件循环。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="fb55" class="mo la in mf b gy mp mq l mr ms">const itemsGenerator2 = (setItems) =&gt; {<br/>  var index = 0;<br/>  while (index &lt; arr.length) {<br/>    const thenTime = Date.now()<br/>    while (Date.now() - thenTime &lt; 1000);  // tight wait loop<br/>    const item = arr[index++]</span><span id="618e" class="mo la in mf b gy mt mq l mr ms">    setItems((prevState) =&gt; prevState.concat(item))<br/>  }<br/>}</span></pre><p id="ec9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该功能与前一个发生器相同，每秒更新<code class="fe mc md me mf b">items</code>状态。你会注意到这次它没有使用<code class="fe mc md me mf b">setTimeout()</code>了:它只是紧循环运行，不断检查<code class="fe mc md me mf b">Date.now()</code>直到第二次通过，同时迭代数组中的每个元素。</p><p id="f7d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这不适用于实时更新<code class="fe mc md me mf b">MyList</code>。不是每一个项目分开一秒钟添加到列表中，而是所有项目在三秒钟后出现在列表中。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="aa46" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">如何修复它</h1><p id="142b" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">处理JavaScript单线程的线程都因为<code class="fe mc md me mf b">while</code>循环而被捆绑。没有时间处理UI事件了。解决方案是创建一个新线程，所有计算密集型的事情都在这里发生。这释放了事件处理。Web workers 是一种启动线程的简单方法，所以我将使用它们。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2f7d" class="mo la in mf b gy mp mq l mr ms">const itemsGenerator3 = (setItems) =&gt; {<br/>  let worker = new Worker('itemsGenerator3.js')<br/>  worker.postMessage('Go!')<br/>  worker.onmessage = e =&gt; {<br/>    if (/Kill me.*/.test(e.data)) {<br/>      worker.terminate();<br/>    } else {<br/>      setItems((prevState) =&gt; prevState.concat(e.data))<br/>    }<br/>  }<br/>}</span></pre><p id="746d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个新的生成器创建一个工作线程，告诉它“开始！”，并等待响应。除非工作人员要求终止，否则每个响应(假设为一个项目)都被附加到<code class="fe mc md me mf b">items</code>状态。工作线程的代码(也叫做<code class="fe mc md me mf b">itemsGenerator3,</code> <strong class="kc io">对不起</strong>)驻留在网站上的一个公共文件夹中(<strong class="kc io">而不是</strong>藏在应用程序源文件夹中)。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="c5f9" class="mo la in mf b gy mp mq l mr ms">const arr = ["nnn", "ooo", "ppp", "qqq"];</span><span id="c52f" class="mo la in mf b gy mt mq l mr ms">onmessage = e =&gt; {<br/>  if (e.data !== 'Go!')<br/>    postMessage("no go")<br/>  else {<br/>    var index = 0;<br/>    while (index &lt; arr.length) {<br/>      const thenTime = Date.now()<br/>      while (Date.now() - thenTime &lt; 1000);  // tight wait loop<br/>      const item = arr[index++]</span><span id="6c0a" class="mo la in mf b gy mt mq l mr ms">      postMessage(item)<br/>    }<br/>    postMessage("Kill me! Kill me now!")<br/>  }<br/>}</span></pre><p id="6b5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工人等待“开始！”信息，然后起飞。它使用与前面的生成器相同的tight while循环，但不更新<code class="fe mc md me mf b">items</code>状态；相反，它会向<code class="fe mc md me mf b">itemsGenerator3()</code>呼叫者发送一条消息。当数组耗尽时，它会通知调用方，以便终止工作线程。</p><p id="010c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我的列表每秒更新一项。</p><figure class="mg mh mi mj gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="d619" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">如果我们使用一个真正的生成器函数会发生什么？</h1><p id="9809" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">生成器函数有一个<code class="fe mc md me mf b">yield</code>命令，它可能会让你认为它产生了事件处理线程，但事实并非如此——它产生了一个值，仅此而已。事实上，如果我尝试使用一个生成器函数，我会看到非常奇怪的事情发生。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2aa4" class="mo la in mf b gy mp mq l mr ms">function* itemTrueGenerator() {<br/>  var index = 0;<br/>  while (index &lt; arr.length) {<br/>    const thenTime = Date.now()<br/>    while (Date.now() - thenTime &lt; 1000);  // tight wait loop<br/>    const item = arr[index++]<br/>    yield item<br/>  }<br/>}</span><span id="9e7e" class="mo la in mf b gy mt mq l mr ms">const itemsGenerator4 = (setItems) =&gt; {<br/>  const it = itemTrueGenerator()<br/>  let item = it.next()</span><span id="9421" class="mo la in mf b gy mt mq l mr ms">  while (!item.done) {<br/>    const itemValue = item.value<br/>    console.log({ itemValue })<br/>    setItems(prevState =&gt; {<br/>      console.log({ prevState, itemValue })<br/>      prevState.concat(itemValue)<br/>    }<br/>    )<br/>    console.log('next')<br/>    item = it.next()<br/>  }<br/>}</span></pre><p id="95c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mc md me mf b">itemsGenerator4()</code>函数调用一个真正的生成器函数，使用那个可怕的while循环每秒产生值。唉，这真的把事情弄糟了。注意<code class="fe mc md me mf b">itemsGenerator4()</code>中的<code class="fe mc md me mf b">console.log()</code>语句。见证人:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2a43" class="mo la in mf b gy mp mq l mr ms">App.js:56 {itemValue: 'nnn'}<br/>App.js:56 {prevState: Array(2), itemValue: 'nnn'}<br/>App.js:60 next<br/>App.js:54 {itemValue: 'ooo'}<br/>App.js:60 next<br/>App.js:54 {itemValue: 'ppp'}<br/>App.js:60 next<br/>App.js:54 {itemValue: 'qqq'}<br/>App.js:60 next<br/>react-dom.development.js:3942 [Violation] 'message' handler took 4003ms<br/>App.js:56 {prevState: undefined, itemValue: 'ooo'}<br/>App.js:56 {prevState: undefined, itemValue: 'ooo'}</span></pre><p id="e160" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成器工作正常，但是setItems()调用…嗯，不太好。我很想告诉你这里发生了什么，但这超出了我的理解范围。如果我遇到一个好的解释，我会发布一个后续。</p><p id="9dbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">— —</p><p id="ba79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章的源代码是这里的<a class="ae jz" href="https://github.com/JeffML/reactDynaList" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>