<html>
<head>
<title>The Perfect Way to Use React’s useEffect Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React的useEffect挂钩的最佳方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-perfect-way-to-use-useeffect-hook-of-react-a6d08af0e3fa?source=collection_archive---------14-----------------------#2021-05-17">https://javascript.plainenglish.io/the-perfect-way-to-use-useeffect-hook-of-react-a6d08af0e3fa?source=collection_archive---------14-----------------------#2021-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经以不同的或者完全错误的方式使用了<strong class="jp ir"> useEffect </strong>钩子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2aed7a67997e7c5febc064305d83951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDhuEK5g5xkA9idNaZ9wBg.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="c68d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在后台</h1><p id="b937" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">先说基本的，最常用的挂钩。我将尝试让你深入了解如何以更好的、近乎完美的方式实现useEffect。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="51f8" class="mh lf iq bd lg mi mj dn lk mk ml dp lo jy mm mn ls kc mo mp lw kg mq mr ma ms bi translated">内侧端托架使用效果</h2><p id="d426" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们可以使用useEffect控制React组件的条件呈现。useEffect钩子非常强大，它已经取代了我们在类组件中使用的许多钩子方法。让我解释一下。<strong class="jp ir">shouldcomponentdimount</strong>应该返回一个布尔值，并根据该布尔值，React决定是否重新呈现DOM。因此，通过在<strong class="jp ir"> shouldComponentDidMount </strong>方法中提供一个条件，我们可以控制React组件的重新呈现。如何使用效果是通过提供一个括号作为第二个参数。</p><p id="3121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">useEffect是一个接受两个参数的钩子，第一个是回调函数，第二个是一个带有单个或多个可变属性或状态的括号。括号内定义的值帮助useEffect决定是否重新渲染React组件。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="2027" class="mh lf iq mu b gy my mz l na nb">const [ data, setData ] = useState()</span><span id="5138" class="mh lf iq mu b gy nc mz l na nb">useEffect(() =&gt; {}, <br/> // Inside the bracket always add some value don't leave it empty <br/>[ data ]<br/>);</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="94ab" class="mh lf iq bd lg mi mj dn lk mk ml dp lo jy mm mn ls kc mo mp lw kg mq mr ma ms bi translated">更好使用的提示</h2><p id="5af2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">始终为括号提供一个值是一个好习惯。我们经常忘记在第二个参数的useEffect括号内添加任何值，这就像虚张声势React虚拟DOM或钩子。React依赖于这个括号来决定其特定组件的重新渲染条件。因此，在useEffect括号内提供一个值作为第二个参数总是一个好的做法。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="7270" class="mh lf iq bd lg mi mj dn lk mk ml dp lo jy mm mn ls kc mo mp lw kg mq mr ma ms bi translated">清除useEffect中的函数</h2><p id="b5fd" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这是大多数开发者所不知道的。一旦React组件被卸载，useEffect钩子确实提供了一种取消函数或清除函数的方法。</p><p id="458a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用了一个类组件，那么您必须知道一旦特定的React组件被卸载，就会调用的<strong class="jp ir"> componentDidUnMount </strong>方法。</p><p id="2902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在useEffect回调中，我们可以返回一个指示useEffect的函数，以便在组件被卸载后清除该函数。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="84af" class="mh lf iq mu b gy my mz l na nb">const [ data, setData ] = useState()</span><span id="e1ea" class="mh lf iq mu b gy nc mz l na nb">useEffect(() =&gt; {},</span><span id="2c22" class="mh lf iq mu b gy nc mz l na nb">// This return will get called on unmounting of this component<br/> return () =&gt; {<br/>  clearInterval(() =&gt; {})<br/> }</span><span id="e025" class="mh lf iq mu b gy nc mz l na nb">[ data  ]<br/>);</span></pre><p id="ac35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您希望在一个被卸载的特定组件和下一个组件被装载之前进行API调用时，这种情况非常有用。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="53d3" class="mh lf iq bd lg mi mj dn lk mk ml dp lo jy mm mn ls kc mo mp lw kg mq mr ma ms bi translated">useEffect内部的异步回调</h2><p id="6bb3" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">大多数API本质上都是异步的，为了获取任何组件的数据，我们总是倾向于useEffect。因此，在这种情况下，您还可以提供一个异步回调函数来使用Effect。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经使用了async-await功能从API中获取数据，并在状态中更新API中的数据。这是从useEffect内部的API加载数据的最完美的方式。您甚至可以将Axios方法解耦到另一个函数中，用<strong class="jp ir"> fetchData </strong>作为方法名。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="3a84" class="mh lf iq bd lg mi mj dn lk mk ml dp lo jy mm mn ls kc mo mp lw kg mq mr ma ms bi translated">取消Axios请求</h2><p id="a628" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">使用Axios发出API请求后，您可以在卸载组件期间取消该请求。为此，您可以使用Axios的cancel方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6a52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果用户立即转到另一个页面，这对于避免过量提取或不必要的API请求非常重要。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="9e81" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="278d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">单一的useEffect钩子如此强大，以至于它的单一句柄取代了React生命周期的类组件的所有方法。我曾经在一次采访中被问到——功能组件能控制React的每一个生命周期吗？</p><p id="6f54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我说是的，尽管面试官并不信服，也许是因为他对功能组件的先入为主的怀疑。是的，功能组件非常强大，可以控制React生命周期的每个阶段。</p><p id="eafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次见。祝大家愉快！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><div class="km kn ko kp gt nf"><a href="https://medium.com/nerd-for-tech/3-minute-roadmap-to-master-the-next-js-in-2021-e022fee244b0" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">掌握2021年下一个JS的3分钟路线图</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">2021年掌握下一个JS的完整指南</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kv nf"/></div></div></a></div><div class="nu nv gp gr nw nf"><a href="https://medium.com/nerd-for-tech/understanding-javascript-creating-sample-json-data-4500db528b9b" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">理解JavaScript —创建示例JSON数据</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">创建用户的样本JSON数据。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="nx l nq nr ns no nt kv nf"/></div></div></a></div><div class="nu nv gp gr nw nf"><a rel="noopener  ugc nofollow" target="_blank" href="/everything-in-react-native-starts-with-cards-and-ends-with-cards-7d35979f6023"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">React Native中的一切都是以卡开始，以卡结束</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">开发可重用组件的秘密。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="no l"><div class="ny l nq nr ns no nt kv nf"/></div></div></a></div><p id="4618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nz">更多内容尽在</em><a class="ae oa" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nz">plain English . io</em></a></p></div></div>    
</body>
</html>