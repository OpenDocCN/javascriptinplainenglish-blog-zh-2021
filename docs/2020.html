<html>
<head>
<title>How to Create Objects Using Factory Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用工厂函数创建对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-factory-functions-cbc5b744671b?source=collection_archive---------1-----------------------#2021-04-28">https://javascript.plainenglish.io/javascript-factory-functions-cbc5b744671b?source=collection_archive---------1-----------------------#2021-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b0da" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">本文将介绍使用工厂函数在JavaScript中构建一个对象。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b297e312f46a086dc6f3f2b33b19429d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*270Yr8UUBfdFyZej"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@alexander_tsang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Tsang</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b201" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当学习JavaScript和任何其他主题时，我倾向于问“为什么？”为什么要这样做？为什么我必须知道这些？为什么？</p><p id="1045" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我承认，‘为什么？’可能是个烦人的问题。“因为我是这么说的”是我父母在成长过程中常说的一句话。令他们懊恼的是，这并没有阻碍我理解“为什么”的努力。</p><p id="59cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些都是为了说明我正在试图理解我们是如何发展到JavaScript类的。我认为开发类似类的对象来展示我们现在所知的JavaScript类会很有趣。</p><p id="f085" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将介绍如何使用工厂函数构建一个对象，接下来的一篇文章将介绍构造函数并使用new运算符来创建相同的对象，最后一篇文章将介绍作为类构建的相同对象。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="ed86" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">工厂功能</h1><blockquote class="mo mp mq"><p id="7a16" class="kt ku mr kv b kw kx jo ky kz la jr lb ms ld le lf mt lh li lj mu ll lm ln lo ig bi translated">在<a class="ae ks" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程(OOP) </a>中，<strong class="kv io">工厂</strong>是<a class="ae ks" href="https://en.wikipedia.org/wiki/Object_creation" rel="noopener ugc nofollow" target="_blank">创建其他对象</a>的<a class="ae ks" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">对象</a>——形式上，工厂是从某个方法调用返回不同原型或类<a class="ae ks" href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>对象的函数或方法，这被认为是“新的”。</p><p id="94cf" class="kt ku mr kv b kw kx jo ky kz la jr lb ms ld le lf mt lh li lj mu ll lm ln lo ig bi translated">— <a class="ae ks" href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="6a6b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果上面的引用没有弄清楚什么是工厂函数，就把它想象成一个不使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">构造函数</a>或类而返回一个对象的函数。</p><p id="b547" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我刚刚重新观看了MCU的第1阶段，所以我们的工厂函数将创建一个表示超级英雄的对象，因为这是我曾经使用的所有示例，所以为什么现在停止呢？</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="bc88" class="na lx in mw b gy nb nc l nd ne">const avengers = [];</span><span id="e401" class="na lx in mw b gy nf nc l nd ne">const captainAmerica = {<br/>   name: 'Steven Rogers',<br/>   alias: 'Captain America',<br/>   abilities: [<br/>      'Enhanced strength, speed, stamina, durability, agility, reflexes, senses, and mental processing via the super soldier serum',<br/>      'Master martial artist and hand-to-hand combatant',<br/>      'Accelerated healing',<br/>      'Immunity to diseases and toxins',<br/>      'Slowed aging', <br/>      'Master tactician, strategist, and field commander',<br/>      'Using Vibranium-steel alloy shield']<br/>}</span></pre><p id="6508" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面你会看到我们有一个代表美国队长的物体。现在，让我们创建一个工厂函数来为我们创建这个对象。</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="4b75" class="na lx in mw b gy nb nc l nd ne">const makeHero = (name, alias, abilities) =&gt; {<br/>  const hero = {};<br/>  hero.name = name;<br/>  hero.alias = alias;<br/>  hero.abilities = abilities;<br/>  return hero;<br/>}</span></pre><p id="71b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">就是这样。那是工厂功能。它没有工厂函数那么激动人心，但它是一个不使用构造函数或类就返回对象的函数。要使用这个工厂创建一个新对象，我们应该编写:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="b64c" class="na lx in mw b gy nb nc l nd ne">const captainAmerica = makeHero('Steven Rogers', 'Captain America', ['Enhanced strength, speed, stamina, durability, agility, reflexes, senses, and mental processing via the super soldier serum',<br/>'Master martial artist and hand-to-hand combatant',<br/>'Accelerated healing',<br/>'Immunity to diseases and toxins',<br/>'Slowed aging',<br/>'Master tactician, strategist, and field commander',<br/>'Using Vibranium-steel alloy shield']);</span></pre><p id="8491" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是这真的能节省我们的时间吗？不完全是。我们仍然需要手工输入所有的信息。但是，如果我们想把我们的复仇者组合成一个阵列呢？嗯，我们可以创建引用数组的变量，比如<code class="fe ng nh ni mw b">const avengers = [];</code>。然后我们可以用JS给我们的数组方法添加和移除对象，比如<code class="fe ng nh ni mw b">push()</code> &amp; <code class="fe ng nh ni mw b">pop()</code>。那将会起作用，但是更有趣的是如果我们在工厂内部创建函数来添加或删除<code class="fe ng nh ni mw b">avengers</code>数组中的英雄？这将允许我们的对象使用相同的方法在<code class="fe ng nh ni mw b">avengers</code>数组中添加和删除它们自己！</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="67d9" class="na lx in mw b gy nb nc l nd ne">const makeHero = (name, alias, abilities) =&gt; {<br/>  const hero = {};<br/>  hero.name = name;<br/>  hero.alias = alias;<br/>  hero.abilities = abilities;<br/>  hero.assemble = function () {<br/>    avengers.includes(this)<br/>      ? console.log(<br/>          `${this.alias} has already been assembled into the<br/>           Avengers`<br/>        )<br/>      : avengers.push(this);<br/>    <em class="mr">return</em> avengers;<br/>  };<br/>  hero.disassemble = function () {<br/>    const heroToRemove = avengers.findIndex(<br/>      (hero) =&gt; hero === this<br/>    );<br/>    heroToRemove === -1<br/>      ? console.log(<br/>          `${this.alias} has already been disassembled from the<br/>           Avengers`<br/>        )<br/>      : avengers.splice(heroToRemove, 1);<br/>    <em class="mr">return</em> avengers;<br/>  };<br/>  <em class="mr">return</em> hero;<br/>}</span></pre><p id="9538" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看那个！当我们用我们的工厂函数创建一个新对象时，它可以使用这些来自我们工厂的内置方法，节省我们大量的时间(好吧，也许不是大量的时间)。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="1bd7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">工厂函数对创建对象非常有帮助，但是还有其他方法可以实现这一点。下周我将深入探讨这个问题。</p><p id="b31c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编码快乐！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="96d9" class="na lx in bd ly nj nk dn mc nl nm dp mg lc nn no mi lg np nq mk lk nr ns mm nt bi translated">有趣的相关阅读</h2><p id="e215" class="pw-post-body-paragraph kt ku in kv b kw nu jo ky kz nv jr lb lc nw le lf lg nx li lj lk ny lm ln lo ig bi translated">[1]埃里克埃利奥特。(2016) <a class="ae ks" href="https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e" rel="noopener"> JavaScript工厂函数vs构造函数vs类</a>。</p><p id="0b11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[2]埃里克·埃利奥特。(2017) <a class="ae ks" href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" rel="noopener">带ES6+ </a>的JavaScript工厂函数。</p><p id="53e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[3] rajaraodv。(2016)<a class="ae ks" href="https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65" rel="noopener">ES6中的“类”是新的“坏”的部分吗？</a>。</p><p id="fe9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>