<html>
<head>
<title>Type Guards and Control Flow Analysis in TypeScript 4.4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.4中的类型保护和控制流分析</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-4-4-be-on-your-guard-7e3bb2e3ebbe?source=collection_archive---------7-----------------------#2021-08-27">https://javascript.plainenglish.io/typescript-4-4-be-on-your-guard-7e3bb2e3ebbe?source=collection_archive---------7-----------------------#2021-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8354" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">警惕</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9b13f35ccef25c4dc6d5a39a406170fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-wxMrqI0Hawghca0LNJZA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The Guard</figcaption></figure><p id="4c95" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了庆祝<a class="ae lo" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.4 </a>的发布，我探索了TypeScript中的类型联合，以及该语言如何使用类型保护和控制流分析来自动细化变量的类型。</p><p id="ebb4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我将报道:</p><ul class=""><li id="42ba" class="lp lq in ku b kv kw ky kz lb lr lf ls lj lt ln lu lv lw lx bi translated">什么是类型联合</li><li id="2437" class="lp lq in ku b kv ly ky lz lb ma lf mb lj mc ln lu lv lw lx bi translated">类型保护和控制流分析</li><li id="b9ec" class="lp lq in ku b kv ly ky lz lb ma lf mb lj mc ln lu lv lw lx bi translated">4.4的CFA用于混叠条件和鉴别条件</li></ul><h1 id="627f" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">介绍</h1><p id="b32e" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">我以前谈到过TypeScript的实用主义，用类型安全来增强JavaScript，以改善开发体验。但是它不仅仅是JavaScript上的一层薄薄的静态类型，它还有一个非常强大的类型系统。在TypeScript中，可以使用类型联合、类型交集、映射类型和条件类型从现有类型派生新类型。这种类型编程能力允许我们减少代码重复，并在定义类型时拥有单一的真实来源。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c609" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这篇文章中，我将深入研究类型联合，因为<a class="ae lo" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.4 </a>增加了编译器对联合类型检查的更自然使用的支持。如果你想在上面的任何一个项目上发帖，一定要喜欢并留下评论。</p><h1 id="1a0d" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">类型联合太棒了</h1><p id="dbcf" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">类型联合允许我们定义一个新的类型，它代表一组可能的类型中的任何一个。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6108" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里，类型联合<code class="fe nc nd ne nf b">Primitive</code>意味着<code class="fe nc nd ne nf b">x</code>可以引用一个<code class="fe nc nd ne nf b">string</code>或<code class="fe nc nd ne nf b">number</code>或<code class="fe nc nd ne nf b">boolean</code>值。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="73eb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这在JavaScript世界中尤其重要，因为API经常包含接受或返回不同类型值的函数。库利用动态类型将许多不同的行为压缩到一个函数中。有了TypeScript中的联合，我们就可以安全地限制到一组有效的类型，而不是去最高的抽象层<code class="fe nc nd ne nf b">any</code>或<code class="fe nc nd ne nf b">unknown</code>。</p><p id="2073" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是如果<code class="fe nc nd ne nf b">x</code>可以是这些可能类型中的任何一种，我们<em class="ng">可以安全地</em>用<code class="fe nc nd ne nf b">x</code>做什么呢。事实证明，在这种情况下，不太多:</p><p id="2df2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">自动完成显示我们能做的只有<code class="fe nc nd ne nf b">valueOf</code>、<code class="fe nc nd ne nf b">toString</code>和<code class="fe nc nd ne nf b">toLocaleString</code>。我们可以安全地在一个联合中使用的唯一API是那些对联合的所有成员通用的API。</p><p id="3165" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们当然可以对特定类型使用类型断言:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b6df" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是我们怎么知道我们的断言是正确的，值是正确的类型呢？当然，如果我们有任何疑问，在JavaScript中，我们会写一些代码来测试数据。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="10d0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">TypeScript通过检查我们程序的控制流(<code class="fe nc nd ne nf b">if</code> s、<code class="fe nc nd ne nf b">switch</code> es等)来简化这种代码，并自动提炼或<strong class="ku io">缩小变量的类型(在其他语言中可能被称为<strong class="ku io">智能转换</strong>)。因此，在<code class="fe nc nd ne nf b">if</code>块中，它自动将<code class="fe nc nd ne nf b">x</code>解释为<code class="fe nc nd ne nf b">number</code>。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0d60" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">此外，在这个<code class="fe nc nd ne nf b">if</code>的<code class="fe nc nd ne nf b">else</code>块上，<code class="fe nc nd ne nf b">x</code>的类型将是联合的剩余部分。因此，在这种情况下，它将被缩小到<code class="fe nc nd ne nf b">string | boolean</code>。</p><p id="f549" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">编译器在这里做的叫做<strong class="ku io">控制流分析</strong> (CFA)，我们写的条件叫做<strong class="ku io">类型保护</strong>。编译器可以通过<code class="fe nc nd ne nf b">if</code>、<code class="fe nc nd ne nf b">switch</code>、<code class="fe nc nd ne nf b">throw</code>、<code class="fe nc nd ne nf b">return</code>以及逻辑(<code class="fe nc nd ne nf b">&amp;&amp;</code>、<code class="fe nc nd ne nf b">||</code>)、赋值、等式、三元(<code class="fe nc nd ne nf b">? :</code>)等运算符来分析控制流。</p><p id="87c1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">真正优雅的是，我们编写的代码与用JavaScript编写的代码相同——注意，上面没有类型注释。打字稿的区别是我们得到了<strong class="ku io">型安全</strong>和<strong class="ku io">更好的工具</strong>。</p><h1 id="8180" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">铅字护板的类型</h1><p id="3cda" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">使用<code class="fe nc nd ne nf b">typeof</code>只是一个保护示例。让我们来分解一下类型守卫的类型。我拒绝把它们归类为太难打字的类型。打字！</p><h1 id="8201" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated"><code class="fe nc nd ne nf b">null</code>守卫</h1><p id="91e5" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated"><code class="fe nc nd ne nf b">null</code>检查是最常见的警卫之一。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ea60" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当然，我们可以使用可选的链接来简化这一点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="33d5" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated"><code class="fe nc nd ne nf b">typeof</code>守卫</h1><p id="c330" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">我们已经看到了<code class="fe nc nd ne nf b">typeof</code>守卫的行动。这是另一个使用开关的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4696" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">记住<code class="fe nc nd ne nf b">typeof</code>只能告诉我们一个类型是不是<code class="fe nc nd ne nf b">string</code>、<code class="fe nc nd ne nf b">number</code>、<code class="fe nc nd ne nf b">boolean</code>、<code class="fe nc nd ne nf b">symbol</code>、<code class="fe nc nd ne nf b">function</code>、<code class="fe nc nd ne nf b">bigint</code>、<code class="fe nc nd ne nf b">undefined</code>。其他的都要回归<code class="fe nc nd ne nf b">"object"</code>。</p><h1 id="7f0d" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated"><code class="fe nc nd ne nf b">instanceof</code>守卫</h1><p id="1322" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">使用<code class="fe nc nd ne nf b">instanceof</code>我们可以测试一个对象是否是一个类的实例，或者是从一个类派生的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5e59" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意，if/else块中的所有属性集在外部都会失败，因为它们不是两种类型所共有的。</p><h1 id="74e1" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated"><code class="fe nc nd ne nf b">in</code>守卫</h1><p id="b92d" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated"><code class="fe nc nd ne nf b">in</code>操作符允许我们测试一个对象是否存在成员。在下面的代码中，只有<code class="fe nc nd ne nf b">HTMLTextAreaElement</code>有一个<code class="fe nc nd ne nf b">rows</code>属性，所以通过测试它的存在，编译器确定每个分支上的<code class="fe nc nd ne nf b">input</code>变量的类型并缩小类型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="fd96" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">注意，<code class="fe nc nd ne nf b">in</code>只能在<strong class="ku io">联合的所有</strong>成员都是对象类型(非原语)时使用。</p><h1 id="21e6" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">受歧视的工会警卫</h1><p id="07b2" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">鉴别联合是这样一种设计，其中联合中的每个类型都包含一个唯一标识或允许编译器鉴别该类型的成员。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="68fb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里，<code class="fe nc nd ne nf b">kind</code>属性对所有类型都是通用的，所以我们可以在类型为<code class="fe nc nd ne nf b">Animal</code>的变量上访问它。TypeScript可以使用此属性与可能值的比较来适当缩小类型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="62ab" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">再次强调，这里最棒的是我们没有编写任何类型注释或断言，但是编译器仍然在进行错误检查，IDE可以给我们很多自动完成和支持。</p><h1 id="2e27" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">用户定义的防护</h1><p id="b0cc" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">在TypeScript 4.4之前，用户定义的保护是提高这类代码可读性的唯一方法。用户定义的守卫允许我们将类型检查逻辑和守卫分解到命名函数中。</p><p id="9b2c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，考虑前面检查HTML元素的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d4e9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我经常会把这样的检查分解到一个函数中，但是编译器不会深入到函数中去寻找类型保护，所以缩小<strong class="ku io">不会发生</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b4c2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须做的是将返回类型从<code class="fe nc nd ne nf b">boolean</code>改为类型谓词。如果我们的布尔函数返回<code class="fe nc nd ne nf b">true</code>，这允许我们提供关于输入参数的编译器类型信息。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="a17f" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">断言函数</h1><p id="ce51" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">我们可以以类似的方式使用断言函数。断言函数通知编译器，如果某个条件不成立，它将抛出一个错误。我们可以使用它们来断言一个输入参数具有某种类型，然后CFA将适当地缩小范围。语法类似于用户定义的类型保护，只是我们在类型谓词前面加上了前缀<code class="fe nc nd ne nf b">asserts</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="20ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里的优势是它消除了缩进，仍然缩小。这对于开发人员在函数顶部(旧的含义是“守卫”)或测试中的断言非常有用。</p><h1 id="1172" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">TypeScript 4.4改进了什么</h1><p id="1896" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">尽管用户定义的类型保护和断言函数有助于提高可读性，但它们是一种粗糙的工具。TypeScript 4.4编译器带来了保留变量的控制流分析信息的能力，因此我们可以编写更自然的代码并保留缩小功能。</p><p id="90c4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，下面的代码在TypeScript 4.4之前将不起作用，因为保护被分解为一个变量:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f294" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在TypeScript 4.4中，这段代码可以正常工作。变量<code class="fe nc nd ne nf b">isTextArea</code>保留了表示<code class="fe nc nd ne nf b">input</code>是否为<code class="fe nc nd ne nf b">HTMLTextAreaElement</code>的信息，这可以被CFA拾取。它称这些<strong class="ku io">为别名条件</strong>。</p><p id="c33a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这些条件可以使用到目前为止描述的所有保护，可以合并多个条件，甚至可以过渡性地工作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="15e9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe nc nd ne nf b">canSpeak</code>变量是另外两个变量的“或”,但是这两个变量的类型信息被组合并应用到<code class="fe nc nd ne nf b">canSpeak</code>。</p><h1 id="72fe" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">限制</h1><p id="475e" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">以下限制本身并不是批评，而仅仅是我为了更好地理解这个特性而进行的实验。</p><h2 id="d21f" class="nh me in bd mf ni nj dn mj nk nl dp mn lb nm nn mp lf no np mr lj nq nr mt ns bi translated">只有条件有别名</h2><p id="b299" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">这种类型的信息别名只对条件有效。如果我们创建变量来包含关键信息，然后根据这些信息构建条件，那么类型保护行为就不起作用了。例如，这里我们将<code class="fe nc nd ne nf b">typeof</code>结果存储在一个变量中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="05f9" class="nh me in bd mf ni nj dn mj nk nl dp mn lb nm nn mp lf no np mr lj nq nr mt ns bi translated">仅顶层变量</h2><p id="f016" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">TypeScript足够聪明，普通类型保护支持嵌套属性的缩小。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="70e7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我们有一个防止属性嵌套在一个对象中两层的类型保护，但是编译器仍然缩小了范围。但是，这不适用于新的别名条件(即使是单层嵌套)。它必须是顶级变量。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="2eee" class="nh me in bd mf ni nj dn mj nk nl dp mn lb nm nn mp lf no np mr lj nq nr mt ns bi translated">过渡深度极限</h2><p id="da7b" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">编译器在多大程度上应用传递规则也是有限制的。我很好奇这个限制是什么，所以写了下面的(可怕的)代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4854" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因此，我们有一个大的区别对待的联盟，其中所有成员都有一个<code class="fe nc nd ne nf b">child</code>属性，只有一个除外<code class="fe nc nd ne nf b">Terminal</code>。接下来，我创建了一系列相互依赖的条件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="be4d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我的目标是看看我们丢失了哪个变量的类型保护信息，以确保<code class="fe nc nd ne nf b">root</code>不是<code class="fe nc nd ne nf b">Terminal</code>类型。我所发现的是，下面的行工作作为<code class="fe nc nd ne nf b">root</code>已知有一个<code class="fe nc nd ne nf b">child</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5f64" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">而下面一行并不像编译器不知道<code class="fe nc nd ne nf b">root</code>是什么:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="93ae" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">指示4级嵌套混淆。我不认为这是一个问题——我只是好奇，觉得测试一下会很有趣。</p><h1 id="e922" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">结论</h1><p id="593d" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">我希望你能找到和我一样酷的警卫。TypeScript 4.4的更新并不是很华丽，但这一变化对于保持代码的整洁和安全非常有用，无需添加大量的类型注释。</p><p id="96d9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您还没有这样做，请查看我的帖子，这些帖子展示了<a class="ae lo" href="https://medium.com/swlh/crazy-powerful-typescript-4-1-features-26036f4de6bc" rel="noopener"> TypeScript 4.1 </a>、<a class="ae lo" href="https://levelup.gitconnected.com/crazy-powerful-typescript-tuple-types-9b121e0a690c" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.2 </a>和<a class="ae lo" href="https://levelup.gitconnected.com/typescript-4-3-i-object-your-honour-2db0368c07cb" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.3 </a>中的一些有用功能。</p><p id="cf05" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">此外，请务必查看我们的<a class="ae lo" href="https://instil.co/courses/introduction-to-typescript-course/" rel="noopener ugc nofollow" target="_blank">打字稿</a>课程。我们也很乐意使用TypeScript提供<a class="ae lo" href="https://instil.co/courses/introduction-to-angular/" rel="noopener ugc nofollow" target="_blank">Angular</a>&amp;<a class="ae lo" href="https://instil.co/courses/react-with-typescript-course/" rel="noopener ugc nofollow" target="_blank">React</a>培训。我们几乎为世界各地的公司提供服务，并且很乐意根据您团队的水平和具体需求定制我们的课程。来看看我们是否能帮助你和你的团队。</p><p id="b02b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">原贴<a class="ae lo" href="https://instil.co/blog/typescript-44-type-guards/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="a8b6" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">关于标题图像</h1><p id="7cfc" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">帖子的标题图片是布莱丹·格里森，取自电影《警卫T21》。这是一部关于爱尔兰警察的黑色喜剧。爱尔兰的警察部门被称为“爱尔兰和平卫士”，其成员被称为“卫士”。我喜欢空洞的电影参考。</p></div></div>    
</body>
</html>