<html>
<head>
<title>Moving Away from React and Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">远离React和Vue.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/frontend-clean-architecture-ca2592bd9d58?source=collection_archive---------1-----------------------#2021-07-11">https://javascript.plainenglish.io/frontend-clean-architecture-ca2592bd9d58?source=collection_archive---------1-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a22d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用干净的架构在前端摆脱React和Vue.js</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/21176da6c21a91e4ab01c68fa68026c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5xM7RDJ7wQruOA5FzDGRw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">front-end Clean Architecture</figcaption></figure><p id="c06f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文是我博客中原文的英文翻译:<a class="ae lo" href="http://xurxodev.com/frontend-clean_architecture/" rel="noopener ugc nofollow" target="_blank">alejándonos de react js y vue js en El front end usando Clean Architecture</a>。</p><p id="0c3e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用Clean Architecture的优势之一是能够将我们的应用程序的交付机制与用户分离，也就是说，与UI框架或库分离。</p><p id="414c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种在长期应用中的优势允许我们在未来适应库和框架中必然会发生的变化。</p><p id="d84f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本文中，我们将通过应用两种交付机制:React和Vue.js，在前端将干净的架构发挥到极致。</p><p id="d106" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将在两个实现之间尽可能多地重用代码。</p><p id="ccdc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这可以通过创建React和Vue.js的域、数据和远程显示逻辑来实现。</p><h1 id="4d1d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">为什么要脱离框架？</h1><p id="4f05" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">我开发了不同的技术应用清洁建筑，如。Net，Android，iOS，和Flutter。很长一段时间，我也是在前端编程，写这方面的东西。</p><p id="3b9e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">发展应用程序的最大问题之一是与UI框架的耦合。</p><p id="0956" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在前端，随着时间的推移，这种类型的应用程序的责任逐渐增加，以更结构化的方式开发越来越有意义，要解决的问题与后端或移动开发等其他前端存在的问题非常相似。</p><p id="c6a8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">像React和Vue.js这样的框架让我们在前端迎接这些挑战变得更加容易。</p><p id="83bb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">今天的前端应用程序在许多情况下是后端的独立应用程序，因此需要有自己的架构。</p><p id="d206" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">此外，这种架构必须在以下几点上帮助我们:</p><ul class=""><li id="f772" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated">独立于UI、框架、API rest和持久性、第三方服务的数据库。</li><li id="6835" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">逃避现实。</li><li id="91e7" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">可测试性。</li></ul><p id="9e78" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这意味着，如果我们改变拥有ReactJs或VueJs应用程序的愿景，拥有一个使用ReactJs或VueJs进行渲染的前端应用程序，这将使我们未来的生活更加轻松。</p><p id="f87e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">因此，例如，将您的ReactJS应用程序从以前使用的类发展到现在使用的函数和钩子，就简单多了。如果在VueJS中从使用options API切换到composition API，也会发生同样的情况。</p><p id="edd5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">它更琐碎，因为您只在绝对必要的情况下使用框架，比如渲染，因此您不会过度使用它，使它远离任何类型的逻辑，无论是它的域、数据还是表示逻辑。</p><blockquote class="na nb nc"><p id="42c6" class="ks kt nd ku b kv kw jo kx ky kz jr la ne lc ld le nf lg lh li ng lk ll lm ln ig bi translated">框架会发展，你不能控制它，但是你能控制的是你与它们的耦合以及它们的变化如何影响你。</p></blockquote><p id="d2cc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但在这种情况下，我们将超越如何适应框架中可能发生的变化，我们将看到当我们使用干净的体系结构和分离的职责来修改VueJS的ReactJS时，不会改变的代码量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/3ccc7abc5812b25d341710851b8ee6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPChCgSKp1XldkNCOUxk6Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Clean architecture</figcaption></figure><p id="120a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您使用<strong class="ku io"> Clean Architecture </strong>进行开发，这就是您要记住的画面。</p><p id="9969" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你还不清楚干净架构的概念，我推荐你阅读这篇<a class="ae lo" href="http://xurxodev.com/por-que-utilizo-clean-architecture-en-mis-proyectos/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="51b1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最重要的部分是依赖规则，所以如果你不知道我在说什么，我推荐你阅读这篇<a class="ae lo" href="http://xurxodev.com/por-que-utilizo-clean-architecture-en-mis-proyectos/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="e183" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将要看到的例子基于我们在这篇<a class="ae lo" href="http://xurxodev.com/el-patron-bloc-junto-a-clean-architecture-en-reactjs/" rel="noopener ugc nofollow" target="_blank">文章</a>中看到的例子。</p><h1 id="5509" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">我们的场景</h1><p id="33ae" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">这是一个功能齐全的购物车，看起来就像一个真实的例子。我们将有一个全局状态，非全局状态，我们将模拟对远程服务的调用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/94761ccf6ff3e26e4b8032cc6ac6fce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8E5StCvDtctSV3MQ0GtIg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Shopping Cart Example</figcaption></figure><h1 id="b0f1" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">体系结构</h1><p id="b247" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在项目结构层面，我们将使用monorepo，使用<a class="ae lo" href="https://classic.yarnpkg.com/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank"> yarn workspaces </a>，这样我们可以将项目分割成模块或包，在它们之间共享代码。</p><p id="159e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们有几个套餐:</p><ul class=""><li id="81f1" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated">核心:在这个包中，我们将拥有ReactJS呈现的应用程序和VueJs呈现的应用程序之间的所有共享代码。</li><li id="5463" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">React:在这个包中可以找到react应用程序版本。</li><li id="1e75" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">Vue:在这个包中可以找到Vue的应用程序版本。</li></ul><h1 id="fadc" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么代码被重用？</h1><p id="8c38" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">我们将重用我们必须从UI框架中分离出来的所有代码，因为作为同一应用程序的不同版本，这些代码是共享的，而不是重复编写。</p><p id="280b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是一个展示Clean Architecture潜力的练习，但是这种UI框架的解耦是必要的，即使当我们开发一个真正的应用程序时。</p><p id="4077" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用UI框架是绝对必要的，这允许我们更好地适应框架未来版本的变化。</p><p id="aed8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是因为包含应用程序逻辑的代码是最重要的部分，随着时间的推移变化很小，并且是潜在的在同一个应用程序的两个版本之间共享的代码，如本例所示，它是不依赖于UI框架的非耦合的。</p><p id="6994" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在干净的架构中，领域层是企业和应用程序业务逻辑所在的地方。</p><p id="4f66" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">数据层是我们与持久性进行通信的地方。</p><p id="b058" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">表示逻辑决定显示什么数据，是否应该显示什么，是否应该向用户显示我们正在加载数据，或者是否应该显示错误。它是管理组件状态的地方。</p><p id="970d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这3个部分中的每一个都包含我们必须解耦的逻辑，并且在核心包中找到。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/bae1e1a81065d685ceb08c7f7a1306e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*857ZuG0GUgZHyZyghwdKFg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Front-end Clean architecture packages</figcaption></figure><h1 id="e1ce" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">畴层</h1><p id="717c" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">领域层是企业和应用程序业务逻辑所在的地方。</p><h2 id="f423" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">用例</h2><p id="4a46" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">用例是意图，包含应用程序的业务逻辑，它们是操作，在本例中，我们有下一个:</p><ul class=""><li id="cb40" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated">GetProductsUseCase</li><li id="8053" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">GetCartUseCase</li><li id="5846" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">AddProductToCartUseCase</li><li id="329e" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">EditQuantityOfCartItemUseCase</li><li id="82e8" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">RemoveItemFromCartUseCase</li></ul><p id="985c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看GetProductsUseCase的例子:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="ebf6" class="nk lq in nx b gy ob oc l od oe">export class GetProductsUseCase {<br/>    private productRepository: ProductRepository;</span><span id="2b6a" class="nk lq in nx b gy of oc l od oe">constructor(productRepository: ProductRepository) {<br/>        this.productRepository = productRepository;<br/>    }</span><span id="0238" class="nk lq in nx b gy of oc l od oe">execute(filter: string): Promise&lt;Either&lt;DataError, Product[]&gt;&gt; {<br/>        return this.productRepository.get(filter);<br/>    }<br/>}</span></pre><p id="18b1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个用例很简单，因为它由一个对数据层的简单调用组成，在其他上下文中，例如，当创建一个产品时，我们必须验证不再有一个具有相同SKU的产品，将会有更多的逻辑。</p><p id="9e68" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">用例返回任一类型，如果你不确定它是什么，那么我推荐你阅读这篇<a class="ae lo" href="http://xurxodev.com/either-en-typescript/" rel="noopener ugc nofollow" target="_blank">文章</a>和这篇<a class="ae lo" href="http://xurxodev.com/either-asincrono-con-promesas-en-typescript/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="60c1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这样，错误处理不是使用承诺的catch来完成的，而是承诺本身的result对象告诉您结果是否成功。</p><p id="a4bc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">与传统的试捕法相比，这两种方法都有几个优点:</p><ul class=""><li id="3c7d" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated">发生错误时，执行流程更容易跟踪，而不会在调用方之间跳转。</li><li id="4b6b" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">明确指出可能会出错。</li><li id="e724" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">可能出现的错误被明确指出。</li><li id="2026" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">使用<a class="ae lo" href="http://xurxodev.com/either-en-typescript" rel="noopener ugc nofollow" target="_blank">穷举开关</a>，如果你将来添加了更多的错误，TypeScript会警告你在哪里没有考虑这个新的错误。</li></ul><p id="0704" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">错误的类型如下:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="a7cd" class="nk lq in nx b gy ob oc l od oe">export interface UnexpectedError {<br/>    kind: "UnexpectedError";<br/>    message: Error;<br/>}</span><span id="b97d" class="nk lq in nx b gy of oc l od oe">export type DataError = UnexpectedError;</span></pre><p id="f807" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在未来，它可能会发展成这样:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="ebe4" class="nk lq in nx b gy ob oc l od oe">export interface ApiError {<br/>    kind: "ApiError";<br/>    error: string;<br/>    statusCode: number;<br/>    message: string;<br/>}</span><span id="ab90" class="nk lq in nx b gy of oc l od oe">export interface UnexpectedError {<br/>    kind: "UnexpectedError";<br/>    message: Error;<br/>}</span><span id="38f2" class="nk lq in nx b gy of oc l od oe">export interface Unauthorized {<br/>    kind: "Unauthorized";<br/>}</span><span id="52c1" class="nk lq in nx b gy of oc l od oe">export interface NotFound {<br/>    kind: "NotFound";<br/>}</span><span id="ddfc" class="nk lq in nx b gy of oc l od oe">export type DataError = ApiError | UnexpectedError | Unauthorized;</span></pre><p id="d049" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在表示层，如果我使用穷举开关，Typescript会警告我，我应该为每个新错误添加更多的事例。</p><h2 id="2cd5" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">实体</h2><p id="8b76" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">实体包含企业业务逻辑。</p><p id="ed99" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看一下Cart的例子:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="d7d7" class="nk lq in nx b gy ob oc l od oe">type TotalPrice = number;<br/>type TotalItems = number;</span><span id="a417" class="nk lq in nx b gy of oc l od oe">export class Cart {<br/>    items: readonly CartItem[];<br/>    readonly totalPrice: TotalPrice;<br/>    readonly totalItems: TotalItems;</span><span id="56fc" class="nk lq in nx b gy of oc l od oe">constructor(items: CartItem[]) {<br/>        this.items = items;<br/>        this.totalPrice = this.calculateTotalPrice(items);<br/>        this.totalItems = this.calculateTotalItems(items);<br/>    }</span><span id="2a22" class="nk lq in nx b gy of oc l od oe">static createEmpty(): Cart {<br/>        return new Cart([]);<br/>    }</span><span id="71d1" class="nk lq in nx b gy of oc l od oe">addItem(item: CartItem): Cart {<br/>        const existedItem = this.items.find(i =&gt; i.id === item.id);</span><span id="78db" class="nk lq in nx b gy of oc l od oe">if (existedItem) {<br/>            const newItems = this.items.map(oldItem =&gt; {<br/>                if (oldItem.id === item.id) {<br/>                    return { ...oldItem, quantity: oldItem.quantity + item.quantity };<br/>                } else {<br/>                    return oldItem;<br/>                }<br/>            });</span><span id="103f" class="nk lq in nx b gy of oc l od oe">return new Cart(newItems);<br/>        } else {<br/>            const newItems = [...this.items, item];</span><span id="b830" class="nk lq in nx b gy of oc l od oe">return new Cart(newItems);<br/>        }<br/>    }</span><span id="059f" class="nk lq in nx b gy of oc l od oe">removeItem(itemId: string): Cart {<br/>        const newItems = this.items.filter(i =&gt; i.id !== itemId);</span><span id="2772" class="nk lq in nx b gy of oc l od oe">return new Cart(newItems);<br/>    }</span><span id="424c" class="nk lq in nx b gy of oc l od oe">editItem(itemId: string, quantity: number): Cart {<br/>        const newItems = this.items.map(oldItem =&gt; {<br/>            if (oldItem.id === itemId) {<br/>                return { ...oldItem, quantity: quantity };<br/>            } else {<br/>                return oldItem;<br/>            }<br/>        });</span><span id="38af" class="nk lq in nx b gy of oc l od oe">return new Cart(newItems);<br/>    }</span><span id="4595" class="nk lq in nx b gy of oc l od oe">private calculateTotalPrice(items: CartItem[]): TotalPrice {<br/>        return +items<br/>            .reduce((accumulator, item) =&gt; accumulator + item.quantity * item.price, 0)<br/>            .toFixed(2);<br/>    }</span><span id="9e91" class="nk lq in nx b gy of oc l od oe">private calculateTotalItems(items: CartItem[]): TotalItems {<br/>        return +items.reduce((accumulator, item) =&gt; accumulator + item.quantity, 0);<br/>    }<br/>}</span></pre><p id="f792" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个例子中，实体是简单的，具有基本类型的属性，但是在一个真实的例子中，我们可以将实体和V<a class="ae lo" href="http://xurxodev.com/como-crear-value-object-en-typescript/" rel="noopener ugc nofollow" target="_blank">value对象</a>定义为类，并使用工厂方法来执行验证。我们使用要么返回错误，要么返回结果。</p><h2 id="5384" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">边界</h2><p id="f1aa" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">边界是适配器的抽象，例如，在六边形架构中，它们被称为端口。它们在领域中的用例层中定义，并指示我们将如何与适配器通信</p><p id="d607" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">例如，为了与数据层通信，我们使用存储库模式。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="f476" class="nk lq in nx b gy ob oc l od oe">export interface ProductRepository {<br/>    get(filter: string): Promise&lt;Either&lt;DataError, Product[]&gt;&gt;;<br/>}</span></pre><h1 id="7723" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">数据层</h1><p id="eb12" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">数据层是找到适配器的地方，适配器负责在域和外部系统之间转换信息。</p><p id="4d87" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">外部系统可能是web服务、数据库等…</p><p id="ac32" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个简单的例子中，我在表示层、域层和数据层之间使用相同的实体来表示产品、购物车和购物车商品。</p><p id="6b0b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在实际应用中，通常每一层都有不同的数据结构，甚至有数据传输对象(dto)在层间传递数据。</p><p id="1ba4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个例子中，我们有返回存储在内存中的数据的存储库。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="a830" class="nk lq in nx b gy ob oc l od oe">const products = [<br/>  ...<br/>];</span><span id="c24e" class="nk lq in nx b gy of oc l od oe">export class ProductInMemoryRepository implements ProductRepository {<br/>    get(filter: string): Promise&lt;Either&lt;DataError, Product[]&gt;&gt; {<br/>        return new Promise((resolve, _reject) =&gt; {<br/>            setTimeout(() =&gt; {<br/>                try {<br/>                    if (filter) {<br/>                        const filteredProducts = products.filter((p: Product) =&gt; {<br/>                            return p.title.toLowerCase().includes(filter.toLowerCase());<br/>                        });</span><span id="6e26" class="nk lq in nx b gy of oc l od oe">resolve(Either.right(filteredProducts));<br/>                    } else {<br/>                        resolve(Either.right(products));<br/>                    }<br/>                } catch (error) {<br/>                    resolve(Either.left(error));<br/>                }<br/>            }, 100);<br/>        });<br/>    }<br/>}</span></pre><p id="4bfd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">重要的是要理解存储库是一个适配器，它的抽象或端口是在域中定义的，所以传统的依赖方向是颠倒的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6b70e7351ff3f699b20b4c3c84b03001.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*ZV9tRL1KrontbBgRtS8Cqg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Dependency inversion</figcaption></figure><p id="c784" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是干净架构中最重要的部分，<strong class="ku io">域不应该依赖于任何外部层</strong>，这样它就被解耦了，并且在将来用另一个适配器替换另一个适配器甚至是为了测试的目的，都变得更加容易。</p><p id="ee13" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这样，如果我们用调用web服务的适配器实现替换适配器实现，域不会受到影响，因此我们隐藏了实现细节。</p><h1 id="3388" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">表示层—适配器</h1><p id="c406" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">表示层的适配器是我们核心包的最后一个重用部分，它是我们挂接UI React或Vue层的地方。</p><p id="b9d9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这些适配器也可以在两个版本的应用程序之间重用，它们是UI组件和域层之间的中介。</p><p id="c380" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">它们包含表示逻辑，决定显示什么信息，什么应该可见，等等</p><p id="2865" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">状态管理由该层</strong>执行，不依赖于React或Vue。</p><p id="59f6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以使用不同的表示模式。在这种情况下，我使用BLoC模式，因为它非常适合React和Vue等声明性框架。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/1139eba9a2799020a81cae91aa4655d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leLTYWOjc2ArBFoYnH7OnQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">BLoC Pattern</figcaption></figure><p id="a1db" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你想深入研究集团模式，我推荐你阅读这篇<a class="ae lo" href="http://xurxodev.com/introduccion-al-patron-bloc/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="aa70" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如我在那篇文章中所讨论的，当您将BLoC与Clean Architecture一起使用时，称它们为PLoC、<strong class="ku io">表示逻辑组件</strong>更有意义。所以在这个例子中，它们是这样命名的。</p><p id="b2a4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看购物车示例:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="fbf3" class="nk lq in nx b gy ob oc l od oe">export class CartPloc extends Ploc&lt;CartState&gt; {<br/>    constructor(<br/>        private getCartUseCase: GetCartUseCase,<br/>        private addProductToCartUseCase: AddProductToCartUseCase,<br/>        private removeItemFromCartUseCase: RemoveItemFromCartUseCase,<br/>        private editQuantityOfCartItemUseCase: EditQuantityOfCartItemUseCase<br/>    ) {<br/>        super(cartInitialState);<br/>        this.loadCart();<br/>    }</span><span id="f48d" class="nk lq in nx b gy of oc l od oe">closeCart() {<br/>        this.changeState({ ...this.state, open: false });<br/>    }</span><span id="c68b" class="nk lq in nx b gy of oc l od oe">openCart() {<br/>        this.changeState({ ...this.state, open: true });<br/>    }</span><span id="e595" class="nk lq in nx b gy of oc l od oe">removeCartItem(item: CartItemState) {<br/>        this.removeItemFromCartUseCase<br/>            .execute(item.id)<br/>            .then(cart =&gt; this.changeState(this.mapToUpdatedState(cart)));<br/>    }</span><span id="b223" class="nk lq in nx b gy of oc l od oe">editQuantityCartItem(item: CartItemState, quantity: number) {<br/>        this.editQuantityOfCartItemUseCase<br/>            .execute(item.id, quantity)<br/>            .then(cart =&gt; this.changeState(this.mapToUpdatedState(cart)));<br/>    }</span><span id="d22d" class="nk lq in nx b gy of oc l od oe">addProductToCart(product: Product) {<br/>        this.addProductToCartUseCase<br/>            .execute(product)<br/>            .then(cart =&gt; this.changeState(this.mapToUpdatedState(cart)));<br/>    }</span><span id="86f7" class="nk lq in nx b gy of oc l od oe">private loadCart() {<br/>        this.getCartUseCase<br/>            .execute()<br/>            .then(cart =&gt; this.changeState(this.mapToUpdatedState(cart)))<br/>            .catch(() =&gt;<br/>                this.changeState({<br/>                    kind: "ErrorCartState",<br/>                    error: "An error has ocurred loading products",<br/>                    open: this.state.open,<br/>                })<br/>            );<br/>    }</span><span id="5a6c" class="nk lq in nx b gy of oc l od oe">mapToUpdatedState(cart: Cart): CartState {<br/>        const formatOptions = { style: "currency", currency: "EUR" };</span><span id="8a5d" class="nk lq in nx b gy of oc l od oe">return {<br/>            kind: "UpdatedCartState",<br/>            open: this.state.open,<br/>            totalItems: cart.totalItems,<br/>            totalPrice: cart.totalPrice.toLocaleString("es-ES", formatOptions),<br/>            items: cart.items.map(cartItem =&gt; {<br/>                return {<br/>                    id: cartItem.id,<br/>                    image: cartItem.image,<br/>                    title: cartItem.title,<br/>                    price: cartItem.price.toLocaleString("es-ES", formatOptions),<br/>                    quantity: cartItem.quantity,<br/>                };<br/>            }),<br/>        };<br/>    }<br/>}</span></pre><p id="5455" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所有PLoCs的基类负责存储状态，并在状态改变时发出通知。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="71cd" class="nk lq in nx b gy ob oc l od oe">type Subscription&lt;S&gt; = (state: S) =&gt; void;</span><span id="29bd" class="nk lq in nx b gy of oc l od oe">export abstract class Ploc&lt;S&gt; {<br/>    private internalState: S;<br/>    private listeners: Subscription&lt;S&gt;[] = [];</span><span id="2df5" class="nk lq in nx b gy of oc l od oe">constructor(initalState: S) {<br/>        this.internalState = initalState;<br/>    }</span><span id="00b3" class="nk lq in nx b gy of oc l od oe">public get state(): S {<br/>        return this.internalState;<br/>    }</span><span id="2369" class="nk lq in nx b gy of oc l od oe">changeState(state: S) {<br/>        this.internalState = state;</span><span id="61ed" class="nk lq in nx b gy of oc l od oe">if (this.listeners.length &gt; 0) {<br/>            this.listeners.forEach(listener =&gt; listener(this.state));<br/>        }<br/>    }</span><span id="58eb" class="nk lq in nx b gy of oc l od oe">subscribe(listener: Subscription&lt;S&gt;) {<br/>        this.listeners.push(listener);<br/>    }</span><span id="f26f" class="nk lq in nx b gy of oc l od oe">unsubscribe(listener: Subscription&lt;S&gt;) {<br/>        const index = this.listeners.indexOf(listener);<br/>        if (index &gt; -1) {<br/>            this.listeners.splice(index, 1);<br/>        }<br/>    }<br/>}</span></pre><p id="9fa0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">UI组件需要的所有信息都必须从状态、要在表或列表中呈现的元素中进行解释，还必须解释某些东西是否应该可见，比如购物车、装载或要显示的错误。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="e382" class="nk lq in nx b gy ob oc l od oe">export interface CommonCartState {<br/>    open: boolean;<br/>}</span><span id="16e4" class="nk lq in nx b gy of oc l od oe">export interface LoadingCartState {<br/>    kind: "LoadingCartState";<br/>}</span><span id="5138" class="nk lq in nx b gy of oc l od oe">export interface UpdatedCartState {<br/>    kind: "UpdatedCartState";<br/>    items: Array&lt;CartItemState&gt;;<br/>    totalPrice: string;<br/>    totalItems: number;<br/>}</span><span id="90c9" class="nk lq in nx b gy of oc l od oe">export interface ErrorCartState {<br/>    kind: "ErrorCartState";<br/>    error: string;<br/>}</span><span id="b7a4" class="nk lq in nx b gy of oc l od oe">export type CartState = (LoadingCartState | UpdatedCartState | ErrorCartState) &amp; CommonCartState;</span><span id="8395" class="nk lq in nx b gy of oc l od oe">export interface CartItemState {<br/>    id: string;<br/>    image: string;<br/>    title: string;<br/>    price: string;<br/>    quantity: number;<br/>}</span><span id="6a53" class="nk lq in nx b gy of oc l od oe">export const cartInitialState: CartState = {<br/>    kind: "LoadingCartState",<br/>    open: false,<br/>};</span></pre><p id="120d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这种情况下，通过typescript的union类型，我们可以使用<a class="ae lo" href="https://xurxodev.com/tipos-de-datos-algebraicos-sum-en-typescript/" rel="noopener ugc nofollow" target="_blank"> sum代数数据类型</a>更安全和功能性地建模我们的状态。</p><p id="78d7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种建模方式不容易出错，因为您指出了一种非常清晰的形式，即状态有3种主要可能性:</p><ul class=""><li id="a763" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated">加载信息</li><li id="87d6" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">出现了一个错误</li><li id="ec37" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">更新的数据</li></ul><h1 id="8fb1" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">表示层—用户界面</h1><p id="dcef" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在这一层中是组件以及与React或Vue相关的一切，如组件、挂钩、应用程序等。</p><p id="dd26" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这些组件非常简单和轻便，因为它们可以自由地管理任何类型的逻辑或状态管理，这是核心包中每一层的责任。</p><h2 id="9925" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">React应用</h2><p id="d80b" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在react中，我们将拥有呈现产品列表的组件、显示购物车中产品数量的应用程序栏，以及呈现为侧边栏的产品购物车。</p><p id="3234" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看呈现购物车内容的组件示例。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="d35f" class="nk lq in nx b gy ob oc l od oe">import React from "react";<br/>import { makeStyles, Theme } from "<a class="ae lo" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core/styles";<br/>import { List, Divider, Box, Typography, CircularProgress } from "<a class="ae lo" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core";<br/>import CartContentItem from "./CartContentItem";<br/>import { CartItemState } from "<a class="ae lo" href="http://twitter.com/frontend" rel="noopener ugc nofollow" target="_blank">@frontend</a>-clean-architecture/core";<br/>import { useCartPloc } from "../app/App";<br/>import { usePlocState } from "../common/usePlocState";</span><span id="93c6" class="nk lq in nx b gy of oc l od oe">const useStyles = makeStyles((theme: Theme) =&gt; ({<br/>    totalPriceContainer: {<br/>        display: "flex",<br/>        alignItems: "center",<br/>        padding: theme.spacing(1, 0),<br/>        justifyContent: "space-around",<br/>    },<br/>    itemsContainer: {<br/>        display: "flex",<br/>        alignItems: "center",<br/>        padding: theme.spacing(1, 0),<br/>        justifyContent: "space-around",<br/>        minHeight: 150,<br/>    },<br/>    itemsList: {<br/>        overflow: "scroll",<br/>    },<br/>    infoContainer: {<br/>        display: "flex",<br/>        alignItems: "center",<br/>        justifyContent: "center",<br/>        height: "100vh",<br/>    },<br/>}));</span><span id="8286" class="nk lq in nx b gy of oc l od oe">const CartContent: React.FC = () =&gt; {<br/>    const classes = useStyles();<br/>    const ploc = useCartPloc();<br/>    const state = usePlocState(ploc);</span><span id="d550" class="nk lq in nx b gy of oc l od oe">const cartItems = (items: CartItemState[]) =&gt; (<br/>        &lt;List className={classes.itemsList}&gt;<br/>            {items.map((item, index) =&gt; (<br/>                &lt;CartContentItem key={index} cartItem={item} /&gt;<br/>            ))}<br/>        &lt;/List&gt;<br/>    );</span><span id="50dc" class="nk lq in nx b gy of oc l od oe">const emptyCartItems = () =&gt; (<br/>        &lt;React.Fragment&gt;<br/>            &lt;Typography variant="h6" component="h2"&gt;<br/>                Empty Cart :(<br/>            &lt;/Typography&gt;<br/>        &lt;/React.Fragment&gt;<br/>    );</span><span id="62cb" class="nk lq in nx b gy of oc l od oe">switch (state.kind) {<br/>        case "LoadingCartState": {<br/>            return (<br/>                &lt;div className={classes.infoContainer}&gt;<br/>                    &lt;CircularProgress /&gt;<br/>                &lt;/div&gt;<br/>            );<br/>        }<br/>        case "ErrorCartState": {<br/>            return (<br/>                &lt;div className={classes.infoContainer}&gt;<br/>                    &lt;Typography display="inline" variant="h5" component="h2"&gt;<br/>                        {state.error}<br/>                    &lt;/Typography&gt;<br/>                &lt;/div&gt;<br/>            );<br/>        }<br/>        case "UpdatedCartState": {<br/>            return (<br/>                &lt;React.Fragment&gt;<br/>                    &lt;Box flexDirection="column" className={classes.itemsContainer}&gt;<br/>                        {state.items.length &gt; 0 ? cartItems(state.items) : emptyCartItems()}<br/>                    &lt;/Box&gt;<br/>                    &lt;Divider /&gt;<br/>                    &lt;Box flexDirection="row" className={classes.totalPriceContainer}&gt;<br/>                        &lt;Typography variant="h6" component="h2"&gt;<br/>                            Total Price<br/>                        &lt;/Typography&gt;<br/>                        &lt;Typography variant="h6" component="h2"&gt;<br/>                            {state.totalPrice}<br/>                        &lt;/Typography&gt;<br/>                    &lt;/Box&gt;<br/>                &lt;/React.Fragment&gt;<br/>            );<br/>        }<br/>    }<br/>};</span><span id="e7fd" class="nk lq in nx b gy of oc l od oe">export default CartContent;</span></pre><h2 id="c7ef" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">钩住</h2><p id="eccf" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">使用干净的架构，钩子不用？是的，他们被使用，但是为了严格必要的东西。</p><p id="0225" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">状态不会被钩子管理，副作用不会被钩子触发，这是核心包中PloCs的责任。</p><p id="b087" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是我们将使用它们来存储PloC返回给我们的组件的最终状态，并且我们将使用它们来共享组件之间的上下文，或者对PloC返回给我们的状态变化做出反应。</p><p id="4071" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们看看我们在组件中使用的usePLocState挂钩是如何定义的:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="4e9d" class="nk lq in nx b gy ob oc l od oe">export function usePlocState&lt;S&gt;(ploc: Ploc&lt;S&gt;) {<br/>    const [state, setState] = useState(ploc.state);</span><span id="1351" class="nk lq in nx b gy of oc l od oe">useEffect(() =&gt; {<br/>        const stateSubscription = (state: S) =&gt; {<br/>            setState(state);<br/>        };</span><span id="f4fd" class="nk lq in nx b gy of oc l od oe">ploc.subscribe(stateSubscription);</span><span id="a564" class="nk lq in nx b gy of oc l od oe">return () =&gt; ploc.unsubscribe(stateSubscription);<br/>    }, [ploc]);</span><span id="4e5a" class="nk lq in nx b gy of oc l od oe">return state;<br/>}</span></pre><p id="3b22" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个定制钩子负责订阅PloC状态变化并存储最终状态。</p><h2 id="d796" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">Vue应用程序</h2><p id="5c50" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在Vue中，我们也将拥有与React版本相同的组件。</p><p id="0eec" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在让我们看看在Vue版本中呈现购物车内容的组件:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="b5dc" class="nk lq in nx b gy ob oc l od oe">&lt;template&gt;<br/>    &lt;div id="info-container" v-if="state.kind === 'LoadingCartState'"&gt;<br/>        &lt;ProgressSpinner /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div id="info-container" v-if="state.kind === 'ErrorCartState'"&gt;Error&lt;/div&gt;<br/>    &lt;div id="items-container" v-if="state.kind === 'UpdatedCartState'"&gt;<br/>        &lt;div v-if="state.items.length &gt; 0" style="overflow: scroll"&gt;<br/>            &lt;div v-for="item in state.items" v-bind:key="item.id"&gt;<br/>                &lt;CartContenttItem v-bind="item" /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;h2 v-if="state.items.length === 0"&gt;Empty Cart :(&lt;/h2&gt;<br/>    &lt;/div&gt;<br/>    &lt;Divider /&gt;<br/>    &lt;div id="total-price-container"&gt;<br/>        &lt;h3&gt;Total Price&lt;/h3&gt;<br/>        &lt;h3&gt;{{ state.totalPrice }}&lt;/h3&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="62fb" class="nk lq in nx b gy of oc l od oe">&lt;script lang="ts"&gt;<br/>import { defineComponent, inject } from "vue";<br/>import { CartPloc } from "<a class="ae lo" href="http://twitter.com/frontend" rel="noopener ugc nofollow" target="_blank">@frontend</a>-clean-architecture/core";<br/>import { usePlocState } from "../common/usePlocState";<br/>import CartContenttItem from "./CartContenttItem.vue";</span><span id="b137" class="nk lq in nx b gy of oc l od oe">export default defineComponent({<br/>    components: {<br/>        CartContenttItem,<br/>    },<br/>    setup() {<br/>        const ploc = inject&lt;CartPloc&gt;("cartPloc") as CartPloc;<br/>        const state = usePlocState(ploc);</span><span id="c1f3" class="nk lq in nx b gy of oc l od oe">return { state };<br/>    },<br/>});<br/>&lt;/script&gt;</span><span id="603c" class="nk lq in nx b gy of oc l od oe">&lt;style scoped&gt;<br/>#info-container {<br/>    display: flex;<br/>    align-items: center;<br/>    justify-content: center;<br/>    height: 100vh;<br/>}<br/>#items-container {<br/>    display: flex;<br/>    flex-direction: column;<br/>    align-items: center;<br/>    min-height: 150px;<br/>    justify-content: space-around;<br/>}<br/>#total-price-container {<br/>    display: flex;<br/>    align-items: center;<br/>    padding: 8px 0px;<br/>    justify-content: space-around;<br/>}<br/>&lt;/style&gt;</span></pre><p id="2447" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如你所见，它看起来很像使用composition API的React版本。</p><h2 id="7287" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">组合API</h2><p id="6e20" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在Vue版本中，我们还将有挂钩，例如管理PLoC状态更改订阅的挂钩:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="3f57" class="nk lq in nx b gy ob oc l od oe">import { Ploc } from "<a class="ae lo" href="http://twitter.com/frontend" rel="noopener ugc nofollow" target="_blank">@frontend</a>-clean-architecture/core";</span><span id="8e57" class="nk lq in nx b gy of oc l od oe">import { DeepReadonly, onMounted, onUnmounted, readonly, Ref, ref } from "vue";</span><span id="c2b7" class="nk lq in nx b gy of oc l od oe">export function usePlocState&lt;S&gt;(ploc: Ploc&lt;S&gt;): DeepReadonly&lt;Ref&lt;S&gt;&gt; {<br/>    const state = ref(ploc.state) as Ref&lt;S&gt;;</span><span id="44a9" class="nk lq in nx b gy of oc l od oe">const stateSubscription = (newState: S) =&gt; {<br/>        state.value = newState;<br/>    };</span><span id="b79c" class="nk lq in nx b gy of oc l od oe">onMounted(() =&gt; {<br/>        ploc.subscribe(stateSubscription);<br/>    });</span><span id="809d" class="nk lq in nx b gy of oc l od oe">onUnmounted(() =&gt; {<br/>        ploc.unsubscribe(stateSubscription);<br/>    });</span><span id="dac8" class="nk lq in nx b gy of oc l od oe">return readonly(state);<br/>}</span></pre><h1 id="33e8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">依赖注入</h1><p id="0313" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">从React和Vue应用程序中，我们必须为每个组件创建或重用PloC结构:用例和存储库。</p><p id="32b6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果这些概念是在核心包中定义的，那么负责创建它们的部分也可能在核心包中。</p><p id="b50d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这次我静态地使用服务定位器模式:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="bb0d" class="nk lq in nx b gy ob oc l od oe">function provideProductsPloc(): ProductsPloc {<br/>    const productRepository = new ProductInMemoryRepository();<br/>    const getProductsUseCase = new GetProductsUseCase(productRepository);<br/>    const productsPloc = new ProductsPloc(getProductsUseCase);</span><span id="7524" class="nk lq in nx b gy of oc l od oe">return productsPloc;<br/>}</span><span id="d6bd" class="nk lq in nx b gy of oc l od oe">function provideCartPloc(): CartPloc {<br/>    const cartRepository = new CartInMemoryRepository();<br/>    const getCartUseCase = new GetCartUseCase(cartRepository);<br/>    const addProductToCartUseCase = new AddProductToCartUseCase(cartRepository);<br/>    const removeItemFromCartUseCase = new RemoveItemFromCartUseCase(cartRepository);<br/>    const editQuantityOfCartItemUseCase = new EditQuantityOfCartItemUseCase(cartRepository);<br/>    const cartPloc = new CartPloc(<br/>        getCartUseCase,<br/>        addProductToCartUseCase,<br/>        removeItemFromCartUseCase,<br/>        editQuantityOfCartItemUseCase<br/>    );</span><span id="bf67" class="nk lq in nx b gy of oc l od oe">return cartPloc;<br/>}</span><span id="ddac" class="nk lq in nx b gy of oc l od oe">export const dependenciesLocator = {<br/>    provideProductsPloc,<br/>    provideCartPloc,<br/>};</span></pre><p id="7ecc" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们也可以使用<a class="ae lo" href="http://xurxodev.com/inyeccion-de-dependencias-typescript-service-locator/" rel="noopener ugc nofollow" target="_blank">动态服务定位器和组合根</a>或依赖注入库。</p><p id="d81a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在React应用中，有一个全局状态必须共享，它就是购物车。因此，管理这个状态的CartPloc必须由所有组件共享和访问。</p><h2 id="0a1e" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">反应</h2><p id="6728" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在React中，我们使用createContext和useContext来解决这个问题。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="0415" class="nk lq in nx b gy ob oc l od oe">export function createContext&lt;T&gt;() {<br/>    const context = React.createContext&lt;T | undefined&gt;(undefined);</span><span id="f440" class="nk lq in nx b gy of oc l od oe">function useContext() {<br/>        const ctx = React.useContext(context);<br/>        if (!ctx) throw new Error("context must be inside a Provider with a value");<br/>        return ctx;<br/>    }<br/>    return [context, useContext] as const;<br/>}</span><span id="d883" class="nk lq in nx b gy of oc l od oe">const [blocContext, usePloc] = createContext&lt;CartPloc&gt;();</span><span id="c810" class="nk lq in nx b gy of oc l od oe">export const useCartPloc = usePloc;</span><span id="1015" class="nk lq in nx b gy of oc l od oe">const App: React.FC = () =&gt; {<br/>    return (<br/>        &lt;blocContext.Provider value={dependenciesLocator.provideCartPloc()}&gt;<br/>            &lt;MyAppBar /&gt;<br/>            &lt;ProductList /&gt;<br/>            &lt;CartDrawer /&gt;<br/>        &lt;/blocContext.Provider&gt;<br/>    );<br/>};</span><span id="91d8" class="nk lq in nx b gy of oc l od oe">export default App;</span></pre><p id="368c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用自定义的useCartPloc，我们可以从任何组件访问这个Ploc及其状态。</p><h2 id="9f1e" class="nk lq in bd lr nl nm dn lv nn no dp lz lb np nq mb lf nr ns md lj nt nu mf nv bi translated">Vue应用程序</h2><p id="1775" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在Vue中，我们通过使用provide特性来解决这个问题。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="f2cd" class="nk lq in nx b gy ob oc l od oe">&lt;template&gt;<br/>    &lt;div id="app"&gt;<br/>        &lt;MyAppBar /&gt;<br/>        &lt;ProductList searchTerm="Element" /&gt;<br/>        &lt;CartSidebar /&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="a653" class="nk lq in nx b gy of oc l od oe">&lt;script lang="ts"&gt;<br/>import { dependenciesLocator } from "<a class="ae lo" href="http://twitter.com/frontend" rel="noopener ugc nofollow" target="_blank">@frontend</a>-clean-architecture/core";<br/>import { defineComponent } from "vue";<br/>import MyAppBar from "./appbar/MyAppBar.vue";<br/>import ProductList from "./products/ProductList.vue";<br/>import CartSidebar from "./cart/CartSidebar.vue";</span><span id="8c07" class="nk lq in nx b gy of oc l od oe">export default defineComponent({<br/>    name: "App",<br/>    components: {<br/>        ProductList,<br/>        MyAppBar,<br/>        CartSidebar,<br/>    },<br/>    provide: {<br/>        cartPloc: dependenciesLocator.provideCartPloc(),<br/>    },<br/>});<br/>&lt;/script&gt;</span></pre><p id="409d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">稍后，我们可以从任何组件访问PLoC及其状态，方法是:</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="7eff" class="nk lq in nx b gy ob oc l od oe">const cartPloc = inject &lt;CartPloc&gt; (“cartPloc”) as CartPloc;</span></pre><h1 id="ff07" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">源代码</h1><p id="1631" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">源代码可以在这里找到:<a class="ae lo" href="https://github.com/xurxodev/frontend-clean-architecture" rel="noopener ugc nofollow" target="_blank">前端-清理-架构</a>。</p><p id="9cda" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">相关文章和资源</p><ul class=""><li id="2a44" class="mm mn in ku b kv kw ky kz lb mo lf mp lj mq ln mr ms mt mu bi translated"><a class="ae lo" href="https://www.amazon.es/gp/product/0134494164?tag=xurxodev0e-21" rel="noopener ugc nofollow" target="_blank">干净的架构:软件结构和设计的工匠指南</a></li><li id="ee43" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/curso-clean-architecture" rel="noopener ugc nofollow" target="_blank">清洁建筑课程</a>。</li><li id="a6d8" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">为什么要在我的项目中使用I Clean架构？</li><li id="df32" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/el-patron-bloc-en-clean-architecture/" rel="noopener ugc nofollow" target="_blank">清洁建筑中的集团模式</a></li><li id="0631" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/el-patron-bloc-junto-a-clean-architecture-en-reactjs/" rel="noopener ugc nofollow" target="_blank">反应堆清洁建筑中的阻塞模式</a></li><li id="a358" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated">T <a class="ae lo" href="http://xurxodev.com/el-patron-bloc-junto-a-clean-architecture-en-flutter/" rel="noopener ugc nofollow" target="_blank">清洁建筑中的阻挡图案在颤动</a></li><li id="752e" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/clean-architecture-code-smells-parte-1/" rel="noopener ugc nofollow" target="_blank">干净的架构:代码气味。第一部分</a></li><li id="081f" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/clean-architecture-code-smells-parte-2/" rel="noopener ugc nofollow" target="_blank">干净的架构:代码气味。第二部分</a></li><li id="d8c2" class="mm mn in ku b kv mv ky mw lb mx lf my lj mz ln mr ms mt mu bi translated"><a class="ae lo" href="http://xurxodev.com/mi-surrealista-compra-del-libro-clean-architecture/" rel="noopener ugc nofollow" target="_blank">我超现实地购买了《清洁建筑》这本书</a></li></ul><h1 id="1bb7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="226e" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在本文中，我们看到了一个干净的前端架构实现。</p><p id="c9ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们有一个版本的React和Vue应用程序，在两者之间尽可能多地重用代码，并将其放在一个核心包中。</p><p id="0bde" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">通过拥有一个所有逻辑都从框架中分离出来的核心包，我们可以体会到Clean Architecture可以在前端为我们提供的强大功能。</p><p id="c57d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个例子中，将项目组织成一个monorepo并拥有一个核心包是必要的，但是在开发一个应用程序React或Vue时，这是不必要的。</p><p id="7d93" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，强迫您脱离UI框架是一个有趣的练习，因为有时很难看出您正在耦合，尤其是在开始的时候。</p><p id="a284" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="nd">多内容于</em> <a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="nd">浅显易懂</em> </strong> </a></p></div></div>    
</body>
</html>