<html>
<head>
<title>The Most Efficient Ways to Clone objects in JavaScript in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年在JavaScript中克隆对象的最有效方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-most-efficient-ways-to-clone-objects-in-javascript-2021-c8e4d04096a5?source=collection_archive---------5-----------------------#2021-03-09">https://javascript.plainenglish.io/the-most-efficient-ways-to-clone-objects-in-javascript-2021-c8e4d04096a5?source=collection_archive---------5-----------------------#2021-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/231bdd56cf43671ffb089ae0bb8ee039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbrL7yHNpCz409NjNovcbQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielkcheung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Daniel Cheung</a> on <a class="ae kc" href="https://unsplash.com/s/photos/star-war?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0f68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克隆对象是JavaScript领域中最常用的操作之一。在本文中，我们将深入探讨JavaScript (Node.js和Browser环境)中存在的不同类型的克隆。我们还将讨论在JavaScript中浅层和深层克隆对象的最有效方法。</p><blockquote class="lb lc ld"><p id="e63d" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">📝已经有很多关于这个主题的博客文章、文章和堆栈溢出线程。本文是我试图把互联网的集体知识整合成一个易于理解和参考的总结。</p></blockquote><p id="06fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们潜水吧🏄‍♀️</p><h1 id="6c91" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">本土深度克隆</strong></h1><p id="fadc" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">本机深度克隆在Node.js中被称为“结构化克隆”。该功能在浏览器中不可用。结构化克隆除了JSON支持的数据类型之外，还支持另外一组数据类型。下面是它支持的其他<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types" rel="noopener ugc nofollow" target="_blank">数据类型</a>列表。以下是本机深度克隆的示例:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">structured clone</figcaption></figure><h1 id="fcf6" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">JSON.parse/stringify—数据丢失的克隆</h1><p id="790b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当您不关心数据丢失时，Good ol' <code class="fe mr ms mt mu b">JOSN.stringify()</code>是最常用的克隆对象的方法，或者对于您的用例，浅层克隆就足够了。这里有一个简单的例子</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">shallow copy</figcaption></figure><p id="cc18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当要复制的对象具有复杂的嵌套数据或函数时，应用JSON.strigify()会导致数据丢失。下面是一个在JSON.strigify()上发生数据丢失的示例。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在样本上面的<strong class="kf ir"> <em class="le">攻击</em> </strong>功能将不会被复制。</p><h1 id="68f8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">扩展操作-浅层克隆</h1><p id="9041" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">扩展操作是在ES6中克隆对象的最简单方法。这种方法也会发生数据丢失。然而，因为这是ES6的固有特性，所以它比JSON.strigify()更有性能。</p><blockquote class="lb lc ld"><p id="ebbc" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">在这里检查基准<a class="ae kc" href="http://jsben.ch/#/bWfk9" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="e261" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个使用spread运算符进行克隆的示例</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="fe50" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对象. assign()</h1><p id="84a8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Object.assign()是一种ES6方法，它允许浅层克隆simmilar扩展操作。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="4e1c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用lodash库进行深度克隆</h1><p id="0b64" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果您正在寻找一种可靠的深度克隆方法，并且不介意使用第三方库，那么lodash可能正是您正在寻找的解决方案。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="d4cb" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">具有自定义功能的深度克隆</h1><p id="9a6e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">最后，我们可以推出自己的深度复制对象的功能。我从堆栈溢出中找到了下面的代码片段，并一直在我的项目中使用它。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您关心各种克隆功能的性能，我强烈建议您看看<a class="ae kc" href="https://jsben.ch/KVQLd" rel="noopener ugc nofollow" target="_blank">下面的线程</a>。我希望这篇文章有用。今天就到这里🙂，直到下次</p><h1 id="232d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">参考文献</strong></h1><p id="640a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Web _ Workers _ API/Structured _ clone _ algorithm # supported _ types</a></p><p id="8094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/122102/最有效的深度克隆对象的方法是什么/5344074#5344074 </a></p><p id="e46c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【https://www.npmjs.com/package/lodash.clonedeep T4】</p></div></div>    
</body>
</html>