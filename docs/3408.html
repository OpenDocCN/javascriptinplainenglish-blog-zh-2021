<html>
<head>
<title>How to Re-authorize Users on Apollo Client and Mongo Atlas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Apollo客户端和Mongo Atlas上重新授权用户</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-re-authorize-your-user-with-refresh-token-on-apollo-client-and-mongo-atlas-dcdf0356d228?source=collection_archive---------8-----------------------#2021-07-10">https://javascript.plainenglish.io/how-to-re-authorize-your-user-with-refresh-token-on-apollo-client-and-mongo-atlas-dcdf0356d228?source=collection_archive---------8-----------------------#2021-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90447502174789d283a6c1fde485dd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMykOEvicu2JeYteP6afbw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae kc" href="https://unsplash.com/s/photos/network-handshake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a975" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网上最常见的认证方法是JWT。我们使用用户名和通行证登录，并得到一个<strong class="kf ir">访问令牌</strong>和一个<strong class="kf ir">刷新令牌</strong>作为响应。我们将它们存储在本地，然后对服务器的任何请求使用访问令牌进行身份验证，而不是用户的密码。最终，访问令牌将到期。刷新令牌允许我们获得新访问令牌，而不必再次提供我们的用户名和密码。</p><p id="cc42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为开发者<em class="lb">我们不知道这种过期何时会发生</em>，因为这有很多原因，一般来说，我们的客户端应用不知道服务器端的技术是一个很好的实践。因此，在我们的任何请求中，我们都需要能够处理访问令牌过期的情况。</p><h1 id="36ab" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">请求的重新认证流程</h1><p id="0aee" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">首先，请求被拒绝，并显示错误消息。然后，我们使用刷新令牌获取新的访问令牌，最后使用新的访问令牌重试请求。Apollo将为我们处理对服务器的实际请求。然而，为了实现重新认证流程，<strong class="kf ir">我们需要扩展请求处理过程</strong>。</p><h1 id="d156" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用Apollo Client 2.0“链接”扩展网络接口</h1><p id="6282" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">扩展Apollo客户端网络接口的方法是通过他们所谓的链接。<a class="ae kc" href="https://www.apollographql.com/docs/react/api/link/introduction/" rel="noopener ugc nofollow" target="_blank">阿波罗链接概述(官方文档)</a>。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/a063b787c20b35babd81fd5ba4071a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ox6Gpedfv9Ir6LbWIzNMlw.png"/></div></div></figure><p id="c8be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接允许我们做的是创建一组函数，<strong class="kf ir">可以在它们执行</strong>之前交互和操纵我们的请求。</p><p id="866e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个Apollo客户端可以由许多链接组成。然而，这组链接必须总是以一个<a class="ae kc" href="https://www.apollographql.com/docs/link/overview.html#terminating" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">终止链接</strong> </a>结束。与前面的链接不同，终止链接必须根据参数执行一些操作，并返回操作的结果。通常，这个操作是一个网络请求。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d1eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apollo提供的默认终止链接是<code class="fe mm mn mo mp b">apollo-http-link</code>。这个终接链路使用<code class="fe mm mn mo mp b">fetch</code>执行网络请求并发回结果。您可以使用<code class="fe mm mn mo mp b">apollo-http-link</code>包中提供的<code class="fe mm mn mo mp b">createHttpLink()</code>功能创建链接。在上面的例子中，我们为graphql服务器传递了URI，这样它就知道将请求发送到哪里，以及身份验证所需的头。</p><h1 id="1efb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">实施重新授权流程</h1><p id="1f9c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了实现上面列出的重新授权流程，我们可以覆盖由终止链接执行的<code class="fe mm mn mo mp b">fetch</code>。我们创建了一个<code class="fe mm mn mo mp b">customFetch</code>函数，它可以执行请求，如果失败，就用一个新令牌重试，并将其作为一个选项传递给<code class="fe mm mn mo mp b">apollo-http-link</code>。</p><pre class="mg mh mi mj gt mq mp mr ms aw mt bi"><span id="5e27" class="mu ld iq mp b gy mv mw l mx my">...</span><span id="1e22" class="mu ld iq mp b gy mz mw l mx my">const httpLink = createHttpLink({<br/>    uri: "/graphql",<br/>    <strong class="mp ir">fetch: customFetch,<br/></strong>    headers: {...}</span><span id="5bd4" class="mu ld iq mp b gy mz mw l mx my">})</span><span id="1e72" class="mu ld iq mp b gy mz mw l mx my">...</span></pre><p id="1bc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个将被添加到Apollo客户端的<code class="fe mm mn mo mp b">customFetch</code>函数的实现:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fde0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当一个请求被执行时，我们在返回结果之前检查一个未授权的错误。如果用户有一个过期的访问令牌，链接将使用刷新令牌获得一个新的令牌，并重试请求。</p><p id="d281" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果没有错误</strong>我们返回链中的初始响应并继续前进。注意我们如何在链中传递<strong class="kf ir">初始响应(</strong> <code class="fe mm mn mo mp b">using .clone()</code> <strong class="kf ir">)和</strong> <code class="fe mm mn mo mp b">response.json()</code> <strong class="kf ir">。</strong></p><pre class="mg mh mi mj gt mq mp mr ms aw mt bi"><span id="8b13" class="mu ld iq mp b gy mv mw l mx my">return ({<br/>    initialResponse: response.clone(),<br/>    json: response.json()<br/>});</span></pre><p id="a7cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述技巧的原因是response.json()的函数调用正在消耗响应，之后我们需要重新打包承诺并将其作为最终结果返回。因此，为了避免重新打包(这可能会导致一些意想不到的结果),我们可以简单地克隆最初的请求，并在需要时准备好。记住<strong class="kf ir"> fetch </strong>期待一个返回<strong class="kf ir"> Promise &lt; Response &gt;的函数。</strong></p><p id="4665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。希望这个实现能让你有一个流畅的用户体验，而不会让用户意外注销。</p><p id="b29e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更多内容请看</em><a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>