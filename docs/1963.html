<html>
<head>
<title>Solving N-Queens (… Sort of)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解N皇后(…算是吧)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-n-queens-sort-of-1eab8ffcec07?source=collection_archive---------9-----------------------#2021-04-24">https://javascript.plainenglish.io/solving-n-queens-sort-of-1eab8ffcec07?source=collection_archive---------9-----------------------#2021-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d222" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当给定一个<code class="fe ki kj kk kl b">n by n</code>矩阵时，n皇后问题的目标是将<code class="fe ki kj kk kl b">n</code>个皇后放置在棋盘上，使得它们都不会互相攻击(根据皇后移动的国际象棋规则)。规则是一个皇后可以在8个方向之一移动任意数量的细胞，只要它不跳另一个棋子。很简单——对吗？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/e329e148369059f7d9bbdacb673c0db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*XqU3T9Y9fvxmw14SmT7o1A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">an n-queens solution</figcaption></figure><p id="4a46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定我解决<a class="ae ky" href="https://akaphenom.medium.com/solving-8-puzzle-with-search-e17c71000780" rel="noopener"> 8-puzzle </a>的解决方案，我最初倾向于将整个搜索空间构建成一个移动的图形，为每个潜在的移动附加边。8-puzzle有9个pick 9排列:大约360，000个棋盘状态。n皇后的不同之处在于，重要的是组合，而不是排列。理论上，搜索空间更小；例如，一个3x3的棋盘(9选3通过组合)将有84种状态。但是一个典型的n皇后棋盘是8×8棋盘，它将有(64个选择8个通过组合)4，426，165，368个棋盘状态(谢谢<a class="ae ky" href="https://stattrek.com/online-calculator/combinations-permutations.aspx" rel="noopener ugc nofollow" target="_blank"> stat-trek </a>)。这还不算边数…</p><p id="4308" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有提前生成所有可能的状态，而是选择在解开始评估移动时生成边界。我还选择将<strong class="jm io">棋盘表示为矩阵</strong>，用<code class="fe ki kj kk kl b">0</code>表示没有皇后的空间，用<code class="fe ki kj kk kl b">1</code>表示有皇后的空间(回想起来<strong class="jm io">可能不是正确的选择</strong>)。我还决定能够以两种可能的方式建立董事会——1 .在棋盘上任意未被占据的格子中随机放置皇后，或者2。每列放置一个皇后(这是该问题的常见限定符。电路板构造相对容易:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="31a5" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">placeQueens </em>= (n, onePerCol=<strong class="kl io">true</strong>) =&gt; {<br/>    // pick a random number<br/>    <strong class="kl io">const </strong><em class="lj">randomN </em>= n =&gt; <strong class="kl io"><em class="lj">Math</em></strong>.round(<strong class="kl io"><em class="lj">Math</em></strong>.random() * (n))<br/>    // define an empty row as anarray of N 0's<br/>    <strong class="kl io">const </strong>emptyRow = <strong class="kl io"><em class="lj">Array</em></strong>(n).fill(0)<br/>    // a function that picks a random number, proxy for a column<br/>    <strong class="kl io">const </strong><em class="lj">randomCol </em>= () =&gt; <em class="lj">randomN</em>(n - 1)</span><span id="30e7" class="ld le in kl b gy lk lg l lh li">    // build an array of which columns queens should be in<br/>    <strong class="kl io">const </strong>queenCols = (onePerCol) ?<br/>        // if 1 per col, create an array of 1..n and shuffle<br/>        <em class="lj">shuffle</em>(<em class="lj">range</em>(0, n-1)) :<br/>        // otherwise, create an array of N and randomly pick cols      <br/>        <strong class="kl io"><em class="lj">Array</em></strong>(n).fill(<strong class="kl io">null</strong>).map((_) =&gt; <em class="lj">randomCol</em>())</span><span id="fb1d" class="ld le in kl b gy lk lg l lh li">    // given a column place it on a row<br/>    <strong class="kl io">const </strong><em class="lj">placeQueen </em>= i =&gt; {<br/>        <strong class="kl io">const </strong>row = emptyRow.slice()<br/>        row[i] = 1<br/>        <strong class="kl io">return </strong>row<br/>    }</span><span id="6f23" class="ld le in kl b gy lk lg l lh li">   // to build the board start with an array of N (rows),<br/>   //      and for each row generate an array of N (cols)<br/>   <strong class="kl io">const </strong>board = (<strong class="kl io"><em class="lj">Array</em></strong>(n)).fill(<strong class="kl io">null</strong>).map((_) =&gt; {<br/>        <strong class="kl io">const </strong>at = queenCols.pop()<br/>        <strong class="kl io">const </strong>row = <em class="lj">placeQueen</em>(at)<br/>        <strong class="kl io">return </strong>row<br/>    })<br/>    <strong class="kl io">return </strong>board<br/>}</span></pre><p id="94ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在写这篇文章时，这里有许多改进，但是把皇后放在棋盘上并不是真正的练习:)。</p><p id="b5b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该解决方案要求在给定当前状态的情况下，生成下一个可能状态的所有组合。该代码包含一个启发法<code class="fe ki kj kk kl b">h</code>，我将很快介绍它，但现在让我们忽略它:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="af10" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">getAlternateBoardsWithHeuristic </em>= board =&gt;<br/>    board<br/>        <em class="lj">// each row has alternatives <br/>        //     (moving queen to any other spot)<br/>        </em>.map(<br/>          (row, rowIdx) =&gt; [rowIdx, <em class="lj">alternativeRows</em>(board[rowIdx])])<br/>        <em class="lj">// for each of these 8*7=56 alternative rows, <br/>        //     generate a new board with board in its existing<br/>        //     state but swapping out those alternative<br/>        </em>.map(([rowIdx, alternativeRows]) =&gt; <br/>          alternativeRows.map(<em class="lj">boardWithRow</em>(board, rowIdx)))<br/>        <em class="lj">// flatten so we get an array of the 56 possible boards<br/>        </em>.flat()<br/>        .map(board =&gt; {<br/>            <strong class="kl io">const </strong>h = <em class="lj">getAttacks</em>(board)<br/>            // return a board and its heuristic <br/>            <strong class="kl io">return </strong>{h, board}<br/>        })</span></pre><p id="a2ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过移动蚁后来构建交替行:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="1a21" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">alternativeRows </em>= row =&gt; {<br/>    <em class="lj">// find where the queen is at<br/>    </em><strong class="kl io">const </strong>queenAt = row.findIndex(c =&gt; c == 1)<br/>    <br/>    <em class="lj">// move queen to a new col<br/>    </em><strong class="kl io">const </strong><em class="lj">moveQueen </em>= to =&gt; {<br/>        <strong class="kl io">const </strong>copy = row.slice()<br/>        copy[to] = 1<br/>        copy[queenAt] = 0<br/>        <strong class="kl io">return </strong>copy<br/>    }<br/><br/>    <em class="lj">// generate all alternative rows<br/>    </em><strong class="kl io">const </strong>alternatives = row<br/>        .map((col, colIdx) =&gt; {<br/>            <strong class="kl io">if </strong>(colIdx != queenAt) {<br/>                <strong class="kl io">return </strong><em class="lj">moveQueen</em>(colIdx)<br/>            }<br/>            <strong class="kl io">return null<br/>        </strong>})<br/>        .filter(<em class="lj">isNotNull</em>)<br/><br/>    <strong class="kl io">return </strong>alternatives<br/>}</span></pre><p id="9830" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">启发式算法是棋盘状态的一个函数，它允许我们选择最佳的后续棋盘状态。为此，我们可以选择“处于危险中”的蚁后数量:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="0cfc" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">getAttacks </em>= (board) =&gt; {<br/>    <strong class="kl io">const </strong><em class="lj">incrementer </em>= (a, b) =&gt; a + 1<br/>    <em class="lj">// get row/col coordinates<br/>    </em><strong class="kl io">const </strong>coordinates = <em class="lj">getQueenCoordinates</em>(board)<br/><br/>    <em class="lj">// build all combinations of coordinate pairs<br/>    </em><strong class="kl io">const </strong>combos = <em class="lj">makeCombinations</em>(2, coordinates)<br/>    <em class="lj">// convert each pair into a slope<br/>    </em><strong class="kl io">const </strong>slopes = combos.map(<em class="lj">slope</em>)<br/><br/>    <strong class="kl io">const </strong><em class="lj">is </em>= x =&gt; o =&gt; x == o<br/>    <strong class="kl io">const </strong><em class="lj">isEither </em>= (x1, x2) =&gt; o =&gt; x1 == o || x2 == o</span><span id="00e6" class="ld le in kl b gy lk lg l lh li"><strong class="kl io">    const</strong> isPosOrNegInfinity = <em class="lj">isEither</em>(<br/>           <strong class="kl io"><em class="lj">Number</em></strong>.POSITIVE_INFINITY, <strong class="kl io"><em class="lj">Number</em></strong>.NEGATIVE_INFINITY)<br/><br/>    <em class="lj">// diagonal attacks happen when pairs have a slope of 1 | -1<br/>    </em><strong class="kl io">const </strong>cntDiag = slopes<br/>        .map(<strong class="kl io"><em class="lj">Math</em></strong>.abs)<br/>        .filter(<em class="lj">is</em>(1))<br/>        .reduce(<em class="lj">incrementer</em>, 0)</span><span id="7d3c" class="ld le in kl b gy lk lg l lh li">    <em class="lj">// vertical attacks happen when pairs have infinite slope<br/>    </em><strong class="kl io">const </strong>cntVert = slopes<br/>        .filter(isPosOrNegInfinity)<br/>        .reduce(<em class="lj">incrementer</em>, 0)<br/><br/>    <em class="lj">// horizontal attacks happen with 0 slope<br/>    </em><strong class="kl io">const </strong>cntHor = slopes<br/>        .filter(<em class="lj">is</em>(0))<br/>        .reduce(<em class="lj">incrementer</em>, 0)<br/><br/>    <strong class="kl io">return </strong>cntDiag + cntHor + cntVert<br/>}</span></pre><p id="068f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的目标是遍历棋盘排列，选择下一步棋，减少可能的危险皇后，因此对于棋盘，我们需要生成备选方案，并筛选出最佳可能性:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="7bce" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">bestFromAlternatives </em>= boards =&gt; {</span><span id="1e5e" class="ld le in kl b gy lk lg l lh li">    // sort based on Heuristic<br/>    <strong class="kl io">const </strong>sorted = boards<br/>        .slice()<br/>        .sort((a, b) =&gt; a.<strong class="kl io">h </strong>- b.<strong class="kl io">h</strong>)</span><span id="2dcf" class="ld le in kl b gy lk lg l lh li">    // find best score<br/>    <strong class="kl io">const </strong>bestScore = sorted[0].<strong class="kl io">h</strong></span><span id="7b16" class="ld le in kl b gy lk lg l lh li"><strong class="kl io">    // </strong>all of the best are possibilities <br/>    <strong class="kl io">return </strong>sorted<br/>        .filter(({h, _}) =&gt; h == bestScore)<br/>        .map(({_, board}) =&gt; <em class="lj">K</em>({<strong class="kl io">nextState</strong>: board}))<br/><br/>}<br/><br/><strong class="kl io">const </strong><em class="lj">getBestAlternatives </em>= board =&gt; {<br/>    <strong class="kl io">const </strong>alts = <em class="lj">getAlternateBoardsWithHeuristic</em>(board)<br/>    <strong class="kl io">const </strong>bestAlts = <em class="lj">bestFromAlternatives</em>(alts)<br/>    <strong class="kl io">return </strong>bestAlts<br/>}</span></pre><p id="ce9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">搜索技术被称为“爬山”(在这种情况下是下降)，只是沿着一条路径来降低启发式。在无法再降低的情况下，但存在相等的价值，它将试图横向移动，希望这些板可能会导致解决方案:</p><pre class="kn ko kp kq gt kz kl la lb aw lc bi"><span id="9f00" class="ld le in kl b gy lf lg l lh li"><strong class="kl io">const </strong><em class="lj">hillClimbingSeach </em>= (direction, problem, limit = 10) =&gt; {<br/>    <strong class="kl io">let </strong>candidate = problem.getInitialSearchNode()<br/>    candidate.<strong class="kl io">h </strong>= problem.<strong class="kl io">heuristic</strong>(candidate.state)<br/><br/>    <strong class="kl io">let </strong>bestCandidate = candidate</span><span id="38b1" class="ld le in kl b gy lk lg l lh li">    // keep track of sideways moves at a level, don't want to <br/>    //  travel sideways forever<br/>    <strong class="kl io">let </strong>tries = 0</span><span id="50de" class="ld le in kl b gy lk lg l lh li">    <strong class="kl io">while </strong>(candidate &amp;&amp; candidate.<strong class="kl io">h </strong>&lt;= bestCandidate.<strong class="kl io">h </strong>&amp;&amp; <br/>      tries &lt; limit) {<br/><br/>        <strong class="kl io">if </strong>(candidate.<strong class="kl io">meetsGoal</strong>()) {<br/>            <strong class="kl io">return </strong><em class="lj">Solution</em>(candidate)<br/>        }<br/><br/>        <em class="lj">// track and limit sideways moves, if they<br/>        // are not equal and there has been sideways moves -&gt; reset<br/>        </em><strong class="kl io">if </strong>(candidate.<strong class="kl io">h </strong>== bestCandidate.<strong class="kl io">h</strong>) {<br/>            tries = tries + 1<br/>            <strong class="kl io"><em class="lj">console</em></strong>.log(<strong class="kl io">"sideways"</strong>)<br/>        } <strong class="kl io">else if </strong>(tries &gt; 0) {<br/>            tries = 0<br/>            <strong class="kl io"><em class="lj">console</em></strong>.log(<strong class="kl io">"new path"</strong>)<br/>        } <strong class="kl io">else </strong>{<br/>            <strong class="kl io"><em class="lj">console</em></strong>.log(<strong class="kl io">"on path"</strong>)<br/>        }<br/><br/>        <em class="lj">// update candidates (best, current), and take next<br/>        //  action (if there is more than 1, pick one at random)<br/>        </em>bestCandidate = candidate<br/>        <strong class="kl io">const </strong>actions = candidate.<strong class="kl io">getActions</strong>();<br/><br/>        <strong class="kl io">const </strong>action = actions[<em class="lj">randomN</em>(actions.<strong class="kl io">length </strong>- 1)]<br/>        candidate = candidate.takeAction(action)<br/><br/>    }<br/><br/>    <strong class="kl io">if </strong>(tries == limit) {<br/>        <strong class="kl io">return </strong><em class="lj">SearchLimitExhausted</em>(limit, candidate)<br/>    } <strong class="kl io">else </strong>{<br/>        <strong class="kl io">return </strong><em class="lj">ClosestSolution</em>(candidate)<br/>    }<br/><br/>}</span></pre><p id="4048" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，有一个问题…它可能找不到解决方案。它确实有效地找到了局部解:)。</p><p id="e588" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你正在解决的问题离得足够近就足够了(比如在呼叫中心转接电话)，爬山可能是你的最佳选择。但是如果你试图找出一系列的移动来得到n皇后的解，这并不能保证。抱歉。</p><p id="a5e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的解决方案是什么？</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><div class="kn ko kp kq gt ls"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">Todd Brown-Liberty Mutual创新和敏捷工程副总裁兼高级总监…</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">www.linkedin.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg ks ls"/></div></div></a></div><p id="e2ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lj">更多内容尽在</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lj">plain English . io</em></a></p></div></div>    
</body>
</html>