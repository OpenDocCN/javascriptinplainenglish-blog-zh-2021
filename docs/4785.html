<html>
<head>
<title>Build a React App Using TypeScript, Yarn Workspaces, Webpack, and Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript、Yarn Workspaces、Webpack和Babel构建一个React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-react-app-by-using-typescript-yarn-workspaces-webpack-and-babel-d0ad120e72d9?source=collection_archive---------2-----------------------#2021-09-24">https://javascript.plainenglish.io/build-react-app-by-using-typescript-yarn-workspaces-webpack-and-babel-d0ad120e72d9?source=collection_archive---------2-----------------------#2021-09-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dce20a66dc8bc2a9528ce996535145a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mk_3peerHLrSZH1puI2Oyg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Large scale React App. Source <a class="ae jz" href="https://www.sitepoint.com/organize-large-react-application/" rel="noopener ugc nofollow" target="_blank">SitePoint</a></figcaption></figure><h1 id="3ba3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">语境</h1></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="68f0" class="ka kb in bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated"><strong class="ak">为什么我们需要使用Yarn工作空间？</strong></h1><p id="139c" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">想象一下，你和另外3个开发人员一起在React应用程序代码库中工作。你从很小的几个路线、集装箱和组件开始。一切都很平静。但是突然之间，公司赚了很多钱，想要在产品上投资更多的钱，他们雇佣更多的人来加快开发过程。</p><p id="7846" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">现在，挑战来了。我们希望有多个团队在每条React路线上工作，不同的路线将有不同的依赖关系，我们有另一个团队在开发不同的产品，需要实现一个共享的组件库——这不再是和平的了。每天，你都需要努力工作，找出如何重组你的代码库。那么，为什么不从一开始就以这样一种方式构建一个项目，以便于扩展呢？好吧，开始吧！</p><p id="b8d3" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated"><strong class="lm io">文件夹结构:</strong></p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/3d89c81844c6e9a4ba8ec552d19ace44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EU-BMFohhDIytD5Jf2641g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Folder structure for React App</figcaption></figure><p id="42ff" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">在这个例子中，我按照路线分割项目，我们有路线<code class="fe ms mt mu mv b">/home</code>、<code class="fe ms mt mu mv b">/about</code>，所以文件夹将是<code class="fe ms mt mu mv b">app</code>、<code class="fe ms mt mu mv b">app-home</code>、<code class="fe ms mt mu mv b">app-about</code>。</p><p id="9230" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">有了这个结构，你可以看到我们在<code class="fe ms mt mu mv b">src</code>文件夹下有多个独立的项目，这些项目将来可以被分割到不同的存储库中，并把它们作为一个依赖项。这就是为什么在<code class="fe ms mt mu mv b">app-home</code>下你会看到我有一个名为<code class="fe ms mt mu mv b">package.json</code>的文件，它声明了该文件夹的依赖关系。</p><p id="993d" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">现在，Yarn Workspaces开始在这里发挥作用。你不想在每个文件夹中都看到<code class="fe ms mt mu mv b">node_modules</code>吧？Yarn工作空间将解析整个项目中的所有依赖关系，然后在项目的根级别中只创建一个<code class="fe ms mt mu mv b">node_modules</code>文件夹。</p><h1 id="f9ff" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用别名导入</h1><p id="62da" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">我总是发现当导入一些东西和重构我的代码时，使用别名非常有帮助。千万不要费心去处理这个点点地狱<code class="fe ms mt mu mv b">../../../../</code></p><p id="72a8" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">但是，当您将一个项目拆分到另一个存储库中，并将其推送到NPM时，它会更有帮助。现在它变成了一个依赖项，所以您需要到处更新您的import语句。有了别名，您实际上不需要做任何事情，或者只需要简单地解析您想要匹配别名的包名。为了更清楚，我给你举个例子:</p><pre class="mo mp mq mr gt mw mv mx my aw mz bi"><span id="ad33" class="na kb in mv b gy nb nc l nd ne">//app-home/index.ts<br/></span><span id="4109" class="na kb in mv b gy nf nc l nd ne">// It works fine in both way</span><span id="e5ec" class="na kb in mv b gy nf nc l nd ne">//But with this way, you need to update the path if you split the component-library to become a node_modules dependency.<br/>import { Button } from '../component-library/src/Button'</span><span id="7fa9" class="na kb in mv b gy nf nc l nd ne">// Minor changes in the config to map the alias again the package.<br/>import { Button } from 'component-library/src/Button'</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="a6a9" class="ka kb in bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">使用Typescript、Babel、Webpack和Yarn工作区创建React应用程序:</h1><p id="4622" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">有很多关于如何用TypeScript、Babel和Webpack设置React的文章，所以我将快速浏览一遍。</p><h1 id="b5ab" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Package.json</h1><p id="238c" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">将这个文件<code class="fe ms mt mu mv b">package.json </code>复制到根级别，它包含编译项目所需的所有开发依赖项。</p><ul class=""><li id="4e4a" class="ng nh in lm b ln mi lr mj lv ni lz nj md nk mh nl nm nn no bi translated">私有:需要真实才能使用Yarn工作空间</li><li id="5009" class="ng nh in lm b ln np lr nq lv nr lz ns md nt mh nl nm nn no bi translated">工作空间:在哪里让Yarn知道工作空间来自哪里。</li><li id="5ad3" class="ng nh in lm b ln np lr nq lv nr lz ns md nt mh nl nm nn no bi translated">依赖项:它是空的，因为在根级别，我们的应用程序不需要任何依赖项，每个工作区都有一组自己的依赖项。</li><li id="a7ee" class="ng nh in lm b ln np lr nq lv nr lz ns md nt mh nl nm nn no bi translated">DevDependencies:所有的DevDependencies将留在这里，因为我们用它来编译我们的代码。</li></ul><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="41b9" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">创建文件夹目录和工作区</p><p id="eeb6" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">在每个工作空间中，我们需要一个文件“package.json”来声明它的依赖项。例如在<code class="fe ms mt mu mv b">src/app-home/package.json</code></p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b39c" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">注意，我声明<code class="fe ms mt mu mv b">component-library, app-home</code>是<code class="fe ms mt mu mv b">app-home</code>的依赖项，因为我们想在使用alias时绕过es-lint规则。</p><h1 id="cae0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">tsconfig.json</h1><p id="8832" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">如果我们想从VS代码自动导入，我们需要添加路径到<code class="fe ms mt mu mv b">tsconfig.json:</code></p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="d9e3" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">babel.config.json</h1><p id="7f48" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">我们还需要将路径解析器添加到babel配置中。在这里，我们使用<code class="fe ms mt mu mv b">babel-plugin-module-resolver</code>来解析别名。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="273b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">网络包.配置. js</h1><p id="ed40" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">在<code class="fe ms mt mu mv b">babel-loader</code>中，我添加了<code class="fe ms mt mu mv b">rootMode: upward</code>来让<code class="fe ms mt mu mv b">src</code>下的工作空间使用与根项目相同的babel配置。您的项目中可能不需要它。</p><figure class="mo mp mq mr gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="92b8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">如何为项目增加新的依赖:</strong></h1><p id="75bd" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">在每个项目的<code class="fe ms mt mu mv b">package.json</code>中，字段<code class="fe ms mt mu mv b">‘name’</code>会告诉你你正在工作的工作空间的名称，但是基本上，它会与文件夹名称相匹配。</p><p id="c761" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">对于为特定工作区添加新的依赖项，我们使用以下命令:</p><pre class="mo mp mq mr gt mw mv mx my aw mz bi"><span id="cab0" class="na kb in mv b gy nb nc l nd ne">yarn workspace &lt;workspace-name&gt; add &lt;packages&gt;</span></pre><p id="fc13" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">例如:我想将<code class="fe ms mt mu mv b">faker</code>添加到<code class="fe ms mt mu mv b">app-home</code>，命令将是:<code class="fe ms mt mu mv b">yarn workspace app-home add faker</code></p><h1 id="9c48" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">如何向根级别添加依赖关系:</strong></h1><p id="8d49" class="pw-post-body-paragraph lk ll in lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ig bi translated">有一些依赖项将在我们的项目中使用，比如<code class="fe ms mt mu mv b">webpack</code>、<code class="fe ms mt mu mv b">jest</code> …如果我们将它添加到根级别，这将是有意义的。</p><pre class="mo mp mq mr gt mw mv mx my aw mz bi"><span id="d61c" class="na kb in mv b gy nb nc l nd ne">yarn -W add &lt;packages&gt;</span></pre><p id="31cc" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated">参见我在<a class="ae jz" href="https://github.com/Tony1106/react-mono-repo" rel="noopener ugc nofollow" target="_blank"> Github repo </a>的示例项目</p><p id="8643" class="pw-post-body-paragraph lk ll in lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ig bi translated"><em class="nw">更多内容尽在</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm io"> <em class="nw">说白了</em> </strong> </a></p></div></div>    
</body>
</html>