<html>
<head>
<title>Don’t Fall For These 3 Common TypeScript Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要陷入这三个常见的类型脚本陷阱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dont-fall-for-these-3-common-typescript-pitfalls-43dd597fc723?source=collection_archive---------3-----------------------#2021-01-15">https://javascript.plainenglish.io/dont-fall-for-these-3-common-typescript-pitfalls-43dd597fc723?source=collection_archive---------3-----------------------#2021-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b462" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我打赌你以前遇到过这3种类型脚本/JavaScript陷阱…</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3d0f51d61d57c72bc830a2f4bfe8d969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dMc4fg3vols5b56t.png"/></div></div></figure><p id="4d72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，TypeScript并不完美。这是因为它向后兼容JavaScript。因此，有些事情可能无法解决，正如你所想的那样。</p><p id="423d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些东西是“不幸”设计的，不得不拖着走。你可以称之为遗留问题，如果不破坏已经存在的代码库，这些问题是不容易消除的。</p><p id="db6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我说重要的是不要只涵盖TypeScript的好的部分，还要涵盖不好的部分。只有这样，你才能以专业的方式处理语言。这篇文章给你带来了三个陷阱，最好不要上当。</p><h1 id="f0da" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.数组不是数组，你知道吗？</h1><p id="e012" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">JavaScript中的数组只不过是一个对象。一种对象，其上定义了一些方法，并自动分配其键。数组和对象几乎是相同的。证据:JavaScript的<em class="mk"> typeof </em>操作符在数组中使用时会返回<em class="mk">对象</em>。</p><p id="1424" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别是，数组和对象在某些地方有相同的行为。在TypeScript中的使用可能会导致问题，或者至少会导致意外和不希望的行为。当你想到OOP语言中对象遵循的规则集时，这一点就变得很清楚了。但在JavaScript中并非如此:它们与面向对象编程中的对象概念几乎没有任何共同之处。因为几乎没有传统面向对象的所有属性。相反，它们类似于所谓的字典或关联数组。</p><p id="0a72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在JavaScript中定义一个对象，试着想想可以用它做些什么。基本上，你是在运行时添加、修改、删除等等。这更像是字典中的键值对，不是吗？但在JavaScript中，这是对象的定义。如果将类型简单地称为字典而不是对象，JavaScript中就会少一个绊脚石。</p><p id="baa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当你试图处理一个不存在的键时:正常的行为会导致一个编译器错误。您甚至不能编译访问不存在的属性的代码。但在JavaScript中，严格来说，我们甚至没有对象，而是字典。所以键下是否有条目的问题不能在编译时回答，只能在运行时回答。因此，当访问对象的未设置属性时，JavaScript只返回未定义的值。</p><p id="a849" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组也不像其他语言中的经典数组。主要的区别是它的变量大小。在C#中，你需要一个泛型类型，比如集合或列表，大小是可变的。数组必须在写入任何值之前定义其大小。JavaScript对数组没有这种限制。它可以在运行时动态放大/缩小。JavaScript也知道所谓的稀疏数组，其中只有实际使用的值才占用内存。与C语言相比，数组的内部表示的结构非常不同。</p><p id="528e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些收集到的差异对TypeScript产生了影响。TypeScript确实不得不以同样的方式处理这些事情:</p><p id="6754" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">否则，将失去与Java脚本的向后兼容性，而这正是TypeScript想要不惜一切代价保留的。</p><p id="f9e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来看看如何在TypeScript中定义数组</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="414a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这确保了它是一个数字数组，因此，下面的调用是有效的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6e8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尝试使用number之外的类型的调用会导致编译器错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="644a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">读访问的行为如何？人们会认为访问索引0会返回number类型的值。正如对函数<em class="mk"> toFixed </em>的调用所证明的，这是完全相同的，只在这个数据类型上定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8da5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当访问一个没有设置值的索引时会发生什么？事实上，如上所述，JavaScript返回未定义的<em class="mk"/>，这就是类型应该考虑这一点的原因:可能返回的数字取决于索引，但也可能是未定义的。作为一名优秀的开发人员，您当然会意识到这一点，并努力将它考虑在内:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="69d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，TypeScript编译器现在抱怨说，与未定义的进行比较是不必要的——毕竟，<em class="mk"> someStack </em>属于类型<em class="mk">编号</em>。这显然是错误的，因为类型也可能是未定义的。这意味着以下内容的数组定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a761" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不应该导致数组中的每个元素都是类型<em class="mk"> number </em>，而是类型<em class="mk"> number | undefined </em>。这可能是正确的，但这正是TypeScript没有做到的！</p><p id="f967" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这个问题可以通过相应地定义数组来轻松解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c28a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不得不为每个阵列手动执行这一操作很烦人，事实证明并没有这样做。在这种情况下，应该始终注意类型系统会假装一种虚假的安全感。</p><h1 id="9fa0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.对象不是对象？{}是记录？等等什么？</h1><p id="2d83" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">正如我提到的，JavaScript中的对象最终是包含键值对的字典，其条目可以改变。但是如何正确地输入它们呢？</p><p id="8d9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个明显的例子是当对象被认为表现得像一个经典对象时的场景。如果它有一组定义良好的属性和方法(如果需要的话),那么它就是真的。然后可以定义一个类或一个接口来描述对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f028" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了类型安全，这两种情况具有相同的效果。类型为<em class="mk">字符</em>的对象——不管<em class="mk">字符</em>是如何定义的——现在总是具有属性<em class="mk">昵称</em>和<em class="mk">比赛</em>，这正是这里要确保的。</p><p id="8f85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们故意把一个物体当作字典使用时，情况就不同了。属性的数量和名称在运行时会有所不同。可以肯定的是，这可能是一个“<em class="mk">对象</em>”。空对象是一种极端情况，人们可能倾向于简单地指定<em class="mk"> {} </em>作为类型。</p><p id="77c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是<em class="mk"> {} </em>作为类型规范并不意味着<em class="mk">空对象</em>。它的意思是任何非空值。然后你可以简单地切换到<em class="mk">对象</em>，但这也不是选项。事实上，如果你用<em class="mk">对象</em>键入它，你的意思是拥有一个任意值，它不对应于<em class="mk">空值</em>。</p><p id="7bb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么<em class="mk">物体</em>就适合了，对吗？(注意，<em class="mk">对象</em>，不是<em class="mk">对象</em>)嗯，这种类型也有问题，说到用法。不可能检查或确保某个密钥是否存在。它只描述了一个空的对象。</p><p id="4ae0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了充分利用它，使用通用数据类型<em class="mk"> Record &lt; TKey，TValue &gt; </em>。这内置于TypeScript中，描述了从键到值的映射。但是要注意，不要犯轻易填写带有<em class="mk">字符串</em>和<em class="mk">任意</em>的类型的错误。这样就会错过这个操作的最初原因。使用<em class="mk">未知的</em>代替。这迫使你在访问一个属性时进行适当的强制转换，就像任何一个属性一样。不幸的是，这里也有问题。当处理定义为接口的对象时，TypeScript不允许您处理类型为<em class="mk"> &lt;字符串、未知&gt; </em>的<em class="mk">记录</em>。</p><p id="b9f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总结一下，在Typescript中有多种方法来描述表现为字典的对象。它们都不简单，或者不能很好地与语言的其他部分配合。这就像在生活中，你不能总是得到你想要的，这更像是一场你需要什么和什么最适合你的游戏。因此，明智地选择你的行动方式，你会得到回报。但是苦涩的余味总是存在，因为<em class="mk"> {} </em>和<em class="mk">对象</em>的行为不一样，当然也不像预期的那样。</p><h1 id="49f8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3.for-in和for-of有什么区别？</h1><p id="bdda" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">JavaScript提供了几种循环类型，除了经典的计数循环<em class="mk">用于</em>之外，还有其他选项可供选择。<a class="ae mn" href="https://bitsofco.de/for-in-vs-for-of/" rel="noopener ugc nofollow" target="_blank"><em class="mk">for-in</em>迭代对象键，当然还有<em class="mk"> for-of </em>迭代所有可迭代类型</a>。不要忘记<em class="mk"> forEach </em>循环，它只在数组上可用。[4]</p><p id="1bd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些年来，你可能还注意到，你可以用<em class="mk"> for-of </em>循环覆盖几乎所有的循环类型。正因为如此，linters为此引入了一个规则。甚至有一个ESLint规则[1],每当它可以替换默认的<em class="mk"> for </em>循环时，强制使用<em class="mk"> for-of </em>循环。</p><p id="0a3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与函数<em class="mk"> Object.keys </em>、<em class="mk"> Object.values </em>和<em class="mk"> Object.entries </em>结合使用，<em class="mk"> for-of </em>循环可用于迭代对象的键、值或两者。没有理由再使用任何其他类型的循环。至少如果不使用TypeScript的话。如果使用以下构造，TypeScript会报告一个错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="80ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该错误声明不确定一个键是否实际上是字符中的一个键——即使您正在遍历字符对象的键，因此它必须包含定义中的键！</p><p id="9a34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用<em class="mk"> Object.entries </em>来防止这种情况，以避免手动解析密钥。这适用于读取权限。这种方式不包括写访问。例如用户定义的对象克隆功能。</p><p id="e83e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk"> for-in </em>循环是唯一可以帮助你离开这里的循环。此外，还有一些副作用。因为它不仅返回并遍历给定对象的键，还迭代来自原型的键。因此，最好使用一个合适的<a class="ae mn" href="https://medium.com/@scadge/if-statements-design-guard-clauses-might-be-all-you-need-67219a1a981a" rel="noopener">保护</a> - <a class="ae mn" href="https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html" rel="noopener ugc nofollow" target="_blank">子句</a>，它确实检查了<em class="mk"> hasOwnProperty </em>以保持在给定对象的属性内。[2] , [3]</p><p id="2133" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，这种情况最终被<em class="mk"> for-of </em>循环抛在了脑后，但是没有！打字稿偷偷带回来的。</p><h1 id="b99e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="c9dc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">TypeScript中有些东西至少是不幸实现的。我们不能再期待改变了。这只会破坏与以前的TypeScript版本的兼容性。</p><p id="26e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<em class="mk"> for-of </em>循环的例子很烦人也很麻烦，但是是可以解决的。例1和例2要严重得多。它们只能通过开销和不方便的方式来解决。例如，通过额外指定<em class="mk">未定义</em>来正确输入数组，或者对象被用作字典。</p><p id="22e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有更多的设计缺陷，但我认为本文提出的这三个缺陷是TypeScript中最常见的误解。</p><p id="f87a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记，Typescript是一种很好的语言，可以用来编写轻量级和高效的代码。使用它很有趣，但主要是要确保知道你的工具的好与坏！</p><p id="8bdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mn" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="mk">节省自己大量的时间，专注于重要的主题。</em> </strong> </a></p><h1 id="b5bb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">继续读</h1><div class="mo mp gp gr mq mr"><a href="https://medium.com/agileinsider/is-kanban-just-putting-sticky-notes-onto-a-wall-1d8c3092213e" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">看板只是把便签贴在墙上吗？</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">关于何时以及何时不使用看板的看板指南</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kp mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a href="https://medium.com/front-end-weekly/html-dom-guide-for-everyone-ec07fdca93a1" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">面向所有人的HTML DOM指南</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">关于HTML 5中的DOM您必须知道的一切</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="ng l nc nd ne na nf kp mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a href="https://medium.com/javascript-in-plain-english/the-dark-side-of-typescript-try-catch-deeded18ba0d" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">TypeScript中Try/Catch的黑暗面</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">用“unknown”转义TypeScript 4.0中的任何错误异常</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">medium.com</p></div></div><div class="na l"><div class="nh l nc nd ne na nf kp mr"/></div></div></a></div><h2 id="0dc4" class="ni lo iq bd lp nj nk dn lt nl nm dp lx la nn no lz le np nq mb li nr ns md nt bi translated">资源</h2><p id="f039" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">[1]ESLint rule For-of:<a class="ae mn" href="https://github.com/sindresorhus/eslint-plugin-unicorn/blob/master/docs/rules/no-for-loop.md" rel="noopener ugc nofollow" target="_blank">https://github . com/sindresorhus/ESLint-plugin-unicorn/blob/master/docs/rules/no-For-loop . MD</a><br/>【2】Guard-clause:<a class="ae mn" href="https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html" rel="noopener ugc nofollow" target="_blank">https://refactoring . com/catalog/replacenesteddconditionalwithguardluctions . html</a><br/>【3】Guard clause Medium教程:<a class="ae mn" href="https://medium.com/@scadge/if-statements-design-guard-clauses-might-be-all-you-need-67219a1a981a" rel="noopener">https://Medium . com/@ scadge/if-statements-design-design</a></p></div></div>    
</body>
</html>