<html>
<head>
<title>What is a Hash Table?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是哈希表？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-a-hash-table-8901416e7042?source=collection_archive---------15-----------------------#2021-03-13">https://javascript.plainenglish.io/what-is-a-hash-table-8901416e7042?source=collection_archive---------15-----------------------#2021-03-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="451e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希表是一种数据结构，它存储了一组键/值对，这种存储方式使得以后查找它们非常有效。</p><h2 id="8498" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">我为什么要在乎？</h2><p id="0356" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">你有没有想知道:</p><ul class=""><li id="9184" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh ll lm ln lo bi translated">在给定的语言中，散列映射、关联数组或字典数据结构是如何工作的？</li><li id="c7a3" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">什么时候适合使用哈希表存储项目？</li><li id="0f59" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">我们如何处理哈希表中的“冲突”?</li></ul><p id="fcf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们想要存储一个用户列表，这样我们以后可以使用他们的名字找到他们。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/894b4b6137b51787f72596652fbc3b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*02F4wBaGlhut2X9JcoFwbw.png"/></div></figure><p id="e8f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以简单地将用户存储在一个数组中。当我们以后需要查找某人时，我们可以遍历所有用户来查找匹配的名字。</p><p id="fd19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们只有3个用户时，这很好。但是，如果我们有几千个，那就太慢了。通过使用哈希表，我们可以做得更好。</p><p id="145b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与遍历数组相比，哈希表存储条目的方式使得以后查找条目更快。</p><h1 id="badd" class="mc kj in bd kk md me mf kn mg mh mi kq mj mk ml kt mm mn mo kw mp mq mr kz ms bi translated">创建我们的哈希表</h1><p id="6394" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">要使用哈希表，我们需要每个用户有一个唯一的值——这是我们的密钥。我们将使用此密钥存储该项目，并在以后检索它。</p><p id="72ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这是一个很好的例子，所以我们假设每个用户都有一个惟一的名字，并以此作为我们的键。在实践中，我们会使用保证像ID一样唯一的东西。</p><p id="0fd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希表的工作原理是将项目存储在桶中:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/1d13e79feb2c5c011e9151c600d06677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UqnMYohyv50-8A75Q5cIVw.png"/></div></figure><p id="fe62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择桶数本身就是一个话题。为了一个简单的例子，我们将使用4个桶。</p><p id="b354" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们将用户添加到哈希表中时，我们使用他们的键来决定将他们存储在哪个桶中。</p><p id="9c83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们需要再次检索用户时，我们可以直接跳到正确的桶来找到它们..比依次检查每个用户要快得多！</p><h1 id="a113" class="mc kj in bd kk md me mf kn mg mh mi kq mj mk ml kt mm mn mo kw mp mq mr kz ms bi translated">在表中存储项目</h1><p id="4753" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">让我们存储我们的第一个用户“Ada”。</p><p id="c3ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要决定把她放在哪个桶里。这意味着我们需要从一个字符串(' Ada ')到一个桶号。这个过程就是我们的哈希函数。</p><p id="a43d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将为这个例子发明一个简单的散列函数。让我们取用户名中的每个字母，并给它分配一个编号；<code class="fe mu mv mw mx b">A=0</code>、<code class="fe mu mv mw mx b">B=1</code>、<code class="fe mu mv mw mx b">C=2</code>等。最后，我们可以把所有的值加在一起。结果就是我们的hash。</p><p id="0567" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于“Ada ”,这是3，因此我们可以将Ada存储在桶3中:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/ed933a23b9eddc23ea773aa2e8e1778e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Dy2nK9QUAjrDJPRYAOeGIg.png"/></div></figure><p id="ac2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们以后需要检索‘Ada’时，我们可以对她的名字执行相同的散列函数。这将告诉我们在3号桶中寻找她，不需要遍历数组。</p><p id="ffde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们存储下一个用户“Grace”:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/dbbc282cbd88d8a59eaa8956f1706bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*V8NVd6DTp1tfqWBq0kvagA.png"/></div></figure><p id="8d35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“grace”的哈希值是29，但我们没有29个存储桶！</p><p id="2df2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅仅使用它们的散列值来存储项目将意味着我们将需要非常大量的桶。相反，我们需要一种方法将哈希值(29)转换为桶号(从0到3)。</p><p id="08dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种常见的方法是将散列除以桶的数量，并将余数用作桶的数量。</p><p id="116b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两个数相除后的余数称为<a class="ae my" href="https://blog.mattclemente.com/2019/07/12/modulus-operator-modulo-operation.html" rel="noopener ugc nofollow" target="_blank">模数</a>。“grace”的哈希值是29，我们有4个存储桶。29除以4后的余数是1，所以“grace”存储在1号桶中。</p><p id="71fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个操作可以写成ad <code class="fe mu mv mw mx b">29 % 4 = 1</code>，或者<code class="fe mu mv mw mx b">29 mod 4 = 1</code>。</p><p id="58fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们以这种方式计算存储桶时，我们的哈希表看起来是这样的:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/27dd50fbed1b6e21588bd42dd041d81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*G0f5VtjHoYHMPsa53xu_Kw.png"/></div></figure><h1 id="8140" class="mc kj in bd kk md me mf kn mg mh mi kq mj mk ml kt mm mn mo kw mp mq mr kz ms bi translated">碰撞</h1><p id="e8e5" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">一个好的散列函数旨在将项目均匀地分布在整个桶中。</p><p id="08ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在实践中，我们最终会为多个项目计算同一个桶。这叫做碰撞。</p><p id="2522" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们存储“Tim”:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4e10d2365b08014c9b87d8b02127f0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*dlRrsXrINGodpw_0cJAkMA.png"/></div></figure><p id="0c21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在有两个用户需要存储在bucket 3中:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/d4cb886371b3523d897a223fdfdf2ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*e9KCUSEz6Pv1vEJfi7AKYA.png"/></div></figure><p id="73e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有几种方法可以解决这个问题:</p><p id="bd55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用一种算法来不断挑选新的桶，直到我们找到一个空的，然后将我们的项目存储在那里。每个桶中只有一个项目的方法称为开放式寻址。</p><p id="08ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，不是在每个桶中只存储<em class="mt">一个</em>物品，我们可以存储一个<em class="mt">物品集合</em>。当我们使用这种方法发现冲突时，我们只需将两个项目放在同一个桶中。</p><p id="286d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们以后需要检索项目时，我们仍然可以直接跳到正确的存储桶。不过，这一次，这个桶可以包含多个项目。在这种情况下，我们将依次检查桶中的每个项目，寻找我们想要的项目。</p><p id="3a0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这被称为独立链接，通常被用于哈希表实现。</p><p id="7ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么好的散列函数对性能极其重要的一个原因。</p><p id="85cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个糟糕的散列函数不会均匀地分布项目，所以它们最终只集中在少数可用的桶中。</p><p id="617b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最坏的情况下，所有东西都在<em class="mt">同一个</em>桶中结束，我们可能会遍历<em class="mt">每个项目</em>来找到我们要找的东西。这就是我们一开始使用哈希表所要避免的！</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="5aa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mt">喜欢这个？通过注册</em> <a class="ae my" href="https://www.baseclass.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mt">我的简讯</em> </a>每两周获得一篇这样的文章</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="7e7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">想了解更多？查看这些链接:</strong></p><ul class=""><li id="b7d2" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh ll lm ln lo bi translated"><a class="ae my" href="https://stackoverflow.com/a/30567466/1558579" rel="noopener ugc nofollow" target="_blank">哈希表上一个精彩的栈溢出答案</a></li><li id="4385" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated"><a class="ae my" href="https://www.geeksforgeeks.org/hashing-set-1-introduction/" rel="noopener ugc nofollow" target="_blank">关于散列表的三部分系列文章，更详细地介绍了上述所有内容</a></li><li id="398d" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated"><a class="ae my" href="https://www.geeksforgeeks.org/what-are-hash-functions-and-how-to-choose-a-good-hash-function/" rel="noopener ugc nofollow" target="_blank">关于哈希函数的更多信息</a></li><li id="e1b6" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated"><a class="ae my" href="https://stackoverflow.com/a/225664/1558579" rel="noopener ugc nofollow" target="_blank">另一个关于如何确定桶数的堆栈溢出回答</a></li></ul><p id="ca6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mt">更多内容尽在</em><a class="ae my" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>