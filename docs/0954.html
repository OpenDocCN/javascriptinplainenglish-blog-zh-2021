<html>
<head>
<title>Build a Custom Form Control using ControlValueAccessor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ControlValueAccessor生成自定义窗体控件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-custom-form-control-using-controlvalueaccessor-dc7e99511fb8?source=collection_archive---------5-----------------------#2021-02-28">https://javascript.plainenglish.io/build-a-custom-form-control-using-controlvalueaccessor-dc7e99511fb8?source=collection_archive---------5-----------------------#2021-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/432f9cd83b1b323877bb50091ba1d9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*brFPWVM1lOSfChCF"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Wiediger</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ada1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用Angular的“FormBuilder”类和本地输入元素，可以生成强大的表单。但是，这些元素有时不能提供足够的功能来按照我们想要的方式显示表单。在这种情况下，您将需要构建必须由“FormBuilder”支持的自定义表单组件。为此，您的定制组件必须实现“ControlValueAccessor”接口，这就是我们将在本文中讨论的内容。</p><h1 id="7d47" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们将要建造的</h1><p id="4551" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了将重点放在实现“ControlValueAccessor”接口的方法上，我们将构建一个非常简单的表单控件，它将显示一个“开/关”按钮。基本上，这将是一个花哨的复选框。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/1205d6f43f124664e8fe950ec63cc072.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/1*SzfcmMf6t2Q6m5uRsx1z5w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">On/off switch</figcaption></figure><h1 id="2840" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基础知识</h1><p id="6d3f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们开始构建我们的组件<strong class="kc io">，而不需要</strong>实现“ControlValueAccessor”接口。我将跳过创建一个新项目/组件所需的步骤，因为已经有很多关于这方面的文章了。假设您已经创建了项目和一个名为“OnOffComponent”的组件。</p><h2 id="be96" class="mg kz in bd la mh mi dn le mj mk dp li kl ml mm lm kp mn mo lq kt mp mq lu mr bi translated">模板</h2><p id="3fa0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">该模板仅包含“开”和“关”按钮:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0568" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还将这些元素的“click”事件绑定到“switch”方法，以便更新“value”输入。</p><h2 id="75f3" class="mg kz in bd la mh mi dn le mj mk dp li kl ml mm lm kp mn mo lq kt mp mq lu mr bi translated">SCSS</h2><p id="2aeb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将使组件成为“inline-flex ”,以便显示相邻的两个按钮。我们将样式直接应用于“host”伪选择器，以避免在组件中有一个主“div”。请注意，当组件被禁用时，类“disabled”也应用于宿主组件(通过TypeScript代码)。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0439" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打字稿</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="97cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们为组件定义了两个输入:</p><ul class=""><li id="8187" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><strong class="kc io">禁用</strong>:定义组件是否被禁用。</li><li id="3e25" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io">值</strong>:定义元件的当前值。</li></ul><p id="e747" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还绑定了主机的一些属性和事件:</p><ul class=""><li id="b218" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><strong class="kc io">角色</strong>、<strong class="kc io"> aria-checked </strong>和<strong class="kc io"> aria-disabled </strong>:提高组件的可访问性</li><li id="4c65" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> class.disabled </strong>:根据“disabled”输入的值，将“disabled”类添加到主机。</li><li id="7183" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> attr.tabIndex </strong>:当组件未被禁用时，将“tabIndex”属性设置为“0”以使其可制表。</li><li id="7e4c" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> keydown.arrowleft </strong>和<strong class="kc io"> keydown.arrowright </strong>:当组件有焦点时，允许组件值随左/右箭头改变。</li></ul><p id="f76e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于“switch”方法，如果组件没有被禁用，并且参数中传递的值与当前值不同，我们只需更新“value”输入。</p><p id="0cbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还创建了一个输出，在每次组件的值改变时发出一个事件。</p><p id="bd37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们在“OnPush”上设置组件的变更检测策略，以提高性能(并为没有zone.js的未来做好准备)。</p><h1 id="e53c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实现“ControlValueAccessor”</h1><p id="1b5c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">因此，该组件不能以反应形式使用，因为它不实现“ControlValueAccessor”接口。为此，首先需要通过在组件的“component”装饰器中添加以下代码，经由“NG_VALUE_ACCESSOR”注入标记将组件注册为控制访问器:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="79c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，您需要指定您的类实现“ControlValueAccessor”接口:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9fb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，您需要实现四个方法:</p><ul class=""><li id="7b30" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><strong class="kc io"> writeValue </strong>:被调用更新组件的值。例如，用“FormBuider”创建表单时，如果将该字段的默认值设置为“true”，Angular将使用该值调用“writeValue”。</li><li id="f0bd" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> registerOnChange </strong>:你需要一种方法来告诉Angular你的组件的值何时改变。该方法为您提供了一个函数，每次组件的值发生变化时，您都必须保存并调用该函数。</li><li id="804f" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> registerOnTouched </strong>:这个方法的目标和“registerOnChange”一样，但是它用来告诉Angular什么时候用户已经和组件交互了。Angular使用它来更新组件的原始状态，以便显示验证提示(例如)。</li><li id="30fe" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><strong class="kc io"> setDisabledState </strong>:顾名思义，这个方法被调用来更新组件的禁用状态。</li></ul><p id="5e94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从最简单的开始实现这些功能:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d85f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里唯一需要注意的是，我们将组件的值设置为“！！值”，以便将值转换为布尔值。</p><p id="e4e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述,“registerOnChange”方法是用参数中的函数调用的，我们必须保存该函数，以便在组件的值发生变化时调用它，因此我们需要声明一个变量并将函数存储在其中:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a048" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们需要在“switch”方法中调用这个函数，以便传播更改:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b206" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，您需要检查是否定义了“onChange”变量，因为您的组件可能用在与反应式表单不同的上下文中，在这种情况下，不会调用“registerOnChange”。</p><p id="ce6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们需要用“registerOnTouched”方法做一些类似的事情:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a1bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用该函数的一个好地方是在组件的“模糊”事件中，因此您需要将它添加到“组件”装饰器的“主机”属性中:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8059" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于“onChange”函数,“onTouched”函数不一定要定义，所以最好在调用它之前确保它是。</p><p id="c5ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管我们已经完成了“ControlValueAccessor”的实现，但是组件还没有完全完成。事实上，由于它公开了“value”输入，组件的值有可能通过这个输入得到更新，这意味着我们也需要传播这个变化。</p><p id="98e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要解决这个问题，首先创建一个私有变量来存储值:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7d38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，修改“值”输入以使用该变量和“切换”方法:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ede7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要在“切换”方法中进行两项更改:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="35ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们做的第一个改变是第5行。以前，我们更改了“value”的值，但这会导致一个循环，因为“value”输入的设置程序调用了“switch”方法。</p><p id="c5c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个变化位于第13行。当使用“OnPush”更改策略构建自定义窗体控件时，您不能总是确保其值以“OnPush”更改策略所涵盖的方式进行更改。例如，组件的值可以通过在组件外部的“setTimeout”中输入的“value”来更改，在这种情况下，视图不会更新，因此我们需要调用“ChangeDetectorRef”的“markForCheck”方法来告诉Angular在值更改后检查我们的组件。</p><p id="f3cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们有一个工作表单控件，我们现在要测试它(使用表单，而不是单元测试)。请注意，实现“ControlValueAccessor”接口还允许您对组件使用“ngModel”。</p><p id="b5d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果它对您不起作用，或者您在解释过程中迷失了方向，以下是该组件的完整代码:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="0530" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试组件</h1><p id="efb9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们像这样修改我们的应用程序组件代码:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1d5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并在模板中使用此表单:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e9b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果是意料之中的:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c40d8078b07a33b94aec1b5a3b432ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*lHByYhtBrMSGeB4gFjysyw.png"/></div></figure><p id="e85b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您也可以更新表单定义以禁用组件:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/918157513c299998843dad085e0052e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*HNr1TDsqND2-fuLQ0A1oyw.png"/></div></figure><p id="e3d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起初，“ControlValueAccessor”接口看起来很奇怪，尤其是“registerOn…”方法，但是一旦理解了它们的用途，构建自定义窗体控件就变得非常容易了。</p><blockquote class="nk nl nm"><p id="f240" class="ka kb nn kc b kd ke kf kg kh ki kj kk no km kn ko np kq kr ks nq ku kv kw kx ig bi translated">如果你喜欢这篇文章，想要支持我，请不要犹豫，鼓掌或者请我喝杯咖啡:-)好吗</p></blockquote><figure class="mc md me mf gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ssougnez"><div class="gh gi nr"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a></figure></div></div>    
</body>
</html>