<html>
<head>
<title>React Learning Roadmap For 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react 2021年学习路线图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-learning-roadmap-for-2021-a1c0f7456186?source=collection_archive---------0-----------------------#2021-01-09">https://javascript.plainenglish.io/react-learning-roadmap-for-2021-a1c0f7456186?source=collection_archive---------0-----------------------#2021-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3d06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习的路线图React我希望我知道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a54f263bd554b7364bbc483a086b0c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77VFzpklgL26QApHui2N4A.png"/></div></div></figure><h1 id="e3ec" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.入门指南</h1><h2 id="b373" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">React需要了解的JavaScript</h2><p id="4c81" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">将<strong class="ma ir"> React </strong>与其他框架相比，React最大的优点是你在使用它时的暴露程度，因为它没有模板DSL <strong class="ma ir"> <em class="mr"> (JSX编译成可感知的JavaScript) </em> </strong>，组件<strong class="ma ir"> API </strong>总是随着React挂钩的加入而变得更简单，并且该框架在核心UI元素之外提供了很少的抽象</p><h2 id="b812" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">1.模板文字</h2><p id="033e" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">模板文字用反斜杠<strong class="ma ir"> (` `) </strong>字符括起来，而不是双引号或单引号。</p><p id="bb51" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">它们可以包含占位符，由美元符号和花括号<strong class="ma ir"> (${})表示，占位符中的表达式和反斜线之间的文本被传递给函数。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/95a2ac9b120ef8fda73688deea1ff92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2sbm5phLYxocPqyGuFeNQ.png"/></div></div></figure><h2 id="0682" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">2.速记属性名</h2><p id="1352" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">构建<strong class="ma ir"> React </strong>应用程序很常见，其中一个对象是描述<strong class="ma ir"> <em class="mr">对象</em> </strong>初始化的表达式，它由用于描述<strong class="ma ir"> <em class="mr">对象</em> </strong>的属性组成。</p><p id="7a00" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">对象属性的值可以包含原始数据类型或其他对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/d8ad0dc6da43a45672a1954ce65d9960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8Ev8zTr849aGLigf5J28A.png"/></div></div></figure><h2 id="4b08" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">3.箭头功能</h2><p id="711a" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">箭头函数是在<strong class="ma ir"> JavaScript </strong>中编写函数的另一种方式。但是它们确实有一些不同，在React中，如果我们在我们的项目中使用钩子而不是类，我们不必担心，因为<strong class="ma ir"><em class="mr"/></strong>。</p><p id="0e75" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">箭头函数允许更简洁的匿名函数和隐式返回，所以你绝对想使用它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/6f31b2d9ed7743f7f667a75f3d12c57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bW2mXpafvpGYqr6QLu4i8A.png"/></div></div></figure><h2 id="c2dc" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">4.解构</h2><p id="3a4f" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">JS最喜欢的特性之一，可以析构对象和数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/7dd15cb3b32e436dae7705c786814377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEixmUdGdLULtkep4CRfgw.png"/></div></div></figure><h2 id="4255" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">5.参数默认值</h2><p id="7de4" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">在<strong class="ma ir"> JS </strong>中，函数参数默认为未定义，设置一个不同的值通常是有用的，这就是默认参数的用处。</p><p id="bb78" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">设置默认值的一般策略是测试函数体中的参数值，如果没有定义，就给它们赋值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/992a8c62115303a1a68109ea77fff0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqR44_r0ddl6AW6GKBcxPA.png"/></div></div></figure><h2 id="0edf" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">6.剩余/扩展运算符</h2><p id="a9e6" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">yntax是一种集合语法，它对值的集合进行操作。在制作复杂的应用程序时，你会一直用到它。我强烈建议你仔细阅读这个概念，因为它总是让你的工作变得容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/6281b141feb7f8b68eea2c123c0d829a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSZMoRwu2L15dogIQVQr2w.png"/></div></div></figure><h2 id="20ff" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">7.ESModules</h2><p id="8ee3" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">使用现代工具构建应用程序总是需要您了解语法是如何工作的，因为任何规模很小的应用程序都可能需要使用模块来进行代码重用和组织。</p><h2 id="cf56" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">8.三元运算符/条件运算符</h2><p id="540b" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">该运算符将为您节省大量时间，在<strong class="ma ir"> JSX </strong>中，它是唯一一个接受三个操作数的JS运算符:</p><ol class=""><li id="0e36" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq ni nj nk nl bi translated">一个条件后跟一个问题<strong class="ma ir">(？)</strong>。</li><li id="6a3f" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">然后用一个<strong class="ma ir">冒号(:)表示条件为真时要执行的表达式。</strong></li><li id="f9ce" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">最后，如果条件为<strong class="ma ir">false</strong>，则执行表达式。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/1ec650f6ab85db113925f2aae7066394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_izgYohsEGerOKJdHChdTg.png"/></div></div></figure><h2 id="7123" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">9.数组方法</h2><p id="7358" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">我一直在使用数组方法，你可能会用到下面这些最常用的方法。</p><ol class=""><li id="9ddd" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq ni nj nk nl bi translated">发现</li><li id="fb4c" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">一些</li><li id="15d2" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">每个</li><li id="58bd" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">包含</li><li id="136e" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">地图</li><li id="38ef" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">过滤器</li><li id="6201" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">减少</li></ol><p id="89de" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/1b5fbf7330135ced03abf16a2f115c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtNOyYXGG8y--wLTsNuFcg.png"/></div></div></figure><h2 id="9c80" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">10.Nulish合并算子</h2><p id="e0e8" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">这可以用逻辑<strong class="ma ir">或(||) </strong>操作符来构造，如果左操作数是任何falsy值，而不仅仅是null或undefined，则返回右边的操作数。</p><p id="2ab8" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">如果您使用<strong class="ma ir"> || </strong>为另一个变量提供一些默认值，如果您考虑任何<strong class="ma ir">false值，您可能会遇到一些错误。</strong></p><p id="eddb" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">如果该值为null或未定义，那么您希望返回到某个默认值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/94d5a223576a4039fee8623637b4567f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_df5VqaPCrAhF7Udl6C5Dg.png"/></div></div></figure><h2 id="2f13" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">11.可选链接</h2><p id="76a3" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">也被称为<strong class="ma ir">‘猫王操作符’</strong>允许你安全地访问属性和调用可能不存在的函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/4abfa891b64c039a400eddf2fd45e32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlI6NL2XFssF9gi_Xy6wvw.png"/></div></div></figure><h2 id="f236" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">12.承诺和异步/等待</h2><p id="29f1" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">承诺在<strong class="ma ir"> JS </strong>生态系统中无处不在，承诺帮助你管理异步代码，并且从任何<strong class="ma ir">DOM API</strong>以及第三方库返回。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="1613" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">2.核心组件</h1><ul class=""><li id="c613" class="nd ne iq ma b mb mc me mf lo og lr oh lu oi mq oj nj nk nl bi translated">JSX</li><li id="cc11" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">MDX</li><li id="c136" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">组件和道具</li><li id="4813" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">状态和生命周期</li><li id="7e25" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">调和与虚拟DOM</li><li id="2ea9" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">处理事件</li><li id="db68" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">参考文献</li><li id="13d9" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">碎片</li></ul><h2 id="719e" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">1.JSX (JavaScript XML)</h2><p id="dc77" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">让我们考虑一个变量:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="a6da" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</strong></span></pre><p id="79c2" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">我们简单地称这个标签语法为<strong class="ma ir"> JSX </strong>它既不是一个<strong class="ma ir"> HTML </strong>也不是一个字符串。</p><p id="5b2f" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><em class="mr">那么为什么JSX在谈到</em> <strong class="ma ir"> <em class="mr">如此重要的学问时会有什么反应呢？</em> </strong></p><p id="e8a7" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">当我们处理大量包含各自属性的独立组件时，这些组件被称为<strong class="ma ir"> props，JSX </strong>支持React应用程序的开发，总体来说React不需要使用JSX，但人们发现它很有帮助，因为在JavaScript代码中处理UI元素时，它允许React显示更多有用的错误和警告消息。</p><p id="f34d" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">此外，JSX还有很多其他优势，例如，JSX可以防止注入攻击，因为默认情况下React DOM在渲染之前会对嵌入在JSX中的任何值进行转义。 </p><h2 id="bd84" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">2.MDX</h2><p id="dc36" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">一种可创作的格式，允许你在你的减价文件中写下<strong class="ma ir"> JSX </strong>。您还可以导入交互式图表或警报等组件，并将它们嵌入到您的内容中。使用<strong class="ma ir"> <em class="mr"> MDX </em> </strong>一直是一个优势，因为<strong class="ma ir"> MDX中没有运行时，所有编译都发生在构建阶段。</strong></p><h2 id="36b8" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">3.React组件和道具</h2><p id="d46a" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">有了新版的<strong class="ma ir"> JavaScript，</strong>我们可以使用类定义带有属性的对象，<strong class="ma ir"> React </strong>让我们使用这个语法来创建我们称之为<strong class="ma ir"> <em class="mr">的组件。</em> </strong></p><p id="1ca4" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">您需要练习两种类型的组件:</p><ol class=""><li id="6c6c" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq ni nj nk nl bi translated"><strong class="ma ir"> <em class="mr">类组件</em> </strong></li><li id="6f39" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated"><strong class="ma ir"> <em class="mr">功能组件</em> </strong></li></ol><p id="7f97" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">我已经用例子简单解释了两者的区别(打开<a class="ae ot" href="https://medium.com/javascript-in-plain-english/understanding-the-difference-between-function-class-components-in-react-35279a119d29" rel="noopener"> <strong class="ma ir">链接</strong> </a>进一步阅读React组件)。</p><h2 id="2939" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated"><strong class="ak"> 4。道具</strong></h2><p id="35de" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">React props就像JavaScript中的函数参数和HTML中的属性一样。为了在组件中发送属性，我们使用了与HTML属性相同的语法。</p><p id="d09a" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">例如:</p><p id="d050" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">我们向<strong class="ma ir">用户名</strong>元素添加一个名称。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="9225" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">const myelement = &lt;Car brand="Ford" /&gt;;</strong></span></pre><p id="ab06" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">并且组件将参数作为prop对象接收。如果我们运行下面的代码:</p><p id="71b3" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">它返回，<strong class="ma ir"> <em class="mr">我是福特。</em>T29】</strong></p><p id="c270" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">所以我们只是从外部将属性传递给一个组件</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="ea37" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/></strong><br/>class Car extends React.Component {<br/>  render() {<br/>    return &lt;h2&gt;I am a {this.props.brand}!&lt;/h2&gt;<br/>  }<br/>}<br/><br/>const myelement = &lt;Car brand="Ford" /&gt;;<br/><br/>ReactDOM.render(myelement, document.getElementById('root'));</span></pre><h2 id="3150" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">5.状态和生命周期</h2><p id="dba8" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">React组件有一个内置的<strong class="ma ir">状态</strong>对象，状态对象是你存储属于组件的属性值的地方。因此，每当<strong class="ma ir">状态</strong>改变时，<strong class="ma ir">组件就会重新呈现。</strong></p><p id="437c" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">关于状态还有很多更深层次的概念要讨论，但我们将只讨论外部部分。</p><blockquote class="ou ov ow"><p id="7d99" class="ly lz mr ma b mb ms jr md me mt ju mg ox mu mi mj oy mv ml mm oz mw mo mp mq ij bi translated">只有3种状态，本地，养育，远程。</p></blockquote><ul class=""><li id="cdd6" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">本地</strong></li></ul><p id="04ac" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">本地状态管理发生在组件本身内部，这通常也是通过类组件中的<strong class="ma ir"> useState </strong>、<strong class="ma ir"> useReducer </strong>和<strong class="ma ir"> this.state </strong>来完成的。例如，看看计数器组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/4ea00adbea6e424dcf2139734a17d19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAU69RaxZu6_fYIqTxo4wA.png"/></div></div><figcaption class="pb pc gj gh gi pd pe bd b be z dk"><strong class="bd pf">Local State</strong></figcaption></figure><ul class=""><li id="8a96" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">肠胃外</strong></li></ul><p id="264e" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">当数据及其<strong class="ma ir"> <em class="mr">更新器</em> </strong>作为道具从组件树中的某个更高位置传入时，状态管理发生。</p><p id="4600" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">在上面的例子中，如果我们使用父状态，那么将数据和更新函数移动到父控制组件，并将它们作为<strong class="ma ir"> props </strong>传递到受控制的子组件，这将非常简单。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/13b8730394728b20cadc7a65069c349e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DCOqjZnkOnrIF31SyU4vA.png"/></div></div></figure><ul class=""><li id="dd4b" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">远程</strong></li></ul><p id="15e7" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">当我们在组件的祖先之外存储和更新数据时，就会发生远程状态管理。我们在<strong class="ma ir"> Redux </strong>或<strong class="ma ir"> React上下文API中非常常用这些方法。</strong></p><p id="1d16" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">这个概念的基本部分是更新程序与消费组件有一段距离，需要一些工作来向消费者提供数据。</p><h2 id="60a6" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">6.生命周期</h2><p id="4e28" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">当我们在React组件中将生命周期定义为出生、成长和死亡时，我们也遵循这个周期:</p><p id="a1da" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir">T1。创建(挂载在DOM上)</strong></p><p id="9982" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> <em class="mr">。</em> </strong>成长(更新)</p><p id="cfec" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> <em class="mr">。</em>死亡(从DOM中卸载)</strong></p><p id="4dad" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">生命周期可以分为四个部分:</p><ul class=""><li id="1ce8" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated">初始化</li><li id="6636" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">增加</li><li id="9732" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">更新</li><li id="ed23" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">卸载</li></ul><h2 id="b32d" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">7.调和与虚拟DOM</h2><p id="d0ef" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">Rect提供了一个声明性的API，这样我们就不必担心每次更新时会发生什么变化，这使得编写应用程序变得更加容易。当组件状态改变时，React必须计算是否有必要更新DOM。</p><h2 id="a1d7" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated"><strong class="ak"> 8。了解虚拟DOM </strong></h2><p id="7c5d" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">在React中，对于每个DOM对象，都有一个对应的<strong class="ma ir">‘虚拟DOM’</strong>对象，它是一个DOM对象的表示。</p><p id="d369" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">虚拟DOM对象与真实DOM对象具有相同的属性，尽管它缺乏真实对象直接改变屏幕内容的能力。</p><p id="47cd" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">当您尝试在React中更新DOM时，会发生以下情况:</p><ol class=""><li id="d029" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq ni nj nk nl bi translated">整个虚拟DOM得到更新。</li><li id="3f8c" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">反应出哪些物体发生了变化。</li><li id="d27d" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">在真实的DOM上，只有更改过的对象才会得到更新。</li><li id="c8c2" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">真实DOM上的改变导致屏幕改变。</li></ol><h2 id="db64" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">9.处理事件</h2><p id="30b5" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">React可以基于用户事件执行操作。React有和HTML一样的事件:点击，改变，鼠标悬停。</p><ol class=""><li id="22a8" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq ni nj nk nl bi translated">React事件使用<strong class="ma ir">驼峰式</strong>符号而不是<strong class="ma ir">小写</strong>命名。</li><li id="0fad" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq ni nj nk nl bi translated">我们传递一个函数作为事件处理器，而不是一个字符串。</li></ol><p id="a5a9" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">我们需要在React应用程序中处理这些事件，以使它们随时响应。</p><p id="eb4c" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">例如，让我们用<strong class="ma ir"> onclick </strong>事件来检测用户何时点击组件中的特定区域:</p><p id="1e6c" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">在HTML中。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="4504" class="lj ks iq ol b gy op oq l or os">&lt;button <strong class="ol ir">onclick</strong>="activateLasers()"&gt;<br/>  Activate Lasers<br/>&lt;/button&gt;</span></pre><p id="52c4" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">在反应。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="db03" class="lj ks iq ol b gy op oq l or os">&lt;button <strong class="ol ir">onClick</strong>={activateLasers}&gt;  Activate Lasers<br/>&lt;/button&gt;</span></pre><h2 id="d20b" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">10.参考文献</h2><p id="b8b1" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">Refs是React提供的一个函数，用于访问我们自己创建的DOM元素和React元素。它们主要用于当我们想改变一个子组件的值而不使用道具和其他东西的时候。</p><p id="ae32" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> <em class="mr">例如:</em> </strong></p><p id="96a6" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">无参考文献</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/f126fa704ff922e31fe9dfc6dbf1af64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mb9FNgynf9VqbrBMVd61Pw.png"/></div></div></figure><p id="4f36" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">使用引用</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/78ca5cd985e8d60b0732111ef6e751f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbC9hmIf4dbXfQnVMct1aw.png"/></div></div></figure><p id="0f32" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">何时使用参考文献。</p><ul class=""><li id="5cdb" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated">使用第三方库时。</li><li id="5de5" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">在动画中。</li></ul><p id="9646" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">何时不使用参考文献。</p><ul class=""><li id="6e12" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated">因为它们没有实例。</li><li id="c5e5" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">可以公开完成的事情。</li></ul><h2 id="dcff" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">11.碎片</h2><p id="057c" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">在React中，当你必须在一个组件中渲染多个组件时，你会大量使用fragment。</p><blockquote class="pj"><p id="1452" class="pk pl iq bd pm pn po pp pq pr ps mq dk translated">一个组件只能返回一个元素。</p></blockquote><p id="7037" class="pw-post-body-paragraph ly lz iq ma b mb pt jr md me pu ju mg lo pv mi mj lr pw ml mm lu px mo mp mq ij bi translated">例如:</p><p id="0015" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">我们使用<strong class="ma ir"> React.fragment </strong>将类组件名称中的<strong class="ma ir"> h1 &amp; p1 </strong>呈现为<strong class="ma ir"> BlogPostExcerpt </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/7e74dd9bfd7c7cc058cf132906f8e063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmtXBNIvB7GsJxYUEj8N9Q.png"/></div></div></figure></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="dc5b" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">3.式样</h1><h2 id="c6af" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">1.React中的CSS</h2><p id="d747" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">CSS-in-JS不是一个特定的东西，它是一种设计应用程序风格的技术。在<strong class="ma ir"> CSS-in-JS兴起之前，</strong>使用CSS最广泛的方式是使用CSS模块，它们基本上只是。css文件，你把你所有的<strong class="ma ir"> CSS </strong>代码，如类名，id，动画等，并且每次它被导入到特定模块的名字和动画，默认情况下是本地组件范围。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/ae1739c4e06a4302b71ceca16210ee80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2UqqtBfh7ABsUaB0uzi4g.png"/></div></div></figure><h2 id="e042" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">2.CSS-In-JS</h2><p id="9874" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated"><strong class="ma ir"> CSS-in-JS </strong>不同于内联样式，因为我们仍然用JS编写所有的CSS，但是我们没有将它传递给style属性，而是将这些样式和一个实际的CSS字符串注入到DOM的&lt; style &gt;标签中。</p><p id="61e7" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">例如:</p><p id="66ad" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">如果您正在使用内联样式，您需要做的就是创建一个JS对象并传递样式化元素的选项。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="2903" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">const styles = {<br/>      background: "#FE0000",<br/>      color: "#FFFFFF"<br/>    };</strong></span></pre><p id="d65e" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">然后在您的元素中，我们传递:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="0a81" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">&lt;div style={styles}&gt;<br/>     &lt;h1&gt;CSS-in-JS&lt;/h1&gt;<br/>    &lt;/div&gt;</strong></span></pre><p id="e755" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">通过使用内嵌样式，我们有一些限制，因为我们不能使用<strong class="ma ir">伪选择器、媒体查询、关键帧等。</strong></p><p id="3a06" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">但CSS-in-JS不同于内联样式，通过将所有CSS放在JS中并使用CSS-in-JS，我们可以有单独的文件夹来以更好的方式组织您的样式，并有不同React组件的文件，消除了我们在单个<strong class="ma ir"> <em class="mr">中的所有混乱。css文件。</em>T11】</strong></p><p id="86fb" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir">例如:</strong></p><p id="c62f" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">您必须首先使用您选择的软件包管理器安装样式化的组件。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="2a51" class="lj ks iq ol b gy op oq l or os">yarn add styled-components</span></pre><p id="4e65" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">然后将其导入React组件:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="c883" class="lj ks iq ol b gy op oq l or os">import styled from "styled-components";</span></pre><p id="49a9" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">要开始使用它，您只需创建一个对象模板文字，</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="5faa" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">const StyledButton = styled.button`<br/>      width: 120px;<br/>      height: 42px;<br/>      background: #FE0000;<br/>      color: #FFFFFF;<br/>    `;</strong></span></pre><p id="ef64" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">要使用我们刚刚创建的这个组件，您必须将它作为我们创建的按钮来传递。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="de30" class="lj ks iq ol b gy op oq l or os"><strong class="ol ir">import React from "react";<br/>    import styled from "styled-components";<br/><br/>    const StyledButton = styled.button`<br/>      width: 120px;<br/>      height: 42px;<br/>      background: #FE0000;<br/>      color: #FFFFFF;<br/>    `;<br/><br/>    const Button = () =&gt; (<br/>      &lt;StyledButton&gt;<br/>        My Styled Button<br/>      &lt;/StyledButton&gt;<br/>    );<br/><br/>    export default Button;</strong></span></pre><h2 id="f2d2" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">3.动画</h2><ol class=""><li id="ab37" class="nd ne iq ma b mb mc me mf lo og lr oh lu oi mq ni nj nk nl bi translated"><strong class="ma ir"> Popmotion </strong></li></ol><p id="fc5b" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">它是一个底层的功能性JS运动库，允许开发者在JS环境中(<strong class="ma ir">浏览器，节点</strong>)动画到任何渲染目标<strong class="ma ir"> (CSS，SVG，Thee，JS，canvas等)。</strong></p><p id="0ca7" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">要安装:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="08c3" class="lj ks iq ol b gy op oq l or os">npm install popmotion --save<!-- --> </span></pre><p id="51f4" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> 2。反应动作</strong></p><p id="0049" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">React Motion是React的一个动画库，它使得创建和实现逼真的动画变得很容易(<strong class="ma ir">你可以创建真正自然的、基于物理的动画)。</strong></p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="78c2" class="lj ks iq ol b gy op oq l or os">npx create-react-app intro-react-motion</span></pre><p id="0167" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> 3。反作用弹簧</strong></p><p id="0983" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">React Spring是另一个伟大的动画库，用于构建基于物理的动画，支持React中大多数UI相关的动画，它是两个世界中最好的，它是两个现有React动画库之间的桥梁，即:<strong class="ma ir"> React Motion &amp; Animated。</strong></p><p id="8d5a" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated"><strong class="ma ir"> 4。反应过渡组</strong></p><p id="d6a8" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">这不是一个像<strong class="ma ir"> React-Motion、</strong>那样的动画库，它公开了用于定义进入和现有过渡的简单组件。它公开转换阶段，管理类和组元素，并以有用的方式操作DOM。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="45f0" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">4.状态管理</h1><h2 id="957b" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">1.Redux</h2><p id="8580" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">Redux是一个针对<strong class="ma ir"> JavaScript </strong>应用的可预测状态容器，你可以编写行为一致并在不同环境<strong class="ma ir">(客户端、服务器和本机)</strong>下运行的应用。你可以把Redux和React一起使用，并且有一个很大的插件生态系统。</p><h2 id="2785" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">2.MobX</h2><p id="56c5" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">React应用程序的另一个很棒的状态管理库，所有对数据的更改和使用都在运行时被跟踪，构建一个依赖关系树来捕获依赖于状态的计算。<strong class="ma ir"> MobX </strong>允许你在任何UI框架之外管理你的应用程序状态，这使得你的代码可移植且易于测试。</p><h2 id="ef87" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">3.未说明的</h2><p id="5f97" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">如果你已经习惯了React，Unstated非常简单易懂，它建立在现有的React概念之上，如<strong class="ma ir"> setState、类结构、上下文和通用模式，如render props </strong>。</p><h2 id="01eb" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">4.RxJS</h2><p id="fae3" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">一个通过使用可观察序列来编写异步和基于事件的程序的库。RxJS 能够使用我们的函数生成值，这意味着您的代码不容易出错。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="507e" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">5.数据管理</h1><h2 id="73ad" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">1.REST APIs</h2><p id="e66e" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">在构建React应用程序时，你会经常用到REST API，REST代表'<strong class="ma ir">具象状态转移【T11'，这是开发人员在创建API时遵循的一套规则。其中一条规则规定，当我们链接到一个特定的URL时，我们应该能够获得一段数据。</strong></p><h2 id="2b06" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">2.GraphQL</h2><p id="ee37" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">由脸书在2012年开发，因为该团队需要一个足够强大的数据获取API来描述整个脸书。<strong class="ma ir"> GraphQL </strong>已被证明对于构建现代移动和网络应用间接有效，为开发人员提供了灵活丰富的数据提取技术。</p><p id="8949" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">它甚至可以部署在一个名为<strong class="ma ir"> <em class="mr"> GraphiQL </em> </strong>的IDE中。作为REST的替代方案，GraphiQL允许开发人员构造一个请求，在一个<strong class="ma ir"> API </strong>调用中从多个数据源提取数据。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="c3e8" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">6.后端开发</h1><h2 id="c768" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">节点. js</h2><p id="bd0d" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">React应用程序的后端有很多选择，但是由于使用<strong class="ma ir"> Node.js </strong>已经成为React开发人员的第二天性，建议学习<strong class="ma ir"> Node.js </strong>。它是托管和运行React应用程序的web服务器的最方便的平台。</p><ul class=""><li id="bac1" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated">使用NPM <strong class="ma ir">(节点包管理器)</strong>，节点与NPM注册中心一起工作，通过NPM CLI安装任何包。</li><li id="62db" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">另外，<strong class="ma ir"> Node </strong>将一个React应用程序捆绑到一个文件中，以便使用webpack和其他几个节点模块进行编译。</li><li id="bbcc" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">开发者可以直接在Node.js环境中执行<strong class="ma ir"> React.js </strong>代码。</li><li id="5190" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir"> React DOM </strong>具有专门设计用于Node.js的组件，减少了代码行，使得服务器端呈现相对容易</li></ul><h2 id="9b78" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">为什么React和Node.js是一个完美的组合:</h2><ul class=""><li id="2046" class="nd ne iq ma b mb mc me mf lo og lr oh lu oi mq oj nj nk nl bi translated"><strong class="ma ir">高服务器负载:</strong>当您的web应用程序需要处理多个请求和绘制服务器负载平衡时，使用Node.js和React是有意义的。</li><li id="e538" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">JSON API:</strong>用Node.js为你的应用构建<strong class="ma ir">JSON API</strong>是非常高效的，因为React.js中的代码重用性高，代码共享简单</li><li id="d1b8" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir"> MERN栈:</strong> Node.js也可以和React with MERN (MongoDB，Express，React &amp; Node)栈一起使用。</li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="1e4d" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">8.内容管理系统</h1><h2 id="3f92" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">网络CMS</h2><p id="c984" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">为您的<strong class="ma ir"> Git </strong>工作流提供一个伟大的开源内容管理系统，为您提供一个非常友好的<strong class="ma ir"> UI </strong>和直观的工作流。您可以将它与任何静态站点生成器一起使用，以便更快、更灵活地创建文件夹和web项目。</p><ul class=""><li id="ba7c" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">快速&amp;基于Web的UI: </strong>在实时预览和拖放媒体中提供富文本编辑。</li><li id="005c" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">完全可扩展:</strong>你可以创建定制风格的预览、UI小部件和编辑器插件。</li><li id="dc8b" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">安装简单:</strong>你只需要在你的网站上添加两个文件，并通过将这些文件包含在你的构建过程中或者链接到我们的<strong class="ma ir"> <em class="mr"> CDN(内容交付网络)来连接后端。</em> </strong></li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="e7a2" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">8.福米克</h1><p id="7a04" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">在React应用程序中创建表单对你来说是一件痛苦的事情，不使用Formik，你仍然可以用React中的状态管理创建你自己的表单，但是当你不得不在表单中添加更多的特性<strong class="ma ir">(验证)</strong>，并且在React应用程序中创建多个表单变得非常困难的时候，这就变成了一个非常痛苦的过程。但是使用formik，您可以轻松地创建各种具有非常灵活选项的表单。</p><ul class=""><li id="acd3" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated">Formik 负责处理重复和烦人的事情，并跟踪表单字段中的<strong class="ma ir">值和</strong>错误。因此，您将花费更少的时间编写状态和变更处理程序，并将更多的时间集中在项目上。</li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="6f7f" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">10.服务器端渲染</h1><h2 id="b12d" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">Next.js</h2><p id="2372" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">这是一个非常棒的创建web应用程序的工具，最著名的是服务器端渲染，你也可以为不同的平台创建强大的web应用程序。</p><p id="dda6" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">如果你已经熟悉CSS、JavaScript和一点React，切换到Next.js对你来说会很容易。</p><ul class=""><li id="5ccc" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">生态系统兼容性:</strong>兼容JavaScript、Node、React。</li><li id="e4b2" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">自动代码分割:</strong>代码中的每个导入都被捆绑在一起，并与每个页面一起提供，这意味着所有不必要的代码都不会加载到页面上。</li><li id="49ec" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir"> Styled-JSX: </strong>允许你直接在JS代码里面写CSS。</li></ul><h2 id="c42b" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">狂欢</h2><p id="0259" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">SSR <strong class="ma ir">(服务器端渲染)</strong>的另一个很好的替代工具，将SSR所需的所有复杂配置抽象为一个依赖项，为我们提供了<strong class="ma ir"> <em class="mr"> create-react-app </em> </strong>的最佳体验，并将所有关于框架、路由和数据获取的应用架构决策留给了我们。它不仅适用于React，还适用于Reason、Elm、Vue和Angular。</p><ul class=""><li id="34ed" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">熟悉度:</strong>了解ES6 JavaScript将永远是一个优势，与create-react-app相同的CSS设置使其非常容易工作。</li><li id="7deb" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">热重装:</strong> Razzel提供了热模块重装，这样无论何时我们做任何改变，客户端和服务器都会更新。</li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="9157" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">14.按指定路线发送</h1><h2 id="6eaa" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">反应路由器</h2><p id="30ce" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated"><em class="mr">路由是保持浏览器URL与页面上呈现的内容同步的过程。React路由器以声明方式处理路由，这允许我们控制应用程序中的数据流。</em></p><p id="31cb" class="pw-post-body-paragraph ly lz iq ma b mb ms jr md me mt ju mg lo mu mi mj lr mv ml mm lu mw mo mp mq ij bi translated">React-路由器的一些主要组件:</p><ul class=""><li id="8a90" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir"> BrowserRouter: </strong>一个路由器实现，它使用HTML历史API ( <strong class="ma ir"> pushState、replaceState和popState </strong>事件)来保持UI与URL同步。</li><li id="d36a" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir"> Route: </strong>当其路径与当前URL匹配时，有条件地显示呈现一些UI的组件。</li><li id="7e3f" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">Link:</strong>Link组件用于创建不同路线的链接，并实现应用程序周围的导航(工作方式类似于<strong class="ma ir"> <em class="mr"> HTML锚标签</em> </strong>)。</li><li id="4d7e" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">开关:</strong>用于只渲染与位置匹配的第一条路线，而不是渲染所有匹配的路线。</li></ul><h1 id="e24c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">16.测试</h1><h2 id="d87d" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">玩笑</h2><p id="4e82" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">一个由脸书开发的JavaScript测试框架，当我们向代码单元提供输入并将输出与预期输出匹配时，它主要用于单元测试。</p><blockquote class="ou ov ow"><p id="c60f" class="ly lz mr ma b mb ms jr md me mt ju mg ox mu mi mj oy mv ml mm oz mw mo mp mq ij bi translated"><strong class="ma ir">笑话特色:</strong></p></blockquote><ul class=""><li id="57b3" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">零配置:</strong>开始编写测试并部署它们需要一个接近于零的配置，然而，也可以向测试提供一个配置文件。</li><li id="8918" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">快照:</strong>当快照与保存的快照匹配时，它还能够启用快照测试，并检查匹配功能。</li><li id="ea52" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated">此外，Jest并行运行以提高运行时间</li></ul><h2 id="f058" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">酶</h2><p id="f9a2" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">Enzyme服务于不同的目的，而不仅仅是一个测试库，它使测试React组件更容易，并与任何完整的测试库集成，包括<strong class="ma ir"> Jest </strong>。如果你使用React来制作web应用，那么结合使用Enzyme和Jest来自动测试UI是非常有意义的。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="7adc" class="kr ks iq bd kt ku ob kw kx ky oc la lb jw od jx ld jz oe ka lf kc of kd lh li bi translated">18.部署</h1><h2 id="8908" class="lj ks iq bd kt lk ll dn kx lm ln dp lb lo lp lq ld lr ls lt lf lu lv lw lh lx bi translated">网络生活</h2><p id="b809" class="pw-post-body-paragraph ly lz iq ma b mb mc jr md me mf ju mg lo mh mi mj lr mk ml mm lu mn mo mp mq ij bi translated">其中一个最好的网络开发平台是众所周知的，以最佳方式倍增你的生产力。通过将现代web解耦的web元素从本地开发过程统一到高级逻辑，它提供了一种令人惊叹的方式来确保更高性能、可伸缩、安全的网站和应用程序。</p><ul class=""><li id="8f68" class="nd ne iq ma b mb ms me mt lo nf lr ng lu nh mq oj nj nk nl bi translated"><strong class="ma ir">无服务器功能:</strong>当我们构建静态网站并且不想处理后端服务时，我们可以使用第三方<strong class="ma ir"> BaaS </strong>解决方案，使用<strong class="ma ir"> Netlify </strong>时，我们不必担心创建后端，因为它允许为后端解决方案集成无服务器功能。</li><li id="ce64" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">表单:</strong>当我们需要从用户那里获取信息时，创建表单是最简单的方法。</li><li id="b1bb" class="nd ne iq ma b mb nm me nn lo no lr np lu nq mq oj nj nk nl bi translated"><strong class="ma ir">对比测试:</strong>它帮助我们部署两个不同的网站版本，以便我们能够以更有效的方式跟踪哪个对业务更好。</li></ul></div></div>    
</body>
</html>