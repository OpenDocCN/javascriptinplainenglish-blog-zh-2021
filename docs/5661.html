<html>
<head>
<title>6 Ways To Drastically Boost Your Productivity As A Node.js developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为Node.js开发人员，大幅提高工作效率的6种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/six-ways-to-drastically-boost-your-productivity-as-a-node-developer-b43387cc5e46?source=collection_archive---------2-----------------------#2021-11-27">https://javascript.plainenglish.io/six-ways-to-drastically-boost-your-productivity-as-a-node-developer-b43387cc5e46?source=collection_archive---------2-----------------------#2021-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1ccc39a990779f6a6aac6792f6ba877f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDtNu2n9L1-XM7hxVGhOpQ.png"/></div></div></figure><h2 id="275c" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h2><p id="1cbb" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">作为Node.js开发人员，这六个生产率技巧将大大提高您的生产率。你可以节省几个小时的时间，然后投资于其他活动。</p><p id="b2b4" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这并不是你应该做的所有事情的完整列表，但是如果你还没有做这些事情的话，这些事情会极大地提高你的工作效率。</p><h2 id="c5e1" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用模糊查找器</h2><p id="f4ce" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们中的许多人仍然在使用大型的单片代码库，有时有数千个文件。</p><p id="a249" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">你应该如何在你的项目中的数千个<code class="fe lr ls lt lu b">.js</code>文件和数百个文件夹中找到隐藏在<code class="fe lr ls lt lu b">/src/authentication/userTypes/employee.js</code>中的<code class="fe lr ls lt lu b">employee.js</code>？手动通过目录树查找文件？再问一个更熟悉代码库的开发者？</p><p id="b58e" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">不，只要使用模糊查找器并输入<code class="fe lr ls lt lu b">employee.js</code>，你将在几秒钟内找到你的文件。</p><p id="0dab" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">它是这样工作的。在VS代码中，按下<code class="fe lr ls lt lu b">Alt+P</code>，然后输入你要找的文件名。结果会立即出现。</p><p id="c98a" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><em class="lv">VS代码中的模糊查找器:</em></p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/2ccc67fed9b326939c6f30d257669519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v23Ta9H36h6fCrWI.png"/></div></div></figure><p id="1675" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果你用的是IntelliJ或者WebStorm，快速按两次<code class="fe lr ls lt lu b">shift</code>(又名双shift)而不是按<code class="fe lr ls lt lu b">Alt+P</code>。</p><h2 id="79a1" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用真正的调试器而不是<code class="fe lr ls lt lu b">console.log()</code></h2><p id="92be" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">当我还是一名中级工程师的时候，学习如何使用调试器本身就大大提高了我的工作效率。我可以在几个小时内完成可能需要一天才能完成的工作。修复bug和增加功能要容易得多。</p><p id="6ed8" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我发现在探索不是我写的不熟悉的代码库时，调试特别有用。你可以很容易地看到用奇怪的方式编写的最复杂的逻辑的结果。当您可以一行一行地运行它并观察事情如何变化时，推理出复杂、令人费解的逻辑会容易得多。</p><p id="3cf9" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果你曾经使用过<code class="fe lr ls lt lu b">console.log()</code>来打印一个值到控制台，你可能知道如果你试图调试一些复杂的东西，它会变得多么乏味。它一次打印一个值，你需要为你想看到的每个值写一个新的<code class="fe lr ls lt lu b">console.log()</code>语句。如果您正在查看的值发生变化，您需要再次<code class="fe lr ls lt lu b">console.log()</code>它。有点像蒙着眼睛或者在黑暗中瞎逛。</p><p id="e501" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">人类的工作记忆是有限的，所以一旦你手动打印了足够多的变量，这些值将开始从你的脑海中消失，然后你必须再次打印它们或把它们写在某个地方。试图把它们都保存在工作记忆中需要宝贵的大脑资源，你可以把这些资源重新导向让你的代码按照你想要的方式工作。</p><p id="523b" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">进入调试器—在代码中设置断点，然后运行应用程序。当您的应用程序到达您设置断点的那一行时，您将能够在debug选项卡中看到范围内的所有变量。</p><p id="6cba" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">没有必要在你的工作记忆中处理大量的数值。只需一个操作，您现在就可以看到所有内容，而不是一次只看到一个值。</p><p id="5edc" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我开始只是调试我自己的应用程序代码，但随着时间的推移，我变得更资深，我发现我可以通过调试框架代码(如<code class="fe lr ls lt lu b">express</code>的代码)获得很大的洞察力。我能够找到文档中没有列出的问题的答案。</p><p id="73b5" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果你想学习如何设置你的调试器，请看我的另一篇文章<a class="ae mb" href="https://dev.to/ciphercode/debug-a-nodejs-express-app-with-vscode-2bh2" rel="noopener ugc nofollow" target="_blank">通过调试提高你的节点生产力</a>。</p><h2 id="b5d1" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用<code class="fe lr ls lt lu b">async/await</code>并避免“回调地狱”</h2><p id="d409" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">考虑以下有和没有<code class="fe lr ls lt lu b">async/await</code>的例子。</p><p id="ad6f" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">不带<code class="fe lr ls lt lu b">async/await</code>:</p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="c82f" class="jv jw in lu b gy mg mh l mi mj">function addFavoriteProduct(favoriteProduct) {<br/>	const user = userRepository.get(userId).then((user) =&gt; {<br/>		const userProfile = profileRepository.get(user.profileId).then((userProfile)) =&gt; {<br/>			const favoriteProducts = productsRepository.getFavoriteProducts(userProfile.favoriteProductsId).then((favoriteProducts) =&gt; {<br/>				favoriteProducts.add(favoriteProduct);<br/>			}).catch((error) =&gt; {<br/>				// Handle error<br/>			})<br/>		}).catch((error) =&gt; {<br/>			//Handle error<br/>		});<br/>	}).catch((error) =&gt; {<br/>		// Handle error<br/>	});<br/>}</span></pre><p id="1add" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这就是“回调地狱”的例子。它包含许多嵌套操作，很难维护。如果你有更多的嵌套操作，你将走向<a class="ae mb" href="https://www.dottedsquirrel.com/pyramid-of-doom-javascript/" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>反模式。</p><p id="3255" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果有我没有注意到的错误，我不会感到惊讶，因为代码比它需要的要复杂得多！。我甚至不想让它工作，因为有更好的方法。</p><p id="9148" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">直到最近，这一直是Node.js中执行这类操作的标准方式。正因为如此，网上很多比较老的例子和教程还是教这种风格的，所以在Stackoverflow这样的地方，要小心你在网上读到的东西。如果你看到这种风格的代码，你应该意识到它不再是最佳实践。在别处找一个不同的例子，或者尝试重构它，使之更好，如下例所示。</p><p id="e3ed" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">同<code class="fe lr ls lt lu b">async/await</code>:</p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="6cd8" class="jv jw in lu b gy mg mh l mi mj">async function addFavoriteProduct(favoriteProduct) {<br/>	try {<br/>		const user = await userProfile.get(userId);<br/>		const userProfile = await profileRepository.get(user.profileId);<br/>		const favoriteProducts = await  productsRepository.getFavoriteProducts(userProfile.favoriteProductsId);<br/>		await favoriteProducts.add(favoriteProduct);<br/>	} catch (error) {<br/>		// Handle error<br/>	}<br/>}</span></pre><p id="150a" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">正如您所看到的，这个例子更加清晰易懂。它不太可能隐藏错误，因为它更简单。</p><p id="9645" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">要使用<code class="fe lr ls lt lu b">async/await</code>，你需要在Node 8或更高版本上，所以Node的最新版本将支持它。你需要在一个<code class="fe lr ls lt lu b">async function</code>里面使用它。通过添加<code class="fe lr ls lt lu b">async</code>来声明一个，例如<code class="fe lr ls lt lu b">async function get()</code>。</p><h2 id="a3ed" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">通过公共网址尽早分享您的作品</h2><p id="60ea" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">您知道吗，您可以从本地机器上的<code class="fe lr ls lt lu b">localhost</code>或<code class="fe lr ls lt lu b">127.0.0.1</code>获取节点应用程序的公共URL，即使它位于防火墙或公司网络之后。它不需要任何网络配置，你可以用<code class="fe lr ls lt lu b">expose</code>在一个命令中完成，例如<code class="fe lr ls lt lu b">expose 80 as myapi.expose.sh</code>。</p><p id="2fc2" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这使您能够尽早与合作者(如其他工程师、客户或产品经理)分享您的工作，并获得快速反馈，而无需建立完整的部署渠道。</p><p id="f242" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">您可以编写一个后端API，共享一个公共URL，然后在与您合作的React前端开发人员从他们的应用程序向您的API发送请求时进行实时调试。</p><p id="a086" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">为什么不在webhook提供商向您发送webhook请求时进行实时调试，而不是花几个小时阅读他们的(通常不是很好的)文档？</p><p id="334f" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果你在Linux上，运行这个来安装<code class="fe lr ls lt lu b">expose</code></p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="e44b" class="jv jw in lu b gy mg mh l mi mj">curl -s https://expose.sh/sh/install-linux.sh | sudo bash`</span></pre><p id="74fe" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果您使用的是Mac，运行</p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="470e" class="jv jw in lu b gy mg mh l mi mj">curl -s https://expose.sh/sh/install-mac.sh --output install-mac.sh &amp;&amp; sudo bash install-mac.sh`</span></pre><p id="20ca" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">对于Windows，请转到<a class="ae mb" href="https://expose.sh/install/" rel="noopener ugc nofollow" target="_blank">安装页面</a>并下载<code class="fe lr ls lt lu b">exe</code>文件。</p><p id="077c" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">然后你可以运行<code class="fe lr ls lt lu b">expose &lt;port&gt;</code>，其中<code class="fe lr ls lt lu b">&lt;port&gt;</code>是你的应用程序运行的端口号。更多说明见<a class="ae mb" href="https://expose.sh/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="b811" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用<code class="fe lr ls lt lu b">npm</code>脚本来自动化重复性任务</h2><p id="cd4d" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">需要编译您的JavaScript、运行linter或您的单元测试吗？您可以将NPM脚本添加到您的<code class="fe lr ls lt lu b">package.json</code>文件中来运行它们，而不是记住运行它们的命令。</p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="f98f" class="jv jw in lu b gy mg mh l mi mj">"name": "myapp",<br/>  "main": "app.js",<br/>  "scripts": {<br/>    "build": "tsc -p ./",<br/>    "watch": "tsc -p ./ -w",<br/>	"test": "jest",<br/>	"lint": "eslint",<br/>	"start": "nodemon app.js"<br/>  },<br/>  "dependencies": {<br/>	.....<br/>  }<br/>}</span></pre><p id="578e" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">此示例使用TypeScript，它是增加类型安全的JavaScript的超集。我运行我的应用程序，首先需要将我的代码编译成节点可以运行的普通JavaScript。</p><p id="73ae" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">要运行该脚本，请运行<code class="fe lr ls lt lu b">npm run &lt;script_name&gt;</code>。在这里，我可以运行<code class="fe lr ls lt lu b">npm run build</code>来编译我的代码，运行<code class="fe lr ls lt lu b">npm run watch</code>来在监视模式下编译，为每次更改自动重新编译。</p><p id="01c1" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><code class="fe lr ls lt lu b">test</code>和<code class="fe lr ls lt lu b">start</code>是特殊的脚本，你可以像<code class="fe lr ls lt lu b">npm test</code>和<code class="fe lr ls lt lu b">npm start</code>一样运行它们。</p><h2 id="2b5f" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用<code class="fe lr ls lt lu b">nodemon</code>启动你的应用程序，获得快速反馈</h2><p id="f092" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">如果您在使用Node(例如<code class="fe lr ls lt lu b">node app.js</code>)启动应用程序后对代码进行了更改，您需要按<code class="fe lr ls lt lu b">ctrl+c</code>停止应用程序，然后再次启动应用程序以获得新的更改。虽然这听起来不多，而且只需要几秒钟的时间，但随着时间的推移重复这样做将会积少成多。假设你花了5秒钟，平均一周做1000次。这相当于5000秒，或者说你每周不需要做的额外1.3小时的工作。</p><p id="bbff" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">与<code class="fe lr ls lt lu b">nodemon</code>的不同之处在于，当你更新代码时，你的应用程序会自动重启。</p><p id="c7f8" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">在你使用<code class="fe lr ls lt lu b">nodemon</code>之前，你需要安装它，所以运行<code class="fe lr ls lt lu b">npm install -g nodemon</code>。</p><p id="876b" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">用<code class="fe lr ls lt lu b">nodemon</code>启动你的app几乎和用Node一样。把<code class="fe lr ls lt lu b">node</code>换成<code class="fe lr ls lt lu b">nodemon</code>就行了，比如你可能会运行<code class="fe lr ls lt lu b">nodemon app.js</code>而不是<code class="fe lr ls lt lu b">node app.js</code>。</p><p id="a100" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">它看起来是这样的:</p><pre class="lx ly lz ma gt mc lu md me aw mf bi"><span id="59b6" class="jv jw in lu b gy mg mh l mi mj">$ nodemon app.js<br/>[nodemon] 1.18.9<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching: *.*<br/>[nodemon] starting `node app.js`<br/>Example app listening at http://localhost:3000 # My app has started up</span><span id="d47a" class="jv jw in lu b gy mk mh l mi mj">#####<br/># Here, I make a change to app.js<br/>#####</span><span id="aa56" class="jv jw in lu b gy mk mh l mi mj">[nodemon] restarting due to changes...<br/>[nodemon] starting `node app.js`<br/>Example app listening at http://localhost:3000 # Now, my app automatically restarts and picks up the change</span></pre><p id="b7e4" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">现在，当我做出更改时，应用程序会自动重启，为我节省了大量时间，我可以将这些时间投入到其他事情中。</p><p id="0937" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><em class="lv">专业提示:将此与一个</em> <code class="fe lr ls lt lu b"><em class="lv">start</em></code> <em class="lv"> npm脚本结合起来，就像上一节</em>中的例子一样。</p><h2 id="0ba9" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h2><p id="ba80" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">这并不是一个完整的列表，列出了作为节点开发人员可以做的提高生产力的事情，但是这是一个很好的起点。</p><p id="0f6d" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这些简单的事情可以为你节省很多不必要的工作时间。</p><p id="4174" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果你觉得这篇文章有用，请考虑分享给其他人。</p><p id="cde6" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">编码快乐！</p><p id="bb30" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><em class="lv">更多内容看</em> <a class="ae mb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="lv">说白了就是</em> </strong> </a> <strong class="kt io"> <em class="lv">。</em> </strong> <em class="lv">报名参加我们的</em> <a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="lv">免费每周简讯这里</em> </strong> </a> <strong class="kt io"> <em class="lv">。</em> </strong></p></div></div>    
</body>
</html>