<html>
<head>
<title>Why does React State Need a New Object/Array?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么反应状态需要新的对象/阵列？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-does-react-state-need-a-new-object-array-bbcb765f7927?source=collection_archive---------17-----------------------#2021-05-25">https://javascript.plainenglish.io/why-does-react-state-need-a-new-object-array-bbcb765f7927?source=collection_archive---------17-----------------------#2021-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5fa20f559c05a7cdb9c232eb28793f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H-SduIyEF5lp4BQz.png"/></div></div></figure><p id="2800" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您已经使用“反应”有一段时间了，那么您应该熟悉状态更新是如何工作的。有很多内部优化，React可以加快渲染速度。反应内部的实现细节之一是，它检查给定的状态对象是否已经实际改变。但是分配一个新的对象/数组的行为会让新来的人大吃一惊。让我们理解为什么在分配状态时，React需要一个新的对象/数组副本。</p><h1 id="1a81" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">JavaScript中的Object.is()</h1><p id="96d4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><code class="fe lw lx ly lz b">Object.is()</code>是JavaScript中的比较运算符。它被附加到Object.prototype，可以用来比较JavaScript值，包括对象值和原始值。</p><p id="b811" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于对象:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="7f92" class="mi ku in lz b gy mj mk l ml mm">const author1 = {name: "Saransh Kataria"};<br/>const author2 = {name: "Saransh Kataria"};<br/>Object.is(author1, author2); // false</span></pre><p id="22d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于对象是通过引用存储的，因此比较返回false。</p><h1 id="1b20" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">就反应而言，这种相关性如何？</h1><p id="892c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用Object.is()进行上一个和下一个状态的比较，以确定是否更新DOM。该案件的相关部分是:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="848c" class="mi ku in lz b gy mj mk l ml mm">const author1 = {name: "Saransh Kataria"};<br/>author1.name = "Wisdom Geek";<br/>Object.is(author1, author1); // true</span></pre><p id="6940" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们正在改变同一个对象及其属性，所以比较将始终返回真。</p><p id="124c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我们这样做时:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="36a1" class="mi ku in lz b gy mj mk l ml mm">const [author, setAuthor] = useState({name:"Saransh Kataria")};</span><span id="94c8" class="mi ku in lz b gy mn mk l ml mm">const updateName = () =&gt; {<br/>  author.name = "Wisdom Geek";<br/>  setAuthor(author)<br/>}</span></pre><p id="468c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在update name函数中，我们正在更新作者对象。并将更新后的对象发送给setAuthor。这不会更新用户界面，即使我们已经更新了作者对象。</p><h1 id="d526" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么用户界面没有更新？</h1><p id="45d9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如我们之前看到的，改变一个对象的属性并不会改变该对象的引用。当我们调用setter函数时，React在引擎盖下使用Object.is()来确定状态是否被更新。</p><p id="3af2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为对象引用没有改变，所以Object.is()返回false，即使我们确实更新了它的某些属性。因此，React感觉不到更新用户界面的需要，因为根据它没有任何改变。</p><p id="904b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让它正确工作，我们需要传入一个对useState函数的新引用。为此，我们需要创建一个新的对象。一旦我们这样做，Object.is()将返回true，因为引用将不会相同，我们将触发重新渲染。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="53a7" class="mi ku in lz b gy mj mk l ml mm">const updateName = () =&gt; {<br/>  setAuthor(prevState =&gt; {...prevState, name: "Wisdom Geek"});<br/>}</span></pre><p id="4a38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这使用扩展语法和回调函数来更新状态。我们返回一个新的对象，它没有任何从初始对象直接引用的属性。我们也更新了我们想更新的属性。</p><p id="6f3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的逻辑也适用于数组，因为它们也是引用类型。</p><h1 id="a380" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="4155" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">希望这个解释能稍微揭开reactor内部的神秘面纱，并对reactor中状态管理的实现细节有更好的了解。如果您有任何问题，请在下面留言！</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="ee32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">原载于2021年5月25日</em><a class="ae mw" href="https://www.wisdomgeek.com/development/web-development/react/why-does-react-state-need-new-object-array/" rel="noopener ugc nofollow" target="_blank"><em class="mv">【https://www.wisdomgeek.com】</em></a>。</p><p id="3c18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">更多内容尽在</em><a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mv">plain English . io</em></a></p></div></div>    
</body>
</html>