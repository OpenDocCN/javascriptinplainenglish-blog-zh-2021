<html>
<head>
<title>Two dimensional timeline — A way to think about asynchronous JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二维时间轴——思考异步JavaScript的一种方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/two-dimensional-timeline-a-way-to-think-about-asynchronous-javascript-bb5e8d4ffd2e?source=collection_archive---------14-----------------------#2021-01-08">https://javascript.plainenglish.io/two-dimensional-timeline-a-way-to-think-about-asynchronous-javascript-bb5e8d4ffd2e?source=collection_archive---------14-----------------------#2021-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a307" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">可视化异步操作的执行顺序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9cf206b7fb3a4b882c5277ea9be06715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSorDKCzWHHD5zMkmsdjrw.png"/></div></div></figure><p id="9b55" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我记得当我第一次从事JavaScript工作时，我发现很难理解如何正确处理异步操作。我犯了一些常见的错误，比如假设AJAX是同步的，这导致我的函数总是返回<code class="fe lk ll lm ln b">undefined</code>。也很难习惯setTimeout的工作方式。它不阻塞代码的事实让我很沮丧。</p><p id="52e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我花了很长时间才习惯回调、承诺和异步/等待的工作方式。我发现一个有用的方法是在二维时间线中可视化执行的顺序。</p><h2 id="dac0" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated"><strong class="ak">同步世界</strong></h2><p id="f929" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">在Python中，我可以使用<code class="fe lk ll lm ln b">time.sleep</code>来暂停执行。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/fcc9f645a199eacc8f65540bd2c4df74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ove_rg4RlfbW0dIDynIk6A.gif"/></div></div></figure><p id="ec1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我想使用函数<code class="fe lk ll lm ln b">setTimeout</code>在JavaScript中暂停执行2秒钟。让我把<code class="fe lk ll lm ln b">print</code>换成<code class="fe lk ll lm ln b">console.log</code>，把<code class="fe lk ll lm ln b">time.sleep</code>换成<code class="fe lk ll lm ln b">setTimeout</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b24f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回调里面的所有东西都在2秒后执行，太好了。但是等等，为什么<code class="fe lk ll lm ln b">console.log(‘End’)</code>会在<code class="fe lk ll lm ln b">console.log(‘Timeout’)</code>之前运行？我假设代码应该逐行执行。第三行不应该在第二行的所有内容执行之前执行，包括回调函数。在JavaScript中，我的假设大错特错。</p><p id="6df0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript执行非阻塞I/O操作，<code class="fe lk ll lm ln b">setTimeout</code>也是非阻塞的。第二行不阻止执行。设置2秒钟计时器后，它继续运行并执行第3行。当2秒计时器结束时，将执行<code class="fe lk ll lm ln b">console.log(‘Timeout’)</code>。</p><p id="ac87" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是<code class="fe lk ll lm ln b">setTimeout</code>的工作方式。但我想实现的是在等待2秒的同时阻塞执行，就像我在Python代码中做的那样。应该有另一个简单的API来实现。在网上找了半天，也找不到这样的API。相反，我找到了一些解决办法来实现它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/d58e6dcd85a31423b0ffac5c5ab1fd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*m7SiwlCVKxPXGGNAnwVqCQ.gif"/></div></div></figure><p id="4b64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我运行代码，看看它是否能阻止执行。是的，它可以阻止执行。在“结束”之前，我可以看到控制台中记录了“超时”。它的行为类似于Python中的<code class="fe lk ll lm ln b">time.sleep</code>。但是当我花一点时间思考代码做什么的时候，它不能阻止执行。蓝色的小圆圈没有停止，而是继续在循环中运行。我就是停不下来。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="d510" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">异步世界</h2><p id="6b90" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">JavaScript在浏览器和NodeJS中是单线程的。我挡不住。更重要的是，我不应该屏蔽。</p><p id="4674" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在浏览器中阻塞线程会导致用户界面冻结，因为它正在循环中忙碌地运行。当用户单击一个按钮时，click事件被排队。然而，在满足循环条件之前，线程就是不能从循环中退出。在此之前，它不能处理click事件的回调。因为JavaScript是单线程的，所以没有其他线程来处理click事件。如果NodeJS中的线程被阻塞，情况可能会更糟。当线程被阻塞时，服务器将无法处理后续请求。</p><p id="90ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">经过长时间的斗争，我不得不接受非封锁行为。我不得不接受第二行的回调可能发生在第三行执行之后，这对我来说是不直观的。这让我思考我应该如何以一种无阻碍的方式来观想时间。我想出了这个图表。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/1bd413260bfeec7d43aad8d3f928b09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vDMnWidShSh7qujK2U6wrA.gif"/></div></div></figure><p id="d1fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">蓝色圆圈仍然会逐行执行代码。但是故事并没有结束。执行setTimeout后，异步操作将被设置为挂起状态。当计时器结束时，回调将在另一个时间线中执行。</p><p id="46f3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如前所述，当我开始用JavaScript编码时，我犯的一个错误是从一个函数返回<code class="fe lk ll lm ln b">undefined</code>,这个函数涉及异步操作，比如从AJAX检索数据、从文件系统读取文件和查询数据库。我相信我不是唯一一个在这个问题上挣扎的人，因为还有一些相关的问题，如<a class="ae mw" href="https://stackoverflow.com/questions/10058814/get-data-from-fs-readfile" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae mw" href="https://stackoverflow.com/questions/33657338/json-ajax-returns-undefined" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae mw" href="https://stackoverflow.com/questions/30428009/mongodb-find-returns-undefined-node-js" rel="noopener ugc nofollow" target="_blank">这个</a>贴在堆栈溢出上。我重新思考二维时间线中的这种错误。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/b2ec543699bae4b300e8ae974a767805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l7tLJ2-SFNgbF407EXm1ag.gif"/></div></div></figure><p id="424e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当从文件系统中读取文件时，数据不是立即可用的，这导致<code class="fe lk ll lm ln b">undefined</code>记录在第一个时间线上。当数据可用时，回调中的代码将在第二个时间线上执行，文件数据可以记录在控制台上。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="6360" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">按顺序运行异步操作</h2><p id="e107" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">有时，我需要根据另一个异步操作的结果执行一个异步操作。例如，虚拟辅助应用可能想要以音频格式的语音消息来响应，而不是以文本消息来响应“你好，汤姆”。这就需要从数据库中查询用户名，然后用这个查询结果调用云服务提供的一个文本到语音的API。</p><p id="2d4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，第二个异步操作需要嵌套在第一个异步操作的回调中。这种深度嵌套的代码降低了代码的可读性。如果异步操作API支持ES6 promise，那么可以用async-await格式编写代码，这种格式看起来是同步的，更容易阅读。但是在幕后，它仍然是一个异步操作，所以二维时间线应该与回调风格的代码相同。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/6afb5b953700a9c628dc53a3faf21e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EF4SiagiWZrknPkSUzPCNw.gif"/></div></div></figure></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h2 id="8119" class="lo lp in bd lq lr ls dn lt lu lv dp lw kx lx ly lz lb ma mb mc lf md me mf mg bi translated">并发运行异步操作</h2><p id="4805" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">上面显示的语音消息示例是一个异步操作依赖于另一个操作的回调结果的示例。在将文本消息转换为语音消息之前，我们需要知道用户名。</p><p id="3ffb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与语音消息示例不同，有时异步操作是独立的。每个异步操作都不依赖于其他操作的回调结果。例如，我们想调用一个web服务，编写一个文件，并向数据库中插入一条记录。一种方法是按顺序一个接一个地执行异步。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/a3a4ab837cee6a96a1e7e7d772815db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gZIkiz5FQerZF1YgDLZX8A.gif"/></div></div></figure><p id="fbbc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们按顺序执行代码，整个执行时间大约是每个操作执行时间的总和。因为本例中的所有操作都是独立的，所以它们可以并发执行，这可以大大减少整个执行时间。</p><p id="646b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这次操作不是等待每个操作，而是立即一个接一个地运行，并将所有承诺传递给<code class="fe lk ll lm ln b">Promise.all</code>，它可以一次等待多个承诺。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/b95dd2696e72184707caf546d2a673c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6Xutr6hQnGNeY2pVMYp5Pg.gif"/></div></div></figure><p id="e3a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">多亏了我曾经认为不直观的非阻塞I/O特性，JavaScript可以在几行代码中同时运行多个异步操作，而无需处理多线程编程。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="b0c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢你阅读这篇文章。如果你觉得很难理解异步操作的执行顺序，我希望二维时间线可以帮助你。</p></div></div>    
</body>
</html>