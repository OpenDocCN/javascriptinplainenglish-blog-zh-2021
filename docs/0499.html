<html>
<head>
<title>Mastering The Git Command Line</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Git命令行</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mastering-the-git-command-line-b2c6efe4f4ad?source=collection_archive---------7-----------------------#2021-01-30">https://javascript.plainenglish.io/mastering-the-git-command-line-b2c6efe4f4ad?source=collection_archive---------7-----------------------#2021-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="03e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">像专家一样使用Git版本控制系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0314bf1716d992788aeb52d1b83b236c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ysk5oDu8RJNhqT4f0WT2rw.png"/></div></div></figure><h2 id="af83" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">正在配置Git</h2><p id="e36c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在系统上正确使用Git需要一组配置步骤，以使进一步的工作流高效快速。我们第一次在机器上安装<strong class="lp ir"> Git </strong>时，我们必须指定这4种配置:</p><ul class=""><li id="3fb4" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated"><strong class="lp ir">姓名&amp;电子邮件:</strong>每次我们在git存储库中提交更改时，我们的姓名和电子邮件都会被存储起来。</li><li id="586d" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated"><strong class="lp ir">我们的默认编辑器:</strong>设置默认编辑器非常重要，因为如果你在mac上工作，你的默认编辑器应该是<strong class="lp ir"> Vim </strong>，只有在你熟悉它的环境时才应该使用它。</li><li id="e9f8" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated"><strong class="lp ir">行尾:</strong>有些情况下，当我们协同工作时，由于不同的操作系统，我们必须定义<em class="mw">行尾</em>，这样当我们提交我们的更改时，就不会出现复杂的错误。<em class="mw">例如，在</em> <strong class="lp ir"> <em class="mw">窗口上</em> </strong> <em class="mw">行尾标有</em> <strong class="lp ir"> <em class="mw">回车</em> </strong> <em class="mw">和</em> <strong class="lp ir"> <em class="mw">换行符(\r\n) </em> </strong> <em class="mw">但是在</em> <strong class="lp ir"> <em class="mw">的情况下MAC OS</em><em class="mw">&amp;</em><strong class="lp ir">T39T47】</strong></strong></li></ul><p id="2ebf" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">为了解决这个问题，我们必须配置一个名为<strong class="lp ir"> core.autocrlf </strong>的文件，在这里我们指定行尾。(如果您使用的是Windows，则将此设置为<strong class="lp ir"> true </strong>，如果是macOS，则设置为<strong class="lp ir">输入</strong>)。</p><p id="f200" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">输入以下命令进行配置:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/f040f2e2e1bd531ff6f3b7d6c68d2281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrFrTxA7qfJYLT7BKcaCoA.png"/></div></div></figure><blockquote class="nb nc nd"><p id="55cc" class="ln lo mw lp b lq mi jr ls lt mj ju lv ne mx lx ly nf my ma mb ng mz md me mf ij bi translated"><strong class="lp ir">注意:</strong>在<strong class="lp ir">全局级别</strong>下设置这些配置被认为是最佳实践，如果你是<strong class="lp ir"> Git </strong>的新手，我会建议你坚持使用全局级别。</p></blockquote><h2 id="1a2d" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">初始化Git存储库</h2><p id="c178" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">为了使用Git命令行，我们需要初始化一个存储库&amp;始终确保您位于您想要使用Git的项目的工作根目录中。</p><ul class=""><li id="4be5" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">在项目目录的根目录中输入命令<strong class="lp ir"><em class="mw">‘git init’</em></strong><em class="mw">来初始化一个空的Git库。</em></li></ul><h2 id="f417" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Git工作流</h2><p id="e2b2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">为了能够使用Git命令行，我们应该对Git实际上是如何工作的有一个正确的理解，因为我们有3个概念要看:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/9716dbd6593b575d20e8f1269417cf98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pu7OAghnC5vsspv4wqTa0w.png"/></div></div></figure><ul class=""><li id="fab4" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated"><strong class="lp ir">工作目录:</strong>您处理项目文件的正常目录，仅包含实际文件。</li><li id="0a93" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">Staging Area:Staging Area对许多开发人员来说有点混乱，这也是为什么大多数时候人们发现学习Git很难的原因之一，因为他们对Staging Area没有清晰的理解。我们可以说它是git存储库中的一个隐藏目录，在提交之前所有的更改都保存在这里，所以如果我们的代码中有bug，我们可以检查它，然后提交给Git存储库。用简单的话来说，Staging Area提供了临时保存更改的能力，因为我们仍然需要在以后提交它们。</li><li id="4537" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated"><strong class="lp ir"> Git存储库:</strong>在最终提交之后，所有已经提交的文件都进入Git存储库，在这里我们可以观察到我们所做的更改。</li></ul><p id="706b" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">为了理解临时区域，这里有一个它工作的例子:</p><p id="7123" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">例如，我们的工作目录中有两个文件<strong class="lp ir">(文件1 &amp;文件2) </strong>，我们使用echo命令对这两个文件做了一些更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/4ed4e48b073da784b209e23b00c61651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQvGsPFQztoro4xELYjx0Q.png"/></div></div></figure><p id="89ba" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">现在，如果我们使用下面的Git命令检查状态-<strong class="lp ir">‘Git status’</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/858ca2b9cc5a8ca398278388e894faa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bllicNEd9mrihQWUWiisA.png"/></div></div></figure><p id="308e" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">它只是说还没有提交(因为我们还没有进行任何提交)&amp;未被跟踪的文件用红色字体显示，所以每当我们在命令行中看到未被跟踪的消息时，它只是意味着我们还没有将这些文件添加到登台区。<strong class="lp ir"> <em class="mw">注意，未跟踪的文件在命令行中总是以红色字体显示。</em>T11】</strong></p><p id="74ae" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">为了将这些文件添加到暂存区，我们使用命令- <strong class="lp ir"> 'git add {fileName} '，</strong>在我的例子中，我只有两个文件可以使用<strong class="lp ir">句点(.)</strong>从工作目录的根目录递归添加所有文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/0083436122792922685ae6fffed63c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQ6nwBbypJkmg8ReXxIXGg.png"/></div></div></figure><p id="7469" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">使用<strong class="lp ir">“git add command”</strong>添加文件后，如果我们再次检查状态，我们看不到任何红色，这意味着现在这些文件正在被跟踪并成功包含在暂存区中。因此，每当我们想要在特定的工作完成时在暂存区添加文件，我们可以使用<strong class="lp ir"> 'git add {fileName}' </strong>命令来添加这些文件。</p><p id="00b5" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">之后，如果我们的代码一切正常，我们想要提交它，但是在我们进入提交部分之前，有一个不可靠的概念需要我们在暂存区中了解。假设我们从工作目录中删除了<strong class="lp ir"> File2.txt </strong>或对其进行了一些更改<strong class="lp ir"> </strong>，然后检查状态，我们再次观察到一些红色消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/ce2b2a4e46af74a2789fbaca4f3703cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ti5Uohtgtd4rEtIH6b2WDA.png"/></div></div></figure><p id="4397" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">现在我们有消息“已修改”,这意味着这些更改未被跟踪，或者如果我们用更具体的术语来说，这些更改不在临时区域中。大多数人对暂存区感到困惑，用我简单的话来说，暂存区存储了我们文件中的更改，不多也不少。</p><p id="ab1a" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">例如，如果我们从工作目录中删除<strong class="lp ir"> File2.txt </strong>，暂存文件的前一版本在暂存区中仍然保持不变。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/658682a5de1fa3d613a4b902b72325c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iN-xkh4bs2Hv78np1gOtsg.png"/></div></div></figure><p id="8b8d" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">正如我们所看到的，我们仍然有一些红色消息，此时<strong class="lp ir"> File2.txt </strong>不再存在于工作目录中，但如果我们使用命令<strong class="lp ir">git add，它会存在于暂存区&amp;</strong>我们不再有未转移的文件，我们只看到了<strong class="lp ir"> File1.txt. </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/5b07908bb7ecd12b31f394d49cbd8be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdvITQovqyjkbxjMVM4LYQ.png"/></div></div></figure><p id="5884" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">通过这个演示，我们可以简单地说，暂存区存储的是文件中的更改，而不是文件本身。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="e4da" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">提交更改</h2><p id="1ca7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">当我们完成了我们的变更，我们可以提交我们的变更，最终的变更将存储在Git存储库中。使用命令<strong class="lp ir">' git commit-m { commit message } '</strong>我们可以用一条描述我们所做更改的消息来提交我们的更改。</p><p id="62c5" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/63801cbb2acf88b8489405b3ebee7eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTgHQnNQhXfrLFTqeHf3LA.png"/></div></div></figure><ul class=""><li id="7281" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">我们提交我们的更改&amp;之后我们的工作树将被清理，这意味着在中没有未被跟踪的文件，我们的更改被保存在<strong class="lp ir"> Git </strong>存储库中。</li></ul><p id="caf6" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">正如我提到的，暂存区负责存储我们在工作目录的文件中所做的更改中的更新。例如，如果我们将<strong class="lp ir"> File1.txt重命名为index.js &amp;，然后检查状态</strong>，您将再次注意到<em class="mw">暂存区中的一些未跟踪的文件。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/378b31680abd5d5f5386b74765d168d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H15WruyTYv8ZZ4T6P66BFg.png"/></div></div></figure><p id="523a" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">因此，我们再次需要使用<strong class="lp ir">‘git add’</strong>命令将重命名的<strong class="lp ir"> <em class="mw"> index.js </em> </strong>文件添加到暂存区中，以更新我们所做的更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/60e666e32d17c9d75d88ced4c86d7fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dYHBqbPdBa4W8WbNFcxPA.png"/></div></div></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="38a9" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">忽略文件</h2><p id="b106" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在每个git项目中，我们需要忽略特定的目录或文件格式，这样Git存储库就不会在我们申请提交时存储这些文件，忽略文件是必要的，否则在我们申请提交的每一步中,<strong class="lp ir"> Git </strong>存储库的大小都会增加。</p><p id="14de" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">忽略任何导演或文件格式有一个<strong class="lp ir">。gitignore </strong>文件，它包含了我们在提交变更时想要过滤掉的所有目录和文件类型。为了更好地理解，我们将添加一个我们想要过滤掉的目录，并将其添加到<strong class="lp ir">中。gitignore </strong>文件</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/242d816702b173c1a09bd4774feed719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6f0qyviPd9MbYwUzlFOHXw.png"/></div></div></figure><ul class=""><li id="9b8b" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">我们创建了一个目录<strong class="lp ir">过滤器</strong>并添加了一个<strong class="lp ir">。我们想要忽略的bin </strong>文件。</li><li id="0fa2" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">使用git status命令我们检查了状态，我们可以观察到<strong class="lp ir"> filter/ </strong>目录未被跟踪。</li><li id="7160" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">要忽略这个过滤器目录，我们必须添加与我们想要过滤掉的目录完全相同的名称，使用默认编辑器，我们在<strong class="lp ir">中添加了<strong class="lp ir">过滤器/ </strong>。gitignore </strong>文件，现在我们将能够很容易地过滤掉这个目录。</li><li id="6079" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">如果我们再次检查状态，Git会停止跟踪该目录&amp;我们不再在命令行的未跟踪区域看到<strong class="lp ir"> filter/ </strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/63fa9cb25d2b556b4c37e5ea0ef16dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EuSogElT8g1bznxu1cmKQ.png"/></div></div></figure><blockquote class="nb nc nd"><p id="083b" class="ln lo mw lp b lq mi jr ls lt mj ju lv ne mx lx ly nf my ma mb ng mz md me mf ij bi translated">注意:如果你使用<strong class="lp ir"> VS代码</strong>作为你机器上的默认编辑器，使用<strong class="lp ir">代码。gitignore </strong>命令<strong class="lp ir"> </strong>打开。gitignore文件。</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="ae07" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">git状态-s</h2><p id="c01c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">之前，我们使用普通的<strong class="lp ir"> git-status </strong>来查看状态，这是一种更具描述性的方式，但是对于干净的环境，我们可以使用<strong class="lp ir"> git status -s </strong>命令。</p><p id="bf38" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">例如:</strong></p><ul class=""><li id="964b" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">我们添加了两个新文件<strong class="lp ir"> status1.txt </strong>和<strong class="lp ir"> status2.txt，</strong>并运行“git status -s”。</li><li id="0e84" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">我们可以观察到两个问号，这仅仅意味着这两个文件未被跟踪。</li><li id="eeed" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">当我们使用<strong class="lp ir"><em class="mw">“git add”添加这些未跟踪的文件时，</em> </strong>我们可以看到<strong class="lp ir"/>【A】显示文件已经添加到暂存区中。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f4107feaf976fe2c71ece5b236a7e1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWg68SpimKcaeockHY3OzQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Untracked Files</strong></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/29f9a179bc409e6a7ef14c76f2ae0433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5clGaPd_8xKr7eF5Zu2DMA.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Added Files in Staging Area</strong></figcaption></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="84e1" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">取消转移文件</h2><p id="6d2f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">如果我们不小心将文件添加到暂存区域，我们还可以使用<strong class="lp ir">“git restore—staged { fileName }”</strong>命令恢复我们所做的更改。在我们的例子中，我们只有两个文件和一个句号<strong class="lp ir">(。)</strong>将恢复我们从根目录&amp;所做的更改，将文件恢复到它们先前的版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/66d97625b95d501b46232e916f7fa07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bfpJmfPxTiZJ0rMPmEzKg.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Unstaging Files</strong></figcaption></figure><p id="9b92" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">我们还可以使用“git restore”命令来恢复文件，但是如果文件未被跟踪，它将不起作用，因为如果文件不在临时区域中，git不知道将更改恢复到哪里。例如，如果我们尝试运行<strong class="lp ir">“git restore”</strong>不会有什么变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/f12a6bb049b2ad1347cb6b2b0d6d2c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVF3UmYymVyfEjSNFm4UQg.png"/></div></div></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="ff61" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建海关命令</h2><p id="ca9d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在Git中，我们还可以创建自己的定制命令，以避免在终端中键入长命令，为了生成定制命令，我们使用alias命令。</p><p id="499d" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/9ae75dd544f749cc873780c285b9d264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2bQXDYx2ShTrcUzdwsyHA.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Custom Commands</strong></figcaption></figure><ul class=""><li id="d40c" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">要取消这些更改，我们必须输入长命令，但是可以在Git中创建任何类型的自定义命令。</li><li id="3f0e" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">在别名之后，我们在命令中键入我们需要的关键字<em class="mw">(在我的例子中是</em><strong class="lp ir"><em class="mw">revert</em></strong><em class="mw">)</em>。</li><li id="4597" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">在双引号中，我们添加了Git使用的原始命令。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="220f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">还原已删除的文件</h2><p id="57d2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">有时我们会不小心从工作目录中删除一些文件，使用Git我们可以在几秒钟内获得这些删除的文件:</p><p id="2552" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/a25337e446eecb1d2c49d120b77188f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95CrE95y5-zj_QF85ejStA.png"/></div></div></figure><ul class=""><li id="fd3a" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">我们生成了一个名为<strong class="lp ir"> newfile.txt </strong> &amp;的新文件，用消息<strong class="lp ir">“new file stored”提交更改。</strong></li><li id="fa2b" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">现在，假设在第二次提交中，我们意外删除了文件，我们提交了一个消息<strong class="lp ir">“新文件已删除”。</strong></li><li id="f616" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">要恢复这个文件，我们必须运行oneline命令来查看到目前为止我们所做的所有提交。</li><li id="c15a" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">正如我们看到的，每个提交都有一个唯一的id(在我的例子中是9209bfd  )与每个提交相关联，我们可以使用这个id返回到上一次提交，并恢复我们刚刚删除的文件。</li><li id="d60b" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">为了恢复文件，我们使用<strong class="lp ir">“git check out”</strong>命令以及提交<strong class="lp ir"> id </strong>和我们想要恢复的文件名。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="56ab" class="ob ks iq bd kt oc od oe kw of og oh kz jw oi jx ld jz oj ka lh kc ok kd ll ol bi translated">分支</h1><p id="4b79" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">分支是<strong class="lp ir">版本控制系统</strong>中令人敬畏的特性之一，它完全改变了我们设计软件的方式，与其他<em class="mw"> VCS </em>如<strong class="lp ir"><em class="mw">Subversion</em></strong>&amp;<strong class="lp ir"><em class="mw">Mercurial相比，Git分支是最有效的。</em> </strong>在Git中，当我们生成一个新的分支时，它会将<strong class="lp ir"> Head </strong>指针移动到那个新的分支，这意味着现在我们可以在同一个工作目录中的新工作区中工作了。</p><h2 id="cfe4" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">切换分支</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/9f58fa31dc05e5dcf8bbcc65e7b8c574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hp4z9Io1Tr0Wi8lnb9f0Yw.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Branching</strong></figcaption></figure><p id="3e5b" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">假设我们正在制作一个Web应用程序，我们在前端代码中遇到了一些错误，此时我们可以创建一个新的分支来处理这些错误，稍后我们可以合并这个新的分支来生成最终的结果。</p><blockquote class="nb nc nd"><p id="b266" class="ln lo mw lp b lq mi jr ls lt mj ju lv ne mx lx ly nf my ma mb ng mz md me mf ij bi translated"><strong class="lp ir">注:</strong><strong class="lp ir"><em class="iq">主指针</em> </strong>在移动到<strong class="lp ir"> <em class="iq">新分支</em> </strong>后仍保持在我们离开工作的同一水平，这样我们就可以在<strong class="lp ir"> <em class="iq">合并</em> </strong>分支后继续我们离开的地方。</p></blockquote><p id="94e0" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b3c91a48087372bba1baf9c344524815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkFrAodRNJKf8a9is_1RSg.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">Switching Branches</strong></figcaption></figure><ul class=""><li id="4530" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">为了更好地理解，我创建了一个名为<strong class="lp ir">“分支”、</strong>的新Git存储库，其中有一个名为<strong class="lp ir">“user . txt”的普通文本文件。</strong></li><li id="97ae" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">现在使用<strong class="lp ir">【git branch】</strong>命令我们可以创建一个新的分支。(在我的例子中，新的分支被命名为<strong class="lp ir"> newuser </strong>)。</li><li id="6bc9" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">使用<strong class="lp ir">“git switch”</strong>命令，我们将分支从<strong class="lp ir">主</strong>分支更改为我们新创建的分支。</li><li id="f225" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">如果我们修改我们的<strong class="lp ir"> User.txt </strong>文件并检查状态，我们可以观察到这些变化现在与新的分支相关联。</li><li id="bf43" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">之后，如果我们使用oneline命令提交我们的更改，我们可以很容易地看到<strong class="lp ir">头</strong>移动到我们的新分支。</li></ul><blockquote class="nb nc nd"><p id="8357" class="ln lo mw lp b lq mi jr ls lt mj ju lv ne mx lx ly nf my ma mb ng mz md me mf ij bi translated">如果我们返回到我们的<strong class="lp ir">主</strong>分支并打开<strong class="lp ir"> User.txt </strong>文件，我们将看不到我们所做的更改，因为它们都是在新分支上执行的。</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="2138" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">合并</h2><p id="5389" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在<strong class="lp ir"> Git </strong>中有两种方法可以合并我们的分支:</p><ul class=""><li id="f5fd" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated"><strong class="lp ir">快进合并</strong></li><li id="ed5e" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated"><strong class="lp ir"> 3路-合并</strong></li></ul><p id="dde6" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">在快进合并中，我们可以说我们的头指针移动到了我们想要与主分支合并的新分支&amp;之后我们可以删除这个新分支。</p><p id="8741" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">但是三路合并，它有点不同，因为工作树会分叉，因为当我们合并两个分支时，Git会创建一个新的提交，这个新的提交在新的分支中并不存在，由于这个新的提交，在合并两个分支后，我们的整个工作树会分叉。</p><blockquote class="nb nc nd"><p id="cb5b" class="ln lo mw lp b lq mi jr ls lt mj ju lv ne mx lx ly nf my ma mb ng mz md me mf ij bi translated"><strong class="lp ir"> <em class="iq">你会从下面的例子中得到更好的理解:</em> </strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/63efc6b98ba46f581ccdb105f57a1808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F8Eypspdp0n7ZDuiEZPSw.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk"><strong class="bd oa">FF Merge &amp; 3-Way Merge</strong></figcaption></figure><p id="c915" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated"><strong class="lp ir">比如:</strong></p><p id="dfdf" class="pw-post-body-paragraph ln lo iq lp b lq mi jr ls lt mj ju lv la mx lx ly le my ma mb li mz md me mf ij bi translated">快进合并工作得很好，可以使用命令<strong class="lp ir"> "git merge {branchName}" </strong>来完成，但是在三路合并中，我们必须告诉git避免使用<strong class="lp ir"> <em class="mw"> FF merge </em> </strong>，即使使用<strong class="lp ir">" Git merge-no-f { branch name } "命令也可以。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/9bf547f6e061acdd08c9a8b886b1df87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgdLs2RQpl4rgdNgLe2hhg.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">3-Way Merge</figcaption></figure><ul class=""><li id="d0d1" class="mg mh iq lp b lq mi lt mj la mk le ml li mm mf mn mo mp mq bi translated">对于三向合并，我们创建了一个名为<strong class="lp ir">“another branch”</strong>的新分支，当我们将其与主分支合并时，可以很容易地观察到分叉的工作树。</li><li id="5531" class="mg mh iq lp b lq mr lt ms la mt le mu li mv mf mn mo mp mq bi translated">如果我们尝试将工作树可视化，它与我们在上面的图表中讨论的结构完全相似&amp;我们可以看到<strong class="lp ir"> HEAD </strong>指针移动到主分支，名为<strong class="lp ir"> anotherbranch </strong>的分支与线性工作树断开连接，并且我们之前的所有分支都连接到上面的工作树。</li></ul></div></div>    
</body>
</html>