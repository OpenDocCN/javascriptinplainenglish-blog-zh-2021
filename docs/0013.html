<html>
<head>
<title>How to Secure JWT in a Single-Page Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在单页应用程序中保护JWT</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-secure-jwt-in-a-single-page-application-6a46e69fc393?source=collection_archive---------1-----------------------#2021-01-02">https://javascript.plainenglish.io/how-to-secure-jwt-in-a-single-page-application-6a46e69fc393?source=collection_archive---------1-----------------------#2021-01-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2e68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React应用程序中安全地进行基于JWT的身份验证</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a43bd11d38d7669744ddc844220bb57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ahz2-8xtJ7hWlzU28jtDOA.png"/></div></div></figure><p id="96e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将了解如何在单页面应用程序中安全地存储JWT令牌以进行身份验证。</p><h2 id="15a2" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">我们在浏览器中存储令牌的所有选项是什么？</strong></h2><ol class=""><li id="cc86" class="ln lo in jm b jn lp jr lq jv lr jz ls kd lt kh lu lv lw lx bi translated">局部存储器</li><li id="0550" class="ln lo in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">记忆</li><li id="204e" class="ln lo in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">饼干</li></ol><h2 id="b966" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak"> JWT在本地存储</strong></h2><p id="6f2e" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">本地存储存储令牌安全吗？让我们找出答案。本地存储只能从客户端访问，因此如果状态为“成功”, API提供程序会将API响应授权头中的JWT设置为登录或注册API中的无记名令牌。在React中，我们将获取JWT并将其存储在本地存储中，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/7d477371f1575373f22bf996e8ea0995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2jThXlaxISSL_bkABiqKg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/e4dfe5e28ecc1d8f779ecad3c28155d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8yeMXWdW4xSZ2hiU_0xCA.png"/></div></div></figure><p id="23a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于React应用程序发出的后续请求，将从本地存储中获取JWT，并在API请求授权头中进行设置，以维护用户会话。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/886c7378de11dea191efe5cdc675839a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUNKGoR9gD-WXr42tvubmQ.png"/></div></div></figure><p id="2414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript可以访问本地存储中的值，因此任何跨站点脚本都可以从本地存储中获取JWT，并获得您的帐户访问权限。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/80c123cc5f53e2e9c684cf7fb04286f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmzp7XRkWof9wYsKo9rsXA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Script used to get local storage value</figcaption></figure><p id="23d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们应该<strong class="jm io">不使用本地存储来存储</strong> JWT。请更新您的身份验证体系结构，因为本地存储不安全，无法存储令牌。接下来，让我们来回忆一下</p><h2 id="14b5" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">内存中的JWT(反应状态)</strong></h2><p id="a226" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">当应用程序刷新或在新标签页中打开时，React状态变量将被赋予默认值。因此，如果默认值为null，当应用程序刷新或在新标签中打开时，它将被设置为null。所以当我们在状态变量中设置JWT时，它会消失。每次刷新应用程序或在新标签中打开应用程序或关闭应用程序时，用户都需要登录。会导致用户体验不佳。所以我们不能在状态变量中存储JWT。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="5b41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在转到cookie 中的<strong class="jm io"> JWT之前，让我们来看看什么是cookie及其主要属性。</strong></p><h2 id="56ae" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">饼干</strong></h2><p id="5f8c" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">cookie是浏览器中另一个可用的存储选项，它有一个过期时间。cookie还有一些有用的属性来保护它免受跨站点脚本(XSS)攻击。让我们详细看看它们是什么。</p><h2 id="f8e7" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak"> HttpOnly </strong></h2><p id="53f9" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">JavaScript无法访问具有HttpOnly属性的cookie，因此我们无法获得如下cookie。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="29db" class="ku kv in mu b gy my mz l na nb">let cookie= document.cookie;</span></pre><p id="2f14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> HttpOnly </strong> cookie只能由服务器端脚本设置和访问。如果使用<strong class="jm io"> SameSite=strict设置，该属性有助于防止跨站点脚本(XSS)攻击。</strong></p><h2 id="b0a6" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">安全</strong></h2><p id="1fd7" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">具有<strong class="jm io">安全</strong>属性的cookie将仅通过HTTPS请求发送到服务器，而不是通过HTTP请求。<strong class="jm io"> Secure </strong> cookie在请求和响应中被加密，因此通过使用<strong class="jm io"> Secure </strong>属性和<strong class="jm io"> HttpOnly </strong>和<strong class="jm io"> SameSite=strict来防止<strong class="jm io">中间人</strong>攻击。</strong></p><h2 id="c784" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">同一地点</strong></h2><p id="17e3" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">一个带有<strong class="jm io"> SameSite=strict </strong>的cookie提到该cookie只适用于同一站点源请求，不适用于跨站点请求。现在让我们看看如何使用cookie来存储JWT。</p><h2 id="42b7" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">饼干里的JWT</strong></h2><p id="b37d" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">cookie可以在服务器端设置，也可以在客户端设置，首先我们可以看到如何在React和使用浏览器控制台设置和获取cookie中的JWT。</p><p id="85c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务器将JWT设置为授权响应报头中的承载令牌。在客户端，脚本可以访问报头中的令牌。我们从响应头中获取令牌，并将其设置在cookie中，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/00ef228c26c294589317daf9a2a914f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjaT1I9OB-G82tKB7pG4_w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Using React</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/a6b1fb1c2edc555ad5a91952862ea6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGDRUPFmB-uS6-0DrbCHHw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Using Browser console</figcaption></figure><p id="f8a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，cookie设置为当前域，到期日期设置为2021年1月1日。到期日基于令牌有效性，因此一旦到期日到来，令牌将从浏览器cookie中删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/254c3ff720a154c1140af8e25edb561c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJYhua1K1dZqYStWrCIl5Q.png"/></div></div></figure><p id="a705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">cookie需要在客户端发出的每个请求的API请求头中作为一个承载令牌发送。因此，为此，我们可以使用下面的<strong class="jm io"> document.cookie </strong>属性从cookie中获取它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/368c4834e6f4d76e3c91451c5e299f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Z85y5gao65EG7FGYZTVZw.png"/></div></div></figure><p id="6b2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">document.cookie将返回域中存在的所有cookie，因此我们可以使用<a class="ae nd" href="https://github.com/reactivestack/cookies/tree/master/packages/react-cookie" rel="noopener ugc nofollow" target="_blank"> react-cookie </a>包来获取特定的cookie，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/2002d9ceeb12b8e908bf8d8f708ebc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7tGwJ959b02ODPPJ1psqA.png"/></div></div></figure><p id="bedd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们可以看到的，令牌是使用脚本设置和获取的，因此我们可以得出结论，在react中处理JWT将导致XSS(跨站点脚本)攻击，就像我们之前在使用本地存储时看到的一样，但我们之前看到了两个属性<strong class="jm io"> HttpOnly </strong>和<strong class="jm io"> Secure </strong>，通过设置这些属性可以避免这些攻击。但是JavaScript无法访问<strong class="jm io"> HttpOnly </strong>属性，只有服务器端脚本可以访问<strong class="jm io"> HttpOnly </strong>属性。让我们看看如何从服务器端设置JWT。</p><blockquote class="nf ng nh"><p id="2b05" class="jk jl ni jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">在前面的例子中，我们看到JWT在授权头中被设置为承载令牌，但是在服务器端处理cookie我们需要在<strong class="jm io"> Set-cookie </strong>头中设置Cookie，并且不需要提到令牌类型为<strong class="jm io">承载</strong>，<strong class="jm io"> </strong>我们可以直接在<strong class="jm io"> Set-Cookie中设置JWT。</strong></p></blockquote><p id="08d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我使用Express从服务器将JWT设置在cookie中，我们将<strong class="jm io"> secure </strong>和<strong class="jm io"> HttpOnly </strong>设置为<strong class="jm io"> true </strong>以限制JWT在cookie中的JavaScript访问，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/06ec4478550b85e308069ec829c08137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NBHr1gl-F9IAXoJjfQG1w.png"/></div></div></figure><p id="4646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API响应<strong class="jm io"> Set-Cookie </strong>头中的令牌将保存到浏览器Cookie中，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/45f71978dc0f5602a6a0959776979faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sc6t3W5ZmxxmvtHZDPV9Ow.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">JWT in Set-Cookie</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/af7f8e6d8db2cc00640820db5fc84595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDf6Xk8O4UBQOe-PnUkrQg.png"/></div></div></figure><p id="24dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">存储在cookie中的JWT将自动追加到每个API请求头中，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a2921ef05e067771fe65db2a82924a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NwVLZX8d0qYAj_eD5cexA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/4b62aab8790e4733f8aa122a6c5a1722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-wemBBvG_f9qqf7Y9KbyA.png"/></div></div></figure><blockquote class="nf ng nh"><p id="2bf9" class="jk jl ni jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">但是请记住，只有当React应用程序和后端服务器位于同一个域中时，这种方法才有效。</p></blockquote><p id="f0b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您的应用可以免受跨站点脚本(XSS)攻击。</p></div></div>    
</body>
</html>