<html>
<head>
<title>Should I Use useEffect or useLayoutEffect in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中应该用useEffect还是useLayoutEffect？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/should-i-use-useeffect-or-uselayouteffect-in-react-738c08a84aa7?source=collection_archive---------3-----------------------#2021-06-15">https://javascript.plainenglish.io/should-i-use-useeffect-or-uselayouteffect-in-react-738c08a84aa7?source=collection_archive---------3-----------------------#2021-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8997" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解这些React挂钩之间的核心区别</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db90611542d66c51242d45a00f1ecc0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kwcLmT80Ho8QtlbF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jasonstrull?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Strull</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都必须熟悉使用React钩子。但是你有没有想过什么时候应该使用<code class="fe ls lt lu lv b">useEffect</code>钩和<code class="fe ls lt lu lv b">useLayoutEffect</code>钩？在本文中，我将解释这些钩子的正确用法的用例。</p><p id="d0ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这两个钩子基本上做同样的事情，但是它们的用例略有不同。但是在讨论这些差异之前，让我们先了解一些术语。</p><ul class=""><li id="17d8" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><strong class="ky ir"> Render </strong> —表示计算每个DOM节点的样式。</li><li id="aa21" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><strong class="ky ir">画图</strong> —表示在屏幕上显示/更新内容。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4437" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">使用效果</h1><p id="e412" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">大多数时候，你可能想使用<code class="fe ls lt lu lv b">useEffect</code>钩。每当你重构你的类组件来使用钩子时，你可能会将任何代码从<code class="fe ls lt lu lv b">componentDidMount</code>、<code class="fe ls lt lu lv b">componentDidUpdate</code>或<code class="fe ls lt lu lv b">componentWillUnmount</code>移到<code class="fe ls lt lu lv b">useEffect</code>。</p><p id="aa2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在React渲染你的组件后运行，确保你的效果回调<strong class="ky ir">不会阻塞</strong>浏览器绘画。这与类组件中的行为不同，类组件中的<code class="fe ls lt lu lv b">componentDidMount</code>和<code class="fe ls lt lu lv b">componentDidUpdate</code>在渲染后同步运行。这样更有性能，这可能是你最想要的钩子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8452" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">useLayoutEffect</h1><p id="407c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useLayoutEffect</code>在React执行完所有DOM突变后，立即同步运行<strong class="ky ir"/>。如果您需要进行<strong class="ky ir"> DOM测量</strong>(如果您要获取元素的滚动位置或其他样式)，然后进行DOM突变或通过更新状态触发同步重新呈现，这可能会很有用。</p><p id="24c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与<code class="fe ls lt lu lv b">componentDidMount</code>和<code class="fe ls lt lu lv b">componentDidUpdate</code>的工作方式相同。DOM更新后，您的代码会立即运行，但在浏览器有机会绘制这些更改之前(我们实际上直到浏览器重新绘制后才会看到更新)。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="78ff" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">独特的例外情况</h1><p id="b193" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当使用<code class="fe ls lt lu lv b">ref</code>时，如果你想在任何其他代码运行之前更新<code class="fe ls lt lu lv b">ref</code>的值，那么你应该使用<code class="fe ls lt lu lv b">useLayoutEffect</code>而不是<code class="fe ls lt lu lv b">useEffect</code>。例如:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="0fc6" class="ns ms iq lv b gy nt nu l nv nw">const ref = React.useRef()</span><span id="3a39" class="ns ms iq lv b gy nx nu l nv nw">React.useEffect(() =&gt; {<br/>  ref.value = 'some value'<br/>})</span><span id="5bff" class="ns ms iq lv b gy nx nu l nv nw">// then, later in another hook or something<br/>React.useLayoutEffect(() =&gt; {<br/>  console.log(ref.value) // logs old value as this runs first!<br/>})</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ccce" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="a8c8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">简单地说，当你的组件在状态更新时看起来闪烁，因为回调在组件被绘制后对DOM进行了可视化的改变，你应该使用<code class="fe ls lt lu lv b">useLayoutEffect</code>。</p><p id="5c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认行为是让浏览器在React运行您的代码之前基于DOM更新重新绘制。这意味着您的代码不会阻塞浏览器，用户可以更快地看到DOM的更新。所以大部分时间坚持使用<code class="fe ls lt lu lv b">useEffect</code>，除非有必要使用<code class="fe ls lt lu lv b">useLayoutEffect</code>。</p><p id="f2d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望我能让你比现在聪明一点。注意安全。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="e985" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">参考</h1><p id="e9ed" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><a class="ny nz ep" href="https://medium.com/u/723e34673c91?source=post_page-----738c08a84aa7--------------------------------" rel="noopener" target="_blank"> pubudu jayasanka </a>的文章用图表给出了详细的解释。</p><div class="oa ob gp gr oc od"><a href="https://pubudu2013101.medium.com/what-is-the-real-difference-between-react-useeffect-and-uselayouteffect-51723096dc19" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">反应使用效果和使用输出效果之间的真正区别是什么？</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">如果您是一名reactor . js开发人员，您将会知道这些在进行前端时会被广泛使用</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">pubudu2013101.medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>