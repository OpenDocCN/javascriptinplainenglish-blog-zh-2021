<html>
<head>
<title>Native HTTP Hooks Management Made Easy Using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js使本机HTTP挂钩管理变得容易</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/native-http-hooks-management-made-easy-reducing-bugs-node-js-442c873fd172?source=collection_archive---------11-----------------------#2021-06-12">https://javascript.plainenglish.io/native-http-hooks-management-made-easy-reducing-bugs-node-js-442c873fd172?source=collection_archive---------11-----------------------#2021-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/06513d1431febb58be46c1df35a71425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvC7zUwv7dRfYS_hCTmNlg.jpeg"/></div></div></figure><div class=""/><p id="d048" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx iz">本地<em class="kt"> HTTP </em> </strong>实例<em class="kt"/><a class="ae ku" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank"><em class="kt">node . js</em></a>的<strong class="jx iz">优势之一是它将允许我们尽可能多地使用它。但是不要担心，然后我们会介绍我们的盟友，使这更容易。不管我们是在<strong class="jx iz">前端</strong>上使用<a class="ae ku" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank"><em class="kt">REST API</em></a><em class="kt"/>还是我们的<strong class="jx iz">后端</strong>需要调用外部服务，下面设想的用例都是有效的。</strong></p><p id="7043" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要用的包就是大家熟知的<a class="ae ku" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="kt">Axios</em></strong></a>。这是一个<strong class="jx iz">助手</strong>，它将处理我们的本地<em class="kt"> HTTP </em>实例。</p><h2 id="2e7e" class="kv kw iy bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">很高兴知道这一点</h2><p id="9bbf" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">随意看看官方<a class="ae ku" href="https://nodejs.org/es/docs/" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> Node.js </em>文档</a>关于<a class="ae ku" href="http://nodejs.org/api/http.html" rel="noopener ugc nofollow" target="_blank"> HTTP协议</a>通过其<strong class="jx iz">原生库</strong>的使用。这将帮助我们<strong class="jx iz">理解</strong>通过它的可用方法<a class="ae ku" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="kt">Axios</em></strong></a>正在采取什么动作。</p><h1 id="fa6b" class="lt kw iy bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">安装</h1><p id="807a" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">让我们将这个包添加到<a class="ae ku" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json" rel="noopener ugc nofollow" target="_blank"><em class="kt">package . JSON</em></a><em class="kt"/>中的"<a class="ae ku" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#dependencies" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> dependencies </em> </a>"部分，但是如果您使用的是<a class="ae ku" href="https://www.typescriptlang.org/docs/handbook/intro.html" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，这个包已经包含了类型</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="70e7" class="kv kw iy mp b gy mt mu l mv mw">npm install --quiet --save axios</span></pre><p id="fc40" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本教程中使用的软件包的当前<a class="ae ku" href="https://www.npmjs.com/package/axios#installing" rel="noopener ugc nofollow" target="_blank"> npm注册表版本</a>是:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b6a5" class="kv kw iy mp b gy mt mu l mv mw">"axios": "^0.21.1"</span></pre><p id="70cd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx iz"> <em class="kt"> Axios </em> </strong>的主要优势之一是<strong class="jx iz">关于使用<a class="ae ku" href="http://nodejs.org/api/http.html" rel="noopener ugc nofollow" target="_blank"> HTTP协议</a>的安全更新</strong>是由<em class="kt"/><a class="ae ku" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank"><em class="kt">node . js</em></a>的维护人员进行的😃</p><h1 id="ac2e" class="lt kw iy bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">选择钩子</h1><p id="0788" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">该软件包引入了<a class="ae ku" href="https://www.npmjs.com/package/axios#interceptors" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="kt">拦截器的概念</em> </strong> </a>对任何<em class="kt"> HTTP </em>请求。这将允许我们在使用任何可用的<em class="kt"> HTTP </em>方法之前或之后执行我们的<strong class="jx iz">定制功能</strong>。这为<strong class="jx iz">修改请求的部分内容</strong>或简单地执行任何其他动作而不进行修改提供了机会。</p><h1 id="9859" class="lt kw iy bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">触发HTTP方法</h1><p id="3660" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">在我们的例子中，我们有一个在<a class="ae ku" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> Node.js </em> </a>中制作的后端，每当它需要调用一个外部提供者的<em class="kt"> HTTP </em> <em class="kt"> API </em>时，它需要通过一个<a class="ae ku" href="https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Authorization" rel="noopener ugc nofollow" target="_blank">授权头</a>证明它的服务是经过认证的。</p><p id="53f2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个应用程序使用对不同的<em class="kt">API</em>的多次调用，所以我们不需要在所有请求中添加这个新的头。出于这个原因，我们将使用Axios  的<a class="ae ku" href="https://www.npmjs.com/package/axios#creating-an-instance" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">新实例，这将允许我们<strong class="jx iz">添加拦截器</strong>，该拦截器将只在对该外部提供者<strong class="jx iz">的<em class="kt"> HTTP </em>调用中执行，而不影响应用程序中已经存在的</strong>的其余</strong>调用。</a></p><p id="bf4d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，对于我们在应用程序中调用的每个外部<em class="kt"> API </em>使用不同的<strong class="jx iz"/><a class="ae ku" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">Axios</strong></a><strong class="jx iz">实例</strong>是一种<strong class="jx iz">良好做法。</strong></p><h2 id="61f8" class="kv kw iy bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">创建实例</h2><p id="9fbd" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">首先，要求包装:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="94d1" class="kv kw iy mp b gy mt mu l mv mw">const axios = require('axios').default;</span></pre><p id="c0c6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们创建一个实例，使<strong class="jx iz">总是</strong>指向相同的<strong class="jx iz"><em class="kt">base URL</em></strong>，这样我们就避免了输入错误。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1d14" class="kv kw iy mp b gy mt mu l mv mw">// This is the external service API url.<br/>const baseURL = process.env.MASTERCARD_API_BASE_URL || '<a class="ae ku" href="https://developer.mastercard.com/product/bill-pay/" rel="noopener ugc nofollow" target="_blank">https://mastercard.com/product/bill-pay/</a>';<br/>const axiosInstance = axios.create({ baseURL });</span></pre><p id="34c7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们试图使用"<a class="ae ku" href="https://nodejs.org/dist/latest-v8.x/docs/api/process.html" rel="noopener ugc nofollow" target="_blank"><em class="kt">process . env</em></a><em class="kt">"</em>全局变量来定义外部提供者的"<em class="kt">const</em><em class="kt">【base URL】</em>。这是一个避免弄乱我们代码的好方法，可以选择查看如何使用模块😍。</p><h2 id="f977" class="kv kw iy bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated">修改请求标头</h2><p id="8207" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">在发送请求内容之前，是时候执行我们的自定义操作了。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="646b" class="kv kw iy mp b gy mt mu l mv mw">const apiSecret = process.env.API_SECRET || 'super-secret-value';</span><span id="b0d3" class="kv kw iy mp b gy mx mu l mv mw">axiosInstance.interceptors.request.use(<br/>    request =&gt; ({<br/>        ...request,<br/>        headers: {<br/>            Authorization: apiSecret,<br/>        },<br/>    }),<br/>    error =&gt; Promise.reject(error),<br/>);</span></pre><p id="db01" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个用例是在日志中记录所有通话(请始终存储匿名数据)。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a22f" class="kv kw iy mp b gy mt mu l mv mw">axiosInstance.post(<br/>    '/api/v2/company/incoming',<br/>    {<br/>        "amount": "4"<br/>        "currency": "BTC"<br/>    },<br/>);</span></pre><h1 id="bc36" class="lt kw iy bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">使用实例</h1><p id="fe39" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">我们将在新的<a class="ae ku" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="kt">Axios</em></strong></a>实例中使用的任何<em class="kt"> HTTP </em>方法都将包含请求<a class="ae ku" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">的原始头，该请求连接或覆盖了headers对象中的</strong><em class="kt">授权</em> </a>"键。</p><p id="1e94" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此<strong class="jx iz">将</strong>应用于<em class="kt"> HTTP </em>对象的<strong class="jx iz">各种元素</strong>，例如body:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b4fc" class="kv kw iy mp b gy mt mu l mv mw">{<br/>    ...request,<br/>    body: {<br/>        companyName: 'We love Axios, LLC',<br/>    },<br/>}</span></pre><h1 id="92d8" class="lt kw iy bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">良好做法</h1><p id="42ca" class="pw-post-body-paragraph jv jw iy jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">由于<em class="kt">API</em>并不总是返回<strong class="jx iz">非失败状态</strong>，我们必须考虑错误情况。为了更好地理解<strong class="jx iz">如何拦截和处理<a class="ae ku" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="kt">Axios</em></strong></a>中的响应错误</strong>，请看一下<a class="ae ku" href="https://www.npmjs.com/package/axios#handling-errors" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="bd84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这种情况<strong class="jx iz">只适用于</strong>如果我们有一个<strong class="jx iz">响应拦截器</strong>定义在我们的实例中，如果我们没有，我们不必担心。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6cd6" class="kv kw iy mp b gy mt mu l mv mw">const logger = console.log;</span><span id="d949" class="kv kw iy mp b gy mx mu l mv mw">axiosInstance.interceptors.response.use(<br/>    ({ data }) =&gt; data, // Destructuring response body element<br/>    ({ status }) =&gt; {<br/>        const responseStatus = status || 500;<br/>        logger.error(responseStatus);<br/>        return responseStatus;<br/>    },<br/>);</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="0058" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有兴趣看到更多真实的用例，不要犹豫，把它放在评论中，你只需要问！</p></div></div>    
</body>
</html>