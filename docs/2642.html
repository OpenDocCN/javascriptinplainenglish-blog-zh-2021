<html>
<head>
<title>Things I Wish I Knew About… JavaScript Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望我知道的事情… JavaScript函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/things-i-wish-i-knew-about-javascript-functions-40fbc8f37bf6?source=collection_archive---------11-----------------------#2021-05-31">https://javascript.plainenglish.io/things-i-wish-i-knew-about-javascript-functions-40fbc8f37bf6?source=collection_archive---------11-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fda19fa9e9bafd60120e376dc1de9758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4M3Aw3CrSweRg5dzHlYTUQ.jpeg"/></div></div></figure><p id="54d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尤其是从C/Python/酏剂的背景来看，有一些关于JavaScript函数的事情我真的没有开始。我想我会把它们写下来，希望它们能在旅途中帮助别人。</p><p id="5fd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我应该注意，这可能是第一部分——随着我继续使用JavaScript，我肯定会学到更多关于JavaScript函数的东西。</p><h1 id="7d1e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">当一个是异步时，所有的都是异步的</h1><p id="6ca9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当我开始使用JavaScript时，我并不真正理解它是如何异步的，所以我花了相当多的时间试图弄清楚一个函数是如何从异步调用中得到一个结果并返回它，而函数调用方本身不必是异步的。</p><p id="10a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你的目标是一样的，我就不麻烦你了——你做不到。我最初对下面的建筑抱有很高的期望。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="24e6" class="mi kx iq me b gy mj mk l ml mm">async function iAmAsync(num) {<br/>  return num * 2;<br/>}<br/><br/>function iUseThen(num) {<br/>  return iAmAsync(num).then(res =&gt; res + 1);<br/>}<br/><br/>console.log("iUseThen(3) =&gt;", iUseThen(3));</span></pre><p id="5722" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有意识到的是<code class="fe mn mo mp me b">iAmAsync(3).then(...)</code>会隐含地返回一个<a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，也就是说整个<code class="fe mn mo mp me b">iUseThen</code>都会返回一个承诺。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a24f" class="mi kx iq me b gy mj mk l ml mm">iUseThen(3) =&gt; Promise { &lt;pending&gt; }</span></pre><p id="1610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我确实发现在简短脚本中使用异步函数的一种方法是声明一个匿名异步函数并立即调用它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8bcf" class="mi kx iq me b gy mj mk l ml mm">(async function() {<br/>	const result = await somethingNetwork();<br/>	console.log("Result", result);<br/>}) ()</span></pre><h2 id="8e2f" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated"><code class="fe mn mo mp me b">function</code>和<code class="fe mn mo mp me b">=&gt;</code>有什么区别？</h2><p id="d03c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe mn mo mp me b">=&gt;</code>在JavaScript中被称为“肥胖的箭头”。胖箭头是创建函数的一种简写方式(有如下限制):</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="415a" class="mi kx iq me b gy mj mk l ml mm">function (name) {<br/>  console.log("Hello", name);<br/>}</span></pre><p id="1929" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="301b" class="mi kx iq me b gy mj mk l ml mm">name =&gt; console.log("Hello", name);</span></pre><h2 id="a5d5" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated"><code class="fe mn mo mp me b">=&gt;</code>的局限性</h2><p id="873b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">虽然这很方便，但胖箭头的形式有一些局限性。</p><h2 id="d3f3" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">否<strong class="ak">本</strong></h2><p id="f58b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">用<code class="fe mn mo mp me b">=&gt;</code>定义的函数没有<code class="fe mn mo mp me b">this</code>可参照。一个(有点做作的)例子- <a class="ae mq" href="https://codepen.io/arafel/pen/VwpeXQx" rel="noopener ugc nofollow" target="_blank">这个作品</a>:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5f43" class="mi kx iq me b gy mj mk l ml mm">withFunction = {<br/>  answer: 42,<br/>  ask: function () {<br/>    console.log("The answer is:", this.answer);<br/>  }<br/>};<br/>withFunction.ask();</span></pre><p id="6986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生产:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e422" class="mi kx iq me b gy mj mk l ml mm">The answer is: 42</span></pre><p id="3514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mq" href="https://codepen.io/arafel/pen/gOmPzgO" rel="noopener ugc nofollow" target="_blank">本不</a>:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bc4b" class="mi kx iq me b gy mj mk l ml mm">withArrow = {<br/>  answer: 42,<br/>  ask: () =&gt; {<br/>    console.log("The answer is:", this.answer)<br/>  }<br/>}<br/>withArrow.ask();</span><span id="a8e2" class="mi kx iq me b gy nc mk l ml mm">The answer is: undefined</span></pre><p id="cca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更真实的例子可以在Vuex中看到——如果你定义了一个突变或者一个动作，并且你使用了一个胖箭头函数，它可能不会像你预期的那样工作。</p><p id="190b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着——因为没有<code class="fe mn mo mp me b">this</code>，你也不能使用<code class="fe mn mo mp me b">super</code>。</p><h2 id="9456" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">不能用作构造函数。</h2><p id="ece3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果要定义一个类，必须使用完整的<code class="fe mn mo mp me b">function foo(bar) {}</code>形式。</p><h2 id="97e7" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">不能用<strong class="ak">屈服</strong></h2><p id="a0f7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我必须承认，这对我来说不是问题，我还没有理由使用发电机。</p><h2 id="11a8" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">何时使用<code class="fe mn mo mp me b">(foo) =&gt;</code>、何时使用<code class="fe mn mo mp me b">foo =&gt;</code>？</h2><p id="374a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe mn mo mp me b">foo =&gt; ...</code>表单只接受一个<em class="nd">和一个</em>参数，即使是简单表单也是如此。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="678a" class="mi kx iq me b gy mj mk l ml mm">foo =&gt; console.log("I'm a valid construction if foo is simple");</span></pre><p id="c9e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果需要指明没有参数，括号是必需的。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0768" class="mi kx iq me b gy mj mk l ml mm">() =&gt; console.log("I'm not listening to you");</span></pre><p id="2cf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你需要传递两个，<code class="fe mn mo mp me b">(foo, bar) =&gt; ...</code>那么它需要括号。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2951" class="mi kx iq me b gy mj mk l ml mm">(foo, bar) =&gt; console.log("You gave me", foo, "and", bar);</span></pre><h2 id="2877" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">重要说明</h2><p id="48e7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你需要用这个参数做任何事情，你需要括号。例如—需要添加一个TypeScript类型？括号。想要提供默认参数吗？括号。诸如此类。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="af63" class="mi kx iq me b gy mj mk l ml mm">(foo: string) =&gt; console.log("Printing the string", foo);<br/>(foo = 'hello world') =&gt; console.log(foo);</span></pre><p id="7215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以归结为——仅仅因为你<em class="nd">可以</em>做某事，并不意味着你<em class="nd">应该</em>做某事。参考见<a class="ae mq" href="https://raw.githubusercontent.com/getify/You-Dont-Know-JS/1st-ed/es6%20%26%20beyond/fig1.png" rel="noopener ugc nofollow" target="_blank">凯尔·辛普森精彩流程图</a>。</p><h2 id="c50a" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">什么时候用<code class="fe mn mo mp me b">foo =&gt; { bar; return baz }</code>，什么时候用<code class="fe mn mo mp me b">foo =&gt; bar</code>？</h2><p id="d225" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果函数体是一条语句，可以省略大括号。否则，大括号是必需的。</p><p id="bb1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果省略了大括号，那么<code class="fe mn mo mp me b">return</code>就是隐含的，也必须省略。</p><p id="43d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一句话，带暗示<code class="fe mn mo mp me b">return</code>:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="191b" class="mi kx iq me b gy mj mk l ml mm">foo =&gt; foo + 1</span></pre><p id="aa37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多条语句，带有明确的<code class="fe mn mo mp me b">return</code>:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8b51" class="mi kx iq me b gy mj mk l ml mm">foo =&gt; {<br/>	console.log("You gave me", foo);<br/>	return foo + 1;<br/>}</span></pre><h2 id="09fb" class="mi kx iq bd ky mr ms dn lc mt mu dp lg kj mv mw lk kn mx my lo kr mz na ls nb bi translated">关闭</h2><p id="6d1c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有点像混合体——一部分是数据，一部分是功能。我以前遇到过闭包，但是JavaScript使它们比我花了很多时间使用的其他语言更容易使用。</p><p id="5b36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个闭包本质上是一个函数以及它被创建时的环境。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8fa6" class="mi kx iq me b gy mj mk l ml mm">function makeClosure(outerArgument) {<br/>  // Return a function which adds 'outerArgument' to<br/>  // whatever argument it's given.<br/>  return function(innerArgument) {<br/>    return outerArgument + innerArgument;<br/>  }<br/>}<br/><br/>addOne = makeClosure(1)<br/>console.log("Created addOne", addOne);<br/>console.log("Two plus one is", addOne(2));</span></pre><p id="9d6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哪些输出:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="138a" class="mi kx iq me b gy mj mk l ml mm">$ node closure.js<br/>Created addOne [Function (anonymous)]<br/>Two plus one is 3</span></pre><p id="25f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，返回的函数是匿名的，仅仅是因为我们没有在<code class="fe mn mo mp me b">makeClosure</code>中命名它。给它命名是很有可能的，虽然我还没发现它有多大用处(到目前为止)。</p><p id="0afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个关于闭包的小例子——更有用的例子见<a class="ae mq" href="https://www.solarwinter.net/using-closures-with-axios/" rel="noopener ugc nofollow" target="_blank">我的另一篇关于使用Axios的博文</a>。</p><h1 id="48d6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="c767" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我希望这对某些人来说是有用的介绍——希望我在开始学习JavaScript时就知道这些！</p><p id="c8f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nd">更多内容请看</em><a class="ae mq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nd">plain English . io</em></a></p></div></div>    
</body>
</html>