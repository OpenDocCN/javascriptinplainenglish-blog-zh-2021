<html>
<head>
<title>Learn to Create a “fetch” API with the Node Core API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用节点核心API创建“获取”API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-to-create-a-fetch-api-with-the-node-core-api-91c1e9119cba?source=collection_archive---------16-----------------------#2021-08-19">https://javascript.plainenglish.io/learn-to-create-a-fetch-api-with-the-node-core-api-91c1e9119cba?source=collection_archive---------16-----------------------#2021-08-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/365113e27f170553896e0301234fcbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b9LvQPqZBeAl-eJ6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@rangel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Rangel</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e362" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我写的每一篇文章，我的目标是为阅读这篇文章的人传递正确的思维框架，这样他们可以在离开现场时对所介绍的概念有更深的理解。</p><p id="4d65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从广义上讲，写作或教学的目的是让学习者更加好奇，并为他们提供一些解决问题的过程，他们可以在其他开放式或远程类似的问题中进行归纳。</p><h2 id="eb78" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">问题描述:</h2><p id="0a5b" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">今天，我想解决的问题是:</p><p id="c99d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">“如何使用async/await在Node.js中的http模块之上构建抽象”</strong></p><p id="d17c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，“http”模块遵循回调模式。因此，我们可能会也可能不会将它完全转换成“异步/等待”模式。</p><p id="3cec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>如果在Node.js代码中使用commonJS，请替换<code class="fe lw lx ly lz b">import ... frpm "..." with const ... = require("...")</code>。</p><p id="e88b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">http请求的一般格式如下:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="3682" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，正如我们所看到的，可能没有空间将其格式更改为基于承诺的功能。</p><h2 id="11fb" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">解决问题的过程:</h2><p id="6c8b" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">第一部分:</p><p id="1660" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想要完成的第一个目标是在我们的解决方案中使用<strong class="kc io"> <em class="mg"> async/await </em> </strong>技术。首先，我们需要知道<code class="fe lw lx ly lz b"><strong class="kc io">async/await</strong></code>是建立在承诺之上的模式。因此，基于承诺的概念，我们要编写的模块必须返回一个承诺。</p><p id="4bb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此该模块的一般格式如下:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6f83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们现在已经创建了一个函数，我们希望它作为核心“http”模块的包装器或父函数。</p><p id="cc3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二部分:</p><p id="c69b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在问我们需要哪些核心模块来使我们的新模块工作。根据我们的观察，我们已经看到了以“http”或“https”开头的网站和资源。</p><p id="ce23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们需要一种方法来指定我们的模块是通用的，以便它可以处理“http”和“https”模块。</p><p id="01af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习:</strong>尝试添加“fetch”函数的逻辑来处理http和https协议</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="58a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经形成了函数的基本结构，现在我们想在<code class="fe lw lx ly lz b">fetch</code>函数体中使用<code class="fe lw lx ly lz b">http</code>和<code class="fe lw lx ly lz b">https</code>模块。</p><p id="c0df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三部分:</p><p id="7e41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有协议变量，它可以是对http或https模块的引用。让我们将它添加到fetch函数体中</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="407a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，基于我们传递给fetch函数的url，我们可以使用http或https功能之一发送请求，所以让我们将url作为protocol.get参数传递:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="b8ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第四部分:</p><p id="4424" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，http/https模块不能在Node.js中转换为promises，所以我们要解决的问题是在协议内部使用回调，这样最后我们就有了一个基于promise的fetch模块。</p><p id="0b79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们解决protocol.get(url)，我们应该首先创建回调的必要功能。</p><p id="2b04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该知道一些关于Node.js在发出请求后如何接收数据的概念:</p><ul class=""><li id="68ed" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">Node.js以块的形式接收数据，即接收到的小信息包，然后在我们的服务器逻辑中打包在一起。</li><li id="cc5c" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">这些块在Node.js中以<code class="fe lw lx ly lz b">Buffer</code>的形式被接收。因此，我们可能必须在代码中将它们转换成有意义的格式。</li><li id="eacb" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">接收块的过程是一个异步操作，所以我们需要确保块是按顺序接收的，这样我们的服务器逻辑中就会有一个有组织的块集合</li></ul><p id="f28d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们要解决的问题是，我们如何按照发送到服务器的顺序获取数据块。</p><p id="8e73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，我们必须等待每个数据块被完全正确地接收，然后才能接受下一个即将到来的数据块。</p><p id="dd28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住，我们正试图使用<code class="fe lw lx ly lz b">async/await</code>特性来解决这个问题，所以如果我们搜索或了解<strong class="kc io">迭代器</strong>，一个<code class="fe lw lx ly lz b">await for ...of</code>可能是一个可靠的选择。</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="c3f6" class="ky kz in lz b gy mz na l nb nc">for await (const chunk of res) { ... }</span></pre><p id="03d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以现在我们应该问:</p><p id="836a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">"在我们确保它们以正确的顺序被接收之后，我们如何收集这些块？"。</p><p id="31ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想想在JavaScript和Node.js中存储本质上相似的值的情况，您可以得出结论，将块放在一个数组中是一个好的决定。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="af30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是body数组内容的示例:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="3964" class="ky kz in lz b gy mz na l nb nc">[<br/>  &lt;Buffer 7b 22 70 61 67 65 22 3a 32 2c 22 70 65 72 5f 70 61 67 65 22 3a 36 2c 22 74 6f 74 61 6c 22 3a 31 32 2c 22 74 6f 74 61 6c 5f 70 61 67 65 73 22 3a 32 2c ... 428 more bytes&gt;,<br/>  &lt;Buffer 64 22 3a 31 30 2c 22 65 6d 61 69 6c 22 3a 22 62 79 72 6f 6e 2e 66 69 65 6c 64 73 40 72 65 71 72 65 73 2e 69 6e 22 2c 22 66 69 72 73 74 5f 6e 61 6d 65 ... 502 more bytes&gt;<br/>]</span></pre><p id="2258" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，我们可以采取两种方法，要么在一个地方编写整个回调函数，要么让回调函数由小函数组成。我认为养成编写小函数的习惯是一项长期受益的技能，所以让我们遵循第二种方法。</p><p id="9832" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个名为<code class="fe lw lx ly lz b">collectChunks</code>的函数:</p><ul class=""><li id="5619" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">它应该接受响应对象</li><li id="2b75" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">它应该按顺序收集数据块</li><li id="dd1e" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">它应该返回块的集合以供进一步处理</li></ul><p id="418a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>编写<code class="fe lw lx ly lz b">collectChunks</code>函数，使其满足上述条件:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8553" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们测试下面的函数，我们会得到下面的错误:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="9c6b" class="ky kz in lz b gy mz na l nb nc">for await (const chunk of res) {<br/>      ^^^^^<br/><br/>SyntaxError: Unexpected reserved word</span></pre><p id="f27c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个错误等于一个学习的机会。因为我们已经在函数体中使用了<code class="fe lw lx ly lz b">await</code>关键字，所以我们需要使函数充当异步函数，以便使其正确工作。所以<code class="fe lw lx ly lz b">collectChunks</code>的最终实现如下:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0602" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，fetch fetch函数的一般结构如下:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="32af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个任务是编写这个someCallback，它调用内部的collectChunks函数。</p><p id="b0af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个回调函数的正确名称应该是<code class="fe lw lx ly lz b">getData</code>。这一职能应该:</p><ol class=""><li id="65f7" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx nd mn mo mp bi translated">调用内部的collectChunks从外部源获取数据</li><li id="58cb" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx nd mn mo mp bi translated">它应该将收集的缓冲区转换成代码其他部分可读的格式</li></ol><p id="b914" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>根据上述要求编写getData</p><p id="a9db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们一起编写它，因为collectChunks被声明为一个<code class="fe lw lx ly lz b">async</code>函数，它将返回一个承诺，所以为了在getData函数中使用它，我们必须将getData也声明为一个<code class="fe lw lx ly lz b">async</code>函数:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6ede" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>你可以去掉async/await关键字，看看会发生什么，加深你对它们如何工作的理解。</p><p id="fcc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在chunks变量包含了一个缓冲区数组。我们必须将数组转换成可读的格式，对吗？</p><p id="9c2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在互联网上搜索缓冲区对象，您会发现它们有一个<code class="fe lw lx ly lz b">toString()</code>方法，使用UTF8编码将缓冲区转换为字符串。因此，一个可能的解决方案是:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="3e8b" class="ky kz in lz b gy mz na l nb nc">chunks.map((buffer) =&gt; buffer.toString())</span></pre><p id="fc08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们必须再次把所有的块放在一起，然后再次解析它们，所以也许我们可以把所有的块放在一起，然后在一个地方解析它们。</p><p id="9787" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这听起来像是我们的getData函数的额外工作，它的工作只是获取数据而不是处理接收到的数据。您猜对了，我们有一个创建新功能的环境，它应该:</p><ul class=""><li id="a7c7" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">连接所有缓冲器</li><li id="604c" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">解析它们以备后用</li><li id="cc78" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">返回解析的数据</li></ul><p id="a385" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>试编写这个名为<code class="fe lw lx ly lz b">parseData</code>的函数来做上述要求:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1b6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以getData函数变成了:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bb0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有适当的错误处理工具，任何处理承诺的函数都是不完整的，异步/等待函数中的错误处理惯例是使用<strong class="kc io"> try/catch块</strong>。</p><p id="d8db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们使用try/catch块修改getData函数。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5c00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修改后，我们的代码如下:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bd47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是时候检查fetch函数是否按预期工作了:</p><p id="bcc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>在getData函数的try块中放置一个<code class="fe lw lx ly lz b">console.log(data)</code>，并使用fetch测试一个免费的API，示例如下:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="f9ce" class="ky kz in lz b gy mz na l nb nc">fetch('https://reqres.in/api/users?page=2');</span></pre><p id="0b3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">控制台上打印的结果将是:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="7e4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可能想把它写到一个文件中，或者保存到一个数据库中，或者对数据做一些逻辑处理。</p><p id="9696" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是等等！目光敏锐的学习者可能会问:</p><p id="9333" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">"在getData函数中处理数据是否是某种反模式？"</p><p id="7a54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">她是对的，如果我们决定遵循单一责任原则，我们的职能应该做一件事，那就是获取数据，不多也不少。</p><p id="1e30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">猜猜看，我们有一个新问题要解决:</p><h2 id="4abc" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">问题陈述:</h2><p id="400d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们希望fetch模块独立于其他函数或额外的工作。</p><p id="0635" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，我们已经声明了我们的<code class="fe lw lx ly lz b">fetch</code>函数，以便它返回一个承诺，我们以后可以在代码的其他部分使用它。</p><p id="96ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要测试当前条件，请记录fetch函数返回的值:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1b9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们的第一个想法是，测试现在已经开始，我们可以这样做:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="d60e" class="ky kz in lz b gy mz na l nb nc">test.then(() =&gt; console.log('fetch works perfectly'));</span></pre><p id="640b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果运行该模块，您会看到消息不会打印在控制台上。这是我们需要检查我们对承诺的理解的地方。</p><p id="5f5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需检查我们到目前为止编写的fetch函数</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a1f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能会注意到，除了两个空闲参数:<strong class="kc io"> resolve和reject </strong>，每个人都在忙碌和工作。</p><p id="763a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我亲爱的华生，正如夏洛克·福尔摩斯所说，“我们可能已经找到了罪犯！”。</p><p id="d9c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在继续之前，试着解释什么是承诺以及承诺是如何运作的。</p><p id="4cc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于承诺定义:</p><p id="94fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">Promise将两个函数作为其参数，并根据Promise的状态调用每个函数。如果承诺状态被满足，将调用resolve函数，如果其状态被拒绝，将调用reject函数。</em></p><p id="9682" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，我们如何使用这两个函数，以便以后可以访问fetch函数的结果呢？</p><p id="ea74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过仔细观察fetch函数的主体，我们可以看到只有一个函数能够接受resolve和reject作为它的参数，那就是:<code class="fe lw lx ly lz b">getData</code></p><p id="cc4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能认为问题已经解决了，就像这样:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9420" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">试着运行这个模块，看看会发生什么。您会得到以下错误:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="afc2" class="ky kz in lz b gy mz na l nb nc">UnhandledPromiseRejectionWarning: ReferenceError: res is not defined</span></pre><p id="1d36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你有权问为什么会发生这种情况。</p><p id="8273" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因是对于protocol.get()，您应该像我们在第一个位置对“getData”功能所做的那样传递一个函数或一个函数的引用，但是现在我们将getData()作为一个参数调用。</p><p id="a405" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么在其他类似的问题中，你会如何解决这样的问题呢？</p><p id="cb4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，首先定义问题:</p><ul class=""><li id="978d" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">您需要向protocol.get()传递一个函数</li><li id="27d9" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">您还需要将resolve和reject传递给getData函数</li></ul><p id="54f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，传递给protocol.get()的函数的形式是:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="0288" class="ky kz in lz b gy mz na l nb nc">(req,res) =&gt; { ... }</span></pre><p id="d39d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，还需要将res对象传递给getData以及resolve和reject:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="4843" class="ky kz in lz b gy mz na l nb nc">getData(res, resolve, reject)</span></pre><p id="776b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此我们可以得出结论，getData必须在传递给protocol.get()的匿名函数内部调用，如下所示:</p><pre class="ma mb mc md gt mv lz mw mx aw my bi"><span id="e08d" class="ky kz in lz b gy mz na l nb nc">protocol.get(url, (res) =&gt; getData(res, resolve, reject));</span></pre><p id="55eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以在getData函数的范围内访问resolve and reject函数，我们可以修改它来处理它使用resolve函数接收的数据:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="14bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们现在已经编写了fetch函数，我们希望它返回一个承诺，即<strong class="kc io"> thenable </strong>。让我们检查一下我们的期望:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ed43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们设法创建了一个基于promised的http模块。</p><p id="f1ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最终代码:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6d08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以在另一个模块中导入<code class="fe lw lx ly lz b">fetch</code>,并将其用于其他目的:</p><p id="1a57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习)</strong>创建一个<code class="fe lw lx ly lz b">getUsers.js</code>文件并测试以下内容:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="f36e" class="ne kz in bd la nf ng nh ld ni nj nk lg nl nm nn lj no np nq lm nr ns nt lp nu bi translated">结论:</h1><ul class=""><li id="2c8b" class="mh mi in kc b kd lr kh ls kl nv kp nw kt nx kx mm mn mo mp bi translated">解决任何问题都是一个多步骤、迭代的过程。不要期望在了解问题各个方面的情况下一次性解决问题。</li><li id="183e" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">我希望你能理解我们在这里所经历的过程，并对你面临的其他问题采用同样的方法。</li><li id="7842" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">每当你记录一条数据并收到与你预期不同的东西时，这是一个很好的机会来重新检查你的知识和理解，并在更深的层次上学习这些概念。</li></ul><p id="c2a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mg">plain English . io</em></strong></a></p></div></div>    
</body>
</html>