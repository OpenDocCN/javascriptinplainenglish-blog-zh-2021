<html>
<head>
<title>JavaScript Promises: Let’s ‘Settle’ This Once and For All</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺:让我们一劳永逸地解决这个问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/promise-in-javascript-94ea3795c7ad?source=collection_archive---------9-----------------------#2021-08-06">https://javascript.plainenglish.io/promise-in-javascript-94ea3795c7ad?source=collection_archive---------9-----------------------#2021-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e080831064ded001fb98b7ea3065ffe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZR1mnZ76aQUUDjN9wj6tw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Pic Source: Google Images</figcaption></figure><p id="2beb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">承诺一直是JavaScript初学者最困惑的话题。</p><p id="6269" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">两年前，我也像你一样，犹豫是否与我的开发伙伴讨论Promise，只是复制粘贴代码而不理解它，当我试图深入了解它时，它看起来很复杂。</p><p id="8d97" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，在这个行业工作了几年后，我想我在JavaScript中得到了承诺的概念。什么是承诺？我们如何使用它？为什么我们需要使用承诺？我将在这篇文章中回答所有这些问题。所以说重点吧。</p><p id="4431" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">“承诺是一个经过某种处理后给你提供价值的对象”</em></p><h1 id="21f7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是承诺？</h1><p id="18ef" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">正如我们所知，JavaScript是一种<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" rel="noopener ugc nofollow" target="_blank">异步语言</a>，这意味着Javascript不会等待一个耗费时间的进程执行，而是直接进入下一行执行。所以，如果这是JavaScript的典型行为，我们要写的代码，是我们想在进程完成后执行的。我知道你会说，我们用<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="kx">回调</em> </strong> </a> <strong class="kb io"> <em class="kx"> </em> </strong>来说明这一点，但是你也知道回调的局限性以及回调所带来的问题。</p><p id="9bf4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么，有什么解决办法呢？</p><p id="a014" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">承诺</strong>就是解决。</p><p id="e349" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> Promise </strong>承诺我们在流程完成后返回成功或失败的结果，之后您可以在<strong class="kb io"> then()或catch() </strong>函数中编写代码，我们将在本文稍后讨论。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/61ee47f8b2ab5fd2f796e147740c7cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4itqjP9sezcsGUckdIiWA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A simple example of Promise</figcaption></figure><p id="27c6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Promise只接受一个函数作为参数，它也接受两个参数，这两个参数是Promise的状态，你要相应地调用Resolve &amp; Reject。根据您的逻辑，如果您希望成功，您可以调用resolve()，或者在出现任何错误或异常时，您可以调用reject()。就像上面的例子一样，我们基于<em class="kx">状态</em>变量调用resolve或reject。</p><h1 id="778c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">承诺的状态</h1><p id="bd56" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">根据承诺的定义<em class="kx">“承诺是一个经过某种处理后为你提供价值的对象”，</em>这意味着承诺有不同的生命周期，比如当它处理某个请求时和当它给出某个响应时。</p><p id="a2ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，当Promise处理某个请求时，它处于<strong class="kb io">未决状态</strong>，当它给出结果时，它处于<strong class="kb io">已解决状态。</strong></p><p id="e284" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们再次知道稳定状态可以是成功状态或失败状态，因为我们将稳定状态分为两种状态<strong class="kb io">满足状态(成功)&amp;拒绝状态(失败)。</strong></p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/23eaec386f2e5fe8ae061a6c78372167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSL0JtaaLSm8wHTyRYY-zw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Pic Source: <a class="ae mb" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_promises.html&amp;psig=AOvVaw1iHCSKjqyUkXU-BNkeJeFi&amp;ust=1628243363775000&amp;source=images&amp;cd=vfe&amp;ved=0CAwQjhxqFwoTCNjCjrDNmfICFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">Exploring JS</a></figcaption></figure><h1 id="3ccd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">处理承诺</h1><p id="a136" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">现在让我们看看，在成功和失败的案例中，我们如何处理来自承诺的那些反应。看看下面的代码。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/fc153fc9abacb41cf663dc2479ef8cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1l-mA5xGyIc0higqFb5rog.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of How to handle Promise</figcaption></figure><p id="07ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码中你可以看到，我们有一个名为<strong class="kb io"> <em class="kx"> job </em> </strong>的函数，它根据传递给它的<strong class="kb io"> <em class="kx"> state </em> </strong>参数返回一个承诺。现在我们调用的是<strong class="kb io"><em class="kx"/></strong>函数中的<strong class="kb io"><em class="kx"/></strong><em class="kx">(它可以命名任何东西，它的关键字不是</em> <strong class="kb io"> <em class="kx"> </em> </strong>变量)。当<strong class="kb io"> <em class="kx">作业</em> </strong>承诺得到解决并发送数据给<strong class="kb io"> <em class="kx">承诺</em> </strong>变量时，它在<strong class="kb io">中处理。然后&amp;。捕捉</strong>功能。</p><p id="ab3c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">“如果</em><strong class="kb io"><em class="kx">resolve()</em></strong><em class="kx">函数执行完毕它就转到</em> <strong class="kb io"> <em class="kx">然后</em> </strong> <em class="kx">如果</em><strong class="kb io"><em class="kx">reject()</em></strong><em class="kx">函数执行完毕它就转到</em><strong class="kb io"><em class="kx">catch</em></strong><em class="kx">”。</em></p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/80828780a67b6741c0897f4ce77bbe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSG7mfuZwLfdv5aX0dMjsQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Another way of handling Promise</figcaption></figure><p id="5d19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">迷茫？如果你看到我们在这里做了什么，我们只是将<strong class="kb io"> catch </strong>方法作为第二个参数传递给<strong class="kb io">和</strong>方法，它将产生相同的结果。因此，基本上有三个要点需要注意。<br/><strong class="kb io">=&gt;</strong>Promise<strong class="kb io"><em class="kx">then()</em></strong>方法接收<strong class="kb io"> <em class="kx"> resolve() </em> </strong>函数作为<strong class="kb io">第一个自变量</strong>其中<strong class="kb io">第二个自变量</strong>是<strong class="kb io"> <em class="kx"> reject() </em> </strong>函数<em class="kx">(可选)</em>。<br/> <strong class="kb io"> = &gt; </strong>您既可以在<strong class="kb io"><em class="kx">【catch()</em></strong>方法中处理<strong class="kb io"><em class="kx"/></strong>，也可以在函数中将第二个参数传递给<strong class="kb io"> <em class="kx"> then() </em> </strong>方法。<br/> <strong class="kb io"> = &gt; </strong>还有一个比较有趣的事情，<strong class="kb io"><em class="kx">【catch()】</em></strong>方法就跟<strong class="kb io"> <em class="kx"> then() </em> </strong>方法一样但是取第一个实参(成功一个)作为<strong class="kb io"> null。</strong></p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/9fa5026d9a07877809542c13551e5d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnowgB35xhDypBCVUQnKXw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Consuming Promise response multiple times</figcaption></figure><p id="3f25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的例子中，我们可以看到我们调用了Promise一次，但是消耗了它的结果两次。你可以多次使用承诺回复。</p><h1 id="f89f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">承诺链</h1><p id="9205" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">就像我们可以多次使用Promise结果一样，我们可以将then()方法的结果作为新的Promise传递给另一个then()方法。这意味着每个then()方法都返回一个对附加到它的另一个then()方法的承诺。您可以附加多个then() &amp; catch()方法来编写您的代码流。看看下面的代码。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/e853f503ca2cf65010d11d379df1765b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HS9oR7GAsiW3_l7GXie10g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Chaining of Promise</figcaption></figure><p id="c96b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的例子中，我们可以看到我们创建了一系列的then() &amp; catch()方法，它们一个接一个地执行。现在有一些简单的规则来理解这个重要的代码流。</p><h2 id="ffe8" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak">承诺链规则</strong></h2><ul class=""><li id="316a" class="mw mx in kb b kc lw kg lx kk my ko mz ks na kw nb nc nd ne bi translated"><strong class="kb io"> <em class="kx">然后()</em> </strong> &amp; <strong class="kb io"> <em class="kx">抓住()</em> </strong>两种方法都返回<strong class="kb io">只许</strong>个。</li><li id="08be" class="mw mx in kb b kc nf kg ng kk nh ko ni ks nj kw nb nc nd ne bi translated">代码永远不会转到<strong class="kb io"> catch() </strong>块，除非您从main <strong class="kb io"> Promise </strong>调用<strong class="kb io"> reject() </strong>函数或者在then()方法中抛出任何错误。<br/>喜欢:<em class="kx">thow“3”；</em></li><li id="9308" class="mw mx in kb b kc nf kg ng kk nh ko ni ks nj kw nb nc nd ne bi translated">所有连锁的<strong class="kb io"> then() </strong>方法以同步的顺序一个接一个地执行。</li><li id="48e0" class="mw mx in kb b kc nf kg ng kk nh ko ni ks nj kw nb nc nd ne bi translated">即使你这样返回:返回新的错误(“错误”)；它将转到then()方法，你不是抛出任何错误，而是返回一个错误。</li></ul><p id="8792" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">借助这4条规则，你可以很容易地找到承诺链的输出。</p><p id="9246" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">再举一个例子来说明这个问题。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/7ac3138b97a4cfc69c882a3d38f8f763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaZ3XK_S234GnfRpUZoEqQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example for Chaining of Promise</figcaption></figure><h1 id="9769" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">承诺方法</h1><p id="2fa2" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">现在假设您需要同时调用多个承诺，并且您的进一步执行取决于该结果。万岁！JavaScript提供了一些owssm Promise方法，通过这些方法我们可以做到这一点。让我们看看它们。</p><h2 id="d745" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak">调用多个承诺的功能</strong></h2><h2 id="d9f7" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak"> 1。Promise.all() </strong></h2><p id="eed4" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">Promise.all()接受一个承诺数组，并且仅当所有承诺都被解析时，才返回数组中所有承诺的结果。如果任何承诺被拒绝，它将进入Catch()状态。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/a36a974f3fc9fbb2f6c466535171216a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QfLX9dpPB5IghDYuX0X_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of Promise.all()</figcaption></figure><h2 id="e461" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak"> 2。Promise.allSettled() </strong></h2><p id="cb3b" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">Promise.allSettled()接受一个承诺数组，如果所有承诺都被解析或拒绝，则返回数组中所有承诺的结果。它给出了一个带有承诺状态及其值的对象数组。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/a36a974f3fc9fbb2f6c466535171216a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QfLX9dpPB5IghDYuX0X_A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of Promise.allSettled()</figcaption></figure><h2 id="b520" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak"> 3。Promise.race() </strong></h2><p id="e204" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">Promise.race()接受一组承诺，并返回先解决或先拒绝的一个承诺的结果。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/c40ac2bf591a596186cab0ef624607d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xk--GDb3B80GMJlSCnUV9w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of Promise.race()</figcaption></figure><h2 id="742f" class="mk kz in bd la ml mm dn le mn mo dp li kk mp mq lm ko mr ms lq ks mt mu lu mv bi translated"><strong class="ak"> 4。Promise.any() </strong></h2><p id="7123" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">Promise.any()接受一个承诺数组，并返回先解决的一个承诺的结果。如果某个承诺先失败了，它就变成catch()。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/2b3a008e36255eb8f3f6c60dad60350e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNwdMZEpOglClKopg-xNHg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of Promise.any()</figcaption></figure><p id="e81b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们知道了关于承诺的一切，为了更好地理解，我建议你完成这些<a class="ae mb" href="https://www.codingame.com/playgrounds/347/javascript-promises-mastering-the-asynchronous/what-is-asynchronous-in-javascript" rel="noopener ugc nofollow" target="_blank">练习题</a>。</p><p id="9700" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢您的阅读，并快乐编码:)</p><p id="757e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">更多内容看</em><a class="ae mb" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>