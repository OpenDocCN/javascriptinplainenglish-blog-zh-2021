<html>
<head>
<title>10 Confusing TypeScript Notations I Wish I Understood Earlier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个令人困惑的打字稿符号，我希望我能早点理解</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-confusing-typescript-notations-i-wish-i-understood-earlier-d1c6f722828c?source=collection_archive---------0-----------------------#2021-03-17">https://javascript.plainenglish.io/10-confusing-typescript-notations-i-wish-i-understood-earlier-d1c6f722828c?source=collection_archive---------0-----------------------#2021-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbd2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">初学者理解TypeScript的一个特殊方面。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/55df9323ea4f717e5b2bd112d8250df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WgGaRdXsC__-3d52W51cg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Create by bytefish</figcaption></figure><p id="42f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我第一次学习TypeScript时，我注意到TS代码充满了难以理解的符号。一些符号也出现在JavaScript中，但是当它们出现在TypeScript中时，它们具有完全不同的含义。这曾经让我很困惑。</p><p id="45ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">后来随着进一步的学习，我明白了这些记数法的用法，也感受到了它们的魅力。这里有10个符号，我当时觉得很奇怪，但现在发现非常有用。</p><h2 id="7143" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">目录:</h2><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="33d3" class="lr ls iq ml b gy mp mq l mr ms">· <a class="ae mt" href="#019f" rel="noopener ugc nofollow">Unions type: |</a><br/>· <a class="ae mt" href="#7d7d" rel="noopener ugc nofollow">Intersection Types: &amp;</a><br/>· <a class="ae mt" href="#34a2" rel="noopener ugc nofollow">Numeric Separators: _</a><br/>· <a class="ae mt" href="#3058" rel="noopener ugc nofollow">Non-null assertion operator: !</a><br/>· <a class="ae mt" href="#79be" rel="noopener ugc nofollow">Optional notation: </a><a class="ae mt" href="#79be" rel="noopener ugc nofollow">?</a><br/>  ∘ <a class="ae mt" href="#5a19" rel="noopener ugc nofollow">Optional Chaining: ?.</a><br/>  ∘ <a class="ae mt" href="#e877" rel="noopener ugc nofollow">Optional Properties: ?:</a><br/>· <a class="ae mt" href="#9eb1" rel="noopener ugc nofollow">Nullish coalescing operator: ??</a><br/>· <a class="ae mt" href="#99e0" rel="noopener ugc nofollow">Private property: #</a><br/>· <a class="ae mt" href="#a77d" rel="noopener ugc nofollow">Angle brackets: &lt;&gt;</a><br/>  ∘ <a class="ae mt" href="#8e31" rel="noopener ugc nofollow">Type assertion</a><br/>  ∘ <a class="ae mt" href="#f35d" rel="noopener ugc nofollow">Generic types</a><br/>· <a class="ae mt" href="#46d3" rel="noopener ugc nofollow">Decorators: @</a></span></pre></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="019f" class="nb ls iq bd lt nc nd ne lw nf ng nh lz jw ni jx mc jz nj ka mf kc nk kd mi nl bi translated">1.工会类型:|</h1><p id="7483" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">在JavaScript中，<code class="fe nr ns nt ml b">|</code>是位操作的符号:</p><blockquote class="nu nv nw"><p id="69ea" class="kv kw nx kx b ky kz jr la lb lc ju ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">按位OR运算符(<code class="fe nr ns nt ml b"><em class="iq">|</em></code>)在每个位位置返回一个<code class="fe nr ns nt ml b"><em class="iq">1</em></code>，其中一个或两个操作数的对应位为<code class="fe nr ns nt ml b"><em class="iq">1</em></code></p></blockquote><p id="3cf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，类似这样的JavaScript代码将在运行时在控制台中打印7:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="b1d6" class="lr ls iq ml b gy mp mq l mr ms">const a = 5;<br/>const b = 3;</span><span id="0090" class="lr ls iq ml b gy ob mq l mr ms">console.log(a | b);<br/>// expected output: 7</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6dcd3d40445fbf19ce5751270a04868e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*3FGuYj0I04X4AfvwkR_oiA.png"/></div></figure><p id="9a25" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是如何工作的？</p><p id="d956" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为5的二进制表示是<code class="fe nr ns nt ml b">101</code>，3的二进制表示是<code class="fe nr ns nt ml b">011</code>。用OR计算对应的位，得到<code class="fe nr ns nt ml b">111</code>，十进制是7。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/2d6763a216988eef7127cdc31e74564f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLvsv4VIvFrfiJfQAKl33A.png"/></div></div></figure><p id="1adf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然TypeScript是JavaScript的扩展，但您也可以在TS代码中使用该运算符。</p><p id="d553" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类型脚本代码:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="80bc" class="lr ls iq ml b gy mp mq l mr ms">let a: number = 5;<br/>let b: number = 3</span><span id="8f0d" class="lr ls iq ml b gy ob mq l mr ms">console.log(a | b)<br/>// 7</span></pre><p id="0b52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在TypeScript中，我们也使用<code class="fe nr ns nt ml b">|</code>来表示联合类型。</p><p id="54e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果变量可以是字符串或数字，我们可以这样写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bcdda249adf3bd715edbd3ae47c5ef15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHAJRc6-vjkFW6qsOh0Q7g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">TypeScript Code</figcaption></figure><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d7b5" class="lr ls iq ml b gy mp mq l mr ms">let val: string | number;<br/>val = 1;<br/>val = "hi";</span></pre><p id="bfb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有时一个类型只有几个可能的值，所以我们也可以用联合类型来表示它们。例如，常用的HTTP方法只有几种，我们可以这样定义它们:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/40c5fde17757547ed699914f3aac9cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChwUcJaLeKqnvi5hZYyw6Q.png"/></div></div></figure><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="b155" class="lr ls iq ml b gy mp mq l mr ms">type HttpMethod = "GET" | "POST" | "PATCH" | "DELETE";</span><span id="6e85" class="lr ls iq ml b gy ob mq l mr ms">function <em class="nx">xhr</em>(method: HttpMethod, url: string): void {<br/>    console.log(`${method}: ${url}`);<br/>}</span></pre><p id="a252" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们使用上述函数时，我们可以看到TypeScript为我们提供的类型检查:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/97abff6aefd536090a37928e33edb22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRpX6F_VzOGLc2U1j3HUmQ.png"/></div></div></figure><p id="8a95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TS会提醒我们<code class="fe nr ns nt ml b">xhr</code>方法不支持<code class="fe nr ns nt ml b">Get</code>作为参数，这有助于我们避免许多可能的类型错误。</p><p id="7834" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看另一个奇怪的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/44b6fcfb649a485dba5e2471ec32b5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHUejtb-PzbdjbaP5l4RqA.png"/></div></div></figure><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="9fb6" class="lr ls iq ml b gy mp mq l mr ms">type BooleanType = 0 | 1;</span><span id="cf70" class="lr ls iq ml b gy ob mq l mr ms">let flag: BooleanType;</span><span id="5316" class="lr ls iq ml b gy ob mq l mr ms">flag = (0 | 1) as BooleanType;</span><span id="8962" class="lr ls iq ml b gy ob mq l mr ms">console.log(flag);</span></pre><p id="5fde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何理解这个代码？</p><p id="4232" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们定义一个BooleanType。该类型的可能值为0或1，符号<code class="fe nr ns nt ml b">|</code>代表联合类型。然后我们声明一个BooleanType类型的变量flag。</p><p id="22c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们把<code class="fe nr ns nt ml b">0 | 1</code>的值赋给<code class="fe nr ns nt ml b">flag</code>，这里的<code class="fe nr ns nt ml b">|</code>是按位运算符。为了确保类型兼容性，我们使用<code class="fe nr ns nt ml b">as</code>操作符强制<code class="fe nr ns nt ml b">0 | 1</code>的结果为BooleanType。</p><p id="68e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，上面代码运行的结果是1。</p><p id="3969" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，这段代码实际上没有任何意义，但我这样写是为了向您展示<code class="fe nr ns nt ml b">|</code>的两种用法。嗯，我似乎把事情变得更奇怪了…</p><h1 id="7d7d" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">2.交叉点类型:&amp;</h1><p id="c02a" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">与<code class="fe nr ns nt ml b">|</code>类似，在JavaScript中，<code class="fe nr ns nt ml b">&amp;</code>也是位操作的符号:</p><blockquote class="nu nv nw"><p id="3694" class="kv kw nx kx b ky kz jr la lb lc ju ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">按位AND运算符(<code class="fe nr ns nt ml b"><em class="iq">&amp;</em></code>)在两个操作数的相应位为<code class="fe nr ns nt ml b"><em class="iq">1</em></code> s的每个位位置返回一个<code class="fe nr ns nt ml b"><em class="iq">1</em></code></p></blockquote><p id="c178" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在TypeScript中，<code class="fe nr ns nt ml b">&amp;</code>也可以用来表示类型交集。<br/>例如，有两个接口:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="0193" class="lr ls iq ml b gy mp mq l mr ms">interface Runnable{<br/>    run(): void;<br/>}</span><span id="bc9e" class="lr ls iq ml b gy ob mq l mr ms">interface Swimmable{<br/>    swim(): void;<br/>}</span></pre><p id="8ef9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们想定义一个新的类型，鹅，鹅既能跑又能游泳，那么我们怎么做呢？</p><p id="0e69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们只需要用<code class="fe nr ns nt ml b">&amp;</code>将两种类型结合在一起:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="2bb3" class="lr ls iq ml b gy mp mq l mr ms">type Goose = Runnable &amp; Swimmable;</span></pre><p id="8c2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是TS代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/868e9f71376ba3300a4ccdbed0f874b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWxw90bMyNQ7chYABuWPzQ.png"/></div></div></figure><p id="0fa9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果参数不满足两个接口，编译器将报告一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/a0a85f7e8e8e0310863a4957e36b20bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRu9YzRxzJ8WPMXRdhPR7g.png"/></div></div></figure><h1 id="34a2" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">3.数字分隔符:_</h1><p id="b3b6" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">这个符号是用来分隔数字的。这实际上是一个JavaScript语法，但我发现它很有用，所以我就把它留在这里。</p><p id="4b1e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们写一个大的数字时，我们可能会这样写:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="90f4" class="lr ls iq ml b gy mp mq l mr ms">let total = 12123421;</span></pre><p id="4361" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，由于数字太长，读码的人往往要花几秒钟才能数清数字的长度。不使用数字分隔符，我们可以写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a69702b3b09a2949e799a60661563889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*8nNPGwlW10e0fEGA0ooQcA.png"/></div></figure><p id="18a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe nr ns nt ml b">_</code>可以快速读出数字:121230421。<code class="fe nr ns nt ml b">_</code>用来分隔数字，没有实际意义。这样的语法糖果可以帮助我们写出更容易阅读的大数字。</p><h1 id="3058" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">4.非空断言运算符:！</h1><p id="83f5" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">在JavaScript中，<code class="fe nr ns nt ml b">!</code>是用于反转布尔值的逻辑运算符。</p><blockquote class="nu nv nw"><p id="6266" class="kv kw nx kx b ky kz jr la lb lc ju ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">逻辑NOT ( <code class="fe nr ns nt ml b"><em class="iq">!</em></code>)运算符(逻辑补码、否定)将真转化为假，反之亦然。</p></blockquote><p id="501e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是JavaScript代码:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e9d4" class="lr ls iq ml b gy mp mq l mr ms">!false // return true</span><span id="d027" class="lr ls iq ml b gy ob mq l mr ms">!true // return false</span><span id="3a65" class="lr ls iq ml b gy ob mq l mr ms">let flag = false;<br/>flag = !flag;<br/>console.log(flag); // true</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d344cc641f2b7f65cd4436aee48a1399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*byacdkE_RTVVRVWv9MNTYg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Chrome Console</figcaption></figure><p id="3f03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在TypeScript中，您仍然可以将它用作逻辑运算符。然而，这种符号还有一个额外的用途。</p><p id="26f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这样的类型脚本代码为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/979f29bea02ca79fbc13b37ecfb15411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWAirZHF0gGe2MQglK4D9Q.png"/></div></div></figure><p id="70cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，<code class="fe nr ns nt ml b">reverse</code>函数接受一个字符串作为参数。<code class="fe nr ns nt ml b">maybeString</code>的类型是字符串和null的联合类型。如果我们直接使用<code class="fe nr ns nt ml b">revere(maybeString)</code>，编译器会报错。</p><p id="3362" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但如果仔细看代码，我们知道<code class="fe nr ns nt ml b">Math.random()</code>总是返回一个从0到1的数，所以在执行这个三元表达式的时候，<code class="fe nr ns nt ml b">maybeString</code>一定是一个字符串，而不是null。</p><p id="d1cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以100%确定<code class="fe nr ns nt ml b">revere(maybeString)</code>是安全的，而编译器不能。在这种情况下，我们可以使用非空断言操作符:<code class="fe nr ns nt ml b">!</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/5293eba91f2b63e304c15aa580bc3050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOjVZ0IU_A9Y9V8F2ycCUw.png"/></div></div></figure><p id="f675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在自己的编译器中测试它，因此代码应该不会报告错误。</p><p id="80d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个符号告诉编译器:以一个程序员的尊严，我肯定变量不会为空(也不会未定义)。</p><p id="11eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种符号也可以用于函数调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/e6124c9a23fe90adb95addf3544fc01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3WOF88RtGkPHWuftLS6JQ.png"/></div></div></figure><p id="a1cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的函数中，如果我们直接调用<code class="fe nr ns nt ml b">getRandomString()</code>，编译器会警告我们该参数可能未定义。但是，如果您非常确定参数不会未定义，那么您可以使用非空断言操作符来断言它。</p><p id="1ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要注意的是，编译器的提示是合理的。使用<code class="fe nr ns nt ml b">!</code>时，需要确保操作安全。</p><h1 id="79be" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">5.可选符号:<code class="fe nr ns nt ml b">?</code></h1><p id="41b6" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">该符号有两个衍生用途:<code class="fe nr ns nt ml b">?.</code>和<code class="fe nr ns nt ml b">?:</code></p><h2 id="5a19" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">可选链接:？。</h2><p id="43d3" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">有时我们不确定一个对象是否具有某种属性，这会使我们的代码难以编写。</p><p id="6a92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一段JavaScript代码:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="f30f" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">getCity</em>(user){<br/>    return user.location.city<br/>}</span></pre><p id="072a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果参数没有位置字段，将在运行时导致错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/d8be5c22d7b8d5b440991332a6c92835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ho1V0E-Q3xNTBeQnyGQUzg.png"/></div></div></figure><p id="adf6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想用JavaScript编写更健壮的代码，我们只能这样做:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c580" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">getCity</em>(user){<br/>    return user.location ? user.location.city : undefined<br/>}</span></pre><p id="b89a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在尝试获取<code class="fe nr ns nt ml b">location.city</code>之前，检查一下<code class="fe nr ns nt ml b">user.location</code>属性是否存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/89e7b015b10a117c6fd6beaf6f379262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9MCaz5TJx6yjjUIzCLpzg.png"/></div></div></figure><p id="660b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这种写法有点麻烦，不那么方便。TS为我们提供了句法糖:<code class="fe nr ns nt ml b">?.</code></p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="f3b0" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">getCity</em>(user: any){<br/>    return user.location?.city<br/>}<br/><em class="nx">getCity</em>({name: 'Jon'})</span></pre><p id="e518" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果用ts-node执行上面的代码，就没问题了。如果<code class="fe nr ns nt ml b">user.location</code>为空或未定义，它将停止访问其city属性。这确保了我们的代码是安全的。</p><p id="033f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们使用<code class="fe nr ns nt ml b">tsc</code>编译上面的代码，结果如下所示:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="320f" class="lr ls iq ml b gy mp mq l mr ms">function getCity(user) {<br/>    var _a;<br/>    return (_a = user.location) === null || _a === void 0 ? void 0 : _a.city;<br/>}</span></pre><p id="c59f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，<code class="fe nr ns nt ml b">void 0</code>等于<code class="fe nr ns nt ml b">undefined</code>。原因可以看<a class="ae mt" href="https://stackoverflow.com/questions/7452341/what-does-void-0-mean" rel="noopener ugc nofollow" target="_blank">关于栈溢出</a>的回答。如果<code class="fe nr ns nt ml b">user.location</code>等于null或undefined，则返回undefined，而不是获取<code class="fe nr ns nt ml b">location.city</code>属性。</p><p id="80f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种符号也可以用于函数调用。下面是一段JavaScript代码:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="82e9" class="lr ls iq ml b gy mp mq l mr ms">function run(obj){<br/>    obj.run()<br/>}</span></pre><p id="acd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数和上一个有同样的缺点，就是我们不确定<code class="fe nr ns nt ml b">obj</code>是否有run方法，如果没有，运行时会报错。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/1744d17245c44b30cc54908c70f203ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQw3mHkqVDxHaI2n5-H_DA.png"/></div></div></figure><p id="c110" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以编写这样的打字稿代码:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="58ba" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">run</em>(obj: any){<br/>    obj.run?.()<br/>}</span><span id="deb7" class="lr ls iq ml b gy ob mq l mr ms"><em class="nx">run</em>({})</span></pre><p id="ef70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个代码和以前一样。如果<code class="fe nr ns nt ml b">obj.run</code>不存在，则不调用该方法。</p><h2 id="e877" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">可选属性:？：</h2><p id="b7d8" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">除了在尝试获取属性时使用可选操作符之外，我们还可以在定义属性时使用它们。</p><p id="6325" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，以下代码将在编译时引发错误:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="bd95" class="lr ls iq ml b gy mp mq l mr ms">interface User{<br/>    name: string;<br/>    email: string;<br/>}</span><span id="02c7" class="lr ls iq ml b gy ob mq l mr ms">let user1: User = {<br/>    name: "Jon",<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/8321c7bc1ff39c3b59e230ff486ada1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkIY-mUXuaCU7vvVQ7oiRw.png"/></div></div></figure><p id="281f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为编译器期望<code class="fe nr ns nt ml b">user1</code>有两个属性:name和email。</p><p id="ab0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是在实际项目中，我们可能认为姓名是必需的，电子邮件是可选的。在这种情况下，我们可以编写这样的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/4047d05b9f7ba1aa273cecad3247b243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*z_ElwxoDl5NcZAwBmrbO8g.png"/></div></figure><p id="b040" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们给它添加了一个可选符号<code class="fe nr ns nt ml b">?</code>，告诉编译器这个属性是可选的。编译上述代码后，不会返回错误。</p><h1 id="9eb1" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">6.无效合并运算符:？？</h1><p id="dedf" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated"><code class="fe nr ns nt ml b">??</code>:如果左操作数为空或未定义，则返回右操作数，否则返回左操作数。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="01bc" class="lr ls iq ml b gy mp mq l mr ms">let foo = null ?? "default string";<br/>console.log(foo); // default string</span><span id="5412" class="lr ls iq ml b gy ob mq l mr ms">let bar = 0 ?? "default string";<br/>console.log(bar); // 0</span><span id="e813" class="lr ls iq ml b gy ob mq l mr ms">let value = "value" ?? "default string";<br/>console.log(value); // value</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/29b3b310761ceb88de52596ec4e5a206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4eYzPonpDjQyAxscO4mqg.png"/></div></div></figure><h1 id="99e0" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">7.私有财产:#</h1><p id="d85f" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">类的私有属性是一个非常常见的需求，我们可以用<code class="fe nr ns nt ml b">#</code>符号来声明。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="3bf6" class="lr ls iq ml b gy mp mq l mr ms">class Person{<br/>    #name: string;</span><span id="b453" class="lr ls iq ml b gy ob mq l mr ms">    constructor(name: string) {<br/>        this.#name = name<br/>    }</span><span id="4347" class="lr ls iq ml b gy ob mq l mr ms">    greet(){<br/>        console.log(`Hello, I am ${this.#name}`)<br/>    }<br/>}</span></pre><p id="2e0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一个字段以<code class="fe nr ns nt ml b">#</code>开头，那么你不能在类方法之外访问这个属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/f1a4fbea3a32aef7024648f797bd44ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMFeQgI7rbsLt4MPm2I-Iw.png"/></div></div></figure><p id="a898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你们中的一些人可能也知道<code class="fe nr ns nt ml b">private</code>关键字也可以用来声明私有字段，那么有什么区别呢？</p><p id="b821" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">答案是由<code class="fe nr ns nt ml b">private</code>关键字声明的私有属性实际上存在于实例中，我们可以强制访问它们。由<code class="fe nr ns nt ml b">#</code>声明的私有属性不直接存储在实例中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/a35a0d0439230510a21ea9648448b357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bM0HAd_5z_Q3WIPn8AXzA.png"/></div></div></figure><p id="ec7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以先将对象转换为<code class="fe nr ns nt ml b">any</code>类型，然后访问由<code class="fe nr ns nt ml b">private</code>定义的私有字段，这对于由<code class="fe nr ns nt ml b">#</code>定义的私有字段是不可能的。</p><h1 id="a77d" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">8.尖括号:&lt;&gt;</h1><p id="ac11" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">这种符号用在两个地方:一个用于类型断言，一个用于泛型类型。</p><h2 id="8e31" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">类型断言</h2><p id="b68a" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">以下代码在编译时会产生错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/0544c24a08d47b1dd4a4223dbb79c97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xzdvbuzTHroJarBHKnZPA.png"/></div></div></figure><p id="b2cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为编译器认为<code class="fe nr ns nt ml b">someValue</code>要么是字符串，要么是数字，所以它与<code class="fe nr ns nt ml b">doubleString</code>参数类型不匹配。但是当我们分析代码的时候，我们知道<code class="fe nr ns nt ml b">someValue</code>一定是一个字符串。然后我们可以使用类型断言告诉编译器变量必须是字符串。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/38c79e9697f8b1f9d8d8cd60a9b9589a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uCx6LjG-8VbqRHC0dN89w.png"/></div></div></figure><p id="a00c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这次编译上面的代码不会返回错误。</p><p id="6d3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，TSLint不建议这样写；相反，它建议使用<code class="fe nr ns nt ml b">as</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/3a2d1c3af7f9c978c5e7a4ad532e1f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgzMpzy94amsMtJ9pD1hUQ.png"/></div></div></figure><p id="8b5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两种语法的效果是一样的:它们断言变量的类型。</p><h1 id="f35d" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">9.泛型类型</h1><p id="408d" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">使用TypeScript给我们一个类型系统，帮助我们编写更安全的代码。但是这也牺牲了JavaScript的灵活性。</p><p id="f23a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果我们要写一个<code class="fe nr ns nt ml b">add</code>函数，它需要两个参数。如果参数是字符串，则将它们连接在一起；如果参数是数字，则将它们相加:</p><p id="2367" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript中，这段代码非常简单:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="fd97" class="lr ls iq ml b gy mp mq l mr ms">function add(a, b){<br/>  return a + b<br/>}</span></pre><p id="168d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，在TypeScript中很难实现。你不能这样写:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="cc54" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">add</em>(a: string | number, b: string | number) {<br/>    return a + b;<br/>}</span></pre><p id="4ae4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为不能直接添加这样的联合类型，所以编译上面的代码将会返回一个错误。</p><p id="3cb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者你可以写:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="0c65" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">addString</em>(a: string, b: string) {<br/>    return a + b;<br/>}</span><span id="4e6d" class="lr ls iq ml b gy ob mq l mr ms">function <em class="nx">addNumber</em>(a: number, b: number) {<br/>    return a + b;<br/>}</span></pre><p id="94b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样写是可以的，但是很麻烦。</p><p id="f277" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，在上述两个函数中，它们具有相同的主体。唯一的区别是一个处理字符串参数，另一个处理数字参数。</p><p id="d0e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也可以把类型看作是需要传递的参数。在这种情况下，我们可以写:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="a465" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">add</em>&lt;T&gt;(a: T, b: T){<br/>    return a as any + b<br/>}</span></pre><p id="0222" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码意味着<code class="fe nr ns nt ml b">add</code>函数还不确定它需要处理什么类型的数据，所以我们在使用它的时候可以将类型作为参数传递。</p><p id="e2a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/17e46a63a5ffa21974e7ab6ca8aef72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pOdsK7azhS8zhLAJigxtw.png"/></div></div></figure><p id="31a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，我们的<code class="fe nr ns nt ml b">add</code>函数可以处理字符串和数字，甚至BigInt。</p><p id="cdf9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">泛型让我享受到了类型系统的安全性，又不失JavaScript的灵活性。</p><h1 id="46d3" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">10.装饰者:@</h1><p id="1a61" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">假设我们有这样一个函数:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="b228" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">hello</em>(name) {<br/>    console.log("Hello " + name)<br/>}</span></pre><p id="0497" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们每次调用<code class="fe nr ns nt ml b">hello</code>都想打印一个日志，那怎么办呢？</p><p id="7c45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript中，没有办法直接做到这一点，但是我们可以用装饰函数包装<code class="fe nr ns nt ml b">hello</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/90792041ff3c97e1c05a09e876771f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La0JZZqNrJNPFURMbiZ2vQ.png"/></div></div></figure><p id="81f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d48f" class="lr ls iq ml b gy mp mq l mr ms">Start execute function "hello" at 2021-03-17T04:15:47.724Z<br/>Hello Jack</span></pre><p id="fc4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是在JavaScript中，这并不优雅。TS提供了一个装饰语法来更好地实现这一点。</p><p id="6545" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，下面是我们的朋友类:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="03ce" class="lr ls iq ml b gy mp mq l mr ms">class Friend {<br/>    name: string;<br/>    constructor(name: string) {<br/>        this.name = name<br/>    }</span><span id="5779" class="lr ls iq ml b gy ob mq l mr ms">    hello() {<br/>        console.log(this.name + " says: Hello")<br/>    }<br/>}</span></pre><p id="2bdc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们想在调用<code class="fe nr ns nt ml b">hello</code>方法时打印一个日志，所以我们可以指定一个装饰函数<code class="fe nr ns nt ml b">logging</code>来装饰方法<code class="fe nr ns nt ml b">hello</code>。</p><p id="60f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果要定义一个装饰类方法的装饰器，装饰器函数必须采用以下格式:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="a190" class="lr ls iq ml b gy mp mq l mr ms">function <em class="nx">logging</em>(target: any, propertyKey: string,<br/>                 descriptor: PropertyDescriptor) {<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/e99a2b97e7c3a1f64fe0b288d70e8dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uRwXhZ97aVqc4LeG9C5Tw.png"/></div></div></figure><p id="32be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<code class="fe nr ns nt ml b">target</code>是将来调用方法的实例对象，<code class="fe nr ns nt ml b">propertyKey</code>是对应方法的属性名，<code class="fe nr ns nt ml b">descriptor</code>是属性描述符。这是装饰者必须遵循的固定语法。</p><p id="6f20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们就可以在日志方法中写具体的逻辑了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/0f516a0b52d45a3af1adbdddbea8af40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoT4r5ZuPY-02zPNiwU24Q.png"/></div></div></figure><p id="4ea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编译并运行上述代码后，控制台应该会显示如下内容:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="7ca9" class="lr ls iq ml b gy mp mq l mr ms">Start execute function "hello" at 2021-03-17T01:31:11.607Z<br/>Jon says: Hello</span></pre><p id="1e1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">装饰者在不修改方法本身的情况下向现有方法添加新功能。想象一下，如果我们需要向许多类方法添加日志功能，我们可以简单地在每个类方法前面添加一个装饰器，而不改变方法本身。</p><h2 id="0ad8" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">装饰工厂</h2><p id="057a" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">以前的日志装饰器仅限于打印日期消息。事实上，我们可以利用装饰工厂，批量生产不同特点的装饰工。</p><p id="81cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/0f27b7d12ee4ba561df8b0b7702aa9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVDUvPPqeiElDFDJDU564Q.png"/></div></div></figure><p id="0de6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的函数中，每次调用loggingFactory时，它都返回不同的decorator，以便可以定制功能。</p><p id="75c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是它的使用方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/4ceba540c9781819771a58c46b0a0f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drBrmdgHS4hCsVqwdNQc6Q.png"/></div></div></figure><p id="f07c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编译并执行上述代码，结果如下:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="1eb3" class="lr ls iq ml b gy mp mq l mr ms">Start execute function "hello" at 2021-03-17T01:49:05.087Z<br/>message: executing Person#hello<br/>Jon says: Hello</span></pre><h1 id="8118" class="nb ls iq bd lt nc oi ne lw nf oj nh lz jw ok jx mc jz ol ka mf kc om kd mi nl bi translated">结论</h1><p id="51d1" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">我们做到了！我希望这有助于澄清TypeScript中的一些特性以及随之而来的一些复杂性。一定要在评论里让我知道你的想法。谢谢！</p></div></div>    
</body>
</html>