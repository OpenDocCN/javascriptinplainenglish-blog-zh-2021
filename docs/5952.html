<html>
<head>
<title>Implement HTTP Client with Interceptor using Plain JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用普通JavaScript实现带有拦截器的HTTP客户端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-http-client-with-interceptor-using-plain-javascript-49eec08a7f21?source=collection_archive---------6-----------------------#2021-12-21">https://javascript.plainenglish.io/implement-http-client-with-interceptor-using-plain-javascript-49eec08a7f21?source=collection_archive---------6-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3d68c30b8f23403c0ec0591eedb9c99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*om_WDdNgXxptJVXiHjfm7g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="a456" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从头开始构建东西总是令人着迷的。总是有可能使用像<a class="ae jd" href="https://axios-http.com/" rel="noopener ugc nofollow" target="_blank"> Axios </a>这样的库。然而，从头开始构建不仅有助于理解编程语言。这也有助于您提高性能。在本文中，我们将使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> JavaScript Fetch </a>来构建一个HTTP客户端。类似的过程可以在Node.js中使用<a class="ae jd" href="https://nodejs.org/api/http.html" rel="noopener ugc nofollow" target="_blank"> HTTP </a>模块。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lb"><img src="../Images/ec79aaf27ee39b45970cfbd03c50f54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AidrcoVnSp0wNYHS"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@barnimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Barn Images</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="9af3" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">先决条件</h2><ol class=""><li id="0e98" class="lz ma jg kf b kg mb kk mc ko md ks me kw mf la mg mh mi mj bi translated">基本了解最新JavaScript (ES6及以上)——<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">传播运算符</a>、<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">方法速记</a></li><li id="9d62" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">异步编程的基本理解— <a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank">异步等待</a>。</li><li id="2d4b" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">对<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取</a>的基本理解</li></ol><h2 id="f5ef" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">目录</h2><ol class=""><li id="3ceb" class="lz ma jg kf b kg mb kk mc ko md ks me kw mf la mg mh mi mj bi translated">创建一个模拟服务器</li><li id="8a05" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">添加服务类别</li><li id="ef9e" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">构建一个简单的HTTP客户端模块</li><li id="7bf9" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">实现拦截器模式</li></ol><h2 id="f772" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">1.创建一个模拟服务器</h2><p id="1701" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在构建实际的HTTP客户端模块之前，我们需要处理数据。您可以使用任何JSON数据源。然而，对于本文，我们将创建一个带有一些基本端点的模拟服务器。我们还将为HTML和JavaScript添加一些静态文件。</p><p id="96ec" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">添加JSON服务器</strong> <br/>添加JSON服务器相当简单。您可以使用<strong class="kf jh"> npx </strong>命令动态启动JSON服务器。</p><p id="7462" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个文件<strong class="kf jh"> db.json </strong>，文件夹<strong class="kf jh"> public </strong>。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="c53c" class="lg lh jg mt b gy mx my l mz na">md intercepter-demo<br/>cd intercepter-demo<br/>md public<br/>touch db.json public/index.html public/app.js</span></pre><p id="c759" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加下面的代码。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b545" class="lg lh jg mt b gy mx my l mz na"><strong class="mt jh">// db.json</strong></span><span id="4b0e" class="lg lh jg mt b gy nb my l mz na">{<br/>  "users": [<br/>    {<br/>      "name": "deepak",<br/>      "age": 32,<br/>      "address": "not found"<br/>    }<br/>  ]<br/>}</span><span id="9aae" class="lg lh jg mt b gy nb my l mz na"><strong class="mt jh">// public/index.html</strong></span><span id="3606" class="lg lh jg mt b gy nb my l mz na">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>    &lt;title&gt;Implementing HTTP Client with Interceptor using Plain JavaScript&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Open Console using inspector&lt;/h1&gt;<br/>    <strong class="mt jh">&lt;script src="app.js"&gt;&lt;/script&gt;</strong><br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span><span id="8c98" class="lg lh jg mt b gy nb my l mz na"><strong class="mt jh">// public/app.js</strong></span><span id="beb7" class="lg lh jg mt b gy nb my l mz na">console.log("Welcome to How To Write Services Using JavaScript")</span></pre><p id="380a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以使用命令<code class="fe nc nd ne mt b">npx json-server db.json. </code>启动服务器。该命令可能会要求您安装一个模块。按(Y)继续。可以打开<a class="ae jd" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>查看变化。可以访问<a class="ae jd" href="http://localhost:3000/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users</a>获取用户列表。</p><h2 id="6b57" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">2.添加服务类别</h2><p id="0f19" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">既然我们的<strong class="kf jh"> app.js </strong>现在已经在工作了。我们可以开始添加代码了。为了添加服务模块，我将使用一个对象。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="175d" class="lg lh jg mt b gy mx my l mz na">// app.js</span><span id="3af5" class="lg lh jg mt b gy nb my l mz na">const services = {<br/>  getUsers() {<br/>    // TODO<br/>  },<br/>  createUser(user) {<br/>    // TODO<br/>  }<br/>}<br/>services.getUsers().then(console.log)<br/>services.createUser({<br/>  "id": Date.now(),<br/>  "name": "deepak2",<br/>  "age": 32,<br/>  "address": "not found2"<br/>}).then(console.log)</span></pre><p id="1f19" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经注意到了，我正在使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">方法简写</a>在一个对象中创建函数。您可以将这些代码移动到一个单独的文件中，并将<code class="fe nc nd ne mt b">export default services</code>作为一个外部模块。</p><p id="2eec" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们已经有了<a class="ae jd" href="http://localhost:3000/users" rel="noopener ugc nofollow" target="_blank">/用户</a>端点。让我们添加通过服务模块获取用户的基本代码。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="76dc" class="lg lh jg mt b gy mx my l mz na"><strong class="mt jh">const apiHost = `</strong><a class="ae jd" href="http://localhost:3000`" rel="noopener ugc nofollow" target="_blank"><strong class="mt jh">http://localhost:3000`</strong></a><br/>const services = {<br/>  getUsers() {<br/>    <strong class="mt jh">return fetch(`${apiHost}/users`)</strong><br/>  },<br/>  createUser(user) {<br/>    <strong class="mt jh">return fetch(`${apiHost}/users`, {<br/>      method: 'POST',<br/>      headers: { 'Content-Type': "application/json" },<br/>      body: JSON.stringify(user)<br/>    })</strong><br/>  },<br/>  updateUser({ id, ...user }) {<br/>    <strong class="mt jh">return fetch(`${apiHost}/users`, {<br/>      method: 'PUT',<br/>      headers: { 'Content-Type': "application/json" },<br/>      body: JSON.stringify(user)<br/>    })</strong><br/>  }<br/>}<br/>const id = Date.now();</span><span id="e62b" class="lg lh jg mt b gy nb my l mz na">services.getUsers().then(console.log)<br/>services.createUser({<br/>  "id": id,<br/>  "name": "deepak2",<br/>  "age": 32,<br/>  "address": "not found2"<br/>}).then(console.log)</span><span id="2cc1" class="lg lh jg mt b gy nb my l mz na">services.updateUser({<br/>  "id": id,<br/>  "name": "deepak2",<br/>  "age": 33,<br/>  "address": "not found2"<br/>}).then(console.log)</span></pre><p id="4427" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">刷新<a class="ae jd" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>页面后，您将在浏览器的控制台中看到日志。</p><p id="9f34" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你看到上面的代码，大量的样板代码必须反复编写。为了避免这种情况，我们可以构建一个包装器HTTP客户端。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/2a3aad3ec57518d3ef32e0eb5457bd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-mDUWzJJLCFrLiGg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cytonn Photography</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="be58" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">3.构建一个简单的HTTP客户端模块</h2><p id="f3bf" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">HTTP客户端必须支持GET、POST、PUT和DELETE协议。Fetch只有一个方法fetch来支持所有的协议。然而，作为关注点分离(SOC ),我们应该分成多个方法。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="dfbf" class="lg lh jg mt b gy mx my l mz na">const http = {<br/>  async get(url, options = {}) {<br/>    // TODO<br/>  },<br/>  async post(url, body = {}, options = {}) {<br/>    // TODO<br/>  },<br/>  async put(url, body = {}, options = {}) {<br/>    // TODO<br/>  },<br/>  async delete(url, body = {}, options = {}) {<br/>    // TODO<br/>  },<br/>  async request(url, body = {}, options = {}) {<br/>    <strong class="mt jh">options.headers = {<br/>      'Content-Type': "application/json",<br/>      ...options.headers,<br/>    };<br/>    const res = await fetch(url, {<br/>      body: body ? JSON.stringify(body) : undefined,<br/>      ...options,<br/>    });<br/>    return res.json()</strong><br/>  }<br/>}</span></pre><p id="a317" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<strong class="kf jh">请求</strong>是处理所有边缘情况的辅助方法。如果你想定制一个请求，你可以使用<strong class="kf jh">请求</strong>方法。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="b6a5" class="lg lh jg mt b gy mx my l mz na">const http = {<br/>  async get(url, options = {}) {<br/>    <strong class="mt jh">return this.request(url, null, options)</strong><br/>  },<br/>  async post(url, body = {}, options = {}) {<br/>    <strong class="mt jh">return this.request(url, body, { ...options, method: "POST" })</strong><br/>  },<br/>  async put(url, body = {}, options = {}) {<br/>    // TODO<br/>  },<br/>  async delete(url, body = {}, options = {}) {<br/>    // TODO<br/>  },<br/>  async request(url, body = {}, options = {}) {<br/>    options.headers = {<br/>      'Content-Type': "application/json",<br/>      ...options.headers,<br/>    };<br/>    const res = await fetch(url, {<br/>      body: body ? JSON.stringify(body) : undefined,<br/>      ...options,<br/>    });<br/>    return res.json()<br/>  }<br/>}</span></pre><p id="621d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在HTTP客户端更新之后，让我们看看如何修改服务类。许多样板代码已经转移到客户端。因此，服务等级将是精简的。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="6443" class="lg lh jg mt b gy mx my l mz na">const services = {<br/>  getUsers() {<br/>    <strong class="mt jh">return http.get(`${apiHost}/users`)</strong><br/>  },<br/>  createUser(user) {<br/>    <strong class="mt jh">return http.post(`${apiHost}/users`, user)</strong><br/>  },<br/>  updateUser({ id, ...user }) {<br/>    return http.put(`${apiHost}/users/${id}`, user)<br/>  }<br/>}</span><span id="16c8" class="lg lh jg mt b gy nb my l mz na">// Rest of the code.</span></pre><figure class="lc ld le lf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/8431c92c60611ae9f77b92d7a9b51b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S19HGYpGk80IR4FF"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@hobiindustri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hobi industri</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="d47c" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">4.实现拦截器模式</h2><p id="2095" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果你使用过Axios或express.js这样的模块，你可能知道拦截器或中间件的概念。拦截器是函数或模块，它们根据请求或响应的实现方式来拦截请求或响应。使用拦截器的最大用途是根据条件为每个请求或响应添加公共代码。在本文中，我们将关注一个简单的用例，您希望基于URL模式在每个路由上添加一个<strong class="kf jh">授权令牌</strong>。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="31a1" class="lg lh jg mt b gy mx my l mz na">const http = {<br/>  <strong class="mt jh">cb: [],<br/>  intercept(cb) {<br/>    this.cb.push(cb);<br/>  },</strong><br/>  async get(url, options = {}) {<br/>    return this.request(url, null, options)<br/>  },<br/>  // Rest of the code<br/>  async request(url, body = {}, options = {}) {<br/>    options.headers = {<br/>      'Content-Type': "application/json",<br/>      ...options.headers,<br/>    };<br/>    <strong class="mt jh">// Iterate all interceptors to modify the options<br/>    if (this.cb.length) {<br/>      for (let fn of this.cb) {<br/>        options = fn(options, url);<br/>      }<br/>    }</strong><br/>    const res = await fetch(url, {<br/>      body: body ? JSON.stringify(body) : undefined,<br/>      ...options,<br/>    });<br/>    return res.json()<br/>  }<br/>}<br/><strong class="mt jh">const authInterceptor = (options, url) =&gt; {<br/>  if (/users/.test(url) &amp;&amp; options.method === "POST")<br/>    options.headers.Authorization = 'Bearer sometoken';<br/>  return options<br/>}<br/>http.intercept(authInterceptor)</strong></span><span id="5cd3" class="lg lh jg mt b gy nb my l mz na">// Rest of the code</span></pre><p id="fa62" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你运行了上面的代码并且查看了网络调用。您会发现<strong class="kf jh">授权‘不记名令牌’</strong>将被添加到<strong class="kf jh">/用户发布</strong>呼叫中。您可以根据需要添加更多拦截器。</p><h2 id="cd92" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">结论</h2><p id="ee5a" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">本文简单演示了普通JavaScript的fetch模块的用法。这并不意味着，我鼓励你在生产环境中使用这些代码。我仍然建议您为您的生产代码选择一个好的库。但是，出于您自己的学习目的，您可以扩展这个版本的代码。</p><p id="e7e3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:你可以在下面的Gist URL中获得app.js代码</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="7a61" class="lg lh jg bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated"><strong class="ak">奖励:如何使用拦截器在Axios中添加授权头</strong></h2><p id="5d87" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">要向任何请求添加头，可以使用持久性数据存储，如localStorage、sessionStorage。根据条件，您可以向请求添加令牌。</p><pre class="lc ld le lf gt ms mt mu mv aw mw bi"><span id="de75" class="lg lh jg mt b gy mx my l mz na">// Global Level<br/>axios.interceptors.request.use(function () {<br/>  <strong class="mt jh">const token = sessionStorage.getItem("token");<br/>  config.headers.Authorization = token;<br/>  return config;</strong><br/>});</span><span id="d0ff" class="lg lh jg mt b gy nb my l mz na">// Individual Instance<br/>const instance = axios.create();<br/>instance.interceptors.request.use(function () {<br/>  <strong class="mt jh">const token = sessionStorage.getItem("token");<br/>  config.headers.Authorization = token;</strong><br/>  return config;<br/>});</span></pre><p id="a24d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">参考文献:</strong></p><ul class=""><li id="944d" class="lz ma jg kf b kg kh kk kl ko nj ks nk kw nl la nm mh mi mj bi translated">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"/></li><li id="5d0a" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la nm mh mi mj bi translated"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Functions/Method _ definitions</a></li><li id="c2d2" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la nm mh mi mj bi translated"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Spread _ syntax</a></li><li id="a737" class="lz ma jg kf b kg mk kk ml ko mm ks mn kw mo la nm mh mi mj bi translated"><a class="ae jd" href="https://axios-http.com/" rel="noopener ugc nofollow" target="_blank">https://axios-http.com</a></li></ul><p id="4d27" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nn">更多内容看</em> <a class="ae jd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="nn">说白了。</em> </strong> <em class="nn">报名参加我们的</em> </a><a class="ae jd" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="nn">免费每周简讯这里</em> </strong> </a> <strong class="kf jh"> <em class="nn">。</em> </strong></p></div></div>    
</body>
</html>