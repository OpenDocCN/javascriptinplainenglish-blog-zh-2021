<html>
<head>
<title>Advanced Asynchronous Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的高级异步编程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-asynchronous-programming-in-javascript-60ace6f7330b?source=collection_archive---------4-----------------------#2021-01-05">https://javascript.plainenglish.io/advanced-asynchronous-programming-in-javascript-60ace6f7330b?source=collection_archive---------4-----------------------#2021-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="74f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为程序员，我们总有一天会面临这个问题:异步编程(也称为非阻塞编程)并不容易。幸运的是，JavaScript是为数不多的能够很好地实现它的编程语言之一(至少从几年前开始)。这就是为什么我今天向您推荐一些比简单地发送HTTP请求并等待响应更高级的技术。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c9045d4b5d82af0ef9b49e609fbb2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_bgk7XaYYXBcFKe"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文面向对promises和async/await语法有所了解并希望了解更多的JavaScript程序员。如果你理解起来有困难，我可以向你推荐Mozilla的课程。本文包含使用<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank"> modern-async </a>开源库的例子。你可能想知道我是这个库的创建者，所以它可能会影响我的观点。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="b654" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">进行多个异步操作</h1><p id="9d15" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">让我们从简单的开始，假设我们有一些无处不在的操作叫做<code class="fe mj mk ml mm b">doSomething()</code>:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="1af3" class="mr lh in mm b gy ms mt l mu mv">async function doSomething () {<br/>  // we don't care what's in here<br/>}</span></pre><p id="4de6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们并不关心它有什么用。它可能会查询REST API，等待用户执行操作，等等。我们唯一知道的是，它是一个异步函数，我们在调用它时必须使用<code class="fe mj mk ml mm b">await</code>关键字。</p><p id="df2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打一次电话很容易。但是如果我们需要调用它n次呢？</p><p id="e2ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以简单地使用一个循环来实现:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="70d6" class="mr lh in mm b gy ms mt l mu mv">for (let i = 0; i &lt; 10; i += 1) {<br/>  await doSomething()<br/>}</span></pre><p id="9649" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">精彩！我们刚刚编写了一个算法，以一种顺序的方式执行多个异步调用。每个异步操作将一个接一个地执行。</p><p id="81e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该算法将完美运行。但是如果我们不想等待每个异步操作完成呢？毕竟，如果我们唯一要做的事情就是等待，我们也可以并行执行多个调用。</p><p id="b092" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样做有一个众所周知的模式:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="7a54" class="mr lh in mm b gy ms mt l mu mv">const promises = []<br/>for (let i = 0; i &lt; 10; i += 1) {<br/>  promises.push(doSomething())<br/>}<br/>await Promises.all(promises)</span></pre><p id="f266" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的微妙之处在于，我们在调用<code class="fe mj mk ml mm b">doSomething()</code>时不直接使用<code class="fe mj mk ml mm b">await</code>。相反，我们收集函数返回的<code class="fe mj mk ml mm b">Promise</code>对象(因为所有的异步函数都返回承诺),并且我们使用<code class="fe mj mk ml mm b">Promise.all()</code>函数将我们的承诺列表收集到一个单独的列表中，当所有的子承诺被解析时，该列表将被解析。然后，我们可以在“超级承诺”上使用<em class="mw">wait</em>。</p><p id="5a7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，那也可以。每个操作将与其他操作并行执行<em class="mw"/>。但是，如果我们没有一个代码示例在从0数到9时执行哑操作，那该怎么办呢？如果这是一个真实的用例，在迭代一个由用户填充的数组时执行耗费资源的REST查询，而这个数组可能包含成百上千个元素，那会怎么样呢？我们真的想并行处理数千个REST查询吗？实际上这不会发生，因为你的浏览器会拒绝执行太多的并行HTTP调用，反而会使你的代码崩溃。</p><p id="032d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们知道如何按顺序进行许多操作，也知道如何进行无限的并行操作。我们唯一怀念的是在有限的<em class="mw">并发性</em>下执行许多并行操作的能力。</p><p id="eeb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，这正是我们触及基本<code class="fe mj mk ml mm b">Promise</code> API极限的时候。当然，我们仍然会像使用<code class="fe mj mk ml mm b">async/await</code>一样使用它，因为它们太棒了。但是我们需要一些帮助来制造更先进的东西。这就是为什么我将使用<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank"> modern-async </a>库:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="4321" class="mr lh in mm b gy ms mt l mu mv">import { forEachLimit } from 'modern-async'</span><span id="0c8f" class="mr lh in mm b gy mx mt l mu mv">...</span><span id="34dc" class="mr lh in mm b gy mx mt l mu mv">const array = ... // our array</span><span id="7fb9" class="mr lh in mm b gy mx mt l mu mv">await forEachLimit(array, doSomething, 5)</span></pre><p id="788e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#forEachLimit" rel="noopener ugc nofollow" target="_blank">forEachLimit()</a></code>类似于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">Array.forEach()</a></code>的方法。唯一的区别是:</p><ul class=""><li id="0c63" class="my mz in jm b jn jo jr js jv na jz nb kd nc kh nd ne nf ng bi translated">这是一个接受异步回调的异步函数。当执行完所有要求的异步操作后，它将返回。</li><li id="681f" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated">它将并行调用它的异步回调多次，同时注意不要超过并发限制(这里是5)。</li></ul><p id="238c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们如何优化我们的代码来执行多个并行操作，同时避免探索极限或我们的资源尖叫“天空是极限！”。(…并认为不是)</p><h1 id="c09c" class="lg lh in bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">集合上更多的异步操作</h1><p id="7e1a" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们已经看到<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank"> modern-async </a>库包含一个名为<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#forEachLimit" rel="noopener ugc nofollow" target="_blank">forEachLimit()</a></code>的类似于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">Array.forEach()</a></code>的函数。但是还有很多其他有用的通用列表操作函数，比如<code class="fe mj mk ml mm b">map()</code>或<code class="fe mj mk ml mm b">find()</code>。</p><p id="a64e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，这个库包含了所有这些函数的异步替代品。以下是它们的列表:</p><ul class=""><li id="fbec" class="my mz in jm b jn jo jr js jv na jz nb kd nc kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#everyLimit" rel="noopener ugc nofollow" target="_blank">everyLimit()</a> </code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank">Array.every()</a></code></li><li id="b2b4" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#filterLimit" rel="noopener ugc nofollow" target="_blank">filterLimit()</a> </code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">Array.filter()</a></code></li><li id="9e5d" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#findLimit" rel="noopener ugc nofollow" target="_blank">findLimit()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noopener ugc nofollow" target="_blank">Array.find()</a></code></li><li id="a02d" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#findIndexLimit" rel="noopener ugc nofollow" target="_blank">findIndexLimit()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank">Array.findIndex()</a></code></li><li id="3a05" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#forEachLimit" rel="noopener ugc nofollow" target="_blank">forEachLimit()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">Array.forEach()</a></code></li><li id="c4c1" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#mapLimit" rel="noopener ugc nofollow" target="_blank">mapLimit()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.map()</a></code></li><li id="6242" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#reduce" rel="noopener ugc nofollow" target="_blank">reduce()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">Array.reduce()</a></code></li><li id="7102" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#reduceRight" rel="noopener ugc nofollow" target="_blank">reduceRight()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" rel="noopener ugc nofollow" target="_blank">Array.reduceRight()</a></code></li><li id="80ae" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#someLimit" rel="noopener ugc nofollow" target="_blank">someLimit()</a></code>相当于<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank">Array.some()</a></code></li></ul><p id="89b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些函数都有简化的等价物，以使常见用例更简短。在<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#filterLimit" rel="noopener ugc nofollow" target="_blank">filterLimit()</a></code>的例子中，我们还有<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#filterSeries" rel="noopener ugc nofollow" target="_blank">filterSeries()</a></code>(一个纯粹的顺序选择)和<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#filter" rel="noopener ugc nofollow" target="_blank">filter()</a></code>(一个纯粹的并行选择，对并发性没有限制)。</p><p id="9f50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些函数应该能够满足集合操作和异步编程的大部分需求。</p><h1 id="5804" class="lg lh in bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">等待呢？</h1><p id="dae4" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">有没有觉得现在的<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank">setTimeout()</a></code>功能调用起来很无聊？让我们来看看对它的最小调用:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="036c" class="mr lh in mm b gy ms mt l mu mv">setTimeout(() =&gt; {<br/>  ... // your code<br/>}, 300)</span></pre><p id="cfcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最少的调用只有3行代码，你会发现调用一个新函数的缺点。当你习惯了<code class="fe mj mk ml mm b">async/await</code>的时候，感觉有点老派和回调，不太符合那种语法。</p><p id="401b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank">modern-async</a></code>还包含一个名为<a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#sleep" rel="noopener ugc nofollow" target="_blank"> sleep() </a>的助手，用于说明:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="8a1c" class="mr lh in mm b gy ms mt l mu mv">import { sleep } from 'modern-async'</span><span id="aa5f" class="mr lh in mm b gy mx mt l mu mv">await sleep(300)</span></pre><p id="ee0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然不多，但是拥有一个适合<code class="fe mj mk ml mm b">async/await</code>范例的替代品总是有用的。</p><h1 id="ec87" class="lg lh in bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">轻松超时</h1><p id="c170" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">回到我们的<code class="fe mj mk ml mm b">doSomething()</code>函数。如果我们想为它的返回设定一个最长的时间，会发生什么呢？</p><p id="90b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用我们刚刚看到的<code class="fe mj mk ml mm b">setTimeout()</code>或<code class="fe mj mk ml mm b">sleep()</code>函数来制作我们自己的解决方案，但是对于编码来说不会那么简单。</p><p id="b418" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么<code class="fe mj mk ml mm b"><a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank">modern-async</a></code>为名称为<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/global.html#timeout" rel="noopener ugc nofollow" target="_blank">timeout()</a></code>的对象提供了一个函数:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="24e3" class="mr lh in mm b gy ms mt l mu mv">import { timeout } from 'modern-async'</span><span id="77df" class="mr lh in mm b gy mx mt l mu mv">await timeout(doSomething, 5000)</span></pre><p id="e439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该调用将执行与<code class="fe mj mk ml mm b">doSomething()</code>完全相同的操作，除了异步操作将被限制为5秒(5000毫秒)。如果超过该延迟，它将抛出一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/TimeoutError.html" rel="noopener ugc nofollow" target="_blank">TimeoutError</a></code>来代替。</p><h1 id="7166" class="lg lh in bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">控制任何事情并发性的关键——无处不在的消息队列</h1><p id="b30d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在本文前面，我们已经看到了如何限制对集合执行的异步操作的并发性。让我们称之为“简单模式”，因为在现实世界中，你并不总是事先有一个好的操作列表。有些情况下，异步操作可以在任何时候触发(例如当用户执行一个动作时)。</p><p id="f92f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这些情况下，限制并发性的最佳通用解决方案被命名为<a class="ae ky" href="https://en.wikipedia.org/wiki/Message_queue" rel="noopener ugc nofollow" target="_blank">消息队列</a>。<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank"> modern-async </a>在<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/Queue.html" rel="noopener ugc nofollow" target="_blank">Queue</a></code>类中提供了该范例的实现。实际上，我们之前看到的所有允许限制并发性的工具都只是它上面的包装器。</p><p id="9735" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个用法示例:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="ec9e" class="mr lh in mm b gy ms mt l mu mv">import { Queue } from 'modern-async'</span><span id="6bc7" class="mr lh in mm b gy mx mt l mu mv">const myQueue = new Queue(3) // we will limit the concurrency to 3</span><span id="64b2" class="mr lh in mm b gy mx mt l mu mv">async function buttonClickHandler () { // let's imagine this<br/>  // function is called when the user clicks a button</span><span id="b3e5" class="mr lh in mm b gy mx mt l mu mv">  const result = await myQueue.exec(doSomething)<br/>  // do something with the result if you want<br/>}</span></pre><p id="7157" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们首先创建一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/Queue.html" rel="noopener ugc nofollow" target="_blank">Queue</a></code>对象，我们假设它对我们的应用程序是全局的。每当用户点击一个按钮，队列中就会安排一个对<code class="fe mj mk ml mm b">doSomething() </code>的异步调用。如果尚未达到并发性，它将立即启动。如果没有，那么一旦至少有一个槽被释放，它就会被执行(这意味着先前调度的异步操作已经完成)。这样，我们的用户就可以随心所欲地点击我们的按钮Cookie点击样式，它不会崩溃。</p><p id="e9cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://nicolas-van.github.io/modern-async/modern-async/1.0.2/Queue.html" rel="noopener ugc nofollow" target="_blank">Queue</a></code>还提供了一种优先级机制，允许将一些任务放在队列中其他任务之前。</p><h1 id="7f9c" class="lg lh in bd li lj nm ll lm ln nn lp lq lr no lt lu lv np lx ly lz nq mb mc md bi translated">最后一句话</h1><p id="cabc" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">正如我所说，异步编程并不容易。太多的程序员忽略了它的微妙之处，这常常会导致程序不稳定。虽然这篇文章可能被称为“高级”，但它是基于我作为前端和后端开发人员在处理非常传统的应用程序时的日常工作中遇到的真实需求。这些用例并不罕见，我认为更多的开发人员应该知道解决它们的解决方案。</p><p id="9bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能也想知道为什么我使用我自己创建的<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank"> modern-async </a>库来提供例子。实际上，还有更流行的库，比如<a class="ae ky" href="https://caolan.github.io/async" rel="noopener ugc nofollow" target="_blank"> Async.js </a>。不幸的是，当我试图使用这些库时，我感到非常沮丧，因为它们中的大多数都很老派，不太适合新的<code class="fe mj mk ml mm b">async/await</code>范式。由于我不太愿意回到回调地狱式的编码风格，我花时间做了一个很好的开源项目来解决我的问题。如果你有时间<a class="ae ky" href="https://github.com/nicolas-van/modern-async" rel="noopener ugc nofollow" target="_blank">的话，一个明星⭐on Github </a>会很受欢迎😀。</p></div></div>    
</body>
</html>