<html>
<head>
<title>Stop Using the Fetch API in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在JavaScript中使用Fetch API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-the-fetch-api-in-javascript-f3ac14aca026?source=collection_archive---------7-----------------------#2021-06-03">https://javascript.plainenglish.io/stop-using-the-fetch-api-in-javascript-f3ac14aca026?source=collection_archive---------7-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b72" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这就是Axios更好的原因</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/721c5ee71e16d08ed440453e3530024f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WiTG6_Rzx0f1CGHg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@oskaryil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oskar Yildiz</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="048b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名开发人员，经常会有很多选项、包和路径需要遵循和选择。例如，当我们发出HTTP请求时，我们应该选择哪种方式？在这篇文章中，我将介绍<strong class="ky ir"> Axios </strong>库和<strong class="ky ir"> Fetch </strong> API，并展示它们的区别。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ebb8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">它们是什么？</h1><p id="9bc8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们想要通过HTTP协议与服务器通信时，我们发出请求并获取数据——这个过程被称为AJAX(异步JavaScript和XML)。任何前端开发人员在执行此操作时都会记得的两个最常见的关键字是——Axios或Fetch。</p><h2 id="ed61" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">Axios</h2><p id="6e34" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Axios是一个JavaScript库，用于从Node.js或浏览器发出HTTP请求。根据其文档，它可以:</p><ul class=""><li id="a049" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">从浏览器发出XMLHttpRequests</li><li id="cf55" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">从Node.js发出HTTP请求</li><li id="e1a9" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">支持承诺API</li><li id="9286" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">拦截请求和响应</li><li id="1be4" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">转换请求和响应数据</li><li id="5d28" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">取消请求</li><li id="fe3f" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">JSON数据的自动转换</li><li id="4dde" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">客户端支持防止<a class="ae kv" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> XSRF </a></li></ul><p id="76c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Axios库不是JavaScript API的原生库，我们必须将其导入到项目中。可以直接一步一步的检查安装<a class="ae kv" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><h2 id="70c9" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">获取API</h2><p id="c730" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Fetch API提供了从浏览器获取资源的接口。根据它的<a class="ae kv" href="https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">文档</a>，Fetch为请求和响应提供了对象的通用定义。它还使用了<strong class="ky ir">承诺</strong>并提供了一个全局<code class="fe nw nx ny nz b">fetch()</code>方法。该方法只需要您想要获取的资源的路径作为强制参数。无论成功与否，它都将返回一个承诺来解决该请求的响应。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="277c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">和睦相处</h1><p id="0225" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">以下是两者兼容的顶级浏览器列表:</p><ul class=""><li id="be95" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">axios——Chrome、Firefox、Safari、Opera、Edge、IE。</li><li id="b492" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">fetch——Chrome、Firefox、Safari、Opera、Edge。</li></ul><p id="7486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以肯定地说，Axios在旧版本的浏览器中支持得很好，它也支持IE，而Fetch API不支持。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="61ea" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安全</h1><p id="71b9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Axios不太容易受到攻击，因为它具有针对XSRF(跨站点请求伪造)的客户端保护。基本上，它发生在网站之间发出HTTP请求的情况下，在这种情况下，有人试图冒充系统用户。关于CSRF更好的解释可以在<a class="ae kv" href="https://owasp.org/www-community/attacks/csrf" rel="noopener ugc nofollow" target="_blank">这里</a>看到！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a335" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">句法</h1><p id="16c9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">比较Axios和Fetch时，需要注意的是，它们的语法明显不同。检查Axios的<code class="fe nw nx ny nz b">GET</code>方法并取出:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="31f2" class="mw ma iq nz b gy oe of l og oh">const url = '<!-- -->https://jsonplaceholder.typicode.com/posts<!-- -->';</span><span id="c2a1" class="mw ma iq nz b gy oi of l og oh">// Axios<br/>axios.get(url)<br/>  .then(response =&gt; console.log(response));</span><span id="2c6b" class="mw ma iq nz b gy oi of l og oh">// Fetch<br/>fetch(url)<br/>  .then(response =&gt; response.json())<br/>  .then(data =&gt; console.log(data));</span></pre><p id="afe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您从未见过它们，我相信您会想知道为什么在Fetch的情况下使用<code class="fe nw nx ny nz b">.json()</code>方法。实际上，Axios内部也是如此，当请求被解析时，它会自动序列化为JSON。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2ded" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">拦截请求和响应</h1><p id="f823" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">HTTP拦截器对于检查从客户端到服务器的HTTP请求非常有用。它们很适合在请求/响应开始/接收之前进行更改。在Fetch中，没有办法拦截HTTP请求，但是可以通过覆盖全局<code class="fe nw nx ny nz b">fetch()</code>方法并创建自己的拦截器来绕过它。</p><p id="12e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与此同时，Axios已经拥有了自己的拦截器，甚至在做出<code class="fe nw nx ny nz b">.then</code>或<code class="fe nw nx ny nz b">.catch</code>的承诺之前就已经执行了。为了说明这一点:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="f771" class="mw ma iq nz b gy oe of l og oh">axios.interceptors.request.use(<br/>  config =&gt; {<br/>    // something can be done with your request data here<br/>    console.log('A request has been sent!');<br/>    return config;<br/>  }, (error) =&gt; {<br/>    return Promise.reject(error);<br/>  }<br/>);</span><span id="26ef" class="mw ma iq nz b gy oi of l og oh">axios.interceptors.response.use(<br/>  config =&gt; {<br/>    // something can be done with your response data here<br/>    console.log('A response has been received!');<br/>    return config;<br/>  }, (error) =&gt; {<br/>    return Promise.reject(error);<br/>  }<br/>);</span><span id="4c3c" class="mw ma iq nz b gy oi of l og oh">axios.get('<!-- -->https://jsonplaceholder.typicode.com/posts<!-- -->')<br/>  .then(response =&gt; console.log(response));</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9447" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">超时和进度</h1><p id="1903" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我觉得Axios很酷的一点是Fetch不提供<code class="fe nw nx ny nz b">timeout</code>作为它的设置之一，也就是请求被中止前的时间限制。超时是以毫秒为单位在<code class="fe nw nx ny nz b">config</code>对象中传递的一个可能的设置选项。重要的是要记住，超时是响应超时，而不是连接超时。例如:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="35b8" class="mw ma iq nz b gy oe of l og oh">axios.get(<br/>  '<!-- -->https://jsonplaceholder.typicode.com/posts<!-- -->',<br/>  {<br/>    timeout: 10<br/>  }<br/>)<br/>  .then(response =&gt; console.log(response));</span></pre><p id="5cb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一种方法可以使用Fetch API创建超时，例如:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="d005" class="mw ma iq nz b gy oe of l og oh">const controller = new AbortController();<br/>const timeoutValue = 10000;<br/>const timeout = setTimeout(() =&gt; controller.abort(), timeoutValue);<br/>fetch('<!-- -->https://jsonplaceholder.typicode.com/posts<!-- -->', { signal: controller.signal })<br/>  .then(response =&gt; response.json())<br/>  .then(data =&gt; console.log(data));</span></pre><p id="bf29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就进展而言，我们有另一个理由更喜欢Axios，因为它提供了一种更简单的方式来了解您请求的进展。<code class="fe nw nx ny nz b">OnUploadProgress</code>是配置对象中传递的可选设置之一。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e233" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">错误处理</h1><p id="b63c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用Axios，处理错误要容易得多，因为错误响应会自动被拒绝，这与Fetch不同，Fetch中甚至可以解决404或500个错误。在这种情况下，后端返回“500内部服务器错误”代码，Fetch将像处理代码“200正常”一样处理它。为了在Fetch中处理这个问题，我们可以使用“ok”标志:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="4f1d" class="mw ma iq nz b gy oe of l og oh">fetch('<!-- -->https://official-joke-api.appspot.com/jokes/ten/hehe<!-- -->')<br/>  .then(response =&gt; {<br/>    if (!response.ok) {<br/>      throw Error(response.statusText)<br/>    }<br/>    return response.json()<br/>  })<br/>  .then(data =&gt; {<br/>    console.log(data)<br/>  })<br/>  .catch(error =&gt; console.error(error))</span></pre><p id="235d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就Axios而言，下面是一个简单的错误处理示例:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="3611" class="mw ma iq nz b gy oe of l og oh">axios<br/>  .get('<!-- -->https://official-joke-api.appspot.com/jokes/ten/hehe<!-- -->')<br/>  .then(response =&gt; {<br/>    console.log("response", response)<br/>  })<br/>  .catch(error =&gt; console.log(error))</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="69a5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fcd8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">很明显，与Fetch相比，Axios的易用性更高。另一个需要考虑的问题是，Axios是一个需要包含在项目中的外部包，而Fetch已经内置在浏览器中，也就是说，它的总重量为0 KB。我更喜欢在我的项目中使用Axios，但这不是使用它的规则。所以做出明智的选择！快乐编码！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b4de" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><div class="oj ok gp gr ol om"><a href="https://github.com/axios/axios" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">axis/axis</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">浏览器和节点的基于承诺的HTTP客户端。js新axios文档网站:单击此处从…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kp om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">获取应用编程接口-网络应用编程接口| MDN</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">获取API提供了获取资源的接口(包括通过网络)。对…似乎很熟悉</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">developer.mozilla.org</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa kp om"/></div></div></a></div><p id="bd9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pc">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="pc">plain English . io</em></a></p></div></div>    
</body>
</html>