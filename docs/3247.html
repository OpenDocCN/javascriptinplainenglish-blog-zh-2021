<html>
<head>
<title>From Zero to Dijkstra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到迪克斯特拉</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/from-zero-to-dijkstra-part-2-a09e92a5ba8a?source=collection_archive---------11-----------------------#2021-07-02">https://javascript.plainenglish.io/from-zero-to-dijkstra-part-2-a09e92a5ba8a?source=collection_archive---------11-----------------------#2021-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4e6d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:出队和优先级队列</h2></div><p id="3d4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎回来。这是我解构Dijkstra算法的博客系列的第2部分。如果你还没看过第1部分，我强烈建议你<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/from-zero-to-dijkstra-the-shortest-path-to-the-shortest-path-algorithm-f070e224f99e">回去</a>看一遍，不然你会很失落。对于那些已经读过的人，我将快速回顾一下我们目前所知道的。</p><ul class=""><li id="4aa0" class="kz la in ke b kf kg ki kj kl lb kp lc kt ld kx le lf lg lh bi translated">Dijkstra算法用于查找图上任意两点之间的最短距离。</li><li id="5831" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">这意味着它可以广泛应用于谷歌地图、航班计算器，甚至电视流媒体“你可能也喜欢……”页面。</li><li id="0f9b" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">Dijsktra的算法涉及到使用一个<strong class="ke io">优先级队列</strong>，它可以用一个修改过的min二进制堆来实现。</li><li id="368f" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated"><strong class="ke io">最小二进制堆</strong>是树结构，其中每个父节点最多有2个子节点，并且每个子节点大于其父节点。</li><li id="92d8" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">我们可以<strong class="ke io">将</strong>值放入我们的堆中，方法是将它们推到数组结构的末尾，并允许它们<strong class="ke io">冒泡</strong>到顶部。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/730da0ea1c512dae7f635ca5942f79c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*V46BUK74t6EINroVSyqSpg.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Our Min Binary Heap w/ Array</figcaption></figure><h1 id="22ef" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">出列介绍</h1><p id="3e08" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">当从最小二进制堆中出列时，我们将提取树的根(在我们的例子中是<strong class="ke io"> 3 </strong>)。因为根总是最小值，所以需要用下一个最小值替换它，整个树需要重新排列，以确保它保持基本结构。</p><p id="4d96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修正树的最简单的方法是用具有最少依赖性的项替换根(在我们的例子中是<strong class="ke io"> 11 </strong>，因为它是数组的结尾，所以它肯定没有子元素)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/e749318bb56e8b9bc37cccd62c2c1376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AABIhjq4Jt0hZbmfUCRK4A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Visualization</figcaption></figure><p id="d658" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦<strong class="ke io"> 11 </strong>处于根位置，我们需要通过与它的两个子节点进行比较，让它<strong class="ke io">下沉到正确的位置。根据min二进制堆的性质，其中一个子堆将是新的最小值，并且可以牢牢地占据它作为根的位置。然后我们的floating <strong class="ke io"> 11 </strong>值重复这个与其子节点进行比较和交换的循环，直到它到达它所属的位置。</strong></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/b3ceea01d202beaecb23c299da708ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD8s_Qb3PFDhyKYvhAI6Ug.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Comparing Our New Root With Its Children</figcaption></figure><p id="6232" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的<strong class="ke io"> 11 </strong>元素将把自己与其子元素进行比较。较小的将成为新的根，并且<strong class="ke io"> 11 </strong>将继续其向下的旅程，直到它在正确的位置结束。</p><p id="cbc6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们对代码做一些初步的设置。就像<strong class="ke io">入队</strong>一样，我们将使用一些基本代码来设置初始出队，并使用强大的“下沉”帮助函数来完成剩下的工作。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="532c" class="nh ma in nd b gy ni nj l nk nl">dequeue() {<br/>    let min = this.values[0];<br/>    let end = this.values.pop();<br/>    if (this.values.length &gt; 0) {<br/>        this.values[0] = end;<br/>        this.sinkDown();<br/>    }<br/>    return min;<br/>}</span></pre><p id="3f06" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！我们在根处初始化最小值，并在数组的末尾弹出替换值。然后，我们检查数组中只有一个值的边缘情况(if语句)。最后，我们将最终值替换到根位置，并开始下沉的过程。最后，我们返回出列的“min”值。</p><h1 id="a259" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">沉落</h1><p id="8b04" class="pw-post-body-paragraph kc kd in ke b kf mr jo kh ki ms jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">沉下心来有点疯狂，但是一旦你掌握了伪代码，这就很有意义了。所以，我们需要做的是:</p><ul class=""><li id="4560" class="kz la in ke b kf kg ki kj kl lb kp lc kt ld kx le lf lg lh bi translated">初始化我们的下沉元素。树的新<strong class="ke io">根</strong></li><li id="2049" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">开始一个循环。</li><li id="1772" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">初始化我们的<strong class="ke io"> 11 </strong>元素的左右子索引。</li><li id="cc2c" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">如果<strong class="ke io"> 11 </strong>大于我们左边的孩子，记住，它可能会交换。</li><li id="79c2" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">如果<strong class="ke io"> 11 </strong>大于左子代，也大于右子代，我们将比较左子代和右子代，并与最小值交换。</li><li id="4964" class="kz la in ke b kf li ki lj kl lk kp ll kt lm kx le lf lg lh bi translated">如果<strong class="ke io"> 11 </strong>小于它的两个子节点，那么它到达了正确的位置，我们完成了循环。</li></ul><p id="8544" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看它的实际应用:</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="9f32" class="nh ma in nd b gy ni nj l nk nl">sinkDown() {<br/>    let idx = 0;<br/>    const length = this.values.length; // Easier to reference length<br/>    const element = this.values[0];<br/>    <br/>    while(true) {<br/>        let leftChildIdx = 2 * idx + 1;<br/>        let rightChildIdx = 2 * idx + 2;<br/>        let leftChild, rightChild;<br/>        let swap = null;</span></pre><p id="0229" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在开始循环之前，我们初始化了堆根的索引和元素。这样我们可以引用元素<strong class="ke io"> 11 </strong>的值和它的索引号。一旦我们开始交换，指数将会改变。</p><p id="659c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们开始一个无限循环，当我们的“swap”值保持为空时，这个循环将会中断。请记住，如果没有可交换的值，我们就到达了正确的位置。我们通过使用在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/from-zero-to-dijkstra-the-shortest-path-to-the-shortest-path-algorithm-f070e224f99e">上一部分</a>中学到的技巧找到了<strong class="ke io"> leftChildIdx </strong>和<strong class="ke io"> rightChildIdx </strong>:父节点的(<strong class="ke io"> n) </strong>左右子节点的索引将分别等于<strong class="ke io"> 2n+1 </strong>和<strong class="ke io"> 2n+2 </strong>。</p><p id="2781" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何为我们的左孩子设置交换支票:</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="2497" class="nh ma in nd b gy ni nj l nk nl">if (leftChildIdx &lt; length) {</span><span id="c9cb" class="nh ma in nd b gy nm nj l nk nl">    leftChild = this.values[leftChildIdx];<br/>    <br/>    if (leftChild &lt; element) {<br/>        swap = leftChildIdx;<br/>    }<br/>}</span></pre><p id="7399" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们检查<strong class="ke io"> leftChildIdx </strong>是否小于长度，这意味着它的值在数组<strong class="ke io"> this.values </strong>中。然后，我们使用索引号初始化<strong class="ke io"> leftChild </strong>的值，并将其与我们的原始元素<strong class="ke io"> 11 </strong>进行比较。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/b3ceea01d202beaecb23c299da708ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD8s_Qb3PFDhyKYvhAI6Ug.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Checking if 6 is less than 11</figcaption></figure><p id="61f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<strong class="ke io"> 6 </strong>小于<strong class="ke io"> 11 </strong>，也就是它，我们新的<strong class="ke io">交换</strong>值变为6。现在我们要和右侧进行对比。为了保持我们的二进制堆尽可能的干净，我们要确保左边的孩子不要比右边的孩子大，因为我们希望总是与最小的孩子交换。</p><p id="181d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，概括一下:如果有一个<strong class="ke io">交换</strong>值，我们检查右边的孩子是否更小。如果是这样，正确的孩子将成为新的交换对象。如果没有<strong class="ke io">交换</strong>值，我们应该检查父元素是否小于正确的子元素。如果是这样，合适的孩子将成为新的交换对象<strong class="ke io">。</strong>否则，没有理由交换，因为父元素小于它的两个子元素。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="3ac6" class="nh ma in nd b gy ni nj l nk nl">if (rightChildIdx &lt; length) {</span><span id="d2da" class="nh ma in nd b gy nm nj l nk nl">    rightChild = this.values[rightChildIdx]<br/>   <br/>    if ( <br/>    (!swap &amp;&amp; rightChild &lt; element) || <br/>    (swap &amp;&amp; rightChild &lt; leftChild)<br/>    ) <br/>        {<br/>        swap = rightChildIdx;<br/>        }<br/>    }</span></pre><p id="960f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来很吓人，但这正是我们刚刚讨论过的。它检查是否没有交换<strong class="ke io">和</strong>right child<strong class="ke io"/>小于父元素。这意味着应该有一个合适的孩子交换。<strong class="ke io">或</strong>如果有交换，但右孩子比左孩子小<strong class="ke io">。这意味着还有一个孩子交换。</strong></p><p id="6271" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后:</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="d10b" class="nh ma in nd b gy ni nj l nk nl">if (!swap) break;</span><span id="f089" class="nh ma in nd b gy nm nj l nk nl">this.values[idx] = this.values[swap];<br/>this.values[swap] = element;<br/>idx = swap;</span></pre><p id="4870" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有交换值(记得我们将它初始化为空值)，那么我们就退出循环。元素在正确的位置！</p><p id="8683" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，我们通过使元素的值等于交换值来就地改变数组，反之亦然。然后我们的元素<strong class="ke io"> idx </strong>将成为<strong class="ke io">交换</strong>值，因为我们必须在新的位置重新开始循环。</p><p id="c607" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这太多了，让我们在一个块中获得代码的完整视图:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nn"><img src="../Images/09948b27fccebe8809ea38adda0dee38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQSdAAok-YhO8SkAMA0Qmg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Dequeue</figcaption></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi no"><img src="../Images/c4148d1f23b03085f1f2272fb0558cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*si8hh7jA5WLtKskULLty2Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Sinkdown</figcaption></figure><p id="a649" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们制作的这个<strong class="ke io">最小二进制堆</strong>和一个<strong class="ke io">优先级队列</strong>之间的唯一区别是，优先级队列包含<strong class="ke io">节点</strong>，它们同时保存一个值和一个优先级。让我们看看节点的类构造函数。</p><pre class="lo lp lq lr gt nc nd ne nf aw ng bi"><span id="4b35" class="nh ma in nd b gy ni nj l nk nl">class Node {<br/>    constructor(val, priority) {<br/>        this.val = val;<br/>        this.priority = priority;<br/>     }<br/>}</span></pre><p id="0891" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很简单。我们只有一个节点数组，而不是数字数组。这只改变了我们堆的一些东西。下面是enqueue方法。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0fb88ead158261dc9e8230f71ca75cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*bmAScC2Nef435UdnWXk8YQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Enqueue w/ Priority Queue</figcaption></figure><p id="ef70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">唯一的区别是，我们将一个节点推入值数组，而不仅仅是一个值。这将是未来的不同之处。当我们使用<strong class="ke io"> bubbleUp() </strong>和<strong class="ke io"> sinkDown() </strong>方法时，我们只是比较每个节点上的<strong class="ke io"> priority </strong>属性，而不是它们的值。</p><p id="4c41" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ed8a16eb72e9bbed5885f55655b800ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*OTvRpwViovXa7pojabLDgA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">bubbleUp w/ Priority Queue</figcaption></figure><p id="4d08" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以看到这里唯一的区别是第23行使用了<strong class="ke io">元素。对于<strong class="ke io"> sinkDown()也是如此。</strong></strong></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nr"><img src="../Images/c1b374b25357c8b6172a44e447342e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*NqvR0rzPnA6lSFExPNrtuw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">sinkDown w/ Priority Queue</figcaption></figure><p id="673a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，唯一的变化在第50、57和58行。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="08df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，这部分到此为止。内容很多，但我试图尽可能详细地解释每一行代码以及我们为什么要这样做。现在我们已经有了一个优先级队列，我们实际上可以继续我们最终的数据结构:<strong class="ke io">图。</strong></p><p id="8a84" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你走到这一步，如果你有任何问题，请在评论中告诉我。编码快乐！</p><p id="cc45" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nz">更多内容看</em><a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>