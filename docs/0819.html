<html>
<head>
<title>JavaScript Loops: A Comprehensive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript循环:综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-loops-a-comprehensive-guide-eb7f98b7c455?source=collection_archive---------7-----------------------#2021-02-20">https://javascript.plainenglish.io/javascript-loops-a-comprehensive-guide-eb7f98b7c455?source=collection_archive---------7-----------------------#2021-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对象、数组和字符串— for、forEach、for…of、for…in、while、do…while、every、some、find、findIndex、includes、map、filter、reduce</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/77efde406c74d102d6ed01a57cfed9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxG1Xl2ob-4ykQ2MbH-EJQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Author</figcaption></figure><p id="90b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你有没有想过在编写JavaScript代码时使用什么循环？有时您可能会想，是否有一种快捷方式可以节省您的时间，或者您的循环是否会导致bug。</p><p id="ec51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文的目的是将所有重要的循环信息放在一个地方，这样您就可以滚动并找到您的循环。</p><p id="60d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，事不宜迟，下面是可以在代码中使用的JavaScript循环，组织成对象、数组和字符串的循环。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="780b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">遍历对象</h1><h2 id="06bc" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">1.为了…在</h2><p id="a26a" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">是最适合对象的JavaScript循环。这个循环遍历一个对象的所有属性。属性的键必须是字符串。跳过符号键。</p><p id="fc13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您需要让<code class="fe nh ni nj nk b">for…in</code>循环看到对象的属性，那么它们必须是可枚举的属性。可枚举属性只是将内部可枚举标志设置为true的属性。用对象文字或通过属性初始化器(<code class="fe nh ni nj nk b">new Object()</code>，<code class="fe nh ni nj nk b">Object.create()</code>)创建的对象将把可枚举属性默认设置为true。</p><p id="0fd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果不想让<code class="fe nh ni nj nk b">for…in</code>循环看到某个属性，可以像这样设置一个不可数的属性:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="af46" class="mq lz iq nk b gy np nq l nr ns">const myObject = {<br/>    keyOne: 5,<br/>    keyTwo: "valueTwo",<br/>    <!-- -->differentkey<!-- -->: "value3"<br/>};</span><span id="3493" class="mq lz iq nk b gy nt nq l nr ns">Object.defineProperty(myObject, 'newKey', {<br/>  value: "can't see me in a for...in loop",<br/>  configurable: <strong class="nk ir">false</strong>, // default is false<br/>  writable: <strong class="nk ir">false</strong>, // default is false<br/>  enumerable: <strong class="nk ir">false</strong>, // default is false<br/>});</span></pre><p id="6b92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for…in</code>循环以随机顺序遍历对象，所以开发人员不应该依赖于属性添加到对象的顺序。</p><p id="1f0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当修改/添加/删除一个对象<strong class="kx ir">的属性，同时仍然在循环</strong>中迭代时，注意以下几点很重要:</p><ul class=""><li id="2dba" class="nu nv iq kx b ky kz lb lc le nw li nx lm ny lq nz oa ob oc bi translated">任何被删除的属性在被删除之前都可以被访问。</li><li id="6dda" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">任何被修改的属性在被修改之前可能被访问，也可能不被访问。</li><li id="f64f" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated">添加的属性可能会被访问，也可能不会被访问。</li></ul><p id="6922" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">break</code>和<code class="fe nh ni nj nk b">continue</code>关键字可以在<code class="fe nh ni nj nk b">for…in</code>循环中使用，但是不能像在<code class="fe nh ni nj nk b">for</code>循环中那样访问任何类型的索引。</p><p id="cbe2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for…in</code>循环可能会迭代原型属性，所以最好执行<code class="fe nh ni nj nk b">hasOwnProperty()</code>检查。(见下文:<strong class="kx ir">中的……与</strong>中的……的对比)</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="3c0f" class="mq lz iq nk b gy np nq l nr ns">const myObject = {<br/>    keyOne: 5,<br/>    keyTwo: "valueTwo",<br/>    <!-- -->differentkey<!-- -->: "value3"<br/>};</span><span id="b66a" class="mq lz iq nk b gy nt nq l nr ns">for (var keyName in myObject) {</span><span id="2aaa" class="mq lz iq nk b gy nt nq l nr ns">  if (myObject[keyName] &gt; 4 &amp;&amp; myObject<!-- -->["differentkey"]<!-- -->) {<br/>    <!-- -->// may not be deleted before loop reaches it<br/>    delete <!-- -->myObject<!-- -->["differentkey"];<br/>  }</span><span id="50b2" class="mq lz iq nk b gy nt nq l nr ns">  if (myObject.hasOwnProperty(keyName)) {<br/>    console.log(keyName + " : " + myObject[keyName]);<br/>  }<br/>}</span></pre><h2 id="844a" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">2.为了…的</h2><p id="c5ae" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">因为<code class="fe nh ni nj nk b">for…of</code>循环不是针对对象的，所以你必须首先通过分别使用<code class="fe nh ni nj nk b">Object.keys()</code>、<code class="fe nh ni nj nk b">Object.values()</code>或<code class="fe nh ni nj nk b">Object.entries()</code>方法将对象的键或值或者键和值存储在一个数组中。</p><p id="7443" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以一起使用析构、<code class="fe nh ni nj nk b">for…of</code>和<code class="fe nh ni nj nk b">Object.values() / Object.keys() / Object.entries()</code>:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="3125" class="mq lz iq nk b gy np nq l nr ns">for (const [value] of Object.values(myObject)) {<br/>  console.log(value);<br/>}</span><span id="0eb6" class="mq lz iq nk b gy nt nq l nr ns">for (const [key] of Object.keys(myObject)) {<br/>  console.log(key);<br/>}</span><span id="4abf" class="mq lz iq nk b gy nt nq l nr ns">for (const [key, value] of Object.entries(myObject)) {<br/>  console.log(key, value);<br/>  if (myObject[keyName] &lt; 4) {<br/>    break;<br/>  }<br/>}</span></pre><p id="a910" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">break</code>和<code class="fe nh ni nj nk b">continue</code>在<code class="fe nh ni nj nk b">for…of</code>循环中工作，但是不能像在<code class="fe nh ni nj nk b">for</code>循环中那样访问任何类型的索引。</p><p id="8e03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">上面的</strong> <code class="fe nh ni nj nk b">for…of</code> <strong class="kx ir">循环可能会成为你遍历对象的常用方法。</strong></p><h2 id="5987" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">3.为每一个</h2><p id="72c6" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如<strong class="kx ir"> 2所示。在上面的</strong>中，你可以分别使用<code class="fe nh ni nj nk b">Object.keys()</code>、<code class="fe nh ni nj nk b">Object.values()</code>或<code class="fe nh ni nj nk b">Object.entries()</code>方法将对象的键或值或者键和值存储在一个数组中，然后使用<code class="fe nh ni nj nk b">Array.prototype.forEach()</code>循环遍历它们。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="ef25" class="mq lz iq nk b gy np nq l nr ns">Object.keys(myObject).forEach(<br/>    (key, index) =&gt; console.log(key, index)<br/>);</span><span id="27d4" class="mq lz iq nk b gy nt nq l nr ns">Object.values(myObject).forEach(<br/>    (value, index) =&gt; console.log(value, index)<br/>);</span><span id="c35d" class="mq lz iq nk b gy nt nq l nr ns">Object.entries(myObject).forEach(<br/>    ([key, value], index) =&gt; console.log(key, value, index)<br/>);</span></pre><h2 id="b475" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">4.为</h2><p id="b45b" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">有更好的方法来遍历一个对象，但是在极少数情况下，您可以使用<code class="fe nh ni nj nk b">for</code>循环遍历一个对象。这种方法的优点是您可以访问对象的键的索引(对象本身没有索引，但是您可以使用<code class="fe nh ni nj nk b">Object.keys()</code>将键保存在一个数组中)。</p><p id="d553" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae oi" href="https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order" rel="noopener ugc nofollow" target="_blank">JavaScript中对象属性的顺序很复杂</a>，所以不要依赖使用<code class="fe nh ni nj nk b">Object.keys()</code>生成的数组的顺序来保持一致或者反映插入到对象中的顺序。然而，您可以使用<code class="fe nh ni nj nk b">i%2</code>可靠地做一些事情，比如仅访问每秒的属性。</p><p id="dbe0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在i = 100以下，循环开始，在i = 155 (56个键)时循环中断。如果一个对象有2000个键，可以通过将循环限制在感兴趣的索引值来节省时间。</p><p id="8ecb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要获得循环的上限，使用<code class="fe nh ni nj nk b">Object.keys()</code>方法将对象的键写入一个数组，并获得该数组的长度。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="be4a" class="mq lz iq nk b gy np nq l nr ns">const myObjectKeys = Object.keys(myObject);<br/>for(let i = 100; index &lt; myObjectKeys.length; index++) {<br/>  if (myObjectKeys[i] === "thisKey") {<br/>    keyInThisRange = true;<br/>  }<br/>  arrayOfAllRangeValues.push(myObject[myObjectKeys[i]]);<br/>  if (i%2 == true) {<br/>    arrayOfEverySecondValue.push(myObject[myObjectKeys[i]]);<br/>  }<br/>  <!-- -->if (i &gt; 155) break;<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="d56d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">遍历数组</h1><h2 id="212f" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为了…的</h2><p id="494a" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这是用于数组的默认循环。<code class="fe nh ni nj nk b">for…of</code>循环遍历可迭代对象。这些<strong class="kx ir">不是</strong>用对象字面量或者用<code class="fe nh ni nj nk b">new Object()</code>或<code class="fe nh ni nj nk b">Object.create()</code>创建的相同对象。数组<strong class="kx ir">是</strong>这些可迭代对象中的一个。</p><p id="0c7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">语法如下所示:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="72d8" class="mq lz iq nk b gy np nq l nr ns">const myArray = [3, 4, 19];</span><span id="c40d" class="mq lz iq nk b gy nt nq l nr ns">for (const value of myArray) {<br/>  console.log(value);<br/>}</span><span id="2c71" class="mq lz iq nk b gy nt nq l nr ns">// use let, not const, if reassigning values inside the loop<br/>for (let value of myArray) {<br/>  value += 20;<br/>  console.log(value);<br/>}</span></pre><p id="fb52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">break</code>和<code class="fe nh ni nj nk b">continue</code>关键字可以在<code class="fe nh ni nj nk b">for…of</code>循环中使用，但是不能像在<code class="fe nh ni nj nk b">for</code>循环中那样访问任何类型的索引。</p><h2 id="2d6b" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为每一个</h2><p id="222c" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这个循环专门用于数组。该函数接受一个带有三个参数的回调，后两个参数<code class="fe nh ni nj nk b">index</code>和<code class="fe nh ni nj nk b">myArray</code>是可选的。<code class="fe nh ni nj nk b">index</code>会给你当前值的索引，<code class="fe nh ni nj nk b">myArray</code>是你调用方法的数组。你可以使用索引来知道你在哪里，但是你不能像使用<code class="fe nh ni nj nk b">for</code>循环那样从某个索引开始。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="20c2" class="mq lz iq nk b gy np nq l nr ns">let myArray = [3, 4, 19];</span><span id="5bfe" class="mq lz iq nk b gy nt nq l nr ns">myArray.forEach((value, index, myArray) =&gt; {<br/>  console.log(value, index, myArray);<br/>});</span></pre><p id="54f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下几点值得注意:</p><ul class=""><li id="1819" class="nu nv iq kx b ky kz lb lc le nw li nx lm ny lq nz oa ob oc bi translated"><code class="fe nh ni nj nk b">forEach()</code>不能用<code class="fe nh ni nj nk b">break</code>或<code class="fe nh ni nj nk b">continue</code>停止或中断循环。</li><li id="bbeb" class="nu nv iq kx b ky od lb oe le of li og lm oh lq nz oa ob oc bi translated"><code class="fe nh ni nj nk b">forEach()</code>期望回调是同步函数，它不会等待承诺被解析。以下将不起作用:</li></ul><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="0065" class="mq lz iq nk b gy np nq l nr ns">let myArray = [3, 4, 2];<br/>let total = 0;<br/><br/>let addFunction = async (x) =&gt; {<br/>  return x + 2<br/>};<br/><br/>myArray<!-- -->.forEach(async (number) =&gt; {<br/>  total = await addFunction(total)<br/>});<br/><br/>console.log(total)<br/>// Expected output with async function: 15<br/>// Actual output: 0</span></pre><ul class=""><li id="1afc" class="nu nv iq kx b ky kz lb lc le nw li nx lm ny lq nz oa ob oc bi translated">调用回调后，<code class="fe nh ni nj nk b">forEach()</code>的回调不会访问追加到数组中的元素。</li></ul><h2 id="ca3c" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为</h2><p id="af8b" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for</code>循环可以很好地处理数组。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="4952" class="mq lz iq nk b gy np nq l nr ns">let myArray = ["Newton", "Isaac", "Hello,"];<br/>let myArrayLength = myArray.length;<br/>for (let i = myArrayLength; i &gt; 0 ; i--) {<br/>    console.log(myArray[i]); //  "Hello,", "Isaac", "Newton",<br/>}</span></pre><p id="3a11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">for循环的优点是可以完全控制索引。例如，如果您愿意，可以从末尾开始循环，如上例所示。</p><h2 id="337a" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为了…在</h2><p id="a464" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for..in</code>可用于迭代数组，但是它访问元素的顺序没有保证，因此它从不用于数组。(另见下文:<strong class="kx ir">中的……与</strong>中的……的对比)</p><p id="60fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下方法是您可以用来代替手动使用任何传统循环的<code class="fe nh ni nj nk b">Array.prototype</code>方法。</p><h2 id="2867" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">地图</h2><p id="8ab2" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">map</code>将通过循环遍历一个数组并对该数组中的每个元素执行一个函数来生成一个新数组。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="dc73" class="mq lz iq nk b gy np nq l nr ns">const myArray = [3, 6, 9, 12, 27];</span><span id="e3c8" class="mq lz iq nk b gy nt nq l nr ns">// place your mapping function in the method<br/>const myArrayMap = myArray.map(x =&gt; x / 3);</span><span id="d0f1" class="mq lz iq nk b gy nt nq l nr ns">console.log(myArrayMap); // [1, 2, 3, 4, 9]</span></pre><h2 id="6c65" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">过滤器</h2><p id="0a11" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">filter</code>将<strong class="kx ir">通过循环遍历一个数组并对该数组中的每个元素执行测试函数来产生一个新数组</strong>。所有通过测试的元素都将被放入新数组中。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="d6d3" class="mq lz iq nk b gy np nq l nr ns">const myNumbersArray= [3, 6, 9, 12, 27];</span><span id="9be7" class="mq lz iq nk b gy nt nq l nr ns">const arrayOfNumbersGreaterThan6 = myNumbersArray.filter(number =&gt; number &gt; 6);</span><span id="9c11" class="mq lz iq nk b gy nt nq l nr ns">console.log(arrayOfNumbersGreaterThan6); // [9, 12, 27]</span></pre><h2 id="2fbf" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">减少</h2><p id="ef4d" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">reduce</code>通过对所有元素执行一个函数，将数组缩减为一个值。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="e79b" class="mq lz iq nk b gy np nq l nr ns">const myArray = [2, 5, 3, 6];<br/>const reducerFunction = (accumulatingValue, currentValue) =&gt; accumulatingValue + currentValue;</span><span id="5f8c" class="mq lz iq nk b gy nt nq l nr ns">console.log(myArray.reduce(reducerFunction)); // 16<br/> <br/>// initial value of 15<br/>console.log(myArray.reduce(reducerFunction, 15)); // 31</span></pre><p id="6425" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有一种镜像法<code class="fe nh ni nj nk b">Array.prototype.reduceRight()</code>从右手边开始。</p><h2 id="c25f" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">一些</h2><p id="281b" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">some</code>将遍历数组并返回一个布尔值，表明<strong class="kx ir">中是否至少有一个</strong>元素通过了测试函数。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="95aa" class="mq lz iq nk b gy np nq l nr ns">const myNumbersArray= [3, 6, 9, 12, 27];</span><span id="c76c" class="mq lz iq nk b gy nt nq l nr ns">const aNumberGreaterThan12 = myNumbersArray.some(number =&gt; number &gt; 12);</span><span id="de86" class="mq lz iq nk b gy nt nq l nr ns">console.log(aNumberGreaterThan12); // true</span></pre><h2 id="ed58" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">每个</h2><p id="04bc" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">every</code>将遍历数组并返回一个布尔值，表明是否所有的<strong class="kx ir">元素都通过了你的测试函数。</strong></p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="5b36" class="mq lz iq nk b gy np nq l nr ns">const myNumbersArray= [3, 6, 9, 12, 27];</span><span id="6383" class="mq lz iq nk b gy nt nq l nr ns">const allNumbersGreaterThan2 = myNumbersArray.every(number =&gt; number &gt; 2);</span><span id="43d9" class="mq lz iq nk b gy nt nq l nr ns">console.log(allNumbersGreaterThan2); // true</span></pre><h2 id="510e" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">包含</h2><p id="2b3e" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这是一个非常有用的循环。要检查一个数组是否有某个值，使用<code class="fe nh ni nj nk b">Array.prototype.includes()</code>来检查它。该方法将遍历数组的值来检查您的值，并将返回<code class="fe nh ni nj nk b">true</code>或<code class="fe nh ni nj nk b">false</code>。</p><p id="c871" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这与前面提到的<code class="fe nh ni nj nk b">some</code>方法不同。<code class="fe nh ni nj nk b">includes</code>不取测试函数，只取一个值。</p><p id="919b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">const isItThere = myArray.includes("this string");</code></p><p id="d15d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您只想确认对象中的键或值的存在，那么就没有必要手动遍历整个对象。使用<code class="fe nh ni nj nk b">Object.values()</code>或<code class="fe nh ni nj nk b">Object.keys()</code>方法将值/键写入一个新数组，然后使用<code class="fe nh ni nj nk b">Array.includes()</code>测试真或假。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="0592" class="mq lz iq nk b gy np nq l nr ns">const myObject = {<br/>    keyOne: 5,<br/>    keyTwo: "valueTwo",<br/>    <!-- -->differentkey<!-- -->: "value3"<br/>};</span><span id="524e" class="mq lz iq nk b gy nt nq l nr ns">myObjectValuesArray = Object.values(myObject);<br/>const helloValue = myObjectValuesArray.includes("hello"); // false</span><span id="3782" class="mq lz iq nk b gy nt nq l nr ns">myObjectKeysArray = Object.keys(myObject);<br/>const helloKey = myObjectKeysArray.includes("<!-- -->keyTwo<!-- -->"); // true</span></pre><h2 id="5ae5" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">发现</h2><p id="0e0b" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">find</code>将遍历数组并返回通过测试函数的第一个<strong class="kx ir">元素的<strong class="kx ir">值</strong>。如果没有找到元素，则返回<code class="fe nh ni nj nk b">undefined</code>。</strong></p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="cd35" class="mq lz iq nk b gy np nq l nr ns">const myNumbersArray= [3, 6, 9, 12, 27];</span><span id="9a1e" class="mq lz iq nk b gy nt nq l nr ns">const valueOfFirstNumberGreaterThan6 = myNumbersArray.find(number =&gt; number &gt; 6);</span><span id="9d45" class="mq lz iq nk b gy nt nq l nr ns">console.log(valueOfFirstNumberGreaterThan6); // 9</span></pre><h2 id="5000" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">findIndex</h2><p id="0d99" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">findIndex</code>将遍历数组并返回通过测试函数的第一个<strong class="kx ir">元素的<strong class="kx ir">索引</strong>。如果没有找到元素，则返回<code class="fe nh ni nj nk b">-1</code>。</strong></p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="42aa" class="mq lz iq nk b gy np nq l nr ns">const myNumbersArray= [3, 6, 9, 12, 27];</span><span id="c7fa" class="mq lz iq nk b gy nt nq l nr ns">const indexOfFirstNumberGreaterThan6 = myNumbersArray.findIndex(number =&gt; number &gt; 6);</span><span id="37b6" class="mq lz iq nk b gy nt nq l nr ns">console.log(indexOfFirstNumberGreaterThan6); // 2</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="4ca4" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">遍历字符串</h1><h2 id="f88b" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为了…的</h2><p id="91fd" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如果你不需要控制迭代的索引，那么一个好的循环是<code class="fe nh ni nj nk b">for…of</code>循环。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="9d8e" class="mq lz iq nk b gy np nq l nr ns">const myString = "Hello";</span><span id="8adf" class="mq lz iq nk b gy nt nq l nr ns">for (let letter of myString) {<br/>  console.log(letter); // "H", "e", "l", "l", "o"<br/>}</span></pre><h2 id="e759" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为</h2><p id="24fd" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如果您需要访问索引，请使用<code class="fe nh ni nj nk b">for</code>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="8c93" class="mq lz iq nk b gy np nq l nr ns">const myString = "Hello";</span><span id="0501" class="mq lz iq nk b gy nt nq l nr ns">for (let i = 2; i &lt; myString.length; i++) {<br/>  console.log(i); // "H", "e", "l", "l", "o"<br/>}</span></pre><h2 id="0bf0" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">为每一个</h2><p id="62fa" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如果您首先使用spread语法<code class="fe nh ni nj nk b">…</code>将字符串扩展到一个数组中，那么您可以使用<code class="fe nh ni nj nk b">forEach</code>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="8173" class="mq lz iq nk b gy np nq l nr ns">const myString = "Hello";</span><span id="270f" class="mq lz iq nk b gy nt nq l nr ns">[...myString].forEach((letter) =&gt; {<br/>   console.log(letter); // "H", "e", "l", "l", "o"<br/>})</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="031d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">其他常规循环</h1><h2 id="d210" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">在…期间</h2><p id="cbcf" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><code class="fe nh ni nj nk b">while</code>循环非常类似于没有第一条和第三条语句的<code class="fe nh ni nj nk b">for</code>循环。索引值在循环之前声明，例如<code class="fe nh ni nj nk b">let i = 0;</code>，并且索引在循环内用<code class="fe nh ni nj nk b">i++</code>增加。以下for和while循环是等效的:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="b2d4" class="mq lz iq nk b gy np nq l nr ns">// FOR LOOP<br/>const myNumbersArray= [3, 6, 9, 12, 27];<br/>let i = 0;</span><span id="7a34" class="mq lz iq nk b gy nt nq l nr ns">for (;<!-- -->myNumbersArray<!-- -->[i];) {<br/> <!-- -->console.log(myNumbersArray<!-- -->[i]);<br/> i++;<br/>}</span><span id="f7a8" class="mq lz iq nk b gy nt nq l nr ns">// WHILE LOOP<br/>const myNumbersArray= [3, 6, 9, 12, 27];<br/>let i = 0;</span><span id="f8ef" class="mq lz iq nk b gy nt nq l nr ns">while (<!-- -->myNumbersArray<!-- -->[i]) {<br/> <!-- -->console.log(myNumbersArray<!-- -->[i]);<br/> i++;<br/>}</span></pre><p id="913c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以像使用<code class="fe nh ni nj nk b">for</code>一样使用<code class="fe nh ni nj nk b">while</code>:</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="676b" class="mq lz iq nk b gy np nq l nr ns">const myObject = {<br/>    keyOne: 5,<br/>    keyTwo: "valueTwo",<br/>    <!-- -->differentkey<!-- -->: "value3"<br/>};<br/>let i = 0;<br/>const obKeys = Object.keys(myObject);</span><span id="09b7" class="mq lz iq nk b gy nt nq l nr ns">while (i &lt; obKeys.length) {<br/>  console.log(myObject[obKeys[i]]);<br/>  i++;<br/>}<br/>///////////////////</span><span id="a75a" class="mq lz iq nk b gy nt nq l nr ns">const myArray= [3, 6, 9, 12, 27];<br/>let i = 0;</span><span id="9667" class="mq lz iq nk b gy nt nq l nr ns">while (i &lt; myArray.length) {<br/>  // get numbers in myArray between 10 and 20<br/>  if (myArray[i] &gt; 9 &amp;&amp; myArray[i] &lt; 21) {<br/>    anotherArray.push(myArray[i]);<br/>  }<br/>  i++;<br/>}</span></pre><p id="7f82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">break</code>和<code class="fe nh ni nj nk b">continue</code>关键字可以在<code class="fe nh ni nj nk b">while</code>循环中使用。</p><h2 id="ecfd" class="mq lz iq bd ma mr ms dn me mt mu dp mi le mv mw mk li mx my mm lm mz na mo nb bi translated">做…的同时</h2><p id="5ecd" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">除了<code class="fe nh ni nj nk b">do</code>块中的代码至少迭代<strong class="kx ir">一次</strong>之外，<code class="fe nh ni nj nk b">do...while</code>循环与<code class="fe nh ni nj nk b">while</code>循环相同。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="69e3" class="mq lz iq nk b gy np nq l nr ns">let num = 3;<br/>let i = 0;</span><span id="b6aa" class="mq lz iq nk b gy nt nq l nr ns">do {<br/>  num += 1;<br/>  i++;<br/>}<br/>while (i &lt; 12);</span></pre><p id="1205" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">break</code>和<code class="fe nh ni nj nk b">continue</code>关键字可以在<code class="fe nh ni nj nk b">do…while</code>循环中使用。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="f18f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">组合循环</h1><p id="5059" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">您可以将循环组合在一起工作。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="9b0c" class="mq lz iq nk b gy np nq l nr ns">const keysToBeAdded = [<br/>  "massOfSugar",<br/>  "massOfBeans",<br/>  "massOfCoffee"<br/>];</span><span id="69ee" class="mq lz iq nk b gy nt nq l nr ns">const myObject = {<br/>    <!-- -->massOfSugar<!-- -->: 5,<br/>    randomMass: 50,<br/>    <!-- -->massOfBeans<!-- -->: 19,<br/>    massOfTomatoes: 50,<br/>    massOfFish: 50,<br/>    <!-- -->massOfCoffee<!-- -->: 5200,<br/>};</span><span id="8c56" class="mq lz iq nk b gy nt nq l nr ns">let totalMass;<br/>let massesToBeAdded = [];</span><span id="f4a2" class="mq lz iq nk b gy nt nq l nr ns">const addValuesReducer = (accumulator, currentValue) =&gt; accumulator + currentValue;</span><span id="b11b" class="mq lz iq nk b gy nt nq l nr ns">for (const [key, value] of Object.entries(myObject)) {<br/>  if (<!-- -->keysToBeAdded.includes(key)<!-- -->) {<br/>    <!-- -->massesToBeAdded.push(<!-- -->value<!-- -->);<br/>  }<br/>}<br/>totalMass = massesToBeAdded.reduce(addValuesReducer);<br/>console.log(totalMass); // 5224</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="a3ec" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">嵌套'</strong> <code class="fe nh ni nj nk b"><strong class="ak">for'</strong></code> <strong class="ak">循环</strong></h1><p id="99f6" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">有时有必要将一个<code class="fe nh ni nj nk b">for</code>循环嵌套在另一个循环中。通常，这是为了相对于另一个对象比较或更新一个对象。通常，对多维数组使用嵌套的for循环。多维数组只是数组的数组，比如<code class="fe nh ni nj nk b">[[1, 6], [2,2,1], [5,6]]</code>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="6c96" class="mq lz iq nk b gy np nq l nr ns">function aggregate(multiDimArray) {<br/>  let sum = 0;<br/>  for (let indexA = 0; indexA &lt; multiDimArray.length; indexA++) {<br/>    const insideArray = multiDimArray[indexA];<br/>    for (let indexB = 0; indexB &lt; indexB.length; indexB++) {<br/>      sum += insideArray[indexB];<br/>    }<br/>  }<br/>  console.log(sum); // 23<br/>}</span><span id="e2e2" class="mq lz iq nk b gy nt nq l nr ns">const multiDimensionalArray = [[1, 6], [2,2,1], [5,6]];<br/>aggregate(multiDimensionalArray);</span></pre><p id="a3c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以对对象使用嵌套循环，首先分别使用<code class="fe nh ni nj nk b">Object.keys()</code>、<code class="fe nh ni nj nk b">Object.values()</code>或<code class="fe nh ni nj nk b">Object.entries()</code>方法将对象键/值/键+值转换为数组。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="b62d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><code class="fe nh ni nj nk b">for...of</code> vs <code class="fe nh ni nj nk b">for...in ?</code></h1><p id="3c5d" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">数组只是带有整数隐藏键的对象。这意味着数组只是一个定制的对象。<code class="fe nh ni nj nk b">for…of</code>循环和<code class="fe nh ni nj nk b">for…in</code>循环都迭代这些对象，但是它们迭代的内容不同。</p><p id="b978" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for…in</code>循环随机遍历对象的<strong class="kx ir">可枚举属性</strong>。它将返回所有属性名，包括非整数名称和继承的属性。</p><p id="f3a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">for…of</code>循环依次迭代对象的<strong class="kx ir">可迭代值</strong>，可迭代对象定义迭代的内容。</p><p id="7373" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意下面的<code class="fe nh ni nj nk b">for…in</code>返回一个数组的隐藏的<strong class="kx ir">索引键</strong>，而<code class="fe nh ni nj nk b">for…of</code>返回<strong class="kx ir">值</strong>。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="c666" class="mq lz iq nk b gy np nq l nr ns">const myArray= [3, 6, 9, 12, 27];</span><span id="a492" class="mq lz iq nk b gy nt nq l nr ns">for (const i <strong class="nk ir">in</strong> myArray) {<br/>  console.log(i); // "0", "1", "2", "3", "4"<br/>}</span><span id="c70c" class="mq lz iq nk b gy nt nq l nr ns">for (const i <strong class="nk ir">of</strong> myArray) {<br/>  console.log(i); // "3", "6", "9", "12", "27"<br/>}</span></pre><p id="4fb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你用<code class="fe nh ni nj nk b">Object.prototype</code>或<code class="fe nh ni nj nk b">Array.prototype</code>修改<code class="fe nh ni nj nk b">Object</code>原型，<code class="fe nh ni nj nk b">for…in</code>将返回那些属性，除非你用<code class="fe nh ni nj nk b">hasOwnProperty</code>指定它不应该。下面，<code class="fe nh ni nj nk b">newArraykey</code>甚至和<code class="fe nh ni nj nk b">hasOwnProperty</code>一起返回，因为它是你添加到<code class="fe nh ni nj nk b">myArray</code>的属性。</p><pre class="kg kh ki kj gt nl nk nm nn aw no bi"><span id="1fad" class="mq lz iq nk b gy np nq l nr ns">const myArray= [12, 6, 9];</span><span id="6491" class="mq lz iq nk b gy nt nq l nr ns">// Array objects will also inherit this property "myObProp"<br/>Object.prototype.myObProp =  function() {};</span><span id="4966" class="mq lz iq nk b gy nt nq l nr ns">// Only array objects will inherit this property "myArrayProp" Array.prototype.myArrayProp =  function() {};</span><span id="f68f" class="mq lz iq nk b gy nt nq l nr ns">myArray.newArraykey = "surprise!";</span><span id="ab48" class="mq lz iq nk b gy nt nq l nr ns">for (const i <strong class="nk ir">in</strong> myArray) {<br/>  console.log(i); // "0", "1", "2", "<!-- -->myObProp<!-- -->", "<!-- -->myArrayProp"<!-- -->, "newArraykey"<br/>}</span><span id="d66f" class="mq lz iq nk b gy nt nq l nr ns">for (const i <strong class="nk ir">in</strong> myArray) {<br/>  <!-- -->if (<!-- -->myArray<!-- -->.hasOwnProperty(i)) {<br/>  <!-- -->  console.log(i); // "0", "1", "2", "newArraykey"<br/>  }<br/>}</span><span id="748b" class="mq lz iq nk b gy nt nq l nr ns">for (const i <strong class="nk ir">of</strong> myArray) {<br/>  console.log(i); // "12", "6", "9"<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="06f6" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">最终外卖</h1><p id="37d8" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如果你想从这篇文章中学到什么，那就是:</p><p id="8720" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"/><code class="fe nh ni nj nk b">for…of</code><strong class="kx ir">循环是最通用的循环。</strong>要迭代对象，首先，使用<code class="fe nh ni nj nk b">Object.keys()</code>、<code class="fe nh ni nj nk b">Object.values()</code>或<code class="fe nh ni nj nk b">Object.entries()</code>方法之一将它们转换成数组，然后使用<code class="fe nh ni nj nk b">for…of</code>中的新数组——这样可以避免错误地迭代继承的属性。要迭代数组，只需像在<code class="fe nh ni nj nk b">for…of</code>循环中一样使用数组。如果不需要知道索引，也可以对字符串使用<code class="fe nh ni nj nk b">for…of</code>。</p><p id="77c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读。如果你喜欢这篇文章，可以考虑在这里<a class="ae oi" href="https://craftedwebpages.medium.com/membership" rel="noopener">订阅</a>中级会员，以获得数以千计的其他文章。</p><p id="1616" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将来我会发布更多的JavaScript文章。你可能也会喜欢我的另一篇文章:</p><div class="oj ok gp gr ol om"><a href="https://levelup.gitconnected.com/9-early-signs-you-will-be-a-successful-programmer-1a604f04be39" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">你将成为成功程序员的9个早期迹象</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">不要放弃</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kp om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.com/technology-hits/the-best-programming-languages-to-learn-first-a-roadmap-for-the-indecisive-beginner-f242e5ffeac5" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">首先学习的最佳编程语言——犹豫不决的初学者的路线图</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">最省时、最具成本效益的学习方式以及免费和付费课程</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa kp om"/></div></div></a></div></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9311" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">学习资源:</h1><p id="77cf" class="pw-post-body-paragraph kv kw iq kx b ky nc jr la lb nd ju ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated"><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">for loop</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noopener ugc nofollow" target="_blank">for…in loop</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">array . prototype .</a><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while" rel="noopener ugc nofollow" target="_blank">while loop</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while" rel="noopener ugc nofollow" target="_blank">do…while loop</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">array . prototype . map</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">array . prototype . filter</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">array . reduce</a><br/><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank">array . prototype . include</a></p></div></div>    
</body>
</html>