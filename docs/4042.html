<html>
<head>
<title>Reverse a Singly Linked List in JavaScript (Iteratively and Recursively)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中反转一个单链表(迭代和递归)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reverse-a-singly-linked-list-in-javascript-iteratively-and-recursively-566ebf7dfd0d?source=collection_archive---------14-----------------------#2021-08-12">https://javascript.plainenglish.io/reverse-a-singly-linked-list-in-javascript-iteratively-and-recursively-566ebf7dfd0d?source=collection_archive---------14-----------------------#2021-08-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="018d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何以迭代和递归的方式反转JavaScript中的单链表？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2197f5a2b22c508eddc2a78ad25b14a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qDtDcfqrh0IOynkM"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="39fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你申请软件工程师职位(尤其是在大型FAANG类型的公司),你可能会遇到的一个常见的面试问题是反转链表。</p><p id="4aef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你熟悉什么是链表，这个问题看起来就像是小菜一碟。别这么快！</p><p id="da76" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">反转链表包括几个不同的步骤，需要按照特定的顺序来实现。所以让我们从什么是链表开始，看看你在野外最有可能遇到的链表类型。</p><h1 id="f1e3" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么是链表？</h1><p id="60d1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">链表是一种数据结构。它是线性存储的元素或节点的集合，每个节点包含一个引用列表中下一个节点的指针，因此将整个节点集合相互链接。这是概念的基本概述。现在有几种类型的链表，如单向链表和双向链表。这里我们将只实现第一个。</p><p id="a1e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">单链表</strong>是节点的集合，每个节点持有一个下一个指针，引用下一个节点，直到最后一个节点的下一个指针指向空。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="173d" class="mr lq in mn b gy ms mt l mu mv">{1, next} =&gt; {2, next} =&gt; {3, next} =&gt; {4, next} =&gt; null</span></pre><p id="3727" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">双向链表</strong>也是一个节点集合，虽然它们像单向链表一样有一个指向下一个节点的指针，但是它们也有一个指向前一个节点的指针。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="1600" class="mr lq in mn b gy ms mt l mu mv">{prev, 1, next} &lt;=&gt; {prev, 2, next} &lt;=&gt; {prev, 3, next} =&gt; null</span></pre><h1 id="f7f9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">迭代方法</h1><p id="524c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">要迭代反转一个单链表，我们必须调整每个节点的节点指针，使其指向链表中的前一个节点。由于单链表只有带有下一个指针的节点，我们需要在当前遍历的每个节点之前手动跟踪前一个节点。</p><p id="631d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，我们应该就地操作节点指针，而不是创建一个新的链表。</p><p id="7c1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是我们的单链表节点的外观:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0e05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们有了一个我们将要处理的视觉效果，让我们在下面的<code class="fe my mz na mn b">reverse()</code>函数中实现我们的解决方案。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fca5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在第5-7行，我们设置了几个指针来跟踪当前节点、当前节点之前的前一个节点和当前节点之后的下一个节点。然后，对于第10–15行，我们通过在每次迭代期间调整节点指针来执行反转，以就地反转链表。当反转完成时，我们从循环中脱离。在第17–18行，我们将头部重置为单链表原始顺序的最后一个节点，并返回对新头部的引用。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="928e" class="mr lq in mn b gy ms mt l mu mv">Before: {1, next} =&gt; {2, next} =&gt; {3, next} =&gt; {4, next} =&gt; null</span><span id="5d2b" class="mr lq in mn b gy nb mt l mu mv">After:  {4, next} =&gt; {3, next} =&gt; {2, next} =&gt; {1, next} =&gt; null</span></pre><h1 id="3ee0" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">递归方法</h1><p id="657a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们已经看到了如何迭代地反转一个链表，现在让我们来看看如何递归地反转一个单链表。</p><p id="37ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将从头节点开始反转列表，然后递归地向下遍历调用堆栈，直到到达最后一个节点。当我们到达最后一个节点时，我们可以通过调整每个节点的next指针来遍历调用堆栈，从而反转列表。一旦我们回到顶部，因为我们保存了对最后一个节点(新的头)的引用，我们就可以返回它，给我们一个完全相反的列表。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cb44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第3–5行是我们的退出条件，当我们完成链表的反转时，我们将在这里返回新的头。那么第6–9行是我们算法的核心。第6行是我们在调用堆栈中向下移动的地方，直到我们到达列表的末尾。第7 &amp; 8行是我们调整下一个指针来反转链接的地方，第9行是我们返回调用栈和评估结果<code class="fe my mz na mn b">reversedHead</code>的地方。</p><p id="507b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下图可能有助于理解这一逻辑。它表示调用堆栈如何出现在这个问题中:</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="0d40" class="mr lq in mn b gy ms mt l mu mv">         -----------------CALL STACK-------------------</span><span id="be90" class="mr lq in mn b gy nb mt l mu mv">         -(head)(reversedHead)-------------------------</span><span id="ddb5" class="mr lq in mn b gy nb mt l mu mv">         ----------(head)(reversedHead)----------------</span><span id="c1ef" class="mr lq in mn b gy nb mt l mu mv">         -------------------(head)(reversedHead)-------</span><span id="cbd1" class="mr lq in mn b gy nb mt l mu mv">         ---------------------------------------(head)-</span></pre><p id="41a5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的视图中，每一行代表为每个递归函数调用创建的堆栈框架。头的顶部引用是当它第一次被传入我们的<code class="fe my mz na mn b">recursivelyReverseList()</code>函数时。最后一行代表我们到达列表末尾时的基本情况。然后，当返回调用堆栈并引用新的列表头时，就会发生相反的情况。</p><h1 id="ab58" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">摘要</h1><p id="c82a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">学习如何反转链表是学习常见面试问题的一个很好的练习。它可能会绊倒你很多次(就像我一样！)但是如果你坚持下去，你可能会对这个基本的数据结构有更好的理解。</p><h1 id="a4ca" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">资源</h1><ul class=""><li id="9b5f" class="nc nd in kv b kw mh kz mi lc ne lg nf lk ng lo nh ni nj nk bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=sYcOK51hl-A" rel="noopener ugc nofollow" target="_blank">反转链表—迭代法</a></li><li id="d768" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=KYH83T4q6Vs&amp;t=39s" rel="noopener ugc nofollow" target="_blank">使用递归反转链表</a></li><li id="348d" class="nc nd in kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=O0By4Zq0OFc" rel="noopener ugc nofollow" target="_blank">如何反转单链表终极解释</a></li></ul><p id="20e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nq">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nq">plain English . io</em></strong></a></p></div></div>    
</body>
</html>