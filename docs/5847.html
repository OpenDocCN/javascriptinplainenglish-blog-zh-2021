<html>
<head>
<title>Keyboard Input of Date and Time According to Language Conventions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据语言约定的日期和时间的键盘输入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/keyboard-input-of-date-and-time-according-to-language-conventions-daf0b9918425?source=collection_archive---------9-----------------------#2021-12-14">https://javascript.plainenglish.io/keyboard-input-of-date-and-time-according-to-language-conventions-daf0b9918425?source=collection_archive---------9-----------------------#2021-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b5f572a7bf66c91571b812297d55d959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFQwmbutS7zO0u2vEypeGA.jpeg"/></div></div></figure><p id="ada3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个用于日期键盘输入的React组件，它遵循浏览器语言的区域设置约定。</p><h1 id="95d9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">理由</h1><p id="94c8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在用于编辑的表单字段中，日期通常与一个<em class="lw">日期</em> <em class="lw">选取器</em>相关联。</p><p id="5f4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">日期和时间的选择由选择器的不同元素直观地驱动。</p><p id="3b1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，所选择的日期将按照浏览器所用语言的约定显示在字段中。</p><p id="e37f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，字段还应该提供键盘输入，以便那些由于各种原因而无法使用定点设备的用户可以使用它。</p><p id="b16f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">键盘输入还可以加速数据输入应用程序的表单填写。</p><p id="54b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">日期应以每种语言的适当格式编辑。在下文中，JavaScript <em class="lw">日期</em>对象方法和国际化API ( <em class="lw"> Intl </em>)将用于实现提供该特性的字段。</p><p id="5b64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在现场实施中，语言约定的正确应用有三个要点:</p><ul class=""><li id="d720" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">日期和时间的显示</li><li id="5a79" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">对用户输入的解析</li><li id="f8fe" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">占位符的可视化(这对于告知用户可识别的语言约定非常重要)</li></ul><h1 id="dab9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">假设</h1><p id="3acb" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在处理日期和时间输入时，以下假设相当常见:</p><ul class=""><li id="d166" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">日期和时间部分以数字形式输入</li><li id="79d1" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">日期部分由以下字符之一分隔:<em class="lw"> / </em>、<em class="lw"> - </em>或空白<em class="lw"> ' </em></li><li id="930f" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">日期和时间部分由空格分隔</li><li id="577f" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">时间成分由<em class="lw"> : </em>分隔</li><li id="e962" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">年份总是用4位数表示</li></ul><h1 id="525a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">日期格式的可变性</h1><p id="3703" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">根据之前的假设，格式可变性仅限于以下两个方面:</p><ul class=""><li id="01b6" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">日期部分的位置:日/月/年，年/月/日或月/日/年</li><li id="2e87" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">带/不带白天的时间(上午/下午)</li></ul><h1 id="8414" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">日期构造函数</h1><p id="f1a0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">虽然很容易判断日期格式是将年份放在第一个位置还是最后一个位置，但是无法区分月份位置不同的两种格式(日/月/年和月/日/年)。</p><p id="bd04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接受字符串作为输入的date构造函数只以一种方式解释日期“1/2/2022”:它是一月二日(不是二月一日)。<br/>构造函数不能用于以日期作为第一部分的日期格式(DD/MM/YYYY)。</p><p id="17b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免这个问题，解析器(见下文)将使用日期构造函数，它将所有日期部分的数值作为输入。</p><h1 id="e4cb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">浏览器语言</h1><p id="de17" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">该字段将按照浏览器采用的语言惯例来管理日期。</p><p id="9832" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该语言由全局变量<em class="lw"> navigator.language </em>定义。</p><p id="240f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要更改该值，只需修改浏览器的<em class="lw">语言</em>选项。</p><h1 id="4257" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">认识地区惯例</h1><p id="c36f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">给定一种语言，使用Intl API很容易识别它的区域设置约定。</p><p id="66b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是声明我们想要使用的日期和时间字符串的类型和部分。因此，根据前面的假设，我们对每个日期和时间部分的数值感兴趣:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c4e7" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> opt = {<br/>  year: ‘numeric’,<br/>  month: ‘numeric’,<br/>  day: ‘numeric’,<br/>  hour: ‘numeric’,<br/>  minute: ‘numeric’,<br/>  seconds: 'numeric'<br/>}</span></pre><p id="507c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用这些选项，可以创建能够处理日期区域设置约定的DateTimeFormat对象:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a5d1" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> dateTimeFormat = <br/>  <strong class="mq io">new</strong> <strong class="mq io">Intl</strong>.<strong class="mq io">DateTimeFormat</strong>(navigator.language, opt)</span></pre><p id="51dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从DateTimeFormat对象中，我们可以检索任何日期字符串的日期和时间部分:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d49d" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> dateParts = localeFormat.<strong class="mq io">formatToParts</strong>(<strong class="mq io">new</strong> <strong class="mq io">Date</strong>(0))</span><span id="d8de" class="mu ku in mq b gy mz mw l mx my">                    <strong class="mq io"> ||<br/>                     \/</strong></span><span id="40d3" class="mu ku in mq b gy mz mw l mx my">[<strong class="mq io"><br/>  </strong>{type: ‘day’, value: ‘1’},<br/>  {type: ‘literal’, value: ‘/’},<br/>  {type: ‘month’, value: ‘1’},<br/>  {type: ‘literal’, value: ‘/’},<br/>  {type: ‘year’, value: ‘1970’},<br/>  {type: ‘literal’, value: ‘, ‘},<br/>  {type: ‘hour’, value: ‘01’},<br/>  {type: ‘literal’, value: ‘:’},<br/>  {type: ‘minute’, value: ‘00’}<br/>]</span></pre><p id="fb70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，pc时区是UTC+1:00，所以小时是01而不是00。</p><p id="893d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据前面的向量，可以构建日期部分索引的映射(在这种情况下，我们对分隔符文字不感兴趣):</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="428a" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> partIndex = dateParts<br/>  .<strong class="mq io">reduce</strong>((acc, e, i) =&gt; ({ ...acc, [e.type]: i + 1 }), {})</span><span id="b296" class="mu ku in mq b gy mz mw l mx my">        <strong class="mq io">               ||<br/>                       \/</strong></span><span id="97ff" class="mu ku in mq b gy mz mw l mx my">{<br/>  day: 1,<br/>  month: 3,<br/>  year: 5,<br/>  hour: 7,<br/>  minute: 9,<br/>  literal:8<br/>}</span></pre><h1 id="910a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">无效日期</h1><p id="a80a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">日期字段的状态变量之一(见下文)是对应于输入字符串的日期对象。</p><p id="fd87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当输入字符串不代表有效日期时，该状态变量的值应为<em class="lw">无效日期</em>。</p><p id="6d3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建无效日期，只需用不代表日期的字符串调用构造函数即可。但是为了使意图明确，将使用下面的惯用表达:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b37d" class="mu ku in mq b gy mv mw l mx my">new Date(undefined)</span></pre><p id="4748" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">检测无效日期的测试非常简单:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5b7e" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">isNaN</strong>(date.getTime())</span></pre><p id="9a8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者用更简洁的方式来说:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="914b" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">isNaN</strong>(date)</span></pre><h1 id="0aa8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">显示日期和时间</h1><p id="4a35" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是开头列出的三项任务中最简单的一项:将日期转换成地区字符串完全由<em class="lw"> Date </em>方法支持:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d6ad" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">export</strong> <strong class="mq io">const</strong> dateToLocaleString = (date) =&gt;<br/>  !date || <strong class="mq io">isNaN</strong>(date.<strong class="mq io">getTime</strong>())<br/>    ? ''<br/>    : date.<strong class="mq io">toLocaleDateString</strong>(navigator.language) + ' ' +<br/>       date.<strong class="mq io">toLocaleTimeString</strong>(navigator.language)</span></pre><h1 id="f73e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">日期占位符</h1><p id="fbb3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用之前定义的<em class="lw"> dateParts </em>对象可以很容易地构建占位符字符串。</p><p id="2635" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">日期部分将显示为四位数字表示年份，两位数字表示月和日，而不考虑前导零上的区域设置指示。<br/>相反，解析器(见下文)将只在分钟和秒钟内强制前导零。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="46ad" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> toUpper = (t, v) =&gt; t === 'literal'<br/>  ? v<br/>  : t[0] === 'y'<br/>    ? 'YYYY'<br/>    : t[0].<strong class="mq io">toUpperCase</strong>() + t[0].<strong class="mq io">toUpperCase</strong>()</span><span id="3ac6" class="mu ku in mq b gy mz mw l mx my"><strong class="mq io">const</strong> DATE_FORMAT_NO_TIME = dateParts<br/>  .<strong class="mq io">slice</strong>(0, 5)<br/>  .<strong class="mq io">reduce</strong>((a, e) =&gt; a + toUpper(e.type, e.value), '')</span><span id="84d8" class="mu ku in mq b gy mz mw l mx my"><strong class="mq io">const</strong> DATE_FORMAT = DATE_FORMAT_NO_TIME +<br/>  ( dateParts.<strong class="mq io">length</strong> &lt; 13<br/>      ? ' HH:mm:ss'<br/>      : ' hh:mm:ss A'<br/>  )</span></pre><h1 id="f389" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">区域日期和时间分析器</h1><p id="f15f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">与更复杂的编译器/传输器一样，解析本地日期字符串并将其转换为日期对象是一个两步过程:</p><ul class=""><li id="bf19" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">令牌识别</li><li id="7502" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">语义检查、翻译和语法错误管理</li></ul><h2 id="db31" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">令牌识别</h2><p id="e4c2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对于像这样的简单情况，使用一个简单的正则表达式就可以一举实现标记化。实际上，为了正确处理年份位置，使用了两种方法:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="25e1" class="mu ku in mq b gy mv mw l mx my">const dateReg = /^(\d?\d)([-/. ])(\d?\d)([-/. ])(\d{4})( +(\d?\d):(\d?\d)(:(\d?\d))?( +([AP]M))?)?$/</span><span id="c440" class="mu ku in mq b gy mz mw l mx my">const dateRegYearFirst = /^(\d{4})([-/. ])(\d?\d)([-/. ])(\d?\d)( +(\d?\d):(\d?\d)(:(\d?\d))?( +([AP]M))?)?$/</span></pre><p id="9ec5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在日期部分，捕获组还包括分隔符，以便与<em class="lw"> partIndex </em>对象保持一致(例如，匹配向量中的日组位于<em class="lw"> partIndex.day </em>位置)。</p><p id="bc28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">秒的输入不是强制的<code class="fe nl nm nn mq b">(:(\d?\d))?</code>。同样的技术可以用来使会议记录不是强制性的。</p><p id="f394" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以省略整个时间子字符串(参见reg exps中由最后一个问号控制的可选组)。在这种情况下，解析器的<em class="lw">翻译</em>部分(简单地说就是<em class="lw">日期</em>构造器)会将时间设置为<code class="fe nl nm nn mq b">00:00:00</code>。</p><h2 id="76ee" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">语义检查、翻译和错误管理</h2><p id="5b73" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用对象<em class="lw"> partIndex </em>和从区域设置字符串中提取的标记数组，很容易执行检查、翻译正确的字符串或管理错误。</p><p id="0b3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的解析器如下所示:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="42bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第4–6行调用标记器。</p><p id="2ee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第9–17行包含语义检查。第14、16行在分钟和秒时强制使用前导零(如果需要的话)。</p><p id="5d46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第19行是错误管理:只返回一个无效的日期。</p><p id="42fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第22–29行将标记集翻译成解析器结果。</p><h1 id="4369" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">反应场</h1><p id="09b0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">既然我们已经定义了管理区域设置字符串(包含数字元素)所需的日期特性，我们就可以在react组件中使用它们了。</p><h2 id="ba55" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">状态变量</h2><p id="8dc6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">该组件使用三个状态变量:</p><ul class=""><li id="8d20" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">输入元素中显示的字符串。输入元素将是一个受控组件，因此我们需要一个变量来存储输入值。</li><li id="6d71" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">表示导出到父组件(通常是管理一组字段的表单组件)的字段值的date对象。</li><li id="5bb2" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">错误状态。它是显示来通知错误的字符串，也是字段错误状态的指示符:空字符串= &gt;无错误；非空字符串= &gt;字段出错</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f62e" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> [date, setDate] = <strong class="mq io">useState</strong>(<strong class="mq io">new</strong> <strong class="mq io">Date</strong>(<strong class="mq io">undefined</strong>))<br/><strong class="mq io">const</strong> [value, setValue] = <strong class="mq io">useState</strong>('')<br/><strong class="mq io">const</strong> [error, setError] = <strong class="mq io">useState</strong>('')</span></pre><h2 id="f7a4" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">事件回调</h2><p id="45f5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">字段的行为由两个回调定义:处理字段更改的回调和当字段失去焦点时调用的回调。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="14ab" class="mu ku in mq b gy mv mw l mx my">const changeDate = useCallback(<br/>  (ev) =&gt; {<br/>    const date = localeStringToDate(ev.target.value)<br/>    setDate(date)<br/>    setValue(ev.target.value)<br/>    setError('')<br/>    props.onChange(date)<br/>  },<br/>  [props.onChange]<br/>)</span><span id="e8ca" class="mu ku in mq b gy mz mw l mx my">const validateDate = useCallback(<br/>  () =&gt; {<br/>    if (value &amp;&amp; isNaN(date)) {<br/>      setError('error')<br/>    } else {<br/>      setValue(dateToLocaleString(date))<br/>      setError('')<br/>    }<br/>  },<br/> [date, value]<br/>)</span></pre><p id="6263" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw"> changeDate </em>回调清除错误字符串(只有当字段失去焦点时才会显示错误，如果有的话)。</p><p id="6c35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">localestringdate</em>返回的date对象(有效或无效)用于设置内部状态变量，并传递给父组件的回调(<em class="lw"> props.onChange) </em>。</p><p id="53f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用户输入的任何内容都用来设置控制输入元素的内部状态变量。</p><p id="05ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果日期无效，<em class="lw"> validateDate </em>回调会设置一条错误消息，否则它会用正确的区域设置字符串替换用户输入。</p><h2 id="cefe" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">渲染组件</h2><p id="5452" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">应将以下代码片段添加到前面的代码片段中，以创建功能性React组件:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="aa21" class="mu ku in mq b gy mv mw l mx my">const stateToColor = error<br/>  ? 'red'<br/>  : value &amp;&amp; isNaN(date.getTime())<br/>     ? 'orange'<br/>     : 'black'</span><span id="3494" class="mu ku in mq b gy mz mw l mx my">return (<br/>  &lt;&gt;<br/>    &lt;input<br/>      type="text"<br/>      placeholder={DATE_FORMAT}<br/>      value={value}<br/>      onChange={changeDate}<br/>      onBlur={validateDate}<br/>      style={{ borderColor: stateToColor,<br/>               outlineColor: stateToColor}}<br/>    /&gt;<br/>    &lt;div style={{ color: 'red' }}&gt;{error}&lt;/div&gt;<br/>  &lt;/&gt;<br/>)</span></pre><h2 id="7694" class="mu ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">自己试试</h2><p id="8ec1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你可以在<a class="ae nq" href="https://codesandbox.io/s/localedatefield-87cdh" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/localedatefield-87cdh</a>上试试前面的代码</p><h1 id="5eac" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">当秒是无用的</h1><p id="0919" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">很容易修改前面的代码，使区域设置字符串、占位符和解析器适应不同的需求。</p><p id="a97f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，在秒不重要且不应使用的情况下(在内部，日期构造函数会将它们设置为0)，应应用以下简单的更改:</p><ul class=""><li id="11d1" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">区域设置字符串:考虑到两种不同的区域设置时间变量(带/不带时间段)，可以删除秒:</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f4d8" class="mu ku in mq b gy mv mw l mx my">date.<strong class="mq io">toLocaleTimeString</strong>(navigator.language)<br/><strong class="mq io">  .replace(/:00( [AP]M)?$/, '$1')</strong></span></pre><ul class=""><li id="20db" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">占位符的修改很简单:</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c9de" class="mu ku in mq b gy mv mw l mx my"><strong class="mq io">const</strong> DATE_FORMAT = DATE_FORMAT_NO_TIME +<br/>  ( dateParts.<strong class="mq io">length</strong> &lt; 13<br/>      ? ' HH:mm'<br/>      : ' hh:mm A'<br/>  )</span></pre><ul class=""><li id="9767" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">应该修改解析器的语义检查，以测试<em class="lw">秒</em>令牌是否为<em class="lw">真值</em>:第15、16行应该替换为<code class="fe nl nm nn mq b">dateToken[10]||</code></li></ul><p id="540d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">更多内容尽在</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lw">plain English . io</em></a><em class="lw">。在这里注册我们的</em> <a class="ae nq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lw">免费周报</em> </a> <em class="lw">。</em></p></div></div>    
</body>
</html>