<html>
<head>
<title>How to cache API responses and other data in Angular2/10+</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular2/10+中缓存API响应和其他数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-cache-api-responses-and-other-data-in-angular2-10-d3feebb24bd4?source=collection_archive---------1-----------------------#2021-03-01">https://javascript.plainenglish.io/how-to-cache-api-responses-and-other-data-in-angular2-10-d3feebb24bd4?source=collection_archive---------1-----------------------#2021-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7a92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用缓存系统可以显著提高web应用程序的性能，并允许用户在离线时也能访问数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25c9e5d4b8efb1a37c0805d235746ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vB3MIw0C6kKvMtFwUqTLUg.jpeg"/></div></div></figure><p id="1f0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最常见的使用案例是:</p><ul class=""><li id="f262" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">缓存慢速API调用的响应</li><li id="6898" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">缓存可预测API调用的响应</li><li id="8e7a" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">缓存需要几秒/几分钟才能完成的本地操作的结果</li><li id="f8c3" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">缓存可以脱机使用的数据</li></ul><p id="41d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存临时数据似乎是一项简单的任务，但是<strong class="jm io">开发人员常常低估了一个结构良好的缓存系统的复杂性</strong>，忘记了计划细节并问自己:</p><ul class=""><li id="6950" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">我应该只在当前窗口还是在每个打开的标签页中缓存结果？</li><li id="2cef" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">应该在每个会话结束时清除数据(内存缓存)还是保存数据并在将来的会话中重用(存储缓存)？</li><li id="d0be" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">缓存应该有定义的过期时间还是应该手动清除？</li><li id="295b" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">我是否只缓存“通用”API响应(例如。GET /users)或特定的(例如。GET /users/10)？</li></ul><p id="20e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，这些问题的答案可能会深刻地改变缓存系统背后的逻辑，并且<em class="li">在每个项目中重新发明轮子</em>在工作时间和代码一致性方面可能会非常昂贵……但是有一种更简单的方法来在你的应用中实现缓存系统，没有麻烦！</p><blockquote class="lj lk ll"><p id="9ad5" class="jk jl li jm b jn jo jp jq jr js jt ju lm jw jx jy ln ka kb kc lo ke kf kg kh ig bi translated"><strong class="jm io">liquid cache(ngx-liquid-cache on</strong><a class="ae lp" href="https://www.npmjs.com/package/ngx-liquid-cache" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">NPM</strong></a><strong class="jm io">和</strong><a class="ae lp" href="https://github.com/luckyseven/ngx-liquid-cache" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">GitHub</strong></a><strong class="jm io">)</strong>是“一个强大的、自动的、优化的Angular2/10+缓存系统，适合任何地方！”。</p></blockquote><p id="7598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，一个<strong class="jm io">现成的</strong>高速缓存系统涵盖了前面提到的所有复杂特性。</p><h1 id="f472" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">LiquidCache简介</h1><p id="f42e" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">LiquidCache使用decorators作为它的主要武器，允许你缓存你的方法结果<strong class="jm io">而不用改变你的代码库</strong>的任何一行。对于更具体的缓存逻辑，您可以使用LiquidCacheService并获得对存储数据的完全控制。</p><blockquote class="mt"><p id="24b5" class="mu mv in bd mw mx my mz na nb nc kh dk translated">你可以在这里看到完整的文档:<a class="ae lp" href="https://github.com/luckyseven/ngx-liquid-cache" rel="noopener ugc nofollow" target="_blank">https://github.com/luckyseven/ngx-liquid-cache</a></p></blockquote><h2 id="a0b7" class="nd lr in bd ls ne nf dn lw ng nh dp ma jv ni nj me jz nk nl mi kd nm nn mm no bi translated">设置</h2><p id="3089" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">LiquidCache可以以非常简单的方式在您的web应用程序中实现。首先，使用npm安装最新版本:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9efc" class="nd lr in nq b gy nu nv l nw nx">npm i --save ngx-liquid-cache</span></pre><p id="7662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在将NgxLiquidCacheModule导入到您的AppModule中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b45d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您已经准备好使用新的缓存系统了！</p><h2 id="1f67" class="nd lr in bd ls ne oa dn lw ng ob dp ma jv oc nj me jz od nl mi kd oe nn mm no bi translated">装修工</h2><p id="2dc7" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">使用decorators是使用LiquidCache最快(也是最常见)的方式。只需在方法的签名前添加一个装饰器，就可以为方法的结果启用缓存:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4385" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，<strong class="jm io"> LiquidCache自动使用同步和异步方法</strong>。尝试在您的原始方法中添加一个console.log("TEST ")来测试它是否工作正常:" TEST "将只在您第一次调用该方法时打印出来。从第二次调用开始，您的方法将返回缓存的结果，而不打印任何消息，这证明我们的缓存系统工作正常。</p><p id="2abb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LiquidCache还有一个<strong class="jm io">强大的参数解析系统</strong>，允许你使用占位符设置缓存装饰器<strong class="jm io">:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="961c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这种机制，您可以通过调用参数自动缓存不同的调用结果。</p><p id="09de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">重要提示</strong>:如果你使用的是Angular 9和之前的版本，那么在你的产品构建过程中将“优化”设置为“假”。</p><h2 id="2de6" class="nd lr in bd ls ne oa dn lw ng ob dp ma jv oc nj me jz od nl mi kd oe nn mm no bi translated">LiquidCacheService</h2><p id="9cf9" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">您可以使用LiquidCacheService直接与缓存系统进行交互:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="e409" class="nd lr in bd ls ne oa dn lw ng ob dp ma jv oc nj me jz od nl mi kd oe nn mm no bi translated">配置</h2><p id="9279" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">您可以从全局配置(在模块初始化期间)或者直接在Decorators和Objects中配置您的缓存系统。您可以使用LiquidCacheConfig对象来设置配置参数。</p><p id="e8ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">全局示例</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cba2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">装饰示例</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b818" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对象示例</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a0f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae lp" href="https://github.com/luckyseven/ngx-liquid-cache" rel="noopener ugc nofollow" target="_blank">官方库</a>中找到全套配置参数。</p><h1 id="f04c" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">摘要</h1><p id="6f20" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ms kf kg kh ig bi translated">您不需要在每次需要在Angular应用程序中缓存数据时都重新发明轮子:LiquidCache是一个功能强大且随时可用的系统，涵盖了web缓存的每个方面(和问题)。</p><blockquote class="mt"><p id="e5c5" class="mu mv in bd mw mx my mz na nb nc kh dk translated">在这里阅读完整的文档:<a class="ae lp" href="https://github.com/luckyseven/ngx-liquid-cache" rel="noopener ugc nofollow" target="_blank">https://github.com/luckyseven/ngx-liquid-cache</a>。欢迎投稿！</p></blockquote></div></div>    
</body>
</html>