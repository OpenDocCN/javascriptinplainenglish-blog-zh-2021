<html>
<head>
<title>Simple Logging to Track Unique Requests in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跟踪Node.js中唯一请求的简单日志记录</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-request-specific-logging-for-node-js-212bb2c0e887?source=collection_archive---------5-----------------------#2021-07-15">https://javascript.plainenglish.io/simple-request-specific-logging-for-node-js-212bb2c0e887?source=collection_archive---------5-----------------------#2021-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2e1c89737df18af80fde11a688ff8ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwZhaw32xpkeMVm0Ud8lUg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Don’t be like Bob. Add request ids to your logs.</figcaption></figure><p id="06dc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们都有过这样的经历，试图通过疯狂地过滤成千上万的日志来调查问题，猜测请求的大致时间，并通过目测毫秒来找到日志。</p><p id="6dc3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要启用跟踪id，您需要一种方法来存储与每个请求相关的信息。Node.js是单线程的，不像其他语言那么简单。如果您想直接进入代码，您可以滚动到文章的底部，复制/粘贴动作中的<strong class="kb io">记录器。</strong></p><p id="4ff0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">注意:请求中发送的唯一标识符有不同的名称，这取决于您使用它们的上下文。请求ID /跟踪ID /跟踪ID等。在本文中，我将把它们称为请求id。定义为</em><strong class="kb io"><em class="kx">‘传递给所有依赖项的请求的唯一标识符。’</em> </strong></p><h1 id="d3c0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">请求id和跟踪API请求</h1><blockquote class="lw lx ly"><p id="076d" class="jz ka kx kb b kc kd ke kf kg kh ki kj lz kl km kn ma kp kq kr mb kt ku kv kw ig bi translated">在开发一个API时，一个好的做法是让requestId在整个服务和任何依赖关系中保持不变。这样就有了一个唯一的标识符，将每个独特的旅程联系在一起。</p></blockquote><p id="cdee" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了获得<code class="fe mc md me mf b">requestId</code>的全部好处，您希望将它添加到应用程序输出的每个日志中。在多线程语言中，这是微不足道的，因为您可以利用<a class="ae mg" href="https://docs.microsoft.com/en-us/cpp/parallel/thread-local-storage-tls?view=msvc-160#:~:text=Thread%20Local%20Storage%20(TLS)%20is,the%20TLS%20API%20(TlsAlloc)" rel="noopener ugc nofollow" target="_blank">线程本地存储(TLS) </a>。当一个请求进入您的应用程序时，您可以在TLS中设置<code class="fe mc md me mf b">requestId</code>,无论何时您想要记录日志，您都可以再次检索它。不幸的是，我们在Node没有这种奢侈。</p><h2 id="936e" class="mh kz in bd la mi mj dn le mk ml dp li kk mm mn lm ko mo mp lq ks mq mr lu ms bi translated">方案</h2><p id="b27e" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated">假设您有一个简单的日志实现，带有函数<code class="fe mc md me mf b">setRequestId</code>和<code class="fe mc md me mf b">loginfo</code>。</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e31c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 1) </strong> <code class="fe mc md me mf b">requestOne</code>进入你的应用程序并调用<code class="fe mc md me mf b">setRequestId</code></p><p id="d364" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">2)</strong>T6】然后开始执行异步数据库操作。</p><p id="b316" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 3) </strong> <code class="fe mc md me mf b">requestTwo</code>进入您的应用程序并调用<code class="fe mc md me mf b">setRequestId</code></p><p id="2b8a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 4) </strong> <code class="fe mc md me mf b">requestOne</code>完成其db操作并调用<code class="fe mc md me mf b">logInfo(‘db.done’)</code></p><p id="92e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看到问题了吗？当<code class="fe mc md me mf b">requestOne</code>记录它已经完成数据库操作时，<code class="fe mc md me mf b">requestTwo</code>已经开始并覆盖了<code class="fe mc md me mf b">requestId</code>值。请求一现在用错误的requestId记录了一条消息，我们失去了开始时提到的<code class="fe mc md me mf b">requestId</code>的主要好处之一<em class="kx">有一个唯一的标识符将每个独特的旅程联系在一起。</em></p><p id="26fe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么，我们如何确保当我们登录时，我们为该请求检索到正确的<code class="fe mc md me mf b">requestId</code>？由于Node.js的性质，问题从:</p><blockquote class="lw lx ly"><p id="be19" class="jz ka kx kb b kc kd ke kf kg kh ki kj lz kl km kn ma kp kq kr mb kt ku kv kw ig bi translated">我们如何针对特定请求全局访问属性？</p></blockquote><p id="8128" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">到</p><blockquote class="lw lx ly"><p id="32a4" class="jz ka kx kb b kc kd ke kf kg kh ki kj lz kl km kn ma kp kq kr mb kt ku kv kw ig bi translated">我们如何跟踪请求的异步操作？</p></blockquote><h1 id="94b2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">异步挂钩和cls挂钩</h1><h2 id="1e10" class="mh kz in bd la mi mj dn le mk ml dp li kk mm mn lm ko mo mp lq ks mq mr lu ms bi translated">异步挂钩</h2><p id="b65a" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated"><a class="ae mg" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank">异步钩子</a>在Node.js v8中引入，提供了一个简单的API来访问异步资源的生命周期事件。</p><p id="cf71" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">异步资源有5个主要的生命周期事件:</p><p id="01ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 1) </strong> <strong class="kb io"> init - </strong> <em class="kx">异步资源初始化时调用</em></p><p id="e8e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">2)</strong><strong class="kb io"/><strong class="kb io">-</strong><em class="kx">在资源执行前调用</em></p><p id="beb0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 3) </strong> <strong class="kb io">后- </strong> <em class="kx">资源执行后调用</em></p><p id="ee7b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 4) </strong> <strong class="kb io">销毁- </strong> <em class="kx">当资源的执行已经完成时调用</em></p><p id="4e36" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">5)</strong><strong class="kb io">promiseResolve-</strong><em class="kx">当promise得到其</em> <code class="fe mc md me mf b"><em class="kx">resolve</em></code> <em class="kx">时调用函数</em></p><p id="921d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了保持这篇文章的简单，我将解释cls-hooked如何在一个非常高的层次上利用异步钩子。但是如果你想了解更多，这里有一些关于异步钩子和cls钩子的极好的资源:</p><p id="f7dc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae mg" href="https://www.youtube.com/watch?v=Sakn7GV6EOw&amp;t=1037s&amp;ab_channel=monday.Engineering" rel="noopener ugc nofollow" target="_blank">异步钩子:通往持久执行环境的旅程</a></p><p id="0535" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae mg" href="https://blog.appsignal.com/2020/09/30/exploring-nodejs-async-hooks.html" rel="noopener ugc nofollow" target="_blank">探索Node.js异步挂钩</a></p><p id="95bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae mg" href="https://habr.com/en/post/442392/" rel="noopener ugc nofollow" target="_blank">详细的cls-hooked解释</a></p><h2 id="c23e" class="mh kz in bd la mi mj dn le mk ml dp li kk mm mn lm ko mo mp lq ks mq mr lu ms bi translated">cls-挂钩</h2><p id="5a35" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated"><a class="ae mg" href="https://www.npmjs.com/package/cls-hooked" rel="noopener ugc nofollow" target="_blank"> cls-hooked </a>通过创建<code class="fe mc md me mf b">asyncId:context</code>的映射来跟踪异步操作，其中<code class="fe mc md me mf b">asyncId</code>总是唯一的，<code class="fe mc md me mf b">context</code>包含关于请求的细节，这是您可以存储请求级别数据的地方。</p><p id="5726" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">注意:当我提到</em> <code class="fe mc md me mf b"><em class="kx">context</em></code> <em class="kx">时，我指的是cls挂钩的上下文。ctx是上下文映射的一种表示。</em></p><p id="f97e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以本文开头的相同场景为例，其中<code class="fe mc md me mf b">requestOne</code>进入应用程序，执行一个异步数据库操作，然后<code class="fe mc md me mf b">requestTwo</code>启动。</p><p id="f033" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 1) </strong> <code class="fe mc md me mf b">requestOne</code>开始，我们将<code class="fe mc md me mf b">requestId</code>添加到<code class="fe mc md me mf b">context</code>，为请求分配一个id并存储上下文。(为了清楚起见，我在表中添加了请求名称)</p><pre class="my mz na nb gt ne mf nf ng aw nh bi"><span id="ecec" class="mh kz in mf b gy ni nj l nk nl">| request    | asyncId |  context |<br/>|------------|---------|----------|<br/>| requestOne |   22    |   ctx1   |</span></pre><p id="7333" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 2) </strong> <code class="fe mc md me mf b">requestOne</code>现在启动异步数据库操作。用<code class="fe mc md me mf b">init(asyncId, type, triggerAsyncId)</code>调用异步钩子<code class="fe mc md me mf b">init</code>。</p><ul class=""><li id="b1af" class="nm nn in kb b kc kd kg kh kk no ko np ks nq kw nr ns nt nu bi translated"><code class="fe mc md me mf b">triggerAsyncId</code>是调用它的操作的<code class="fe mc md me mf b">asyncId</code>(在本例中是22)</li><li id="c098" class="nm nn in kb b kc nv kg nw kk nx ko ny ks nz kw nr ns nt nu bi translated"><code class="fe mc md me mf b">asyncId</code>是新资源的id</li></ul><p id="107e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它检查地图中是否存在<code class="fe mc md me mf b">triggerAsyncId</code>，如果存在，它将添加一个带有新<code class="fe mc md me mf b">asyncId</code>和相同上下文的新条目。</p><pre class="my mz na nb gt ne mf nf ng aw nh bi"><span id="1ad2" class="mh kz in mf b gy ni nj l nk nl">| request    | asyncId |  context |<br/>|------------|---------|----------|<br/>| requestOne |   22    |   ctx1   |<br/>| requestOne |   49    |   ctx1   |</span></pre><p id="10c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 3) </strong> <code class="fe mc md me mf b">requestTwo</code>进入您的应用程序，<code class="fe mc md me mf b">requestId</code>被添加到一个新的上下文对象，一个<code class="fe mc md me mf b">asyncId</code>被分配给请求，上下文被存储。</p><pre class="my mz na nb gt ne mf nf ng aw nh bi"><span id="360c" class="mh kz in mf b gy ni nj l nk nl">| request    | asyncId |  context |<br/>|------------|---------|----------|<br/>| requestOne |   22    |   ctx1   |<br/>| requestOne |   49    |   ctx1   |<br/>| requestTwo |   72    |   ctx2   |</span></pre><p id="f1e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 4) </strong> <code class="fe mc md me mf b">requestOne</code>完成其db操作。异步钩子将调用<code class="fe mc md me mf b">destroy(asyncId)</code>作为<code class="fe mc md me mf b">destroy(49)</code>，并且<code class="fe mc md me mf b">49</code>将被移除。它现在知道它的<code class="fe mc md me mf b">asyncId</code>是<code class="fe mc md me mf b">22</code>。它将检索<code class="fe mc md me mf b">22</code>的上下文，其中包含<code class="fe mc md me mf b">requestOne</code>的<code class="fe mc md me mf b">requestId</code>，而不是<code class="fe mc md me mf b">requestTwo</code>。</p><h1 id="b957" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">让我们开始编码</strong></h1><p id="c4d7" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated">现在我们对cls-hooked有了一个了解，我们可以开始将我们新发现的知识集成到一个日志记录器中。</p><p id="1b0b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们创建一个名称空间，用于跟踪应用程序的异步操作。</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3f69" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">调用<code class="fe mc md me mf b">clsNamespace.run</code>开始跟踪请求。这将创建新的<code class="fe mc md me mf b">context</code>。在这里，您可以设置您需要的请求级别数据，然后启动一个<code class="fe mc md me mf b">next</code>回调，以便它可以挂钩到请求。</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a5b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">既然我们已经设置了特定于请求的值，我们希望在记录时检索它们。</p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b545" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我知道上面的内容看起来需要处理很多信息，但是日志记录器的实际实现是相当容易理解的。</p><h1 id="39ae" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">运行中的记录器</h1><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2eb5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于我的用例，我选择了一个非常简单的javascript原生记录器包装器。但是，<code class="fe mc md me mf b">cls-hooked</code>也可以插入流行的日志库。这里有一个使用winston 的<a class="ae mg" href="https://danoctavian.com/2019/04/13/thinking-coroutines-nodejs-part2/" rel="noopener ugc nofollow" target="_blank">替代方案。</a></p><h1 id="f6fb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="653b" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated">异步钩子提供了强大的工具来跟踪异步操作的生命周期。<code class="fe mc md me mf b">cls-hooked</code>以一种为Node.js提供请求级存储的方式来利用它们，node . js不仅仅可以用于日志记录。您可以使用这个持久存储来存储您在应用程序中偶尔访问的信息，就像一个<code class="fe mc md me mf b">accountId</code>一样，而不是将它传递给每个函数。</p><p id="34e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，有两个缺点必须注意。</p><p id="eb9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 1) </strong>截至Node.js v16.5，异步钩子还在实验的保护伞下。这意味着可以在任何版本中进行非向后兼容的更改或删除，使用它需要您自担风险。</p><p id="337c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 2) </strong>使用这个可以对性能产生影响，正如<code class="fe mc md me mf b">bmeurer</code>用他的<a class="ae mg" href="https://github.com/bmeurer/async-hooks-performance-impact" rel="noopener ugc nofollow" target="_blank">异步钩子显示的性能影响</a>。性能影响的程度将取决于您的应用程序、框架和用例。</p><h1 id="9045" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">奖金代码</strong></h1><h2 id="de90" class="mh kz in bd la mi mj dn le mk ml dp li kk mm mn lm ko mo mp lq ks mq mr lu ms bi translated">海军校生</h2><p id="6fbf" class="pw-post-body-paragraph jz ka in kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw ig bi translated">对于我使用AWS Lambda的大多数个人项目，我使用Middy来处理中间件。以下示例在动作中利用了<em class="kx">记录器中的记录器。它检查入站请求是否有一个<code class="fe mc md me mf b">requestId</code>报头，如果有，它将<code class="fe mc md me mf b">requestId</code>设置为该值，否则，它将生成一个UUID。</em></p><figure class="my mz na nb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e235" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">更多内容尽在</em> <a class="ae mg" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="kx">说白了</em> </strong> </a></p></div></div>    
</body>
</html>