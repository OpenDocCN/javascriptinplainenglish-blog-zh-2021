<html>
<head>
<title>RxJS Operators Everyone Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS操作符大家应该都知道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everyone-needs-these-rxjs-operators-46cc0dbf4c25?source=collection_archive---------3-----------------------#2021-06-30">https://javascript.plainenglish.io/everyone-needs-these-rxjs-operators-46cc0dbf4c25?source=collection_archive---------3-----------------------#2021-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/19f0cf9eaf66be63c6ec532a9cd61fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*8y6tpMH27-H9fJ8UjMKekA.png"/></div></figure><blockquote class="jr js jt"><p id="46bd" class="ju jv jw jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果涉及到数据流，并且你使用JavaScript库，你很可能需要RxJS的一些方法，这是JavaScript的另一个框架。在这篇文章中，我将谈论其中一些，这是经常使用的。</p></blockquote><p id="58f3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">无论是在<em class="jw">前端</em>还是在<em class="jw">后端</em>工作，流都是一个极其重要的问题。有许多框架可以处理这个问题，在本文中，我们将重点关注一个JavaScript库，<strong class="jx io">RxJS</strong>(JavaScript的反应扩展库)。</p><p id="2cd3" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated"><em class="jw"> RxJS </em>是一个利用<em class="jw">可观察</em>序列组成<em class="jw">异步</em>和基于事件的程序的库。</p><p id="ceb4" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">您可以在<em class="jw">前端</em>项目中使用<em class="jw"> RxJS方法</em>，如<strong class="jx io"> Angular </strong>以及<em class="jw">后端</em>项目中使用<a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> NodeJS </strong> </a>。可以找一些npm包给它。这篇文章将给出一些关于这些方法的信息和它们的用法的例子。我更喜欢用<strong class="jx io">NodeJS内置的一个<strong class="jx io"> RESTful API </strong>项目来举例。而且我会用<strong class="jx io"> Visual Studio代码</strong>作为<em class="jw"> IDE </em>。</strong></p><p id="6a77" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">(它必须已经在您的PC上安装了<em class="jw"> NodeJS </em>。)</p><p id="a90a" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">让我们一步一步来，从项目的创建开始。首先我们转到将要创建项目的文件，用下面的代码创建项目的<strong class="jx io"> package.json </strong>文件:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8f2c" class="lg lh in lc b gy li lj l lk ll">npm init -yes</span></pre><p id="0feb" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">为了构建服务，我们安装了以下软件包:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ca3e" class="lg lh in lc b gy li lj l lk ll">npm install express cors nodemon</span></pre><p id="aedb" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">为了语法方便，让我们安装一些包。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d1e9" class="lg lh in lc b gy li lj l lk ll">npm install @babel/cli @babel/core @babel/ node @babel/preset-env</span></pre><p id="7c18" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">为了使用<a class="ae kw" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> babel </strong> </a>，我们将下面的代码添加到<em class="jw"> package.json </em>文件中:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7452" class="lg lh in lc b gy li lj l lk ll">“scripts”: {<br/>  “start”: “ nodemon — exec babel-node src/index.js”,<br/>  ...<br/>}{<br/>  ... <br/> “babel”: {<br/>   “presets”: [“@babel/preset-env”]<br/>  ...<br/>}</span></pre><p id="3c9a" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">我将使用<a class="ae kw" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Axios </strong> </a>来发出<em class="jw"> HTTP请求</em>:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="290c" class="lg lh in lc b gy li lj l lk ll">npm install axios</span></pre><p id="97d8" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">最后当然是:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="73fd" class="lg lh in lc b gy li lj l lk ll">npm i rxjs</span></pre><p id="dc37" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">创建完<em class="jw"> package.json </em>文件后，我创建了如下图左侧所示的文件树:</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/db10c447018e4f6173a130145a164f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nYM-YCU3_Z6igjFR.jpeg"/></div></div></figure><p id="0e16" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">而我正在编辑右边的<em class="jw"> index.js </em>文件。对于每个操作员，我会在<strong class="jx io">路由器文件夹</strong>下创建文件，并在<em class="jw"> index.js </em>中给这些文件赋予<em class="jw">端点</em>(如下图)。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="cfb1" class="lg lh in lc b gy li lj l lk ll">app.use(“/”, opof)</span></pre><h2 id="1bda" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">什么是运算符？</h2><p id="efc9" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">运算符是在<em class="jw"> RxJS </em>中定义的一组方法，在数据流期间使用。</p><p id="3e4d" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">本文将要讨论的操作符列表如下所示。将给出关于该列表中操作符的简要信息，并将在该列表下添加关于每个操作符的示例代码。</p><ul class=""><li id="1cd1" class="mn mo in jx b jy jz kc kd kt mp ku mq kv mr ks ms mt mu mv bi translated"><a class="ae kw" href="#d038" rel="noopener ugc nofollow">共</a></li><li id="6199" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#2ab4" rel="noopener ugc nofollow">来自</a></li><li id="a1fb" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#1e90" rel="noopener ugc nofollow">间隔</a></li><li id="0603" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#61ec" rel="noopener ugc nofollow">定时器</a></li><li id="3ca1" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#6a57" rel="noopener ugc nofollow">轻击</a></li><li id="6327" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#3357" rel="noopener ugc nofollow">抛出错误</a></li><li id="74d9" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#f36e" rel="noopener ugc nofollow">延迟时间</a></li><li id="2c87" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#f36e" rel="noopener ugc nofollow"> retryWhen </a></li><li id="052a" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#aa6e" rel="noopener ugc nofollow">过滤器</a></li><li id="c679" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#8b42" rel="noopener ugc nofollow">地图</a></li><li id="4221" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#bcef" rel="noopener ugc nofollow">扫描</a></li><li id="ab61" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#eef3" rel="noopener ugc nofollow">串联图</a></li><li id="434a" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#2fbb" rel="noopener ugc nofollow">合并地图</a></li><li id="add7" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="#7b11" rel="noopener ugc nofollow">开关图</a></li></ul><h2 id="d038" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">关于</h2><p id="e10e" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">操作器的<em class="jw">的作用类似于<em class="jw">。map() </em>我们从JavaScript中熟悉的函数。差异；即使你没有一个数组，它也能收集任何类型的数据，并发出<em class="jw">个观察值</em>。例如，假设我们有一些不相关的数据，如下图所示。</em></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ba58" class="lg lh in lc b gy li lj l lk ll">1 — “mike” — true — 4 — { country: “German” }</span></pre><p id="ed1d" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">现在让我们在控制台上按顺序显示这些数据，就好像它们是数组的元素一样:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6819" class="lg lh in lc b gy li lj l lk ll">const source = of(1, “mike”, true, 4, { country: “German” });<br/>const subscribe = source.subscribe((val) =&gt; <br/> console.log(val)<br/>);</span></pre><p id="597c" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b3e4" class="lg lh in lc b gy li lj l lk ll">1<br/>mike<br/>true<br/>4<br/>{ country: ‘German’ }</span></pre><h2 id="2ab4" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">从</h2><p id="439d" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">从数组、类数组对象、承诺、可迭代对象或类可观察对象创建可观察对象。</p><p id="5279" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">对于一个真实的流，让我们用<em class="jw"> /people </em> <em class="jw">端点</em>从<a class="ae kw" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank"><em class="jw">【https://swapi.dev/】</em></a>中获取一些数据，并用中的<em class="jw">将它们作为可观察值发出。</em></p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="072a" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">如您所见，我们可以使用<em class="jw">将来自</em>的输入数据转换为可观察数据，然后使用<em class="jw">订阅它。subscribe() </em>方法。</p><p id="6396" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ee54" class="lg lh in lc b gy li lj l lk ll">{<br/>  name: ‘Luke Skywalker’,<br/>  height: ‘172’,<br/>  …<br/>}<br/>{<br/>  name: ‘C-3PO’,<br/>  height: ‘167’,<br/>  …<br/>}<br/>...</span></pre><h2 id="1e90" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">间隔</h2><p id="2a50" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">创建一个可观察对象，它在指定的时间间隔内发出连续的数字。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="68e4" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="1cfd" class="lg lh in lc b gy li lj l lk ll">1<br/>2<br/>3<br/>...</span></pre><h2 id="61ec" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">计时器</h2><p id="14db" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">创建一个可观察对象，它将在发出数字0之前等待一个指定的时间段或确切的日期。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="6a57" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">轻敲，水龙头</h2><p id="e10a" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">使用<em class="jw"> tap </em>操作器，可以进行<em class="jw">测井</em>等不影响输出的操作。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5cf2" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="f617" class="lg lh in lc b gy li lj l lk ll">map’ten önce: 1<br/>map’ten sonra: 11<br/>11<br/>map’ten önce: 2<br/>map’ten sonra: 12<br/>12<br/>map’ten önce: 3<br/>map’ten sonra: 13<br/>13<br/>map’ten önce: 4<br/>map’ten sonra: 14<br/>14<br/>map’ten önce: 5<br/>map’ten sonra: 15<br/>15</span></pre><h2 id="3357" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">投掷误差</h2><p id="5c52" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">它是一个操作符，如果在流中发生错误，您可以使用它打印错误和关于错误的消息。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="f36e" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">retryWhen和delayWhen</h2><p id="8aec" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">顾名思义，当根据流期间确定的情况抛出错误时，该错误在<em class="jw"> retryWhen </em>中被捕获，相关函数再次运行。使用<em class="jw">delay当</em>时，在这些错误情况下，流可以等待一段时间。下面是两个运算符的用法示例。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="aa6e" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">过滤器</h2><p id="d094" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">您可以使用<em class="jw"> filter </em>操作符过滤流发出的值。该过滤规则将是您指定的规则。在下面的例子中，来自<a class="ae kw" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank"><em class="jw"/></a>服务器的人的身高信息被打印到控制台上。作为过滤规则，它被确定为大于100。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="8b42" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">地图</h2><p id="2857" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">使用<em class="jw"> map </em>操作符，我们可以转换一个<em class="jw"> iterable </em>对象的每个元素。这个操作符的工作方式与<em class="jw"> JavaScript </em>的<em class="jw">非常相似。map() </em>函数。不同的是；它的作用不是对现有数组中的元素进行更改，而是对流(从可观察对象发出)时获得的元素进行更改。</p><p id="793d" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">在下面的例子中，从服务器获取对象的一个字段，并将其转换为一个<em class="jw">整数</em>值，然后向其中添加50并打印到控制台。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="25b7" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">在这里，<strong class="jx io">。</strong>管子()【方法】脱颖而出。使用这种方法，可以使用多个运算符，用逗号分隔。也就是说，一个值可以连续处理多次。</p><p id="2ead" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">由于<em class="jw">映射</em>操作符返回<em class="jw">可观察</em>，我们还要注意，我们是通过<em class="jw">订阅</em>来获取值的。</p><h2 id="bcef" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">扫描</h2><p id="81c3" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated"><em class="jw">扫描</em>通过对数据流中的每个值求和来继续。也就是说，它创建一个<em class="jw">累加值</em>，并且每个最后的值都被加到这个累加值上。</p><p id="00ef" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">我们可以在下面的例子中看到，它显示了数组中的每个元素都被添加到先前值的总和中。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bc52" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="0afe" class="lg lh in lc b gy li lj l lk ll">10<br/>30<br/>60<br/>100<br/>150<br/>210</span></pre><p id="fb04" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">让我们再举一个例子，它将相同的值彼此相加，作为<em class="jw">字符串</em>:</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b7c9" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="0142" class="lg lh in lc b gy li lj l lk ll">10<br/>10–20<br/>10–20–30<br/>10–20–30–40<br/>10–20–30–40–50<br/>10–20–30–40–50–60</span></pre><h2 id="eef3" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">串联图</h2><p id="0ab2" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">在流中的活动订阅过程结束之前，该操作符不会启动下一个操作符，而是根据数据源中的顺序提供流。因此，有可能使用以前的数据作为下一个变量。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="12d7" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6b1c" class="lg lh in lc b gy li lj l lk ll">With concatMap: Delayed by: 3000ms<br/>With concatMap: Delayed by: 2000ms<br/>With concatMap: Delayed by: 1000ms</span></pre><p id="5417" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">由于延迟过程将根据源中数据的顺序，第一个数据将在3秒后打印，第二个数据将在2秒后打印，最后一个数据将在1秒后打印。</p><h2 id="2fbb" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">合并地图</h2><p id="a57e" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">与<em class="jw"> concatMap </em>不同的是，<em class="jw"> mergeMap </em>快速地一个接一个地映射所有订阅，不考虑数据源中的数据顺序，也不关注前一个数据操作的完成情况。</p><p id="13ae" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">因此，mergeMap最常见的用例之一是不应该被取消的请求。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4ec8" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="34fe" class="lg lh in lc b gy li lj l lk ll">With mergeMap: Delayed by: 1000ms<br/>With mergeMap: Delayed by: 2000ms<br/>With mergeMap: Delayed by: 3000ms</span></pre><p id="f9b2" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">这可以在控制台中观察到；由于它不使用前一个<em class="jw">预订</em>结果作为下一个的变量，并且由于没有注意顺序，延迟功能不能很好地工作。</p><h2 id="7b11" class="lg lh in bd lr ls lt dn lu lv lw dp lx kt ly lz ma ku mb mc md kv me mf mg mh bi translated">开关图</h2><p id="70f6" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated"><em class="jw"> switchMap </em>的特点区别于<em class="jw"> mergeMap </em>和<em class="jw">concat map</em>；当数据由<em class="jw">开关映射</em>发射时，先前的发射被取消，新的结果被订阅。</p><p id="5b18" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">以下示例比较了map和<em class="jw">开关Map </em>。<em class="jw">映射</em>操作符发出可观察值。<em class="jw"> MergeMap </em>创建一个内部可观察对象，订阅它，并将其值作为可观察对象发出。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="16da" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated"><em class="jw">映射</em>返回值为<code class="fe nd ne nf lc b">(val*2)</code>，而<em class="jw">合并映射</em>使用<code class="fe nd ne nf lc b"><a class="ae kw" href="https://www.tektutorialshub.com/angular/rxjs-observable-using-create-of-from-in-angular/" rel="noopener ugc nofollow" target="_blank">of</a></code>函数返回值为可观察值<code class="fe nd ne nf lc b">(of(val*2))</code>。它还订阅新创建的可观察对象，并将其值发送给流。</p><p id="30a8" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">在下面的例子中，我们看到<em class="jw">开关映射</em>取消了前一个，并在新的输入到来时重新启动。您可以尝试在示例中使用<em class="jw"> concatMap </em>和<em class="jw"> mergeMap </em>而不是<em class="jw"> switchMap </em>来查看区别。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="ng nc l"/></div></figure><h1 id="e64a" class="nh lh in bd lr ni nj nk lu nl nm nn lx no np nq ma nr ns nt md nu nv nw mg nx bi translated">结论</h1><p id="b3c1" class="pw-post-body-paragraph ju jv in jx b jy mi ka kb kc mj ke kf kt mk ki kj ku ml km kn kv mm kq kr ks ig bi translated">本文主要关注14个RxJS操作符，它们对于在流中操作数据非常有用。当然，还有更多的操作符可用。有关更多信息:</p><ul class=""><li id="0a47" class="mn mo in jx b jy jz kc kd kt mp ku mq kv mr ks ms mt mu mv bi translated"><a class="ae kw" href="https://rxjs.dev" rel="noopener ugc nofollow" target="_blank">T32】https://www . rxjs . devT34】</a></li><li id="1d94" class="mn mo in jx b jy mw kc mx kt my ku mz kv na ks ms mt mu mv bi translated"><a class="ae kw" href="https://www.learnrxjs.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">https://www . learn rxjs . io</strong></a></li></ul><p id="db41" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated">为了到达给出示例代码的项目:</p><ul class=""><li id="be4a" class="mn mo in jx b jy jz kc kd kt mp ku mq kv mr ks ms mt mu mv bi translated"><a class="ae kw" href="https://github.com/azizkale/RxJS---TUTORIAL" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">https://github.com/azizkale/RxJS——教程</strong> </a></li></ul><p id="04bf" class="pw-post-body-paragraph ju jv in jx b jy jz ka kb kc kd ke kf kt kh ki kj ku kl km kn kv kp kq kr ks ig bi translated"><em class="jw">更多内容请看</em><a class="ae kw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="jw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>