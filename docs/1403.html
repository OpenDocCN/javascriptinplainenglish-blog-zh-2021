<html>
<head>
<title>I Come Here Not to Praise Redux, But to Bury it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我来这里不是为了赞美Redux，而是为了埋葬它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-come-here-not-to-praise-redux-but-to-bury-it-d29f4bde4653?source=collection_archive---------12-----------------------#2021-03-24">https://javascript.plainenglish.io/i-come-here-not-to-praise-redux-but-to-bury-it-d29f4bde4653?source=collection_archive---------12-----------------------#2021-03-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7c71" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Redux对于普通用途来说已经太大了。我建议使用一个更小、更易于使用的TypeScript + React系统，称为evalvite</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/23390cf5e3c7094a29e881c91b145cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0eNS8SafYnQFJbM8FOdeA.jpeg"/></div></div></figure><blockquote class="ko kp kq"><p id="1bd1" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">小丑对小偷说<br/>这里太混乱了<br/>我无法解脱</p></blockquote><p id="24ec" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">Redux是一个巨大的东西。带着些许悲伤，我也认为这是一件重要的事情。我在这里指的是<em class="kt">巨大的</em>在两种意义上的常见用法:巨大是因为它有许多行代码，尤其是当你考虑到它的必要表亲，如“redux-react”、“redux-devtools”、“redux-persist”、“redux-thunk”，甚至是表亲的祖父“redux toolkit”我甚至不考虑一个有<em class="kt">还原传奇</em>的世界。另一种“巨大”的感觉是有很多采用、牵引、用户或思想共享的东西。例如，带有伯尼·桑德斯手套的迷因是(曾经是？)，毫无疑问，<em class="kt">巨大。</em></p><p id="d0b5" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">许多React应用程序的整个操作都依赖于Redux。(React是另一个“巨大”的东西，但那是改天的话题。)使用Redux和React的争论，或者更直接地说，响亮、粗俗的争论通常归结为这样一个概念，即当Redux用于驱动React组件时，React组件可以变得更具有声明性。(声明性必然更好的原因通常没有解释。)那些提出上述论点的人通常会指出这样一个事实，即人们可以<em class="kt">声明</em>从状态(Redux)到显示(React)的转换，并保证它总是为真。这是一种保证，就像“如果你不吸烟，你不会得肺癌”一样(有点错误)当然，不吸烟当然是一个很大的帮助，但有很多重要的细节隐藏在这句话里。</p><p id="f5ea" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">这篇文章的论点是Redux已经变得太大、太复杂，而且一般来说太重<em class="kt">以至于不能在实际的React应用程序中使用；复杂性并没有给我们带来足够的回报。是的，是的，我知道Redux的核心可以很小，但大多数人现在在Redux上涂上足够多的糖霜，足以导致一个相当大的欧洲国家的全部人口患糖尿病。向B. Stroustrup道歉。</em></p><h1 id="2003" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">Redux内部是一个小而简单的数据流系统，它拼命地想要出去。</h1><h1 id="1999" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">以打字打的文件</h1><p id="2b0b" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">本文关注在TypeScript中使用Redux我不会用普通的JavaScript来评论Redux。我可以提出一大堆理由来解释为什么这段婚姻会触礁，但是我认为一个单独的、经常使用的类型声明<code class="fe mo mp mq mr b">AsyncThunkActionCreator</code>可以解释我所需要的一切:</p><pre class="kd ke kf kg gt ms mr mt mu aw mv bi"><span id="2fe4" class="mw ls in mr b gy mx my l mz na">declare type AsyncThunkActionCreator&lt;Returned, ThunkArg, ThunkApiConfig extends AsyncThunkConfig&gt; = IsAny&lt;ThunkArg, (arg: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt;, unknown extends ThunkArg ? (arg: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt; : [ThunkArg] extends [void] | [undefined] ? () =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt; : [void] extends [ThunkArg] ? (arg?: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt; : [undefined] extends [ThunkArg] ? WithStrictNullChecks&lt;(arg?: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt;, (arg: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt;&gt; : (arg: ThunkArg) =&gt; AsyncThunkAction&lt;Returned, ThunkArg, ThunkApiConfig&gt;&gt;;</span></pre><p id="6078" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">如果当你看代码样本时，你的目光呆滞，那么恭喜你，你是一个半正常的人类。</p><p id="08c5" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">我不是说<code class="fe mo mp mq mr b">AsyncThunkActionCreator</code>的打字是<em class="kt">坏了</em>，我是说<em class="kt">错了。</em>在这里被破坏意味着上面没有像宣传的那样工作，或者在某些方面需要<em class="kt">修复</em>才能工作；这不是问题所在。相反，这个代码是错误的，因为它是被<strong class="ku io">而不是</strong>破坏的事实让我担心人类的未来。这也让我想到，“当你需要宣言来实现它时，什么能让你相信你正在做的是一个好主意？”</p><h1 id="3aee" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">小Redux的大麻烦</h1><p id="4d3e" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">简而言之，Redux最大的四个问题详述如下。如果你不同意这些是问题，或者问题大到足以证明更换工具是正确的，那么你可以回到你定期安排的努力，以确保一个Playstation 5。</p><ul class=""><li id="6708" class="nb nc in ku b kv kw ky kz lo nd lp ne lq nf ln ng nh ni nj bi translated">将Redux与React一起使用时，您肯定需要理解的概念:Redux、组合Redux、actions、action creators、dispatch、mapStateToProps、mapDispatchToProps，以及何时何地可以修改状态、选择器、存储和异步thunks。根据您的工具和应用，您可能还需要了解切片、中间件、增强器和immer。</li><li id="a91a" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">Redux的打字和typescript不太协调，如果你能忍受的话，再读一遍上面的内容。它们确实有效，但肯定不简单。首先，当你在编辑器中得到一个错误时，你会注意到“解释”它的工具提示覆盖了你的半个屏幕，内容看起来是调制解调器线路噪声！这是因为使Redux与Typescript一起工作所需的类型声明极其复杂。其次，通过connect()使用HOC或更高阶的组件意味着您必须理解redux-react通过connect()生成的包装器，以及它如何与您的代码(被包装的对象)相关联。这已经成为一个问题，Redux Toolkit创建了<code class="fe mo mp mq mr b">ConnectedProps</code>来试图改善一些问题。(Post scriptum: Reddit用户acemarke纠正我说<code class="fe mo mp mq mr b">ConnectedProps</code>来自react-redux而不是我上面写的Redux Toolkit。我为这个错误道歉。)</li><li id="be0f" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">Redux的性能与减速器的数量成比例。Redux将所有调度的动作传递给所有的减速器，从而保证<strong class="ku io">app的所有</strong>部件的性能都受到添加<strong class="ku io">任何</strong>新减速器的影响。换句话说，一旦你的Redux数量足够大，你用Redux做什么都没关系，都会很慢，哪怕你在做的操作简单到翻转一点点。</li><li id="0bc0" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">Redux对<code class="fe mo mp mq mr b">&lt;Provider&gt;</code>的设计是将底层数据值的一部分从存储中推入props供组件使用，通常是为了进行可视化显示。<code class="fe mo mp mq mr b">mapStateToProps()</code>控制组件看到哪些值。这个函数名字的讽刺意味不应该被忽略。很明显，Redux store代表了你的应用程序的<strong class="ku io">状态</strong>，然而成熟的<strong class="ku io">状态</strong>的React概念却被忽略了。</li></ul><blockquote class="ko kp kq"><p id="67df" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你可能会问自己，我该怎么做？</p></blockquote><h1 id="1cb4" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">evalvite</h1><p id="33a0" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">为了尝试修复上面列出的问题，我构建了<em class="kt"> evalvite </em> : bad french，意为“快速评估”。软件的名字没有大写。这里是它与Redux的主要对比，所以如果你不在乎这些，你可以回到你定期安排的努力，从百思买的网站上狙击Playstation 5。</p><ul class=""><li id="ec3f" class="nb nc in ku b kv kw ky kz lo nd lp ne lq nf ln ng nh ni nj bi translated">evalvite具有属性(自动维护的数据值)和模型(属性的集合)的概念。就是这样。</li><li id="3f5e" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">evalvite是为Typescript设计的，具有强类型，所有的类型声明都有直接意义，例如<code class="fe mo mp mq mr b">Attribute&lt;number&gt;</code>或<code class="fe mo mp mq mr b">Attribute&lt;string&gt;</code>。</li><li id="359e" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">evalvite软件是增量的，因为EvalVite是算法(见Hudson '93)。这里的增量意味着维护数据模型所做的工作量与对数据模型所做的更改量成比例。小变化比大变化快。</li><li id="68af" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">evalvite将React组件模型的值放入所述组件的“状态”中。这意味着<code class="fe mo mp mq mr b">render()</code>可以简单地咨询<code class="fe mo mp mq mr b">this.state</code>来完成它的工作。</li><li id="f50b" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">异步调用不需要特殊的技巧，比如从网络上获取数据。您可以正常处理承诺，根据需要设置属性值。</li></ul><p id="6ba2" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><em class="kt">注意:evalvite目前只支持基于类的React组件。没有已知的原因使</em>不能<em class="kt">工作功能组件(FCs ),但是作者更喜欢基于类的组件。如果你是FCs，hooks等方面的专家，请提交一份PR来解决文章末尾列出的回购问题！</em></p><h1 id="aa26" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">通过示例进行评估</h1><p id="7a7a" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">用evalvite的话来说，您需要为每个React组件创建一个<em class="kt">模型</em>。如果您的React应用程序中有一个<code class="fe mo mp mq mr b">FooList</code>和一个<code class="fe mo mp mq mr b">FooListItem</code>组件，那么您可能会有<code class="fe mo mp mq mr b">FooListModel</code>和<code class="fe mo mp mq mr b">FooListItemModel</code>包含各自组件显示的数据。evalvite保证来自模型的最新值在您所在的州总是可用的，所以<code class="fe mo mp mq mr b">render()</code>很容易。</p><p id="85e6" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">让我们做一个愚蠢的，但教学上有趣的例子。有几个例子也可以在evalvite发行版中帮助您。</p><p id="37bd" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">我们将定义一个复选框，它的文本内容从普通变为粗体。是的，很傻，但是看看evalvite如何解决UI问题，比redux简单很多，还是很有用的。</p><h1 id="e473" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">定义模型</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="50fa" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">上面的模型在发行版中的文件<code class="fe mo mp mq mr b">example1/models.ts</code>中，通常将模型放在它们自己的文件中是很方便的，因为如果不分离模型，经常会导致导入循环。这在这里并不是绝对必要的。</p><p id="eb3c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">正如您所看到的，模型只包含一个属性，如果复选框很重要，它就是一个布尔值，如果是，它将以粗体显示。</p><h1 id="c188" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">类型声明</h1><p id="39cd" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">让我们看看我们需要什么声明，通常在组件的文件中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="bcd5" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">组件本身</h1><p id="d552" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">因此，与任何React组件一样，您需要定义组件的属性和状态。上面我们遵循了从父模型向下传递模型的React和evalvite约定。这不是强制性的，而是“反应性的”通常，属性<code class="fe mo mp mq mr b">model</code>用于包含在models.ts中定义的模型的副本。</p><p id="e810" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">自然，我们现在需要定义组件。不需要Redux使用的任何“额外功能”，如Provider、mapStateToProps、connect、mapDispatchToProps等。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9896" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">关于这个定义，有几点值得注意。在构造函数中，我们使用了<code class="fe mo mp mq mr b">bindModelToComponent</code>来通知evalvite，当模型更新时，应该重新绘制这个组件。虽然这个模型只有一个属性，但是当一个模型有几个属性改变为<strong class="ku io">时，绑定到组件的模型中的任何</strong>属性都会导致重绘。</p><p id="b442" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">很容易看出，change函数与复选框的onChange相关联，它唯一的动作是操纵模型。这是使用evalvite时的典型安排:您只需根据需要更新模型，让evalvite处理其余的工作。请注意，如果有其他属性是从模型的重要字段或其他组件中计算出来的，并且因为这一更改而需要更新，那么这些属性将被自动处理。</p><h1 id="9b56" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">从属属性</h1><p id="eb75" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">记住这个简单的例子，我们将尝试用属性可以相互依赖的思想来扩展您的思维。这些可以以你想要的任何方式跨越模型，但是我们将定义一个只依赖于它自身部分的模型。(旁白:如果您愿意，您还可以将同一个模型传递给不同的组件。)这个完整的示例在示例3的分布中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a077" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">这个相对愚蠢的应用程序允许你显示任意数量的可以输入数字的框(<input type="”text”/"/>)。所有这些计算都是基于整个输入字段集进行的。计算属性的构造函数的第一个参数是用于更新属性值的函数。第二个参数是新声明属性的依赖属性数组；这些属性的<em class="kt">值</em>在必要时被传递给作为第一个参数的函数。第三个参数仅用于调试输出。众所周知，EvalVite在所执行的函数评估数量方面是最优的，尽管这并不能保证该算法在所执行的工作量方面是最优的；EvalVite不知道计算不同的函数有多贵。</p><p id="b071" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">evalvite自动更新值的一个可能意想不到的副作用是，在向类似“1234”的文本框中键入数字的过程中，从新数字中导出的值会被更新。因此，在您完成输入之前，您会得到1、12和123的更新。</p><p id="d39c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">这里第一个重要的想法是这个模型的字段内容是一个数组。当这个数组的内容改变时(push、pop等)<strong class="ku io">或</strong>当数组中的任何元素改变时，相应的属性被更新，呈现它们的组件被重画。自然，数组的内容本身应该是一个模型，就像React中有FooList和FooItemList组件一样。</p><p id="ee03" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">这个模型中展示的第二个重要思想是属性可以从其他属性中计算出来。evalvite维护必要的数据结构，以便了解哪些属性是从其他属性派生的，以及它们需要以什么顺序进行计算。除了内容之外的所有属性都是从内容(输入框中的一组数字)中派生出来的，或者是从内容的其他属性中派生出来的！</p><p id="7a94" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">如果您检查属性isDefined，您将看到我们正在计算一个布尔属性，只有当内容不为空时，该属性才为真。这是许多界面中的一个常见任务，当列表内容为空时，显示一个组件的完全不同的呈现。在NumberList(未显示)的render()函数中，对于isDefined为false的情况，我们采用不同的代码路径。</p><p id="e5ef" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">另一个有趣的属性是这个模型的平均场。它取决于isDefined防止被零除的问题。它还依赖于sum和number字段分别为平均值计算提供分子和分母。显然，必须确保在平均值之前更新总数和数字。这就是为什么EvalVite维护属性之间的依赖关系图，并在进行更新时对所述图进行拓扑排序。</p><h1 id="4645" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">结论</h1><p id="8542" class="pw-post-body-paragraph kr ks in ku b kv mj jo kx ky mk jr la lo ml ld le lp mm lh li lq mn ll lm ln ig bi translated">github.com/iansmith/evalvite是上面探索的系统，与TypeScript一起干净地工作，大约800行代码，将为1983年的道奇Dart提供动力，并将在冰淇淋上品尝美味。这个简单的应用程序中有一些简单的例子供你借鉴。</p><p id="4ee7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">如果你需要提醒Redux为什么跌倒并且爬不起来，可以将本文中的例子比作</p><ul class=""><li id="96f5" class="nb nc in ku b kv kw ky kz lo nd lp ne lq nf ln ng nh ni nj bi translated">https://redux.js.org/recipes/usage-with-typescript<a class="ae nr" href="https://redux.js.org/recipes/usage-with-typescript" rel="noopener ugc nofollow" target="_blank"/></li><li id="9af6" class="nb nc in ku b kv nk ky nl lo nm lp nn lq no ln ng nh ni nj bi translated">https://redux-toolkit.js.org/tutorials/typescript<a class="ae nr" href="https://redux-toolkit.js.org/tutorials/typescript" rel="noopener ugc nofollow" target="_blank">(注意前提条件！)</a></li></ul><blockquote class="ko kp kq"><p id="0ef3" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你好吗，指挥官先生？</p></blockquote></div></div>    
</body>
</html>