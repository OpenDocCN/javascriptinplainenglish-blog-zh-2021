<html>
<head>
<title>LeetCode Algorithm Series: Valid Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:有效括号</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7?source=collection_archive---------18-----------------------#2021-09-03">https://javascript.plainenglish.io/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7?source=collection_archive---------18-----------------------#2021-09-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2875f66e850204924bdb12446d4b7980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGwdfZFE8JZRksvPxkQQ9g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ad0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你好！让我们深入另一个算法问题。今天的问题来自Leetcode的顶级面试问题——轻松在<em class="ky">其他</em>章节下。</p><p id="e9cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">有效括号</strong>中:</p><blockquote class="kz la lb"><p id="c2cd" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">给定一个仅包含字符<code class="fe lf lg lh li b">'('</code>、<code class="fe lf lg lh li b">')'</code>、<code class="fe lf lg lh li b">'{'</code>、<code class="fe lf lg lh li b">'['</code>和<code class="fe lf lg lh li b">']'</code>的字符串<code class="fe lf lg lh li b">s</code>，确定输入的字符串是否有效。</p><p id="dc28" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">在以下情况下，输入字符串有效:</p><p id="2d08" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">左括号必须用相同类型的括号括起来。</p><p id="dafd" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">左括号必须以正确的顺序结束。</p></blockquote><p id="87d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e65e" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> s = "()"<br/><strong class="li io">Output:</strong> true</span><span id="9fff" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> s = "()[]{}"<br/><strong class="li io">Output:</strong> true</span><span id="40d1" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> s = "(]"<br/><strong class="li io">Output:</strong> false</span><span id="5f09" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> s = "([)]"<br/><strong class="li io">Output:</strong> false</span><span id="86e7" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> s = "{[]}"<br/><strong class="li io">Output:</strong> true</span></pre><p id="ac7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是遵循两个验证:一个开括号必须由相同类型的括号括起来，并且它们必须以正确的顺序括起来。所以我需要遍历输入字符串，识别括号的类型，是左括号还是右括号，以及它是否正确匹配到它的对应部分。</p><p id="ba37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我知道我需要循环输入字符串，所以我继续设置我的初始循环。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="481f" class="lr ls in li b gy lt lu l lv lw">for (let i = 0; i &lt; s.length; i++) {<br/>// do something here with s[i]<br/>}</span></pre><p id="170f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我希望能够比较我所在的当前字符串字符，以确定正确的括号。此外，因为括号在打开和关闭时需要是相同的括号，所以我需要设置那个连接。我可以用一个数据结构解决这两个问题。有什么猜测吗？</p><p id="495a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">…</p><p id="9d80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你说的是Object(或者Hash或者Dictionary，取决于语言)你就对了！我设置了一个名为map的对象，其中左括号是键，值是右括号。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="7b35" class="lr ls in li b gy lt lu l lv lw">const map = {<br/>        '(': ')',<br/>        '{': '}',<br/>        '[': ']'<br/>}</span></pre><p id="0724" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当我遍历输入字符串时，如果我遇到一个左括号，那么我想继续遍历输入字符串。如果我遇到一个右括号，那么我想检查是否以正确的顺序与左括号<strong class="kc io">匹配。为此，我使用push()和pop()方法建立了一个数组，以正确的顺序存储所有的左括号。然后，当我遍历输入字符串时，每当我遇到一个左括号，我就可以把它添加到数组中。当我遇到一个右括号(也不是左括号)时，我可以把最后一个左括号添加到数组中，并检查它们是否匹配。如果是，我们继续循环输入字符串。如果它们不匹配，那么我有无效的括号，我可以返回false。</strong></p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b95d" class="lr ls in li b gy lt lu l lv lw">for (let i= 0; i &lt; s.length; i++) {<br/>    if (s[i] in map) {<br/>        k.push(s[i])<br/>    } else {<br/>        let opening = k.pop()<br/>        if (map[opening] !== s[i]) {<br/>            return false<br/>        }<br/>    }<br/>}</span></pre><p id="7de8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，我在字符串中循环。首先，使用操作符中的<strong class="kc io">来检查我是否有一个开括号。如果我这么做了，我就把左括号放入数组。如果不是，那么我有一个右括号。该右括号必须与我添加到数组中的最后一个左括号匹配，才能被认为是正确的顺序。我使用pop()方法获取最后添加的左括号。知道了左括号，我就可以在我的对象中访问与它相关的值，以便与输入字符串中我当前所在的右括号进行比较。如果它们不匹配，那么我返回false。如果它们匹配，那么我继续遍历字符串。</strong></p><p id="1a42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我添加的一些最后润色是:</p><ol class=""><li id="272b" class="ly lz in kc b kd ke kh ki kl ma kp mb kt mc kx md me mf mg bi translated">有效的括号总是意味着输入字符串需要偶数个字符。如果字符串长度是奇数，这意味着我将有一个额外的无效的左括号或右括号。所以不用遍历整个数组得出结论，我可以做这个简单的检查，而不用运行整个方法，这样可以节省很多时间。</li><li id="e15d" class="ly lz in kc b kd mh kh mi kl mj kp mk kt ml kx md me mf mg bi translated">如果我遍历整个字符串而不返回false，那么我必须有一个有效的字符串，对吗？你几乎是正确的。想象输入字符串是<strong class="kc io">“{ {((“</strong>)。由于长度是偶数，该方法将继续并循环遍历字符串。该循环永远不会返回false，因为它们都是看起来要关闭的左括号。这仍然是无效字符串。所以最后，我不是在完成循环的<strong class="kc io">后才返回true，而是通过三元运算符使用条件逻辑来检查我的数组是否为空。如果数组是空的，那就意味着我正确地匹配了每个括号。如果我在数组中有剩余的东西，那么我没有，所以我需要返回false。</strong></li></ol><p id="5212" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住这一点，查看完整的代码:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b4e9" class="lr ls in li b gy lt lu l lv lw">var isValid = function(s) {<br/>    if (s.length % 2 !== 0){return false}<br/>    <br/>    let k = []<br/>    <br/>    const map = {<br/>        '(': ')',<br/>        '{': '}',<br/>        '[': ']'<br/>    }<br/>    <br/>    for (let i= 0; i &lt; s.length; i++) {<br/>        if (s[i] in map) {<br/>            k.push(s[i])<br/>        } else {<br/>            let opening = k.pop()<br/>            if (map[opening] !== s[i]) {<br/>                return false<br/>            }<br/>        }<br/>    }<br/>    <br/>    return k.length !== 0 ? false : true<br/>};</span></pre><p id="457a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样做的时间复杂度是O(n ),因为我知道我的for循环将根据输入(n)的值运行。<strong class="kc io"> </strong>在LeetCode上运行这个，运行时间是<strong class="kc io"> 83ms </strong>，只比提交的<strong class="kc io"> 29.44% </strong>好。但是，看看其他一些50毫秒-70毫秒(前90%)的解决方案，我的代码几乎是相同的。此外，我确信有一种递归的方法可以完成这个解决方案，从而提高性能。</p><p id="d500" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有一个不同的方法来解决这个问题，或者你是如何解决这个算法的，我很乐意听到我的代码如何改进。如果你正在与它斗争，我希望这有助于澄清它！</p><p id="4e96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请关注未来更多的LeetCode解决方案！</p><p id="3225" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="kz la lb"><p id="6470" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="d6d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>