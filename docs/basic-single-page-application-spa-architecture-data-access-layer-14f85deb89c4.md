# 基本单页应用程序(SPA)架构

> 原文：<https://javascript.plainenglish.io/basic-single-page-application-spa-architecture-data-access-layer-14f85deb89c4?source=collection_archive---------12----------------------->

## 数据访问层

![](img/e4aff8eac8e2a4c209b582a4d8f7477c.png)

Zentrum Paul Klee Museum by [Ricardo Gomez Angel](https://unsplash.com/@ripato)

这里没有令人难以置信的见解，没有热门话题，也没有值得鼓掌的东西。这是一个简单的规则，我在我建造的每一个温泉浴场都遵循它——无论大小。对我来说，这是显而易见且有意义的。我无法想象维护一个没有专用数据访问层(DAL)的应用程序。当人们直接从他们的组件访问 API 时，我总是看到同样的问题发生。DAL 是一种钛子弹解决方案(银子弹不存在)，可以一次解决所有这些问题。

*数据访问层*在技术上可能不是正确的术语，但英语中的解释足够有意义，我就是这么用的，所以如果我错了就起诉我。

**TL；DR:** 为您的组件构建一个专用的共享数据访问层。永远不要直接从组件访问 API。

我们来看看这些琐碎的 Vue 组件，这样我就可以说明我的委屈了。

如果您不熟悉 Vue，我们的第一个组件从组件的挂载钩子中的 API 获取一个待定“ToDo”列表，将其设置为一个数据属性，然后遍历集合以在列表中显示一个“ToDo”组件。下一个组件做了几乎相同的事情，但是获取最近完成的待办事项。最后，我们有一个组件，它基于一个 id 获取一个 todo。

我在这里提到的这些问题没有一个是 Vue 独有的，我在 React 中也经常看到它们。我不喜欢棱角分明，所以谁知道那个世界会发生什么。Svelte 和 Elm 太单纯了，不会有这些问题🤘

# 这段代码让我想哭的原因

## 结构耦合

(不必要的)耦合一般不好。尽可能避免它。我打赌你从来没听过这个。停下来，欣赏这句深刻的话，它震撼了你的内心，让你质疑你所知道的关于构建软件的一切。

结构耦合并不总是一个问题，但它是我所看到的最普遍和最有害的问题。

从表面上看，这种耦合似乎是无害的，尤其是在下列情况下:

*   您已经在 SPA 和 API 之间共享了类型定义(实际上在我的大型项目经验中相对较少)，这意味着您在数据结构上获得了良好的类型安全性和一致性
*   您有一个很少改变的稳定的 API，并且有良好的契约测试

结构耦合使得修改 API 契约变得非常困难。如果您想要重命名一个字段或更改您的响应结构，我们现在必须在所有三个组件中更新它。如果您将 TypeScript 与共享类型定义一起使用，您可能会通过静态分析来获得这一点，并避免发送损坏的代码。修复它仍然是一件痛苦的事情——实际上，可能有 20 个组件而不是 3 个组件需要更改。

我认为这种耦合是有害的，因为它有一个微妙的问题，熟悉无处不在的语言概念的人可能会意识到。语言和上下文是必不可少的，没有理由相信你的前端和后端不能从分离他们谈论和思考数据的方式中受益。随着项目的增长，在应用程序的入口点重命名、忽略、组合或转换数据的能力可以降低认知的复杂性。

使用 DAL 解决了结构耦合，因为 DAL 封装了从外部系统(您的 API)获取数据并将其转换成对前端有意义的结构的逻辑。当我们改变我们的 API 时，我们只需要在前端的一个地方——在 DAL 代码中——进行必要的改变。在 Vue 中，我们将通过为 Todos 创建一个专用的 Vuex 商店来实现这一点。我们的三个组件中的每一个都将从 Vuex 商店获取它们的待办事项列表。

## 欢迎来到分布式系统的世界

作为一个神奇的全栈独角兽🦄，有了穆罕默德·阿里的自信和麦克拉温的才华，我可以在前端架构上给人们讲课，尽管我的大部分时间都花在后端。

生活在分布式系统世界中的一个症状是，你会不断地想到彼得·多伊奇和他的分布式系统的地狱般的 T2 谬误。建造水疗中心也有类似的问题，我们需要注意所有的谬误，但是下面这些主要适用于我现在的咆哮:

*   网络是可靠的
*   延迟为零
*   带宽是无限的
*   运输成本为零

在我们天真的实现中，我们做了很多不必要的工作。每当组件呈现时，我们都从 API 中重新获取(很可能是相同的)数据。

即使在一个带宽不断增加、数据流量无限的世界里，我们也应该清楚自己需要获取多少数据。减少我们获取的应用程序数据可以让我们将更多的带宽用于广告和其他改进网络的膨胀软件。

这个世界上仍有一些地方的互联网连接不可靠。虽然您可能不一定在这些闭塞的地方(如纽约地铁)为客户服务，但有许多方法可以影响网络可靠性，而不涉及在地下的钢管中飞驰。

虽然延迟确实淘汰了那些从未真正关心过你的应用程序的伪装者，但它也可能会因为糟糕的 lighthouse 分数而让你失去在 Twitter 上吹嘘的权利。一般的“最佳实践”是尽可能减少延迟。显而易见的解决方案是减少数据在显示之前必须经过的距离。虽然我没有对此进行基准测试，但是从本地缓存读取应该比从最近的 AWS 数据中心读取要快。

如果你有一个集中的 DAL，你可以在一个地方实现缓存逻辑。如果你是通过代码的总行数来获得报酬，你会发现这种策略对你的银行账户不利。

像[沃尔特·米歇尔](https://en.wikipedia.org/wiki/Stanford_marshmallow_experiment)这样的人可能会说，现在消费陈旧的数据，而不是推迟对新数据的满足，会导致你的用户生活结果更差。恐怕我不同意这种解释，我更倾向于利用 ***失效而重新验证*** 的方法(受 t [his HTTP RFC](https://tools.ietf.org/html/rfc5861#section-3) 的启发)来为我的应用程序的适应良好的用户提供数据。

***stale-while-re validate***模式允许我们异步向我们的 API 发出新数据请求，同时立即显示任何(可能陈旧的)缓存数据。在第一次交互时，这将是一个空的 todos 数组。一旦 API 更新了我们的缓存，Vue 的双向数据绑定和反应将自动显示新数据。

这种模式允许我们的用户在加载数据时以有意义的方式进行交互。显然，与组件的后续交互将降低缓存更新的严重性。这种模式允许我们的用户在网络故障或高延迟的情况下与缓存的数据进行交互。

*重新验证*逻辑应仔细考虑带宽问题，不要过于激进。您可能不需要一直重新验证所有数据。

DAL 缓存可以像内存实现一样简单，利用本地存储，也可以是利用 [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 的成熟解决方案。IndexedDB 是一个用于浏览器的事务数据库系统，允许您使用类似 SQL 的查询来获取数据。它给了你很大的权力来最大化本地缓存的效用。我经常伸手去拿，我们一起看了很多。

## 关注点分离

我认为我的前端只不过是一些共享数据的可视化表示和一组交互来改变这些数据。他们应该对数据的变化做出反应。因为这是我对我的应用程序的想法，所以这是构建前端的一种真正的方式。

拥有一个共享的 DAL 意味着我的组件变得更加简单。它们不再包含任何关于数据的逻辑。(几乎)所有获取、过滤和转换数据的逻辑都存在于 DAL 中。共享的 DAL 允许组件专注于标记/表示，并管理本地状态。如果我们的组件对底层 DAL(Vue 中的默认行为)的变化有*反应*，我们就能在整个应用程序中获得良好的数据一致性。

## 测试

我们刚刚将所有的数据访问逻辑都发送到了 DAL。我们现在可以非常容易地对组件进行单元测试。我们通过清除 DAL 的状态来隔离测试我们的组件(在 Vue 的情况下，我们为每个测试显式地设置存储的状态)。不再嘲笑 fetch/axios 或处理我们组件中的任何其他严重副作用。获取数据可以被删除，我们不再需要关心测试组件中的突变/副作用。