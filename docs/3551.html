<html>
<head>
<title>Build Your Own Live Chat Web Component with Ably and AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ably和AWS构建您自己的实时聊天Web组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-live-chat-web-component-with-ably-and-aws-62fc8cadcbcd?source=collection_archive---------12-----------------------#2021-07-16">https://javascript.plainenglish.io/build-your-own-live-chat-web-component-with-ably-and-aws-62fc8cadcbcd?source=collection_archive---------12-----------------------#2021-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/22a6d6cad4eaa9f0357eab2cd22f3435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5fBnW9PHoMf2Vtm4PLlVg@2x.jpeg"/></div></div></figure><div class=""/><p id="9658" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Web组件是构建可在不同网页和web应用程序中使用的可重用功能的好方法。想象一下在React、Vue.js或Next.js等不同框架之间共享组件！在这篇文章中，我们将深入研究web组件，并向您展示如何使用Ably构建一个聊天Web组件，以及如何在使用AWS Amplify和AWS Lambda构建的应用程序中使用它。</p><p id="8c00" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Web组件是web技术的集合，在浏览器中标准化，以简化可重用标记和功能的编写。它们是定制元素、<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">阴影DOM </a>和<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement" rel="noopener ugc nofollow" target="_blank"> HTML模板</a>的组合。当它们一起使用时，它们被统称为<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>。Web组件是特定于框架的组件重用方法(如React组件和Vue.js模板)的替代方法。Web组件很有趣，因为它们没有绑定到任何运行时框架，并且所有现代浏览器都支持它们。web组件的竞争方法是在Web组件被广泛支持之前建立的，这导致许多框架开发了自己的重用和封装方法。Web组件提供了一种独立于框架的方式来为浏览器构建可重用的功能。</p><p id="2a44" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当谈到Web组件时，大多数人指的是自定义HTML元素，因为它们是最接近React或Vue中的组件模型的东西。自定义元素可以:</p><ul class=""><li id="682b" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">通过设置自己的innerHTML属性来呈现HTML。</li><li id="c884" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">通过将数据存储为自身实例的属性来封装数据。</li><li id="0503" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">跟踪存储在其属性中的数据的变化，并触发重新渲染。</li><li id="9f32" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">允许您编写在DOM中添加和删除它们时触发的代码。</li></ul><p id="d775" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们要做的第一件事是创建一个自定义元素的例子，显示一个按钮被点击的次数。为了创建这个定制元素，我们需要创建一个新的JavaScript文件，我们可以从我们的web页面引用它。首先创建一个名为<em class="li"> index.js </em>的新文件。我们将为定制元素定义一个类，并将其命名为<code class="fe lj lk ll lm b">CountComponent</code>。这将扩展HTMLElement(浏览器所有元素的基本类型):</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fd77" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个类中，我们需要为<code class="fe lj lk ll lm b">change tracking</code>定义要观察的属性。为了这个演示，我们将返回一个单字符串的数组——属性名<code class="fe lj lk ll lm b">count</code>:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6a56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要定义一些定制属性及其行为。我们为自定义的“计数”属性创建了一个<code class="fe lj lk ll lm b">getter</code>，在函数中，属性值<code class="fe lj lk ll lm b">count</code>被加载了一个对<code class="fe lj lk ll lm b">getAttribute</code>的调用，默认为<em class="li">字符串</em> <code class="fe lj lk ll lm b">"0"</code>。一旦数据被加载，我们就从JSON解析它——我们这样做是因为我们存储的任何数据都必须是字符串。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fb4e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要为我们的属性创建一个<em class="li"> setter </em>，这里我们将值序列化为JSON并在我们的元素上设置它:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1171" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管自定义元素被定义为类，但是除了调用<code class="fe lj lk ll lm b">super</code>来触发HTML元素类的基本逻辑之外，不能将任何逻辑放入它们的构造函数中。<em class="li">添加任何其他逻辑，或者错过调用super，您将在控制台中看到一个错误，元素将无法工作</em>。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0591" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们不能在构造函数中做任何有意义的工作，定制元素提供了<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks" rel="noopener ugc nofollow" target="_blank">生命周期回调</a>——可以在组件生命周期的不同部分实现的功能。我们将使用<code class="fe lj lk ll lm b">connectedCallback</code>功能。实现这个回调将导致代码在组件被添加到DOM时运行——这类似于React的<code class="fe lj lk ll lm b">componentDidMount</code>函数。在connectedCallback中，我们为计数器设置了一个默认值，并调用了一个函数，我们稍后将会看到这个函数叫做<code class="fe lj lk ll lm b">setContent</code>:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="cb36" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可用的下一个生命周期回调函数是<code class="fe lj lk ll lm b">disconnectedCallback</code>(这里显示只是为了说明，因为我们没有运行任何代码)。当您的元素从DOM中移除并销毁时，这个函数中的代码就会执行。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="084c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义元素也为我们提供了一个<code class="fe lj lk ll lm b">attributeChangedCallback</code>。每当<code class="fe lj lk ll lm b">observedAttribute</code>改变时，我们将使用该函数执行代码:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="62ca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lj lk ll lm b">setContent</code>是一个函数，当组件被添加到DOM时，以及当更新发生时，组件调用该函数。上面代码中的click处理程序可以使用<code class="fe lj lk ll lm b">this</code>关键字访问元素的属性，所以每次单击，我们都会增加值，从而触发重新呈现。<em class="li">注意:这个演示并不特别关注性能，因为它设置了整个innerHTML，并在每次调用按钮时连接一个click处理程序。这不是我们构建生产应用程序的方式！在实际的应用程序中，您不会重置整个DOM。相反，您只需更改UI中需要更新的部分。此外，</em><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"><em class="li">Shadow DOM API</em></a><em class="li">可以用于对性能更敏感的场景。</em></p><p id="c556" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在JavaScript文件的末尾，我们调用浏览器的<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define" rel="noopener ugc nofollow" target="_blank">custom elements . define API</a>——为元素提供一个标记名，并引用我们刚刚定义的类。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8800" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在可以将自定义元素JavaScript文件作为一个模块引用，并使用我们定义的标记名将我们刚刚创建的元素添加到页面中:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7bfa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且该组件呈现如下:</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/9d0e8ea5d24e80eb7503209c5b0aceb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QjvDotRDYICWZQcZK0D4g.png"/></div></div></figure><p id="28cd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将通过构建<em class="li">两个</em>定制元素来构建一个文本聊天组件——Ably Chat组件:</p><ul class=""><li id="bafd" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">js——封装交互的基础组件</li><li id="dd67" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">AblyChatComponent.js —继承自AblyBaseComponent并在Ably之上实现聊天逻辑的元素。</li></ul><p id="8e7f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本组件被严格设计为构建在Ably API密钥管理和订阅通道的基础之上，并且封装了Ably API密钥管理和订阅通道的基本需求。使用这个基础组件，我们可以构建任何依赖于实时消息传递的定制元素。</p><p id="42ca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了连接到Ably，你需要一个Ably账户和一个API密匙。</p><h1 id="6271" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">构建基础组件</h1><p id="11df" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">基本组件从标准定制元素样板开始— AblyBaseComponent扩展HTMLElement，并调用其构造函数。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="82bd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在connectedCallback函数中，我们调用<code class="fe lj lk ll lm b">this.connectToAblyChannel</code>(我们将很快对此进行研究):</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a958" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">disconnectedCallback函数循环通过<code class="fe lj lk ll lm b">this.subscribedChannels</code>(我们将在<code class="fe lj lk ll lm b">connect</code>函数中创建)并取消订阅任何已使用的Ably频道:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6eea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lj lk ll lm b">connectToAblyChannel</code>函数是大量实际工作发生的地方。我们从加载一些配置开始——我们将建立一个约定，我们期望用户提供<em class="li">他们的Ably API密钥，或者一个API的回调URL，该API使用Ably令牌认证请求进行响应。为了提供这些值，并且因为我们正在创建HTML元素，<strong class="jx iz">我们希望当在标记中创建元素时，它们被设置为元素的属性</strong>。</em></p><p id="710d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了在连接元素时读取数据属性，我们希望元素看起来如下:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b46b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要设计一种方法来配置Ably客户端。在常规JavaScript中，您可能会使用<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/Document" rel="noopener ugc nofollow" target="_blank">文档API </a>来与DOM中的元素进行交互——但是因为我们实际上是在自定义元素内部<em class="li">,所以我们可以使用DOM API调用，比如从<code class="fe lj lk ll lm b">this</code>对象调用<a class="ae kt" href="https://www.w3schools.com/jsref/met_element_getattribute.asp" rel="noopener ugc nofollow" target="_blank"> getAttribute </a>。</em></p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="dca2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码试图加载<code class="fe lj lk ll lm b">data-api-key</code>和<code class="fe lj lk ll lm b">data-get-token-url</code>。如果找到一个API键，它就优先，否则，我们创建一个包含“authUrl”属性的JavaScript SDK配置对象。现在我们有了一个配置对象(或者是API键或者是URL)，我们可以创建一个实时JavaScript SDK的实例。<em class="li">需要指出的是，这个定制元素依赖于包含它的页面，该页面在执行之前已经使用一个脚本元素包含了Ably JavaScript SDK。</em>在<code class="fe lj lk ll lm b">connectToAblyChannel</code>函数中，下面的代码是在配置之后出现的:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fb5b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们有了存储在变量<code class="fe lj lk ll lm b">this.ably</code>中的SDK实例，我们还将创建一个名为<code class="fe lj lk ll lm b">subscribedChannels</code>的空数组。</p><p id="d488" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将以AblyBaseComponent中的两个附加函数来结束——一个<code class="fe lj lk ll lm b">publish</code>函数和一个<code class="fe lj lk ll lm b">subscribe</code>函数。</p><p id="d48c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦您调用了<code class="fe lj lk ll lm b">ably.channels.get(channelName)</code>来获得一个通道，常规的Ably SDK就会公开发布和订阅功能。对于这个聊天示例，我们希望让AblyChatComponent决定它将在哪些通道上发布和订阅，从而有效地扩展Ably SDK的API表面积(API可以做的事情的集合)。</p><p id="e5a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">增强的发布和订阅功能在开始时接受一个额外的参数——频道名称——然后将其余的参数传递给Ably SDK来为我们完成所有的艰苦工作。我们通过析构<em class="li"> arguments </em>数组并忽略第一个元素来做到这一点。这允许我们在新定义的变量<code class="fe lj lk ll lm b">args</code>中捕获除第一个参数之外的所有参数:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9560" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们可以在Ably SDK的发布或订阅调用中使用<code class="fe lj lk ll lm b">.apply</code>,将剩余的变量传递给SDK来发布或订阅消息。</p><p id="8c1f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用第一个参数<code class="fe lj lk ll lm b">channelName</code>来获取正确的通道并跟踪它，这样当我们从DOM中卸载时就可以取消订阅。下面的代码将放在<code class="fe lj lk ll lm b">publish</code>函数中，参数赋值的下面。订阅功能的工作方式类似</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a2fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，<code class="fe lj lk ll lm b">publish</code>和<code class="fe lj lk ll lm b">subscribe</code>实际上是相同的函数——除了我们分别传递给它们对<code class="fe lj lk ll lm b">channel.publish</code>或<code class="fe lj lk ll lm b">channel.subscribe</code>的调用。</p><p id="6d1e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来有点像框架，但这意味着在这个基类之上构建Ably组件的开发人员可以在调用开始时使用额外的<code class="fe lj lk ll lm b">channelName</code>参数调用<code class="fe lj lk ll lm b">publish</code>或<code class="fe lj lk ll lm b">subscribe</code>，而不用担心与Ably通道的连接或断开。</p><p id="0e37" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个基类包含了我们所有的代码，现在我们可以在它的基础上构建令人兴奋的组件了，所以让我们创建第二个组件，AblyChatComponent。</p><h1 id="61b1" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">构建聊天组件</h1><p id="a081" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">这些组件被设计为作为ES6模块导入——其中您在HTML中使用的脚本标签将<code class="fe lj lk ll lm b">type="module"</code>作为属性。当使用ES6模块时，我们可以在浏览器组件中使用<code class="fe lj lk ll lm b">import</code>,所以从这里开始，我们导入AblyBaseComponent来扩展它。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="b6bb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来要做的是为元素设置一些样板代码。定义一个名为“消息”的属性，并将其设置为可观察的。接下来，设置<code class="fe lj lk ll lm b">constructor</code>，它又通过调用<code class="fe lj lk ll lm b">super();</code>来调用<strong class="jx iz"> AblyBaseComponent </strong>的构造函数。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="d08d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<code class="fe lj lk ll lm b">connectedCallback</code>来配置聊天应用。我们调用<code class="fe lj lk ll lm b">super.connectedCallback</code>来触发基本组件的所有配置逻辑。以下代码位于<code class="fe lj lk ll lm b">AblyChat</code>类的右括号内的<code class="fe lj lk ll lm b">constructor</code>下方:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="68bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们调用在基础上定义的<code class="fe lj lk ll lm b">super.subscribe* *</code>函数来订阅名为<code class="fe lj lk ll lm b">chat</code>的通道上的消息。正如我们前面指出的，其余的参数都是标准的JavaScript SDK参数——我们只订阅主题为<code class="fe lj lk ll lm b">chat-message</code>的消息。当收到一条消息时，我们调用一个名为<code class="fe lj lk ll lm b">this.onAblyMessageReceived</code>的函数(稍后我们将实现它)，将收到的消息作为参数传递。</p><p id="a40b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了确保应用于页面的任何CSS样式不会影响组件，反之亦然，在<code class="fe lj lk ll lm b">connectedCallback</code>的主体内，我们将生成一个随机字符串，并将其分配给一个名为<code class="fe lj lk ll lm b">id</code>的属性:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1ba3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们调用一个名为<code class="fe lj lk ll lm b">renderTemplateAndRegisterClickHandlers</code>的函数，我们很快就会看到它。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6d09" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们将浏览器焦点放在一个名为<code class="fe lj lk ll lm b">this.inputBox</code>的元素上，该元素是在呈现模板时生成的，以便使用聊天UI的人能够立即开始输入。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5162" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，当收到消息时，我们使用<code class="fe lj lk ll lm b">attributeChangedCallback</code>来更新聊天窗口中聊天气泡的innerHTML。当属性改变时，设置<code class="fe lj lk ll lm b">this.chatText</code>的<code class="fe lj lk ll lm b">innerHTML</code>并滚动到视图中。我们使用一个名为<code class="fe lj lk ll lm b">formatMessages</code>的函数，它获取消息历史，并将其转换为适合显示的HTML元素:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7114" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们设置了<code class="fe lj lk ll lm b">renderTemplateAndRegisterClickHandlers</code>函数，该函数因其用途而得名！这个函数调用另一个名为<code class="fe lj lk ll lm b">defaultMarkup</code>的函数，它接受一个参数——元素的* id *,并返回我们想要在屏幕上显示的innerHTML一个空的聊天框元素。</p><p id="38fc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦元素被呈现到DOM中，我们就可以使用<code class="fe lj lk ll lm b">querySelectorAll</code>来查找chatText、inputBox、sendButton和messageEnd元素，以便在我们的代码中使用它们:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="664f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在内部，我们还为sendButton上的点击和输入框中的每一次按键连接eventListeners，以便我们可以处理用户输入。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c3e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们之前在订阅Ably messages时提到过<code class="fe lj lk ll lm b">onAblyMessageReceived</code>函数——这个函数从<code class="fe lj lk ll lm b">this.messages</code>获取当前的消息历史，确保它最多有199条消息长，并将最新的消息添加到数组的末尾:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c8e6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个新数组然后被分配给<code class="fe lj lk ll lm b">this.messages</code>，这触发UI重新呈现，因为<code class="fe lj lk ll lm b">this.messages</code>是一个被观察的属性。</p><p id="4a87" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当按下回车键或点击发送消息的按钮时，会调用<code class="fe lj lk ll lm b">sendChatMessage</code>函数。因为我们扩展了AblyBaseComponent，所以它调用了<code class="fe lj lk ll lm b">super.publish</code>函数，传递了通道名和Ably消息有效负载:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8dbb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以看到它还负责清除文本框并关注它，以便用户可以继续聊天。</p><p id="74fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次按键都会触发<code class="fe lj lk ll lm b">handleKeyPress</code>功能。如果按键是回车键<em class="li">并且</em>聊天框中有消息，则发送聊天消息:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5ed1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lj lk ll lm b">formatMessages</code>函数负责将Ably消息历史映射到span元素中。这里有一点逻辑来检测消息是否是由应用程序的当前用户发送的，方法是对照<code class="fe lj lk ll lm b">ably.connection.id</code>属性检查<code class="fe lj lk ll lm b">message.connectionId</code>属性，并添加一个可以将样式应用于的<code class="fe lj lk ll lm b">me</code>或<code class="fe lj lk ll lm b">other</code> CSS类。消息中的<code class="fe lj lk ll lm b">data</code>属性用于携带接收到的文本消息。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7d83" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面总结了自定义元素类。自定义元素类结束后，我们有两个函数。第一个是<code class="fe lj lk ll lm b">uuidv4()</code>函数——它为组件生成一个唯一的<code class="fe lj lk ll lm b">id</code>:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1074" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个是<code class="fe lj lk ll lm b">defaultMarkup</code>,它接受一个参数——组件的ID——并用它来设置生成的HTML的<code class="fe lj lk ll lm b">id</code>属性。</p><p id="1be6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们设置了这个<code class="fe lj lk ll lm b">id</code>属性，我们就可以将专门针对这个元素ID的CSS直接嵌入到输出代码中。这意味着如果自定义元素的多个实例出现在同一页面上，它们不会有冲突的<em class="li">id</em>或<em class="li">样式</em>。</p><p id="698b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一个代码片段的底部，您可以看到组件的标记——一个用于保存消息历史的<code class="fe lj lk ll lm b">div</code>,一个用于捕获用户输入的<code class="fe lj lk ll lm b">form</code>,以及之前在我们的<em class="li">查询选择器调用</em>中使用的<em class="li">类名</em>。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f9f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，很像我们开始的示例元素，我们调用<code class="fe lj lk ll lm b">customElements.define</code>来注册HTML标签:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e681" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自定义元素现在在功能上是完整的，只要AblyBaseComponent.js和AblyChatComponent.js文件都包含在web应用程序中，就可以通过引用我们的AblyChatComponent.js作为模块来使用它们。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ccce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用现在注册的定制元素，我们像使用任何旧的HTML标记一样使用它，并为它提供正确的属性:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5341" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该元素在页面中呈现为这样，当用API键或get-token-url配置时，它就工作了！</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mx"><img src="../Images/16d0ec8c9669f15292c4a5d59890a2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*accS2o1akWIqpwOt"/></div></div></figure><h1 id="50f9" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">API密钥管理</h1><p id="1abc" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">正如上面所暗示的，我们需要讨论API密钥管理。虽然这个定制元素支持直接从您的标记中读取Ably API键——这对本地开发和调试非常好——但是您绝对不应该在您的标记中存储Ably API键，否则，它们可能会被窃取和误用。</p><p id="1a07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前端使用API密钥的推荐方式是使用<a class="ae kt" href="https://ably.com/documentation/core-features/authentication/#token-authentication" rel="noopener ugc nofollow" target="_blank"> Ably令牌认证</a>。令牌身份验证是一种交换机制，在这种机制中，您使用真正的API密钥来生成有限使用的令牌，这些令牌可以传递回您的客户端以在前端使用。</p><p id="b04a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了以这种方式使用令牌认证，我们需要在某个地方创建一个API，从前端调用，其中存储了您真正的Ably API密钥。然后，我们可以使用Ably SDK中的一个函数将您真正的API密钥交换为一个令牌，该令牌将返回给Ably JavaScript SDK。JavaScript SDK为您管理这个令牌交换过程。当您提供一个指向将返回令牌的API的URL时，SDK将根据需要管理和刷新令牌，因此您无需担心。这个演示将通过使用AWS Lambda函数和AWS API网关来实现这一点。</p><p id="e53b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下示例AWS Lambda函数提供了必要的令牌交换功能。我们所需要做的就是要求Ably JavaScript SDK，并创建一个从<em class="li"> process.env.ABLY_API_KEY传递Ably API key的<code class="fe lj lk ll lm b">Ably.Realtime</code>客户端实例。</em></p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="30df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe lj lk ll lm b">client.auth.createTokenRequest</code>来生成一个临时令牌，并将其返回给客户端。</p><p id="bee2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">API密匙的所有者有责任确保请求临时令牌的用户能够访问聊天——您可以以任何方式验证请求，这与任何其他lambda函数中的验证没有什么不同。在下一节中，我们将在AWS Lambda上进行托管</p><h1 id="eaea" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">使用AWS Lambda进行身份验证</h1><p id="b54f" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">为了部署到AWS Lambda，我们需要创建一个名为/api/createTokenRequest的新目录，其中包含两个文件——package . JSON和index.js</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5548" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是index.js文件</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9d65" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">AWS Lambda运行时需要这两个文件以及它们的node_modules。我们将使用npm来恢复节点模块，然后将/createTokenRequest目录的内容压缩到一个zip文件中。在终端中执行以下操作:</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="afbd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，压缩createTokenRequest目录的内容(这个过程依赖于操作系统)。我们将使用AWS UI创建一个Lambda函数，并将这个zip文件作为源代码上传。</p><p id="c6f9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将完成这一过程。您需要首先<a class="ae kt" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank">登录您的AWS账户</a>:</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/93dfa15b49a5cd45c87302309407e701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anW-cDDQGryOdohFhgm2dQ.png"/></div></div></figure><ol class=""><li id="ff53" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks mz la lb lc bi translated">在服务搜索栏中搜索lambda，然后单击显示在结果中的Lambda服务框。</li></ol><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/fdc2c6ad6e76ef175f4cdfb7f2ca8519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ospwK-MdLFXcPrDTT7Lcpg.png"/></div></div></figure><p id="2eb5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.单击“创建函数”按钮创建一个新的Lambda函数。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/cfcda1a7b17739e6bfccb7290afa299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-fjd2oNYkxcz7G1WWWF-zQ.png"/></div></div></figure><p id="ae8e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.选择“从头开始创作”并给你的函数起一个名字，然后点击“创建函数”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/821ab6b8732657838ec335928805d838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYGW2Q1JhvcA1gsOaiNM6Q.png"/></div></div></figure><p id="3ba8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.创建函数后，单击“添加触发器”使Lambda函数可以通过HTTP访问。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/8a73d2c42bb197fec85c00af3212f40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzRSHkX1P8ZAAwk8biyQjw.png"/></div></div></figure><p id="93b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.从“触发配置”下拉列表中选择“API网关”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/586c584d332180c2f16bc2cf09909467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewIyIbgnTlUyyX8NJWZoiQ.png"/></div></div></figure><p id="4df4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">6.在出现的页面上，从下拉列表中选择您的功能，然后单击“添加”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/312ed529cca84f0df7c81ac5668310eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaUNK5qaurwx7oGAXAT84Q.png"/></div></div></figure><p id="65b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">7.将部署阶段设置为默认，将安全性设置为打开，然后单击“添加”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div class="gh gi na"><img src="../Images/007495b86ea8c5dd467ad8c789aa68e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*ROys3_3B8p5QZH1n1JRMHQ.png"/></div></figure><p id="325e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">8.添加触发器后，UI会在“配置”下的“触发器”选项卡中显示一个URL。(这是当您在HTML中使用您的组件时，您将作为data-get-token-url参数添加的内容，但是我们还有一些设置要做！)</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/1481411140be3468be84632f17f560ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oONg4xWifgrytiNv92QqEg.png"/></div></div></figure><p id="0645" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">9.现在您需要上传我们之前创建的zip文件。单击“代码”选项卡，然后单击“上传自”并选择”。zip文件”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/2e659be5f2bb50f7d4874ef458dd484e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hM-3ZHAZfo-p0A_B7i9tQ.png"/></div></div></figure><p id="1f5a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">10.一旦zip文件被上传，您将需要用Ably API键设置您的环境变量。在“配置”下，选择“环境变量”，然后单击“编辑”按钮</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/4ca5e8dd57d0938c907c88e73eff15b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxmCz-ZcEAdcYCvKQn7paw.png"/></div></div></figure><p id="4bf8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">11.将Ably API键添加到“环境变量”设置中。</p><p id="7542" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">就这样，你的Lambda设置好了！</strong></p><p id="b96c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们从<code class="fe lj lk ll lm b">process.env.ABLY_API_KEY</code>开始读取的index.js文件中。您将需要<a class="ae kt" href="https://knowledge.ably.com/setting-up-and-managing-api-keys" rel="noopener ugc nofollow" target="_blank">生成一个新的ably API键</a>，然后使用AWS UI中的键值定义这个环境变量(或者使用您喜欢的自动化工具)。</p><p id="cdcd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们的lambda函数被创建，我们将需要添加一个AWS API网关触发器来为我们的Lambda提供一个外部可访问的URL。这是一个URL，我们可以在HTML标记中安全地配置它来代替实际的API键。Ably SDK会处理剩下的事情。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="072f" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">在Amplify上托管您的Web组件</h1><p id="89b4" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">现在我们可以在Amplify上托管你的组件，Amplify是AWS的静态网络托管服务。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/c23011a4e6863842af3dfddd7dafefe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fI6vSvnTD70zL5czFhoexw.png"/></div></div></figure><ol class=""><li id="0f03" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks mz la lb lc bi translated">在服务搜索栏中搜索Amplify，然后点击出现的AWS Amplify链接。</li></ol><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/b91dcbe45b0611d595b2c66701ba6627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ja87b9bWPYA3QdwubY1_A.png"/></div></div></figure><p id="030f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.点击“开始”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/a655987ec293e6f34d86b5898b29c2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk9sN48BK6uKifRmOmakKQ.png"/></div></div></figure><p id="a699" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.向下滚动结果页面至“托管您的web应用程序，然后点击“开始”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/d904f863abd42a834a60908ec7f68154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkNKVJu1zTkZgxm_dopdQA.png"/></div></div></figure><p id="06ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.使用您的GitHub帐户验证AWS Amplify。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/c64e29ab5ab977c4ccc81f85787d5760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJasiL3URl76VkDOFA5mHw.png"/></div></div></figure><p id="0bd8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.选择web组件的存储库。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e27b6f50e8dd40fd72dbe2cfd123fb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*-5VE2HM6WR0pdda2wKcpbA.png"/></div></figure><p id="837e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">6.编辑您的构建设置，将npm run ci作为预构建命令包含在内，并将baseDirectory设置为“/build”。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/3f982b820488e7805853687c09b012b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9ErxiU4a25VnoUVvUbmow.png"/></div></div></figure><p id="f080" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">7.单击“保存并部署”按钮来托管您的组件。</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/290868516dfaf7f42af173d1d9270dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oroGi-DIZnK3fqYK-QUTGQ.png"/></div></div></figure><p id="6dc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">8.如果一切顺利，组件将会成功地供应、构建和部署。UI将为您提供一个URL来查看您托管的组件。</p><p id="3e07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">托管的web组件看起来会像这样:</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi my"><img src="../Images/2fc5b5e181e70ad82ff5c3ef27825411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sDGbJ6gbN6TtRVZp4Rw5Q.png"/></div></div></figure><p id="e5a3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为组件是作为普通的旧JavaScript构建的，所以我们可以使用NPM和各种浏览器友好的方式将NPM包添加到您的前端来分发和消费组件。</p><p id="89c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Ably这里，我们<a class="ae kt" href="https://www.npmjs.com/package/ably-chat-component" rel="noopener ugc nofollow" target="_blank">已经将这个组件作为ably-chat-component发布给NPM </a>，你可以使用<em class="li">的Skypack </em> CDN直接引用它。这确保了包是浏览器兼容的。</p><figure class="ln lo lp lq gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7733" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要引用客户端Ably SDK来使组件工作。然而，一旦你完成了这些，你就可以引用我们组件的Skypack URL，将ably-chat标签添加到你的页面中，设置你的API密匙，一切都将正常工作。</p><p id="b76e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是在开发模式下使用该组件的最简单的支持方式。然而，如上所述，您将需要<em class="li">切换出您的API密钥</em>来获得您自己的令牌请求URL。</p><h1 id="49c5" class="lu lv iy bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">组件架构</h1><p id="a7ee" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">概略地说，组件架构可以描述如下:</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/7dc6b95a12b057c1a441aa2bbb16fd5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15NJ5ypcey1xWazQF8KmMQ@2x.png"/></div></div></figure><p id="a653" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有相应的序列图:</p><figure class="ln lo lp lq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/6bf5627a146041f3e25595a07deb4faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dn2KnJZ-Qcsgbp1nerqYtQ@2x.png"/></div></div></figure><p id="bb73" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们分析了web组件的工作原理，探索了Web组件，并演示了如何使用AWS Amplify和AWS Lambda来托管支持实时聊天的应用程序。</p><p id="b8dd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你已经有了一个web应用程序，并且知道如何托管它，我们也谈到了你如何使用Skypack来<a class="ae kt" href="https://www.npmjs.com/package/ably-chat-component" rel="noopener ugc nofollow" target="_blank">包含这个直接来自NPM </a>的组件。</p><p id="8719" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">聊天只是您使用实时消息和Web组件的一种方式，我们很想看看您能用这个代码库做些什么。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="d547" class="lu lv iy bd lw lx nl lz ma mb nm md me mf nn mh mi mj no ml mm mn np mp mq mr bi translated">差不多</h1><p id="7e45" class="pw-post-body-paragraph jv jw iy jx b jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks ig bi translated">巧妙地提供API来实现应用程序中实时特性的<a class="ae kt" href="https://ably.com/topic/pub-sub" rel="noopener ugc nofollow" target="_blank">发布/订阅</a>消息。您还可以获得现成的全球分布式可扩展基础架构，以及一套服务。这些功能包括<a class="ae kt" href="https://ably.com/documentation/core-features/presence" rel="noopener ugc nofollow" target="_blank">在线</a>——显示各种参与者的在线/离线状态、<a class="ae kt" href="https://knowledge.ably.com/connection-state-recovery" rel="noopener ugc nofollow" target="_blank">在间歇性网络问题的情况下自动重新连接和恢复消息</a>、<a class="ae kt" href="https://ably.com/four-pillars-of-dependability#integrity" rel="noopener ugc nofollow" target="_blank">消息排序和保证交付</a>，以及<a class="ae kt" href="https://ably.com/integrations" rel="noopener ugc nofollow" target="_blank">与第三方API</a>集成的简单方法。</p><p id="2a72" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">巧妙地启用发布/订阅消息，主要通过<a class="ae kt" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>。<a class="ae kt" href="https://ably.com/documentation/core-features/channels" rel="noopener ugc nofollow" target="_blank">通道</a>的概念允许您对数据进行分类，并决定哪些组件可以访问哪些通道。您还可以为这些通道上的各种参与者指定<a class="ae kt" href="https://ably.com/documentation/core-features/authentication#capabilities-explained" rel="noopener ugc nofollow" target="_blank">功能</a>，如仅发布、仅订阅、消息历史等。</p><p id="bfce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://ably.com/" rel="noopener ugc nofollow" target="_blank">了解更多关于Ably平台的信息</a></p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="9289" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li">最初发表于</em><a class="ae kt" href="https://ably.com/blog/ably-aws-web-components" rel="noopener ugc nofollow" target="_blank">https://ably.com/blog/ably-aws-web-components</a>。</p><p id="329f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li">更多内容请看</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="li">plain English . io</em></a></p></div></div>    
</body>
</html>