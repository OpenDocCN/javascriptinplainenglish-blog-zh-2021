<html>
<head>
<title>Linked List Basics in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的链表基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/linked-list-the-basics-with-javascript-pt-2-6392d6d16223?source=collection_archive---------24-----------------------#2021-07-08">https://javascript.plainenglish.io/linked-list-the-basics-with-javascript-pt-2-6392d6d16223?source=collection_archive---------24-----------------------#2021-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6c34" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在JavaScript中实现链表(第2部分)</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/555a3292c44f07c93729604608fa5389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D1CrYSZ1GfgvTmcQ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4c29" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">这是</em> <a class="ae ks" href="https://dhruvmohapatra.medium.com/linked-list-the-basics-with-javascript-pt-1-60404df9ed" rel="noopener"> <em class="lp"> Part 1 </em> </a> <em class="lp">的后续。</em></p><p id="6fda" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">欢迎回来！让我们开始解决一些问题。</p><p id="b5d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我用head来指代链表。因为我们是通过一个head指针来引用这个列表的，所以它在我的…head(😅).</p><p id="d6dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将继续重用这些类，这就是为什么我将它们写在这里，这样我就不必把其余的笔记弄乱了。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="3d10" class="lv lw in lr b gy lx ly l lz ma">class Node {<br/> constructor(data, next) {<br/>    this.data = data;<br/>    this.next = null;<br/> }<br/>};<br/> <br/> class SinglyLinkedList {<br/> constructor() {<br/>    this.head = null;<br/>    this.tail = null;<br/> }<br/>};</span></pre><p id="0ced" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是我们如何<strong class="kv io">反转一个链表</strong>。</p><p id="ea8d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.创建一个变量“当前”和一个等于null的变量“先前”。</p><p id="d7a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.将标题分配给当前</p><p id="ae3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.将head的next的referral赋值给head(我想说的是将head之后的节点标注为head)</p><p id="b914" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.现在让当前的紧挨着前一个——实际上是把它变成零(想象把参考旋转180度)</p><p id="f288" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.现在将current赋值给previous(现在将标签从null移动到它所连接的节点)</p><p id="0bad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">6.现在继续这样做，直到到达链表的末尾</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="4fa8" class="lv lw in lr b gy lx ly l lz ma">const reverseList (head) =&gt; {</span><span id="b064" class="lv lw in lr b gy mb ly l lz ma">   let previous = null;</span><span id="caf9" class="lv lw in lr b gy mb ly l lz ma">   let current;</span><span id="24ab" class="lv lw in lr b gy mb ly l lz ma">   while (head != null) {</span><span id="2d0d" class="lv lw in lr b gy mb ly l lz ma">      current = head;</span><span id="0fb2" class="lv lw in lr b gy mb ly l lz ma">      head = head.next;</span><span id="d9e5" class="lv lw in lr b gy mb ly l lz ma">      current.next = previous;</span><span id="741e" class="lv lw in lr b gy mb ly l lz ma">      previous = current;</span><span id="5930" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="9ca3" class="lv lw in lr b gy mb ly l lz ma">   return current;</span><span id="3a97" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="8e06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">反向打印列表</strong>非常简单。有几种方法可以做到这一点，但我最喜欢的是这个简单的递归调用。</p><p id="4067" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.如果我们不在头上，告诉程序结束</p><p id="98fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.在下一个节点上递归调用reversePrint函数</p><p id="5d66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.和打印头数据</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="ab69" class="lv lw in lr b gy lx ly l lz ma">const reversePrint = (head) =&gt; {</span><span id="ecb5" class="lv lw in lr b gy mb ly l lz ma">   if (!head) {</span><span id="ced9" class="lv lw in lr b gy mb ly l lz ma">   return;</span><span id="70b9" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="7b37" class="lv lw in lr b gy mb ly l lz ma">   reversePrint(head.next);</span><span id="1472" class="lv lw in lr b gy mb ly l lz ma">   console.log(head.data);</span><span id="01fc" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="e65b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本质上，我们要求程序自己运行这个函数。它通过第一个节点。显然还剩下更多的链表，所以它不会‘返回’/停止运行函数，它会将控制发送到下一个节点，直到我们到达末尾。现在它转过来开始执行console.log，所以它打印最后一个，倒数第二个…一直到开头。递归不是很有意义，但是我正在学习使用它，它确实对简化程序有很大帮助。</p><p id="baf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一个很有趣。我花了一段时间才弄明白，当我弄明白的时候，我觉得肩上的重担卸了下来。让我们试着<strong class="kv io">从一个特定的位置获取节点值，从尾节点</strong>开始倒数。</p><p id="4318" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想到的最明显的地方是浏览列表，将值存储在一个数组中，然后检索答案。但是后来，我觉得用掉更多的内存是一种浪费，也是对不理解如何正确操作链表的一种逃避。这是我想到的。</p><p id="595d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们假设一个包含6个节点的列表。如果我们想要从尾部2开始的节点的值，那么一直到尾部，然后从那里回溯到2是有意义的。两个变量只向前比一个变量先向前后向后更有意义。我们通过迭代将两个变量分开，使得它们等于尾节点到我们寻找的节点的距离。我们通过使用初始化为0的索引来实现这一点。因此，当当前节点为2时，我们开始递增index，并将其下一个节点赋给result——当前节点与result的差值为2，当到达列表末尾时，它会给出答案。</p><p id="7c9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.创建一个变量索引并初始化为零</p><p id="907e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.创建变量“当前”和“结果”,并初始化为head</p><p id="c659" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.将其下一个节点分配给当前节点</p><p id="cb2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.每移动一次就增加一个索引，每次它大于从尾部开始的位置时，就把它的下一个节点赋值给结果。-</p><p id="87b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.这样做，直到列表结束，然后打印结果的数据</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="7a0b" class="lv lw in lr b gy lx ly l lz ma">const nodeFromTail = (head, positionFromTail) =&gt; {</span><span id="7ea3" class="lv lw in lr b gy mb ly l lz ma">   let index = 0;</span><span id="2856" class="lv lw in lr b gy mb ly l lz ma">   let current = head;</span><span id="e8d8" class="lv lw in lr b gy mb ly l lz ma">   let result = head;</span><span id="39d3" class="lv lw in lr b gy mb ly l lz ma">   while (current != null) {</span><span id="569d" class="lv lw in lr b gy mb ly l lz ma">      current = current.next;</span><span id="17ca" class="lv lw in lr b gy mb ly l lz ma">      if (index++ &gt; positionFromTail) {</span><span id="5fb4" class="lv lw in lr b gy mb ly l lz ma">         result = result.next</span><span id="0f7f" class="lv lw in lr b gy mb ly l lz ma">      }</span><span id="1abd" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="bb03" class="lv lw in lr b gy mb ly l lz ma">   return result.data;</span><span id="c354" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="5c8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">比较两个链表</strong>非常简单。</p><p id="9749" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.如果数据不相等，检查第一个节点，那么它不是重复的。</p><p id="40af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.现在移动到下一个节点，重复第一步</p><p id="1b54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.如果我们遍历了列表，其中一个列表还没有到达末尾，那么它们就不是重复的</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="5ef3" class="lv lw in lr b gy lx ly l lz ma">const compareLists (head1, head2) {</span><span id="584b" class="lv lw in lr b gy mb ly l lz ma">   while (head1 != null &amp;&amp; head2 != null) {</span><span id="374a" class="lv lw in lr b gy mb ly l lz ma">      if (head1.data != head2.data) {</span><span id="eb23" class="lv lw in lr b gy mb ly l lz ma">      return false;</span><span id="5812" class="lv lw in lr b gy mb ly l lz ma">      }</span><span id="f087" class="lv lw in lr b gy mb ly l lz ma">      head1 = head1.next;</span><span id="ee1e" class="lv lw in lr b gy mb ly l lz ma">      head2 = head2.next;</span><span id="24ee" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="4296" class="lv lw in lr b gy mb ly l lz ma">   if (head1 != null || head2 != null) {</span><span id="6f43" class="lv lw in lr b gy mb ly l lz ma">   return false;</span><span id="a08c" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="69b6" class="lv lw in lr b gy mb ly l lz ma">   return true;</span><span id="994c" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="5655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">合并两个有序列表</strong>就是创建一个if条件和另一个递归调用。</p><p id="ce33" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.如果其中一个列表为空，则返回另一个列表</p><p id="f70a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果list2的节点数据大于list1的，那么在list1的下一个节点上运行这个完全相同的函数。所以当数据实际上更大时，它会把它发送出去</p><p id="6e58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.列表2也是如此。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8b59" class="lv lw in lr b gy lx ly l lz ma">const mergeLists (head1, head2) {</span><span id="0443" class="lv lw in lr b gy mb ly l lz ma">   if (head1 == null || head2 == null) {</span><span id="1860" class="lv lw in lr b gy mb ly l lz ma">   return (head1 == null) ? head2 : head1;</span><span id="af86" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="bfe7" class="lv lw in lr b gy mb ly l lz ma">   if (head1.data &lt; head2.data) {</span><span id="514e" class="lv lw in lr b gy mb ly l lz ma">      head1.next = mergeLists(head1.next, head2)</span><span id="818c" class="lv lw in lr b gy mb ly l lz ma">      return head1;</span><span id="c21a" class="lv lw in lr b gy mb ly l lz ma">   } else {</span><span id="1d19" class="lv lw in lr b gy mb ly l lz ma">      head2.next = mergeLists(head1, head2.next);</span><span id="4856" class="lv lw in lr b gy mb ly l lz ma">      return head2;</span><span id="0872" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="e4f4" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="e471" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在的问题是，如果你有两个列表和一些相同的数据点，那么这个列表将会有所有的副本。所以接下来我们尝试<strong class="kv io">从列表</strong>中删除重复的值节点。</p><p id="41f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.如果第一个或后面一个是空的，那么我们返回头节点</p><p id="a140" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果数据不等于下一个节点中的数据，则将它的下一个节点分配给头部</p><p id="bc4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.否则，将其下一个节点分配给头部的下一个节点，实际上跳过了重复的节点</p><p id="62c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.在整个列表上运行循环</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="67fb" class="lv lw in lr b gy lx ly l lz ma">const removeDuplicates = (head) =&gt; {</span><span id="22b1" class="lv lw in lr b gy mb ly l lz ma">   if (head == null || head.next == null) return head;</span><span id="997a" class="lv lw in lr b gy mb ly l lz ma">   let root = head;</span><span id="2b48" class="lv lw in lr b gy mb ly l lz ma">   while (head.next != null) {</span><span id="ce4f" class="lv lw in lr b gy mb ly l lz ma">      if (head.data != head.next.data) {</span><span id="9d14" class="lv lw in lr b gy mb ly l lz ma">      head = head.next;</span><span id="1e49" class="lv lw in lr b gy mb ly l lz ma">      } else {</span><span id="69f7" class="lv lw in lr b gy mb ly l lz ma">         head.next = head.next.next;</span><span id="8687" class="lv lw in lr b gy mb ly l lz ma">      }</span><span id="8327" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="8772" class="lv lw in lr b gy mb ly l lz ma">   return root;</span><span id="4183" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="dbac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我结束之前，我想解决最后一个非常有趣的问题。为了<strong class="kv io">到达链表的中间</strong>，有两种方法:</p><p id="86d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一，线性遍历列表，将列表切成两半，然后返回，这对于非常大的数据集来说会很慢。第二，有两个指针，一个移动1步，另一个移动2步。当第二个指针到达终点时，第一个指针将位于中间</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8e17" class="lv lw in lr b gy lx ly l lz ma">const findMiddle = (head) =&gt; {</span><span id="b3cf" class="lv lw in lr b gy mb ly l lz ma">   let slow_ptr = head;</span><span id="7ecb" class="lv lw in lr b gy mb ly l lz ma">   let fast_ptr = head;</span><span id="02a0" class="lv lw in lr b gy mb ly l lz ma">   if (head == null) return;</span><span id="6877" class="lv lw in lr b gy mb ly l lz ma">   if (head != null) {</span><span id="fcfb" class="lv lw in lr b gy mb ly l lz ma">      while (fast_ptr != null &amp;&amp; fast_ptr.next != null) {</span><span id="c0d0" class="lv lw in lr b gy mb ly l lz ma">         fast_ptr = fast_ptr.next.next;</span><span id="435b" class="lv lw in lr b gy mb ly l lz ma">         slow_ptr = slow_ptr.next;</span><span id="4799" class="lv lw in lr b gy mb ly l lz ma">      }</span><span id="0e2a" class="lv lw in lr b gy mb ly l lz ma">   }</span><span id="040b" class="lv lw in lr b gy mb ly l lz ma">   return slow_ptr.data;</span><span id="dc0a" class="lv lw in lr b gy mb ly l lz ma">}</span></pre><p id="3d21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基本情况就是这样。我会尽快解决更多的问题和写更多的笔记。✌️</p><p id="4436" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>