<html>
<head>
<title>6 Most Common Array Methods Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了6种最常见的数组方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-most-common-array-methods-explained-7ae3c20a9bd6?source=collection_archive---------12-----------------------#2021-05-31">https://javascript.plainenglish.io/6-most-common-array-methods-explained-7ae3c20a9bd6?source=collection_archive---------12-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6777aee5ff78616e55fe8f2066c80141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2_CfZ34VQIZ6Nnfc"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Todd Quackenbush</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="7d67" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数组是Javascript中一些最常用的数据结构。为了使用它们，语言提供了许多不同的方法来以更简单的方式转换、提炼和确定数组。</p><p id="7681" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为正确的工作选择正确的方法并不容易，尤其是当你刚刚开始编码的时候。本指南指出了6种最常用的方法，并试图帮助您了解应该为您指明哪种数组方法可以最有效地帮助您解决当前问题的模式。</p><h1 id="8fc3" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。地图</h1><p id="21b4" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这是目前为止我最常用的数组方法。当您有一个条目列表，并且您想要的结果是一个新列表，其长度与先前的列表相同，只应用了一些转换，或者只返回了一些值时，可以使用这种方法。</p><p id="cd4e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个方法将为我们遍历一个数组，并用数组中当前正在迭代的索引处的值调用我们的回调函数。当映射完成时，此函数调用返回的将是当前索引位置的最终值。</p><p id="cc4c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个非常常见的例子，将两个属性链接在一起，在一个数组中的所有对象上创建一个属性。假设您有一些从后端获取的用户数据，并且需要将这些数据提供给某个UI框架/库中的一个组件，该组件需要对象上的一个<code class="fe mb mc md me b">name</code>属性。这个属性实际上并不存储在后端，而是存储在名字和姓氏中。我们可以使用map快速遍历数组中的每一项，并添加name属性，它是另外两个属性的集合:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9bf4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前面的例子中，我们关心的是向原始数据添加一些东西。不要以为这是<code class="fe mb mc md me b">Array.Map</code>唯一的工作方式。记住，无论你返回什么，都将成为那个索引位置的新值。假设我们有一个需求，我们需要来自用户的所有年龄的列表:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a984" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里需要注意的一点是。在这两个例子中，我们将结果赋给一个变量。使用<code class="fe mb mc md me b">Array.Map</code>操作不到位。换句话说，原始数组根本没有改变。这其实大部分时候都是好事。一般来说，最好不要改变Javascript中对象的原始引用，创建新引用有很多好处。如果您确实需要在原始参考上就地操作呢？这就引出了我们的下一个方法。</p><h1 id="b2a4" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。为每一个</h1><p id="675f" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mb mc md me b">Array.ForEach</code>可能是紧随其后的我发现自己使用的最常用的数组方法。对我来说，这非常类似于替换一个常规for循环。</p><p id="18c8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本质上，你只是在一个数组上循环并调用一些回调函数。就像<code class="fe mb mc md me b">Array.Map</code>一样，我们的回调是用数组中当前索引处的值来调用的。这里最大的区别是，如果我们操作一个传递给回调函数的对象(不总是对象，而是存储在数组中那个索引位置的任何对象)，我们就改变了原始引用。</p><p id="823d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我发现自己使用这种方法的情况是有意想要改变原始数组的引用或者模仿传统的for循环。在这种情况下，尽管使用索引值(作为第二个参数传递，可选地在回调函数中使用)并引用原始数组的<code class="fe mb mc md me b">Array.Map</code>是可能的，但这将是一种反模式，我希望用<code class="fe mb mc md me b">Array.ForEach</code>来代替。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f9a7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们有意想改变原来的参考。在过去我可能选择for-of循环或传统风格的for-loop时，我通常会使用这种方法。也就是说，有理由选择常规的传统for循环而不是<code class="fe mb mc md me b">Array.ForEach</code>，所以不要认为一个优于另一个。需要指出的一个通常被忽视的区别是，你不能像传统的for循环一样跳出<code class="fe mb mc md me b">Array.ForEach</code>。</p><h1 id="2ae7" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。一些</h1><p id="9a8e" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mb mc md me b">Array.Some</code>方法也非常有用。当您需要在数组中找到至少一个满足某些条件的项时，可以使用此方法。如果出现这种情况，即使只有一次，它也将返回true。但是，如果该方法遍历数组中的所有项，并且没有满足给定条件的项，那么它将返回false。</p><p id="7cf2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个有很多用途，但是我想在这里强调一个。例如，假设我们有一个用户正在向UI输入数据。我们正在管理输入的值，以及它是否出错。我们可以使用<code class="fe mb mc md me b">Array.Some</code>快速遍历数据，检查是否有错误。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2763" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你可以看到这个<code class="fe mb mc md me b">hasErrors</code>函数是如何决定表单的保存按钮的禁用或启用状态的。</p><h1 id="3c87" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。每个</h1><p id="0983" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mb mc md me b">Array.Every</code>就像是<code class="fe mb mc md me b">Array.Some</code>的姊妹方法。当使用这个方法时，它将遍历你的数组，并调用你的回调函数，将数组中存储的值传入当前被遍历的索引处。不过，在这个方法中，只有当数组中的所有项都从回调函数返回true时，它才会返回true。如果有一个返回false，那么方法as将返回false。我们可以用上面的例子来重写，用<code class="fe mb mc md me b">Array.Every</code>为我们做同样的事情。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="0d92" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。过滤器</h1><p id="1408" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mb mc md me b">Array.Filter</code>也是很常见的阵法。就像我们之前的所有方法一样，它将一个回调作为第一个参数，这个回调被调用并从当前正在迭代的数组中传递项目。根据此回调返回true还是false，从最终返回的数组中保留或丢弃该项。False将丢弃该项，true将保留该项。</p><p id="9aed" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个非可变的方法，它返回一个新的数组引用，而原始的数组引用保持不变。这就像上面提到的<code class="fe mb mc md me b">Array.Map</code>，总的来说，是一件好事。这是知道何时使用的最明显的方法。当您当前拥有的阵列需要根据某种限定条件缩短长度时，就会出现这种情况。例如，如下所示，一个用户列表，我们只想使用当前客户端的列表。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7335" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很简单但是很有效，我经常使用这种方法。</p><h1 id="1822" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数组。减少</h1><p id="3a34" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mb mc md me b">Array.Reduce</code>是数组方法中最容易被误解和误用的一种。在我看来，这种方法应该谨慎使用，并且只在特定条件下使用。</p><p id="2d4a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很多次，我看到了这种误用，如果同样的操作可以用其他链接在一起的数组方法来完成，或者仅仅是其他数组方法，那么就应该使用它们。这样做的理由是<code class="fe mb mc md me b">Array.Reduce</code>比一些更直接的迭代方法更难使用，更容易导致错误。您考虑使用<code class="fe mb mc md me b">Array.Reduce</code>的全部原因是，您有一个数组，并且您希望遍历该数组并创建一个完全不同的数据结构。</p><p id="2816" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两个常见的例子应该被称为是<code class="fe mb mc md me b">Array.Reduce</code>的好例子，它们是从一个数组中创建一个数据的引用图，以防止不断地搜索对象，以及将一个数组中的数字相加为一个值。让我们看一下第一个例子:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="17db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以调用userMap[SOME_ID]并在常量时间内获取我们的用户对象。这是reduce的一个很好的用例。注意回调是如何被调用的。传递给回调函数的第一个参数实际上是由传递给<code class="fe mb mc md me b">Array.Reduce</code>调用的第二个参数决定的。如果提供了第二个参数，就像这里一样，那么这将是传递给回调的第一个参数的起始值。这被称为累加器，在每次函数调用时，它必须被返回。这是<code class="fe mb mc md me b">Array.Reduce</code>中最常见的bug来源。</p><p id="064b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有提供第二个参数，那么累加器实际上将被设置为数组的第一个值，而不是从索引位置0开始，而是从索引位置1开始。对我的大脑来说，这不仅仅是预期的行为，直到你学会它。我实际上在没有这方面知识的情况下使用了<code class="fe mb mc md me b">Array.Reduce</code>一段时间，但它实际上在对一组数字求和时非常有用，如下所示:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3883" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码的关键是，<code class="fe mb mc md me b">baseNumber</code>默认情况下没有使用<code class="fe mb mc md me b">Array.Reduce</code>调用中的第二个参数进行设置，因此，第一个值(1)就是<code class="fe mb mc md me b">baseNumber</code>的起始值，第一个函数调用实际上将从索引1开始。对一个数组求和来说，这是一个非常有用的技术。我们已经看到了两个关于<code class="fe mb mc md me b">Array.Reduce</code>的好例子。我只想重申，这种方法存在一些潜在的混淆，我个人尽可能避免这种情况。很多时候我看到类似下面的东西:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2d1c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这通常在两种情况下完成。在第一种情况下，开发人员看到最终解决方案是一个数组，所以他们从<code class="fe mb mc md me b">Array.Map</code>开始，然后很快意识到最终结果不会有相同的长度，因此，我们必须转到<code class="fe mb mc md me b">Array.Reduce</code>，因为我们没有包括所有结果，在最终列表中只包括当前客户端。这可以通过将两个数组方法(array。地图和数组。过滤器)。</p><p id="f951" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如下所示，您可以简单地(顺序无关紧要)使用<code class="fe mb mc md me b">Array.Map</code>迭代数组并应用名称转换。然后使用<code class="fe mb mc md me b">Array.Filter</code>遍历数组并删除任何不是当前客户端的。代码实现见下文，但首先，让我们讨论高度相关的第二种情况。第二种情况实际上是看到上述解决方案的人，他认为在一个循环中的reduce中执行此操作有某种优化。我们必须记住O符号是如何度量的。</p><p id="c491" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">O(N)和O(2N)之间是否存在某种性能优化？当然，2N比N大，但是因为我们在讨论大O符号时去掉了常数，所以这里没有真正的区别。当执行一个循环来映射和一个循环来过滤和一个循环来减少时，最终，我们仍然在讨论O(N)。这也是为什么一般情况下<code class="fe mb mc md me b">Array.Reduce</code>没有太多不能通过结合其他方法简化的用例。如果是这种情况，我会考虑进行重构来移除reduce，如下所示。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="5335" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="2fc6" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">到目前为止，您应该对在何种情况下使用哪种数组方法有了更好的了解。有时需要反复试验，对于特定的问题，哪一个是正确的并不是很明显。</p><p id="7633" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章旨在给你一些提示，告诉你哪些情况应该是显而易见的选择。值得一提的是，除了reduce之外，许多函数都有相同的API，它们接受一个回调函数，传入正在迭代的当前值，因此快速尝试许多不同的函数是一项简单的任务。关于运行时的复杂性和数组方法的使用，需要注意一点。在计算运行时复杂性时，很容易看到如下内容并出错。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f6ea" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，所有这些数组方法都是for循环之上的抽象，嵌套它们与嵌套两个for循环没有什么不同。上面的代码运行时复杂度为O(N ),但是在复杂的函数中这有时会被忽略。</p><p id="45d3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">更多内容看</em><a class="ae ja" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ml">plain English . io</em></a></p></div></div>    
</body>
</html>