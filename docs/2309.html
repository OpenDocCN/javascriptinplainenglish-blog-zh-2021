<html>
<head>
<title>Understanding Function Composition in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的函数组合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-function-composition-in-javascript-1f7d28931d21?source=collection_archive---------4-----------------------#2021-05-14">https://javascript.plainenglish.io/understanding-function-composition-in-javascript-1f7d28931d21?source=collection_archive---------4-----------------------#2021-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6b09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">功能编程的一个组成部分— <strong class="jm io">功能组合</strong>是一种组合多个功能以创建一个新功能的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45321a5e3c9bd9ba87bca40529f4d4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkrH3QLmvm0RGU9krnyovA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Example of composing atomic functions (“join”, “reverse”, “split”) to create a new function (“reverseText”), which reverses a text.</figcaption></figure><h1 id="3292" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">入门指南</h1><h2 id="53e1" class="lw kz in bd la lx ly dn le lz ma dp li jv mb mc lm jz md me lq kd mf mg lu mh bi translated">理论部分</h2><p id="c26f" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">简而言之，当您组合多个函数时，您会得到另一个函数，当用一些参数调用该函数时，它会依次调用底层函数，并将它们的输出作为输入传递给后续函数，直到得到最终输出。</p><h2 id="6f1e" class="lw kz in bd la lx ly dn le lz ma dp li jv mb mc lm jz md me lq kd mf mg lu mh bi translated">实用部分</h2><p id="fe6e" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">让我们看看一个真正的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><blockquote class="mp mq mr"><p id="173c" class="jk jl ms jm b jn jo jp jq jr js jt ju mt jw jx jy mu ka kb kc mv ke kf kg kh ig bi translated">如果您不熟悉<strong class="jm io"> currying </strong>，请随意先阅读“<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/the-simplest-intro-to-currying-in-javascript-c36b892f2597">JavaScript中currying的最简单介绍</a>”一文。</p></blockquote><p id="04d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里需要注意几件事:</p><ul class=""><li id="58a4" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated"><code class="fe ng nh ni nj b"><strong class="jm io">compose(...fns)</strong></code>-我们正在使用<a class="ae mw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a> JS特性，以便支持尽可能多的传递给我们的功能。</li><li id="8fa5" class="mx my in jm b jn nk jr nl jv nm jz nn kd no kh nc nd ne nf bi translated"><code class="fe ng nh ni nj b"><strong class="jm io">function(...args)</strong></code>-与上一点相似，这里我们也使用<a class="ae mw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a>，这允许我们成为初始参数长度不可知的。</li><li id="9cbe" class="mx my in jm b jn nk jr nl jv nm jz nn kd no kh nc nd ne nf bi translated"><code class="fe ng nh ni nj b"><strong class="jm io">fns.reducerRight</strong></code>——我们使用<a class="ae mw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight" rel="noopener ugc nofollow" target="_blank">array . prototype . reduce right</a>从最后到第一次调用函数并累加最终结果。此外，请注意，我们正在累加一个具有单个值的数组<code class="fe ng nh ni nj b">[fn.apply(null, result)]</code>，因为初始值<code class="fe ng nh ni nj b">args</code>是一个数组，这又迫使我们在返回最终结果时使用<code class="fe ng nh ni nj b">[0]</code>索引。</li></ul><blockquote class="mp mq mr"><p id="2e74" class="jk jl ms jm b jn jo jp jq jr js jt ju mt jw jx jy mu ka kb kc mv ke kf kg kh ig bi translated"><strong class="jm io">注:</strong>按照惯例<code class="fe ng nh ni nj b">compose</code>从<strong class="jm io">右向左</strong>移动。也可以创建并使用从左到右的<strong class="jm io"/>版本，尽管通常会有不同的叫法，比如<code class="fe ng nh ni nj b">pipe</code>或<code class="fe ng nh ni nj b">sequence</code>。</p></blockquote><h1 id="c5f5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">调试</strong></h1><p id="5987" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">有时，我们可能很难理解到底哪里出了问题，我们可能需要检查每次函数调用后发生了什么:</p><ul class=""><li id="32ab" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated">显然，我们可以使用内置的IDE调试器</li><li id="1b11" class="mx my in jm b jn nk jr nl jv nm jz nn kd no kh nc nd ne nf bi translated">或者，我们也可以有一些专用的助手功能，简单地在某一点记录数据</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><blockquote class="mp mq mr"><p id="db0c" class="jk jl ms jm b jn jo jp jq jr js jt ju mt jw jx jy mu ka kb kc mv ke kf kg kh ig bi translated">注意:你可能已经猜到了函数的顺序很重要，因为它们是按顺序调用的。</p></blockquote><h1 id="7b99" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试</h1><p id="67da" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">此外，您可能听说过函数式编程如何鼓励您使用纯函数，并避免创建具有不可预知副作用的不纯函数。</p><p id="6b92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要原因是:</p><ul class=""><li id="55c2" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated">纯函数更容易理解和测试</li><li id="8098" class="mx my in jm b jn nk jr nl jv nm jz nn kd no kh nc nd ne nf bi translated">合成纯函数给你另一个纯函数，上面的观点也适用</li></ul><h1 id="892c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="b8de" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">函数组合是一种非常强大的技术，它允许我们使用更小的原子函数来构建更复杂的函数。</p><p id="4db6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你用更小的积木建造更高级的建筑时，它可以和乐高相媲美。</p><p id="7e32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望现在你对<strong class="jm io">函数组合</strong>有了更好的理解，这是<strong class="jm io">函数编程</strong>的核心特性之一，还有其他类似<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/the-simplest-intro-to-currying-in-javascript-c36b892f2597"><strong class="jm io"/></a>的技巧。</p><p id="ba50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">附言:</strong>如果你觉得这篇文章有趣，可以随时在<a class="ae mw" href="https://erzhtor.medium.com/" rel="noopener"> Medium </a>和<a class="ae mw" href="https://twitter.com/erzhtor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="af8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ms">更多内容请看</em><a class="ae mw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ms">plain English . io</em></a></p></div></div>    
</body>
</html>