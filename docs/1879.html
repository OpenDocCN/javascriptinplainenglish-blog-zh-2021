<html>
<head>
<title>How to Streamline Angular Reactivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何简化角反应性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-reactivity-streamlined-831754b60a11?source=collection_archive---------0-----------------------#2021-04-20">https://javascript.plainenglish.io/angular-reactivity-streamlined-831754b60a11?source=collection_archive---------0-----------------------#2021-04-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8eb5fca6bc76af25f31ceafdd49d64dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFM0GH5sIybYFtA9-uAF8Q.png"/></div></div></figure><p id="3fcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">角拥抱RxJS可观。路由器、HTTP客户端和反应式表单等主要功能公开了使用或返回RxJS可观察对象的接口。角度示意图和生成器可以处理可观测量来执行异步操作。common包提供了著名的<code class="fe kt ku kv kw b">AsyncPipe</code>，用于从组件模板的可观察值中提取值。文档中甚至有一节专门讨论RxJS和observables 。</p><p id="ab94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑到一切，Angular可能是与RxJS observables最全面的集成。然而，一旦观察到组件类中发出的值，事情就变得有点复杂了。让我们创建一个组件，它将路由数据和参数一起引用，以逐个浏览帖子列表。它看起来会像这样:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/045158c4ec591e7dea5f3e3a56a79473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*F_aRV7P--wQ29oMyvmKqcA.gif"/></div></div></figure><p id="f744" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了访问路由数据和参数，我们将注入<code class="fe kt ku kv kw b">ActivatedRoute</code>实例。数据和参数都是可观察的，所以如果我们想在组件类中使用发出的值，我们需要订阅它们。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Using route data and params in an Angular component</figcaption></figure><p id="88e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道我可以用管道将路线数据和参数传输到单独的<code class="fe kt ku kv kw b">prev$</code>和<code class="fe kt ku kv kw b">next$</code>流中，并在模板中使用<code class="fe kt ku kv kw b">async</code>管道，但是我在这里试图说明一点，所以请原谅我。</p><p id="837f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，它已经开始感觉不那么被动了，一旦我修复了我在这里故意犯的几个错误，它会感觉更不被动。您可能已经注意到了第一点:在组件销毁之后，任何打开的订阅都是潜在的内存泄漏。因此，当组件被销毁时，让我们通过存储它并调用它的<code class="fe kt ku kv kw b">unsubscribe</code>方法来清除订阅。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Clearing RxJS subscriptions in an Angular component</figcaption></figure><p id="3492" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调用<code class="fe kt ku kv kw b">unsubscribe</code>方法还有其他选择。我们可以通过<code class="fe kt ku kv kw b">takeUntil</code>操作符来传输流，并用<code class="fe kt ku kv kw b">Subject</code>来通知它。我们可以将令人惊叹的<a class="ae kx" href="https://github.com/ngneat/until-destroy" rel="noopener ugc nofollow" target="_blank"> @ngneat/until-destroy </a>库付诸行动，这样就不需要<code class="fe kt ku kv kw b">ngOnDestroy</code>了。我们甚至可以使用一个类似于<a class="ae kx" href="https://docs.abp.io/en/abp/latest/UI/Angular/Subscription-Service" rel="noopener ugc nofollow" target="_blank">的服务，一个ABP Angular UI提供的服务</a>来收集订阅并避免破坏钩子。然而，这并没有消除本质上的缺陷:订阅一个可观察的感觉并不被动。</p><p id="35dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有第二个问题是上面没有解决的:变化检测。这个组件工作是因为<strong class="jx io"> zone.js </strong>会触发变化检测，Angular会在每次检测周期运行时检查这个组件。在真实的应用程序中，这个组件可能会被检查太多次。我们可以应用<code class="fe kt ku kv kw b">OnPush</code> <a class="ae kx" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank">变更检测策略</a>来避免这种情况，但是我们的流发出的值不会导致重新呈现，除非手动触发变更检测。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="be9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，<code class="fe kt ku kv kw b">ChangeDetectorRef</code>的<code class="fe kt ku kv kw b">markForCheck</code>方法没有安排新的变更检测周期，但是它会注册这个要检查的组件。因此，流将发出一个新的值，<code class="fe kt ku kv kw b">prev</code>和<code class="fe kt ku kv kw b">next</code>将被更新，在下一个变更检测周期中，我们的组件将有一个部分重新呈现。然而，如果您不必进行显式的变更检测调用，那不是很好吗？</p><h1 id="d6e1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">输入ng-观察</h1><p id="52d5" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">你一定累得翻白眼:<em class="mm">“不！不是另一个订阅库！”是的，这个简单的库为你订阅和取消订阅observables。但是，它也为您提供了一个反应性对象，并标记您的组件，以便对每个发出的值进行更改检测。这导致了一种反应性的成分/方向性的感觉。本库名为<a class="ae kx" href="https://github.com/ngbox/ng-observe" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">NG——观察</strong> </a>，我是其背后<strong class="jx io"> NG盒子</strong>团队的一员。</em></p><p id="1896" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看当我们应用ng-observe时，我们的组件是什么样子的。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Using ng-observe to observe and react to emitted values</figcaption></figure><p id="8748" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们提供了组件级的<code class="fe kt ku kv kw b">OBSERVE_PROVIDER</code>。然后，使用<code class="fe kt ku kv kw b">OBSERVE</code>标记，我们在组件中注入了一个函数(<code class="fe kt ku kv kw b">ObserveFn</code>)。使用这个函数，我们可以观察发出的值，并将它们存储为<code class="fe kt ku kv kw b">Observed</code>对象。引用这些对象的<code class="fe kt ku kv kw b">value</code>属性总是会给我们当前值，所以我们可以很容易地在两个简单的getters中为<code class="fe kt ku kv kw b">prev</code>和<code class="fe kt ku kv kw b">next</code>构建逻辑。</p><p id="f993" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，ng-observe允许您将<code class="fe kt ku kv kw b">count</code>和<code class="fe kt ku kv kw b">id</code>组合在一个集合中，从而去掉<code class="fe kt ku kv kw b">Observed</code>对象。我们可以这样做:</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Using ng-observe to observe a collection of emitted values</figcaption></figure><p id="e5b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很可爱，不是吗？不过，有一个问题:析构<code class="fe kt ku kv kw b">state</code>属性在这里有效，因为它发生在getter内部。如果想获得ng-observe集合道具派生的反应属性，就要把它们转换成<code class="fe kt ku kv kw b">Observed</code>对象。为此有<a class="ae kx" href="https://github.com/ngbox/ng-observe#tovalue" rel="noopener ugc nofollow" target="_blank">实用函数</a>，你甚至可以得到计算的观察值。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Mapping reactive collections to reactive values with ng-observe</figcaption></figure><p id="9cae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢<code class="fe kt ku kv kw b">toMappedValue</code>功能，我们已经将反应状态集合映射到<code class="fe kt ku kv kw b">prev</code>和<code class="fe kt ku kv kw b">next</code>道具。我们不再需要吸气剂了。我们也没必要把收藏当道具。另一方面，模板上的绑定发生了变化，以反映出<code class="fe kt ku kv kw b">Observed</code>类的形状。</p><h1 id="38b7" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="be95" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">这些示例演示了ng-observe在组件中的用法，但是这个库在指令中也同样适用，因为它是独立于模板的。然而，这是一个附带的好处。作为一名开发人员，您获得的真正优势是当您使用可观察的流时，组件或指令的反应性如何。我们希望它也能提高你的DX。你可以在这里找到游乐场。</p><p id="3391" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一句话，如果可以的话:请通过与他人共享该库来显示您对我们的支持(或许<a class="ae kx" href="https://github.com/ngbox/ng-observe" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上给我们一颗星)。我们是NG Box，作为一个团队，这是我们的第一个但希望不是最后一个Angular库。</p><p id="e73f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读。祝您愉快！</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/42becc9d5a0633b51d443adcacc595e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LHupYHmSilVhu1d8QC5Bg.png"/></div></div></figure><p id="84f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mm">更多内容请看</em><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mm">plain English . io</em></a></p></div></div>    
</body>
</html>