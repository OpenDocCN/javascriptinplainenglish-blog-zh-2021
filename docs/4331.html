<html>
<head>
<title>How to Write Middleware for Express Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Express应用程序编写中间件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-middleware-for-express-apps-775153b4e6b?source=collection_archive---------7-----------------------#2021-08-28">https://javascript.plainenglish.io/writing-middleware-for-express-apps-775153b4e6b?source=collection_archive---------7-----------------------#2021-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b1e8212e32a0c46ee73b8385ea70ac70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EWjauKpsOaL7Fe_v"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@frenchriera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Riera</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章将让你清楚地了解Express中的<em class="ky">中间件</em>，它的用法以及它对我们的Express应用程序的影响。对于初学者来说，中间件的概念可能很难一下子掌握，但是一旦你理解了，它就不是最难的事情了。有几个关键的事情需要了解，了解它们将使您的Express生活变得更加轻松。</p><p id="0924" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，说够了。让我们看看什么是中间件功能。</p><p id="e539" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据Express <a class="ae jz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> docs </a>，<strong class="kc io"> <em class="ky">中间件</em> </strong>函数是在应用的请求-响应周期中访问<a class="ae jz" href="https://expressjs.com/en/4x/api.html#req" rel="noopener ugc nofollow" target="_blank">请求对象</a>(<code class="fe kz la lb lc b">req</code>)<a class="ae jz" href="https://expressjs.com/en/4x/api.html#res" rel="noopener ugc nofollow" target="_blank">响应对象</a> ( <code class="fe kz la lb lc b">res</code>)和<code class="fe kz la lb lc b">next</code>函数的函数。现在让我们把这个不太清楚的定义分成更小的部分，这将帮助你更快地理解中间件的概念。</p><p id="80f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">中间件是介于请求和响应之间的东西。正如官方定义所述，它可以访问请求和响应对象。它可以运行<em class="ky">任何</em>代码，<em class="ky">更新</em>请求或响应对象，调用<em class="ky">下一个</em>中间件函数，或者可以完全<em class="ky">终止</em>请求和响应的循环。</p><p id="0957" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个例子:</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/037ae9a696365da0ac5b50ab2a3040a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yu2jBQs16nIFq6B1Q7EJOg.jpeg"/></div></div></figure><p id="d3b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我已经使用了<em class="ky"> app.use() </em>方法来传入中间件函数。app.use() 将执行任何请求类型，如GET、POST、PUT等。我们通常的<em class="ky"> req，res </em>参数保持不变，但是还有一个'<em class="ky"> new' </em>回调参数。你可以给它起任何你想要的名字，但是<em class="ky"> new </em>是用来声明它的标准名字。它所做的是，在运行我们放在中间件中的任何代码之后，它调用下一个与请求匹配的函数。</p><p id="8460" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，由于我们还没有指定路径，只要服务器启动并运行，这个中间件将应用于任何路径的任何请求。有点普通。但是如果我们要更具体一点，我们可以想出这样的东西，</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/1fc9c15f13df2eaefd9ef802aa7f98ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7x22f8qtUsxNxg40dAkzQ.jpeg"/></div></div></figure><p id="6425" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WRT在上面的例子中，假设我们从浏览器向<a class="ae jz" href="http://localhost:3000/cats" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/cats</a>发送GET请求。在请求到达GET路由之前，它会通过我们定义的中间件。该步骤将<em class="ky">‘这是我的第一个cat中间件’</em>打印到控制台。因为我们已经在中间件中调用了<em class="ky"> next() </em>，所以express然后搜索任何匹配的路由，继续我们的中间件来执行。因为有一个GET路径，它的路径是'<em class="ky"> /cats' </em>，所以它将被调用，并且' meowzy' 将被输出到控制台。</p><p id="21c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，假设我们通过<a class="ae jz" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> postman </a>向<a class="ae jz" href="http://localhost:3000/cats" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/cats</a>发送了一个POST请求。它不会触发获取路线。但是尽管如此，我们放置在<em class="ky"> app.use() </em>中的中间件功能将被触发，并且<em class="ky">‘这是我的第一个cat中间件’</em>将被打印出来。</p><p id="deec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们忽略了从我们的中间件函数中调用<em class="ky"> next() </em>，<em class="ky">所有的</em>其他的路由都将被忽略，因为<em class="ky"> app.use() </em>会捕获每个对app的请求。因此调用<em class="ky"> next() </em>是非常必要的，除非我们想结束请求-响应循环。</p><p id="71fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于我们应该只把我们的中间件放在<em class="ky"> app.use() </em>里面，没有硬性规定。这完全取决于你想要达到的目标。您还可以使用<em class="ky"> app.get() </em>来整合中间件，如下例所示。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/e2556121ef1928bebfd0b749f7f6653a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3P6xgs_-j1Q1jo0Ai7EvA.jpeg"/></div></div></figure><p id="2fad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“嘿”将在我们向<a class="ae jz" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>发出get请求时显示，我没有包括<em class="ky"> next() </em>，因为没有其他路由。</p><p id="7d7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经看到了中间件如何影响我们的应用程序，我将展示中间件如何更新<em class="ky"> req </em>和<em class="ky"> res </em>对象。假设我们想要向req对象添加一个名为'<code class="fe kz la lb lc b">requestTime'</code>'的新属性，该属性将捕获Date.now()的值。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/92c57c6c8c98210c2c3d70da62fd9288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FooaCK5GYkXRfZLDA3HKg.jpeg"/></div></div></figure><p id="4151" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我已经向名为'<code class="fe kz la lb lc b">requestTime'.</code>'的<em class="ky"> req </em>对象添加了一个新属性。如果我们发送一个匹配的GET请求，那么首先添加该属性，并通过GET路径将其值打印到控制台。</p><p id="7058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，如果我们想对GET请求只使用中间件函数<em class="ky">和</em>，上面的例子可以简化成这样。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/07cd38f8cc81063008c71198fd468000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4aX7Y22T_nrEQ4-pYmhsg.jpeg"/></div></div></figure><p id="d2d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将该功能提取到一个单独的函数中，并将其作为一个<em class="ky">回调</em>传递给我们的GET路由。<em class="ky"> app.get() </em>在path之后接受回调，由于我已经在addingTime函数中添加了<em class="ky"> next() </em>，其余的回调(老好人<em class="ky"> req </em>，<em class="ky"> res </em>回调)将在流中执行。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="7106" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，关于Express中间件就这些了。下次见！</p><p id="d438" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>