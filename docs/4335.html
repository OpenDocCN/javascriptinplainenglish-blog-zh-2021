<html>
<head>
<title>Angular Router: Children or LoadChildren?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角路由器:孩子还是LoadChildren？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-router-children-or-loadchildren-a74a9593af07?source=collection_archive---------0-----------------------#2021-08-29">https://javascript.plainenglish.io/angular-router-children-or-loadchildren-a74a9593af07?source=collection_archive---------0-----------------------#2021-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/48de4f982e8d4d9be2e70ae8202816a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jc1mrPb898HeaERh"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jannisbrandt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jannis Brandt</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ce5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">(本文假设基本了解路由器和路由器API。如需深入了解，请参考</em> <a class="ae jz" href="https://angular.io/guide/router" rel="noopener ugc nofollow" target="_blank"> <em class="ky">棱角文档</em> </a> <em class="ky"> ) </em></p><p id="e0fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Angular Router </strong>是Angular生态系统中最有用的包之一。但是，如果您是Angular的新手，并且刚刚开始使用路由器，您的目标可能是设置一些基本路由。此外，对于新的开发人员，我通常会看到许多关于<strong class="kc io"> children </strong>和<strong class="kc io"> loadChildren </strong>属性的问题。因此，本文将只关注这两个属性之间的区别以及何时使用什么。</p><h2 id="0c45" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">角度路线界面</strong></h2><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6033" class="kz la in lx b gy mb mc l md me">export interface Route {</span><span id="e018" class="kz la in lx b gy mf mc l md me">path?: string;<br/>component?: Type&lt;any&gt;;</span><span id="e2e0" class="kz la in lx b gy mf mc l md me">children?: Route[];</span><span id="2c11" class="kz la in lx b gy mf mc l md me">loadChildren?: LoadChildren;</span><span id="2c20" class="kz la in lx b gy mf mc l md me">... few other properties</span><span id="f59a" class="kz la in lx b gy mf mc l md me">}</span></pre><p id="6efd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我先快速解释一下路由接口的上述四个属性(在本文的范围之内):</p><ul class=""><li id="3a2b" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx ml mm mn mo bi translated"><strong class="kc io">路径</strong>:路由器API将整个URL分解成单独的片段。路径属性可以对应于这些片段的组合。它主要用于标识应该在父路由器出口中实例化和加载的角度组件。</li><li id="bd54" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated"><strong class="kc io">组件</strong>:该属性是指应该为该路径实例化的角度组件。</li><li id="ee85" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated"><strong class="kc io"> Children </strong>:这个属性定义了嵌套的路径，angular会提前加载它们。</li><li id="a68c" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated"><strong class="kc io"> LoadChildren </strong>:也用于定义嵌套路由，但是Angular Router会延迟加载。你看到这里的优势了。</li></ul></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="9560" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经定义了相关的路由属性，让我们看看什么时候应该在<code class="fe nb nc nd lx b">children</code>和<code class="fe nb nc nd lx b">loadChildren</code>之间进行选择。</p><h1 id="6354" class="ne la in bd lb nf ng nh le ni nj nk lh nl nm nn lk no np nq ln nr ns nt lq nu bi translated">使用儿童:</h1><ul class=""><li id="e2ed" class="mg mh in kc b kd nv kh nw kl nx kp ny kt nz kx ml mm mn mo bi translated">添加嵌套路由。</li><li id="2053" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">Angular将预先加载所有子组件。</li><li id="78d3" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">确保为嵌套路由表中定义的每个组件导入所有NgModules。否则，您的代码将无法工作。</li><li id="6708" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">为了提高代码的可读性和可维护性，如果路由表的嵌套太长，请避免使用该属性。我个人的偏好是&lt; 3级最高。</li><li id="943d" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">简单路线的理想选择。</li><li id="f31b" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">代码示例:</li></ul><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="16f6" class="kz la in lx b gy mb mc l md me">const routes = [<br/>  {<br/>    path: '',<br/>    component: ApplicationFrameComponent,<br/>    children: [<br/>    {<br/>      path: 'home',<br/>      component: HomeDashboardComponent,<br/>      children: [<br/>        {<br/>           path: 'api-dashboard',<br/>           component: ApiHomeDashboardComponent<br/>        }]<br/>    },<br/>    {<br/>      path: 'api-list',<br/>      component: ApiListComponent,<br/>      children: [<br/>        {<br/>           path: 'internal',<br/>           component: InternalApisListComponent<br/>        },<br/>        {<br/>           path: 'external',<br/>           component: ExternalApisListComponent<br/>        }]<br/>    }]<br/>  }];</span></pre><h1 id="9e22" class="ne la in bd lb nf ng nh le ni nj nk lh nl nm nn lk no np nq ln nr ns nt lq nu bi translated">使用LoadChildren:</h1><ul class=""><li id="6e6f" class="mg mh in kc b kd nv kh nw kl nx kp ny kt nz kx ml mm mn mo bi translated">对于懒加载。当用户导航到与当前路由路径匹配的特定URL时，使用此属性将只加载嵌套的路由子树，从而优化应用程序的性能。</li><li id="c526" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">这有助于保持嵌套路由表的独立性。</li><li id="8811" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">您必须为loadChildren指定一个路由模块。此模块必须定义路线，并应导入所有相关的ng模块</li><li id="980a" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">如果您使用<code class="fe nb nc nd lx b">import(&lt;module-path&gt;).then(module =&gt; module.&lt;routing-module&gt;)</code>，Angular将创建一个单独的js包，只有当一个子路径被激活时才会被加载。您将获得更好的性能、代码可读性和可维护性。</li><li id="5869" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">如果您使用<code class="fe nb nc nd lx b">() =&gt; &lt;routing-module&gt;</code>，angular将不会创建一个单独的js包，但是routes表将保持独立。结果是更好的代码可读性和可维护性。性能将与<code class="fe nb nc nd lx b">children</code>方法相同。</li><li id="f077" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">代码示例:</li></ul><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="cfee" class="kz la in lx b gy mb mc l md me">const rootRoutes = [<br/>  {<br/>    path: '',<br/>    component: ApplicationFrameComponent,<br/>    children: [<br/>    {<br/>      path: 'home',<br/>      loadChildren: () =&gt; HomeDashboardRoutingModule<br/>    },<br/>    {<br/>      path: 'api-list',<br/>      loadChildren: @import('./api-list.module').then(module =&gt; module.ApiListRoutingModule)<br/>    }]<br/>  }];</span><span id="b355" class="kz la in lx b gy mf mc l md me">// In HomeDashboardRoutingModule</span><span id="0827" class="kz la in lx b gy mf mc l md me">const homeRoutes = [<br/>  {<br/>    path: '',<br/>    component: HomeDashboardComponent,<br/>    children: [<br/>      {<br/>         path: 'api-dashboard',<br/>         component: ApiHomeDashboardComponent<br/>      }]<br/>  }];<br/></span><span id="1808" class="kz la in lx b gy mf mc l md me">// In ApiListRoutingModule<br/>const apiListRoutes = [<br/>{<br/>   path: '',<br/>   component: ApiListComponent,<br/>   children: [<br/>     {<br/>        path: 'internal',<br/>        component: InternalApisListComponent<br/>     },<br/>     {<br/>        path: 'external',<br/>        component: ExternalApisListComponent<br/>     }]<br/>}];</span></pre></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="1601" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章是有帮助的！一个<strong class="kc io">给我的观众的小问题</strong>。如果我们为带有<strong class="kc io"> loadChildren </strong>属性的路由传递一个<code class="fe nb nc nd lx b">component</code>会发生什么？</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ad89" class="kz la in lx b gy mb mc l md me">{<br/>  path: 'home',<br/>  component: HomeDashboardComponent,<br/>  loadChildren: () =&gt; HomeDashboardRoutingModule<br/>},</span></pre><p id="54f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请在下面的评论区回复好吗？</p><p id="039a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>