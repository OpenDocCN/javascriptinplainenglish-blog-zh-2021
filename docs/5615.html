<html>
<head>
<title>Why Streams?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是溪流？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-streams-56dd72975ad8?source=collection_archive---------9-----------------------#2021-11-23">https://javascript.plainenglish.io/why-streams-56dd72975ad8?source=collection_archive---------9-----------------------#2021-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d627" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">势在必行，面向对象的编程非常强大，但是对于某些问题，流更适合。在本文中，我列举了一些用例，在这些用例中，我发现RxJs流比仅使用命令式方法能产生更好的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e7bd1e71d6af979e1bdb9af526b93a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zHTCKOrfQajEMDWR"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@karimsan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Karim Sakhibgareev</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5715" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我来自面向对象的背景，有C++、C#和JavaScript/TypeScript方面的经验。我对面向对象的思维模式很有信心，我可以编写相当好的命令式代码来解决我的大部分问题。然而，在过去的几年里，我发现自己写了越来越多的重流代码。我认为我正在使用面向对象架构和流相结合来创建明显更好的代码。</p><p id="0fae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我回顾了那些我发现streams更优秀的用例。我关注的是在大多数OO代码库中应用流，而不是那些已经建立在类似Redux的状态管理(例如NgRx)之上的代码库。</p><p id="acb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我必须提出一个微不足道的概念。它可能很琐碎，但我花了一段时间才完全理解。</p><h1 id="61ac" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">流不是面向对象的</h1><p id="9c70" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果你来自面向对象的背景，除了面向对象原则之外，你很有可能需要拥抱一种不同的方法<em class="mc">。因为<strong class="jm io">流不是面向对象的</strong>。</em></p><p id="d4bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">面向对象方法使用分治法。整个问题太大了，所以我们一次又一次地将它分成更小的块，并创建我们可以管理的更小的责任组——类。也许你已经这样做了很多年了。你知道设计模式，创建了很好的架构，你已经掌握了一些MV*框架，三层架构，等等。</p><h2 id="2419" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">转换思维模式</h2><p id="bce3" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">设计合适的流有点违背这种思维模式。我们不应该问“谁拥有这些数据”、“这个任务属于哪个责任”或“要定义什么数据类型(类)”这样的典型问题。这些不一定对我们有帮助。</p><blockquote class="mp mq mr"><p id="816d" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">相反，关注目标:用这个流解决什么？然后:解决这个任务需要哪些输入(数据源，最好是输入流)？</p></blockquote><p id="3590" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">剩下的会做相应的安排。一个典型的例子是这样的:我们将所有的输入都作为流。让我们将它们合并成一个单一的，然后通过一些映射操作，也许是一些过滤器，然后订阅结果，使事情在应该发生的时候发生。但这一开始可能会觉得有些奇怪。</p><p id="c703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于更复杂的管道，会有许多中间数据类型。核心的面向对象思维可能会开始小声地为所有东西定义类型。你不应该。</p><p id="cc79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于异步任务，执行可能感觉太不稳定，并且没有明确的所有权。是的，因为它是一个流，而不是众所周知的面向对象解决方案(例如，一个类的异步函数)。</p><p id="02b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">流可能组合来自不同来源的数据源，这可能感觉像是对单一责任原则的背叛。但是也许你的OO肌肉有点太活跃了。</p><h2 id="9bc0" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">面向对象是静态的，流关注动态</h2><p id="292e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">面向对象主要关注代码中更静态的部分:或多或少永久存在的对象(如服务)或被传递的数据。面向对象的思维模式接近于数据库、类，也许还有UML中的部署图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/10b1f6ea979db9183cd8ba7d399902d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*HwCukmVRm4hiHLh2LSu9Bg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Class diagram of the ATM system from <a class="ae ky" href="https://www.researchgate.net/figure/Class-diagram-of-the-ATM-system_fig3_222961575" rel="noopener ugc nofollow" target="_blank">Carlos E. Cuesta</a>. Note that this tells us only a little about the dynamic behavior: about how things interact over time.</figcaption></figure><blockquote class="mp mq mr"><p id="64e8" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">流更接近于UML的序列图或活动图。</p></blockquote><p id="a32e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Streams excel在命令式代码较弱的地方:关注代码的动态行为，而不是单一的线性执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/d09a28d95c3bcf2ebc402fe46861a495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vm7c34Chg4jQ4N1JQikHrg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Example of UML activity diagram showing subscription to an ATM service from <a class="ae ky" href="https://www.researchgate.net/profile/David-Lewis-60" rel="noopener ugc nofollow" target="_blank">David Lewis</a>. It focuses on the dynamic behavior rather than the classes&amp;interfaces.</figcaption></figure><p id="9ad3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两种方法并不相互排斥，它们经常相互补充。例如，您仍然可以将您的流分类。我经常这样做。它为应用程序提供了一个良好的面向对象架构，如果你已经有了一个面向对象框架(例如一个2/3层的Node.js应用程序或Angular中的任何东西)，这可能是你想要的。另一方面，也可以使用纯函数。</p><h1 id="b642" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在哪里使用流？</h1><p id="49d5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">编程很难。我们需要又快又好地解决复杂的问题。而且经常搞砸，经常是被过去的我写的烂代码搞砸。该死的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1c4cbfb9bc54a9ed349a4dadf4f17743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XMqi8yTQJO_K1ZXZgN0mMQ.jpeg"/></div></figure><p id="865b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，至少，我们应该选择各种各样的解决方案，为应对各种各样的挑战做好准备。让我们看看为什么溪流是我们腰带的重要资产。</p><h2 id="bca6" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">1.溪流给地表带来了复杂性</h2><p id="cbc8" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">溪流不容易。我认为命令式代码更容易理解。(这可能是因为我的教育和背景，但是，嘿，大多数程序员可能都是这么看的。)</p><p id="d7c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是命令式代码有一个基本问题:它关注顺序执行。</p><p id="ea8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命令式代码的线性执行很容易理解。然而，如果一个命令式代码(例如一个对象)以各种方式被触发，我们必须处理不断变化的内部状态和一些约束，那么就很难看到全局。</p><p id="80cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我是说，涵盖95%的可能状态转换是很容易的。但是我们错过的单边案例呢？我们如何确保所有可能的转换都被适当地覆盖？好吧，如果你是一个经验丰富的工程师，你有一些诀窍。你可以使用状态机。来自四人组的<a class="ae ky" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/" rel="noopener ugc nofollow" target="_blank">设计模式，也来自你的经验。当然是各种层次各种口味的测试。坚实，干燥，YAGNI，最重要的是:通过多年的编码积累的普遍智慧。</a></p><p id="2585" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，您如何知道您已经涵盖了所有的边缘情况呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8eccf5139af303efdce29af7dcaa75d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-MYyXkmTTPc8YEofaXM2OQ.jpeg"/></div></figure><p id="19f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以看似简单的命令式代码很容易成为丑陋的错误的温床。</p><p id="4952" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果应用得当，流可以为应用程序的正确性提供更强的保证。尽管它们是有代价的，但它们让问题的复杂性变得清晰可见。我们必须把这个问题作为一个整体来理解，来处理流。</p><blockquote class="mp mq mr"><p id="c07d" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">当使用流时，我们必须丢掉简单的幻想。</p></blockquote><h2 id="4c35" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">2.数据流:创建一次，处理所有更改</h2><p id="2b06" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">假设我们有一个前端组件，它从3到4个来源收集数据，然后显示一些派生数据。这些资源中的任何一个都可能随时间任意改变，我们必须保持UI的更新。</p><p id="dc40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命令式代码可能会在发生任何变化时重新计算。这非常简单易懂。但是说，我们必须保持一个间隔运行，不能停止&amp;重新开始。或者数据很大并且经常变化，因此性能方面的问题即将出现。现在，无论什么时候<em class="mc">的某个东西</em>发生变化，我们都无法重新计算<em class="mc">所有的东西</em>。是时候变聪明，开始一个接一个地处理每个变化了，对吗？不对。变得聪明通常是一个非常错误的想法，并且经常会导致神秘的代码和/或大量的错误。</p><p id="50b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这正是溪流介入的时刻。如果3–4个数据源作为流可用，我们可以从它们构建一个管道来计算派生的数据。</p><p id="6963" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，创建这个管道比编写命令式代码更困难。尤其是如果你是新来的。但是一旦我们理解了这个问题(并且有一点流的经验)，就很容易创建一个高效的、<em class="mc">不那么容易的</em>，但是<em class="mc">仍然更容易推理的</em>代码。</p><p id="b354" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您构建的流管道将处理第一次计算，然后以同样的方式处理所有可能的更改。根据我的经验，这将为偷偷摸摸的边缘情况留下更少的空间，代码将有更少的错误，它将更短，更容易维护。</p><h2 id="3057" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">3.跨平台的标准化工具箱</h2><p id="5648" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><a class="ae ky" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank"> Rx在许多编程语言中可用</a>。我主要关注RxJs，但是这些例子在其他语言中也有效。</p><p id="7804" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当构建管道来创建新的流时，<strong class="jm io">我们有一套令人印象深刻的操作符和其他工具供我们使用</strong>。这个工具箱可以卸下我们肩上的重担。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/1ccbfc0865fad524d31bfc384424d5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iit3aTYIwVYcDfjL"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@barnimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Barn Images</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b9a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RxJs中的<a class="ae ky" href="https://rxjs.dev/api" rel="noopener ugc nofollow" target="_blank">操作符和其他工具</a>需要相当长的时间来熟悉。但它们可以极大地提高程序员的生产率，因为它们可能有助于解决许多更困难的问题。</p><p id="6973" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在编程领域，投资于自己的生产力通常是一个非常好的主意。我强烈推荐所有Js开发者熟悉RxJs。如果你是团队领导，也要从团队生产力的角度考虑这个问题。</p><p id="fa70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不是所有的东西都值得投资。但如果用Angular，最好熟悉Angular的细节。React或Vue以及所有其他框架也是如此。我认为RxJs值得在这些值得熟悉的工具中占有一席之地。</p><p id="8100" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">掌握RxJs需要时间和大量的练习。你会搞砸几次。你会付出代价的。但以我的经验来看，这是值得的。</p><h2 id="ec47" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">4.易测性</h2><p id="ce69" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">你做测试对吗？对吗？！</p><p id="20b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RxJs 有<a class="ae ky" href="https://rxjs.dev/guide/testing/marble-testing" rel="noopener ugc nofollow" target="_blank">相当好的测试工具，marble测试真的很强大。它们很容易理解，它们可以处理与时间相关的东西(除了承诺)，它们帮助你惊人地准确识别你的流的行为！</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/68b2fa6be849d5e324ba848e66b9b163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P27-iBdpQpZbqk70IXX6xQ.jpeg"/></div></div></figure><h2 id="0759" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">5.控制的解耦和反转</h2><p id="565d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">很难定义什么是好代码。但是有些方面抓住了好代码的一个重要属性。就像去耦一样:</p><blockquote class="mp mq mr"><p id="da66" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">好的代码很容易删除。</p></blockquote><p id="ec0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有更多:</p><blockquote class="mp mq mr"><p id="28ac" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">删除代码比编写代码更有趣。</p></blockquote><p id="4e32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你没感觉到吗？当删除一大块过时的代码时，当清除一些旧代码中一些令人讨厌的部分时…这很好。但最好的是:</p><blockquote class="mp mq mr"><p id="ae76" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">最好的代码是根本没有代码。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bdb4f39540a78f97fa16655965a99868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*9FFIIcWdKPz3lZNq18pYtQ.jpeg"/></div></figure><p id="d727" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管如此，我们还是在这里，在大部分工作日写代码。(有时在周末。谢谢你的耐心，我的爱人！)</p><p id="4d89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">好的代码被解耦</strong>。很容易独立于其他部分或多或少地修改或删除每个部分。而<strong class="jm io">流可以改善解耦</strong>。</p><p id="7a0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似于控制反转(IoC)。最初，IoC用于依赖注入(DI)。流有些类似:它们是对类交互的<strong class="jm io">控制反转。这是什么意思？假设我们有"<em class="mc">A类"</em>管理一些数据，而"<em class="mc">B类"</em>对这些数据的变化感兴趣。</strong></p><ul class=""><li id="b213" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated">老办法:<em class="mc">A类</em>期望回调或者给定接口通知它。<em class="mc">类B </em>将提供回调或者实现给定的接口。</li><li id="27aa" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">更解耦的方式(又名<a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察器模式</a>):<em class="mc">A类</em>提供一个可观察值。B类将认购——或将由外部方认购。<em class="mc">A类</em>和<em class="mc">B类</em>没有直接接触点。</li></ul><p id="1989" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看后一个怎么更解耦？还有一个好处:它可以无缝地处理更多订阅。</p><h2 id="cd3e" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">6.表演</h2><p id="e55e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我的另一个经验是，面向流的解决方案通常比基本的命令式方法更有效。出于这个原因，Angular的<a class="ae ky" href="https://netbasal.com/a-comprehensive-guide-to-angular-onpush-change-detection-strategy-5bac493074a4?gi=171010e2eb4f" rel="noopener ugc nofollow" target="_blank"> OnPush变化检测策略</a>在很大程度上依赖于流和<em class="mc">异步</em>管道。</p><p id="2ef2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">流管道的微调本质上相对容易。当然，你必须了解订阅是如何工作的，并学习<a class="ae ky" href="https://rxjs.dev/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank">区分时间变化</a>、<a class="ae ky" href="https://rxjs.dev/api/operators/share" rel="noopener ugc nofollow" target="_blank">分享</a>、<a class="ae ky" href="https://rxjs.dev/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank">分享</a>操作符来让信息流闪耀。但是，这些仍然是强大的——一旦你开始理解它们——非常简单的工具。</p><p id="a28d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这个主题，我有一个很好的调试挑战，请随意测试您的知识。</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/rxjs-challenge-spot-the-mistake-fa4fbd163135"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd io gy z fp ny fr fs nz fu fw im bi translated">RxJs挑战:发现错误</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">我已经用RxJs流烧伤了自己(一点点),所以你不必这样做。欢迎来到RxJs上的这个简短的调试之旅。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><h2 id="77b4" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">7.妥协更少</h2><p id="0d04" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当处理与时间相关的复杂问题时，我经常发现自己做出了令人不满意的妥协。类似这样的话:“嗯，让我们把时间间隔定为100毫秒，这就足够接近了。”它通常是绰绰有余的，但仍然…它在我的嘴里留下了不好的味道。</p><p id="0f00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当使用streams时，我几乎发现自己面临这样的妥协。也许是因为当使用streams时，我被迫面对问题的整体复杂性。除了理解它，我还有合适的工具来轻松地创建解决方案。</p><blockquote class="mp mq mr"><p id="9e21" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">当使用streams时，我可以用更少的时间和精力来更好地工作。</p></blockquote><h2 id="2b8c" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">8.开始反复使用它们</h2><p id="645f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">想尝一口溪水吗？好消息:你也可以在面向对象的代码库中引入流。您不必全力以赴地面向流或功能化来获得流的好处。</p><p id="0c26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，我在一个面向对象的代码库上工作，我们在需要的时候逐步引入流。新代码通常比旧代码更加面向流。尽管如此，我们还是计划保留优秀的老OO架构。它很好地服务于我们，解决了我们的许多问题。</p><blockquote class="mp mq mr"><p id="7ccf" class="jk jl mc jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">因此，在保持面向对象架构的同时，我们到处添加更多的反应式解决方案。</p></blockquote><p id="05d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，有一个关于代码库的<strong class="jm io">一致性的问题。你不应该登上你遇到的每一辆炒作列车。但是streams和RxJs的工具箱值得考虑采用。我认为收益远远大于成本，尤其是如果你能达到一个转折点，流的收益开始增加，事情变得更加协同。</strong></p><h1 id="32bd" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么时候不使用流？</h1><p id="82bf" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">流只是熟练程序员手中的一个工具——一个重要的工具。当它使你的生活变得更容易时，你应该使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/89a997afcca2737bb3a6f74e6aeec2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*anDBa76F2ZmBxlTh47QY7A.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">If you only know OO, you’ll try to solve everything using OO. And the very same goes for streams.</figcaption></figure><p id="9617" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看3个不应该急于使用流的用例。</p><h2 id="1799" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">非常简单的问题</h2><p id="4b71" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">你不需要溪流来做这些。它们只会让非常简单的问题变得更加困难。</p><h2 id="9ce8" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">严格线性执行</h2><p id="c9b0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">例如算法；或者大多数基本的3层和/或MVC架构。</p><p id="7933" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，对3层web应用程序的调用是这样的:</p><ul class=""><li id="dda7" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated"><em class="mc">控制器</em>:客户端请求东西</li><li id="a552" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated"><em class="mc">控制器</em> → <em class="mc">服务</em>:拿东西</li><li id="773d" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated"><em class="mc">服务</em> → <em class="mc">仓库1 </em>:从数据库中获取一些东西</li><li id="c4a3" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated"><em class="mc">维修</em> → <em class="mc">仓库2 </em>:从DB获取其他材料</li><li id="7600" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated"><em class="mc">服务</em>:计算并返回东西给控制器</li><li id="b536" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated"><em class="mc">控制器</em>:返回东西给客户端</li></ul><p id="5b43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很简单，不是吗？这里没有太多空间给溪流。ASP.NET MVC、<a class="ae ky" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a>，甚至一个合适的Laravel app都可以做到这一点。</p><p id="c827" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有一个相当大的内存状态(比如一个游戏逻辑)与客户端交互，趋势就开始转变。这是一个很好的候选流。</p><h2 id="38ed" class="md la in bd lb me mf dn lf mg mh dp lj jv mi mj ln jz mk ml lr kd mm mn lv mo bi translated">我想用溪流</h2><p id="3d7c" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这是值得称赞的，然而，欲望不应该指导建筑决策。首先，找到一个适合流的问题。</p><h1 id="aad8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">包裹</h1><p id="4aa0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当使用流可以提高您的性能和您创建的代码的质量时，我强调了以下几个方面。</p><ol class=""><li id="bfb2" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh oj ni nj nk bi translated">溪流给地表带来了复杂性</li><li id="2313" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">数据流:创建一次，处理所有更改</li><li id="968a" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">跨平台的标准化工具箱</li><li id="9215" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">易测性</li><li id="1569" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">控制的解耦和反转</li><li id="4ee9" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">表演</li><li id="c188" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">妥协更少</li><li id="dc2e" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh oj ni nj nk bi translated">开始反复使用它们</li></ol><p id="49be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的几周里，我会写更多关于溪流的内容。感兴趣就订阅吧。</p><h1 id="3985" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">感谢</h1><p id="9279" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">有专家帮助你，你可以学得很快。我从贝特森的Viktor和Péter那里学到了很多关于NgRx &amp;一些高级流的东西。谢谢伙计们。</p><p id="3451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">更多内容看</em> <a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">说白了就是</em> </a> <em class="mc">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">免费周报在这里</em> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>