<html>
<head>
<title>11 Mathematical Algorithms in Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript中的11种数学算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/11-mathematical-algorithms-in-modern-javascript-bce71318e2da?source=collection_archive---------10-----------------------#2021-01-20">https://javascript.plainenglish.io/11-mathematical-algorithms-in-modern-javascript-bce71318e2da?source=collection_archive---------10-----------------------#2021-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6bbb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理数字的超级有用的帮手</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d3813492aa12ce6aca168b7f6a670209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCGhBmY9EgIKspE4j28-tQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/es-es/@black-ice-551383?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Black ice</a> in <a class="ae kv" href="https://www.pexels.com/es-es/foto/muchos-numeros-1314543/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="f37e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个集合包含一组(&gt; = ES6)算法来处理数字。事实是，我以为写这篇文章会花更少的时间，但最终，我花了更多的时间来找到每种情况的最优(或至少最简单)解决方案。</p><p id="ce59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望对你有用！</p><h1 id="843d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">索引:</h1><ol class=""><li id="789a" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">reverse编号</li><li id="1ab1" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">isOdd</li><li id="3e0a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">sumAll</li><li id="a725" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">平均的</li><li id="913a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">中位数</li><li id="35a6" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">计算cd</li><li id="c992" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">计算</li><li id="175b" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">isPrime</li><li id="51da" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">欧几里德距离</li><li id="0d7f" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">是可分的</li><li id="981d" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">格式到货币</li></ol><h1 id="5e6a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.reverse编号</h1><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="ec30" class="nf lt iq nb b gy ng nh l ni nj">const reverseANumber = n =&gt; {<br/>    //1. <br/>    let sing = Math.sign(n).toString();</span><span id="255a" class="nf lt iq nb b gy nk nh l ni nj">//2. <br/>    n = n.toString().replace('-','').replace('+','');</span><span id="5290" class="nf lt iq nb b gy nk nh l ni nj">//3.<br/>    return sing.concat(n.split("").reverse().join(""));<br/>};</span></pre><h2 id="5cb1" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">例子</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="a723" class="nf lt iq nb b gy ng nh l ni nj">console.log(reverseANumber(1000));<br/>console.log(reverseANumber(-1000));<br/>console.log(reverseANumber(0001));<br/>console.log(reverseANumber(12345));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/509a46f30db02c8e52788d6a4e37b4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*VSLcXf61vintwbI3KpQKUg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="da13" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">说明</h2><ol class=""><li id="2b4c" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">首先，我们保存我们的号码。</li><li id="1011" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">其次，我们将数字转换为字符串，以使用replace方法并消除符号。</li><li id="b3b0" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">第三，我们用String.prototype.split(')、Array.prototype.reverse()和String.prototype.join(')，把n的反过来的值作为一个字符串；最后，我们连接先前保存的符号。</li></ol><h1 id="9c0b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.isOdd</h1><p id="c3d0" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">以下方法使用模(%)运算符测试数字是奇数还是偶数，如果数字是奇数，则返回true，如果数字是偶数，则返回false。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="d5d9" class="nf lt iq nb b gy ng nh l ni nj">const isOdd = num =&gt; num % 2 === 1;</span></pre><h2 id="a1a4" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b936" class="nf lt iq nb b gy ng nh l ni nj">console.log("1 is " + isOdd(1));<br/>console.log("2 is " + isOdd(2));<br/>console.log("3 is " + isOdd(3));<br/>console.log("4 is " + isOdd(4));<br/>console.log("5 is " + isOdd(5));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/c022843d87e837f92af2b40eeac458ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*XKa1gxt0NHv6Bzkp4AFYVw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h1 id="e342" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.sumAll</h1><p id="b279" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">这个方法将所有的数字相加，包括两个整数。</p><p id="9545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，给定下面的数组:[2，5]包括两个整数之间的和的所有数之和是2+3+4+5 = 14。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="cfbf" class="nf lt iq nb b gy ng nh l ni nj">const sumAll = (min, max) =&gt; ((max-min)+1) * (min + max) / 2;</span></pre><h2 id="a930" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="6d8d" class="nf lt iq nb b gy ng nh l ni nj">sumAll(2,5);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2feeac99483b3dcc7ea86e7b952a5aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*P9MkqRwWwpdkJuAt-uXq3g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><p id="adb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果第二个参数是零呢？结果为零，这是不正确的。</p><p id="0c33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">[1, 0] = 0</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="a5fb" class="nf lt iq nb b gy ng nh l ni nj">sumAll(1, 0);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/24b8bebfccfede95a060ef67797713f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*eJbeDCW6en9e4BiyZZmIbQ.png"/></div></figure><p id="9330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以改进算法来考虑这一点:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="aa3d" class="nf lt iq nb b gy ng nh l ni nj">const sumAll = (min, max) =&gt; {return max === 0 ? min <br/>     : ((max-min)+1) * (min + max) / 2;<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cac6b299a25a5bb8cf64887ac24ae90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*4Wn0cHjwc12R3QxhWsMfaQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h1 id="8fb6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.平均的</h1><p id="588b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">求一组数字的平均值就像把所有数字相加然后除以数字总数一样简单。</p><p id="e4fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的方法使用Array.prototype.reduce()增加用0初始化的累加器的值，然后将得到的数组除以其长度以获得其平均值。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="0122" class="nf lt iq nb b gy ng nh l ni nj">const average = (...values) =&gt;<br/>  values.reduce((acc, val) =&gt; acc + val, 0) / values.length;</span></pre><h2 id="26d6" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">例子</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="e526" class="nf lt iq nb b gy ng nh l ni nj">console.log(average(1, 2, 3, 4, 5, 6, 7, 8, 9));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/21139b68241fe8cae57a629557537aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*VrxBeYUTLtaJ4oqsjPiPmQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h1 id="2e58" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.中位数</h1><p id="5b4b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">中值是所有数据从最低到最高排序时占据中心位置的值。</p><p id="c878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下方法计算数字数组的中值:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c5ee" class="nf lt iq nb b gy ng nh l ni nj">const median = arr =&gt; {<br/>  const mid = Math.floor(arr.length / 2),<br/>  nums = [...arr].sort((a, b) =&gt; a - b);<br/>  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;<br/>};</span></pre><h2 id="3f2b" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">例子</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="267c" class="nf lt iq nb b gy ng nh l ni nj">console.log(median([5, 2, 10, 3, 20, 1]));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5514483dfda74d8954279137fee097c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*5jzGCJMODl0v_TmK_eBpgQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="a666" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">解释:</h2><ol class=""><li id="035b" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">计算中间值:3</li><li id="c8b8" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">初始数组:[5，2，10，3，20，1]</li><li id="b8aa" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">使用Array.prototype.sort()对值进行排序:[1，2，3，5，10，20]</li><li id="cc75" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">如果数组长度为奇数，则返回中点处的数字，否则返回两个中间数字的平均值:[1，2，<strong class="ky ir"> 3，5 </strong>，10，20]</li><li id="d43a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi">(3 + 5 )/ 2 = 4</li></ol><h1 id="c0b8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.计算cd</h1><p id="a959" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">一组数的<strong class="ky ir">最大公约数</strong>是所有集合数相除后没有余数的最大正整数。它是集合中所有数字的最大倍数。</p><p id="cc02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的方法计算一组数字的最大公约数。</p><p id="3644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑因素:</p><h2 id="aab0" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">使用递归(对于数字数组)</h2><p id="0603" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">如果y等于零，则返回x。否则，返回y的calculateGcd和除法x / y的余数。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="ec46" class="nf lt iq nb b gy ng nh l ni nj">const calculateGcd= (...arr) =&gt; {<br/>  const _calculateGcd = (x, y) =&gt; (!y ? x : _calculateGcd(y, x %  y));<br/>  return [...arr].reduce((a, b) =&gt; _calculateGcd(a, b));<br/>};</span></pre><h2 id="c661" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="4111" class="nf lt iq nb b gy ng nh l ni nj">console.log(calculateGcd(9, 3));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/28a6673fffec28550d665671f7c64b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*RzV6ivxnLxjIBOhUsOII4Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="2c6b" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">无递归(仅针对两个数)</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="9393" class="nf lt iq nb b gy ng nh l ni nj">const calculateGcd = (x, y) =&gt; {<br/>  x = Math.abs(x);<br/>  y = Math.abs(y);<br/>  while(y) {<br/>    var t = y;<br/>    y = x % y;<br/>    x = t;<br/>  }<br/>  return x;<br/>}</span></pre><h2 id="9a06" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f1a8" class="nf lt iq nb b gy ng nh l ni nj">console.log(calculateGcd(9, 3));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2b84a9de01a541f4b1417046dbed95af.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*A5HKrvoXKKV4mX_JtcAcoQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h1 id="50de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.计算</h1><p id="e5ad" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">对于两个整数，x和y表示为LCM(x，y)，<strong class="ky ir">最小公倍数</strong>是能被x和y整除的最小正整数</p><p id="a318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以实现这个数学公式，用Gcd求两个数的LCM这就是:LCM = (n1 x n2) / Gcd (n1，n2)。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="5a6d" class="nf lt iq nb b gy ng nh l ni nj">const calculateGcd = (x, y) =&gt; {<br/>  x = Math.abs(x);<br/>  y = Math.abs(y);<br/>  while(y) {<br/>    var t = y;<br/>    y = x % y;<br/>    x = t;<br/>  }<br/>  return x;<br/>}</span><span id="2f55" class="nf lt iq nb b gy nk nh l ni nj">const lcm = (x, y) =&gt; {<br/>  //1.<br/>  let gcd = calculateGcd(x, y);<br/><br/>  //2.<br/>  return (x * y) / gcd;<br/>}</span></pre><h2 id="fb33" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="fd60" class="nf lt iq nb b gy ng nh l ni nj">console.log(lcm(15, 20));<br/>console.log(lcm(6, 8));<br/>console.log(lcm(10, 2));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c2a47eb7cf5b9903bb9584ecc4af648f.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*mlidseGdE82HnuywWrNKZA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="1057" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">解释:</h2><ol class=""><li id="520c" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">首先使用我们之前的“计算Gcd”方法获得gcd。</li><li id="a03a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">应用计算的gdc计算lcm。</li></ol><h1 id="64c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.isPrime</h1><p id="b1b2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">质数是只能被自己和1整除的数。下面的方法检查一个数是否是质数。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="16a8" class="nf lt iq nb b gy ng nh l ni nj">const isPrime = n =&gt; {<br/>  //1.<br/>  const limit = Math.floor(Math.sqrt(n));</span><span id="0af1" class="nf lt iq nb b gy nk nh l ni nj">  //2.<br/>  for (let i = 2; i &lt;= limit; i++){ </span><span id="14eb" class="nf lt iq nb b gy nk nh l ni nj">      //3.<br/>      if (n % i === 0) return false;<br/>  }</span><span id="ca9e" class="nf lt iq nb b gy nk nh l ni nj">   //4. <br/>   return n &gt;= 2;<br/>};</span></pre><h2 id="62fd" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="7ce7" class="nf lt iq nb b gy ng nh l ni nj">console.log(isPrime(1));<br/>console.log(isPrime(7));<br/>console.log(isPrime(11)); <br/>console.log(isPrime(4));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/765e513a517de2b2ba5b3ae8fddec60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*7zTNIFrgDxMNGgp204T9UA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="77b3" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">解释:</h2><ol class=""><li id="e624" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">计算给定数字的平方根。</li><li id="f43c" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">测试数字从2到计算的平方根。</li><li id="1f92" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">如果它们中的任何一个除以给定的数(n % i === 0)，则返回false。我们只想要能被它们自己和1整除的数字。</li><li id="3bc2" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">在另一种情况下，如果n≥2，则返回true。</li></ol><h1 id="d7bc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">9.欧几里德距离</h1><p id="5e78" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">欧氏空间中两点间的欧氏距离是两点间线段的长度。下面的方法计算任意维数的两点之间的距离。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="db81" class="nf lt iq nb b gy ng nh l ni nj">const euclideanDistance = (x, y) =&gt;<br/>  Math.hypot(...Object.keys(x).map(k =&gt; y[k] - x[k]));</span></pre><h2 id="1d6e" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="4319" class="nf lt iq nb b gy ng nh l ni nj">console.log(euclideanDistance([1, 5], [2, 6])); <br/>console.log(euclideanDistance([1, 1, 2], [2, 4, 6]));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c2af257eb3a1aa942123af7dc908d845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*8kDPopZvoL9BAQ78SgbB_Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="c3cf" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">解释:</h2><ol class=""><li id="163b" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">首先，我们将每个坐标映射到两点之间的差值。</li><li id="7946" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">其次，我们使用Math.hypot()方法来计算前面两点之间的欧氏距离。</li></ol><h1 id="3323" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">10.是可分的</h1><p id="6ed6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">下面的方法检查第一个数字参数是否能被第二个整除。</p><p id="f8a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用模运算符(%)来检查余数是否等于0。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="4556" class="nf lt iq nb b gy ng nh l ni nj">const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;</span></pre><h2 id="3697" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">例子</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b4c5" class="nf lt iq nb b gy ng nh l ni nj">console.log(isDivisible(10,1));<br/>console.log(isDivisible(10,2));<br/>console.log(isDivisible(10,3));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/374d9df879461582bb73d8c713eb9688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*9qK_1Q6e5AK7qmsDHxR7jA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h2 id="221c" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">说明</h2><p id="bb4a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">如果计算被除数和除数之间的除法余数是零，那么它是可除的。</p><h1 id="11e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">11.格式到货币</h1><p id="3fe9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">获取一个数字，并以指定的货币格式返回该数字。</p><p id="de26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用NumberFormat实例将任何数字格式化为货币值:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b20d" class="nf lt iq nb b gy ng nh l ni nj">const formatToCurrency = (n, curr, language) =&gt;<br/>  Intl.NumberFormat(language, {<br/>    style: 'currency',<br/>    currency: curr,<br/>  }).format(n);</span></pre><h2 id="1ece" class="nf lt iq bd lu nl nm dn ly nn no dp mc lf np nq me lj nr ns mg ln nt nu mi nv bi translated">示例:</h2><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="251e" class="nf lt iq nb b gy ng nh l ni nj">//Currency: US Dollar, currency lang format: USA<br/>console.log(formatToCurrency(1000.10, 'USD', 'en-us'));</span><span id="1500" class="nf lt iq nb b gy nk nh l ni nj">//Currency: Euro, currency lang format: German<br/>console.log(formatToCurrency(1000.10, '<!-- -->EUR<!-- -->', '<!-- -->de-DE<!-- -->'));</span><span id="036b" class="nf lt iq nb b gy nk nh l ni nj">//Currency: Euro, currency lang format: Local<br/>console.log(formatToCurrency(1000.10, 'EUR'));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/98a41cd98da95b9cfb4eb83ec785f4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*-Y9CuLDXWfOz5PPvWIu-oA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of running the above code in Chrome dev tools.</figcaption></figure><h1 id="3ca2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="0351" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">到目前为止，这个用JavaScript编写的数学算法的小集合，我写得很开心，尽管有时候它们一开始并没有把我弄明白，我不得不上网一点点直到我成功。</p></div></div>    
</body>
</html>