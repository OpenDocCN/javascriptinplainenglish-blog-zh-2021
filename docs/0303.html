<html>
<head>
<title>How to Make a Simple Custom Drag to Move Component in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中进行简单的自定义拖动以移动组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-simple-custom-drag-to-move-component-in-react-f67d5c99f925?source=collection_archive---------0-----------------------#2021-01-18">https://javascript.plainenglish.io/how-to-make-a-simple-custom-drag-to-move-component-in-react-f67d5c99f925?source=collection_archive---------0-----------------------#2021-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d9f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React组件，允许用户拖动和移动常规DOM元素和SVG元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b23a4038da2baf3137bd9ca5ed240b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UUDrxeLvfFTIx8q16Ml9Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Your move.</figcaption></figure><p id="d1c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢制作有趣的交互式web东西，最近我写了一篇关于在React中创建一个挂钩的文章。正如我在那篇文章中提到的，有大量的拖放库，无论是专门用于React还是其他。例如，<code class="fe kz la lb lc b"><a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd" rel="noopener ugc nofollow" target="_blank">react-beautiful-dnd</a></code>是一个漂亮的拖放实现，用于在列表间移动，很像<a class="ae ky" href="https://trello.com/" rel="noopener ugc nofollow" target="_blank"> Trello </a>。也就是说，有时你并不需要所有的火力，你只需要一些小的东西，或者你只是喜欢修补和编写自己的代码！</p><p id="c04f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，我的另一篇<a class="ae ky" href="https://medium.com/javascript-in-plain-english/how-to-make-a-simple-custom-usedrag-react-hook-6b606d45d353" rel="noopener">文章</a>讨论了使用React钩子拖动组件，这有它的优点和缺点；这一个将集中在包装元素和使用React内置事件处理程序的容器组件上。我们还将介绍如何升级我们的组件以允许它拖动一个<code class="fe kz la lb lc b">svg</code>元素。</p><h1 id="7f59" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">反应事件处理程序</h1><p id="3018" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">您可能已经知道，React元素的事件处理方式与DOM元素略有不同。对于React元素，我们使用<code class="fe kz la lb lc b">camelCase</code>而不是<code class="fe kz la lb lc b">lowercase</code>作为事件名称，并传递一个函数作为事件处理程序而不是一个字符串，如这里概述的<a class="ae ky" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank"/>。有大量不同的处理程序类型可以用来满足我们最疯狂的拖动幻想，其中一些包括<strong class="jm io">拖动</strong>处理程序、<strong class="jm io">鼠标</strong>处理程序和<strong class="jm io">指针</strong>处理程序。除其他外。</p><h2 id="bebc" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">拖动处理程序</h2><p id="9133" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">如果我们的目的是将一个元素拖动到一个特定的拖放区，那么我们绝对希望使用这组处理程序。通常，在这种情况下，我们实际上并不<em class="mg">移动</em>元素本身，而是我们拖动<em class="mg">数据</em>，然后当我们放下它时执行一个动作。例如，我们可以从一个列表中拖动一个<code class="fe kz la lb lc b">li</code>项到另一个列表上，然后当我们放下<code class="fe kz la lb lc b">li</code>时，它会从原来的列表中移除并呈现在新列表中。</p><ul class=""><li id="634b" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDrag</code> —拖动元素时调用</li><li id="f61e" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDragStart</code> —拖动开始时调用</li><li id="c1f2" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDragEnd</code> —拖动结束时调用</li><li id="fd41" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDragEnter</code> —当被拖动的元素进入有效的放置目标时调用</li><li id="52fd" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDragLeave</code> —当被拖动的元素离开有效的放置目标时调用</li><li id="98c0" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onDragOver</code> —当元素被拖动到有效的放置目标上时调用</li></ul><blockquote class="nh ni nj"><p id="ae5d" class="jk jl mg jm b jn jo jp jq jr js jt ju nk jw jx jy nl ka kb kc nm ke kf kg kh ig bi translated">使用这些拖动处理程序还需要元素具有<code class="fe kz la lb lc b">draggable</code>属性。</p></blockquote><h2 id="34d5" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">鼠标处理程序</h2><p id="9c20" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">这些都是不言而喻的，并且通常与鼠标交互。我们可以使用这些来实现拖动行为，跟踪移动的像素并为元素分配新的坐标，从而实际上是<em class="mg">移动</em>或<em class="mg">平移</em>元素到一个新的位置。</p><ul class=""><li id="7598" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated"><code class="fe kz la lb lc b">onMouseDown</code> —按下鼠标时调用</li><li id="3357" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onMouseUp</code> —释放鼠标时调用</li><li id="2456" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onMouseMove</code> —鼠标移动时调用</li></ul><h2 id="bc2f" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">指针处理程序</h2><p id="f248" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">指针处理程序的功能基本上与鼠标处理程序相同，除了它们是“硬件不可知的”，这意味着它们不<em class="mg">只</em>与鼠标交互，还包括其他“指针设备”，如触摸(手指、脚趾等)。)表面和笔/触笔表面。也就是说，使用指针处理程序可以简化和改善用户体验，因此通常是我们用例的首选。</p><ul class=""><li id="8d34" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerDown</code> —按下<em class="mg">指针</em>时调用</li><li id="995b" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerUp</code> —按下<em class="mg">指针</em>时调用</li><li id="2981" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerMove</code> —按下<em class="mg">指针</em>时调用</li></ul><h1 id="ad93" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">DragMove组件</h1><p id="4496" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">这个React组件的目标是允许通过一个<code class="fe kz la lb lc b">css</code>属性将一个元素移动到DOM空间中的一个新位置。因为我们实际上是在移动或<em class="mg">转换</em>元素，所以我们<em class="mg">而不是</em>将使用<code class="fe kz la lb lc b">drag</code>处理程序集，因为它们更关心的是移动数据，而不是元素本身。相反，我们将使用<code class="fe kz la lb lc b">pointer</code>处理程序。为了避免混淆，并与实现<code class="fe kz la lb lc b">drag</code>处理程序的组件区分开来，我们将组件命名为<code class="fe kz la lb lc b">DragMove</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">DragMove component</figcaption></figure><p id="c261" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">包装很简单，但是让我们来看一下。</p><h2 id="a7a1" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">小道具</h2><p id="bfb9" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">它需要两个可选的回调:<code class="fe kz la lb lc b">onPointerDown</code>和<code class="fe kz la lb lc b">onPointerMove</code>。如果您想扩展组件的功能，可以提供这些。</p><p id="1f64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它还需要一个必需的<code class="fe kz la lb lc b">onDragMove</code>函数，该函数为<code class="fe kz la lb lc b">onPointerMove</code>传回事件。</p><p id="3748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过<code class="fe kz la lb lc b">children</code>访问被包装的子节点，它是我们想要拖动和移动的任何有效的React节点。</p><p id="04ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们还接受可选的<code class="fe kz la lb lc b">style</code>和<code class="fe kz la lb lc b">className</code>道具，以防我们想要或需要扩展<code class="fe kz la lb lc b">div</code>包装器的样式。</p><h2 id="5d53" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">状态</h2><p id="e4c9" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我们声明一个<code class="fe kz la lb lc b">isDragging</code>状态变量来跟踪包装器当前是否在拖动。</p><h2 id="83f3" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">方法</h2><p id="0377" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在组件中，我们声明了三个处理程序方法:<code class="fe kz la lb lc b">handlePointerDown</code>、<code class="fe kz la lb lc b">handlePointerUp</code>和<code class="fe kz la lb lc b">handlePointerMove</code>，它们分别被分配给包装传递的<code class="fe kz la lb lc b">children</code>的<code class="fe kz la lb lc b">div</code>容器上的属性<code class="fe kz la lb lc b">onPointerDown</code>、<code class="fe kz la lb lc b">onPointerUp</code>和<code class="fe kz la lb lc b">onPointerMove</code>。</p><p id="b6b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当按下<code class="fe kz la lb lc b">div</code>上的<code class="fe kz la lb lc b">pointer</code>时，<code class="fe kz la lb lc b">handlePointerDown</code>被调用，我们将<code class="fe kz la lb lc b">isDragging</code>设置为<code class="fe kz la lb lc b">true</code>(如果传递了一个函数，则调用我们可选的<code class="fe kz la lb lc b">onPointerDown</code>函数)。</p><p id="08fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当在<code class="fe kz la lb lc b">window</code>上释放<code class="fe kz la lb lc b">pointer</code>时，就会调用<code class="fe kz la lb lc b">handlePointerUp</code>，我们将<code class="fe kz la lb lc b">isDragging</code>设置为<code class="fe kz la lb lc b">false</code>(如果传递了一个函数，则调用可选的<code class="fe kz la lb lc b">onPointerUp</code>函数)。</p><p id="9eb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后还有<code class="fe kz la lb lc b">onPointerMove</code>，每当指针移动的时候就叫<em class="mg">。由于我们只想在<code class="fe kz la lb lc b">isDragging</code>为<code class="fe kz la lb lc b">true</code>时移动包装器，所以我们先检查<code class="fe kz la lb lc b">isDragging</code>，如果是<code class="fe kz la lb lc b">true</code>，我们调用所需的<code class="fe kz la lb lc b">onDragMove</code>函数。如果可选的<code class="fe kz la lb lc b">onPointerMove</code>函数被传递，我们在这里也调用它。</em></p><h2 id="1a66" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">效果</h2><p id="1c28" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">我们定义了一个<code class="fe kz la lb lc b">useEffect</code>钩子，只在组件挂载后触发一次(因为我们传递了一个空的依赖关系数组<code class="fe kz la lb lc b">[]</code>)。安装后，我们将<code class="fe kz la lb lc b">pointerup</code>监听器添加到<code class="fe kz la lb lc b">window</code>对象，该对象调用<code class="fe kz la lb lc b">handlePointerUp</code>。我们在<code class="fe kz la lb lc b">window</code>而不是<code class="fe kz la lb lc b">div</code>上注册这个监听器，因为否则的话<code class="fe kz la lb lc b">isDragging</code>状态只会在指针上升<em class="mg">同时</em>超过<code class="fe kz la lb lc b">div</code>时切换。我们想在指针上升时切换<code class="fe kz la lb lc b">isDragging</code>状态，不管它在哪里。我们还返回一个移除事件侦听器的函数，该函数在组件卸载时运行。</p><h1 id="fbda" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">例子</h1><p id="dc4f" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">这里有一个<code class="fe kz la lb lc b">DragMove</code>包装器的示例实现。注意，我们声明了一个<code class="fe kz la lb lc b">translate</code>状态变量来保存被包装的<code class="fe kz la lb lc b">children</code>的当前位置。每当我们在图像上按下并拖动指针时，<code class="fe kz la lb lc b">handleDragMove</code>被调用，我们从事件中提取<code class="fe kz la lb lc b">movementX</code>和<code class="fe kz la lb lc b">movementY</code>，并将它们添加到当前的<code class="fe kz la lb lc b">translateX</code>和<code class="fe kz la lb lc b">translateY</code>。甜度！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np no l"/></div></figure><h2 id="a81b" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">其他考虑</h2><p id="f6e0" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在我们的例子中，我们用元素的<code class="fe kz la lb lc b">transform</code>属性移动了它。我们也可以设置我们的元素有<code class="fe kz la lb lc b">relative</code>或<code class="fe kz la lb lc b">absolute</code>定位，并用<code class="fe kz la lb lc b">left</code>和/或<code class="fe kz la lb lc b">top</code> CSS属性调整它的位置。这是我们选择<em class="mg">而不是</em>在<code class="fe kz la lb lc b">DragMove</code>组件内部保存当前位置信息的一个原因——它让您决定如何处理拖动信息以及如何根据具体情况实现它。</p><p id="cff5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，您可以将<code class="fe kz la lb lc b">translate</code>状态移动到<code class="fe kz la lb lc b">DragMove</code>组件中，这样可以简化它的使用，但是可能会降低它的可扩展性。</p><h1 id="44fe" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">SVG元素</h1><p id="8800" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">可缩放矢量图形(SVG)是一种“基于XML的标记语言，用于描述基于二维的矢量图形<a class="ae ky" href="https://en.wikipedia.org/wiki/Vector_graphics" rel="noopener ugc nofollow" target="_blank">。也就是说，SVG可以用来制作漂亮的——借助于像<code class="fe kz la lb lc b">DragMove</code>这样的东西——交互式图形。</a></p><p id="88a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然SVG很棒，但是我们不能像现在一样使用我们的<code class="fe kz la lb lc b">DragMove</code>包装器，因为SVG使用他们自己的一组特殊标签，不包括像<code class="fe kz la lb lc b">div</code>这样的标签，这是我们用来包装<code class="fe kz la lb lc b">children</code>的。让我们对考虑到<code class="fe kz la lb lc b">svg</code>的<code class="fe kz la lb lc b">DragMove</code>组件做一个小小的修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">DragMove component—upgraded for SVG</figcaption></figure><p id="1ea5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们添加了一个<code class="fe kz la lb lc b">isSvg</code>属性，它决定了它是否在<code class="fe kz la lb lc b">svg</code>中被渲染。当<code class="fe kz la lb lc b">true</code>时，我们动态地将包装元素从<code class="fe kz la lb lc b">div</code>更改为<code class="fe kz la lb lc b">g</code>，这是一个“组”SVG容器元素，它将其属性传递给其子元素。</p><blockquote class="nh ni nj"><p id="fe77" class="jk jl mg jm b jn jo jp jq jr js jt ju nk jw jx jy nl ka kb kc nm ke kf kg kh ig bi translated">注意:动态设置元素标签类型时，变量名<strong class="jm io">必须</strong>以大写字母开头。</p></blockquote><p id="e5ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！这是另一个使用包装器包装<code class="fe kz la lb lc b">svg</code>组件的例子。尝试移动地图上的<strong class="jm io">紫色航点</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np no l"/></div></figure><h1 id="26a9" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="e192" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">噪音🎉，我们制作了自己的包装器，允许我们移动常规DOM元素和SVG元素！以下是一些要点:</p><h2 id="d309" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated"><strong class="ak">拖动事件</strong></h2><p id="fac5" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">通常用于拖放<em class="mg">数据</em>，而不是实际改变元素的CSS定位。</p><h2 id="a1cd" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">指针事件</h2><p id="bb82" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">可用于操纵给定DOM或SVG元素的CSS定位。通常也是<code class="fe kz la lb lc b">mouse</code>事件的更好替代，因为它包含更广泛的设备类型(触摸等)。).</p><ul class=""><li id="7f60" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerUp</code></li><li id="102a" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerDown</code></li><li id="856f" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><code class="fe kz la lb lc b">onPointerMove</code></li></ul><h2 id="7445" class="mh le in bd lf mi mj dn lj mk ml dp ln jv mm mn lr jz mo mp lv kd mq mr lz ms bi translated">SVG元素</h2><p id="9509" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">SVG元素不像<code class="fe kz la lb lc b">div</code>那样使用原生DOM元素，相反，您会希望使用<code class="fe kz la lb lc b">g</code>元素来“分组”SVG元素。</p><p id="db74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">差不多就是这样！感谢阅读🙏，希望你学到了一些东西(我当然有)！</p><h1 id="d2e4" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">资源和参考</h1><ul class=""><li id="5aab" class="mt mu in jm b jn mb jr mc jv nq jz nr kd ns kh my mz na nb bi translated"><a class="ae ky" href="https://codesandbox.io/s/dragmove-wrapper-cg4hu" rel="noopener ugc nofollow" target="_blank">示例代码沙箱</a></li><li id="f422" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><a class="ae ky" href="https://codesandbox.io/s/dragmove-wrapper-svg-gdogo" rel="noopener ugc nofollow" target="_blank">示例SVG代码沙箱</a></li><li id="b4c7" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><a class="ae ky" href="https://github.com/tmarshall07/medium-dragmove-component" rel="noopener ugc nofollow" target="_blank">https://github.com/tmarshall07/medium-dragmove-component</a></li><li id="2fdf" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated"><a class="ae ky" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/handling-events.html</a></li></ul></div></div>    
</body>
</html>