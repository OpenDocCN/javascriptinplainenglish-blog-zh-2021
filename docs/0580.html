<html>
<head>
<title>React Server Components comes with Zero Bundle Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React服务器组件的捆绑包大小为零</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-server-components-comes-with-zero-bundle-size-bc23c8052813?source=collection_archive---------8-----------------------#2021-02-04">https://javascript.plainenglish.io/react-server-components-comes-with-zero-bundle-size-bc23c8052813?source=collection_archive---------8-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e705" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React服务器组件仍在研发中，但对React开发者来说将是一个巨大的变化。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f38edb1eeefde644cf4faab960b558ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSw-njRsFwVlqbTElIX8oQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ikukevk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kv" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2020年12月，react宣布他们正在研究React服务器组件。服务器端的React组件？它引起了我很大的兴趣，在发现之后，我爱上了它。让我们一起来了解一下这些组件是什么。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3d48" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是React服务器组件？</h1><p id="d8dc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">React服务器组件是一个带有<strong class="ky ir"> <em class="mw"> .server.js </em> </strong>扩展名的基本组件。</p><p id="7fa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个组件的强大之处在于它将在服务器端呈现。这意味着它将能够非常容易和快速地恢复数据进行渲染。然后，服务器会将完全呈现的组件发送到客户端进行显示。</p><p id="a9bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React服务器组件的一个简单示例可能是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/3bb34e69e0f195e8a549d709a45c6efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhxBnRfjqPW3f4NjIkeALg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Post.server.js</figcaption></figure><p id="417a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来很神奇，但这是可能的。因为组件是在服务器端呈现的，所以我们可以直接访问组件需要的数据。</p><h1 id="a5fd" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">零束尺寸</h1><p id="5020" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经看到，React服务器组件在服务器端呈现，然后发送到客户端。这意味着该组件不包含在客户机捆绑包中，并且根本不会增加它的大小。</p><p id="6742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的是:当一个外部库只被服务器组件使用而不被客户机组件使用时，这个库也不会被添加到客户机包中，因为这是不必要的。</p><p id="a832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个带有Post组件的moment库的快速示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/6b4bb6d7f202450e88bca5b14a93ad2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3N-Kqa5_4ai8gjWLWSblKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Server component using external library</figcaption></figure><p id="cc51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">moment库将不包含在捆绑包客户端中，因为它由服务器组件使用。服务器只会向客户端发送Post组件的呈现形式，仅此而已。这是减少客户端捆绑和提高性能的好方法。</p><h1 id="288a" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">混合React服务器组件和React客户端组件</h1><p id="936c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">由于组件是在服务器端呈现的，所以它只能用于显示数据，而不能进行交互，因此不能使用状态或事件侦听器。</p><p id="9324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是可以同时使用客户机和服务器组件。这允许将所有交互逻辑放在客户机组件中，并将显示放在服务器组件中。</p><p id="25d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到我们的Post组件。我们将使用一个客户端组件PostWrapper，当我们单击一个按钮时，它将显示或隐藏其子组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/073b5ced8563d9ea02c7c693d8ffe623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_v4Iy34-Fkncb17QWM3FQ.png"/></div></div></figure><p id="5378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理所有交互性的代码在我的PostWrapper客户端组件中。我给它一个已经在服务器端生成的props，它可以显示或隐藏，这取决于在PostWrapper组件中生成的逻辑。太神奇了！</p><p id="385d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您将props从服务器组件传递到客户端组件时，您只能通过网络传递可序列化的数据。因此不可能将函数作为props给出，因为函数是不可序列化的。</p><h1 id="78c3" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated"><strong class="ak">重新渲染服务器组件</strong></h1><p id="373a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在他们的演示应用程序中，React团队使用上下文实现了一个系统，路由基础设施正在监视该上下文。一旦服务器组件的给定属性发生变化，就会调用服务器，以便组件被重新呈现并返回给客户机。</p><p id="d513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，可以重新渲染服务器组件，但这不应该定期进行，因为每次重新渲染都会调用服务器，这可能需要几毫秒的时间，并会降低用户体验。</p><h1 id="8a5d" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">共享组件</h1><p id="c6b1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">扩展名为<strong class="ky ir"> <em class="mw"> .server.js </em> </strong>的组件是服务器组件。扩展名为<strong class="ky ir"> <em class="mw"> .client.js </em> </strong>的组件是静默组件(日常使用的普通组件)。也有可能同时拥有两者的组件:它是一个共享组件。</p><p id="0b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">共享组件是扩展名为<strong class="ky ir"> <em class="mw">的组件。js </em> </strong>如果导入到服务器组件中则成为服务器组件，如果导入到静默组件中则成为静默组件。</p><p id="91d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一个允许我以特定样式显示文本的基本组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/2a5fa78556d88b6274bc0bbad249a907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uue5vop5Jq-0_f_DBejzVA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Example of Text Component</figcaption></figure><p id="e8a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以使用这个组件作为服务器组件来显示静态文本，比如一篇中型文章的文本。由于服务器组件的优势，结果会很快出来。</p><p id="91d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我也可以将这个组件作为客户端组件使用。当我写一篇中型文章时，我的组件的道具文本会经常改变，我想很快看到结果。服务器组件需要调用服务器，以便为每个更改重新呈现。在这种情况下，使用客户端组件更合适，我的组件响应速度会更快。</p><p id="4e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，可以根据需要在服务器端或客户端使用共享组件。不幸的是，它不具备真正客户端组件的所有功能，比如使用状态或事件监听器。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="4a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，服务器组件的要点是:</p><ul class=""><li id="6809" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">对束尺寸没有影响</li><li id="3d34" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">直接访问后端</li><li id="7c6c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">自动客户代码分割</li><li id="6351" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">你喜欢用多少就用多少</li><li id="6dc4" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">服务器心智模型，现代UX</li></ul><p id="973e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是React团队制作的演示视频的摘要。如果你喜欢这篇文章，我强烈建议你在他们的博客上观看。</p><p id="87d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，服务器组件仍在研发中，几个月后才会上市。我等不及要用它们了！</p></div></div>    
</body>
</html>