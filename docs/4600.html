<html>
<head>
<title>How to Reduce React App Loading Time By 70%</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将React应用程序加载时间缩短70%</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/speed-up-your-react-app-initial-load-using-code-splitting-f2de58c01ed2?source=collection_archive---------0-----------------------#2021-09-14">https://javascript.plainenglish.io/speed-up-your-react-app-initial-load-using-code-splitting-f2de58c01ed2?source=collection_archive---------0-----------------------#2021-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0119" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用代码分割减少React应用程序初始加载时间的步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48843ca913b3e6adb5080ee67372c03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hD8AmQ4yeAhubVx8LBtlLw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NordWood Themes</a> on <a class="ae ky" href="https://unsplash.com/s/photos/loading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用<a class="ae ky" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>构建大规模应用。在构建这些应用程序时，我们面临的主要问题是应用程序性能。当应用程序变得越来越大时，性能可能会下降。特别是应用程序的初始加载时间将受到更大的影响。最初的应用程序加载需要快速，而不需要向用户显示几秒钟的空白屏幕。因为需要更多的时间来加载，这会给用户留下不好的印象。</p><p id="d798" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个问题的主要原因是在一个包文件中添加了太多的组件，所以加载这个包文件可能需要更多的时间。为了避免这种问题，我们需要以一种优化的方式构建我们的组件。为了解决这个问题，react本身有一个本地解决方案，那就是代码分割和延迟加载。这允许将包文件分割成较小的大小。</p><p id="a5d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">引入代码分割的最佳位置是在路由中。基于路由的代码分割解决了一半的问题。但是大多数应用程序只利用了代码分割的50%的优势。</p><p id="f979" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当使用代码分割时，我们是否正确地构造了组件？我们可以使用一些代码示例来了解为什么以及如何修复它。为此，我们将使用一个带有一些UI组件的示例React应用程序。</p><p id="3aac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的截图中，我们可以看到一个仪表板组件，它有多个选项卡。每个选项卡都有多个组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/a61e1ae5b284638706a3ba6afb1d331c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6SfBR-gVF0obbHBvgYETA.png"/></div></div></figure><p id="b2a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仪表板组件使用基于路线的代码分割作为下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="d018" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仪表板组件包含一些子组件，如销售、利润、图表、图块和趋势，如下面的代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3255" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经把代码分成了几条路线。因此，当应用程序被捆绑，我们得到一个单独的构建文件为每条路线如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lc"><img src="../Images/89b8ac3e9d41dc1453ce061ec68bcb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHsAz_3ZfoyF7YZcwBw4Kw.png"/></div></div></figure><p id="b774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上图来看，大小为<strong class="jm io"> 405.1 KB </strong>的文件是dashboard组件，其他文件是Header、sidebar、其他组件和CSS。</p><p id="a7b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经在<a class="ae ky" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>托管了这个应用来测试性能。就像我们在本地测试应用程序一样，我们找不到不同之处。当我用<a class="ae ky" href="https://gtmetrix.com/" rel="noopener ugc nofollow" target="_blank"> GTmetrix </a>测试托管的应用程序时，仪表板屏幕花了<strong class="jm io"> 2.9秒</strong>加载，检查下图的逐帧加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ld"><img src="../Images/92aeb124ad9e877fb15cea894a882ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzN60KPtdHyGANgnh10B8w.png"/></div></div></figure><p id="783d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仪表板组件是该应用程序的初始页面，因此当我们点击应用程序URL <strong class="jm io">时，405.1KB </strong>文件将与标题和侧栏一起加载。</p><p id="9760" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初，用户将只查看<strong class="jm io">销售</strong>选项卡，但是我们的示例应用程序仪表板组件有多个选项卡。浏览器也在下载其他标签代码，所以它延迟了用户的第一次绘制。为了减少初始加载时间，我们需要对仪表板组件进行如下更改</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ff9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我用延迟加载导入了每个选项卡组件，并用悬念包装了组件。为了更好的理解，我在这里添加了多个悬念，但是你可以对所有组件使用单个悬念。</p><p id="f332" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有对路由级代码分割做任何修改。当我们构建应用程序时，我们会添加一些额外的文件，因为我们已经延迟加载了仪表板组件中的每个选项卡。检查下图中的构建文件分离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi le"><img src="../Images/582a525fd9f35272aa946f56965a2ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sK5bOcHmt3JkxjwmixJNg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Build Logs</figcaption></figure><p id="9b06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们根据上面的更改，再次使用GTmetrix测试该应用程序。查看下图中的应用程序性能</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ld"><img src="../Images/9b98d84636ce4b676cd83fdbeff62b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv_a5zJjawulMcK2RSOXAw.png"/></div></div></figure><p id="d378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，现在我们的仪表板组件在<strong class="jm io"> 1秒</strong>内加载完毕。由于<strong class="jm io">销售</strong>标签代码现在只加载。通过做一些改动，我们已经减少了差不多<strong class="jm io"> 2秒</strong>。让我们看看下图中基于路由和基于路由、基于组件的代码分割的比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lf"><img src="../Images/840daac94c9503cdd8d235a4c273efc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8evnktHj-F4wPGMPisHOw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Route Based Code Splitting</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lg"><img src="../Images/12c3546addab32c448244b62b6bc4f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-PghMZzRra0k--oYd1X1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Route and Component-Based Code Splitting</figcaption></figure><p id="fad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，这是应用程序初始加载的巨大改进。现在，通过在仪表板组件中有效地使用代码拆分，我们已经通过一些调整将React应用程序的初始加载时间减少了70%。</p><h1 id="c597" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">参考</h1><ol class=""><li id="b9d1" class="mf mg in jm b jn mh jr mi jv mj jz mk kd ml kh mm mn mo mp bi translated"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#code-splitting" rel="noopener ugc nofollow" target="_blank">代码拆分</a></li><li id="4dc1" class="mf mg in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated"><a class="ae ky" href="https://gtmetrix.com/blog/first-contentful-paint-explained/" rel="noopener ugc nofollow" target="_blank">第一次心满意足的画画</a></li></ol><h1 id="04ad" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">结论</strong></h1><p id="a05c" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh ig bi translated">以优化的方式构建组件并有效地使用React APIs将提高大型应用程序的性能。</p><p id="8964" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读。</p><p id="6fec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="my">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="my">plain English . io</em></strong></a></p></div></div>    
</body>
</html>