<html>
<head>
<title>7 Native Errors in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的7个原生错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-native-errors-in-javascript-39c0474ad1f2?source=collection_archive---------10-----------------------#2021-10-04">https://javascript.plainenglish.io/7-native-errors-in-javascript-39c0474ad1f2?source=collection_archive---------10-----------------------#2021-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/acc766fd0a69dda3a188246256554bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pd8gBlsiRa_dbreImA2eVA.png"/></div></div></figure><p id="d649" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一次又一次，你坐在StackOverflow前面，试图找出你的代码中到底发生了什么，为什么它不工作。这很令人沮丧，因为大多数时候，报告的问题并不总是立即清晰。这篇博文将帮助你下次使用JavaScript时更好地解决问题。我将介绍一些常见的JavaScript错误类型和它们的来源，我希望它能在将来帮助你更有效地调试代码。</p><blockquote class="kt ku kv"><p id="7c8d" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">我也有这篇文章的youtube版本，你可以在这里观看。</p></blockquote><h2 id="f328" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated"><strong class="ak">JS中最常见的错误类型</strong></h2><ol class=""><li id="1e04" class="lu lv in jx b jy lw kc lx kg ly kk lz ko ma ks mb mc md me bi translated">评估错误</li><li id="f6fa" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">范围误差</li><li id="c933" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">参考错误</li><li id="9acd" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">语法错误</li><li id="af45" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">类型错误</li><li id="ff66" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">URIError</li><li id="95df" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">聚合错误</li></ol><p id="5b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些错误类型是浏览器返回的<strong class="jx io">对象</strong>。因此，任何时候你得到一个属于这种类型的错误，你都可以使用这个错误对象的所有属性。由于这些错误继承了主<strong class="jx io">错误</strong>对象的属性，您可能会看到它们之间的相似之处。Error对象具有下列属性，您可以在应用程序中利用这些属性</p><ul class=""><li id="dc92" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">消息—出现此错误时显示的消息。</li><li id="0306" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">名称—错误的名称/类型</li><li id="245b" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">您还会看到一些额外的属性，基于错误的类型，也基于您正在使用的浏览器。</li></ul><h2 id="24b0" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">1.评估错误</h2><p id="1c69" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">JavaScript有这个全局<strong class="jx io"> eval() </strong>函数，它最初用于计算字符串形式的JavaScript语句/表达式。比如说，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="56df" class="lb lc in mw b gy na nb l nc nd">eval('2 + 2') //  Output: 4</span></pre><p id="d063" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你运行这个函数的时候，每当你得到一个错误，它会给你一个<strong class="jx io"> EvalError </strong>。现在，如果你有一些安全方面的经验，你会立即在这里看到一个<strong class="jx io">危险信号</strong>。如果有人将恶意代码作为字符串传递到这个函数中，该怎么办？正如所料，它将由浏览器执行。因为JavaScript支持现成的字符串表达式求值，所以最好不要在任何项目中使用eval函数。</p><p id="eff5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">在当前的ECMAScript规范中没有使用EvalError，所以在大多数情况下，您不会遇到这个错误。但是为了向后兼容，仍然存在</em><strong class="jx io"><em class="kw">eval error</em></strong><em class="kw">对象。</em> <a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> MDN字面意思告诉你不要用这个</em> </a> <em class="kw">。</em></p><h2 id="d9f3" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">范围误差</h2><p id="b3bd" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">每当您试图传入不在有效范围内的变量或参数时，都会得到一个RangeError。JavaScript对其所有数据成员都有限制。例如，假设您正在创建一个具有特定长度的数组。您可以为数组设置的最大元素数是2 -1。但是在那之后，它超出了范围，你会得到一个RangeError。如果你试图传入一个负值，它会给你同样的结果。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7f09683f283b0b34df0dc60ca30c7ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*-qeAefq7pL-dYBUDY2MwJA.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">RangeError for Arrays</figcaption></figure><p id="4b5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其他一些常见的RangeError实例可能是，</p><ul class=""><li id="7a20" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">尝试获取浮点数中小数点后的101位(或更多)数字。</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="46a6" class="lb lc in mw b gy na nb l nc nd">1.2345.toFixed(2)   //1.23<br/>1.2345.toFixed(101) //RangeError<br/>1.2345.toFixed(-1)  //RangeError</span></pre><ul class=""><li id="8d98" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">使用<strong class="jx io"> repeat() </strong>重复字符串超过特定范围</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a0c8" class="lb lc in mw b gy na nb l nc nd">"abc".repeat(5)      //abcabcabcabcabc<br/>"abc".repeat(2**28)  //RangeError<br/>"abc".repeat(-1)     //RangeError</span></pre><blockquote class="kt ku kv"><p id="17d4" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在Chrome中，如果你在一个无限循环中递归地运行一些东西，超出了调用栈的限制，你也会得到一个RangeError。在Firefox或Edge的情况下，对于同一问题，您可能会得到不同的错误。</p></blockquote><h2 id="aa45" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated"><strong class="ak">参考错误</strong></h2><p id="8134" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">当你试图访问一个尚未声明的变量时，你会得到一个ReferenceError。对于这种类型的错误，现在有一些注意事项，让我们简单地看一下。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1263" class="lb lc in mw b gy na nb l nc nd">function getName(){<br/>   console.log("My name is " + name)  // "My name is undefined."<br/>}</span><span id="58e3" class="lb lc in mw b gy nj nb l nc nd">getName();<br/>var name = "Jack";</span></pre><p id="e352" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果你按照ReferenceError的定义，我们应该在这里得到一个错误，因为变量在声明之前被访问<strong class="jx io">。但是我们得到了想要的字符串，但是用“<strong class="jx io"> undefined </strong>”代替了名称变量。这是因为<strong class="jx io">吊装</strong>造成的。<a class="ae la" href="https://youtu.be/nnCykighqxI" rel="noopener ugc nofollow" target="_blank">我已经在一个单独的视频中详细介绍了吊装，所以你可以查看一下</a>。<br/>但是基本上发生的是，整个文件首先经过一个<strong class="jx io">创建阶段</strong>，其中所有的变量和函数都被JS引擎分配了一些内存。获取内存时的变量也被<strong class="jx io">赋予占位符值“未定义”</strong>。所以在文件的实际执行过程中，它会有一个未定义的值，因此它不会抛出错误。</strong></p><p id="681a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我对文件做一点小小的改动，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0cd9" class="lb lc in mw b gy na nb l nc nd">function getName(){<br/>   console.log("My name is " + name)  // "My name is undefined."<br/>}</span><span id="e11e" class="lb lc in mw b gy nj nb l nc nd">getName();<br/>let name = "Jack";  //Changed the declaration from var to let</span></pre><p id="18ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变量声明已从<strong class="jx io"> var更改为let。</strong>现在如果我运行这个，我会得到一个变量名的引用错误。这会让你认为使用“<strong class="jx io"> let </strong>声明的变量没有被提升。但事实并非如此。它们也会被提升，但是它们的处理比var声明更严格。只有当一个“let声明”被<strong class="jx io">完全初始化</strong>时，你才能访问它们。所以，任何在let name =" Jack "之前的代码都不能访问name变量。"<strong class="jx io"> const </strong>"声明也类似地工作。</p><p id="2764" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种错误的一些其他常见情况是，</p><ul class=""><li id="0608" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">未定义的变量</li><li id="ea7d" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">无效范围</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="24f4" class="lb lc in mw b gy na nb l nc nd">const sayHello = () =&gt; {<br/>   let name = "John";<br/>   console.log("Hello " + name);<br/>}<br/>sayHello();<br/>console.log(name);  //Reference error since name is inside a                                                    function scope</span></pre><h2 id="84c5" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">类型错误</h2><p id="d83d" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">每当变量/参数不是有效(预期的)类型时，JS引擎都会抛出TypeError。例如，尝试定义一个值为10的变量x。如果你像调用函数一样调用它，你会得到一个类型错误。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/25e1d1e4b68ea3a72484c14627e77636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*ayoLak5BKi7N7iAFJjWG0A.png"/></div></figure><p id="c753" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种情况，加上语法错误，是很常见的。如果您创建的函数的名称已经用于文件中的变量或对象，您也会得到这个错误。其他一些常见的例子有</p><ul class=""><li id="e9af" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">尝试迭代不可迭代的元素(如变量)</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3382" class="lb lc in mw b gy na nb l nc nd">let x = 10;<br/>x.map(val =&gt; return true)  //Error: map() is only for iterables</span></pre><ul class=""><li id="743c" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">尝试编辑只读属性</li><li id="ca9e" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">尝试在非字符串元素上调用类似toUpperCase/toLowerCase的字符串方法。</li><li id="439a" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">试图重新分配常量声明。</li></ul><h2 id="ef25" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">URIError</h2><p id="2375" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">当某个全局URI处理函数(decode URI、endcodeURI、encodeURIComponent、decodeURIComponent)使用不当时，会出现此错误。</p><p id="5b1e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">encodeURI用一个、两个、三个或四个表示字符的UTF-8编码的转义序列替换某些字符的每个实例。所以如果你试图编码一个无效的序列，你会得到这个错误。在解码URI的例子中，如果你传入一个畸形的URI，它会给你这个错误。</p><p id="c412" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我个人从未遇到过与URI相关的错误。所以我假设大多数开发人员都是这种情况，但是如果您正在开发特定的URI编码/解码相关的应用程序，您可能希望深入了解它们。</p><h2 id="7040" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">语法错误</h2><p id="84ea" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">当您编写语法不正确的代码时，就会触发这种类型的错误。无论何时运行一段代码，JavaScript引擎都必须将这段代码转换成机器可以理解的格式。</p><ul class=""><li id="9300" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">它将首先分解您的代码，并从中创建单独的令牌。例如“让x = 10”将被标记化为"<strong class="jx io">让"</strong>，"<strong class="jx io"> x" </strong>，"<strong class="jx io"> =" </strong>，"<strong class="jx io"> 10" </strong>，"<strong class="jx io">"</strong>。</li><li id="a4b6" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">之后，它会将这些标记解析成一个树状结构，称为抽象语法树，这是一个更规范的代码表示。有一个在线工具，叫做<a class="ae la" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>，可以让你查看代码的AST版本。</li></ul><p id="76cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在解析阶段，如果JS引擎发现任何不符合其语法的标记，它将抛出一个SyntaxError。这种错误的例子不胜枚举，但是我们将会看到一些常见的错误</p><ul class=""><li id="e168" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">尝试使用保留的关键字作为标识符</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0b0a" class="lb lc in mw b gy na nb l nc nd">let var = 10; // Error; var is reserved for variable declarations</span></pre><ul class=""><li id="db2c" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">将无效字符串解析为JSON。</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7502" class="lb lc in mw b gy na nb l nc nd">JSON.parse('{foo: 1}'); //Invalid string -&gt; JSON<br/>JSON.parse('{"foo": 1}'); // Valid</span></pre><ul class=""><li id="086c" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">缺少或尾随逗号、括号、圆括号</li><li id="5c51" class="lu lv in jx b jy mf kc mg kg mh kk mi ko mj ks mn mc md me bi translated">不被立即调用的无名函数</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fcab" class="lb lc in mw b gy na nb l nc nd">function () { return 'Hello world';} //invalid<br/>(function () {})(); //valid</span></pre><ul class=""><li id="5301" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">未初始化的常量声明</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="85b0" class="lb lc in mw b gy na nb l nc nd">const VALUE; //Error</span></pre><ul class=""><li id="994e" class="lu lv in jx b jy jz kc kd kg mk kk ml ko mm ks mn mc md me bi translated">将测试相等性的“==”与用于赋值的“=”互换</li></ul><p id="d000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很明显，有很多方法可以犯语法错误。这些错误对象提供的大多数消息都非常简单明了，因此解决它们不是问题。</p><h2 id="6595" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">聚合错误</h2><p id="b2a7" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">AggregateError基本上是包装在单个错误中的一堆错误。因此，每当一个操作报告多个错误时，就会返回这个错误。最好的例子就是当你在一个“Promise.any()”中传递多个承诺时，所有这些承诺都被拒绝。您将获得一个AggregateError，其中实际上是通过数组传递的错误。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d7ae" class="lb lc in mw b gy na nb l nc nd">Promise.any([<br/>  Promise.reject(new Error("Error 1")),<br/>  Promise.reject(new Error("Error 2")),<br/>  Promise.reject(new Error("Error 3"))<br/>]).catch(e =&gt; {<br/>  console.log(e.name);        //"AggregateError"<br/>  console.log(e.errors);      //[ Error: "Error 1", Error: "Error 2", Error : "Error 3"]<br/>});</span></pre><h2 id="2640" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">结论</h2><p id="1ac4" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">这些是一些最常见的本机错误，您可能会经常看到。我希望这有助于您未来的调试工作。如果你认为我可能遗漏了什么，请随意添加到这个列表中。</p><p id="afcf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对这篇文章或其他任何东西有任何问题，你可以把它放在评论中，或者你可以在下面提到的我的社交网站上给我发一个DM。干杯！</p><p id="ecd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae la" href="https://www.linkedin.com/in/akilesh-rao-610357137/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/>T3】TwitterT5<a class="ae la" href="https://github.com/AkileshRao" rel="noopener ugc nofollow" target="_blank">Github</a></p><p id="338c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">更多内容请看</em><a class="ae la" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>