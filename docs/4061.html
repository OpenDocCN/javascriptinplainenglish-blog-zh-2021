<html>
<head>
<title>LeetCode Algorithm Series: Longest Common Prefix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:最长公共前缀</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7?source=collection_archive---------9-----------------------#2021-08-13">https://javascript.plainenglish.io/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7?source=collection_archive---------9-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2711b17efa18f51517433f91256d2bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGwG5AJ4P88K2bNO_upjOQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lucabravo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae jz" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ca36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面这个问题来自Leetcode的<em class="ky">顶级面试问题——轻松</em>下<em class="ky">琴弦</em>章节。</p><p id="69bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">中最大的常用前缀:</strong></p><blockquote class="kz la lb"><p id="4fd7" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">写一个函数在字符串数组中寻找最长的公共前缀字符串。</p><p id="ca6f" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">如果没有公共前缀，则返回空字符串<code class="fe lf lg lh li b">""</code>。</p></blockquote><p id="7c5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a0ed" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> strs = ["flower","flow","flight"]<br/><strong class="li io">Output:</strong> "fl"</span><span id="94a7" class="lr ls in li b gy lx lu l lv lw"><strong class="li io">Input:</strong> strs = ["dog","racecar","car"]<br/><strong class="li io">Output:</strong> ""<br/><strong class="li io">Explanation:</strong> There is no common prefix among the input strings.</span></pre><p id="4390" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下例子，我们想要找到在单词开头的相同的字母序列。如果没有共同点，那么我们返回一个空字符串。</p><p id="14bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，我认为既然所有的单词都必须有相同的前缀，我可以选择任何一个单词，然后将其他单词的字母与我选择的单词进行比较</p><p id="a4c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我决定在这篇文章中以不同的方式展示我的步骤。下面是我的解决方案，我在整个函数中放置了粗体注释来解释我的过程。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="9325" class="lr ls in li b gy lt lu l lv lw">var longestCommonPrefix = function(strs) {<br/>    <strong class="li io">// if array is empty, return a prefix of empty string</strong><br/>    if (strs.length === 0) {return ""}</span><span id="9e97" class="lr ls in li b gy lx lu l lv lw">    <strong class="li io">// if array has 1 word, return the whole word</strong><br/>    if (strs.length === 1) {return strs[0]}<br/>    <br/>    <strong class="li io">// set a variable prefix equal to empty string</strong><br/>    let prefix = ""</span><span id="0e43" class="lr ls in li b gy lx lu l lv lw">    <strong class="li io">// iterate through the letters of the first word</strong><br/>    for (let i = 0; i &lt; strs[0].length; i++) {</span><span id="20f1" class="lr ls in li b gy lx lu l lv lw">    <strong class="li io">// compare those letters to same Index-ed letter of other words</strong><br/>        for (let j = 1; j &lt; strs.length; j++) {</span><span id="0a6c" class="lr ls in li b gy lx lu l lv lw">        <strong class="li io">// if the letters match, continue to next set of letters;             <br/>        // but if the letters don't match, return prefix<br/>        // for the inside for loop (currently an empty string)</strong><br/>            if (strs[j][i] === strs[0][i]) {<br/>                continue<br/>            } else {<br/>                return prefix<br/>            }<br/>        }</span><span id="d21f" class="lr ls in li b gy lx lu l lv lw">    <strong class="li io">// After inside for loop completes OR Breaks because the letters <br/>    // no longer match, the index in the first word will mark where <br/>    // the longest common prefix is, so we add to our empty string</strong><br/>        prefix += strs[0][i]<br/>    }<br/>    <br/>    return prefix<br/>};</span></pre><p id="e3dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为在另一个<strong class="kc io"> for循环中运行一个<strong class="kc io"> for循环</strong>，所以时间复杂度为O(n)。R </strong>在LeetCode上运行这个，运行时间是<strong class="kc io"> 79ms </strong>，只比提交的<strong class="kc io"> 59.52% </strong>好。然而，似乎还有一些其他因素在起作用，因为我的代码与其他提交的代码相似，但速度更快。</p><p id="f426" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我很乐意听到我的代码如何改进，特别是如果它能以比n更好的时间复杂度完成，或者你如何着手解决这个算法。</p><p id="aa1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请关注未来更多的LeetCode解决方案！</p><p id="11bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="kz la lb"><p id="351e" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="8bb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>