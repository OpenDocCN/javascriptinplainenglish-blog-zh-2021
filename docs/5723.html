<html>
<head>
<title>Options for Optimizing Caching in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中优化缓存的选项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/options-for-optimizing-caching-in-react-bc224f70145f?source=collection_archive---------4-----------------------#2021-12-03">https://javascript.plainenglish.io/options-for-optimizing-caching-in-react-bc224f70145f?source=collection_archive---------4-----------------------#2021-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2690ff33de41af5dc99a57d7a061737d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YDN2CHhVQa5x52uj.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://www.toptal.com/" rel="noopener ugc nofollow" target="_blank">https://www.toptal.com/</a></figcaption></figure><p id="ef35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为创建高性能web应用程序最流行的前端库之一，React遵循基于组件的方法，其中每个组件都有自己的状态和逻辑。</p><p id="eba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React面临的最大挑战是避免不必要的渲染，这可能会导致重大的性能问题，尤其是在较大的应用程序中。在本文中，我们将介绍通过不同的缓存方法来优化React应用程序性能的几种不同方法。</p><h1 id="e6c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">记忆反应钩</h1><p id="84f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">记忆化是React本身提供的一个特性。正如我们所知，React每次重新渲染时都会创建新的引用。如果组件有大量的计算，即使输出没有改变，每次重新渲染时都会进行计算。</p><p id="f1d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过避免不必要的负载来保持CPU负载最小，React提供了两个钩子来帮助内存化。钩子遵循一个过程，在这个过程中，结果被缓存在内存中，当我们得到相同的输入时，不需要重新计算就可以返回。在不同输入的情况下，缓存会失效。</p><h1 id="507e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用备忘录()</h1><p id="185c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">useMemo()</code>是React为记忆化提供的一个钩子，它有助于保持提供给它的相同值的缓存值。它跟踪输入并返回先前执行的结果。</p><p id="8b74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子。假设我们必须用以下函数将两个巨大的数字相加:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="49bb" class="mq lc iq mh b gy mr ms l mt mu">const addTwoHugeNumbers=(a,b)=&gt;{<br/>return a+b<br/>}</span></pre><p id="3494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面写的函数在CPU上很重，因此只应在<code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>的值改变时计算。但是，默认情况下，它将在每次重新渲染时运行。</p><p id="9133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">useMemo()</code>，我们可以存储特定值的结果，这意味着函数将不进行计算，我们将直接获得之前计算的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be0c" class="mq lc iq mh b gy mr ms l mt mu">const memoizedValue = useMemo(() =&gt; addTwoHugeNumbers(a, b), [a, b])</span></pre><p id="f6f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该值存储在<code class="fe me mf mg mh b">memoizedValue</code>中。我们已经将依赖数组传递给了<code class="fe me mf mg mh b">useMemo</code>，它告诉我们何时再次运行。在我们的例子中，当其中一个值改变时，它将运行。</p><h1 id="1bac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">UseCallback()</h1><p id="9657" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了<code class="fe me mf mg mh b">useCallback()</code>，我们也获得了记忆的能力，但它以不同的方式工作。<code class="fe me mf mg mh b">useCallback()</code>不记忆该值，而是记忆提供给它的回调函数。我们来看一个小例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6820" class="mq lc iq mh b gy mr ms l mt mu">const increment = (() =&gt; {<br/>  setCount(count + 1);<br/>});</span></pre><p id="f862" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">useCallback()</code>，上面的函数看起来像下面的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de99" class="mq lc iq mh b gy mr ms l mt mu">const increment = useCallback(() =&gt; {<br/>  setCount(count + 1);<br/>}, [count]);</span></pre><p id="1b4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useCallback()</code>将记忆增量功能，仅在给定的依赖关系改变时运行。它不跟踪输入或函数返回的值。</p><h1 id="1082" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">惰性加载反应组件</h1><p id="6295" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React中的延迟加载会在前面呈现必要的组件，而将不重要的组件延迟到后面加载。</p><p id="787f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别是在较大的应用程序中，强烈建议使用这种方法来提高性能。在React中，我们内置了延迟加载组件的选项。</p><p id="4c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经创建了一个名为<code class="fe me mf mg mh b">&lt;/Artists&gt;</code>的组件，我们想让它延迟加载，我们可以这样做:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f76" class="mq lc iq mh b gy mr ms l mt mu">import { lazy } from 'react';</span></pre><p id="dead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们从react导入lazy并如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d02e" class="mq lc iq mh b gy mr ms l mt mu">const Artists = React.lazy(() =&gt; import('./Artists'));</span><span id="7134" class="mq lc iq mh b gy mv ms l mt mu">function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Artists /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="b32c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">useRef()</code></h1><p id="94ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们知道，每当我们在组件中使用<code class="fe me mf mg mh b">useState()</code>时，当状态改变时，它会导致组件中的重新呈现。为了在不导致重新渲染的情况下跟踪状态，React引入了<code class="fe me mf mg mh b">useRef()</code>钩子。</p><p id="a4d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某些情况下，<code class="fe me mf mg mh b">useState()</code>可能不是您应用程序的正确解决方案。<code class="fe me mf mg mh b">useRef()</code>非常适用于我们需要一个不会导致重新呈现并且对组件呈现的可见信息没有贡献的状态的情况。例如，可以使用它来计算渲染次数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a783" class="mq lc iq mh b gy mr ms l mt mu">function App() {<br/>    const [foo, setFoo] = React.useState(false)<br/>    const counter = React.useRef(0)<br/>    console.log(counter.current++)<br/>    return (<br/>      &lt;button onClick={() =&gt; setFoo(f =&gt; !f)} &gt; Click &lt;/button&gt;<br/>     )<br/>}</span><span id="7e93" class="mq lc iq mh b gy mv ms l mt mu">ReactDOM.render(&lt;React.StrictMode&gt;&lt;App /&gt;&lt;/React.StrictMode&gt;, document.getElementById('mydiv'))</span></pre><p id="2176" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个简单的toggler来重新呈现组件。<code class="fe me mf mg mh b">counter</code>是一个保持其值的可变ref。我们可以用<code class="fe me mf mg mh b">useState()</code>做同样的事情，但是它会导致每个切换两次渲染。</p><h1 id="9e6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">冗余缓存选择器</h1><p id="1acf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">选择器只是用来从更大的数据池中选择数据的函数。在React中，选择器被广泛用于从Redux存储中获取值。选择器非常有用和强大，但是它们也有自己的缺点。</p><p id="8b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React Redux中，我们使用了<code class="fe me mf mg mh b">useSelector()</code>钩子来从存储中获取状态。<code class="fe me mf mg mh b">useSelector()</code>的问题是每次组件渲染时它都会运行。<code class="fe me mf mg mh b">useSelector()</code>在某些情况下可能是理想的，但是大多数时候，选择器返回的数据不会改变，这使得计算变得不必要。</p><p id="10c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2495" class="mq lc iq mh b gy mr ms l mt mu">import React, {useEffect,useState} from 'react'<br/>import {useSelector, useDispatch} from 'react-redux'<br/>import {getPosts} from './postActions'</span><span id="5d6d" class="mq lc iq mh b gy mv ms l mt mu">export const List=()=&gt;{<br/>  Const [toggle, setToggle]=useState(false)<br/>  const myPosts=useSelector(state=&gt;state.posts)<br/>  const dispatch=useDispatch()<br/></span><span id="8533" class="mq lc iq mh b gy mv ms l mt mu">  return(<br/>    &lt;div&gt;<br/>    {myPosts.map(post=&gt;&lt;p&gt;{posts}&lt;p/&gt;)}<br/>    &lt;button type="button" onClick={()=&gt;{setToggle(!toggle)}} &gt;Click Me!&lt;/button&gt;<br/>    &lt;div/&gt;<br/>  )<br/>}</span></pre><p id="0813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们更改了切换状态，每次我们这样做时，组件都会呈现出来。虽然我们的Redux商店中的帖子没有变化，但是<code class="fe me mf mg mh b">useSelector()</code>钩子也将运行。</p><p id="b7c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们将缓存选择器函数的结果。尽管没有内置的React解决方案，但我们有许多第三方库，允许我们创建缓存选择器。让我们使用Reselect，这是著名的缓存选择器的解决方案。</p><h1 id="ae1c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重新选</h1><p id="b9f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Reselect是一个用于创建记忆选择器的流行库。您可以使用以下命令将它安装到您的项目中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4938" class="mq lc iq mh b gy mr ms l mt mu">yarn add reselect</span></pre><p id="cc47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用重选:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74ee" class="mq lc iq mh b gy mr ms l mt mu">import { createSelector } from 'reselect' <br/>import React, {useEffect,useState} from 'react'<br/>import {useSelector, useDispatch} from 'react-redux'<br/>import {getPosts} from './postActions'</span><span id="c17d" class="mq lc iq mh b gy mv ms l mt mu">export const List=()=&gt;{<br/>  Const [toggle, setToggle]=useState(false)<br/>  const myPosts = createSelector(state=&gt;state.posts)<br/>  const dispatch=useDispatch()<br/></span><span id="9472" class="mq lc iq mh b gy mv ms l mt mu">  return(<br/>  &lt;div&gt;<br/>  {myPosts.map(post=&gt;&lt;p&gt;{posts}&lt;p/&gt;)}<br/>  &lt;button type="button" onClick={()=&gt;{setToggle(!toggle)}} &gt;Click Me!&lt;/button&gt;<br/>  &lt;div/&gt;<br/>  )<br/>}</span></pre><p id="77f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们从Reselect导入了<code class="fe me mf mg mh b">createSelector</code>，它接受一个选择器并返回它的一个记忆版本。有了记忆化版本，组件将不会计算选择器的值，即使在数千次重新渲染之后，除非<code class="fe me mf mg mh b">postReducer</code>的值改变。Reselect的<code class="fe me mf mg mh b">createSelector</code>被证明是解决大型应用中<a class="ae kc" href="https://blog.logrocket.com/react-re-reselect-better-memoization-cache-management/" rel="noopener ugc nofollow" target="_blank">性能问题的优秀解决方案。</a></p><h1 id="622d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用React查询优化API调用</h1><p id="167b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React以自己的方式处理异步操作，这对开发人员来说有时是个问题。异步操作的通常模式是在<code class="fe me mf mg mh b">useEffect</code>钩子中获取服务器数据，该钩子在每次渲染时运行并每次获取新数据，即使服务器上没有新数据。</p><p id="d049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，React Query缓存数据并在进行调用之前首先返回，但如果服务器返回的新数据与之前的数据相同，React Query不会重新呈现组件。我们可以如下使用React查询:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="49bc" class="mq lc iq mh b gy mr ms l mt mu">import React from 'react'<br/>import {useQuery} from 'react-query'<br/>import axios from 'axios'</span><span id="7056" class="mq lc iq mh b gy mv ms l mt mu">async function fetchPosts(){<br/>    const {data} = await axios.get('https://jsonplaceholder.typicode.com/posts')    <br/>    return data<br/>}</span><span id="a492" class="mq lc iq mh b gy mv ms l mt mu">function Posts(){<br/>    const {data, error, isError, isLoading } = useQuery('posts', fetchPosts) <br/>    // first argument is a string to cache and track the query result<br/>    if(isLoading){<br/>        return &lt;div&gt;Loading...&lt;/div&gt;<br/>    }<br/>    if(isError){<br/>        return &lt;div&gt;Error! {error.message}&lt;/div&gt;<br/>    }</span><span id="a51f" class="mq lc iq mh b gy mv ms l mt mu">    return(<br/>        &lt;div className='container'&gt;<br/>        &lt;h1&gt;Posts&lt;/h1&gt;<br/>        {<br/>            data.map((post, index) =&gt; {<br/>                return &lt;li key={index}&gt;{post.title}&lt;/li&gt;<br/>            })<br/>        }</span><span id="dabb" class="mq lc iq mh b gy mv ms l mt mu">        &lt;/div&gt;<br/>    )<br/>}</span><span id="e093" class="mq lc iq mh b gy mv ms l mt mu">export default Posts</span></pre><h1 id="6821" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应碎片</h1><p id="1fba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您是React开发人员，您可能会遇到一个错误，要求用父div包装组件。如果组件中不需要额外的div，那么添加它就没有意义。例如，如果React应用程序中有1000个组件，那么就会有1000个额外的div，这对DOM来说是很大的负担。为了避免这种情况，React为您提供了使用片段的选项:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ef89" class="mq lc iq mh b gy mr ms l mt mu">const Message = () =&gt; {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;p&gt;Hello&lt;p/&gt;<br/>      &lt;p&gt;I have message for you&lt;p/&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span></pre><p id="bd43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码片段与上面的代码完全相同，使用<code class="fe me mf mg mh b">&lt;&gt;</code>作为<code class="fe me mf mg mh b">React.Fragment</code>的快捷方式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eeb4" class="mq lc iq mh b gy mr ms l mt mu">const Message = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;Hello&lt;p/&gt;<br/>      &lt;p&gt;I have message for you&lt;p/&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="848e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论使用哪种方法，都可以避免添加额外的<code class="fe me mf mg mh b">&lt;div&gt;</code>，从而减少DOM标记，提高渲染性能，并减少内存开销。</p><h1 id="abb1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应虚拟列表</h1><p id="de66" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">经常，我们需要在浏览器上呈现大的列表；对于浏览器来说，这样做的工作量很大，因为它必须创建新的节点，并将它们都绘制在屏幕上。</p><p id="6b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使React中的过程高效，我们可以选择使用虚拟列表。<a class="ae kc" href="https://blog.logrocket.com/react-hooks-infinite-scroll-advanced-tutorial/" rel="noopener ugc nofollow" target="_blank">虚拟列表根据需要仅呈现少量项目</a>，当用户动态滚动项目时简单地替换它们。</p><p id="0d85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">呈现比更改DOM更快，因此您可以使用虚拟列表快速呈现数千个列表项。<a class="ae kc" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank"> React-virtualized </a>是一个优秀的库，拥有用于呈现虚拟列表的组件。</p><h1 id="d735" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能组件</h1><p id="1bba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React从基类组件开始，但是，现在推荐使用功能组件，因为它们的轻量级性质。功能组件基本上是创建速度更快的功能，它们更容易缩小，从而减小了包的大小。</p><h1 id="c5e9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2da9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本教程中，我们讨论了在React应用程序中优化缓存管理的几种不同的解决方案，如记忆、缓存选择器、延迟加载、React片段、虚拟列表和功能组件。这些方法中的每一种都可以通过减少不必要的组件渲染数量、减少开销和提高速度来改进您的应用程序。</p><p id="ef4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确的解决方案将取决于您个人项目的需求，但希望本文能帮助您了解可用的选项。</p><p id="a2d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em> <strong class="kf ir"> <em class="mw"> </em> </strong> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">说白了. io </em> </strong> </a> <strong class="kf ir"> <em class="mw">。</em> </strong> <em class="mw">报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="mw">免费每周简讯点击这里</em> </strong> </a> <strong class="kf ir"> <em class="mw">。</em> </strong></p></div></div>    
</body>
</html>