<html>
<head>
<title>How to Detect a Click Outside of a React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测React组件外部的点击</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/detect-a-click-outside-of-a-react-component-with-a-reusable-hook-and-useref-a0c282171c3f?source=collection_archive---------4-----------------------#2021-03-22">https://javascript.plainenglish.io/detect-a-click-outside-of-a-react-component-with-a-reusable-hook-and-useref-a0c282171c3f?source=collection_archive---------4-----------------------#2021-03-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e8ef" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用可重复使用的钩子和useRef</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/49413dc4d622d423b2945ef0f04f2efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6a80B8kFhKGGkkkuLvAlg.png"/></div></div></figure><p id="56b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">检测React组件外部的单击对于关闭下拉框、模式和对话框非常有用。一个常见的模式是，在这些组件的主体外部单击会关闭它们:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/4bb34a15a0303b352c24a563a39763b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VKH4NbRW12coreanV5I5XQ.gif"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Clicking outside of this dropdown menu closes it</figcaption></figure><p id="2c4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我从栈溢出上的<a class="ae lp" href="https://stackoverflow.com/users/1212039/ben-bud" rel="noopener ugc nofollow" target="_blank"> Ben Bud得到了这个钩子中的主函数。我并不声称自己发明了这种代码——我修改了它，但这个概念的所有功劳都归于他的帖子。</a></p><p id="7bf8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是钩子:<strong class="kq io"> useDetectClickOut.js </strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="391d" class="lv lw in lr b gy lx ly l lz ma">import { useEffect, useRef, useState } from 'react';</span><span id="3e5d" class="lv lw in lr b gy mb ly l lz ma">export default function useDetectClickOut(initState) {<br/>   const triggerRef = useRef(null); // optional<br/>   const nodeRef = useRef(null); // required <br/>   <br/>   const [show, setShow] = useState(initState);</span><span id="854c" class="lv lw in lr b gy mb ly l lz ma">const handleClickOutside = event =&gt; {<br/>     //if click is on trigger element, toggle modal<br/>     if(triggerRef.current &amp;&amp; <br/>        triggerRef.current.contains(event.target)) {<br/>        return setShow(!show);<br/>       }<br/>    <br/>    //if modal is open and click is outside modal, close it<br/>    if(nodeRef.current &amp;&amp; <br/>      !nodeRef.current.contains(event.target)) {<br/>        return setShow(false);<br/>      }<br/>   };</span><span id="29f0" class="lv lw in lr b gy mb ly l lz ma">useEffect(() =&gt; {<br/>     document.addEventListener("click", handleClickOutside, true);<br/>     return () =&gt; {<br/>     document.removeEventListener("click", handleClickOutside, true);<br/>    };<br/>   });</span><span id="5c1d" class="lv lw in lr b gy mb ly l lz ma">return {<br/>   triggerRef,<br/>   nodeRef,<br/>   show,<br/>   setShow<br/>   }<br/> }</span></pre><p id="49d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Ref设置在我们打开的任何东西上——工具条、菜单、对话框等等。</p><p id="d720" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> triggerRef </strong>是<strong class="kq io"> </strong>设置在任何触发<strong class="kq io"> nodeRef </strong>的事件上。例如，如果nodeRef是一个下拉菜单，那么triggerRef就是切换菜单打开和关闭的按钮。</p><p id="1a15" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> triggerRef </strong>是可选的——有时组件不会被终端用户可用的元素触发，比如警告用户其订阅将在一天后到期的对话框。但是对于有最终用户触发器的组件来说，这是必要的。否则，单击triggerRef将注册为外部单击，这将自动关闭nodeRef，而有时triggerRef应该打开nodeRef。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/5b671da1a527cedc5007639dd35574f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FanBFBZ0JxoCKvd6NhIXag.png"/></div></div></figure><p id="33fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">手柄点击外部</strong>设置和移除<strong class="kq io">使用效果</strong>。useEffect的<a class="ae lp" href="https://dev.to/otamnitram/react-useeffect-cleanup-how-and-when-to-use-it-2hbm" rel="noopener ugc nofollow" target="_blank">清理函数</a>在组件未渲染时移除事件监听器。同时，在呈现组件时，在文档(整个窗口)上设置一个事件侦听器来侦听单击。</p><p id="73b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">单击时，会检查两个条件:</p><ol class=""><li id="24fd" class="md me in kq b kr ks ku kv kx mf lb mg lf mh lj mi mj mk ml bi translated">如果triggerRef被呈现并且被点击。如果两个条件都成立，<code class="fe mm mn mo lr b">show</code>应该设置为它的对立面。这使得triggerRef作为一个开关工作。</li><li id="5038" class="md me in kq b kr mp ku mq kx mr lb ms lf mt lj mi mj mk ml bi translated">如果nodeRef被呈现(<code class="fe mm mn mo lr b">ref.current</code>)，并且如果Ref不包含被点击的元素(<code class="fe mm mn mo lr b">event.target</code>)。如果满足这些条件，则点击必须在ref之外，并且<code class="fe mm mn mo lr b">setShow(false)</code>被设置。</li></ol><p id="ec74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是钩子的全部内容。这是它在组件中的使用方式:</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="4190" class="lv lw in lr b gy lx ly l lz ma">import React from 'react';<br/>import useDetectClickOut from '../../hooks/useDetectClickOut';<br/>import IconButton from '../raw/IconButton';<br/>import { DrawerTest } from '../../components/DrawerTest';<br/>import { VscEllipsis } from 'react-icons/vsc';</span><span id="1e7a" class="lv lw in lr b gy mb ly l lz ma">const Dropdown = () =&gt; {</span><span id="4e4f" class="lv lw in lr b gy mb ly l lz ma">const { show, nodeRef, triggerRef } = useDetectClickOut(false);</span><span id="a143" class="lv lw in lr b gy mb ly l lz ma">return(<br/>    &lt;&gt;<br/>   &lt;div ref={triggerRef}&gt;<br/>      &lt;IconButton icon={&lt;VscEllipsis/&gt;} inline/&gt;<br/>   &lt;/div&gt;<br/>   {show &amp;&amp; &lt;Drawer nodeRef={nodeRef}&gt;<br/>      &lt;li&gt;{"oats"}&lt;/li&gt;<br/>      &lt;li&gt;{"oat milk"}&lt;/li&gt;<br/>      &lt;li&gt;{"oatmeal"}&lt;/li&gt;  <br/>      &lt;li&gt;{"oat bran"}&lt;/li&gt;    <br/>    })}<br/>    }<br/>   &lt;/&gt; <br/>)}</span><span id="8eaa" class="lv lw in lr b gy mb ly l lz ma">export default Dropdown;</span></pre><p id="134f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，只有当<code class="fe mm mn mo lr b">show</code>为真时，抽屉才会被调用。这使得钩子可以打开和关闭它。</p><p id="f5f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为抽屉从它的父级Dropdown被传递了一个ref，所以它必须用一个<code class="fe mm mn mo lr b">forwardRef</code>来呈现。更多关于forwardRefs的细节<a class="ae lp" href="https://medium.com/javascript-in-plain-english/using-forwardref-with-react-hooks-9d0d096ad810" rel="noopener">在这里</a>，但这是我使用<code class="fe mm mn mo lr b">forwardRef</code>的超级简单的抽屉组件示例</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="9032" class="lv lw in lr b gy lx ly l lz ma">import React, { forwardRef } from 'react';</span><span id="2d71" class="lv lw in lr b gy mb ly l lz ma">const Drawer = forwardRef((props, ref) =&gt; {<br/>   return (<br/>     &lt;menu className="dropdown" ref={ref}&gt;<br/>       {props.children}<br/>     &lt;/menu&gt;<br/>    );<br/>  });</span><span id="21bb" class="lv lw in lr b gy mb ly l lz ma">export default Drawer;</span></pre><p id="4684" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下拉列表的例子只是<strong class="kq io"> useDetectClickOut </strong>钩子的一个实现。它可以重复用于同一应用程序中的多个其他组件。</p></div></div>    
</body>
</html>