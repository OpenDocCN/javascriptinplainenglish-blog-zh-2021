<html>
<head>
<title>TypeScript Intersection Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript交集最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-intersection-best-practice-6a7de85bb2f1?source=collection_archive---------11-----------------------#2021-03-17">https://javascript.plainenglish.io/typescript-intersection-best-practice-6a7de85bb2f1?source=collection_archive---------11-----------------------#2021-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d0e5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用TypeScript找到交集的8种方法</h2></div><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="6d6d" class="kl km in kh b gy kn ko l kp kq">Table of Contents</span><span id="0ac9" class="kl km in kh b gy kr ko l kp kq">* What's Intersection<br/>* Step-by-Step to the best practice<br/>    * First step: using for-loop<br/>    * How to reduce space complexity - Array.filter()<br/>    * Stops when we find the value — Array.find()<br/>* Performance<br/>* TL; DR<br/>* References</span></pre><h1 id="52ac" class="ks km in bd kt ku kv kw kx ky kz la lb jt lc ju ld jw le jx lf jz lg ka lh li bi translated"><strong class="ak">什么是交集？</strong></h1><p id="e1d5" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">假设我们有两个阵列:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="14c7" class="kl km in kh b gy kn ko l kp kq">let arr1: number[] = [1, 2, 3, 4, 5];<br/>let arr2: number[] = [3, 4, 5, 6, 7];</span></pre><p id="db15" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">如果我们想找出这两个数组的交集是什么，也就是:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="4057" class="kl km in kh b gy kn ko l kp kq">[3, 4, 5] # which is both in arr1 and arr2</span></pre><p id="5c7c" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">我们通常对2个数组进行for循环并比较值，这需要O(n)的时间复杂度，但Array中有很多内置函数，如Array.includes()、Array.indexOf()，那么找到交集的最好方法是什么呢？让我们为此做些实验……</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="aa79" class="ks km in bd kt ku ms kw kx ky mt la lb jt mu ju ld jw mv jx lf jz mw ka lh li bi translated">最佳实践</h1><h2 id="24f8" class="kl km in bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">第一步:使用for循环</h2><p id="4f46" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">一种直观的方法是使用for-loop，迭代一个数组并与另一个进行比较:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="55a1" class="kl km in kh b gy kn ko l kp kq">function func(arr1: number[], arr2: number[]): number[] {<br/>  let res: number[] = [];<br/>  for (let i = 0; i &lt; arr1.length; ++i) {<br/>    for (let j = 0; j &lt; arr2.length; ++j) {<br/>      if (arr1[i] === arr2[j]) {<br/>        res.push(arr1[i]);<br/>      }<br/>    }<br/>  }<br/>  return Array.from(new Set(res));<br/>}</span></pre><h2 id="c4d2" class="kl km in bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">如何降低空间复杂度— Array.filter()</h2><p id="1f55" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">虽然for-loop很容易编写，但我们需要一个额外的数组来存储值，在本例中是O(n + m ),因此，我们可以使用一个过滤器来修改一个数组:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="c241" class="kl km in kh b gy kn ko l kp kq">function func(arr1: number[], arr2: number[]): number[] {<br/>  return arr1.filter((val1) =&gt; {<br/>    for (let val2 of arr2) {<br/>      if (val1 === val2) {<br/>        return true;<br/>      }<br/>    }<br/>    return false;<br/>  });<br/>}</span></pre><blockquote class="ni nj nk"><p id="96de" class="lj lk nl ll b lm mf jo lo lp mg jr lr nm mh lu lv nn mi ly lz no mj mc md me ig bi translated">注意:Array.filter()的时间复杂度是O(n)，因为它将循环数组中的所有元素。</p></blockquote><h2 id="b00e" class="kl km in bd kt mx my dn kx mz na dp lb ls nb nc ld lw nd ne lf ma nf ng lh nh bi translated">当我们找到值— Array.find()时停止</h2><p id="4330" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">考虑上面的代码:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="cc0f" class="kl km in kh b gy kn ko l kp kq">if (val1 === val2) {<br/>    return true;<br/>}</span></pre><p id="889e" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">一旦我们找到了两个数组中都存在的值，我们就可以跳出for循环，在这种情况下，我们使用Array.find()来缩短代码:)</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="e404" class="kl km in kh b gy kn ko l kp kq">function func(arr1: number[], arr2: number[]): number[] {<br/>  return arr1.filter((val1) =&gt; {<br/>    return arr2.find((val2) =&gt; val1 === val2);<br/>  });<br/>}</span></pre><blockquote class="ni nj nk"><p id="4e88" class="lj lk nl ll b lm mf jo lo lp mg jr lr nm mh lu lv nn mi ly lz no mj mc md me ig bi translated">注意:Array.find()也是一个O(n)函数，但是优点是一旦它找到一个元素匹配请求的值，它就会跳出循环。</p></blockquote><h1 id="ad1f" class="ks km in bd kt ku kv kw kx ky kz la lb jt lc ju ld jw le jx lf jz lg ka lh li bi translated">表演</h1><p id="aa76" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">因此，在用3种方法实现了检索交集的函数之后，您可能会注意到for-loop的最小值是2，因此您有很多方法可以做到这一点，例如:</p><ul class=""><li id="9183" class="np nq in ll b lm mf lp mg ls nr lw ns ma nt me nu nv nw nx bi translated">for循环+ for循环</li><li id="b682" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">for-loop(使用“of”)+for-loop(使用“of”)</li><li id="6e5c" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">for-loop + Array.indexOf()</li><li id="8ef5" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">Array.filter() + for循环</li><li id="476f" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">Array.filter() + Array.find()</li><li id="c4aa" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi">……</li></ul><p id="004d" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">求交集的方法太多了，我们来对比一下执行时间，看看性能。</p><figure class="kc kd ke kf gt oe gh gi paragraph-image"><div class="gh gi od"><img src="../Images/878f11e92217e38e1e462d417e8af330.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*_w1NXH00OsmdnKxuBzSLqA.png"/></div></figure><p id="fa61" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">所以在这个测试中，我们有8个组合:</p><p id="fa25" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">主要有两种:</p><ul class=""><li id="e029" class="np nq in ll b lm mf lp mg ls nr lw ns ma nt me nu nv nw nx bi translated">for循环:需要额外的空间</li><li id="831d" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">过滤器:没有额外空间</li></ul><p id="6d17" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">这是在两种情况下执行100次的平均时间:</p><ul class=""><li id="286a" class="np nq in ll b lm mf lp mg ls nr lw ns ma nt me nu nv nw nx bi translated">分类或不存储</li><li id="7011" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">大小— 100或10000</li></ul><figure class="kc kd ke kf gt oe gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/a59fd44e8ba7d7d4546aee2c9104b31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qkqvwGrUVLpen5TBB1VUg.png"/></div></div></figure><p id="6e09" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">桌子的洞察力:</p><ul class=""><li id="e4c5" class="np nq in ll b lm mf lp mg ls nr lw ns ma nt me nu nv nw nx bi translated">如果数组很大(例如~10000个元素)，使用<code class="fe om on oo kh b">Array.filter()</code>和<code class="fe om on oo kh b">Array.find()</code>。</li><li id="a09e" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">如果数组很小(例如~100个元素)，使用<code class="fe om on oo kh b">Array.filter()</code>和<code class="fe om on oo kh b">Array.indexOf()</code>。</li><li id="a084" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated"><code class="fe om on oo kh b">sorted</code>阵列比未排序的要好。</li></ul><p id="07d0" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">如果你想自己玩，这里有<strong class="ll io"/><a class="ae mk" href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABFApgZygYQIZpQQQCdDsBPAcRTBRKjkIAo0YAvFALkTBAFsAjGgBpEaelE584cADYpsSALyJg2aXmEkwAEzg8JU2fMRKValMLTYeKAPydu-GgEpOAbQcDCrgLrCPNH29EAG8AKFDESMRZKERsYgBGe15PH2NEIhJSJlYUJwBuCKiYuOIAJmTHLyClTLIctgKiyOblekQGEph0gAZ8xG6AHhFc-oBqMZgnENao0sIE1xgaxE0dHkQbRABZbCgACwA6QjhwLQZdg+P5dYZpgCoRxsROGEK5ufjCMqWVtd1Njs9kcTmcLsDrtpdHdEI9mM9XogxkCrqDtA0UIgAPSIMpNOYAX3CcxgwA6-w2ADJKYgAIS0yzWaZhD5RYDtTooWLdJR9AaIYbwlD9bpjJSMvIzVmsr4-ZbpL6LZbvaVEwnEqKK9J1UiHYAnHgMagAd0QAGUuQxFU58ZrytriGQ9QajShTRaoFbyjbCq1SR1RIQoMzZnaFgrEodA56rcI+NMFAA+OKIAC0iHjKpl9qUsqjYgYsYzCeT2DTxaziCJrUIXJAhCQrkVwll3kK1dAkFgCAGYFQhDw0HgYEo1Fo9AA+gkvQtKqlfPMKlwUgFvC5l1U0izilzVug56v0j5K+zCB0ur0RQL5glDrIwABzA7jSYh6VtM+c2IAK0viF-wx5veT77C+35vu+UT+jOSo1AoublK435rlKkGsrWaCHAADiAaD7DBvy2mhaqqq0JGRLWUD1kgOrOtCJrmpaGE+qEHbgEOPYwH2NCDt2I5UDQeyTmUMEHtULblGJPjrv41SoZEJQYVJKzHq0p7nruABuqgJIgcBkta8kfOpX6INp0hlHpBnekZ77QeZunwUo5l4rZaF7phOF4QwDlEZB5EfAFAWUdRGSOrq+r0W6jGesxTRsV2w69v2vHDqOgl0IQE4AMyiRu84Sd8ykySucnbgpu5Kflh5KKpakche+k3hBrLQXmwBcecLnGMm3VOQMNpueh6DYbh+FTJW6pTVEIUNh57bhJ2HFIFxKUoMt6XjllAAseWyT4hVLvta7KUZin7tVcm1W2GqRCZjXWQsLUfG15SHJ1KAAB4APLAAwUx0vBaYJM974YaN3kTaGkRBTWdZzRhC2hEtfHJTx618ZtQlZQArHtpUHYuxWneVe5UXNip6jA0j9j5Ok9UNH4abE3VNbKoPSvZ9P9S5HNobNSBQIQIDCtDgViwFcwC8oqh4JWBLxYt7Go6t6MbQJW0TgAbPjm4LrKxOXVucPk0glMdTTNB09IjnJqTUvw2bb0deifW9dzQO8-LivI8rSWqwOGNpRr2MTgA7LrBVE0bJ0x0Z0vm9TtMOQz9szY7i7vdoX2-dbIOA0oqYJN7SMo-73GB+rY6hwAHJHq6HYbx3xxnieW4wKdJozCdvaI1jW5ZXed57qh4iXrFK4lPZYTQp48PIEAoAAKugnqwNYaBicIS2cAAYn7CCFUkMeNzHz0lHQUCqNsaCXvVn4XryV7DOv6AvgDacVbEsRKDPhBzwvFAhwwBwGNHcSaO5YgTnSEtGCh0-JzEvtfW+YpEB-wAZAIBICwHTHTFAeWrQIAIFELIO8cAHwMAAAYABJghLWAVYFABJOC0IYEg6QN9sTIBgBvJwhw6C7xgJ9FA5wa5OAJIgHgaBKE+zLj2VAGB8APgfLWB8exhwMDRFoTel0j7KVPsdZ66D6Dz0wSvDAmjTjaDQMIAOqUEBY0ylOI+8DKzGMIKYxe5jYpWO0bYiu9j+LVycWUFxi4-LuM8cvVelizg2LRpXTGIcnHZTCezNxs8TGAO8bE6x-i1pVwypObaaTvQZP-lksxMStHxLsUHBxyTJw41Kd8CJmSPHZOqb42pAT6lBKKVlLWLSx6tEiZ0ixNT8lqyScEycYdhltIqR0qpEzulTMScHWZWUa4LKRkQsAJCgHSHIVQ8AoghYiMQAkHoPQZGFBKE2RIh0VgKKwLgAg4VHH0AYNcno29ZbmGQMLQF20ehNFeUolRKA1F8R+Tc3Z4R9mHLIRQyhZy4AXK0Fcm5Ny7mhEeQsZ56RXk4DwDqL5jBfnwplmYYQQsRbCBrjc8Fq9IWqPUQgOFfybyuNCEAA" rel="noopener ugc nofollow" target="_blank"><strong class="ll io">打字游戏场</strong> </a> <strong class="ll io">的链接。</strong></p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="c455" class="ks km in bd kt ku ms kw kx ky mt la lb jt mu ju ld jw mv jx lf jz mw ka lh li bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="542c" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">如果您想找到两个<code class="fe om on oo kh b">number</code>数组之间的交集:</p><ul class=""><li id="75f5" class="np nq in ll b lm mf lp mg ls nr lw ns ma nt me nu nv nw nx bi translated">如果数组很大(例如~10000个元素)，使用<code class="fe om on oo kh b">Array.filter()</code>和<code class="fe om on oo kh b">Array.find()</code>。</li><li id="6765" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated">如果数组很小(例如~100个元素)，使用<code class="fe om on oo kh b">Array.filter()</code>和<code class="fe om on oo kh b">Array.indexOf()</code>。</li><li id="b968" class="np nq in ll b lm ny lp nz ls oa lw ob ma oc me nu nv nw nx bi translated"><code class="fe om on oo kh b">sorted</code>数组比未排序的要好。</li></ul><p id="b97e" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated">这里的例子:</p><pre class="kc kd ke kf gt kg kh ki kj aw kk bi"><span id="bdee" class="kl km in kh b gy kn ko l kp kq">function func(arr1: number[], arr2: number[]): number[] {<br/>  return arr1.filter((val1) =&gt; {<br/>    return arr2.find((val2) =&gt; val1 === val2);<br/>  });<br/>}</span></pre></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="1037" class="ks km in bd kt ku ms kw kx ky mt la lb jt mu ju ld jw mv jx lf jz mw ka lh li bi translated">参考</h1><p id="d440" class="pw-post-body-paragraph lj lk in ll b lm ln jo lo lp lq jr lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">[1]<a class="ae mk" href="https://stackoverflow.com/questions/1885557/simplest-code-for-array-intersection-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中最简单的数组交集代码</a></p><p id="044b" class="pw-post-body-paragraph lj lk in ll b lm mf jo lo lp mg jr lr ls mh lu lv lw mi ly lz ma mj mc md me ig bi translated"><a class="ae mk" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#the-array-type" rel="noopener ugc nofollow" target="_blank"> [2]打字稿文档</a></p></div></div>    
</body>
</html>