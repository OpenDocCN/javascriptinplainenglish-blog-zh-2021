<html>
<head>
<title>Reverse a Stack using a Queue in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用队列反转堆栈</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reversing-a-stack-using-a-queue-in-javascript-2fb5075fda97?source=collection_archive---------5-----------------------#2021-04-10">https://javascript.plainenglish.io/reversing-a-stack-using-a-queue-in-javascript-2fb5075fda97?source=collection_archive---------5-----------------------#2021-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/104947f2c87790f40a67f94ec05c9d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFBP1-l_syxoDntRR7DTlg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@prrbnt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pierre Binet</a> on <a class="ae jz" href="https://unsplash.com/s/photos/reverse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6245" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将学习如何使用JavaScript中的队列来反转堆栈。首先，我们需要理解什么是栈和队列。</p><blockquote class="kz la lb"><p id="e089" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">注意:如果您已经了解堆栈和队列，您可以跳过本文的“什么是堆栈”和“什么是队列”部分，阅读“反转堆栈概述”部分。</p></blockquote></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="dc02" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是堆栈？</h1><p id="fab2" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">堆栈是一种线性数据结构，它遵循操作执行的特定顺序。顺序是<em class="ky">后进先出</em>(后进先出)。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/f2c1805970eaf1dc7dc7fbb8918338f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*49ID7tKscyiFoMh7.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A simple visualization of a stack</figcaption></figure><p id="4f8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">栈使用<code class="fe mu mv mw mx b">push()</code>和<code class="fe mu mv mw mx b">pop()</code>分别用于<em class="ky">添加</em>和<em class="ky">删除</em>元素。一个栈可以有任意多的元素，但是添加和移除元素的方式仍然是LIFO。不能对堆栈底部/之间的元素进行操作。</p><h2 id="f666" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">实现堆栈</h2><p id="5ada" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">为了实现堆栈，我们将使用基于类的方法。堆栈中将使用以下方法。</p><ol class=""><li id="a1bf" class="nk nl in kc b kd ke kh ki kl nm kp nn kt no kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">push()</code> —将元素添加到堆栈中。</li><li id="651a" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">pop()</code> —移除并返回栈顶元素。</li><li id="dc25" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">isEmpty()</code> —根据堆栈是否为空返回真或假。</li></ol><h2 id="7d7a" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">让我们为栈写代码吧！</h2><p id="ea7b" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">首先，让我们用一个构造函数创建一个类<code class="fe mu mv mw mx b">Stack</code>，该构造函数初始化一个名为elements的数组，该数组将存储元素。</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="ee6a" class="my ln in mx b gy oc od l oe of">class Stack { <br/>    constructor(){  <br/>        this.elements = []; <br/>    }<br/>}</span></pre><p id="05a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们添加所有的方法。</p><h2 id="ded9" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">推送方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="3032" class="my ln in mx b gy oc od l oe of">push(element){ <br/>    this.elements.push(element);<br/>}</span></pre><h2 id="5f05" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">pop方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="9cee" class="my ln in mx b gy oc od l oe of">pop(){ <br/>    if(this.isEmpty()) return "Underflow situation"; <br/>    else return this.elements.pop();<br/>}</span></pre><h2 id="9c10" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">isEmpty方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="549e" class="my ln in mx b gy oc od l oe of">isEmpty(){<br/>    return this.elements.length == 0;<br/>}</span></pre></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="6473" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是队列？</h1><p id="5670" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">队列是一种线性数据结构，它遵循访问元素的顺序。它非常类似于堆栈，但唯一的区别是队列两端都是开放的。一端用于<em class="ky">添加</em>元件，另一端用于<em class="ky">移除</em>元件。添加和删除元素的技术术语分别叫做<strong class="kc io"> <em class="ky">入队</em> </strong>和<strong class="kc io"> <em class="ky">出列，</em> </strong>。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/bc97be80861f9940fcb3b0ec54b736aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G5Zn-JobSOBArSsM.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A simple illustration of the queue data structure.</figcaption></figure><p id="c1ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">队列令人兴奋的部分是我们不能对队列中的每个元素进行操作。只有队列的前端和后端可以被访问或操作。</p><h2 id="1985" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">实现队列</h2><p id="7f7d" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">为了实现队列，我们将使用基于类的方法。队列中将使用以下方法。</p><ol class=""><li id="159a" class="nk nl in kc b kd ke kh ki kl nm kp nn kt no kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">enqueue()</code> —将元素添加到队列中。</li><li id="bd31" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">dequeue()</code> —删除并返回队列中输入的第一个项目。</li><li id="fc8b" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated"><code class="fe mu mv mw mx b">isEmpty()</code> —根据队列是否为空返回真或假。</li></ol><h2 id="f025" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">让我们为队列编写代码吧！</h2><p id="23a0" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">首先，让我们创建一个带有构造函数的类<code class="fe mu mv mw mx b">Queue</code>，该构造函数初始化一个名为elements的数组，该数组将存储元素。</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="f577" class="my ln in mx b gy oc od l oe of">class Queue { <br/>    constructor(){  <br/>        this.elements = []; <br/>    }<br/>}</span></pre><p id="49a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们添加所有的方法。</p><h2 id="b0c2" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">入队方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="0367" class="my ln in mx b gy oc od l oe of">enqueue(element){ <br/>    this.elements.push(element) <br/>}</span></pre><h2 id="2e66" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">出队方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="c609" class="my ln in mx b gy oc od l oe of">dequeue() {<br/>    if(!this.isEmpty()) {<br/>          return this.elements.shift();<br/>    } else {<br/>          return 'Underflow situation';<br/>    }<br/>}</span></pre><h2 id="3bec" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">isEmpty方法:</h2><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="97f1" class="my ln in mx b gy oc od l oe of">isEmpty() {<br/>    return this.elements.length == 0;<br/>}</span></pre></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="eec4" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">反转堆栈概述</h1><p id="b171" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">先说栈的反转！</p><p id="8c12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，栈的元素被弹出并放入队列。接下来，队列的元素逐个出队，并被推送到堆栈上。因为堆栈遵循后进先出(LIFO)，队列遵循先进先出(FIFO)，所以堆栈的顶部元素出现在队列的前面。当我们将队列出队时，前面的元素被推到堆栈上，因此创建了一个反向堆栈。</p><h2 id="f05d" class="my ln in bd lo mz na dn ls nb nc dp lw kl nd ne ma kp nf ng me kt nh ni mi nj bi translated">可视化堆栈的反转</h2><p id="146e" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们举个例子。我们用堆栈<code class="fe mu mv mw mx b">[1st Element (0), 2nd Element (1), 3rd Element (2), 4th Element (3)]</code>调用函数<code class="fe mu mv mw mx b">reverse()</code>(负责反转的函数)</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/2058aa99c10ed8431cd004478696956a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSkFfsRZ3IlLx8wNOSeLSw.png"/></div></div></figure><p id="427b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是反转堆栈的步骤:</p><ol class=""><li id="9567" class="nk nl in kc b kd ke kh ki kl nm kp nn kt no kx np nq nr ns bi translated">初始化一个空队列。</li><li id="bcf1" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated">从堆栈中弹出每个元素，并将其放入队列中。</li><li id="c513" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated">将每个元素从队列中出队，并将其推送到堆栈上。</li></ol><p id="484f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将这些步骤应用于上面的堆栈，并创建反转过程的简单可视化。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/bd45889b85ba449eb8ac8452c52c040f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPTCdKgQZgs0X4EMX6nuXw.png"/></div></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/94c5d0f3fbf02e188191d5c7d468cb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6-1NzfHcuomFe5-0R8U9g.png"/></div></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/5531b910e769b66d1bb2d1cf0b376436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jg8RRAKgFRPQKW7UscNBbQ.png"/></div></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/3d45f189e97bbe265ebfb9cf274e9f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hotJaFCpexm3T-5YbUXzeA.png"/></div></div></figure><p id="88f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，当堆栈弹出时，最顶端的元素(<code class="fe mu mv mw mx b">1st element</code>)被放入队列。这个过程一直进行到堆栈为空。当栈为空时，队列包含栈的所有元素(队列中的元素:<code class="fe mu mv mw mx b">[4th element (0), 3rd element (1), 2nd element (2), 1st element (3)]</code>)。接下来，我们开始从队列中取出元素，并将它们放入堆栈。第一个出列的元素:<code class="fe mu mv mw mx b">4th element</code>。这种情况持续下去，堆叠被反转(<code class="fe mu mv mw mx b">[4th element (0), 3rd element (1), 2nd element (2), 1st element (3)]</code>)</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="ff97" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">堆栈反转的代码。</h1><p id="f3b1" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">首先，让我们创建一个带有参数<code class="fe mu mv mw mx b">stack</code>的函数</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="2532" class="my ln in mx b gy oc od l oe of">function reverse(stack){}</span></pre><p id="e97d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">逆转需要的三个步骤是:</p><ol class=""><li id="d933" class="nk nl in kc b kd ke kh ki kl nm kp nn kt no kx np nq nr ns bi translated">初始化一个空队列。</li><li id="a3d5" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated">从堆栈中弹出每个元素，并将其放入队列中。</li><li id="854b" class="nk nl in kc b kd nt kh nu kl nv kp nw kt nx kx np nq nr ns bi translated">将每个元素从队列中出队，并将其推送到堆栈上。</li></ol><p id="d7bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们创建一个空队列。</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="8dbb" class="my ln in mx b gy oc od l oe of">function reverse(stack){ <br/>    const queue = new Queue(); <br/>}</span></pre><p id="edc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们现在必须从堆栈中弹出每个元素，所以我们需要循环直到堆栈为空。因此，代码如下:</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="7df5" class="my ln in mx b gy oc od l oe of">function reverse(stack){ <br/>    const queue = new Queue(); //Creating a new queue<br/>    while(!stack.isEmpty()){ // Looping until the stack is empty.<br/>       queue.enqueue(stack.pop()); //Enqueue the popped stack element.<br/>    }<br/>}</span></pre><p id="9c9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经介绍了两个步骤，最后一步，我们必须让每个元素从队列中出列，并将这些元素推到堆栈上。因此，代码如下:</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="35a6" class="my ln in mx b gy oc od l oe of">function reverse(stack){ <br/>    const queue = new Queue(); //Creating a new queue<br/>    while(!stack.isEmpty()){ // Looping until the stack is empty.<br/>       queue.enqueue(stack.pop()); //Enqueue the popped stack element.<br/>    } <br/>    <br/>    while(!queue.isEmpty()){  //Looping until the queue is empty.<br/>       stack.push(queue.dequeue()); //Pushed the dequeued queue element.<br/>    }<br/>}</span></pre><h1 id="f52f" class="lm ln in bd lo lp oi lr ls lt oj lv lw lx ok lz ma mb ol md me mf om mh mi mj bi translated">测试反向功能</h1><p id="6a09" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">就是这个！我们已经使用队列成功地反转了堆栈！现在，让我们测试一个样本堆栈的反转:<code class="fe mu mv mw mx b">[‘Welcome’, ‘There’, ‘Hi’]</code></p><blockquote class="kz la lb"><p id="87a2" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">注意:在上面的堆栈中，<code class="fe mu mv mw mx b"><em class="in">‘welcome’</em></code>的索引为0。</p></blockquote><p id="5e55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了测试这个函数，我在<code class="fe mu mv mw mx b">Stack</code>类中创建了一个名为<code class="fe mu mv mw mx b">print()</code>的新方法，它返回堆栈中的所有元素。<code class="fe mu mv mw mx b">print</code>功能的代码:</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="04ff" class="my ln in mx b gy oc od l oe of">print(){<br/>   return this.elements; <br/>}</span></pre><p id="4780" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反转和测试的代码:</p><pre class="mq mr ms mt gt ny mx nz oa aw ob bi"><span id="ce7e" class="my ln in mx b gy oc od l oe of">function reverse(stack){ <br/>    const queue = new Queue();<br/>    while(!stack.isEmpty()){<br/>       queue.enqueue(stack.pop());<br/>    } <br/>    <br/>    while(!queue.isEmpty()){<br/>       stack.push(queue.dequeue());<br/>    }<br/>}</span><span id="b58d" class="my ln in mx b gy on od l oe of">//Creates a new stack.<br/>const stack = new Stack(); </span><span id="1c90" class="my ln in mx b gy on od l oe of">//Pushes 3 strings onto the stack<br/>stack.push('Welcome');<br/>stack.push('There');<br/>stack.push('Hi'); </span><span id="49b5" class="my ln in mx b gy on od l oe of">//Prints the stack before the reversal.<br/>console.log('Printing stack before reversal: ', stack.print());</span><span id="0bc6" class="my ln in mx b gy on od l oe of">//Reverses the stack.<br/>reverse(stack);</span><span id="a50f" class="my ln in mx b gy on od l oe of">//Prints the stack after the reversal.<br/>console.log('Printing stack after reversal: ', stack.print());</span></pre><p id="60db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当执行上述代码时，我们得到的输出是:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oo"><img src="../Images/88b1ebc78cfdef09b602e1dfc8a3fd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DelAWJAIUkkfLi2rDo_x9w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The output of the above code.</figcaption></figure><h1 id="34cc" class="lm ln in bd lo lp oi lr ls lt oj lv lw lx ok lz ma mb ol md me mf om mh mi mj bi translated">最终代码</h1><p id="1d1c" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">知识库链接:<a class="ae jz" href="https://github.com/Megh-Agarwal/stack-reversal-using-queue" rel="noopener ugc nofollow" target="_blank">https://github.com/Megh-Agarwal/stack-reversal-using-queue</a></p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="7b22" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="b29a" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">感谢您阅读这篇文章。希望你觉得有用。如果有，一定要留下评论让我知道。</p><p id="655f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>