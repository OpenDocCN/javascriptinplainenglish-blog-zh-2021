<html>
<head>
<title>The Easiest Way to Learn Higher-Order Components With Simple Instance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单实例学习高阶元件的最简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-easiest-way-to-learn-higher-order-components-with-simple-instance-44c4230c5351?source=collection_archive---------13-----------------------#2021-07-26">https://javascript.plainenglish.io/the-easiest-way-to-learn-higher-order-components-with-simple-instance-44c4230c5351?source=collection_archive---------13-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0604" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中的高阶组件，用一个简单的例子解释并使用功能组件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed9da84c2d1fe9450c45241d81ede67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YtJameefkNMtQ36T"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@anthonytran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Tran</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3ec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能多次听说过高阶元件(HOC)。申请实习的时候被问到高阶元件。</p><p id="b3b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道这是什么。或者你可能读到过，但还没有理解。</p><p id="5350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没问题。在这里，我将帮助你轻松学习。</p><p id="63f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将基于基本的React概念，如<a class="ae kv" href="https://medium.com/code-blog/learn-react-components-for-your-next-react-or-react-native-project-bcf69cd81752" rel="noopener">类和功能组件</a>，所以在继续之前，试着熟悉它们。</p><blockquote class="ls lt lu"><p id="999a" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我使用了来自<a class="ae kv" href="https://youtu.be/rsBQj6X7UK8" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>的代码，做了一点改动。在视频中，使用类组件解释了HOC，而我在这里使用了功能组件。</p></blockquote><p id="0991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧。</p><h1 id="a2dc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">我们为什么需要特设委员会？</strong></h1><p id="491b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">根据<a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>，高阶组件(HOC)是React中重用组件逻辑的高级技术。</p><p id="c51f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，高阶组件主要用于避免重复代码和重用相同的组件逻辑。</p><p id="af6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建一个网站时，很多时候我们在几个组件中应用相同的逻辑；相反，我们可以使用特设。</p><p id="23fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子来更清楚地理解它。</p><p id="0e88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你正在创建一个网站，你有三个相同的组件功能。这意味着你只是复制代码，而不是重用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/89700ec0135fa13e9c84652a05b9aa44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*bSP7ae79C45HE4yLLOXbcg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Src: Author</figcaption></figure><p id="6cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是将状态提升到父组件，并将状态和处理程序作为道具传递给子组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5bfe423a8f172d34cc392882e1079845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*M-iJHH6PKbRl9O4jpnWzlg.png"/></div></figure><p id="bd38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，如果我们有同一个父元素的子元素，这是没问题的，但是如果组件是分散的，我们必须在几个组件中传递道具，那该怎么办呢？</p><p id="9a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是最糟糕的情况。为此，我们可以使用HOC。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="4a1f" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">什么是HOC？</h1><p id="4fc7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了更清楚地记住它，我再重复一遍。</p><p id="4772" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<a class="ae kv" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>，高阶组件(HOC)是React中重用组件逻辑的高级技术。</p><p id="5278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说:</p><p id="6d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高阶组件主要用于避免重复代码和重用相同的组件逻辑。</p><p id="31cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多时候，我们在几个组件中应用相同的逻辑；相反，我们可以使用HOC。</p><p id="c21e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特设的语法非常简单。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="9b71" class="no ma iq nk b gy np nq l nr ns">const NewComponent = higherOrderComponent(originalComponent)</span></pre><p id="7d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以理解为我们有一个函数，它接受原始组件添加功能并返回新组件。</p><p id="3bfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际的语法是:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f223" class="no ma iq nk b gy np nq l nr ns">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span></pre><p id="cfba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释得更清楚，这里有一个非技术性的例子:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="a13d" class="no ma iq nk b gy np nq l nr ns">const IronMan = withSuit(TonyStark);</span></pre><p id="a38c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我在YouTube的一个视频中见过这个语法，所以所有的功劳都归YouTube频道。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="e7e5" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">无条件的实例</h1><p id="0e1b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们需要在用户点击一个按钮以及用户悬停在另一个按钮上时创建一个计数器功能。</p><p id="da45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将创建Click.js和Hover.js文件来添加功能。</p><p id="dcae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Click.js中，</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="96e0" class="no ma iq nk b gy np nq l nr ns">import React, { useState } from "react";</span><span id="44f5" class="no ma iq nk b gy nt nq l nr ns">const Click = () =&gt; {<br/> const [count, setCount] = useState(0);<br/> const incrementCount = () =&gt; {<br/>  setCount(count + 1);<br/> };</span><span id="a14f" class="no ma iq nk b gy nt nq l nr ns"> return <br/>  &lt;button onClick={incrementCount}&gt;Clicked {count} times&lt;/button&gt;;<br/>};</span><span id="d2c7" class="no ma iq nk b gy nt nq l nr ns">export default Click;</span></pre><p id="5447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Hover.js中，我们将编写以下代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6027" class="no ma iq nk b gy np nq l nr ns">import React, { useState } from "react";</span><span id="4ca3" class="no ma iq nk b gy nt nq l nr ns">const Hover = () =&gt; {<br/> const [count, setCount] = useState(0);</span><span id="a9dd" class="no ma iq nk b gy nt nq l nr ns"> const incrementCount = () =&gt; {<br/>  setCount(count + 1);<br/> };</span><span id="640f" class="no ma iq nk b gy nt nq l nr ns"> return (<br/>  &lt;div&gt;<br/>   &lt;h2 onMouseOver={incrementCount}&gt;Hovered {count} times&lt;/h2&gt;<br/>  &lt;/div&gt;<br/>); };</span><span id="2810" class="no ma iq nk b gy nt nq l nr ns">export default Hover;</span></pre><p id="0091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将通过在App.js中导入组件来显示它</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6485" class="no ma iq nk b gy np nq l nr ns">import "./styles.css";<br/>import Click from "./Click";<br/>import Hover from "./Hover";</span><span id="c116" class="no ma iq nk b gy nt nq l nr ns">export default function App() {<br/>return (<br/>  &lt;div className="App"&gt;<br/>   &lt;Click /&gt;<br/>   &lt;Hover /&gt;<br/>  &lt;/div&gt;<br/>);}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/67366ac4d3be65fb24650033baa51ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62yjdR9Bg7DTuL2yFx7oxg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output</figcaption></figure><p id="b9af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出可以工作，但是您是否意识到我们在点击和悬停组件中重复了代码？</p><p id="a793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们用HOC来解决这个问题。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="a501" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">带有HOC的实例</h1><p id="9932" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将创建一个Counter.js文件来添加计数器功能。</p><p id="7650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Counter.js中编写以下代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="e50d" class="no ma iq nk b gy np nq l nr ns">import React from "react";<br/>import { useState } from "react";</span><span id="40f7" class="no ma iq nk b gy nt nq l nr ns">const UpdatedComponent = (OriginalComponent) =&gt; {<br/> const NewComponent = () =&gt; {<br/>   const [count, setCount] = useState(0);<br/>   const incrementCount = () =&gt; {<br/>    setCount(count + 1);<br/>   };</span><span id="4df3" class="no ma iq nk b gy nt nq l nr ns">   return &lt;OriginalComponent count={count} incrementCount={incrementCount} /&gt;;</span><span id="b780" class="no ma iq nk b gy nt nq l nr ns"> };</span><span id="5aa1" class="no ma iq nk b gy nt nq l nr ns"> return NewComponent;</span><span id="a795" class="no ma iq nk b gy nt nq l nr ns">};</span><span id="9090" class="no ma iq nk b gy nt nq l nr ns">export default UpdatedComponent;</span></pre><p id="84c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个接受原始组件、添加功能并返回新组件的函数。</p><p id="6eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您还记得我们将添加到Click.js和Hover.js文件中的语法吗？</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="625c" class="no ma iq nk b gy np nq l nr ns">const NewComponent = higherOrderComponent(originalComponent)</span></pre><p id="2e91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改Click.js文件，</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="98c3" class="no ma iq nk b gy np nq l nr ns">import React from "react";<br/>import UpdatedComponent from "./Counter";</span><span id="2017" class="no ma iq nk b gy nt nq l nr ns">const Click = (props) =&gt; {<br/>  const { count, incrementCount } = props;<br/>  <br/>  return &lt;button onClick={incrementCount}&gt;Clicked {count} times &lt;/button&gt;;</span><span id="d045" class="no ma iq nk b gy nt nq l nr ns">};</span><span id="c235" class="no ma iq nk b gy nt nq l nr ns"><strong class="nk ir">export default UpdatedComponent(Click);</strong></span></pre><p id="2058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并修改Hover.js文件，</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="844c" class="no ma iq nk b gy np nq l nr ns">import React from "react";<br/>import UpdatedComponent from "./Counter";</span><span id="d711" class="no ma iq nk b gy nt nq l nr ns">const Hover = (props) =&gt; {<br/>  const { count, incrementCount } = props;</span><span id="dd9a" class="no ma iq nk b gy nt nq l nr ns">  return (<br/>  &lt;div&gt;<br/>   &lt;h2 onMouseOver={incrementCount}&gt;Hovered {count} times&lt;/h2&gt;<br/>  &lt;/div&gt;<br/>);};</span><span id="7f34" class="no ma iq nk b gy nt nq l nr ns"><strong class="nk ir">export default UpdatedComponent(Hover);</strong></span></pre><p id="a7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们使用了HOC来重用逻辑。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="c3cc" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">让我们结束吧</h1><p id="2f79" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我学习React的时候，它是帮助我学习HOC的最简单的例子。</p><p id="abca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这篇文章中，我想你们大多数人会明白我们为什么使用HOC以及如何使用它。</p><p id="9555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有，请再次阅读文章，然后在任何代码编辑器中练习相同的示例。它会帮助你更清楚地掌握这个概念。</p><p id="4037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别忘了<a class="ae kv" href="https://nitinfab.medium.com/" rel="noopener">关注我</a>，它会帮助我写更多这类内容。</p><p id="6cd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢了。</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/11-web-development-tools-i-use-every-day-because-they-make-my-life-easier-54ede59743c2"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">我每天都在使用的11个Web开发工具，因为它们让我的生活变得更加轻松</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">他们也一定会为你做同样的事情。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/8-life-lessons-a-programmer-with-30-years-of-experience-taught-me-2a9fb090a398"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">一个有30多年经验的程序员教给我的8条人生经验</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">就连千禧一代也在放弃六位数的技术工作。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kp ny"/></div></div></a></div><p id="6253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="lv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>