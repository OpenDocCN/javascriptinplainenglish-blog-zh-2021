<html>
<head>
<title>Communication Patterns in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的通信模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/communication-patterns-in-react-30df2de702eb?source=collection_archive---------2-----------------------#2021-11-02">https://javascript.plainenglish.io/communication-patterns-in-react-30df2de702eb?source=collection_archive---------2-----------------------#2021-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f159" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从基础到更复杂的事情，爱丽丝终于和鲍勃说话了！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/179571b8c6696776d6cc52fd4c495565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0cfWJn3ovOOUZtY2Ngakw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@quinoal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Quino Al</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="394e" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="a395" class="ll lm in ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ln io">亲子沟通的道具</strong>-&gt;儿童沟通</li><li id="4065" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">回调道具</strong>用于子- &gt;父沟通</li><li id="d9d8" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">共同祖先</strong>:不可伸缩，几乎是一种反模式</li><li id="6121" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">事件冒泡</strong>:隐式耦合，显然是一种反模式</li><li id="c05c" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">通过服务器</strong>:为什么不呢？</li><li id="c155" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">反应上下文</strong>，还有呢？</li><li id="9574" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated">基于React上下文，让我们添加一些<strong class="ln io">契约</strong></li><li id="122a" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><strong class="ln io">发布订阅</strong></li></ul></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="c4c1" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">React现在是一个开发单页面应用程序(spa)的成熟环境，拥有专业开发人员有权期待的每一个工具:启动项目、(结构)打字、linters，加上许多维护良好的、可用于生产的库。</p><p id="3d88" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">然而，当代码库增长时，人们面临两个主要问题:</p><ul class=""><li id="cce1" class="ll lm in ln b lo mr lq mt ls ne lu nf lw ng ly lz ma mb mc bi translated"><strong class="ln io">构图</strong>。它的第一个目的是确保每个组件只有<em class="nh">一个</em>职责，这就是众所周知的SRP(单一职责原则)。第二是避免一遍又一遍地写同样的代码，这就是所谓的干禁令(不要重复自己)。在React中，只有4种组合模式:直接调用子组件、高阶组件(HOC)、render-props模式(与HOC相比，大多数人更喜欢这种模式)和钩子。没错。</li><li id="a77a" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated">但是更多的组件也意味着让它们相互交流的额外技术。沟通将是我们今天的重点。</li></ul><p id="4801" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">在本文中，我们将讨论常见通信模式的优缺点，然后讨论对其他模式的需求。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="30b8" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">先说第一件事:道具，回调道具和共同祖先模式。</h1><p id="8a28" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">得益于React properties对象，即众所周知的“<strong class="ln io"> props </strong>”，父-&gt;子通信非常简单。<code class="fe nq nr ns nt b">message</code>是下面代码示例中的属性之一。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="abaa" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">相反，子-&gt;父通信由<strong class="ln io">回调props </strong>保证，即父(<code class="fe nq nr ns nt b">sendMessage(message: string): void</code>)提供的一个函数被其子(<code class="fe nq nr ns nt b">message</code>)用感兴趣的数据调用。在父组件中，这些数据必须处于一种状态(<code class="fe nq nr ns nt b">useState()</code>)才能被使用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="fbc7" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这让我们很自然地想到了<strong class="ln io">公共祖先</strong>模式，用于给定组件的后代之间的通信，从兄弟(同一个组件的两个孩子)开始。假设<code class="fe nq nr ns nt b">Alice</code>必须与她的兄弟<code class="fe nq nr ns nt b">Bob</code>通信，这个模式组合了一个回调属性用于从<code class="fe nq nr ns nt b">Alice</code>到<code class="fe nq nr ns nt b">Parent</code>的通信，然后组合了一个属性用于从<code class="fe nq nr ns nt b">Parent</code>到<code class="fe nq nr ns nt b">Bob</code>的通信。</p><pre class="kd ke kf kg gt nw nt nx ny aw nz bi"><span id="0722" class="oa ku in nt b gy ob oc l od oe">Alice --(callback property)--&gt; Parent (state) --(property)--&gt; Bob</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c90f" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这是相当系统的，但它显然没有规模。对于一级亲属(兄弟姐妹)，该模式导致1个回调属性、1个状态和1个属性。对于二级亲属(表亲)来说，已经是2个回调道具，1个状态，2个道具了。以此类推，对于N度亲属，就是N个回调道具，1个状态，N个道具。换句话说，这就是道具钻井的诅咒，我们应该寻求更好的解决方案。</p><h1 id="bd4b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">为了全面起见</h1><p id="4841" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">在跳到更适合“远距离”通信模式的附加部分之前，让我们先提一下<strong class="ln io">渲染道具</strong>。对于单个<code class="fe nq nr ns nt b">render</code>属性(或任何最合适的名称)，父组件避免传输<code class="fe nq nr ns nt b">message</code>属性，因为相应的数据(<code class="fe nq nr ns nt b">"Hello World!"</code>)仅用于<code class="fe nq nr ns nt b">render</code>函数的目的。从父对象传递给子对象用于直接显示的数据越多，而没有子对象负责的进一步计算，使用render props模式就越有意义。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e1a9" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">你还可以在下面这个优雅但不常见的“作为孩子的功能”变体下找到渲染道具模式。它稍微有些限制性，因为它只允许一个渲染属性:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="0da1" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">有反模式吗？</h1><p id="0481" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">是的…事件冒泡在这方面看起来是个不错的选择。事件冒泡描述了一个子组件发出一个事件而没有捕获它的情况。它在React树中的一个祖先代替了它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8b74" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这种模式使得组件之间的耦合是隐式的:通过查看单个的<code class="fe nq nr ns nt b">Parent</code>组件，或者同样地查看单个的<code class="fe nq nr ns nt b">Child</code>组件，通信并不明显。如果<code class="fe nq nr ns nt b">Child</code>被移动到它的<code class="fe nq nr ns nt b">Parent</code>树之外，所有东西都会坏掉。此外，在传输数据时，事件是非常有限的。通常，唯一可用的信息是事件本身的存在…</p><p id="7e21" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">随着原生DOM事件冒泡，情况变得更糟。这与上面的情况相同，但是事件是本地DOM事件，而不是React事件(<code class="fe nq nr ns nt b">React.ReactSyntheticEvent</code>)。</p><p id="2803" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">为什么会更糟？因为React的要点是虚拟DOM，它是本地DOM之上的一个抽象层次。本质上，虚拟DOM提供了一个声明性的API来操作DOM，而不是本地的命令式API。因此，<em class="nh">虚拟DOM </em>组件之间通过<em class="nh">本地DOM </em>事件的通信混合了抽象层次，违背了总是在同一抽象层次<a class="ae ks" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Levels_of_abstraction" rel="noopener ugc nofollow" target="_blank">工作的原则</a>。</p><p id="0613" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">更一般地说，当稍后引入额外的通信模式时，我们将特别注意总是依赖虚拟DOM。</p><h1 id="99e9" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">简单点，笨蛋！</h1><p id="d739" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">回到我们主要关心的问题:如何确保相距遥远的组件之间的通信？所谓“远亲”，我指的是两个组件都不是对方的后代:它们有一个共同的祖先，但是对于共同祖先模式来说，它在树中的位置太高了。</p><p id="ce2e" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">那么，在这种情况下，通过服务器进行通信是一个应该经常考虑的解决方案。基本模式是:</p><pre class="kd ke kf kg gt nw nt nx ny aw nz bi"><span id="56be" class="oa ku in nt b gy ob oc l od oe">1. Alice sends data to the server;<br/>2. Later, Bob fetches the data from the server.</span></pre><p id="4143" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">在下面的例子中，延迟获取是由用户触发的，但是该模式也适用于来自服务器(WebSockets)的推送通知。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0480" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">如果加以推广，这种模式会导致应用程序状态主要位于服务器上，而不是浏览器上。因此，尽管这种方法很实用，但与常规应用程序相比，它可能会质疑单页面应用程序的相关性。和往常一样，业务约束有助于做出架构决策:如果许多用户可能更新同一块数据，那么状态必须在服务器上。</p><h1 id="252b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">现在，让我们以React上下文为基础</h1><p id="25fa" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">终于！好的。让我们停止旁敲侧击，考虑一下与我们关注的问题相关的常见疑点:<a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文</a>。</p><blockquote class="of og oh"><p id="c9a1" class="mp mq nh ln b lo mr jo ms lq mt jr mu oi mv mw mx oj my mz na ok nb nc nd ly ig bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="61cd" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这是一个有趣的基础。人们可能希望有两个改进:</p><ul class=""><li id="4053" class="ll lm in ln b lo mr lq mt ls ne lu nf lw ng ly lz ma mb mc bi translated">仅更新作为上下文提供的对象的子部分的能力，并且仍然受益于变更检测(当提供新的引用时触发变更检测<code class="fe nq nr ns nt b">&lt;MessageContext.Provider value={...}&gt;</code>)；</li><li id="db4a" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated">某种契约化，因为上下文对象是应用程序状态将存在的地方。它必须被视为一个黄金来源，一个所有成分的真理的单一来源。</li></ul><p id="09fd" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这就是引入<a class="ae ks" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>架构的地方，随后是Redux、MobX等。但是Redux远不止这些，因为它附带了事件源。</p><p id="3722" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">因此，让我们稍微倒退一下，构建最简单的商店对象。商店是保护国家的大门。我们通过一个<code class="fe nq nr ns nt b">getState(): State</code>和一个<code class="fe nq nr ns nt b">setState(reducer: Reducer&lt;State&gt;): void</code>方法来约束读写操作。</p><p id="5c78" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">人们应该注意到<code class="fe nq nr ns nt b">getState(): State</code>没有提供任何保护:返回状态可能会被错误地改变。没有实施不变性的库(想想<a class="ae ks" href="https://immutable-js.com/" rel="noopener ugc nofollow" target="_blank">不可变</a>或<a class="ae ks" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank"> Immer </a>)，不变性依赖于君子协定。</p><p id="ffa7" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">那么必须做出选择来更新状态。这里有两种选择:</p><ul class=""><li id="4c8c" class="ll lm in ln b lo mr lq mt ls ne lu nf lw ng ly lz ma mb mc bi translated">直接更新:<code class="fe nq nr ns nt b">setState(state: State): void</code>；</li><li id="772b" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated">通过减速器<code class="fe nq nr ns nt b">(state: State): State</code>和<code class="fe nq nr ns nt b">setState(reducer: Reducer): void</code>更新。</li></ul><p id="ce5c" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">直接更新至少有两个缺点。</p><p id="6cd1" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">首先，因为只有状态的一部分要被更新，所以必须首先检索当前状态，然后传播。这种逻辑<code class="fe nq nr ns nt b">const state = getState();</code>会在每次更新时重复，这是我们想要避免的:</p><pre class="kd ke kf kg gt nw nt nx ny aw nz bi"><span id="38cf" class="oa ku in nt b gy ob oc l od oe">const state = getState();<br/>const newState = {<br/>  ...state,<br/>  // override some attributes<br/>};<br/>setState(newState);</span></pre><p id="1a8b" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">但是更深入地说，使用Reducer允许在一次重新渲染之前链接和批量更新，而第一个选项不允许。</p><p id="5134" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">下面有很多代码，您可以安全地跳到下一个代码示例，它展示了商店的运行情况。对于那些想深入了解的人来说，这里的难点是允许在状态更新时进行更改检测，而整个存储对象必须<em class="nh">而不是</em>发生更改。这里我们依靠一个简单的<code class="fe nq nr ns nt b">renderIndex</code>作为密钥。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2c1d" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">同样，如果上面的代码现在对你来说没有意义，它肯定是没问题的。更重要的是商场在运作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="501e" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这种契约化为人们认为有用的任何其他模式打开了大门。这正是我们将通过探索一个PubSub模式来实现的。</p><h1 id="2695" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">发布/订阅(发布订阅)</h1><p id="fce8" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">这种模式是众所周知的，甚至被<a class="ae ks" href="https://backbonejs.org/" rel="noopener ugc nofollow" target="_blank">骨干</a>用在前端。许多库，从<a class="ae ks" href="https://github.com/mroderick/PubSubJS" rel="noopener ugc nofollow" target="_blank"> PubSubJS </a>、<a class="ae ks" href="https://github.com/postaljs/postal.js" rel="noopener ugc nofollow" target="_blank"> postal.js </a>和<a class="ae ks" href="https://github.com/Olical/EventEmitter" rel="noopener ugc nofollow" target="_blank"> EventEmitter </a>开始，用普通的JavaScript提供了很好的实现。但是如上所述，我们希望我们的实现在与React相同的抽象层次上工作，而不是更低。下面，<code class="fe nq nr ns nt b">Channel</code>和<code class="fe nq nr ns nt b">PubSub</code>是普通的JavaScript类，然后我们使用React API(Context、HOC和hooks)使它们在React组件中可用。</p><p id="d24f" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">发布/订阅的要点是解耦，或者说是松耦合。通信通过事件总线进行。因此，发布者不知道它在和谁交谈，反过来，订阅者也不知道事件来自谁。</p><pre class="kd ke kf kg gt nw nt nx ny aw nz bi"><span id="fd53" class="oa ku in nt b gy ob oc l od oe">Publisher --&gt; Event bus --&gt; Subscriber</span></pre><p id="9cba" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">在引擎盖下，它依赖于<a class="ae ks" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>。等等……什么？这意味着紧密耦合，对吗？右图:受试者保留了其观察者的记录。有道理，所以让我们把事情弄清楚:观察者模式发生在事件总线和订阅者之间，而不是发布者和订阅者之间:</p><pre class="kd ke kf kg gt nw nt nx ny aw nz bi"><span id="adbc" class="oa ku in nt b gy ob oc l od oe">Publisher --&gt; Event bus --(observer pattern)--&gt; Subscriber</span></pre><p id="9ec7" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">顺便说一下，从轮询开始，其他实现也可以工作。</p><p id="b77b" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">嗯……说了很多，还是没有代码！这就是:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9ae4" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">瞧！</p><p id="4f3d" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">当然，这只是一个要点，而不是一个生产就绪的实现。为了简单起见，它是同步的，而在“现实世界”中通常以异步方式实现。但是，毕竟，在浏览器中，组件之间的异步通信有什么用呢？</p><p id="201d" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这提供了一个相当简单的API:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="48d7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">为了全面起见(再次)</h1><p id="4f20" class="pw-post-body-paragraph mp mq in ln b lo lp jo ms lq lr jr mu ls nn mw mx lu no mz na lw np nc nd ly ig bi translated">同样，为了全面起见，让我们提一下<a class="ae ks" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank"> React门户</a>。官方文件称:</p><blockquote class="of og oh"><p id="2199" class="mp mq nh ln b lo mr jo ms lq mt jr mu oi mv mw mx oj my mz na ok nb nc nd ly ig bi translated">门户提供了一种一流的方法来将子组件呈现到父组件的DOM层次结构之外的DOM节点中。</p></blockquote><p id="07ea" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">换句话说，它允许虚拟DOM中的<code class="fe nq nr ns nt b">parent-child</code>关系，而它们在DOM中的具体化(渲染元素)位于不同的树中。</p><p id="70e1" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">所有已经看到的交流模式都适用:道具、回调道具、上下文等。</p><p id="76cb" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">这在特定的用例中非常有用，比如模态和通知，但是你不能把它想象成一个系统的通信模式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="f65b" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">我们到了！本文概述了React组件之间的通信模式。事实上，它们中的大多数确实适用于其他库和框架(Vue.js，Angular…)</p><p id="9751" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">我很乐意听到您的反馈，尤其是关于PubSub模式的用例:您遇到过它有用的情况吗？</p><p id="80fd" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated">感谢阅读！</p><h1 id="c899" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">进一步阅读</h1><ul class=""><li id="69d4" class="ll lm in ln b lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae ks" href="https://github.com/mathieueveillard/react-communication-patterns" rel="noopener ugc nofollow" target="_blank">https://github . com/mathieueveillard/react-communication-patterns</a></li><li id="a38d" class="ll lm in ln b lo md lq me ls mf lu mg lw mh ly lz ma mb mc bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/21285923/reactjs-two-components-communicating" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/21285923/react js-two-components-communicating</a></li></ul><p id="a24a" class="pw-post-body-paragraph mp mq in ln b lo mr jo ms lq mt jr mu ls mv mw mx lu my mz na lw nb nc nd ly ig bi translated"><em class="nh">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io"><em class="nh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>