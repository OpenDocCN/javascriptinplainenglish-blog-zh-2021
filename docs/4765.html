<html>
<head>
<title>Typed Express Request and Response with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript键入的快速请求和响应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typed-express-request-and-response-with-typescript-7277aea028c?source=collection_archive---------1-----------------------#2021-09-23">https://javascript.plainenglish.io/typed-express-request-and-response-with-typescript-7277aea028c?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/adcdd1cdcb62b8eacb3f8a58d9cee60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v_mDTJ6cXotRWyQj"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jefferson Santos</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c352" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用TypeScript编写代码是很棒的，但是在代码中有一些地方让TypeScript发光是很棘手的。其中之一是在Express中定义路线时。</p><p id="62db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文介绍了一些向<code class="fe ky kz la lb b">Express.Request</code>和<code class="fe ky kz la lb b">Express.Response</code>对象添加TypeScript的方法。</p><h1 id="54e8" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">设置Express</h1><p id="bf1b" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">让我们先做基本的东西。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="9c5b" class="mn ld in lb b gy mo mp l mq mr">import Express from 'express';<br/>import http from 'http';</span><span id="97b8" class="mn ld in lb b gy ms mp l mq mr">let app: Express.Application | undefined = undefined;</span><span id="58c6" class="mn ld in lb b gy ms mp l mq mr">export function InitializeExpress(port = 3001): void {</span><span id="a7f2" class="mn ld in lb b gy ms mp l mq mr">    app = Express();<br/>    app.use(Express.urlencoded({ extended: true }));</span><span id="22cc" class="mn ld in lb b gy ms mp l mq mr">    app.get('/', function (_req: Express.Request, res: Express.Response) {<br/>        res.status(200).json(<strong class="lb io">{<br/>            "Foo": "Bar",<br/>             "Time": new Date().toISOString()<br/>        }</strong>);<br/>    });</span><span id="1fe9" class="mn ld in lb b gy ms mp l mq mr">   // Add 404 handler<br/>   app.use(function (_req: Express.Request, res: Express.Response) {<br/>      res.status(404).send("Not found");<br/>   });</span><span id="76e0" class="mn ld in lb b gy ms mp l mq mr">   // Start server (app.listen can also be used)    <br/>   http.createServer(app).listen(port, () =&gt;  <br/>    console.log(`Running at <a class="ae jz" href="http://localhost:${port}/`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}/`</a>));</span><span id="a927" class="mn ld in lb b gy ms mp l mq mr">}</span></pre><p id="103d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在访问<a class="ae jz" href="http://localhost:3001/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001/ </a>时，该服务器将返回如下内容:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="6f4d" class="mn ld in lb b gy mo mp l mq mr">{"Foo":"Bar","Time":"2021-09-21T19:32:15.091Z"}</span></pre><h1 id="e44a" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">快递。Request.body </strong></h1><p id="7cd0" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">特快列车。请求对象定义为:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="beeb" class="mn ld in lb b gy mo mp l mq mr">interface e.Request&lt;P = ParamsDictionary, <strong class="lb io">ResBody = any</strong>, ReqBody = any, ReqQuery = QueryString.ParsedQs, Locals extends Record&lt;string, any&gt; = Record&lt;string, any&gt;&gt;</span></pre><p id="374e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种类型使用起来很复杂。为了简化这一点，新类型被定义为:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="5fe9" class="mn ld in lb b gy mo mp l mq mr">export interface TypedRequestBody&lt;T&gt; extends Express.Request {<br/>    body: T<br/>}</span></pre><p id="a58a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这个新接口，就可以使用泛型对主体进行类型化:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="1cf2" class="mn ld in lb b gy mo mp l mq mr">app.post('/login', function (req: <strong class="lb io">TypedRequestBody&lt;{ username: string, password: string }&gt;</strong>, res: Express.Response) {</span><span id="86f6" class="mn ld in lb b gy ms mp l mq mr">    const success = req.body.username === "foo"<br/>                    &amp;&amp; req.body.password === "bar";</span><span id="25d5" class="mn ld in lb b gy ms mp l mq mr">    res.status(200).json({ "Success": success });<br/>});</span></pre><blockquote class="mt"><p id="8fcc" class="mu mv in bd mw mx my mz na nb nc kx dk translated">这将提供类型脚本检查和智能感知:</p></blockquote><figure class="ne nf ng nh ni jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/ada34a8d7a9b3192a99ff9db5a265b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sxXonOoLHnjO2l76WvDP5w.gif"/></div></div></figure><h1 id="5313" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">快递。请求。询问</h1><p id="9f9a" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">修改Express中的<code class="fe ky kz la lb b">query</code>。Request有点复杂，因为Express使用了来自<code class="fe ky kz la lb b">express-serve-static-core</code>的类型，而Express并不公开这些类型。因此，获得合适类型的唯一途径是<code class="fe ky kz la lb b">import { Query } from 'express-static-serve-core';</code>。解决方案是:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="d10a" class="mn ld in lb b gy mo mp l mq mr">import { Query } from 'express-serve-static-core';</span><span id="62cd" class="mn ld in lb b gy ms mp l mq mr">export interface TypedRequestQuery&lt;T extends Query&gt; extends Express.Request {</span><span id="d763" class="mn ld in lb b gy ms mp l mq mr">     query: T</span><span id="d516" class="mn ld in lb b gy ms mp l mq mr">}</span></pre><p id="c70b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用它，它看起来会像这样:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="9406" class="mn ld in lb b gy mo mp l mq mr">app.get('/article/:id', function (req: <strong class="lb io">TypedRequestQuery&lt;{ id: string }</strong>&gt;, res: Express.Response) {</span><span id="36df" class="mn ld in lb b gy ms mp l mq mr">    const id = req.query.id;</span><span id="5591" class="mn ld in lb b gy ms mp l mq mr">    // Fetch from database here and return article        </span><span id="c8aa" class="mn ld in lb b gy ms mp l mq mr">    res.status(200).json({ ID: id });</span><span id="109b" class="mn ld in lb b gy ms mp l mq mr">});</span></pre><h1 id="4a86" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">快递。请求。正文和查询</h1><p id="66e4" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">让我们做另一个类型，其中<em class="nj"/><code class="fe ky kz la lb b">body</code>和<code class="fe ky kz la lb b">query</code>都可以被键入:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="cbf8" class="mn ld in lb b gy mo mp l mq mr">export interface TypedRequest&lt;T extends Query, U&gt; extends Express.Request {<br/>    body: U,<br/>    query: T<br/>}</span></pre><p id="d49b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种用法可能类似于:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="1da0" class="mn ld in lb b gy mo mp l mq mr">app.put('/article/:id', function (req: <strong class="lb io">TypedRequest&lt;{ id: string }, { name: string }&gt;</strong>, res: Express.Response) {</span><span id="b811" class="mn ld in lb b gy ms mp l mq mr">        console.log(`Updating article<strong class="lb io"> ${req.query.id}</strong>`);<br/>        console.log(`setting name to <strong class="lb io">${req.body.name}</strong>`);<br/>        res.status(200).json({ Success: true });</span><span id="4d62" class="mn ld in lb b gy ms mp l mq mr">});</span></pre><h1 id="fcf5" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于传入请求的小安全说明</h1><p id="d619" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">TypeScript在运行时不存在，因此即使代码被设置为期望有效负载:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="7473" class="mn ld in lb b gy mo mp l mq mr">{ username: string, password: string }</span></pre><p id="bca1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">...像这样的错误负载:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b38f" class="mn ld in lb b gy mo mp l mq mr">{ username: undefined, password: ["Hello", "World"] }</span></pre><p id="4fda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">..可以提交以便“搞乱”路线。因此，<strong class="kc io">始终确保<em class="nj">始终</em>验证输入的有效载荷</strong>。</p><h2 id="ff05" class="mn ld in bd le nk nl dn li nm nn dp lm kl no np lq kp nq nr lu kt ns nt ly nu bi translated">PS:</h2><p id="45b7" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">如果你想从TypeScript接口/类型中自动生成验证器函数，那么阅读这篇文章:<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/how-to-automatically-convert-typescript-types-to-runtime-validators-5b06ee269b13">https://JavaScript . plain English . io/how-to-automatically-convert-TypeScript-Types-to-runtime-validators-5b 06 ee 269 b 13</a></p><h1 id="6047" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">快递。反应</h1><p id="b26c" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">Express再次使用来自<code class="fe ky kz la lb b">express-serve-static-core</code>的类型:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="d153" class="mn ld in lb b gy mo mp l mq mr">import { Send } from 'express-serve-static-core';</span></pre><p id="4625" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接口被定义为:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="a2df" class="mn ld in lb b gy mo mp l mq mr">export interface TypedResponse&lt;ResBody&gt; extends Express.Response {</span><span id="8554" class="mn ld in lb b gy ms mp l mq mr">   json: Send&lt;ResBody, this&gt;;</span><span id="7767" class="mn ld in lb b gy ms mp l mq mr">}</span></pre><p id="ca51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用法可能类似于:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b884" class="mn ld in lb b gy mo mp l mq mr">app.get('/ping', function (_req: Express.Request, res: <strong class="lb io">TypedResponse&lt;{ Pong: string }&gt;</strong>) {</span><span id="b88c" class="mn ld in lb b gy ms mp l mq mr">     res.status(200).json(<strong class="lb io">{ "Pong": new Date().toISOString() }</strong>);</span><span id="ee29" class="mn ld in lb b gy ms mp l mq mr">});</span></pre><p id="b0fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，如果响应的格式与预期的结果不匹配，TypeScript/VSCode (ErrorLens)将通知一个错误:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/b5d509b9380cbd2ac256415cefff0c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M8Aj0DmK1FmpTpzMpJoXDw.gif"/></div></div></figure><h1 id="df4c" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">演示源代码？</h1><p id="aaff" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/tomnil/typedexpress" rel="noopener ugc nofollow" target="_blank">https://github.com/tomnil/typedexpress</a></p><h1 id="48f8" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">享受:)</h1></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><h2 id="efdb" class="mn ld in bd le nk nl dn li nm nn dp lm kl no np lq kp nq nr lu kt ns nt ly nu bi translated">进一步阅读</h2><div class="od oe gp gr of og"><a href="https://bit.cloud/blog/sharing-types-between-your-frontend-and-backend-applications-l5qih48g" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">在前端和后端应用程序之间共享类型</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">您的后端API已经更新，可以返回新类型的数据。必须通知前端团队进行更新…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">比特云</p></div></div><div class="op l"><div class="oq l or os ot op ou jt og"/></div></div></a></div></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="2076" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nj">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">plain English . io</em></strong></a><em class="nj">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nj">免费周报</em> </strong> </a> <em class="nj">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">LinkedIn</em></strong></a><em class="nj"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">YouTube</em></strong></a><em class="nj"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nj">不和</em> </strong> </a> <em class="nj">。对增长黑客感兴趣？检查</em> <a class="ae jz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nj">电路</em> </strong> </a> <em class="nj">。</em></p></div></div>    
</body>
</html>