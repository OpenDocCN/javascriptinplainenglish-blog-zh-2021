<html>
<head>
<title>Angular meets RxJS: “takeUntil” and the “async” pipe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular符合RxJS:“take until”和“async”管道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d?source=collection_archive---------3-----------------------#2021-03-11">https://javascript.plainenglish.io/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d?source=collection_archive---------3-----------------------#2021-03-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/930715dfa12b3fbc5d1bb3016070dc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PxL1185tPfPgr68b"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@bigspringsstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lauren George</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6e41" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="0db0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这篇文章属于名为“<strong class="la io"> Angular meets RxJS </strong>”的系列文章，在这篇文章中，我尽我所能在“Angular”上下文中使用“RxJS”来解释反应式编程。</p><h1 id="62f2" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目录</h1><p id="125e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-basic-concepts-f178d8fe0e02">基本概念</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3"> RxJS科目</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e"> RxJS运算符(第1部分)</a> <br/> <a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-60d8b2140d20"> RxJS运算符(第2部分)</a> <br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-rxjs-operators-e64caa5f72e7" rel="noopener"> RxJS运算符(第3部分)</a><br/>“take until”和“async”管道<br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-higher-order-observables-632e560ce2d0" rel="noopener">高阶可观测量</a> <br/> <a class="ae jz" href="https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49" rel="noopener">错误处理</a> <br/> RxJS调度器(即将推出)<br/></p><h1 id="e32b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在这篇文章中</h1><p id="8aa0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">将“RxJS”与“Angular”一起使用的一个挑战是，我们需要以最佳方式释放observables使用的资源，以避免内存泄漏。到目前为止，我们看到的唯一方法是调用订阅的“取消订阅”功能。尽管它工作得很好，但像这样管理订阅会变得很麻烦。</p><p id="8e6c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在本文中，我们将看到简化订阅管理的两种方法:“takeUntil”操作符和“async”管道。</p><h1 id="879e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">具体的例子</h1><p id="79f6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">您可能很熟悉在组件中订阅永无止境的可观察对象的情况。在这种情况下，您必须取消订阅“ngOnDestroy”钩子中的可观察对象，以避免内存泄漏。</p><p id="970d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">一个典型的例子是某种计数器组件，它显示自初始化以来经过的秒数。这种组件的代码可以是:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2bfa" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">及其模板:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0174" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这段代码很好，并按预期工作。对可观察对象的订阅在“ngOnInit”钩子中创建，并在“ngOnDestroy”钩子中释放。然而，总是这样管理订阅会很麻烦，尤其是当你必须订阅多个observables时。</p><h1 id="fdc5" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">“拿”可以有所帮助</h1><p id="a689" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">“take”操作符可以帮助减少订阅的数量。事实上，有时候，即使你认同一个永无止境的可观察值，也可能你只对第一个值感兴趣。例如，假设您想在一秒钟后以一种被动的方式只执行一次(因此不使用“setTimeout”)，您可以通过使用“timer”操作符和“take”操作符来完成输出可观察值。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2b2c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，我们订阅源可观察对象，然后一旦源可观察对象发出第一个值，就完成输出。您可以在本文的<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-operators-60d8b2140d20">中找到关于“take”操作符的更多信息。</a></p><h1 id="a704" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">“takeUntil”拯救世界</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/374d170eebac4aabb3eacf246ea256b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*qUUQ2TZL-zfzCukn7ylqkQ.png"/></div></figure><p id="c681" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">“takeUntil”是一个非常酷的操作符，它发出源可观测值，直到另一个可观测值发出一个值。它的大理石图如下:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/45e9a97f08cf14ce20396ed3ead095d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNP7lZI42vy0Q4PGWTzsVA.png"/></div></figure><p id="f62c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们可以使用该运算符来避免像这样管理订阅:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d0ae" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个版本的代码中，我们创建了一个“<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3">主题</a>，并在“ngOnDestroy”钩子中发出一个值。我们还完成了它，因为我们以后不再需要它。我们还通过使用“takeUntil”操作符将订阅更改为可观察对象，以指定我们希望在可观察对象“_subject”发出后立即完成输出可观察对象。</p><p id="6ad9" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我已经听到你说“好的，很酷，但是…现在我有一个主题而不是订阅，它甚至有更多的代码，所以我为什么要使用它？”。</p><p id="3a91" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第一个原因是它极大地改进了管理多个订阅的方式。事实上，当订阅其他observabless时，你也可以使用“takeUntil”和“_subject ”,这样当组件被销毁时，你就可以取消订阅所有observable。</p><p id="2b3a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是使用这种方法的更好的方法是创建以下基本组件:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8c0c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，您唯一要做的就是扩展这个组件，并使用“takeUntil”和“destroy$”可观察值。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e55e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是我在所有“Angular”应用程序中使用的一种方法，它工作得非常好，特别是因为大多数时候，你将不得不通过一些操作符来传递你的可观察对象，以实现你想要的，所以只需在正确的位置添加“takeUntil”就可以避免管理订阅。</p><h1 id="3c5a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">“异步”管道</h1><p id="0eaa" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">尽管“takeUntil”方法非常简洁，但“Angular”团队有一个好主意，创造了令人敬畏的<strong class="la io"/>“异步”管道。当处理可观测量时，这个管道使一切变得容易。</p><blockquote class="mj mk ml"><p id="3c5d" class="ky kz mm la b lb lw ld le lf lx lh li mn ly ll lm mo lz lp lq mp ma lt lu lv ig bi translated">这个管道也可以用来管理承诺，但我们不会在本文中讨论它</p></blockquote><p id="0a3e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">该管道用于声明性地订阅“Angular”模板中的可观察对象，并在发出值后立即更新视图，最大的好处是该管道可以为您处理订阅。例如，您以前的代码可以像这样得到很大的改进:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a05c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如你所见，我们过去使用的大部分代码已经消失了。唯一剩下的就是创造可观察的事物。当然，我们还需要更新模板来使用“异步”管道。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6a07" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">就是这样…基本上，通过这样做，您请求管道订阅可观察对象，并在使用管道的组件被破坏后立即取消订阅。您将整个订阅管理卸载到“Angular”的“async”管道中。</p><h1 id="2268" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">关于“异步”管道的更多信息</h1><p id="87c4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">“异步”管道提供了两个很好的特性，我想在本文结束之前谈谈。</p><h2 id="d74e" class="mq kb in bd kc mr ms dn kg mt mu dp kk lj mv mw ko ln mx my ks lr mz na kw nb bi translated">如果可观察到的变化呢？</h2><p id="9d3f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在“Angular”应用程序中，通常有一些组件只是用来显示数据。例如，我们可以考虑使用一个“用户组件”来显示用户的数据。关于那件事有两种不同的观点:</p><ul class=""><li id="c84f" class="nc nd in la b lb lw lf lx lj ne ln nf lr ng lv nh ni nj nk bi translated">创建一个期望显示整个对象的输入。</li><li id="c5bb" class="nc nd in la b lb nl lf nm lj nn ln no lr np lv nh ni nj nk bi translated">创建一个期望显示对象id的输入。</li></ul><p id="0442" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">正如我们将在下一篇文章中看到的，我越来越喜欢使用商店来管理我的“Angular”应用程序。长话短说，商店就像数据库的一部分，其中充满了应用程序需要的数据。</p><p id="00bc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果我必须创建一个“UserComponent ”,我可能会在我的存储中有一个用户映射，我将通过查询来检索用户的数据。因为我们还没有看到如何在“Angular”中创建一个商店，所以我将使用一些伪代码，但是最后，您的组件可能看起来像这样:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c485" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">基本上，我们只是在组件初始化期间，根据输入的“userId”查询存储以检索用户。函数“selectUser”返回一个在用户数据改变时发出用户数据的可观察对象。</p><p id="70c8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">尽管这种方法是有效的，但是这个组件有一个问题:“如果userId改变了怎么办？”。事实上，如果输入的值发生变化，我们必须更新我们的可观察值，以便返回由新值“userId”标识的用户的数据。我对此做了很多实验，不幸的是，我没有找到一个完美的解决方案，然而，我找到了一个接近完美的解决方案，这要感谢<a class="ae jz" href="https://stackoverflow.com/questions/64287715/use-an-observable-store-and-a-component-input-with-angular" rel="noopener ugc nofollow" target="_blank">这篇StackOverflow帖子</a>。</p><p id="ae58" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">想法是在setter中转换我们的输入，并更新那里的可观察值:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1159" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我们只需在每次“userId”改变时更新可观察对象。然而，如果“异步”管道没有那么好，这是不可能的。事实上，假设组件加载了输入“1”。当用户“1”的数据改变时，可观察对象被创建并发出值。当我们在模板中使用“async”管道时，创建了对此可观察对象的订阅，但是过了一会儿，输入的值发生了变化，这意味着创建了一个新的可观察对象并将其放入“data$”中，那么活动订阅会发生什么情况呢？“异步”管道简单地取消订阅。事实上，这个管道足够聪明，可以检测到可观察的引用何时发生变化，并取消所有活动订阅，这使得上面的代码可行。</p><h2 id="2d81" class="mq kb in bd kc mr ms dn kg mt mu dp kk lj mv mw ko ln mx my ks lr mz na kw nb bi translated">与ngIf异步</h2><p id="313e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果我们继续上面的“UserComponent ”,我们可以想象该模板如下所示:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f61e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">不太好。事实上，一旦我们想要显示一个值，就需要订阅可观察值，这是非常麻烦的。如果您认为在上面的例子中，我们创建了三个不同的订阅只是为了显示一些数据，那就更是个问题了。</p><p id="f890" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，一个非常好的解决方案是使用“ngIf … as”指令:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="25d5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这已经很清楚了，好消息是我们将活动订阅的数量减少到了一个。因此，基本上，“异步”管道订阅可观察对象，并将发出的值放在本地模板变量“user”中。之后，你可以使用“用户”作为一个常规变量。如果你真的想拥有一个好的组件，你可以预见用户被获取的情况。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="656b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这样，如果可观察对象没有发出一个值或发出一个“假”值，将显示文本“正在加载”。</p><h1 id="4b6b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最后的想法</h1><p id="0ca4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在本文中，我们学习了如何在我们的“Angular”组件中大幅减少要管理的订阅数量。我们可以通过使用“takeUntil”操作符和强大的“async”管道来实现这一点。现在我们已经准备好讨论最复杂的“RxJS”主题之一:更高阶的可观测值。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ssougnez"><div class="gh gi nq"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a></figure></div></div>    
</body>
</html>