<html>
<head>
<title>Deploy a PlanetScale, Next.js &amp; Prisma App to Vercel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将PlanetScale，Next.js &amp; Prisma应用程序部署到Vercel</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deploying-a-planetscale-next-js-prisma-app-to-vercel-d67cbf8ea7?source=collection_archive---------18-----------------------#2021-08-16">https://javascript.plainenglish.io/deploying-a-planetscale-next-js-prisma-app-to-vercel-d67cbf8ea7?source=collection_archive---------18-----------------------#2021-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5e3da88d3f0b34600c88ea311b2e449d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YFmMm9G9zt5eYZbQ.png"/></div></div></figure><h1 id="76a9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="45d1" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当探索无服务器数据库解决方案时，目前只有少数几种能够很好地匹配。你可以使用传统的DBaaS平台，比如Amazon RDS或Heroku，但是如果不使用像<a class="ae lr" href="https://www.pgbouncer.org/" rel="noopener ugc nofollow" target="_blank"> PgBouncer </a>这样的工具来使用某种连接池，你会发现你的数据库会很快耗尽其连接限制，并由于<a class="ae lr" href="https://www.prisma.io/docs/guides/performance-and-optimization/connection-management#the-serverless-challenge" rel="noopener ugc nofollow" target="_blank">无服务器限制</a>而关闭你的整个应用。如果有一个数据库解决方案可以与Prisma无缝集成，并且根本不用担心管理并发连接的问题就好了！输入<a class="ae lr" href="https://planetscale.com/" rel="noopener ugc nofollow" target="_blank">行星标度</a>。</p><h1 id="714c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是PlanetScale？</h1><p id="1181" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">基于<a class="ae lr" href="https://vitess.io/" rel="noopener ugc nofollow" target="_blank"> Vitess </a>，PlanetScale是一个新的DBaaS平台，它允许您在几秒钟内启动数据库，而完全不用担心连接管理。Vitess是支持许多超大规模网站的相同技术，这些网站需要关键的正常运行时间、性能和可扩展性。PlanetScale还引入了一些非常酷的概念，比如数据库分支(类似于Git分支逻辑)，因此您的数据库迁移是无缝和无阻塞的。</p><p id="80bc" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在本文中，我们将介绍如何创建一个全新的<strong class="kv io">next . js</strong><strong class="kv io">Prisma</strong>应用程序，使用<a class="ae lr" href="https://planetscale.com/blog/connect-any-mysql-client-to-planetscale-using-connection-strings" rel="noopener ugc nofollow" target="_blank">新发布的连接字符串选项</a>将其连接到<strong class="kv io"> PlanetScale </strong>，使用PlanetScale非阻塞模式更改工作流发出一个简单的部署请求，然后使用<strong class="kv io"> Vercel </strong>将其部署到生产环境中。</p><h1 id="1b17" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置</h1><h1 id="b385" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">行星尺度</h1><p id="14a6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们开始之前，请在<a class="ae lr" href="https://planetscale.com/" rel="noopener ugc nofollow" target="_blank"> PlanetScale </a>注册一个账户。一旦注册完毕，下载<a class="ae lr" href="https://planetscale.com/cli" rel="noopener ugc nofollow" target="_blank"> PlanetScale CLI </a>，这对于本地连接到我们的数据库、创建新的数据库分支，以及<a class="ae lr" href="https://docs.planetscale.com/tutorials/automatic-prisma-migrations" rel="noopener ugc nofollow" target="_blank">在我们使用Prisma对我们的模式</a>进行更改时发出部署请求非常重要。</p><p id="3b73" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">从您的仪表板，点击“创建数据库”按钮，输入一个数据库名称(我将命名为我的教程-数据库)，选择一个地区，并取消选择启动教程数据库选项。</p><p id="0cc5" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在无服务器应用程序中，为了减少延迟，选择尽可能靠近应用程序部署位置的数据库区域非常重要。在我的例子中，我的Vercel应用程序和PlanetScale数据库都在美国西部。</p><p id="55f2" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">太棒了。一旦创建了数据库，请转到设置页面并启用<strong class="kv io">自动复制迁移数据</strong>，每当我们合并<a class="ae lr" href="https://planetscale.com/blog/non-blocking-schema-changes" rel="noopener ugc nofollow" target="_blank">部署请求</a>时，它会将我们的Prisma模式迁移存储在一个名为<strong class="kv io"> _prisma_migrations </strong>的表中。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/81642de3a7f40d69cb3237239a143930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ty69jEVboqLY1YKFCxhRcw.png"/></div></div></figure><p id="feb8" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">厉害！回到您的数据库仪表板，您应该看到这个视图。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/e6d3567056da14afa8638d9981f8bab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne7MpXCjM8EXfUUX7n7G2A.png"/></div></div></figure><p id="4394" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在，我们已经设置了数据库，并启用了复制Prisma迁移数据选项，接下来点击仪表板右上角的<strong class="kv io">连接</strong>按钮，并为您的<strong class="kv io">主</strong>分支生成一个新密码。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/e7e1f8cd75da72e7d69c8d903924f775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aydOL45A4hi98PtSGzFVKw.png"/></div></div></figure><p id="2712" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用下拉菜单，选择<strong class="kv io"> Prisma </strong>格式，并确保将这些连接详细信息安全地保存在某个地方，因为PlanetScale会在初始生成后隐藏您的密码。(如果您放错了这些凭据，您可以随时生成一个新密码，并删除放错的密码)。这些是我们将在部署期间在Vercel上的Prisma <code class="fe me mf mg mh b">DATABASE_URL</code>环境变量中使用的细节。</p><p id="f735" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">由于Prisma迁移遵循PlanetScales非阻塞模式迁移工作流，我们将需要从我们的主数据库分支<strong class="kv io">创建两个额外的分支，以便处理这些模式更改。这可以通过<strong class="kv io"> PlanetScale CLI </strong>轻松完成。</strong></p><p id="7a08" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在您选择的终端中发出以下命令，登录PlanetScale CLI:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="c86a" class="mm jw in mh b gy mn mo l mp mq">pscale auth login</span></pre><p id="498b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们已经通过了身份验证，让我们创建另外两个<strong class="kv io">开发分支</strong>:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="903d" class="mm jw in mh b gy mn mo l mp mq">pscale branch create tutorial-db initial-setup <br/>pscale branch create tutorial-db shadow</span></pre><p id="f7b4" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在两个单独的终端中，使用以下命令连接到每个数据库分支:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="5c54" class="mm jw in mh b gy mn mo l mp mq">pscale connect tutorial-db initial-setup --port 3309</span><span id="a403" class="mm jw in mh b gy mr mo l mp mq">pscale connect tutorial-db shadow --port 3310</span></pre><h1 id="608e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">Next.js &amp; Prisma</h1><p id="c971" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现在我们已经建立并运行了数据库和数据库分支，是时候初始化我们的<strong class="kv io"> Next.js </strong>和<strong class="kv io"> Prisma </strong>应用程序了。</p><p id="078e" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用以下命令启动一个新的Next.js项目:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="275e" class="mm jw in mh b gy mn mo l mp mq">npx create-next-app planetscale-prisma-next</span></pre><p id="5581" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe me mf mg mh b">cd</code>进入新项目目录，并使用以下命令初始化Prisma:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="f93f" class="mm jw in mh b gy mn mo l mp mq">npx prisma init</span></pre><p id="0e1c" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">像这样修改项目根目录下的<code class="fe me mf mg mh b">.env</code>文件:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="d857" class="mm jw in mh b gy mn mo l mp mq">DATABASE_URL="mysql://root@127.0.0.1:3309/tutorial-db" SHADOW_DATABASE_URL="mysql://root@127.0.0.1:3310/tutorial-db"</span></pre><p id="63fa" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为了确保平台兼容性，我们还需要对我们生成的<code class="fe me mf mg mh b">prisma</code>文件夹中的<code class="fe me mf mg mh b">schema.prisma</code>文件进行一些特定于行星尺度的调整。编辑我们的数据源并生成以启用<strong class="kv io"> planetScaleMode </strong>，包含我们的<strong class="kv io"> shadowDatabaseUrl </strong>，并将<strong class="kv io"> planetScaleMode </strong>添加到我们的previewFeatures数组中。</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="4041" class="mm jw in mh b gy mn mo l mp mq">datasource db {<br/>  provider = "mysql"<br/>  url      = env("DATABASE_URL")<br/>  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")<br/>  planetScaleMode = true<br/>}<br/><br/>generator client {<br/>  provider = "prisma-client-js"<br/>  previewFeatures = ["planetScaleMode"]<br/>}</span></pre><p id="a9f4" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">出于本教程的考虑，我们将为一篇<strong class="kv io">文章</strong>创建一个简单的Prisma模型，我们将通过一个无服务器函数和<strong class="kv io"> Prisma客户端</strong>检索该模型。我们不会深入到UI中，因为我们要做的只是演示如何设置和部署。因此，在编辑模式后，我们将手动向数据库中输入一些数据。将以下内容添加到我们的<code class="fe me mf mg mh b">schema.prisma</code>文件中:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="f995" class="mm jw in mh b gy mn mo l mp mq">datasource db {<br/>  provider = "mysql"<br/>  url      = env("DATABASE_URL")<br/>  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")<br/>  planetScaleMode = true<br/>}<br/><br/>generator client {<br/>  provider = "prisma-client-js"<br/>  previewFeatures = ["planetScaleMode"]<br/>}<br/><br/>model Post {<br/>  id        Int      @default(autoincrement()) @id<br/>  createdAt DateTime @default(now())<br/>  updatedAt DateTime @updatedAt<br/>  title     String   @db.VarChar(255)<br/>  content   String<br/>}</span></pre><p id="3c93" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们有了模式设置，让我们生成我们的第一个Prisma迁移！</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="115a" class="mm jw in mh b gy mn mo l mp mq">npx prisma migrate dev --name init</span></pre><p id="1002" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果一切顺利，我们应该在终端上看到一条成功消息，以及项目中的一个新的<code class="fe me mf mg mh b">migrations</code>文件夹。现在，是时候打开一个deploy-request，将这些更改带到我们的主数据库分支。</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="4897" class="mm jw in mh b gy mn mo l mp mq">pscale deploy-request create tutorial-db initial-setup</span></pre><p id="87da" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">呜哇！我们刚刚创建了第一个<strong class="kv io"> PlanetScale部署请求</strong>。如果我们返回到我们的仪表板，并导航到我们的部署请求选项卡，我们应该看到一个针对我们的模式更改的打开的部署请求。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/53ee2f91e366b0ab21d6829a633d75d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bboJXEbWMSumz-3Hlkwcaw.png"/></div></div></figure><p id="89ca" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">单击<strong class="kv io">Add changes to deploy queue</strong>按钮，如果一切顺利，我们的更改将被部署到主数据库分支！</p><p id="87b9" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们已经更新了我们的主分支，接下来关闭已经连接到PlanetScale的两个终端，让我们重新运行一个命令，在端口3309上打开到我们的<strong class="kv io">主</strong>分支的连接，这样我们就可以向我们的数据库添加一个<strong class="kv io"> Post </strong>记录。</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="198b" class="mm jw in mh b gy mn mo l mp mq">pscale connect tutorial-db main --port 3309</span></pre><p id="0ae7" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">让我们在项目中打开一个新的终端并运行<code class="fe me mf mg mh b">npx prisma studio</code>,这样我们就可以打开Prisma的web GUI，允许我们向PlanetScale数据库添加一个新的Post记录。点击工具栏上的<strong class="kv io">添加记录</strong>，输入您想要的任何样本数据。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/a92030f8e0c024f71cd513043106ed5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4i6lw0LcpCamym476GDPA.png"/></div></div></figure><p id="77f2" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">既然我们已经建立了数据库，我们的模式已经部署到我们的主分支，并且一个示例帖子已经添加到我们的数据库，现在是时候建立一个<strong class="kv io">无服务器函数</strong>来检索我们所有的帖子了。</p><p id="ed56" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">由于我们处理的是一个<strong class="kv io">无服务器</strong>应用程序，我们希望避免在每个后续请求中实例化一个新的<strong class="kv io"> Prisma客户端</strong>来保留连接，所以让我们在项目的根目录下创建一个名为<code class="fe me mf mg mh b">lib</code>的新文件夹和一个名为<code class="fe me mf mg mh b">prisma.js</code>的文件，这样我们就可以导出一个可重用的Prisma客户端。</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="f41b" class="mm jw in mh b gy mn mo l mp mq">import { PrismaClient } from '@prisma/client'<br/><br/>const prisma = global.prisma || new PrismaClient();<br/><br/>if (process.env.NODE_ENV === "development") global.prisma = prisma;<br/><br/>export default prisma</span></pre><p id="f598" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">接下来，让我们在<code class="fe me mf mg mh b">pages/api</code>中的<code class="fe me mf mg mh b">api</code>文件夹内创建一个名为<code class="fe me mf mg mh b">posts.js</code>的新文件，包括以下内容:</p><pre class="ly lz ma mb gt mi mh mj mk aw ml bi"><span id="5e57" class="mm jw in mh b gy mn mo l mp mq">import prisma from "../../lib/prisma";<br/><br/>export default async function assetHandler(req, res) {<br/>    const { method } = req;<br/><br/>    switch (method) {<br/>        case "GET":<br/>            try {   <br/>                const posts = await prisma.post.findMany();<br/>                res.status(200).json(posts);<br/>            } catch(e) {<br/>                console.error("Request error", e);<br/>                res.status(500).json({ error: "Error fetching posts" });<br/>            }<br/>            break;<br/>        default:<br/>            res.setHeader("Allow", ["GET"]);<br/>            res.status(405).end(`Method ${method} Not Allowed`);<br/>            break;<br/>    }<br/>}</span></pre><p id="c556" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在，如果我们访问<code class="fe me mf mg mh b">http://localhost:3000/api/posts</code>，我们应该会看到从我们的PlanetScale数据库中获取的帖子记录！</p><h1 id="d748" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">部署</h1><p id="e874" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">由于我们正在部署到<strong class="kv io"> Vercel </strong>，请确保您已经注册并连接了您的Github帐户。将文件提交到Github后，选择Vercel上的<strong class="kv io">新项目</strong>选项，向下滚动到<strong class="kv io">环境变量</strong>部分。</p><p id="916e" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用您之前为我们的主分支保存的<strong class="kv io">连接字符串细节</strong>，用您之前保存的连接字符串为我们的<code class="fe me mf mg mh b">DATABASE_URL</code>创建一个新的环境变量。</p><p id="8680" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">由于Vercel使用特定的Linux发行版，我们需要确保编辑我们的连接字符串以指向正确的证书位置，即<code class="fe me mf mg mh b">/etc/pki/tls/certs/ca-bundle.crt</code>。</p><p id="273c" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">您的连接字符串环境变量应该类似于:</p><p id="755b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe me mf mg mh b">mysql://YOUR_USER:************@YOUR_HOST/tutorial-db?sslmode=require&amp;sslcert=/etc/pki/tls/certs/ca-bundle.crt</code></p><p id="ec4b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">继续并点击部署！</p><p id="100b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">一旦部署了应用程序，如果您导航到同一个<code class="fe me mf mg mh b">/api/posts</code>端点，您应该会看到返回的数据。</p><p id="3787" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">恭喜您，您已经成功将一个使用<strong class="kv io"> PlanetScale </strong>作为数据库的<strong class="kv io"> Next.js Prisma </strong>应用程序部署到<strong class="kv io"> Vercel </strong>！</p><h1 id="d1b6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">包裹</h1><p id="74b5" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我希望这篇文章对那些希望将PlanetScale集成到他们的技术堆栈中，并使用Vercel将其部署到生产环境中的开发人员有所帮助。PlanetScale提供的开发者体验棒极了，他们的支持也是无与伦比的(特别感谢<a class="ae lr" href="https://twitter.com/NickVanWig" rel="noopener ugc nofollow" target="_blank"> Nick Van Wiggeren </a>帮助我解决了写这篇文章时遇到的一个问题)。</p><p id="2e8a" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果你想看看这个演示使用的代码，请点击这里的库<a class="ae lr" href="https://github.com/DavidTParks/planetscale-prisma-next" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5cb8" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">感谢阅读！</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="3ed3" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="nb">最初发布于2021年8月16日</em><a class="ae lr" href="https://davidparks.dev/blog/planetscale-deployment-with-prisma/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://David parks . dev</em></a><em class="nb">。</em></p><p id="ed26" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="nb">更多内容请看</em><a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>