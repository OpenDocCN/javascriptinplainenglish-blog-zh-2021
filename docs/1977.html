<html>
<head>
<title>Test Angular Components with Jasmine, Karma, and the Test Wrapper Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jasmine、Karma和测试包装模式测试有角度的组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-angular-components-using-jasmine-karma-and-the-test-wrapper-pattern-f0a64a8a29ba?source=collection_archive---------5-----------------------#2021-04-25">https://javascript.plainenglish.io/testing-angular-components-using-jasmine-karma-and-the-test-wrapper-pattern-f0a64a8a29ba?source=collection_archive---------5-----------------------#2021-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="637d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自动化测试已经成为保护应用程序不受新错误影响的一个好方法。让我们看一个可以用来测试组件的模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb2bbeece05fcd8b464ea19bcd3faf90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tWN3q4AP2uIkBmBO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clay Banks</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="07ff" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">先决条件/假设</h2><p id="adbf" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">您至少有一个样板角度应用程序(使用<code class="fe lx ly lz ma b">ng new &lt;app-name&gt;</code>生成的也可以)，用<a class="ae ky" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>和<a class="ae ky" href="https://karma-runner.github.io/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Karma </a>设置。代码是使用<a class="ae ky" href="https://v11.angular.io/docs" rel="noopener ugc nofollow" target="_blank"> Angular 11 </a>和Angular <a class="ae ky" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank"> CLI </a>编写的——测试包装器模式应该可以与Angular的任何支持版本一起工作。我们还希望在您的机器上设置好<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>和<a class="ae ky" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git </a> bash。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="bf62" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">示例组件</h2><p id="d0c5" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">第一步是使用命令<code class="fe lx ly lz ma b">ng generate component simple-sample</code>生成一个简单的组件。当组件生成后，您可以删除HTML并生成CSS(或任何样式文件)。不会使用Style，模板将位于Typescript文件本身中。</p><p id="c88c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，这个组件很简单。它将有两个输入，一个布尔值和一个字符串，以及一个输出发射器，它将发出一个字符串。该组件将显示由输入传入的标题，并在没有输入时有一个默认标题。它还将有两个按钮，根据输入布尔值启用/禁用。当单击一个按钮时，将向父组件发出一个输出。这是组件的Typescript文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Simple component Typescript file.</figcaption></figure><h2 id="d374" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">测试包装组件</h2><p id="98f4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当您运行<code class="fe lx ly lz ma b">generate</code>命令时，您将得到一个样板规格文件来构建测试。该文件是用一个<code class="fe lx ly lz ma b">component</code>和<code class="fe lx ly lz ma b">fixture</code>变量建立的。组件变量是被测试的组件。fixture变量是一个测试工具，用于将更改应用到组件，并查看这些更改如何影响组件的状态。下面是由generate命令创建的规范文件的外观。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/18c43837b85b9afa65a5aba4581d9e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*aeAKeb5UW40ssYrdCYHDRw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Initial test file generated.</figcaption></figure><p id="129c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您想要添加到规范文件的第一项内容是创建TestWrapperComponent。包装器组件就是这样，它是一个容器，用所有的输入、处理的输出和一个标志来包装我们正在测试的组件，该标志充当显示和隐藏组件的开关(缺省值为不显示)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e341a40ccd5e8a3823c83c66d0de8914.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*VyTRQPlRqgoiUxZC21rhGQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">TestWrapper for the SimpleSample component.</figcaption></figure><p id="88cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每个测试用例的开始，show标志默认为false。这意味着将不会显示正在测试的组件。在每个测试用例中要做的第一件事是设置测试所需的输入值。这包括打开显示标志。一旦一切设置完毕，使用fixture工具调用<code class="fe lx ly lz ma b">detectChanges()</code>来刷新组件。这将导致每个测试初始化被测试的组件，ngOnInit和构造函数为每个测试用例运行。</p><p id="bc9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显示/隐藏开关是这种模式的关键。它将允许被测试的组件在每个测试用例之前被重置，这样组件将运行通过生命周期功能。</p><h2 id="17f9" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">测试案例</h2><p id="9ac1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在开始编写实际的测试之前，应该有几个测试用例(场景)，在其中对SimpleSampleComponent进行测试。因为组件没有太多的东西在运行，所以没有太多的东西需要测试。</p><p id="8928" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以测试以下几个方面；组件的默认行为当包装显示测试组件时，单击按钮将发出预期的值，被单击的禁用按钮不会发出事件，并且在组件初始化后更改输入将相应地更新组件。</p><p id="ce98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这些要测试的场景，下面是要检查的测试用例列表。</p><pre class="kj kk kl km gt mm ma mn mo aw mp bi"><span id="2b1d" class="kz la in ma b gy mq mr l ms mt">#01 - undefined inputs, show default title<br/>#02 - someBoolean true, click right button, event is "right"<br/>#03 - default inputs, try click right button, event is ""<br/>#04 - some title updated, span displays specific title<br/>#05 - default inputs, click left button, event is "left"<br/>#06 - update someTitle input after first shown, show updated title</span></pre><h2 id="4dc5" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">更新测试配置</h2><p id="4746" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在已经有了一个TestWrapperComponent和一个测试用例列表，我们可以配置spec文件进行测试了。当Angular生成一个规格文件时，<code class="fe lx ly lz ma b">component</code>和<code class="fe lx ly lz ma b">fixture</code>变量被设置为SimpleSampleComponent类型。</p><p id="852d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于测试包装器模式，我们将设置类型为TestWrapperComponent。在每个测试用例之前调用的函数<code class="fe lx ly lz ma b">beforeEach()</code>中，使用TestBed类重新创建夹具。还必须更新该重置以使用TestWrapperComponent而不是SimpleSampleComponent。TestWrapperComponent必须通过TestBed <code class="fe lx ly lz ma b">configureTestingModule()</code>函数在测试配置集中声明。</p><h2 id="e8f5" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">编写测试用例</h2><p id="78d0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一旦您设置了配置，就可以编写测试用例了。SimpleSampleComponent基本上有两种类型的测试用例。一个测试组件中显示的标题，另一个测试基于组件状态的按钮点击所产生的事件。</p><p id="d00e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这两种情况下，fixture的调试属性<code class="fe lx ly lz ma b">nativeElement</code>用于查询包装器组件元素，以获取将在DOM中呈现的内容。可以使用<code class="fe lx ly lz ma b">querySelector()</code>或<code class="fe lx ly lz ma b">querySelectorAll()</code>函数查询<code class="fe lx ly lz ma b">nativeElement</code>，就像浏览器中页面上的<code class="fe lx ly lz ma b">document</code>。</p><p id="99da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当测试一个特定的标题出现在DOM中时，在<code class="fe lx ly lz ma b">querySelector()</code>中使用一个CSS选择器来抓取一个元素。然后，被查询元素的<code class="fe lx ly lz ma b">innerHTML</code>字符串值被修整，并对照预期值进行检查。</p><p id="b96b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于按钮测试，CSS选择器将用于获取ButtonElement。button元素有一个在其上执行的<code class="fe lx ly lz ma b">click()</code>，并且有一个值将由TestWrapperComponent发出和处理。</p><p id="ea49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是完整的spec文件，带有TestWrapperComponent、配置集和所有实现的测试用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Completed spec file with Test Wrapper pattern.</figcaption></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="9dcf" class="mu la in bd lb mv mw mx le my mz na lh nb nc nd lk ne nf ng ln nh ni nj lq nk bi translated">结果</h1><h2 id="768e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">Karma浏览器</h2><p id="b93f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在可以用<code class="fe lx ly lz ma b">npm test</code>命令运行测试了。从样板Angular项目中运行这个命令将启动Karma test runner并打开一个浏览器。浏览器将显示以下内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/36899c0500afd90be4d58917d19f8664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cwNkyoIG7WaBxpP_Hl4hA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Karma test runner in Chrome Browser.</figcaption></figure><h2 id="ec94" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">代码覆盖率</h2><p id="1e29" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">也可以使用命令<code class="fe lx ly lz ma b">ng test --no-watch --code-coverage</code>检查测试的测试覆盖率。当命令在命令行中运行时，组件具有100%的语句覆盖率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/64de74ec313a60f154fbf6940d1bc868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGmqgHM8mRBav0cb0Hi2jA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Code coverage report for tests.</figcaption></figure><h1 id="0653" class="mu la in bd lb mv nn mx le my no na lh nb np nd lk ne nq ng ln nh nr nj lq nk bi translated">结论</h1><p id="d425" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">编写单元测试是保护应用程序在重构时不引入错误的好方法。Angular为用Jasmine framework和Karma test runner编写测试提供了一个很好的样板。在测试中使用测试包装器模式是全面测试组件生命周期的好方法，并且可以轻松测试父组件的变化将如何影响您正在测试的组件。</p><p id="882e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下次生成组件时，尝试使用该模式。祝你好运，并快乐编码！</p><p id="8dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ns">更多内容请看</em><a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ns">plain English . io</em></strong></a></p></div></div>    
</body>
</html>