<html>
<head>
<title>Building a Sentiment Analysis App with React, Flask, and Tesseract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React、Flask和Tesseract构建情感分析应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/full-stack-sentiment-analysis-application-with-react-flask-and-tesseract-ea2de9200169?source=collection_archive---------14-----------------------#2021-01-12">https://javascript.plainenglish.io/full-stack-sentiment-analysis-application-with-react-flask-and-tesseract-ea2de9200169?source=collection_archive---------14-----------------------#2021-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f7bd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个全栈的基于人工智能的web应用，有一个React前端和一个Flask后端</h2></div><p id="3e9c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大家好，在这篇文章中，我将尝试用React前端和Flask后端演示一个基于全栈人工智能的web应用程序。这个项目几乎所有的前端代码都来自<a class="ae ky" href="https://github.com/stacksapien/react-tesseract-ocr" rel="noopener ugc nofollow" target="_blank">这个</a>库，所以不要忘记继续下去，并在项目的原始OCR React代码上打个星号。实际上，正如你所看到的项目的<a class="ae ky" href="https://github.com/eren23/react-tesseract-ocr" rel="noopener ugc nofollow" target="_blank">最终版本</a>也是React repo的一个分支，我只是添加了后端和情绪分析，改变了文件夹结构，并重新构建了项目。</p><p id="fdbe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个项目的最终目标是向你展示，你可以使用来自牛逼社区的完美设计的开发人员友好的工具来解决CS中一些真正困难的问题，如果你基本上不想的话，你不必弄脏你的手。</p><p id="bc5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不会在本教程中逐行解释代码，相反，我会简单解释每个部分是如何工作的，然后你就会有一个在AI支持下创建类似图像基础情感分析应用程序的基础图像。</p><h1 id="712c" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">反应和镶嵌</h1><p id="c888" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">正如我在上面解释的那样，我不会带您完成应用程序的每一步，但是，我将解释如何获得这些代码并让它在您自己的本地环境中运行。</p><p id="26a2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要克隆回购协议，我们可以从这里的<a class="ae ky" href="https://github.com/eren23/react-tesseract-ocr" rel="noopener ugc nofollow" target="_blank">最终版本</a>链接获得它(同上)，然后我们可以下载zip版本或者你可以通过git克隆它。</p><p id="f519" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，文件夹结构应该如下图所示。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/742d9329c0c51c02628077e1c34032e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/0*SkDfCpSu9z6bdcHl.png"/></div></figure><p id="a354" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该先安装npm包，因为我们可以进入“react-tesseract-ocr”文件夹并运行以下命令:</p><p id="2ae1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe me mf mg mh b">npm install</code></p><p id="6ba4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，如果一切正常，我们应该会看到如下所示的页面。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/2c54ab9ca84f1b6b0e086acbeacd81f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S0fGD2MX2PIPtJOv.png"/></div></div></figure><p id="4ae5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，在这个页面上，我们可以对任何我们想尝试的图像运行OCR(光学字符识别)。OCR作为一个概念实际上相当复杂，从头开始运行这样一个项目绝对是一场噩梦(至少如果你像我一样没有太多经验的话)。我们分叉的回购使用谷歌的宇宙魔方库，这基本上为我们自动化了所有的OCR过程，实际上是原始宇宙魔方的JS端口。</p><p id="2fa7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将为教程改变的唯一地方是下面的这一部分。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="aba3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这部分是React项目的原作者用来打印从图片中提取的文本的地方。为了提取，我们使用Google的Tesseract库的JS版本。如果你想了解更多关于tesseract.js的信息，你可以点击这里的链接<a class="ae ky" href="https://golb.hplar.ch/2019/07/ocr-with-tesseractjs.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b6f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用对端口8080的给定端点的“POST”请求替换了这一部分，并将提取的文本添加到请求体中。</p><p id="9039" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从那时起，我们可以快速转移到我们的后端。</p><h1 id="a182" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">Flask和朴素贝叶斯</h1><p id="9c7c" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">为了简单起见，我还移到了我们通常获取数据和训练模型的部分。通常，这应该是这样一个项目的痛苦部分，我并不想用我的方法来否认这个事实。事实上，你可以通过使用<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/how-to-perform-sentiment-analysis-in-python-3-using-the-natural-language-toolkit-nltk" rel="noopener ugc nofollow" target="_blank">链接</a>中的教程来训练你自己的模型。我个人前段时间也是这么做的。</p><p id="6944" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以为了运行后端，我们在Python环境中安装了两个依赖项，<a class="ae ky" href="https://anaconda.org/anaconda/nltk" rel="noopener ugc nofollow" target="_blank"> nltk </a>和<a class="ae ky" href="https://anaconda.org/anaconda/flask" rel="noopener ugc nofollow" target="_blank"> Flask </a>来自以下链接(它们是conda指南，因为我在本地环境中使用Anaconda。如果你想了解更多关于蟒蛇的信息</p><p id="bd5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所看到的，我们的模型位于“情绪-后端”文件夹的根目录下。当我们拥有了所有的依赖项之后，运行服务器就非常容易了。我们所需要做的就是运行“python server.py ”,我们的服务器就应该启动并运行了。</p><p id="343f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我现在将带您浏览我们的服务器代码。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="cbf1" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated"><strong class="ak">进口</strong></h1><p id="996a" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这是我们导入的服务器代码，前两行是Flask服务器需要的，但第三行稍微复杂一点，因为我们要发送一个POST请求，我们需要通过从flask_cors导入CORS来启用跨源资源共享。Pickle是用来读取我们的模块的，remove_noise是一个从传入的文本中删除不必要甚至危险无用数据的功能，它将帮助我们更好地做出决定。work_tokenize是一个用于标记输入文本的模块，是一个非常常用的机器学习实践，如果你想了解更多信息，可以查看这里的<a class="ae ky" href="https://www.guru99.com/tokenize-words-sentences-nltk.html" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="b30e" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated"><strong class="ak"> Inits </strong></h1><p id="f6c1" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们导入ML模型，创建Flask app对象并启用CORS。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="5e27" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated"><strong class="ak">端点和服务器运行</strong></h1><p id="8f7e" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在我们用前面的步骤准备好一切之后，现在我们可以用Flask装饰器创建我们的API端点。这个装饰器主要做的是把我们的“home”函数变成一个API端点，在我们的例子中，同一个地址接受GET和POST请求。</p><p id="d5e3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当一个请求到达我们的端点时，我们检查它是否是POST请求，如果是，我们现在尝试从请求体中获取我们的句子。</p><p id="835d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于上面解释的原因，在我们有了句子之后，我们去除噪音并标记它们。</p><p id="2d44" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以检查句子的上下文是否定的还是肯定的，然后返回结果。</p><p id="f4d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以运行必要的代码，用run和keep_alive函数运行我们的Flask服务器。</p><h1 id="371c" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">测试我们的系统</h1><p id="7e86" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我在前端目录中添加了1个正面和1个负面的包含图像的文本。我们现在可以直接从UI中选择其中一个。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/90de4bda51aaa2691ad31763652a0d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0633r84L2PGNXlNx.png"/></div></div></figure><p id="70c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们选择我们的图像应用OCR和情感分析后，我们的React应用程序自动开始进行OCR，在一切都解决后，如果我们的系统可以提供一个有意义的文本，我们就可以收到服务器的响应。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mq"><img src="../Images/818b2d70f0ff5a27bf9045aa005d522e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qEYqGrEHR66X1cnQ.png"/></div></div></figure><p id="e793" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在下面看到的，我们的系统能够理解我们的图像包含一个正面的文本。现在我们来试试一个不好的。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mq"><img src="../Images/5c242709ba6b20a30b77dad8a431f2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6xP78HkLhQbODvTW.png"/></div></div></figure><p id="b53b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它说它是阴性的，我同意。我的意思是，我可能会吸，但不是这个模型迄今为止:p。</p><p id="cd43" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mr">注:我故意使用我制作的那些简单图像，因为我不想处理任何侵犯版权的事情。请随意继续，并尝试用更复杂的图像。</em></p><p id="3a3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这些大家，希望这个教程对你有帮助，我真的相信这次会对很多人很有用。</p><p id="e992" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下次再见，保重。:)</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="80ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mr">最初发表于</em><a class="ae ky" href="https://blog.akbuluteren.com/blog/fullstack-sentiment-analysis-app-react-flask-tesseract" rel="noopener ugc nofollow" target="_blank">T5【https://blog.akbuluteren.com】</a><em class="mr">。</em></p><p id="f97d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mr">在</em><a class="ae ky" href="https://margin.io/blogs" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://margin.io/blogs</em></a>结账加密相关物品</p></div></div>    
</body>
</html>