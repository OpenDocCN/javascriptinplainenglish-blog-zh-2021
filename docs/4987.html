<html>
<head>
<title>React vs Vue.js from a Developer Friendliness Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从开发者友好的角度看React与Vue.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-vs-vuejs-from-a-developer-friendliness-perspective-a67684bc2465?source=collection_archive---------12-----------------------#2021-10-08">https://javascript.plainenglish.io/react-vs-vuejs-from-a-developer-friendliness-perspective-a67684bc2465?source=collection_archive---------12-----------------------#2021-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b9dd52be79bcb41aa720f5380832ef89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mM9H24rqtQw5nCIlklGqFA.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@berkaygumustekin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Berkay Gumustekin</a> on <a class="ae ja" href="https://unsplash.com/s/photos/friendly?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="2300" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我经常在我的feed文章中看到有人声称一些被大量使用的库(通常是React或Angular)是宇宙中所有邪恶的来源。或者相反，一个图书馆(Vue.js，Svelte，或者通常是一个新的图书馆)是治愈人类所有开放性创伤的灵丹妙药。</p><p id="47ec" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管存在明显的愚蠢和歇斯底里，但对于那些以帮助开发人员完成任务为唯一目的的工具来说，批判性分析总是一件好事，有时这些文章有好的观点，即使隐藏在一层愚蠢的断言评论之下。有一篇文章的座右铭是“停止使用React”或类似的东西，这让我想到，不久前，当我每天使用React时，为什么有人会不喜欢它？</p><p id="c5b5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">过去五年来，我一直是React的开发者，来自<em class="ky"> Angular.js </em> (Angular 1.x)世界。最近，由于花了一些时间(可能是受这篇文章引发的想法的影响)，我一直在转向Vue.js，这是我目前工作的首选框架，也是我以前选择使用的框架。我在日常使用Vue.js时得到的印象是，在它的帮助下编码感觉比React更“流畅”。作为一个程序员，我尽力去找出我为什么会有这种感觉，所以我有一个关于它的小理论。</p><h1 id="2f97" class="kz la jd bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">举起干草叉</h1><p id="f32a" class="pw-post-body-paragraph ka kb jd kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">我在这里不是说Vue.js比React“更好”,这是愚蠢的，因为它符合上述歇斯底里的文章之一。然而，我想说的是，尽管这两种解决方案对于它们计划要做的事情和它们的(稍微不同的)理想用例来说都很棒，但是随着时间的推移，我清楚地看到React有一点问题。这个问题无论如何都不是不可克服的，我认识的大多数人都很好地解决了这个问题。此外，它可能会影响我，尤其是因为我对代码可读性问题很敏感(请关注未来关于这方面的文章)。</p><p id="fcd1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事情是这样的，React用所谓的“钩子”拥抱了异步函数式编程。这完全没问题，事实上，我喜欢函数式编程，因为我认为它使事情变得更简单，类通常是不必要的抽象。然而，我认为在编写和命名内置“钩子”来处理函数中应用程序的渲染周期时，存在某种夸大的乐观情绪。它们感觉不均匀，比它们本来应该的更不光滑。我是如此渴望摆脱React中的类，以至于我尽可能快地接受了hooks/FP语法。然而，随着时间的推移，我觉得逃课的收获在其他地方消失了。但是在哪里？</p><p id="e3b4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像，通常冗余有利于友好，但是有冗余的<code class="fe mc md me mf b">useCallback</code>和<code class="fe mc md me mf b">useMemo</code>几乎没有好处。同时，<code class="fe mc md me mf b">useEffect</code>作为<em class="ky">唯一的</em>方法有太多的事情要做，比如跟踪效果，在第一次渲染时触发动作，以及在应用卸载前做一些事情。</p><p id="3bb6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，Vue.js即使在新的Composition API(与React的钩子方向一致)中，也保留了<code class="fe mc md me mf b">watch</code>和所有清晰简单的生命周期方法。事实上，现在这些也可以被认为是类似于“钩子”的东西，它们工作得一样好。</p><h1 id="1dcf" class="kz la jd bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Vue.js和“生活质量”方法</h1><p id="a72b" class="pw-post-body-paragraph ka kb jd kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">Vue.js对组合API所做的事情与他们过去所做的事情有些类似:当<em class="ky"> Angular.js </em> (1.x)彻底改变API成为<em class="ky"> Angular.io </em> (2+)时，Angular团队说这是其速度优化的必要步骤，Vue.js 1成为Vue.js 2，进行了类似的优化，但基本上保持了完全相同的API。</p><p id="a223" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在React改变为更加面向FP的语法并彻底改变其方式后，Vue.js已经改变为保持不止一种而是两种有效的编写应用程序的方式:“传统的”<em class="ky"> Options API </em>，更具声明性，以及新的<em class="ky"> Composition API </em>，更像FP并且可分离。除了后者提供了新的可能性，它们提供了基本相同的东西，在它们之间切换通常很容易，最重要的是，它们保留了我们如何编写应用程序的相同数量的良好冗余，这是我一直喜欢Vue的一点。</p><p id="8092" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我记得我第一个真正的app在Vue.js，是从另一个开发者那里继承来的app。我不得不扩展它，所以我很快去找了文档，得到了最基本的东西，然后我写了一些东西，它就工作了。当我最终学会了做同样事情的更多方法时，我发现我最初使用的方法仍然有效，而且很好。在React中，做事情的方式要么是<em class="ky">单向的，要么是高速公路</em> …当然是通往外部库的高速公路，这种高速公路有很多，很多人甚至认为这是一种更好的方法。就我而言，我更喜欢Vue为我提供内置选项的方式。</p><p id="f56b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">拥有“选项”意味着它有许多从严格的角度来看并不需要的结构，但是当涉及到使开发人员的生活更容易时，它带来了相关的价值。简单的<code class="fe mc md me mf b">emit</code>、<code class="fe mc md me mf b">provide</code> / <code class="fe mc md me mf b">inject</code>、观察器、生命周期方法、计算值、组件之外的反应，所有这些都是工具，可以使用也可以不使用。此外，这些额外的结构并没有使Vue.js比React重很多:事实上React更重，而且在大多数比较中也更慢。</p><h1 id="0193" class="kz la jd bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">反应和极简主义的坏的一面</h1><p id="fc46" class="pw-post-body-paragraph ka kb jd kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">显然，React中可以构建很棒的东西(实际上，它的活跃社区每天都在构建这些东西)。然而，当一个组件试图在几个<code class="fe mc md me mf b">useEffect</code>后面做太多事情时，或者当一个开发人员(渴望优化速度但不确定如何做到这一点)将几乎所有东西都放在<code class="fe mc md me mf b">useCallback</code>或<code class="fe mc md me mf b">useMemo</code>钩子内时，我看到一些React应用遭受代码“分割化”的倾向。看到这一点，甚至还有相当多的代码使用具有竞争条件问题的钩子，我只是有一种预感，人们很难理解内置钩子实际上是如何工作的，对我来说，这是关于lib本身的一些事情，React团队应该考虑作为一个潜在的缺陷来解决。</p><p id="1966" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我首先诊断一下这个问题，与旧的“基于类”的语法相比，我觉得在命名结构上有点缺乏清晰度。例如像<code class="fe mc md me mf b">ComponentDidMount</code>这样的名字，它的意图是非常清楚的，但是<code class="fe mc md me mf b">useCallback</code>不是。事实上，即使是<code class="fe mc md me mf b">useEffect</code>也是一个相当模糊的名字，特别是关于它的许多用例和结构变体，特别是效果所依赖的值的数组和行为类似于卸载钩子的返回值函数。</p><p id="7465" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，大多数React代码只依赖于三或四种类型的结构:<code class="fe mc md me mf b">useState</code>、<code class="fe mc md me mf b">useEffect</code>、<code class="fe mc md me mf b">useMemo</code> / <code class="fe mc md me mf b">useCallback</code>，有时还有<code class="fe mc md me mf b">useRef</code>。当然，还有其他的挂钩和可能性，但它们要么只对边缘情况有效，要么没有足够的用处来普及，所以事实证明我们只有这四种。虽然我重视极简主义，但我觉得在这种情况下，我们得到了两个世界最糟糕的结果，因为API太不清晰，无法从它的精简中受益。难怪为了尽可能兼容React而设计的framework <a class="ae ja" href="https://www.solidjs.com/" rel="noopener ugc nofollow" target="_blank"> Solid </a>为它的“钩子”选择了完全不同的命名方案，并且还有生命周期方法。</p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="11ce" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">顺便提一句，</em> <code class="fe mc md me mf b"><em class="ky">useContext</em></code> <em class="ky">甚至可能有用，但我经常看到它的使用(通常用于全局状态)导致代码感觉杂乱，更重要的是，非常难以阅读。我认为，所有写文章讨论放弃Redux而使用React context支持全局状态的人都应该三思，因为Redux肯定会导致许多样板文件，但最终，它仍然比使用上下文来承载全局存储更有意义。不过，在我看来，这些人可能只是想要一个即插即用的通用状态，而没有Redux带来的样板文件，也没有四处传递道具的混乱。有很多解决方案，但由于某种原因，它们似乎都不受欢迎。React以牺牲一些额外的库字节为代价提供一个内置的解决方案可以吗？</em></p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="e7d2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">依我拙见，在设计这个“钩子”API时，React团队开发了一些太低的内部机制级别的东西，因此它反映了太多的内部工作方式，而不是专注于开发人员的工作流。获得了透明性，<strong class="kc je">可用性是代价</strong>。</p><p id="9c10" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在这篇文章的开始所说的“流动”是指:不那么严格，更友好，所以当给定我们在时间、焦点甚至技能方面的有限环境时，开发人员可以感到更轻松，并产生更好的代码。有了Vue.js，我才知道这是可以实现的。</p><h1 id="cab4" class="kz la jd bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="ca51" class="pw-post-body-paragraph ka kb jd kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">抛开React在采用、工具和库方面的优势不谈，React当前的API在我看来并不支持Vue，也不容易在日常生活中处理，尽管它更精简。我不认为任何人希望React简单地变成Vue.js的克隆，但如果它朝着友好迈出一些小步，肯定会有所帮助。</p><p id="5737" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae ja" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc je"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>