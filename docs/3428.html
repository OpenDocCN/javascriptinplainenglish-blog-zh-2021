<html>
<head>
<title>How to Solve Common JavaScript Coding Challenges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决常见的JavaScript编码挑战</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-stringing-along-and-some-easy-coding-challenges-to-practise-ea3f028299a4?source=collection_archive---------10-----------------------#2021-07-11">https://javascript.plainenglish.io/javascript-stringing-along-and-some-easy-coding-challenges-to-practise-ea3f028299a4?source=collection_archive---------10-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9214" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">您可以使用的常见字符串函数，以及在JavaScript中涉及字符串操作的编码挑战</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/19c02d2c8510fa63a994cb66bea30cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZgiKCyVLJ05TZ1mT.jpg"/></div></div></figure><p id="15d3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">有时你只想要一个角色。是的，你喜欢保持简单。</strong>从指定索引处的字符串中获取单个字符:</p><p id="59b7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io"> <em class="ll"> charAt(索引)</em> </strong></p><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="74eb" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">getInitials</strong> (firstName, lastName) {</span><span id="24ea" class="lr ls in ln b gy lx lu l lv lw">  return firstName.<strong class="ln io">charAt</strong>(0) + lastName.<strong class="ln io">charAt</strong>(0);</span><span id="27d2" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="8d1b" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// Example: getInitials('Charles', 'Boyle') should return 'CB'.</em></span></pre><p id="7b3a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">用更多的琴弦连接琴弦</strong>。</p><ul class=""><li id="e3de" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">`$ { string go } $ { string two }</strong></li><li id="9735" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated"><strong class="kr io"> concat(分离器)；</strong></li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="ba86" class="lr ls in ln b gy lt lu l lv lw">const first_name = ‘Joe’;</span><span id="a0fa" class="lr ls in ln b gy lx lu l lv lw">const last_name = ‘Booboo’;</span><span id="bcee" class="lr ls in ln b gy lx lu l lv lw">const fullName = first_name.<strong class="ln io">concat</strong>(‘ ‘, last_name);</span><span id="0e14" class="lr ls in ln b gy lx lu l lv lw">const fullNameV2 = first_name + “ “ + last_name;  // nobody likes this way anymore, people will judge you</span><span id="110c" class="lr ls in ln b gy lx lu l lv lw">const fullNameV3 = `${first_name} ${last_name}`; // the new cool way</span></pre><p id="ac56" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">对于所有敏感人群，尤其是区分大小写:<strong class="kr io">我们可以使用大写或小写字符串:</strong></p><ul class=""><li id="128a" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">to ppercase()；</strong></li><li id="b704" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated"><strong class="kr io">tolower case()；</strong></li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="ec3f" class="lr ls in ln b gy lt lu l lv lw">const string = ‘dont shout at me’;</span><span id="6179" class="lr ls in ln b gy lx lu l lv lw">const uppercase = string.<strong class="ln io">toUpperCase</strong>();</span><span id="3e2c" class="lr ls in ln b gy lx lu l lv lw">const string2 = ‘OK IM SORRY’;</span><span id="3823" class="lr ls in ln b gy lx lu l lv lw">const lowercase = string2.<strong class="ln io">toLowerCase</strong>();</span></pre><p id="bca5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">在找什么？询问indexOf，它会告诉您它在字符串中找到的索引或位置。如果它找不到它，它将返回-1。</strong></p><ul class=""><li id="ac5b" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">。</strong>的索引(searchString，其中indexto startlookingat<strong class="kr io">)</strong></li><li id="8b7c" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">返回找到的索引或-1</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="7945" class="lr ls in ln b gy lt lu l lv lw">const string = “I love cats.”;</span><span id="b430" class="lr ls in ln b gy lx lu l lv lw">const searchFor = “cats”;</span><span id="822a" class="lr ls in ln b gy lx lu l lv lw">const result = string.indexOf(searchFor); // Result is 7 (YES WE FOUND IT!!!)<br/></span></pre><p id="8a0b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">你想要一根绳子吗？</strong> AKA子串？这个非常直观，它叫做substr()</p><ul class=""><li id="e142" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">。子字符串</strong> (startIndex，endIndex)</li><li id="141a" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">第一个参数指定开始提取的位置。</li><li id="b4a8" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">第二个参数指定要提取的字符数。</li><li id="e939" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">如果未设置第二个参数，则从字符串的开始位置到结束位置的所有字符都将被提取。</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="384e" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">getUsernameFromEmail</strong> (string) {</span><span id="e2c6" class="lr ls in ln b gy lx lu l lv lw">  const indexOfSymbol = string.<strong class="ln io">indexOf</strong>(‘@’);</span><span id="53f3" class="lr ls in ln b gy lx lu l lv lw">  return string.<strong class="ln io">substr</strong>(0, indexOfSymbol);</span><span id="fa26" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="4f51" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">getUsernameFromEmail</strong>(‘jumanah@gmail.com’) <em class="ll">// output: jumanah</em></span></pre><p id="bafd" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">需要用别的东西替换你绳子上的坏东西..你明白了…替换()</strong></p><ul class=""><li id="dbdd" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">代替()</strong></li><li id="984e" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">第一个参数是要替换的内容</li><li id="dea6" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">第二个参数是替换文本</li></ul><p id="462c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">*仅替换第一个匹配项..需要多次链接，尽管有replaceAll(需要更新本文)</p><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="3e95" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">formatDate</strong>(date) {</span><span id="bcdc" class="lr ls in ln b gy lx lu l lv lw">  let newDate = date.<strong class="ln io">replace</strong>(‘-’, ‘/’).<strong class="ln io">replace</strong>(‘-’, ‘/’);</span><span id="44c2" class="lr ls in ln b gy lx lu l lv lw">  return newDate;</span><span id="a670" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="6455" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// Example: </em><strong class="ln io">formatDate</strong><em class="ll">('20-05-2017') will return '20/05/2017'.</em></span></pre><p id="3fd4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">你有强迫症吗？<strong class="kr io">你讨厌文本周围的多余空间吗？不要再说了，将它们连同装饰一起移除()；</strong></p><ul class=""><li id="7692" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">修剪()；</strong></li><li id="7e96" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">删除字符串周围的空白，而不是其中的空白</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="6397" class="lr ls in ln b gy lt lu l lv lw">const searchString = ‘animals in australia  ‘</span><span id="7021" class="lr ls in ln b gy lx lu l lv lw">function <strong class="ln io">searchName</strong>(name) {</span><span id="6a1b" class="lr ls in ln b gy lx lu l lv lw">   name.<strong class="ln io">trim</strong>(); // output: 'animals in australia'</span><span id="9d30" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">  // .. GET request or somethang</em></span><span id="9296" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="97c9" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">searchName(</strong>searchString); </span></pre><p id="a3b7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">将字符串转换为数组</strong>。如果您想对字符串中的每个字母重复某个操作，您可能需要这样做。</p><ul class=""><li id="da95" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">。拆分(“分隔符”)；</strong></li><li id="e284" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated"><strong class="kr io">[…弦] </strong></li><li id="0e47" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated"><strong class="kr io">array . from()；</strong></li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="7048" class="lr ls in ln b gy lt lu l lv lw">const sentence = ‘i was not stringing him along’;<br/>const string = ‘word’;<br/></span><span id="9215" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// Option 1: Using Split(), provide the seperator as an argument, here we can use space<br/></em>var array = sentence.<strong class="ln io">split</strong>(‘ ’); <em class="ll">// output: [‘i’, ‘was’, ‘not’, ‘stringing’, 'him', 'along'];</em></span><span id="2f9d" class="lr ls in ln b gy lx lu l lv lw"><em class="ll"><br/>// Option 2: Using ... spread syntax<br/></em>var array = […string]; <em class="ll">// output: [‘w’, ‘o’, ‘r’, ‘d’]</em></span><span id="7df7" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// Option 3: Using Array.from<br/></em>var array = <strong class="ln io">Array</strong>.<strong class="ln io">from</strong>(string); <em class="ll">// output: [‘w’, ‘o’, ‘r’, ‘d’]</em></span></pre><p id="8d0d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">将数组转换为字符串！</strong>你可能想用一个数组组成一个句子，或者将字符串连接到一个数组中</p><ul class=""><li id="e215" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated"><strong class="kr io">连接(‘分离器’)；</strong></li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="6979" class="lr ls in ln b gy lt lu l lv lw">const newStringFromArray = [‘Twas’, ‘the’, ‘night’, ‘before’, ‘Christmas’].<strong class="ln io">join</strong>(‘ ‘);</span><span id="77bd" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// output: ’Twas the night before Christmas’</em></span><span id="69b8" class="lr ls in ln b gy lx lu l lv lw">const newStringUrlFromArray = [‘masteringjs.io’, ‘tutorials’, ‘fundamentals’, ‘string-concat’].<strong class="ln io">join</strong>(‘/’);</span><span id="1be3" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// output: ‘masteringjs.io/tutorials/fundamentals/string-concat’</em></span></pre><p id="7ff1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">你喜欢颠倒的东西，还是相反的东西？:D</p><p id="6c10" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">请继续关注下面的编码挑战！</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="abf4" class="mt ls in bd mu mv mw mx my mz na nb nc jt nd ju ne jw nf jx ng jz nh ka ni nj bi translated"><strong class="ak">【EASY】编码挑战，字符串操作#1:反转字符串</strong></h1><p id="9e2d" class="pw-post-body-paragraph kp kq in kr b ks nk jo ku kv nl jr kx ky nm la lb lc nn le lf lg no li lj lk ig bi translated">所以要反转一个字符串，我们要讨论字符串中的所有字符，可能是一个单词，也可能是一个完整的句子。我马上想到了一些主意…</p><ul class=""><li id="f800" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">想法一:如果我们做一个从字符串末尾到开头的循环会怎么样？！</li><li id="3432" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated"><strong class="kr io">想法二:</strong>如果我们以前用<strong class="kr io"> reverse() </strong> …但是它只对数组有效呢..嗯..我们如何才能做到这一点。</li></ul><p id="7c16" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">好的..让我们发展这些想法</p><p id="73c0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">创意1:反向循环</strong></p><p id="fbaa" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">复杂度:o(n)我们对字符串中的每一项循环一次</p><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="1390" class="lr ls in ln b gy lt lu l lv lw"><strong class="ln io">function reverseString(str) {</strong></span><span id="dad7" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io"> </strong> let output = ''; </span><span id="7394" class="lr ls in ln b gy lx lu l lv lw"><br/>  // loop from the very last element in the array all the way to 0 (the first element) </span><span id="3521" class="lr ls in ln b gy lx lu l lv lw">  for (let i = str.length-1; i &gt;= 0; i--) {</span><span id="8d62" class="lr ls in ln b gy lx lu l lv lw">     // add letters from the back of the string to the start of this new string</span><span id="d5b8" class="lr ls in ln b gy lx lu l lv lw">     output += str[i];   // p, po, poo, pool<br/> </span><span id="264a" class="lr ls in ln b gy lx lu l lv lw"> <strong class="ln io"> </strong>}</span><span id="8c8e" class="lr ls in ln b gy lx lu l lv lw">  return output;</span><span id="0808" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">}</strong></span><span id="03fb" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">reverseString('loop'); // output: pool</strong></span></pre><p id="a8b2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">想法二:<strong class="kr io">内置方法，reverse() </strong></p><ul class=""><li id="1799" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">首先，我们需要将整个字符串转换成一个单独字符的数组，以利用reverse()；反转数组的函数！</li><li id="4184" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">然后我们把数组转换回字符串！简单的柠檬挤在一条线上。</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="adc4" class="lr ls in ln b gy lt lu l lv lw"><strong class="ln io">function reverseString(str) {</strong></span><span id="e128" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// convert to an array, reverse the array and then join</em></span><span id="ef45" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">  return str.split("").reverse().join("");</strong></span><span id="8cf6" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="33d3" class="lr ls in ln b gy lx lu l lv lw"><strong class="ln io">reverseString</strong>("love"); // 'evol'  YUP JUST LIKE EMINEM SAID!!!</span></pre></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="e4fe" class="mt ls in bd mu mv mw mx my mz na nb nc jt nd ju ne jw nf jx ng jz nh ka ni nj bi translated">[简单]编码挑战，字符串操作#2: Pangram</h1><ul class=""><li id="3a7a" class="ly lz in kr b ks nk kv nl ky np lc nq lg nr lk md me mf mg bi translated">盘符是一个包含字母表中所有26个字母的句子</li><li id="8c8f" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">给定一个字符串输入，找出该字符串是否是一个盘符，并返回true或false</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="b0df" class="lr ls in ln b gy lt lu l lv lw">function isPangram(str) {</span><span id="b80b" class="lr ls in ln b gy lx lu l lv lw">}</span></pre><p id="3eed" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">好吧，让我们一起<strong class="kr io">想想这个:</strong></p><ul class=""><li id="2d3d" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">可以使用正则表达式来检测一个字符是否属于一个字母表，或者你可以自己定义字母表(不需要)</li><li id="dc9d" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">显然，句子需要至少26个字符才能满足这个要求</li></ul><p id="6419" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那么我们的<strong class="kr io">伪码</strong>是什么呢..还是我们的策略？我们可以把它写在代码的注释中</p><ul class=""><li id="3fd1" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">我们可以使用一个集合或一个散列来存储我们遇到的所有独特的字母。如果这是一个七巧板，应该有26个字母</li><li id="9c1a" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">定义一个正则表达式来查找字母字符</li><li id="de85" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">将字符串转换成小写，这样我们就不会有大小写问题了</li><li id="d1d7" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">如果字符串小于26个字符，就不用循环了</li><li id="bdfc" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">遍历字符串中的所有字符，检查它是否是字母表的一部分</li><li id="a974" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">使用我们的正则表达式，如果字符在字母表中，我们将它添加到我们的集合中(我们的集合将忽略重复的)</li><li id="dba8" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">如果我们的集合的大小或长度为26(与字母表相同)，这意味着我们返回true，否则，我们返回false。</li></ul><p id="9f9d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">解决方案1:使用集合和正则表达式</strong></p><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="d223" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">isPangram</strong>(string) {</span><span id="b8d4" class="lr ls in ln b gy lx lu l lv lw"> // Convert to lowercase<br/> string = string.<strong class="ln io">toLowerCase</strong>();</span><span id="060f" class="lr ls in ln b gy lx lu l lv lw"><em class="ll"> // Define our set which will store the alphabet<br/> </em>let uniqueLetters = new <strong class="ln io">Set</strong>();</span><span id="3262" class="lr ls in ln b gy lx lu l lv lw"><em class="ll"> // Define our regex to test for alpha characters<br/> </em>const regex = /[a-z]g/;</span><span id="b58b" class="lr ls in ln b gy lx lu l lv lw"><em class="ll"> // Short circuit - not enough characters<br/> </em>if (string.length &lt; 26) {</span><span id="1d99" class="lr ls in ln b gy lx lu l lv lw">  return false;</span><span id="de29" class="lr ls in ln b gy lx lu l lv lw"> }</span><span id="3ddf" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">  // Loop through all characters in the string to check if it is part of the alphabet</em></span><span id="2732" class="lr ls in ln b gy lx lu l lv lw"> for (let i = 0; i &lt; string.length; i++) {</span><span id="b3ea" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">   // using our regex, if character is in the alphabet, we add it to our set (our set will ignore duplicates)</em></span><span id="7bf8" class="lr ls in ln b gy lx lu l lv lw">   if (regex.<strong class="ln io">test</strong>(string[i])) {</span><span id="2d77" class="lr ls in ln b gy lx lu l lv lw">      uniqueLetters.<strong class="ln io">add</strong>(string[i]); <em class="ll">// store it in our set</em></span><span id="1b46" class="lr ls in ln b gy lx lu l lv lw">   }</span><span id="80e1" class="lr ls in ln b gy lx lu l lv lw"> }</span><span id="5e0e" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">// if our set has a size or length of 26 (same as the alphabet) it means we return true, otherwise, we return false.</em></span><span id="6385" class="lr ls in ln b gy lx lu l lv lw"> return uniqueLetters.size === 26;</span><span id="573e" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="face" class="lr ls in ln b gy lx lu l lv lw">console.<strong class="ln io">log</strong>(<strong class="ln io">isPangram</strong>('Bawds jog, flick quartz, vex nymphs.')); <em class="ll">// true</em></span><span id="e1f6" class="lr ls in ln b gy lx lu l lv lw">console.<strong class="ln io">log</strong>(<strong class="ln io">isPangram</strong>('Bawds jog, flick quartz, vex nymphs.')); <em class="ll">// true</em></span><span id="8c9e" class="lr ls in ln b gy lx lu l lv lw">console.<strong class="ln io">log</strong>(<strong class="ln io">isPangram</strong>('Roses are red, violets are blue, sugar is sweet, and so are you.')); <em class="ll">// false</em></span></pre><p id="fe8a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们可以在这个<strong class="kr io">替代</strong>方法中使用散列，而不是在这里使用集合:</p><p id="690a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">解决方案2:使用散列和正则表达式</strong></p><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="c2d2" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">isPangram</strong>(string) {</span><span id="a484" class="lr ls in ln b gy lx lu l lv lw">  let counter = 0;</span><span id="a5e1" class="lr ls in ln b gy lx lu l lv lw">  const hash = {};</span><span id="70c6" class="lr ls in ln b gy lx lu l lv lw">  for (let i = 0; i &lt; string.length; i++) {</span><span id="adc2" class="lr ls in ln b gy lx lu l lv lw">    if (string[i].<strong class="ln io">match</strong>(/[a-z]/i) &amp;&amp; !hash[string[i]]) {</span><span id="a765" class="lr ls in ln b gy lx lu l lv lw">       hash[string[i]] = true;</span><span id="1b8a" class="lr ls in ln b gy lx lu l lv lw">       counter += 1;</span><span id="03b8" class="lr ls in ln b gy lx lu l lv lw">    }</span><span id="2787" class="lr ls in ln b gy lx lu l lv lw">  }</span><span id="75f7" class="lr ls in ln b gy lx lu l lv lw">  return counter === 26;</span><span id="0a6a" class="lr ls in ln b gy lx lu l lv lw">}</span></pre></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="6011" class="mt ls in bd mu mv mw mx my mz na nb nc jt nd ju ne jw nf jx ng jz nh ka ni nj bi translated">[MEDIUM]编码挑战，字符串操作#2: <em class="kc">字谜</em></h1><ul class=""><li id="d486" class="ly lz in kr b ks nk kv nl ky np lc nq lg nr lk md me mf mg bi translated">变位词是通过重新排列不同单词的字母而形成的单词，通常只使用所有原始字母一次。<br/> * cat、act、atc、tca、atc <br/> * listen”和“silent”</li><li id="ee54" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">给定两个字符串输入，找出字符串是否是变位词，并返回true或false</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="ab71" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">areAnagrams</strong>(strA, strB) {</span><span id="95d9" class="lr ls in ln b gy lx lu l lv lw">}</span></pre><p id="2c6d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">好吧，让我们<strong class="kr io">一起想想这个… </strong></p><ul class=""><li id="c86b" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">重排装置..如果我们按字母顺序排列单词，它们在技术上看起来应该是一样的？</li><li id="d115" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">这些字符串需要有相同的长度</li><li id="2d2f" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">如果我们不分类..我们可以试着用哈希……嗯</li></ul><p id="73d4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">解决方案1:按字母顺序排列单词</strong></p><p id="6d52" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那么我们的<strong class="kr io">伪码</strong>是什么呢..还是我们的策略？我们可以把它写在代码的注释中</p><ul class=""><li id="1078" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">我们将字符串都转换成小写</li><li id="d4a3" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们从它们中删除空格(它们不会被处理)..我们可以使用replace()来做到这一点</li><li id="caf1" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们可以通过将两个字符串转换成数组并排序，然后再将它们变回字符串来对它们进行排序</li><li id="8398" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">如果字符串是相同的…他们是字谜！！！</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="d3da" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">areAnagrams</strong>(strA, strB) {</span><span id="842a" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">  // A regex to look for all spaces globally and replace them</em></span><span id="0803" class="lr ls in ln b gy lx lu l lv lw">  const spaceRegex = / /g;</span><span id="64d6" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">  // Convert both strings to lowercase and remove whitespace from them</em></span><span id="848b" class="lr ls in ln b gy lx lu l lv lw">    strA = strA.replace(spaceRegex, "").toLowerCase();<br/>    strB = strB.replace(spaceRegex, "").toLowerCase();</span><span id="b93e" class="lr ls in ln b gy lx lu l lv lw">   // Short circuit.. these strings need to be the same length</span><span id="d53c" class="lr ls in ln b gy lx lu l lv lw">   if (strA.length !== strB.length) {</span><span id="9f3d" class="lr ls in ln b gy lx lu l lv lw">      return false;</span><span id="c926" class="lr ls in ln b gy lx lu l lv lw">   }</span><span id="41b1" class="lr ls in ln b gy lx lu l lv lw"><em class="ll">  // Convert into arrays and sort<br/>  // Return if they are equal</em></span><span id="3da8" class="lr ls in ln b gy lx lu l lv lw">  return strA.<strong class="ln io">split</strong>("").<strong class="ln io">sort</strong>().<strong class="ln io">join</strong>("") ===      strB.<strong class="ln io">split</strong>("").<strong class="ln io">sort</strong>().<strong class="ln io">join</strong>("");</span><span id="5420" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="ad46" class="lr ls in ln b gy lx lu l lv lw"><br/>// Test cases</span><span id="85dd" class="lr ls in ln b gy lx lu l lv lw">console.<strong class="ln io">log</strong>(<strong class="ln io">areAnagrams</strong>("aFdl e  ", "adle F "));  // true<br/>console.<strong class="ln io">log</strong>(<strong class="ln io">areAnagrams</strong>("aFdl e  ", "adle XX ")); // false</span></pre><p id="e438" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">解决方案2:散列和循环</strong></p><p id="53e2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那么我们的<strong class="kr io">伪码</strong>是什么呢..还是我们的策略？我们可以把它写在代码的注释中</p><ul class=""><li id="ce48" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">定义一个散列来存储字母</li><li id="1072" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">将两个字符串都转换成小写，并删除其中的空格</li><li id="5d16" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">短路..这些字符串需要有相同的长度</li><li id="2e31" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">将字符串组合成一个字符串，这样我们就可以循环</li><li id="357d" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">遍历合并后的字符串，将它们添加到哈希中，并记录它们出现的次数</li><li id="98ba" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">检查哈希以查看每个字母是否存在两次以上</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="372d" class="lr ls in ln b gy lt lu l lv lw">function areAnagrams(strA, strB) {</span><span id="63f7" class="lr ls in ln b gy lx lu l lv lw">// Define our hash to store the letters<br/>    let hash = {};</span><span id="119d" class="lr ls in ln b gy lx lu l lv lw">// A regex to look for all spaces globally and replace them<br/>    const spaceRegex = / /g;</span><span id="4c2d" class="lr ls in ln b gy lx lu l lv lw">// Convert both strings to lowercase and remove whitespace from them<br/>    strA = strA.replace(spaceRegex, "").toLowerCase();<br/>    strB = strB.replace(spaceRegex, "").toLowerCase();</span><span id="4d24" class="lr ls in ln b gy lx lu l lv lw">// Short circuit.. these strings need to be the same length<br/>    if (strA.length !== strB.length) {<br/>        return false;<br/>    }<br/>    <br/>    // Combine the strings into one string<br/>    const combinedString = strA.concat(strB);</span><span id="a5af" class="lr ls in ln b gy lx lu l lv lw">// Loop through the combined string and add them to the hash<br/>    for (let i = 0; i &lt; combinedString.length; i++) {</span><span id="9b5f" class="lr ls in ln b gy lx lu l lv lw">// if it doesn't already exist in the hash<br/>        if (!hash[combinedString[i]]) {<br/>            // add it to the hash with a value of 1<br/>            hash[combinedString[i]] = 1;<br/>        } else {<br/>            // update the occurrence<br/>            hash[combinedString[i]] += 1; <br/>        }<br/>    }</span><span id="5f02" class="lr ls in ln b gy lx lu l lv lw">// Now if it is an anagram, each letter in our hash will occur at least twice<br/>    for (let [key, value] in hash) {<br/>        if (value &lt; 2) {<br/>            return false;<br/>        }<br/>    }</span><span id="61f2" class="lr ls in ln b gy lx lu l lv lw">return true;<br/>    <br/>}</span></pre></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="effa" class="mt ls in bd mu mv mw mx my mz na nb nc jt nd ju ne jw nf jx ng jz nh ka ni nj bi translated">[MEDIUM]编码挑战，字符串操作#2:回文</h1><ul class=""><li id="153f" class="ly lz in kr b ks nk kv nl ky np lc nq lg nr lk md me mf mg bi translated">回文是一个单词或句子，前后读起来都一样</li><li id="9543" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">给定一个字符串输入，找出该字符串是否为回文，并返回true或false</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="2f38" class="lr ls in ln b gy lt lu l lv lw">function <strong class="ln io">isPalindrome</strong>(string) {</span><span id="50ca" class="lr ls in ln b gy lx lu l lv lw">}</span></pre><p id="4b34" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">好吧，让我们<strong class="kr io">一起想想这个… </strong></p><ul class=""><li id="ef36" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">如果我们向后循环，字符串应该是相同的</li><li id="ec5c" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们需要一个正则表达式来检查字母字符</li><li id="b4a0" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们当然应该转换成小写</li></ul><p id="4d2a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">方案一:反向循环！</strong></p><p id="4c48" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">那么我们的<strong class="kr io">伪码</strong>是什么呢..还是我们的策略？我们可以把它写在代码的注释中</p><ul class=""><li id="bfd6" class="ly lz in kr b ks kt kv kw ky ma lc mb lg mc lk md me mf mg bi translated">我们定义了空的反向字符串，我们将在后面添加它</li><li id="7dd7" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们将字符串转换成小写</li><li id="20d9" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">我们从它们中删除空格(它们不会被处理)..我们可以使用replace()来做到这一点</li><li id="d3f4" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">遍历字符串并反转字符串</li><li id="d566" class="ly lz in kr b ks mh kv mi ky mj lc mk lg ml lk md me mf mg bi translated">将反转的字符串与原始字符串进行比较</li></ul><pre class="ke kf kg kh gt lm ln lo lp aw lq bi"><span id="ed23" class="lr ls in ln b gy lt lu l lv lw">function isPalindrome(string) {</span><span id="e71f" class="lr ls in ln b gy lx lu l lv lw">    const spaceRegex = / /g;<br/>    string = string.replace(spaceRegex, "").toLowerCase();<br/>  <br/>    let backwardsString = '';</span><span id="942c" class="lr ls in ln b gy lx lu l lv lw">    for (let i = string.length-1; i &gt;= 0; i--) {<br/>       backwardsString += string[i];<br/>    }</span><span id="02ec" class="lr ls in ln b gy lx lu l lv lw">    return backwardsString == string;</span><span id="b023" class="lr ls in ln b gy lx lu l lv lw">}</span><span id="a1fc" class="lr ls in ln b gy lx lu l lv lw">console.log (isPalindrome('Never odd or even'));  // true</span></pre><p id="c6f6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="ll">更多内容看</em> <a class="ae ns" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io"> <em class="ll">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>