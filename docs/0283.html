<html>
<head>
<title>Algorithm Practice: Checking for a Valid Subsequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法练习:检查有效的子序列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithm-practice-checking-for-a-valid-subsequence-9753fe28caad?source=collection_archive---------10-----------------------#2021-01-16">https://javascript.plainenglish.io/algorithm-practice-checking-for-a-valid-subsequence-9753fe28caad?source=collection_archive---------10-----------------------#2021-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a390719596a845b7d1c3c3d94acdc9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsAkSRWRVyMeyAlBI_CQqQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@viazavier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Laura Ockel</a> on <a class="ae jz" href="https://unsplash.com/s/photos/algorithm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7979" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">提高算法水平的唯一方法是通过一致性和实践——所以让我们回到另一个算法实践。本周，我们将看看<em class="ky">验证子序列</em>算法。这是一个非常常见且相对简单的算法，所以如果你刚开始学习算法，这是一个很好的练习方法。</p><p id="0920" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看这个问题:</p><h2 id="ab37" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">给定两个非空的整数数组，判断第二个数组是否是第一个数组的有效子序列。</strong></h2><p id="875e" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated">请注意，数组中的单个数字以及数组本身都是数组的有效子序列。</p><p id="3e2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们深入这个问题之前，让我们首先确定我们知道什么是子序列。<strong class="kc io">子序列</strong>是可以通过移除一些(或不移除)元素而不改变任何剩余元素的顺序从原始序列中获得的序列。</p><p id="9968" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将通过几个例子来说明这个概念:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4f46" class="kz la in md b gy mh mi l mj mk">array = [7, 10, 5, 3, -1, -8, 11]<br/>sequence = [7, 5, 11]</span></pre><p id="b9ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，序列<em class="ky">是数组的有效子序列</em>。我们可以通过从原始数组中移除10，3，<em class="ky"> - </em> 1和-8来获得序列，而无需重新排列剩余的元素。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="11e2" class="kz la in md b gy mh mi l mj mk">array = [72, 0, 1, 3, 3, 10, -13, 22]<br/>sequence = [72, 0, -13, 10, 22]</span></pre><p id="1b88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述序列<em class="ky">不是</em>数组的有效子序列。我们可以从数组中删除整数1、3和3，得到[72，0，10，-13，22]，但是-13和10必须重新排列才能匹配。</p><h2 id="c00c" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">概念演练</strong></h2><p id="5c61" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated">在我们开始编写解决方案之前，让我们先来看一下如何找到这个问题的解决方案。想想你是如何完成上面的例子的。浏览例子并清楚地说明你在每一步都做了什么，这对于找出解决方案非常有帮助。</p><p id="186c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以设置两个指针，一个用于数组，一个用于序列，从每一个的开头开始。在每次迭代中，我们希望将数组中的当前数字与潜在子序列中的当前数字进行比较。如果数组中的数字等于潜在子序列中的数字，我们将把两个指针都向右移动一位，继续比较下一个元素。如果它们不相等，我们将只移动主数组指针，并将这个新的当前数组元素与序列元素进行比较。我们将继续这个过程，直到到达数组的末尾或序列的末尾。</p><p id="a46b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们如何知道序列是否确实是数组的子序列？当我们在数组中找到匹配时，我们只移动序列指针。因此，如果我们能够在到达主数组末尾之前遍历整个序列，我们就知道它是一个子序列。如果不是，它不是一个子序列。</p><h2 id="d65c" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">代码演练</strong></h2><p id="9d9a" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated">现在我们已经理解了解决方案的概念，我们可以开始编码了。先自己试一试。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="18e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的解决方案中，我为序列设置了一个指针(sequenceIndex)，并将其初始化为0。使用for循环，我为数组设置了一个指针(arrayIndex)，它也从0开始。只要arrayIndex小于数组的长度，for循环就会运行，并且arrayIndex在for循环的每次迭代中都会增加。在循环内部，我们检查当前数组元素是否与当前序列元素深度相等，如果是，我们将sequenceIndex增加1。请记住，无论这两个元素是否相等，arrayIndex都会增加1。退出for循环后，我们将根据sequenceIndex是否等于序列的长度返回一个布尔值。这让我们知道我们是否能够完成整个序列——如果我们完成了序列，我们知道它是一个子序列。</p><h2 id="dc0a" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">空间/时间复杂度</strong></h2><p id="e30e" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated">这个解在线性(O(n))时间和常数(O(1))空间中运行。相当高效！</p></div></div>    
</body>
</html>