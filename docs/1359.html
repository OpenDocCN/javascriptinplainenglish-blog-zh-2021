<html>
<head>
<title>Calling REST API inside GraphQL queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GraphQL查询中调用REST API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/calling-rest-api-inside-graphql-queries-e715c0f2da44?source=collection_archive---------6-----------------------#2021-03-22">https://javascript.plainenglish.io/calling-rest-api-inside-graphql-queries-e715c0f2da44?source=collection_archive---------6-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不需要将后端从REST切换到GraphQL。获取GraphQL中的REST查询。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/83bf4c04e7f99f4c46e9e21010665160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPOnPU3XKhAtWPJx1I8q-Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk"><a class="ae lb" href="http://ihatereading.in/creativity" rel="noopener ugc nofollow" target="_blank">iHateReading</a></figcaption></figure><p id="d02d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信GraphQL将成为在前端获取数据的未来。GraphQL有许多优点，我个人最喜欢的一个优点是后端和前端的解耦，使用GraphQL，我们可以将后端和前端视为一个独立的实体，这有助于两个实体无中断地独立存在。</p><h1 id="4b1f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">问题</strong></h1><p id="9d34" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">GraphQL是脸书在2015年公开发布的，REST API很早以前就可以使用，所以今天，那些想将后端升级到GraphQL的公司不会那么容易。此外，GraphQL目前只在apollo服务器上运行，转移服务器和架构需要几个月甚至一年的时间(显然取决于存储库的大小)。我觉得执行这一重大转变是不可行的，它还会导致公司在业务环境中陷入困境。</p><h1 id="0e6b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">备选方案</strong></h1><p id="ef89" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Apollo GraphQL确实理解这个问题，所以他们提出了一个包装器的解决方案。他们创建了一个npm包，在REST端点上提供了一个GraphQL的包装器，所以我们只需用GraphQL包装器包装一个REST端点，并对我们的REST API进行GraphQL查询。听起来很有趣，我们只是不需要改变后端架构和框架，在前端，我们将对REST端点进行GraphQL查询。</p><h1 id="0fc3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">我的经历</strong></h1><p id="8a5a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我正在为一个加密货币交易应用程序制作图表。我用的是一个名为“<a class="ae lb" href="https://formidable.com/open-source/victory/docs/native/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="mf">victor-native</em></strong></a><strong class="jp ir"><em class="mf"/></strong><strong class="jp ir"><em class="mf">【react-native】</em></strong>的库。到目前为止，整个图表已经开发出来了，我们面临的唯一问题是我们的图表有点慢，用户互动时间滞后了一秒钟。对问题进行调试后，我们找到了问题原因，</p><p id="8d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题</strong> —我们是一个用户，为一个图表获取大量数据，但是为了创建一个图表，你只需要一个特定点的两个值(x轴值和y轴值)。</p><p id="aed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想到的唯一解决方案是创建一个新的API端点，它将只返回图表所需的数据，但是要执行这个更改，我必须联系<strong class="jp ir">后端开发人员</strong>加上我们的<strong class="jp ir">工程师经理</strong>并向他们推销这个想法，这似乎是一个相当耗时的过程。我们发现的另一种方法是将API请求作为GraphQL查询，我们将只获取所需的数据。最后，在阅读了成吨的文章，观看了一些<strong class="jp ir"> Youtube </strong>视频之后，我们已经通过Apollo本身得到了这个包，以便对REST endpoint进行GraphQL查询。</p><h1 id="d3a2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">阿波罗-链接-休息</h1><p id="5810" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Apollo提供了一种用GraphQL包装器包装REST端点的方法。该解决方案有以下好处:<br/>您所在的前端开发团队希望尝试GraphQL，而不要求后端团队实现GraphQL服务器。</p><ul class=""><li id="9709" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">您无权更改后端，因为它是一组现有的API，可能由第三方管理。</li><li id="7c5e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">您已经有了一个现有的代码库，但是您正在考虑评估GraphQL是否能够满足您的需求。</li><li id="0770" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">您有一个很大的代码库，GraphQL迁移正在后端进行，但是您想立即使用GraphQL<em class="mf"/>！</li></ul><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="4481" class="mz ld iq mv b gy na nb l nc nd"><strong class="mv ir">Package: </strong>apollo-link-rest </span></pre><p id="b927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="mf">Apollo-link-rest</em></strong>包接受REST端点URL作为参数，并返回作为包装器的GraphQL客户端。</p><h1 id="15c3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">执行</strong></h1><p id="5e49" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们需要一个具有<strong class="jp ir"><em class="mf">Apollo-link-RES</em></strong>t的对等依赖包来执行。最重要的包是<strong class="jp ir"> "@apollo/client" </strong>，这个javascript库帮助您编写GraphQL查询，使用GraphQL获取、更新和修改应用程序的数据。运行以下命令安装所需的包。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="2c17" class="mz ld iq mv b gy na nb l nc nd"><strong class="mv ir">yarn run @apollo/client apollo-link-rest </strong><strong class="mv ir">graphql qs</strong></span></pre><p id="c9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在安装了上述软件包之后，我们将把GraphQL查询与REST查询分离开来。我们将在包内创建一个名为“GraphQL”的单独文件夹，并使用一个示例<strong class="jp ir"> GET REST API </strong>在前端获取数据，但使用graphQL查询。</p><h1 id="26dd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">终点</strong></h1><p id="2244" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将使用的示例GET端点如下-</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="0065" class="mz ld iq mv b gy na nb l nc nd"><a class="ae lb" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a></span></pre><p id="5b09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该端点将以对象数组的形式返回用户列表。数组中的每个对象都是具有键值对的JSON对象。每个对象看起来都如下所示:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="28c0" class="mz ld iq mv b gy na nb l nc nd">const singleUser = { <br/>  id: string,<br/>  username: string,<br/>  email: string,<br/>  phone: string,<br/>  Website: string,<br/>  adddress: {<br/>    street: string,<br/>    city: string <br/>  },<br/>  company: {<br/>    name: string<br/>  }<br/>}</span></pre><p id="8a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的主要议程是只从查询中获取所需的数据(键值对)。例如，我们只需要id、电子邮件、用户名和公司名称作为键值，所以我们将使用GraphQL获取所需的唯一数据，而不是使用REST获取整个数据。</p><h1 id="f082" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">假设</h1><p id="8533" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我假设，您对GraphQL查询以及我们如何在前端编写GraphQL查询有一点了解。</p><h1 id="dcf4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">执行</h1><p id="241e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在包内创建一个单独的文件夹后，我们将为GraphQL查询定义客户机。该客户端将接受查询参数。我们在client.js中的客户端看起来像这样</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="e0c7" class="mz ld iq mv b gy na nb l nc nd">import { ApolloClient, InMemoryCache } from '@apollo/client';<br/>import {  RestLink } from 'apollo-link-rest';</span><span id="d669" class="mz ld iq mv b gy ne nb l nc nd"><em class="mf">// Set `RestLink` with your endpoint<br/></em>const restLink = new RestLink(<br/>      { uri: 'https://jsonplaceholder.typicode.com/' }<br/>);</span><span id="a3cd" class="mz ld iq mv b gy ne nb l nc nd"><em class="mf">// Setup your client<br/></em>export const client = new ApolloClient({<br/>   cache: new InMemoryCache(),<br/>   link: restLink<br/>});</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/88ebfca7bd69b071019d35c141dba03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sLPvBqU41vyQ9M3nrlG--A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">client.js</figcaption></figure><p id="cb5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经使用restLink构造函数创建了<strong class="jp ir"> restLink </strong>，该构造函数将接受URL作为参数。使用ApolloClient构造函数，我们将URL作为链接传递，其值作为键-值对传递。这是我们GraphQL的基本客户端。</p><p id="a406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个客户端类似于获取对象，如果你已经在前端使用获取包。将其视为使用<strong class="jp ir"> fetch </strong>包在前端发出请求，在其中我们将body作为参数传递，类似地，在GraphQL中，每个请求都是POST，因此我们需要将GraphQL查询作为参数传递给我们的客户端对象。</p><h1 id="08cd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">写作查询</strong></h1><p id="0332" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">GraphQL将每个API请求都视为POST方法，在GraphQL中没有称为GET request的术语。在幕后，GraphQL将其API称为查询或变异。你可以像下面这样映射它们-</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="70c8" class="mz ld iq mv b gy na nb l nc nd">GRAPHQL =&gt; REST API<br/> Query =&gt; GET request in REST API, <br/> Mutation =&gt; POST, PUT, DELETE, UPDATE request in REST API</span></pre><p id="c7eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的第一个查询将包含路径、查询类型和发出请求所需的主体数据。此外，我们需要在GraphQL查询中提到“@rest”构造函数来告诉我们的<strong class="jp ir">客户端</strong>我们正在对我们的rest端点进行GraphQL查询。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="f7b4" class="mz ld iq mv b gy na nb l nc nd">import { gql } from '@apollo/client';<br/>export const usersQuery = gql`<br/> query User {<br/>  users @rest(type: "User", path: "users"){<br/>   id,<br/>   username,<br/>   email,<br/>   company {<br/>     name<br/>   }<br/>  }}<br/>`;</span></pre><h2 id="74ee" class="mz ld iq bd le ng nh dn li ni nj dp lm jy nk nl lq kc nm nn lu kg no np ly nq bi translated"><strong class="ak">映射内容</strong></h2><ul class=""><li id="c36d" class="mg mh iq jp b jq ma ju mb jy nr kc ns kg nt kk ml mm mn mo bi translated"><strong class="jp ir">查询</strong> = &gt;请求的类型(枚举["查询"，"突变"])</li><li id="e3e1" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">用户</strong> = &gt;请求的名称(可以是任何名称，但不要使用大写字母)</li><li id="9bae" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">用户</strong> = &gt;数据将使用this(users)作为“<strong class="jp ir">键”</strong>返回</li><li id="c606" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> @rest </strong> = &gt;操作符通知我们的客户端我们发出请求的方式(在我们的例子中，我们必须使用@rest，因为我们正在向rest端点发出GraphQL请求)</li><li id="59ec" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">路径</strong> = &gt;到端点的路径</li><li id="9d9d" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> { id，用户名，邮箱} </strong> = &gt;在API的响应中提到我们在前端需要的数据结构</li></ul><h1 id="0966" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">获取数据</strong></h1><p id="4bc0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，我们的客户端对象就像一个样本获取方法，它将使用查询作为主体参数发出请求，并且我们的客户端确实需要将<strong class="jp ir">查询</strong> <strong class="jp ir">对象</strong>作为值，将<strong class="jp ir">查询</strong>作为键。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="19d2" class="mz ld iq mv b gy na nb l nc nd">const <strong class="mv ir">apiRequest</strong> = client.<strong class="mv ir">query</strong>({ query: <strong class="mv ir">queryObject</strong> })</span></pre><p id="1e90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="mf">API request</em></strong>如果你的控制台是一个<strong class="jp ir">的承诺</strong>，那么我们只需要使用。<strong class="jp ir">然后</strong>和。<strong class="jp ir">捕捉</strong>方法来获取我们的REST端点返回的数据。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="a35a" class="mz ld iq mv b gy na nb l nc nd">client.<strong class="mv ir">query</strong>({ query: <strong class="mv ir">userQuery</strong> }).then(response=&gt; {<br/>   console.log(response.data.<strong class="mv ir">users</strong>)<br/>}).catch(error =&gt; console.log('error', error)</span></pre><h1 id="282e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">结论</strong></h1><p id="9f57" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我个人喜欢这个包装器，它让前端的一切变得如此简单，而不需要改变后端的技术堆栈。如果你真的想为你的团队添加一个GraphQL作为新的技术栈，那么这是最好的方法。</p><p id="3991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到下一次，祝大家愉快</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="79c4" class="mz ld iq mv b gy na nb l nc nd">Repository =&gt; <a class="ae lb" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/GraphQLWithRESTAPI" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/GraphQLWithRESTAPI</a></span></pre></div></div>    
</body>
</html>