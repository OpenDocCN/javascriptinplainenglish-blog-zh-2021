<html>
<head>
<title>Setting Up Auth Guards with React Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反应路由器设置授权保护</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/auth-guard-and-react-router-46bb7a7160aa?source=collection_archive---------20-----------------------#2021-01-05">https://javascript.plainenglish.io/auth-guard-and-react-router-46bb7a7160aa?source=collection_archive---------20-----------------------#2021-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="702a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于用户的身份验证呈现特定的路由或页面很重要，这也是为什么我惊讶地看到，当涉及到reactor中的身份验证防护时，我的谷歌搜索结果并不尽如人意。有时你只需要更好的理解(或词汇)来利用谷歌的力量并做出反应。反应路由器有<a class="ae ki" href="https://reactrouter.com/web/example/auth-workflow" rel="noopener ugc nofollow" target="_blank">本例为</a>。这很好。他们利用<a class="ae ki" href="https://usehooks.com/useAuth/" rel="noopener ugc nofollow" target="_blank">使用</a>。不过，我觉得这有点难，因为它可以更简单！方法如下:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="2c1c" class="ks kt in ko b gy ku kv l kw kx">state = {</span><span id="dacb" class="ks kt in ko b gy ky kv l kw kx">    auth: false</span><span id="e9f7" class="ks kt in ko b gy ky kv l kw kx">};</span></pre><p id="d6da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘣。我们结束了！恭喜！</p><figure class="kj kk kl km gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kz"><img src="../Images/eb25c77839e892f206529ffab29404ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3M1SXX7ldg36ZDyX"/></div></div></figure><p id="627e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，还有一点。</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="8004" class="ks kt in ko b gy ku kv l kw kx">{ this.state.auth ? &lt;SomeComponent /&gt; : &lt;h1&gt;Please login!&lt;/h1&gt; }</span></pre><p id="4dd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在组件的JSX中使用三元表达式！因此，只有当this.state.auth为“真”时，这才会渲染<SomeComponent/>。对于来自服务器的成功登录请求，我们将auth设置为true，如下所示:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="081b" class="ks kt in ko b gy ku kv l kw kx">.then(res =&gt; res.json())<br/>.then(json =&gt; this.setState({ auth: true }));</span></pre><p id="93f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是假设您在登录不成功的任何时候抛出一个错误。这实际上就是简单的身份验证和条件渲染的全部内容。当用户没有登录或注销时，您只需使用这个. setState({ auth: false })。</p><p id="7368" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，还有其他方法可以做到这一点。使用rails时，您可以在控制器中设置一个before_action，在调用任何方法之前检查用户是否登录。您在这里可以看到更多<a class="ae ki" href="https://guides.rubyonrails.org/action_controller_overview.html#filters" rel="noopener ugc nofollow" target="_blank"/>。您仍然需要前端的错误处理，所以总体上这需要做更多的工作。这种编程的全部思想是尽可能少地编码。如果您还有其他资源，请在下面发表评论！</p><p id="1d72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，感谢<a class="ae ki" href="https://medium.com/@aryamurali" rel="noopener">艾莉亚·穆阿利</a>精彩的<a class="ae ki" href="https://medium.com/@aryamurali/embed-code-in-medium-e95b839cfdda" rel="noopener">帖子</a>。</p></div></div>    
</body>
</html>