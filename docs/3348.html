<html>
<head>
<title>Create a Marketplace API with Plumier in 4 Simple Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Plumier通过4个简单的步骤创建一个市场API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-marketplace-api-with-plumier-in-4-simple-steps-6415078a433b?source=collection_archive---------15-----------------------#2021-07-07">https://javascript.plainenglish.io/create-a-marketplace-api-with-plumier-in-4-simple-steps-6415078a433b?source=collection_archive---------15-----------------------#2021-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8a716b8d53601f572a43d1fec6c96038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sn-qADtPLfarLA1e8DGZ2w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Marketplace — Photo by <a class="ae jz" href="https://unsplash.com/@saintjaddy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jaddy Liu</a> on <a class="ae jz" href="https://unsplash.com/s/photos/marketplace?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a59d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">API最重要也是最困难的方面是安全系统，它保证数据不被未授权的用户泄露/访问。如果没有合适的工具，就没有简单的方法来做到这一点，因为大多数授权规范需要密集的编程和测试。</p><p id="2891" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几十年来，我们有一个实用的解决方案，只需通过创建逻辑来保护对URI的访问，创建另一个逻辑来限制基于角色的用户输入，创建另一个逻辑来排除一些数据，并在您拥有的每个资源上一遍又一遍地重复这些逻辑，将授权逻辑分散到代码库的每个地方。最终，它增加了代码库的复杂性，同时降低了可读性。</p><p id="ecdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Plumier提供了工具来完全将授权从控制器中分离出来。授权逻辑可以单独隔离，然后通过配置轻松应用于安全路由、查询字符串、请求/响应主体属性等。反过来，创建具有复杂授权的API会变得更加简单和容易。这个故事将向您展示如何使用Plumier创建一个具有复杂授权逻辑的Marketplace API，通过遵循一些步骤来使开发过程变得平稳和容易。</p><h2 id="a1bb" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">一言以蔽之</h2><p id="c5f0" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">对于不熟悉的你来说，<a class="ae jz" href="https://plumierjs.com/" rel="noopener ugc nofollow" target="_blank"> Plumier </a>是一个专注于生产力的TypeScript后端框架，它有一个专用的反射库来帮助你愉快地创建一个健壮、安全、快速的API。</p><p id="76f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个故事使用了一些更加华丽的特性，为了避免混淆，你需要理解一些术语。如果你访问过Plumier <a class="ae jz" href="https://plumierjs.com/" rel="noopener ugc nofollow" target="_blank">登陆页面</a>，你可以跳过这一部分。</p><p id="55b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一类实体</strong>:是一个ORM实体(TypeORM ),通过通用控制器提升对框架组件的控制，如授权、验证和生成的路由。这是一种基于ORM实体创建具有CRUD功能的API的即时方法。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3a74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子生成成下面的六条路线</p><pre class="lw lx ly lz gt mc md me mf aw mg bi"><span id="33b3" class="ky kz in md b gy mh mi l mj mk">POST   /items       accessible by Supervisor and Staff<br/>GET    /items?      accessible by any login user<br/>GET    /items/{id}  accessible by any login user<br/>POST   /items/{id}  accessible by Supervisor and Staff<br/>PUT    /items/{id}  accessible by Supervisor and Staff<br/>DELETE /items/{id}  accessible by Supervisor and Staff</span></pre><p id="8d5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一类实体背后没有魔法，它只是利用反射和通用控制器在后台自动创建一个控制器。你可以在这里阅读关于这个功能<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/70f2f53bb2a8">的完整故事。</a></p><p id="7863" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">嵌套的第一类实体</strong>:是生成Restful嵌套路线<code class="fe ml mm mn md b">parents/{pid}/children</code>的父子特定的第一类实体。嵌套的第一类实体，最适合用于根据父ID缩小结果范围或根据父ID限制对资源的访问。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1aa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第8行，我们定义了一对多关系的通用控制器装饰器。上面的示例生成为下面的六个嵌套路线。</p><pre class="lw lx ly lz gt mc md me mf aw mg bi"><span id="2148" class="ky kz in md b gy mh mi l mj mk">POST   /posts/{pid}/comments      insert new <br/>GET    /posts/{pid}/comments <br/>GET    /posts/{pid}/comments/{id}  <br/>POST   /posts/{pid}/comments/{id}<br/>PUT    /posts/{pid}/comments/{id}<br/>DELETE /posts/{pid}/comments/{id}</span></pre><p id="bfaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于根据特定帖子ID <code class="fe ml mm mn md b">pid</code>缩小评论结果的API。并根据帖子ID保护添加、修改、删除、获取等操作。</p><p id="0fd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">不支持深度路线嵌套</strong>:记住我们只支持两级嵌套，因为这通常就足够了。例如，不要有被<code class="fe ml mm mn md b">oid</code>缩小的<code class="fe ml mm mn md b">/users/{uid}/orders/{oid}/items</code>，这意味着<code class="fe ml mm mn md b">/orders/{oid}/items</code>就足够了。</p><p id="4bde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">授权策略</strong>:这是从配置中分离授权逻辑的功能。此外，它可以应用于使用配置的控制器的任何部分，例如在动作上保护路由，在参数上保护查询字符串，在模型属性上保护请求/响应主体属性等。阅读Plumier文档中关于<a class="ae jz" href="https://plumierjs.com/security" rel="noopener ugc nofollow" target="_blank">授权策略</a>的更多信息。</p><p id="9540" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">实体授权策略(Entity Policy) </strong>:这是一种专门的授权策略，最适合用于保护一级实体。实体策略提供了上下文ID，它是当前被访问资源的ID。有了这个上下文ID，基于存储在数据库表中的数据动态保护资源就相对容易了。在Plumier文档中阅读更多关于<a class="ae jz" href="https://plumierjs.com/generic-controller#entity-authorization-policy" rel="noopener ugc nofollow" target="_blank">实体授权策略</a>的信息。</p><h2 id="3608" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">市场API规范</h2><p id="7ca6" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在这个例子中，我们将创建市场API的核心特性。这些API被分成具有以下规范的功能组。</p><ol class=""><li id="1f1f" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><strong class="kc io">用户管理</strong>:任何人都可以使用电子邮件、密码和姓名自由注册。受限用户只能修改和删除自己的用户数据。电子邮件仅限于在API响应上的任何地方对用户可见。只有管理员可以访问的用户列表。</li><li id="8354" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">店铺管理</strong>:任何注册用户都可以创建店铺。默认情况下，创建商店的用户被指定为商店所有者。用户可以根据自己的喜好创建多个商店。只有店主可以修改和删除店铺数据。任何登录用户应该能够看到所有商店的列表。</li><li id="3f4b" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">店铺用户管理</strong>:店主可以给店铺添加更多的用户作为员工。商店职员对商店的进出是有限制的。非商店用户无法访问商店用户列表。</li><li id="7ce2" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">店铺产品管理</strong>:店主和店员可以添加新的、修改和删除产品。该产品包含多个图像。产品底价只对店主和店员可见，对其他用户不可见。</li><li id="f286" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">图像管理</strong>:所有用户都可以上传图像，但最大允许大小为5 MB。只有管理员才能访问的所有图像的列表。</li><li id="24c7" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">用户送货地址管理</strong>:所有用户可以有多个送货地址。只有数据的所有者可以查看、修改和删除送货地址。</li><li id="abfd" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">产品列表</strong>:所有用户能够看到所有产品，产品包含价格、图片和合适的店铺等信息。用户可以稍后将产品添加到他们的购物车中。</li><li id="1b9d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">购物车</strong>:所有用户都有一个购物车。购物车会自动创建并保持打开状态，直到关闭(签出)。来自多个商店的产品可以添加到购物车中。当添加相同的产品时，它会自动合并并增加数量。购物车商品可以修改和删除。购物车中的商品根据商店进行分组。已关闭的购物车既不能修改也不能删除。结帐过程完成后，会创建一个新的购物车。</li><li id="9a54" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">店铺订单管理</strong>:显示与店铺相关的用户订单列表。只有店主和店员才能进入。秩序是不可改变的，除了国家。商店的可用状态值为<code class="fe ml mm mn md b">Prepared</code>和<code class="fe ml mm mn md b">Sent</code>。</li><li id="9480" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io">用户订单管理</strong>:显示用户订单列表。只有数据的所有者可以访问。用户只能设置订单的状态值。用户可用的状态值有<code class="fe ml mm mn md b">Received</code>和<code class="fe ml mm mn md b">Issue</code>。</li></ol><p id="7731" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为参考，下面是Marketplace API使用的数据库表的实体关系图。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/bc6a0c15d34f13e78d1efcec5139c742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4GHc2YGNZUarKksG.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Marketplace API Entity Relationship Diagram (ERD)</figcaption></figure><h2 id="0a0c" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">源代码</h2><p id="9e55" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这个项目的源代码可以在这个<a class="ae jz" href="https://github.com/plumier/examples/tree/master/08-complete-example/marketplace-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到。这个项目使用Plumier <code class="fe ml mm mn md b">rest-api-typeorm</code>创建<a class="ae jz" href="https://github.com/plumier/starters" rel="noopener ugc nofollow" target="_blank">项目启动器</a>。</p><p id="894b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">project starter附带了身份验证和用户管理以及一些默认的授权设置。你可以随意修改源代码。</p><h2 id="0578" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">开发步骤</h2><p id="dbfd" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">为了利用Plumier的特性，最好将下面的开发步骤作为最佳实践。</p><ul class=""><li id="f896" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated"><strong class="kc io">步骤1 </strong>:从规范中识别并列出所有用户角色和授权策略。</li><li id="423e" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">步骤2 :检查是否可以使用第一类实体或嵌套的第一类实体来实现。如果是CRUD功能或C、R、U、D功能之一，检查每个功能规范。不要忘记检查第一个类实体提供的API是否适合UI工作流。</li><li id="18e7" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated"><strong class="kc io">步骤3 </strong>:使用步骤1中定义的用户角色或策略，对每个动作C、R、U和D配置授权。并对实体属性上的每个请求/响应主体属性设置授权限制。</li><li id="52c7" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated"><strong class="kc io">第4步</strong>:第3步应用的程序授权逻辑</li></ul><p id="c3a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤1只需要一次，步骤2、3和4需要在每个规格上重复。</p><h2 id="983f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">用户角色和授权策略</h2><p id="359d" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这一步需要能够明确授权策略的名称。通过更早地识别用户角色和授权策略，我们可以清晰地创建授权逻辑。</p><p id="1f45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于上面描述的市场API规范，我们可以提取其中涉及的用户角色和策略。</p><ol class=""><li id="81f8" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><code class="fe ml mm mn md b">Admin</code>和<code class="fe ml mm mn md b">User</code>我们得到了项目启动者的内置。这些角色在应用程序范围的角色系统中区分用户。此外，我们可以为Marketplace API创建一个单独的管理API。但是我们将在下一个故事中讨论这个问题。</li><li id="5d8d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><code class="fe ml mm mn md b">ShopOwner</code>和<code class="fe ml mm mn md b">ShopStaff</code>是特定于店铺的角色，限制对店铺相关API的访问，如店铺数据修改、添加新产品、修改为产品等。</li><li id="bf06" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><code class="fe ml mm mn md b">ResourceOwner</code>该策略用于将访问权限仅限于资源所有者。</li></ol><h2 id="aaa5" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">程序产品列表</h2><p id="134e" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们从最简单的开始开发，产品列表是CRUD功能的其余部分。这个功能可以使用第一类实体实现，只使用R，忽略C、U和D功能，如下所示。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a10e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码显示了我们使用第一类实体只是为了获得更多的功能，而忽略了所有其他的方法。由于所有登录用户都可以访问产品列表，因此不需要进一步的授权编程来保护产品列表。</p><p id="b48c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您运行该项目并导航到Swagger <code class="fe ml mm mn md b">localhost:8000/swagger</code>，您将获得产品列表，其中包含一些很酷的功能，如投影、过滤和排序，如下所示。点击阅读更多关于此功能的信息<a class="ae jz" href="https://plumierjs.com/query-parser" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/7dab7dd0a34c973b1da2eabd061da272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xHSPNDJ0yBYlLlzs_c5y8w.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Product List Filter, Order and Projection</figcaption></figure><h2 id="1142" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">程序商店管理</h2><p id="8158" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">接下来容易的部分是用户管理和店铺管理。我们有项目启动者内置的用户管理，所以这里我们只关注商店管理。车间管理规范如下。</p><blockquote class="nf ng nh"><p id="1209" class="ka kb ni kc b kd ke kf kg kh ki kj kk nj km kn ko nk kq kr ks nl ku kv kw kx ig bi translated">任何注册用户都可以创建商店。默认情况下，创建商店的用户被指定为商店所有者。用户可以创建他们喜欢的多个商店。只有店主可以修改和删除店铺数据。任何登录用户应该能够看到所有商店的列表。</p></blockquote><p id="67be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的规范清楚地说明了有一个带有一些授权限制的CRUD功能，它可以用下面的第一类实体来实现。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ebb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上代码涵盖了所有的店铺管理规范。请记住，默认情况下，任何登录用户都可以访问生成的路由。因此规范:<em class="ni">任何注册用户可以创建一个商店</em>和<em class="ni">任何登录用户应该能够看到所有商店的列表。</em>已经默认覆盖，无需进一步配置。</p><p id="e125" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一类实体可以有在实体保存到数据库之前或之后执行的脚本。我们使用这个特性自动将当前登录用户指定为商店的所有者。点击阅读更多关于此功能的信息<a class="ae jz" href="https://plumierjs.com/generic-controller#request-hook" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="573d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您保存上面的代码并在<code class="fe ml mm mn md b">npm run debug</code>之前运行项目，您将从路径分析中获得这些错误消息。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/969ef6824a82d34ffed09b1e3db8e9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT4NCIS_7P0JItMKSuNO1w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Plumier Route Analysis Report</figcaption></figure><p id="6fa8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上图显示<code class="fe ml mm mn md b">ShopOwner</code>策略缺失，我们还没有触及任何授权的逻辑。我们进行第4步来修复它。为了对与商店实体相关的<code class="fe ml mm mn md b">ShopOwner</code>逻辑进行编程，我们需要理解商店和用户表之间的关联，如下图ERD所示。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/8bd30fb7ac92d317fe8f21dbecf1679a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lsxg0-BAh6wlpEZj.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Relation Between User and Shop</figcaption></figure><p id="3e8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了保护商店，我们需要在<code class="fe ml mm mn md b">ShopUser</code>表中获取当前登录用户的角色。因此，根据提供的当前访问商店的上下文ID，我们可以很容易地检查用户是否授权。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="91bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们为名为<code class="fe ml mm mn md b">ShopOwner</code>的店铺实体注册了实体保单。实体策略返回布尔值，<code class="fe ml mm mn md b">true</code>授权用户，否则<code class="fe ml mm mn md b">false</code>。上面代码的逻辑非常简单明了。我们使用商店上下文ID(<code class="fe ml mm mn md b">id</code>参数)和当前登录用户ID(<code class="fe ml mm mn md b">user?.userId</code>)从<code class="fe ml mm mn md b">ShopUser</code>表中获取用户角色，然后检查角色是否为<code class="fe ml mm mn md b">ShopOwner</code>。就是这样！这个逻辑足以保护所有用<code class="fe ml mm mn md b">@authorize</code> decorator保护的第一类实体方面。</p><p id="f85e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，授权策略必须是快速和轻量级的，使用短生命周期缓存来缓存查询是最佳实践。</p><h2 id="5827" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">程序商店用户管理</h2><p id="b96a" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">现在我们已经准备好使用嵌套的第一类实体来处理更高级的功能。如前所述，嵌套的第一类实体最适合用于具有父子行为的功能。</p><p id="b4b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于上面的大多数规范可以使用嵌套的第一类实体来解决，因此我们将只关注商店用户管理，对于其他规范，如商店产品管理、商店订单管理、用户送货地址管理、用户订单管理。这些功能的开发过程大部分都是相同的，在本文中不做讨论。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/5545ab3abaa8cbfd0c35ef18b91858d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/0*ltt-xvbYjTv_9_kQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Shop — Shop User ERD</figcaption></figure><p id="fb58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">店铺用户管理有如下图的亲子行为。</p><ul class=""><li id="3759" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated">用户列表根据父id缩小，在本例中是商店id。例如<code class="fe ml mm mn md b">GET /api/shops/123/users</code>，列出与商店<code class="fe ml mm mn md b">123</code>相关的所有用户。</li><li id="dd72" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">要添加新用户，需要根据店铺ID限制用户访问。例如<code class="fe ml mm mn md b">POST /api/shops/123/users</code>限制用户进入<code class="fe ml mm mn md b">123</code>商店。使用这个实体策略可以根据商店ID提供上下文ID。</li></ul><p id="de2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此功能用于与一些用户共享对商店的访问。如果你看过GitHub组织成员页面，你可能会明白这个想法。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/64b7820f80ee68804e905b21eea85dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egDOLyQ0L01l_vjNi8dZaA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">GitHub Organization Members Page</figcaption></figure><p id="6f7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们假设上面的UI是商店用户UI。上面的UI是<code class="fe ml mm mn md b">ShopUser</code>表的一个CRUD功能。</p><ul class=""><li id="add3" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated">邀请用户按钮将调用只有店主才能访问的<code class="fe ml mm mn md b">POST /api/shops/{shopId}/users</code></li><li id="1c74" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">改变用户角色将调用<code class="fe ml mm mn md b">PATCH /api/shops/{shopId}/users/{id}</code>,只有店主可以访问</li><li id="ef6a" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">删除用户将调用<code class="fe ml mm mn md b">DELETE /api/shops/{shopId}/users/{id}</code>，只有店主可以访问</li><li id="d286" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">用户列表将调用<code class="fe ml mm mn md b">GET /api/shops/{shopId}/users</code>，只有店主和店员可以访问。但是由于结果是<code class="fe ml mm mn md b">ShopUser</code>对象，我们需要提供一个<a class="ae jz" href="https://plumierjs.com/generic-controller#transform-response" rel="noopener ugc nofollow" target="_blank">自定义转换器</a>来将<code class="fe ml mm mn md b">ShopUser</code>转换成<code class="fe ml mm mn md b">User</code>。</li></ul><p id="25f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嵌套的第一类实体需要一对多关系和反向关系才能正常工作。请参见下面代码片段的注释以获得更好的解释。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="bbfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码相当简单明了，<code class="fe ml mm mn md b">mutators()</code>是一个方法查询来配置<code class="fe ml mm mn md b">POST</code>、<code class="fe ml mm mn md b">PUT</code>、<code class="fe ml mm mn md b">PATCH</code>、<code class="fe ml mm mn md b">DELETE</code>授权给店主。而<code class="fe ml mm mn md b">accessors()</code>则是针对<code class="fe ml mm mn md b">GET</code>方法(获得多和凭id获得)授权的店主和店员。正如你所看到的，我们还对<code class="fe ml mm mn md b">ShopUser</code>表属性应用了一些必需的验证，以使用户输入的API更加健壮。</p><p id="844e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，由于<code class="fe ml mm mn md b">GET /api/shops/{pid}/users</code>的结果是ShopUser实体，我们添加了额外的逻辑将其转换成新的形式<code class="fe ml mm mn md b">ShopUserDto</code>。实际上，如果您不介意嵌套的结果，也可以在没有转换器的情况下使用它，因为默认情况下嵌套的<code class="fe ml mm mn md b">user</code>和<code class="fe ml mm mn md b">shop</code>属性将被填充到响应中。</p><p id="f974" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们进入第4步，对授权逻辑进行编程。如果你检查路径分析，你会得到一些错误如下。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/70b79d27c22586da68d6d9e35ea2aeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaRvigm2rc6h1hHmA8bmCQ.png"/></div></div></figure><p id="21c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的新路线是从21号线到26号线。您可以看到Plumier告诉了我们特定于<code class="fe ml mm mn md b">ShopUser</code>实体的缺失实体策略<code class="fe ml mm mn md b">ShopOwner</code>和<code class="fe ml mm mn md b">ShopStaff</code>。注意，在第21行和第22行上，对于<code class="fe ml mm mn md b">GET</code>方法和<code class="fe ml mm mn md b">POST</code>方法，它使用我们来自商店实体的最后一个实体策略，它使用<code class="fe ml mm mn md b">pid</code>作为上下文ID，因为它没有<code class="fe ml mm mn md b">id</code>参数。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Entity Policies for ShopUser Entity</figcaption></figure><p id="bdf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实体策略注册可以针对多个策略进行链接。上面的代码显示了我们用<code class="fe ml mm mn md b">ShopOwner</code>和<code class="fe ml mm mn md b">ShopStaff</code>策略为ShopUser实体注册了实体策略。隔离的逻辑只与商店用户相关，因为上下文ID是当前被访问的商店用户的ID。</p><h2 id="ff2a" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">程序商店产品管理</h2><p id="74d0" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">店铺产品管理的开发过程大多与店铺用户管理相同。它可以完全使用嵌套的第一类实体来实现。但是商店产品管理需要更多的处理，因为它关系到形象。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/6b3dfd6b8b151728f400f1ff419893d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G_ixji7tcJTKcfk7.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Shop — Product ERD</figcaption></figure><p id="2019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">带有图片上传工作流程的创建产品对话框的用户界面与下面脸书的创建文章对话框基本相同。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/942be1d0295783e29689b2d6419febed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEbf8cakArq9hoN5dkPCUg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Facebook Create Post Dialog</figcaption></figure><p id="d918" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图像上传功能(箭头所示)使用一个单独的API，在用户选择图像并返回id后调用该API。对话框本身使用另一个API来保存带有图片id的帖子。在我们的添加产品对话框中，我们将使用相同的技术。</p><ul class=""><li id="0ba1" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated">使用<code class="fe ml mm mn md b">POST /api/images/upload</code>上传图像，将记录保存到包含图像文件属性的<code class="fe ml mm mn md b">Image</code>表中，并返回图像记录的ID。这个API是使用自定义控制器手动创建的。</li><li id="415d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">添加产品对话框调用<code class="fe ml mm mn md b">POST /shops/{pid}/products</code>来保存创建的产品。与图像表有多对多关系的<code class="fe ml mm mn md b">images</code>属性可以用图像上传API返回的图像ID来填充。</li></ul><p id="16e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图片上传需要使用控制器手动编程，这非常简单。你可以从官方的Plumier例子<a class="ae jz" href="https://github.com/plumier/examples/tree/master/07-serve-static-and-file-upload" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p><p id="f7d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">商店产品管理可以完全使用嵌套的第一类实体来实现，并且不需要更多的工作。如果您在Swagger UI上看到适当的路径，您将看到多对多关系<code class="fe ml mm mn md b">images</code>属性接收数字(图像记录的id)而不是对象本身。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/075883bc09bdc333779770ddb6fd7bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AV-lIlownsSCrrNKOu2atA.png"/></div></div></figure><h2 id="72dd" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">计划购物车</h2><p id="d661" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">购物车和购物车item涉及两个表<code class="fe ml mm mn md b">Cart</code>和<code class="fe ml mm mn md b">CartItem</code>。我们将使用第一类实体和嵌套的第一类实体来开发它们。为了使API规范与UI工作流相匹配，下面将解释UI如何使用购物车API。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/c8ffdcf5ee2fecb1ea7607eeb69250b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AYg6ZrPzO0tz_PTY.png"/></div></div></figure><p id="23bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在继续编写代码之前，下面解释一下UI如何使用购物车API。</p><ul class=""><li id="59c7" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated">UI使用返回当前打开的购物车的ID的<code class="fe ml mm mn md b">GET /api/carts/open</code>请求打开的购物车。在内部，API将检查购物车状态，如果没有发现打开的购物车，它将创建一个新的购物车。该API行为不同于任何第一类实体动作行为，因此我们在自定义控制器中实现该API。</li><li id="74a7" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">UI使用<code class="fe ml mm mn md b">GET /api/carts/{pid}/items</code>作为购物车商品列表，其中<code class="fe ml mm mn md b">pid</code>是从<code class="fe ml mm mn md b">/open</code> API获得的当前购物车ID。该列表包含产品信息、商店信息、数量和小计。我们需要提供一个转换器来计算该项目的小计。</li><li id="b6d1" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">UI使用“添加到购物车”按钮上的<code class="fe ml mm mn md b">POST /api/carts/{pid}/items</code>。该API将一个商品添加到购物车商品中，如果已经添加了该商品，则合并该商品的数量。该API行为不同于第一类实体<code class="fe ml mm mn md b">POST</code>行为，因此我们在自定义控制器中实现该API。</li><li id="2aae" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">此外，购物车API可以使用购物车条目的<code class="fe ml mm mn md b">PATCH</code>和<code class="fe ml mm mn md b">DELETE</code>方法来修改和删除购物车条目。</li><li id="4868" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">UI可以使用<code class="fe ml mm mn md b">PATCH /api/carts/{id}</code>修改购物车(例如分配送货地址)。此API受限只能由资源所有者修改，并且购物车状态必须为打开。</li><li id="6cfc" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">UI使用<code class="fe ml mm mn md b">POST /api/carts/checkout</code>结账购物车。该方法将当前购物车状态设置为Close，并将所有商品复制到Order表和Order Item表中。这个API是使用自定义控制器手动创建的。</li></ul><p id="2c79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，基于上述详细的规范分解，我们实现了如下购物车。</p><ul class=""><li id="c668" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx nd mu mv mw bi translated">使用购物车的第一类实体，但只使用<code class="fe ml mm mn md b">PATCH</code>和<code class="fe ml mm mn md b">GET One</code>方法，忽略<code class="fe ml mm mn md b">POST</code>、<code class="fe ml mm mn md b">PUT</code>、<code class="fe ml mm mn md b">DELETE</code>、<code class="fe ml mm mn md b">GET Many</code>。</li><li id="a55f" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">为<code class="fe ml mm mn md b">/open</code>和<code class="fe ml mm mn md b">/checkout</code>单体使用自定义控制器。</li><li id="5e3d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">对购物车商品使用嵌套的第一类实体，忽略<code class="fe ml mm mn md b">POST</code>方法。</li><li id="0970" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx nd mu mv mw bi translated">使用自定义控制器获取购物车物品的<code class="fe ml mm mn md b">POST</code>方法。</li></ul><p id="e06b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以从源代码<a class="ae jz" href="https://github.com/plumier/examples/tree/master/08-complete-example/marketplace-api/src/api/carts" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jz" href="https://github.com/plumier/examples/tree/master/08-complete-example/marketplace-api/src/api/carts-items" rel="noopener ugc nofollow" target="_blank">这里</a>查看实现。</p><p id="87e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一件重要的事情是，用户不应该能够访问/修改关闭的购物车和购物车物品。我们将这个逻辑添加到用于保护购物车和购物车商品的<code class="fe ml mm mn md b">ResourceOwner</code>策略中。您可以从源代码中查看实现。</p><h2 id="5e57" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">遗言</h2><p id="5a8f" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">就是这样！这应该涵盖了所有的核心市场API规范。有了第一类实体，创建具有复杂授权系统的应用程序就相对容易了。如果你遵循上面解释的四个步骤，你会发现创建一个Marketplace API是非常容易的，并且不需要很长的编程时间，可能不到一周就可以完成。</p><p id="4f11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，如果你认为这个故事有帮助，考虑在你的社交媒体上分享这个故事。帮助Plumier在社区中获得更多关注。非常感谢！</p><p id="d260" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ni">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>