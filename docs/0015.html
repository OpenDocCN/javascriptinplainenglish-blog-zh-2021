<html>
<head>
<title>JavaScript Import vs Require Statements in Gatsby, Next.js, and Similar Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Gatsby、Next.js和类似的框架中JavaScript Import vs Require语句</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-import-vs-require-statements-in-gatsby-next-js-and-similar-frameworks-1de1145f1228?source=collection_archive---------3-----------------------#2021-01-02">https://javascript.plainenglish.io/javascript-import-vs-require-statements-in-gatsby-next-js-and-similar-frameworks-1de1145f1228?source=collection_archive---------3-----------------------#2021-01-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8e76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么在使用这些框架的项目目录的不同部分中,<code class="fe ki kj kk kl b">import</code>语句和<code class="fe ki kj kk kl b">require</code>语句的用法有所不同，回答了。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/93b583b5738ee08789267263b880644d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l00DovJrpHVFrtjL"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CHUTTERSNAP</a> on <a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我一直认为JavaScript的<code class="fe ki kj kk kl b">import</code>和<code class="fe ki kj kk kl b">require</code>语句或多或少是一样的。当你想使用不同文件或模块中的其他组件和功能时，你可以通过<code class="fe ki kj kk kl b">import</code>或<code class="fe ki kj kk kl b">require</code>将它们添加到你正在处理的文件中。我认为,<code class="fe ki kj kk kl b">import</code>和<code class="fe ki kj kk kl b">require</code>语句之间的唯一区别在于前者是后者的“更新”版本。没别的了。</p><p id="90e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我使用Gatsby框架进行一个项目时，我的预想被证明是错误的。在<code class="fe ki kj kk kl b">src</code>目录中编写代码时，我使用<code class="fe ki kj kk kl b">import</code>或<code class="fe ki kj kk kl b">require</code>语句都没有问题。然而，当涉及到在位于根目录的文件上配置应用程序时，当使用<code class="fe ki kj kk kl b">import</code>语句时，错误开始出现。在深入研究这个问题之后，我发现了以下情况。</p><h1 id="131f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">模块之前Javascript的一点历史</h1><p id="2372" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在JavaScript <code class="fe ki kj kk kl b">require</code>和<code class="fe ki kj kk kl b">import</code>语句出现之前，没有真正可行的方法使JavaScript模块化。javascript语言没有自己的模块特性。唯一能做的就是将代码分成不同的javascript文件，并将每个文件作为自己的<code class="fe ki kj kk kl b">&lt;script&gt;</code>标签添加到html文件中。</p><p id="2d1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用<code class="fe ki kj kk kl b">&lt;script&gt;</code>标签进行模块化，您必须格外小心<code class="fe ki kj kk kl b">&lt;script&gt;</code>标签的排序。如果您只有几个javascript文件，这是可以管理的。但是，如果因为app的规模而不得不管理几十个文件的顺序，那将是一种痛苦。</p><p id="c794" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe ki kj kk kl b">&lt;script/&gt;</code>标签的另一个问题与全局范围/名称空间的使用有关。变量、函数和类被放在全局范围内，造成了混乱。您只希望一个文件中的代码不会与其他文件中的代码冲突，因为所有代码都占用相同的全局名称空间。</p><p id="ffba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了应对全局范围污染问题，程序员可以求助于立即调用函数表达式(IIFE)和模块对象。这样，您可以将相关的方法和值放入一个对象中，同时让所有的局部变量都留在IIFE函数的局部范围内。尽管如此，这并没有解决排序问题。此外，您只是将全局范围内的对象数量减少到几个，而不是全部消除。</p><h1 id="f3b3" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">CommonJS和NodeJS</h1><p id="8c34" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">随着javascript开始成为首选语言，让它在浏览器之外运行是利用javascript的一种新方式。当在浏览器之外使用javascript时，也应该实现模块化。最好将代码放在不同的文件中，每个文件都有自己的功能，而不是在一个文件中放很多行代码。</p><p id="21a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建CommonJS标准是为了解决浏览器之外的javascript模块化问题。当时，javascript只能通过使用不同的<code class="fe ki kj kk kl b">&lt;script&gt;</code>标签将每个javascript文件包含在同一个html页面中来实现“模块化”。在浏览器之外根本没有办法实现同样的壮举。浏览器外的Javascript不依赖于html文件。通过使用CommonJS标准，一个文件中的代码可以毫不费力地在另一个文件中使用。注意，CommonJS不是一个库，而是一个标准。通过使用用于导入模块/代码的<code class="fe ki kj kk kl b">require</code>语句和用于导出模块/代码的<code class="fe ki kj kk kl b">module.exports</code>语句来识别CommonJS标准。</p><p id="7b8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2009年，NodeJS面世，boy做到了在浏览器之外普及javascript。它开始成为后端开发最受欢迎的选择之一。NodeJS在实现模块系统时采用了CommonJS标准。因此，当使用NodeJS时，模块化代码的方法是使用CommonJS的<code class="fe ki kj kk kl b">require</code>和<code class="fe ki kj kk kl b">module.exports</code>。</p><h1 id="07e2" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">ES6导入</h1><p id="063e" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">随着ES6或ECMAScript 2015的发布，javascript语言获得了自己的模块系统实现。模块系统的Javascript ES6实现可以用<code class="fe ki kj kk kl b">import</code>和<code class="fe ki kj kk kl b">export</code>语句来标识。顾名思义，我们使用<code class="fe ki kj kk kl b">import</code>语句导入功能，否则使用<code class="fe ki kj kk kl b">export</code>语句。使用ES6，您可以在引用其他javascript文件(模块)的html中只包含一个javascript文件。</p><p id="2c0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在发布的时候，浏览器并没有立即实现ES6。浏览器适应起来很慢(尽管在撰写本文时，除了Internet Explorer，几乎所有主流浏览器都实现了ES6)。一些浏览器很快实现了ES6，而另一些则采取了缓慢的方式。</p><p id="c437" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了帮助使用ES6，同时确保在当时不同的浏览器上正确实现，创建了捆绑器和编译器。这些库中最受欢迎的是Webpack和Babel。通过使用Webpack和Babel，javascript的ES6实现可以被转换、编译和捆绑成与浏览器兼容的javascript，而不管浏览器实现ECMAScript版本。</p><p id="378f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Webpack高度利用ES6导入和导出。然而，Webpack中的导出和导入系统实际上有助于依赖图的创建。依赖图指出了哪个文件依赖于哪个其他文件。然后，在将所有这些相关文件或“模块”捆绑成一个javascript文件的过程中，会用到这个映射(或者，如果您要进行代码拆分，会用到几个javascript文件——但这是另一个主题)。</p><p id="5bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了将ES6 javascript转换成与浏览器兼容的javascript，通过Webpack的加载器特性使用babel-loader。除了babel-loader来转换ES6+ javascript代码之外，还有其他加载器允许我们捆绑javascript之外的静态资源。这个特性使得Webpack能够加载javascript之外其他文件类型。因此，使用Webpack，像<code class="fe ki kj kk kl b">import "a.png"</code>、<code class="fe ki kj kk kl b">import “b.css"</code>和<code class="fe ki kj kk kl b">import "c.jpeg"</code>这样的导入语句是可能的。</p><h1 id="d859" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Gatsby、Next.js和类似框架中的需求与导入</h1><p id="7acd" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">回到手头的问题。作为一个典型的Gatsby项目，我的文件夹结构如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/0be883e84d9e6355f62716710dce65ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*wXJaV5d66K0WCd4Nt0ewmQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">My project folder structure</figcaption></figure><p id="2ce4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的主代码在<code class="fe ki kj kk kl b">src</code>目录里面，而所有的配置代码(比如<code class="fe ki kj kk kl b">gatsby-config</code>、<code class="fe ki kj kk kl b">gatsby-node</code>、<code class="fe ki kj kk kl b">gatsby-browser</code>)都在根目录外面。对于在<code class="fe ki kj kk kl b">src</code>目录中使用<code class="fe ki kj kk kl b">require</code>和<code class="fe ki kj kk kl b">import</code>语句，我没有任何问题。然而，只有<code class="fe ki kj kk kl b">require</code>语句在配置文件中起作用(在<code class="fe ki kj kk kl b">src</code>目录之外，在根目录中)，而<code class="fe ki kj kk kl b">import</code>语句不起作用。</p><p id="cd64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gatsby使用Webpack来捆绑文件，并使用Babel将ES6和React的JSX语法转换为浏览器可以读取的javascript。<code class="fe ki kj kk kl b">import</code>语句和<code class="fe ki kj kk kl b">require</code>语句都在<code class="fe ki kj kk kl b">src</code>目录中工作(在主代码中),因为这些代码将在稍后的构建过程中使用Babel和Webpack进行传输和捆绑。另一方面，位于根目录中(在<code class="fe ki kj kk kl b">src</code>之外)的配置文件中的javascript代码无法利用ES6 <code class="fe ki kj kk kl b">import</code>，因为它运行在NodeJS生态系统中，我们之前知道它采用了CommonJS标准作为默认标准。</p><p id="1406" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况并不是盖茨比独有的。在撰写本文时，当您使用其他框架(比如Next.js)开始一个项目时，<code class="fe ki kj kk kl b">require</code>和<code class="fe ki kj kk kl b">import</code>语句的二分法也会出现。</p><h1 id="aed1" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">节点中的ES模块</h1><p id="b736" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">你可能会问，NodeJS会实现ES6 <code class="fe ki kj kk kl b">import</code>语句吗？从技术上讲，答案是已经有了。从2018年NodeJS版本10开始已经采用ES6模块，尽管仍处于实验状态(截至本文撰写时的版本15，状态已经稳定)。然而，CommonJS <code class="fe ki kj kk kl b">require</code>语句并没有被弃用。ES6模块和CommonJS标准在NodeJS生态系统中并存，CommonJS标准是默认的。</p><p id="d098" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在NodeJS中使用ES6模块，我们需要将我们的文件扩展名设置为<code class="fe ki kj kk kl b">.mjs</code>而不是典型的<code class="fe ki kj kk kl b">.js</code>扩展名。这意味着，您应该将文件命名为<code class="fe ki kj kk kl b">index.mjs</code>而不是<code class="fe ki kj kk kl b">index.js</code>。另一种方法是让我们的javascript文件仍然作为一个<code class="fe ki kj kk kl b">.js</code>扩展名，但是我们需要在项目的<code class="fe ki kj kk kl b">package.json</code>中将类型字段指定为“模块”。通过将<code class="fe ki kj kk kl b">.mjs</code>作为文件扩展名或在<code class="fe ki kj kk kl b">package.json</code>中将字段类型定义为“模块”，CommonJS <code class="fe ki kj kk kl b">require</code>语句不能在该文件中使用。</p><p id="39d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了明确而有目的地使用commonjs标准，我们可以使用<code class="fe ki kj kk kl b">.cjs</code>扩展(例如<code class="fe ki kj kk kl b">index.cjs</code>)或将<code class="fe ki kj kk kl b">package.json</code>中的类型字段指定为“CommonJS”。这样，您可以根据需要在节点环境中使用<code class="fe ki kj kk kl b">require</code>语句。</p><h1 id="f9e3" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="ef52" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">概括地说，在典型的javascript框架(如Gatsby或Next.js)项目结构中，<code class="fe ki kj kk kl b">require</code>和<code class="fe ki kj kk kl b">import</code>语句都可以在<code class="fe ki kj kk kl b">src</code>目录中使用，因为这些文件将在生产构建过程的后期使用Babel和Webpack进行转换、编译和打包。同时，位于根目录下<code class="fe ki kj kk kl b">src</code>目录之外的配置文件将不会被转换、编译或捆绑，而是会在NodeJS环境中运行。由于NodeJS默认采用了CommonJS系统，所以它只能理解<code class="fe ki kj kk kl b">require</code>语句。</p><p id="b9d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在撰写本文时，NodeJS已经实现了ES6 <code class="fe ki kj kk kl b">import</code>语句的稳定版本。然而，使用它需要对规范进行一些简单的修改。</p></div></div>    
</body>
</html>