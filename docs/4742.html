<html>
<head>
<title>Angular: DON'T Call Functions Inside The Template Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:不再调用模板内部的函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-dont-call-a-function-inside-the-template-anymore-e74ebf499bb8?source=collection_archive---------0-----------------------#2021-09-22">https://javascript.plainenglish.io/angular-dont-call-a-function-inside-the-template-anymore-e74ebf499bb8?source=collection_archive---------0-----------------------#2021-09-22</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="e3c4" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">为什么不应该在角度模板中调用函数</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/e6ecf1080f828267dedfc9260504574c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYyAJ__Bbrdvh9gG-PYxKA.jpeg"/></div></div></figure><p id="277e" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">模板是HTML的一种形式，它告诉Angular如何呈现组件。每个组件都有自己的模板，模板定义了组件的元素和外观。但是最常见的误用技术之一是调用模板内部的函数。</p><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="b2e7" class="lq lr io lm b gz ls lt l lu lv">import { <strong class="lm ip"><em class="lw">Component </em></strong>} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let <strong class="lm ip"><em class="lw">name</em></strong> of filterNames()"&gt;{{ <strong class="lm ip"><em class="lw">name</em></strong> }}&lt;/div&gt;`,<br/>})<br/>export class PerformanceIssueComponent {<br/><br/>  names = ['Maria', 'Michel', 'Jack', 'John', 'Sam', 'Mila'];<br/><br/>  filterNames(): string[] {<br/>    return this.names.filter(name =&gt; name.startsWith('M'));<br/>  }<br/>}</span></pre><p id="018a" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">用这种方法很容易得到计算值。但是这可能会导致一个严重的性能问题，我们应该注意到这一点。</p></div><div class="ab cl lx ly hs lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ih ii ij ik il"><h1 id="7d7b" class="me lr io bd mf mg mh mi mj mk ml mm mn ju mo jv mp jx mq jy mr ka ms kb mt mu bi translated">问题是</h1><p id="8d01" class="pw-post-body-paragraph kp kq io kr b ks mv jp ku kv mw js kx ky mx la lb lc my le lf lg mz li lj lk ih bi translated">问题的核心与更改检测机制有关，Angular使用该机制来检测更改的数据并更新DOM受影响的部分。然而，Angular无法检测函数调用的值是否有任何变化。事实是，模板中的所有函数都将在每个变更检测周期中重新执行，以便进行比较。</p><p id="48aa" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">例如，在上面的代码片段中，很明显<code class="fe na nb nc lm b"><em class="lw">filterNames()</em></code> <em class="lw"> </em>依赖于<em class="lw">名称。</em>如果<code class="fe na nb nc lm b"><em class="lw">filterNames()</em></code> <em class="lw"> </em>没有变化，那么<em class="lw">名称</em>也没有变化。即使在变化检测周期中没有值变化，仍然会调用<code class="fe na nb nc lm b"><em class="lw">filterNames()</em></code> <em class="lw"> </em>，因为Angular引擎还不能检测这种类型的关系。</p><p id="cb71" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">让我们实际看看问题的核心。</p><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="c4fc" class="lq lr io lm b gz ls lt l lu lv">import { <strong class="lm ip"><em class="lw">Component </em></strong>} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let name of filterNames()"&gt;{{ name }}&lt;/div&gt;<br/>    &lt;button (click)="onClick()"&gt;Click Me!&lt;/button&gt;`,<br/>})<br/>export class PerformanceIssueComponent {<br/><br/>  names = ['Maria', 'Michel', 'Jack', 'John', 'Sam', 'Mila'];<br/><br/>  filterNames(): string[] {<br/>    <strong class="lm ip"><em class="lw">console</em></strong>.log("filterNames() called!");<br/>    return this.names.filter(name =&gt; name.startsWith('M'));<br/>  }<br/><br/>  onClick() {<br/>    <strong class="lm ip"><em class="lw">console</em></strong>.log("Button clicked!");<br/>  }<br/>}</span></pre><p id="2fc3" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">每次点击按钮(触发了一个变化检测周期)，总会重新执行<code class="fe na nb nc lm b"><em class="lw">filterNames()</em></code>函数，如下图截图所示。</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div class="gi gj nd"><img src="../Images/414c1738d688925ca4a9068e98ae99d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*u_l68T1-woa3Mbr_uSdUWw.png"/></div></figure><blockquote class="ne nf ng"><p id="e8cb" class="kp kq lw kr b ks kt jp ku kv kw js kx nh kz la lb ni ld le lf nj lh li lj lk ih bi translated">在开发模式下，预计每个检测周期会调用该函数两次。这是一个角度调试功能。<a class="ae nk" href="https://stackoverflow.com/questions/56785866/why-is-change-detection-called-twice" rel="noopener ugc nofollow" target="_blank">下面是更详细的解释</a></p></blockquote><p id="82ea" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">每当按钮被点击时调用函数听起来无害，因为没有人会一直点击它。</p><p id="501d" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">Angular中有一些特性在后台非常频繁地触发变化检测，比如绑定到<code class="fe na nb nc lm b"><em class="lw">mousemove</em></code> <em class="lw"> </em>事件。当我们在应用程序中使用这些特性时，函数的重新执行将成为一个不可忽视的问题。例如，看看下面的代码片段。</p><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="ea4f" class="lq lr io lm b gz ls lt l lu lv">import { Component } from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let name of filterNames()"&gt;{{ name }}&lt;/div&gt;<br/>    &lt;div<br/>        style="height: 300px; width: 300px; background-color: #2f487e;"<br/>        (mousemove)="onMousemove()"&gt;<br/>    &lt;/div&gt;`,<br/>})<br/>export class PerformanceIssueComponent {<br/><br/>  names = ['Maria', 'Michel', 'Jack', 'John', 'Sam', 'Mila'];<br/>  counter = 0;<br/><br/>  filterNames(): string[] {<br/>    this.counter++<br/>    console.log("filterNames() called! " + this.counter + " times!");<br/>    return this.names.filter(name =&gt; name.startsWith('M'));<br/>  }<br/><br/>  onMousemove() {<br/>    console.log('Mouse moved');<br/>  }<br/>}</span></pre><p id="ce81" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">通过在带有<code class="fe na nb nc lm b"><em class="lw">mousemove</em></code> <em class="lw"> </em>绑定的<code class="fe na nb nc lm b"><em class="lw">&lt;div&gt;</em></code>中移动光标，我们将看到该函数在很短的时间内被执行了数百次。</p><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/fe4a312d066195611a80df8faacd31ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*ywSGT-0_5NMgiglTtO8IkA.png"/></div></figure><p id="2e69" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">如果只有几个函数调用，最初的影响可能并不明显。然而，当越来越多的新组件添加到应用程序中时，它们会呈指数级增长，最终耗尽所有的计算能力并使应用程序变慢。</p><p id="34d2" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">有些人可能会想到使用getter方法来避免函数调用。但实际上是不行的，因为getter方法也是函数调用，也有同样的问题。</p><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="6222" class="lq lr io lm b gz ls lt l lu lv">import { Component } from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let name of filteredNames"&gt;{{ name }}&lt;/div&gt;<br/>    &lt;div<br/>        style="height: 300px; width: 300px; background-color: #2f487e;"<br/>        (mousemove)="onMousemove()"&gt;<br/>    &lt;/div&gt;`,<br/>})<br/>export class PerformanceIssueComponent {<br/><br/>  names = ['Maria', 'Michel', 'Jack', 'John', 'Sam', 'Mila'];<br/>  counter = 0;<br/><br/>  get filteredNames(): string[] {<br/>    this.counter++<br/>    console.log("filterNames() called! " + this.counter + " times!");<br/>    return this.names.filter(name =&gt; name.startsWith('M'));<br/>  }<br/><br/>  onMousemove() {<br/>    console.log('Mouse moved');<br/>  }<br/>}</span></pre><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div class="gi gj nm"><img src="../Images/f368655cc92f530253736205fa93d380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*jCmltyjtNqlzGb8pEKkU2w.png"/></div></figure></div><div class="ab cl lx ly hs lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ih ii ij ik il"><h1 id="f561" class="me lr io bd mf mg mh mi mj mk ml mm mn ju mo jv mp jx mq jy mr ka ms kb mt mu bi translated">解决方案</h1><p id="35a2" class="pw-post-body-paragraph kp kq io kr b ks mv jp ku kv mw js kx ky mx la lb lc my le lf lg mz li lj lk ih bi translated">事实上，这个问题没有完美的解决方案。Angular必须在变化检测期间重新执行模板内部的所有函数，这是其设计的一个限制。一个可能的解决方法是避免复杂计算的模板函数调用。如果我们需要一些计算值，我们应该自己手动管理它们，而不是依赖角度变化检测。</p><h2 id="0bec" class="lq lr io bd mf nn no dn mj np nq dp mn ky nr ns mp lc nt nu mr lg nv nw mt nx bi translated">解决方案1 —使用setter函数</h2><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="256a" class="lq lr io lm b gz ls lt l lu lv">import {<strong class="lm ip"><em class="lw">Component</em></strong>, <strong class="lm ip"><em class="lw">Input</em></strong>} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let name of filteredNames"&gt;{{ name }}&lt;/div&gt;`,<br/>})<br/>export class PerformanceIssueComponent {<br/><br/>  filteredNames = []<br/><br/>  @Input() set names(value: string[]) {<br/>    this.filteredNames = value.filter(name =&gt; name.startsWith('M'));<br/>  }<br/>}</span></pre><h2 id="0e89" class="lq lr io bd mf nn no dn mj np nq dp mn ky nr ns mp lc nt nu mr lg nv nw mt nx bi translated">解决方案2 —使用<em class="ny"> ngOnChanges </em></h2><pre class="ke kf kg kh gu ll lm ln lo aw lp bi"><span id="762e" class="lq lr io lm b gz ls lt l lu lv">import {Component, Input, OnChanges, SimpleChanges} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-performance-issue',<br/>  template: `<br/>    &lt;div *ngFor="let name of filteredNames"&gt;{{ name }}&lt;/div&gt;`,<br/>})<br/>export class PerformanceIssueComponent implements OnChanges{<br/><br/>  @Input() names = []<br/>  filteredNames = []<br/><br/>  ngOnChanges(changes: SimpleChanges): void {<br/>    if (changes.value) {<br/>      this.filteredNames = this.names.filter(name =&gt; name.startsWith('M'));<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl lx ly hs lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ih ii ij ik il"><p id="a144" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">感谢阅读！</p><p id="c204" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated">任何意见都将受到高度赞赏。</p><p id="cd98" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated"><strong class="kr ip">快乐编码:D </strong></p><p id="9401" class="pw-post-body-paragraph kp kq io kr b ks kt jp ku kv kw js kx ky kz la lb lc ld le lf lg lh li lj lk ih bi translated"><em class="lw">更多内容尽在</em><a class="ae nk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kr ip"><em class="lw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>