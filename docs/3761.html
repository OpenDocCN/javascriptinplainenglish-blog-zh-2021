<html>
<head>
<title>Ember.js: The Good Parts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好的部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ember-js-the-good-parts-f80850414053?source=collection_archive---------7-----------------------#2021-07-28">https://javascript.plainenglish.io/ember-js-the-good-parts-f80850414053?source=collection_archive---------7-----------------------#2021-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9f93" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">辛烷真的很好</h2></div><p id="6e85" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从2017年年中开始，我就一直在使用Ember.js，一开始，它相当具有挑战性。我在这个帖子中记录了我的挑战，我用Ember.js 记录了我面临的挑战。自从我发表我的挑战已经两年多了，随着时间的推移，它们中的大部分都消失了，相反，我发现用Ember.js进行开发是令人愉快的。</p><p id="72ed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本帖中，我将分享Ember.js的好的部分，以我的拙见。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/58ab624083ed4ff6003e71773175a49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qjex-6IivmVyLI5kCEYog.jpeg"/></div></div></figure><ul class=""><li id="3f7a" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">本机类而不是Ember对象模型</li><li id="dfe6" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">@decorators</code></li><li id="11ce" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">@tracked</code>和本土的<code class="fe lz ma mb mc b">get</code> ters而不是<code class="fe lz ma mb mc b">@computed</code>属性。</li><li id="c908" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">this.property</code>而不是<code class="fe lz ma mb mc b">get()</code>和<code class="fe lz ma mb mc b">set()</code></li><li id="fc99" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">Component</code>世界的大变革</li></ul><ol class=""><li id="1f5e" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx md lr ls lt bi translated">模板协同定位</li><li id="0536" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">&lt;AngleBracket/&gt;</code>组件的语法超过<code class="fe lz ma mb mc b">{{handle-bar}}</code></li><li id="229a" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">@named</code>元件中的自变量</li><li id="8a53" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">{{this.property}}</code>在模板中</li><li id="f691" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated">如<code class="fe lz ma mb mc b">on</code>、<code class="fe lz ma mb mc b">fn</code>、<code class="fe lz ma mb mc b">did-insert</code>、<code class="fe lz ma mb mc b">on-destroy</code>等修饰词</li></ol><h1 id="8b29" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">本地班级</h1><p id="99b0" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在原生类的支持下，它只是JavaScript，没有Ember对象模型的任何负担。Ember对象模型对我来说极具挑战性，主要是因为嵌套的抽象。随着对原生类支持的引入，我的JavaScript知识已经足够了，我不需要理解内部原理就能高效工作。</p><p id="0762" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">快速对比:</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="30a0" class="nf mf in mc b gy ng nh l ni nj">// pre Octane<br/>export default Component.extend({<br/> init() {<br/>   this._super(...arguments);<br/>   this.set('answer', 42);<br/> }<br/>});</span><span id="6c20" class="nf mf in mc b gy nk nh l ni nj">//Octane<br/>export default class MyComponent extends Component {<br/> constructor(owner, args) {<br/>   super(owner, args);<br/>   this.answer = 42;<br/> }<br/>}</span></pre><p id="64cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意标准的<code class="fe lz ma mb mc b">class</code>定义、<code class="fe lz ma mb mc b">extends</code>、<code class="fe lz ma mb mc b">constructor</code>、<code class="fe lz ma mb mc b">super</code>语法代替了<code class="fe lz ma mb mc b">extend</code>、<code class="fe lz ma mb mc b">init</code>、<code class="fe lz ma mb mc b">this._super</code>语法。</p><p id="c3e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在Ember Guide 阅读更多关于本地类及其好处的内容。</p><h1 id="7bf1" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated"><code class="fe lz ma mb mc b">@decorators</code></h1><blockquote class="nl nm nn"><p id="9a9b" class="kc kd no ke b kf kg jo kh ki kj jr kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated">装饰器是在定义期间在类、类元素或其他JavaScript语法形式上调用的<em class="in">函数</em>。</p></blockquote><p id="8091" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lz ma mb mc b">@decorators</code>的引入进一步简化了语法。</p><p id="6af4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="732d" class="nf mf in mc b gy ng nh l ni nj">@service('some-service')<br/>someService;</span><span id="8198" class="nf mf in mc b gy nk nh l ni nj">// instead of</span><span id="7f5e" class="nf mf in mc b gy nk nh l ni nj">someService: service('some-service')</span><span id="1775" class="nf mf in mc b gy nk nh l ni nj">...</span><span id="b1f9" class="nf mf in mc b gy nk nh l ni nj">@action<br/>someAction() {}</span><span id="32ef" class="nf mf in mc b gy nk nh l ni nj">//instead of</span><span id="9fe3" class="nf mf in mc b gy nk nh l ni nj">actions {<br/>  someAction() {}<br/>}</span></pre><p id="60ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lz ma mb mc b">@service</code>、<code class="fe lz ma mb mc b">@action</code>等。不仅简化和统一了用法，而且减少了认知负荷。</p><p id="73c4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，我不确定我们是否需要<code class="fe lz ma mb mc b">@action</code>装潢师。我发现箭头函数<code class="fe lz ma mb mc b">() =&gt; {}</code>也是为了同样的目的，在下面的例子中，<code class="fe lz ma mb mc b">someArrowFunction</code>和<code class="fe lz ma mb mc b">someAction</code> <a class="ae ky" href="https://codesandbox.io/s/thirsty-shape-zo8t4?file=/app/services/foo.js" rel="noopener ugc nofollow" target="_blank">达到了同样的结果</a>。</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="e7e1" class="nf mf in mc b gy ng nh l ni nj">export default class MyComponent extends <!-- -->Component<!-- --> {<br/>  someArrowFunction = () =&gt; {},</span><span id="6819" class="nf mf in mc b gy nk nh l ni nj">  @action<br/>  someAction() {}<br/>}</span></pre><p id="fd83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这些装修工中，我最喜欢的是<code class="fe lz ma mb mc b">@tracked</code>。</p><h1 id="fbdd" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated"><code class="fe lz ma mb mc b">@tracked and native getter</code></h1><p id="72c7" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated"><code class="fe lz ma mb mc b">@tracked</code>很明显，相应的属性正在被跟踪，并且每当它被更新时，变化都会反映在UI中。</p><p id="5ab4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在辛烷前版本中，这是通过以下方式实现的:</p><ul class=""><li id="37fa" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">computed property</code></li><li id="ad5e" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">this.set()</code></li><li id="db68" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated"><code class="fe lz ma mb mc b">set()</code></li></ul><p id="a96a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不清楚观察到哪个属性发生了变化，需要在<code class="fe lz ma mb mc b">.js</code>文件中查找<code class="fe lz ma mb mc b">this.set()</code>、<code class="fe lz ma mb mc b">set</code>或<code class="fe lz ma mb mc b">computed property</code>。</p><p id="f213" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="7b8d" class="nf mf in mc b gy ng nh l ni nj">// pre Octane<br/>import Component from '<a class="ae ky" href="http://twitter.com/ember/component" rel="noopener ugc nofollow" target="_blank">@ember/component</a>';</span><span id="6b7d" class="nf mf in mc b gy nk nh l ni nj">export default Component.extend({<br/>  count: 0,<br/>  <br/>  suffixedValue: computed('count', <!-- -->function() {<br/>    return foo + this.get('count')<br/>  }),</span><span id="b941" class="nf mf in mc b gy nk nh l ni nj">  actions: {<br/>    increase() {<br/>      this.set('count', this.get('count') + 1);<br/>    }, <br/>    decrease() {<br/>      this.set('count', this.get('count') - 1);<br/>    }<br/>  }<br/>});</span><span id="7449" class="nf mf in mc b gy nk nh l ni nj">// Octane<br/>import Component from '<a class="ae ky" href="http://twitter.com/glimmer/component" rel="noopener ugc nofollow" target="_blank">@glimmer/component</a>';<br/>import { tracked } from '<a class="ae ky" href="http://twitter.com/glimmer/tracking" rel="noopener ugc nofollow" target="_blank">@glimmer/tracking</a>';</span><span id="6185" class="nf mf in mc b gy nk nh l ni nj">export default class MyComponent extends Component {<br/>  <a class="ae ky" href="http://twitter.com/tracked" rel="noopener ugc nofollow" target="_blank">@tracked</a> count = 0;<br/>  <br/>  get suffixedValue() { <br/>    return 'foo' + this.count<br/>  }</span><span id="f092" class="nf mf in mc b gy nk nh l ni nj">  increase = () =&gt; {<br/>    this.count = this.count + 1;<br/>  };</span><span id="d161" class="nf mf in mc b gy nk nh l ni nj">  decrease = () =&gt; {<br/>    this.count = this.count + 1;<br/>  };<br/>}</span></pre><p id="854e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，Octane语法是普通的JavaScript，没有任何Ember抽象，不像pre Octane语法。不需要使用<code class="fe lz ma mb mc b">set</code>来获得反映在模板中的变化。通过使用<code class="fe lz ma mb mc b">@tracked</code>装饰器，我们已经明确地确保了反应性，并且剥夺了未来维护者追踪反应性来源的乐趣。</p><h1 id="83c4" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated"><code class="fe lz ma mb mc b">Component</code>世界的大变革</h1><p id="36ea" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">组件世界已经有了一些改进，我最喜欢的是这样的:</p><ol class=""><li id="5656" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx md lr ls lt bi translated">模板协同定位</li><li id="e141" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">&lt;AngleBracket/&gt;</code>超过<code class="fe lz ma mb mc b">{{handle-bar}}</code>的组件的语法</li><li id="6904" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">@named</code>论据中的成分</li><li id="83e5" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated"><code class="fe lz ma mb mc b">{{this.property}}</code>在模板中</li><li id="dc5c" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx md lr ls lt bi translated">如<code class="fe lz ma mb mc b">on</code>、<code class="fe lz ma mb mc b">fn</code>、<code class="fe lz ma mb mc b">did-insert</code>、<code class="fe lz ma mb mc b">on-destroy</code>等修饰语</li></ol><h2 id="eae6" class="nf mf in bd mg ns nt dn mk nu nv dp mo kl nw nx mq kp ny nz ms kt oa ob mu oc bi translated">模板协同定位</h2><p id="3dc2" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">技术上，模板协同定位在前辛烷时代也是可能的，<a class="ae ky" href="https://cli.emberjs.com/release/advanced-use/project-layouts/#podslayout" rel="noopener ugc nofollow" target="_blank">通过</a> <code class="fe lz ma mb mc b"><a class="ae ky" href="https://cli.emberjs.com/release/advanced-use/project-layouts/#podslayout" rel="noopener ugc nofollow" target="_blank">pod</a></code>，然而，它不是主流。对我来说，这真的是一件大事，让<code class="fe lz ma mb mc b">.js</code>和它对应的<code class="fe lz ma mb mc b">.hbs</code>共处一地，当我在编辑器浏览器中看到对应的文件时，访问对应的文件会容易得多。当然，我可以使用模糊搜索或类似于<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=suchitadoshi1987.file-hopper" rel="noopener ugc nofollow" target="_blank">相关文件Hopper </a>的扩展，但是没有什么比协同定位更好的了，至少对我来说是这样。</p><p id="8242" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望有一天，甚至测试文件也能放在一起。</p><h2 id="45b4" class="nf mf in bd mg ns nt dn mk nu nv dp mo kl nw nx mq kp ny nz ms kt oa ob mu oc bi translated"><code class="fe lz ma mb mc b">&lt;AngleBracket/&gt;</code></h2><p id="c5f2" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">再次，<AngleBracket/>在辛烷之前的版本中受到支持，但在辛烷中成为主流。</p><p id="c0c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对我来说，最直接的好处是在。hbs文件。早些时候这是一个巨大的挑战。</p><p id="80a5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哦，等等，还有一个缺点。在<AngleBracket/>之前的日子里，组件的使用与<code class="fe lz ma mb mc b">file-name</code>非常相似，并且经常很容易在代码库中搜索相同的<code class="fe lz ma mb mc b">file-name</code>。然而，随着<code class="fe lz ma mb mc b">&lt;AngleBracket/&gt;</code>的出现，我的工作流程发生了变化。我不能再简单的搜索<code class="fe lz ma mb mc b">file-name</code>，而是转换成<code class="fe lz ma mb mc b">PascalCase</code> ( <code class="fe lz ma mb mc b">FileName</code>)再搜索。嗯，考虑到它带来的其他好处，这不是一个交易破坏者。</p><h2 id="66b8" class="nf mf in bd mg ns nt dn mk nu nv dp mo kl nw nx mq kp ny nz ms kt oa ob mu oc bi translated">@命名参数</h2><p id="d899" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">又一个善良！只要看一下语法，我就能确切地知道该属性是自己的属性还是作为参数传递的。<code class="fe lz ma mb mc b">@named</code>语法用于将参数传递给组件。</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="04e0" class="nf mf in mc b gy ng nh l ni nj">//pre Octane<br/>{{some-component someProperty="some-value"/}}</span><span id="afc3" class="nf mf in mc b gy nk nh l ni nj">// Octane<br/>&lt;SomeComponent @someProperty="some-value"/&gt;</span></pre><p id="1c2c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最好的部分是如何访问这些<code class="fe lz ma mb mc b">@named</code>参数。</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="fea8" class="nf mf in mc b gy ng nh l ni nj">// pre Octane<br/>// not easy to identify from the usage, <br/>// if someProperty is a own property<br/>// or passed as an argumemnt<br/>this.get('someProperty'); //in .js, </span><span id="aae4" class="nf mf in mc b gy nk nh l ni nj">{{someProperty}} // in .hbs</span><span id="0a01" class="nf mf in mc b gy nk nh l ni nj">// Octane<br/>// the presense of `args` in .js and `@` in .hbs<br/>// cleaarly identifes it to be<br/>// passed as an argumemnt<br/>this.args.someProperty; //in .js</span><span id="ab51" class="nf mf in mc b gy nk nh l ni nj">{{@someProperty}} // in .hbs</span></pre><h2 id="f60d" class="nf mf in bd mg ns nt dn mk nu nv dp mo kl nw nx mq kp ny nz ms kt oa ob mu oc bi translated"><code class="fe lz ma mb mc b">{{this.property}}</code>在模板中</h2><p id="2c66" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated"><code class="fe lz ma mb mc b">{{this.property}}</code>补充了<code class="fe lz ma mb mc b">{{@namedArgument}}</code>在模板中访问其相应值的功能。通过查看语法，我可以很容易地识别出哪个是自己的属性，哪个是作为参数传递的。</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="1b54" class="nf mf in mc b gy ng nh l ni nj">// pre Octane<br/>{{somePropertyOrArgument}}</span><span id="4da0" class="nf mf in mc b gy nk nh l ni nj">// Octane<br/>{{this.property}} {{!-- own property --}}<br/>{{@namedArgument}} {{!-- passed argument --}}</span></pre><h2 id="c0b2" class="nf mf in bd mg ns nt dn mk nu nv dp mo kl nw nx mq kp ny nz ms kt oa ob mu oc bi translated">像<code class="fe lz ma mb mc b">on</code>、<code class="fe lz ma mb mc b">fn</code>这样的修饰词</h2><p id="d68b" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">我发现像<code class="fe lz ma mb mc b">{{on}}</code>、<code class="fe lz ma mb mc b">{{fn}}</code>这样的修饰符比<code class="fe lz ma mb mc b">{{action}}</code>更直观，<code class="fe lz ma mb mc b">{{action}}</code>很神奇，它从<code class="fe lz ma mb mc b">.js</code>中查找相应的函数，默认情况下将它附加到<code class="fe lz ma mb mc b">click</code>事件，并负责传递相应函数的参数，等等。</p><p id="b3a5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，这些修改器的功能更直观。例如，<code class="fe lz ma mb mc b">on</code>用于处理事件，<code class="fe lz ma mb mc b">fn</code>用于创建包装函数。</p><pre class="la lb lc ld gt nb mc nc nd aw ne bi"><span id="8061" class="nf mf in mc b gy ng nh l ni nj">//pre Octane<br/>&lt;button<br/>  type="button"<br/>  {{action "someAction"}}<br/>&gt;</span><span id="36c9" class="nf mf in mc b gy nk nh l ni nj">&lt;button<br/>  type="button"<br/>  onclick={{action "someAction" "someArgument"}}<br/>&gt;</span><span id="2ef2" class="nf mf in mc b gy nk nh l ni nj">// Octane<br/>&lt;button<br/>  type="button"<br/>  {{on "click" this.someAction }}<br/>&gt;</span><span id="27a6" class="nf mf in mc b gy nk nh l ni nj">&lt;button<br/>  type="button"<br/>  {{on "click" (fn this.someAction "someArgument"}}<br/>&gt;</span></pre><h1 id="56c6" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">结论</h1><p id="8cdf" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">最近和Ember.js一起工作真的很愉快。我希望它继续提高和增强开发人员的生产力和幸福感。</p><p id="1527" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些重要的东西将会很棒:</p><ul class=""><li id="eba5" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">测试文件与源文件在同一位置</li><li id="e672" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated">能够使用自定义目录布局</li><li id="aedd" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated">能够在不创建ember应用程序的情况下，在CodePen、JSFiddle等中渲染Ember组件</li><li id="4b14" class="ll lm in ke b kf lu ki lv kl lw kp lx kt ly kx lq lr ls lt bi translated">能够通过标准节点模块共享和消费成员组件，而无需使用<code class="fe lz ma mb mc b">addon</code>格式。</li></ul><p id="bd85" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢所有Ember.js贡献者的辛勤工作，感谢他们让这成为一次令人愉快的开发体验。</p><p id="22e3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后但同样重要的是，我感谢<a class="ae ky" href="https://www.linkedin.com/in/chriskrycho/" rel="noopener ugc nofollow" target="_blank"> Chris Krycho </a>、<a class="ae ky" href="https://www.linkedin.com/in/gopalvenkatesan/" rel="noopener ugc nofollow" target="_blank"> Gopal Venkatesan </a>的宝贵见解和评论。🙏</p><p id="bdae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="no">更多内容请看</em><a class="ae ky" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="no">plain English . io</em></strong></a></p></div></div>    
</body>
</html>