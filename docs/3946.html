<html>
<head>
<title>An Introduction to Redis Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis流简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-introduction-to-redis-stream-57445a21751e?source=collection_archive---------2-----------------------#2021-08-07">https://javascript.plainenglish.io/an-introduction-to-redis-stream-57445a21751e?source=collection_archive---------2-----------------------#2021-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4400" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用Redis流有效地管理数据消耗和持久化数据？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4ca501bc1be7df4165a0b322bcbebcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eW-MCIv6NkzSVq-4.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://devopedia.org/redis-streams" rel="noopener ugc nofollow" target="_blank">Image Source</a></figcaption></figure><p id="1792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是内存中的数据结构存储，主要用作数据库、缓存和消息代理。Redis以其令人难以置信的速度和对不同类型数据结构的支持，如字符串、散列、列表、集合、位图、流等，在开发人员中非常流行。</p><p id="e46d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它有如此多的内置特性，如内置复制、Lua脚本、LRU驱逐、事务、磁盘持久性等，这使它非常出色。在本文中，我们将了解一个名为<strong class="ky ir">流</strong>的Redis数据结构。我们可以使用这种数据结构在我们的消费者或微服务中构建消息服务。</p><p id="d146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，我们可以把它作为一个消息代理，我们的微服务可以通过这个数据结构在它们之间进行通信。开始吧！</p><h1 id="b2b0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是Redis流？</h1><p id="d3dd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">简单地说，Redis streams是Redis的一种仅附加数据结构。它与列表等其他数据结构有一些相似之处，但它更有用，也更复杂。当我们在一个流变量上附加一些数据/消息时，它就可供消费者使用了。它有一个<strong class="ky ir">阻塞API </strong>，允许我们让消费者等待新消息的到来。它速度快，易于实现。它还提供<strong class="ky ir">消费者群体</strong>，允许向不同的消费者发送不同的消息子集。</p><h1 id="37cb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用例示例</h1><p id="78d4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">例如，假设我们有两个微服务— <strong class="ky ir"> MS-1 </strong>和<strong class="ky ir"> MS-2 </strong>。这些微服务想要在它们之间进行通信或者想要在它们之间交换一些数据。在这种情况下，消息服务就成了问题。Redis流位于<strong class="ky ir"> MS-1 </strong>和<strong class="ky ir"> MS-2 </strong>之间，充当<strong class="ky ir">代理</strong>。它通过Redis中的一些streams变量交换消息/数据<strong class="ky ir"> MS-1 </strong>到<strong class="ky ir"> MS-2 </strong>，反之亦然。为了更清楚，让我们说<strong class="ky ir"> MS-1 </strong>在一个流中附加一些数据。MS-2正在持续监听那个流。一旦<strong class="ky ir"> MS-1 </strong>在那个流中追加数据，<strong class="ky ir"> MS-2 </strong>就会得到它。</p><h1 id="323e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本操作</h1><p id="3653" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">流条目不仅仅是一个字符串，而是由一个或多个字段-值对组成。基本上，主要有两种类型的操作，向流中添加数据和从流中获取数据。</p><h1 id="d5dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加数据</h1><p id="45b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">基本的写命令是<strong class="ky ir"> XADD </strong>，它在指定的流中追加一个新的条目。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a58b" class="mu lt iq mq b gy mv mw l mx my">&gt; XADD profile-information * name alex age 27 hair black</span><span id="7f6c" class="mu lt iq mq b gy mz mw l mx my">Sample Output<br/>-------------------------------------------<br/>1627885225420-0</span></pre><p id="1a6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的命令将在关键字"<strong class="ky ir"> profile information "的流中添加一个新条目</strong>让我们一部分一部分地解释这个命令，以便更好地理解。</p><ul class=""><li id="3f78" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir"> XADD </strong>是告诉Redis在指定的键上添加一个新条目的命令。</li><li id="7137" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> profile-information </strong>是流的键名。</li><li id="fb80" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> * </strong>告诉Redis为每个条目创建一个单调递增的ID。我们也可以显式指定ID，但这种情况非常少见。服务器自动生成id几乎在所有情况下都是完美的。</li><li id="3603" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">命令的其余部分是组成我们的流条目的键值对。</li></ul><p id="37e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个有用的命令可以告诉我们流中的项数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="aa2b" class="mu lt iq mq b gy mv mw l mx my">&gt; XLEN profile-information</span><span id="8725" class="mu lt iq mq b gy mz mw l mx my">Sample Output<br/>-------------------------------------------<br/>(integer) 1</span></pre><ul class=""><li id="8940" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir"> profile-information </strong>是流的关键名称</li></ul><h1 id="766b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">获取数据</h1><p id="95ea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们能够通过<strong class="ky ir"> XADD </strong>命令在流中追加数据。现在是时候学习如何从流中读取条目了。获取数据的操作主要有三种类型。我们一个一个来讨论吧。</p><h2 id="fa93" class="mu lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">按范围查询:XRANGE &amp; XREVRANGE</h2><p id="6354" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在学习如何进行范围查询之前，我们需要对IDs有更多的了解。由<strong class="ky ir"> XADD </strong>命令返回的id看起来确实是这样的——1627796743670–0，格式为。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="04fe" class="mu lt iq mq b gy mv mw l mx my">&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;</span></pre><p id="208c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫秒部分是本地Redis节点中的本地时间，如果条目是在相同的毫秒内创建的，则序列号用于区分它们。Redis确保这些id以单调递增的顺序排列。IDs的第一部分基本上是一个时间戳，因此它也为我们提供了一个基于时间的范围查询。为了进行范围查询，我们需要分别指定两个id—<strong class="ky ir">start</strong>和<strong class="ky ir"> end，</strong>。请注意，查询的范围是<strong class="ky ir">包含</strong>，这意味着返回的范围将包括ID为<strong class="ky ir"> start </strong>或<strong class="ky ir"> end </strong>的元素。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e0f9" class="mu lt iq mq b gy mv mw l mx my">&gt; XRANGE profile-information - +</span><span id="d1c4" class="mu lt iq mq b gy mz mw l mx my">Sample Output<br/>-------------------------------------------<br/>1) 1) 1627885225420-0<br/>   2) 1) "name"<br/>      2) "alex"<br/>      3) "age"<br/>      4) "27"<br/>      5) "hair"<br/>      6) "black"</span></pre><ul class=""><li id="4b3d" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir"> XRANGE </strong>是基于范围的查询命令。</li><li id="0809" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> profile-information </strong>是流的键名。</li><li id="1a1d" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">两个特殊ID<strong class="ky ir">(—和+ ) </strong>分别表示指定流中可用的<strong class="ky ir">最小</strong>和<strong class="ky ir">最大</strong> ID。</li><li id="a472" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">我们还可以指定任何有效的id来代替——和<strong class="ky ir"> + </strong>来表示范围的起点和终点。</li></ul><p id="e02b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间范围查询</p><p id="7485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于基于时间的查询，我们可以省略序列部分，只放置开始时间和结束时间的时间戳。当我们省略序列部分时，开始序列自动设置为0，结束序列将是可用的最大序列号。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7f70" class="mu lt iq mq b gy mv mw l mx my">&gt; XRANGE profile-information 1627796743670 1627799297560</span></pre><p id="080d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在查询的最后指定一个选项<strong class="ky ir"> COUNT </strong>。它将从一个范围中获取前N项。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="276a" class="mu lt iq mq b gy mv mw l mx my">&gt; XRANGE profile-information - + COUNT 2</span></pre><p id="2664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XREVRANGE 的工作方式与<strong class="ky ir"> XRANGE </strong>完全一样，只是顺序相反。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1bc0" class="mu lt iq mq b gy mv mw l mx my">&gt; XREVRANGE profile-information + - COUNT 2</span></pre><p id="2f34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将以范围的逆序返回N个元素。</p><h2 id="9f0b" class="mu lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">使用XREAD获取新项目</h2><p id="2faf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以<strong class="ky ir">订阅</strong>到达信息流的新项目。这个概念看起来类似于<strong class="ky ir"> Pub/Sub，</strong>但是有显著的区别。主要的相似之处是，一个流可以有多个消费者，默认情况下，一个新的项目将被交付给每个等待消息的消费者。这非常类似于<strong class="ky ir">扇出</strong>技术，如<strong class="ky ir">发布/订阅</strong>。主要区别在于，虽然发布/订阅的工作方式类似于<strong class="ky ir"> fire和forgot </strong>意味着在扇出消息后，它将从Redis中删除，但流的工作方式完全不同。流用它们的id保存消息。除了流，<strong class="ky ir">消费者群体</strong>提供了发布/订阅或阻止列表无法实现的控制级别。</p><p id="14de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">xdread</strong>是监听到达流的新消息的命令。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a0a3" class="mu lt iq mq b gy mv mw l mx my">&gt; XREAD COUNT 1 STREAMS profile-information 0</span></pre><ul class=""><li id="e607" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir">计数</strong>是限制输出条目的可选命令。COUNT之后的值表示我们想从一个流中读取多少个条目。</li><li id="6daf" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> STREAMS </strong>是强制的，带有以下流的键名。</li><li id="0652" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">最后一个值0是ID。该ID表示最大ID已经存储在流配置文件信息中，并且该命令将仅返回其ID大于该ID的那些条目。这里，0表示我们希望消息从流的开头开始，ID大于0–0。</li></ul><p id="3a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以很容易地把<strong class="ky ir"> XREAD </strong>变成阻塞命令。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="eb7b" class="mu lt iq mq b gy mv mw l mx my">&gt; XREAD BLOCK 0 STREAMS profile-information $</span></pre><ul class=""><li id="1278" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir">阻塞</strong>选项，超时值为0表示该命令将检查是否可以立即处理请求。如果它能够处理请求，它就会这样做。否则，它将阻塞请求，直到数据到达。超时0毫秒意味着该请求永远不会超时。</li><li id="6eb7" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> $ </strong>是一个特殊的ID，表示已经存储在流中的最大ID，因此我们将只接收新消息。</li><li id="c2ae" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">我们还指定COUNT选项来限制输出条目。其实，<strong class="ky ir"> XREAD </strong>只有两个选项<strong class="ky ir">BLOCK</strong>&amp;<strong class="ky ir">COUNT</strong>。</li></ul><h2 id="a079" class="mu lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">消费者群体</h2><p id="4b0f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们处于一个有趣的部分。XREAD已经为我们提供了一种很好的扇出技术。但是我们可以考虑一种不同的情况，我们可以有多个消费者，我们希望在他们之间分发我们的消息子集。简单地说，我们不想向不同的消费者传递相同的信息。例如，假设我们有两个消费者——<strong class="ky ir">C1</strong>、<strong class="ky ir"> C2 </strong>，我们有7条消息，它们的id分别是1、2、3、4、5、6、7。现在我们想在C1和C2之间分发这些信息，就像这样</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8d78" class="mu lt iq mq b gy mv mw l mx my">1 -&gt; <strong class="mq ir">C1</strong><br/>2 -&gt; <strong class="mq ir">C2</strong><br/>3 -&gt; <strong class="mq ir">C1</strong><br/>4 -&gt; <strong class="mq ir">C2</strong><br/>5 -&gt; <strong class="mq ir">C1</strong><br/>6 -&gt; <strong class="mq ir">C2</strong><br/>7 -&gt; <strong class="mq ir">C1</strong></span></pre><p id="5de7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到，我们没有向多个客户推送相同的消息。我们向不同的客户发送不同的信息。在这种情况下，消费者群体进入了这个画面。</p><p id="d72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建消费者群体</p><p id="8d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我已经有一个stream类型的键“<strong class="ky ir"> profile-information </strong>”，那么下面的命令将创建一个消费者组。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4fa5" class="mu lt iq mq b gy mv mw l mx my">&gt; XGROUP CREATE profile-information mygroup $</span></pre><ul class=""><li id="9e9b" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">您可能已经知道<strong class="ky ir"> $ </strong>是一个特殊的ID，表示流中最后一个可用的最大ID。消费者团体需要知道应该从哪里为其消费者跟踪消息。传递<strong class="ky ir"> $ </strong>将仅跟踪该组创建时间之后的新消息。如果我们传递0而不是$,那么这个组将从流的开始使用所有的消息。我们可以指定任何有效的id来指示组消费消息的起点。</li><li id="9c0a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir">我的组</strong>是组的名称。</li><li id="1ccf" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir">简档信息</strong>是现有的流密钥。</li><li id="e718" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">如果流不存在，XGROUP 也支持通过在最后一个<strong class="ky ir"> MKSTREAM </strong>处传递子命令来创建流</li></ul><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="43b3" class="mu lt iq mq b gy mv mw l mx my">&gt; XGROUP CREATE newstream mygroup $ MKSTREAM</span></pre><p id="acd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从群体中消费</p><p id="4962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis提供了一个命令名<strong class="ky ir"> XREADGROUP </strong>非常相似，提供了相同的<strong class="ky ir"> BLOCK </strong>选项；否则，就是同步的。有一个带有两个参数的强制选项组—消费者组的名称和试图读取的消费者的名称。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f660" class="mu lt iq mq b gy mv mw l mx my">&gt; XREADGROUP BLOCK 0 GROUP mygroup Alice COUNT 1 STREAMS profile-information &gt;</span></pre><ul class=""><li id="983b" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">这个命令非常具有描述性。它声明我想使用消费者组'<strong class="ky ir">my group '</strong>'从流'<strong class="ky ir">简档信息'</strong>中读取，我是消费者Alice。每个消费者必须指定一个名称，该消费者名称在组内唯一地标识该消费者。</li><li id="e90f" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> &gt; </strong>是另一个特殊的ID，只在消费者群体的上下文中有效，这意味着消息迄今为止从未被传递给其他消费者。</li></ul><h1 id="8862" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="fb16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这几乎是所有关于Redis流的基本东西。我从这篇发表在官方网站上的<a class="ae kv" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">文章</a>中获取了概念和信息。如果你阅读原文，你可能会了解更多。我已经缩小了主要文章的范围，并试图呈现Redis流的有用视图。我希望它能帮助你，如果有帮助，请把它分享给你的朋友。编码快乐！</p><p id="0716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nz">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>