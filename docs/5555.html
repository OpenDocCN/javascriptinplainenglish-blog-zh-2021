<html>
<head>
<title>How to Write an Infinite Scroll List with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React写一个无限滚动列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-an-infinite-scroll-list-with-react-6565c775aef6?source=collection_archive---------6-----------------------#2021-11-18">https://javascript.plainenglish.io/how-to-write-an-infinite-scroll-list-with-react-6565c775aef6?source=collection_archive---------6-----------------------#2021-11-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7118f5a0f6ee71debebe59dfd63ec4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUrq4yw1d6O0vgRfTQc7aQ.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@scottwebb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae ja" href="https://unsplash.com/s/photos/infinite?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="23d4" class="jb jc jd bd b dl je jf jg jh ji jj dk jk translated" aria-label="kicker paragraph">反应发展</h2><div class=""/><div class=""><h2 id="7604" class="pw-subtitle-paragraph kj jm jd bd b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dk translated">在这篇文章中，我想告诉你如何用React编写无限滚动。</h2></div><p id="b801" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">当您不知道页面大小时，无限滚动是合适的。您的项目在流中(例如，时间线)。而唯一的机会就是按顺序展示物品。实现无限滚动是可用性的最佳方式。我写了一个简单的模拟，当用户访问滚动的最后一项时加载新的项目。示例<a class="ae ja" href="https://onurdayibasi.dev/infinite-scroll/v1" rel="noopener ugc nofollow" target="_blank">迷你应用链接</a></p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lx"><img src="../Images/bdbe59779c6c15391736097a46a39d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8DW3yHmBReAfLBGntB-3Q.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk"><a class="ae ja" href="https://onurdayibasi.dev/infinite-scroll/v1" rel="noopener ugc nofollow" target="_blank">https://onurdayibasi.dev/infinite-scroll/v1</a></figcaption></figure><p id="da4b" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">首先，我们需要一个具有固定高度和溢出滚动能力的列表容器。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mc"><img src="../Images/5e35efbedd657c4c7113ac84e1d19d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7h9cHa_e_CRveMUnMH6bA.png"/></div></div></figure><p id="353b" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">第二部分是信息卡项目和加载…元素。加载元素仅在提取操作处于活动状态时可见。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi md"><img src="../Images/2d0f78f9b8d0696d1d6b3b0bda1c4ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsw3pa7d8qPBcVoupvC_0Q.png"/></div></div></figure><h1 id="28dc" class="me mf jd bd mg mh mi mj mk ml mm mn mo ks mp kt mq kv mr kw ms ky mt kz mu mv bi translated">滚动机制</h1><p id="0a5f" class="pw-post-body-paragraph lb lc jd ld b le mw kn lg lh mx kq lj lk my lm ln lo mz lq lr ls na lu lv lw ig bi translated">当组件安装到应用程序时，我们将滚动监听器添加到<strong class="ld jn"> <em class="nb">【无限滚动容器】</em> </strong>中，并在卸载元素时移除它。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/e5ffe0527159926e00cb3e0b0020e7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ygCHVv00BDEQ9f0z87FRQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Scrolling EventListener subscribe/unsubscribe</figcaption></figure><p id="613a" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这里必不可少的部分是“轨道滚动<strong class="ld jn"><em class="nb"/></strong>我们在轨道滚动中会做什么？</p><ul class=""><li id="16b4" class="nd ne jd ld b le lf lh li lk nf lo ng ls nh lw ni nj nk nl bi translated">检查您是否访问了滚动区的底部。</li><li id="fbef" class="nd ne jd ld b le nm lh nn lk no lo np ls nq lw ni nj nk nl bi translated">如果访问，则从后端获取新的数据块</li><li id="b869" class="nd ne jd ld b le nm lh nn lk no lo np ls nq lw ni nj nk nl bi translated">并生成新项目，将其呈现在列表容器中</li></ul><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/fecf3403f2335568d879d120b80ce420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CLOQLcgekjbViDrAdGemg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">track scrolling Algorithm Steps</figcaption></figure><h1 id="b0cc" class="me mf jd bd mg mh mi mj mk ml mm mn mo ks mp kt mq kv mr kw ms ky mt kz mu mv bi translated">检查滚动访问最后一个元素</h1><p id="fbb9" class="pw-post-body-paragraph lb lc jd ld b le mw kn lg lh mx kq lj lk my lm ln lo mz lq lr ls na lu lv lw ig bi translated">我们借助<strong class="ld jn"><em class="nb">document . getelementbyid .</em></strong>获取DOM元素，然后计算滚动访问底部。如果滚动访问到底部并且获取错误，那么我们开始获取操作。</p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="9bf0" class="nx mf jd nt b gy ny nz l oa ob">if (el.offsetHeight + el.scrollTop &gt;= el.scrollHeight) </span></pre><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oc"><img src="../Images/1ac9e4c8277cdd7e2d429455242c5732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvqM33qoVnFcHBnGiAa0_g.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">is Scroll Access To Bottom function</figcaption></figure><p id="28b1" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">然后我编写了一个简单的假获取函数，在等待0.6秒后生成新的项目</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi od"><img src="../Images/637aab0a3f7ce09678b267cd42b36c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7rNoqTDCmoABG0sGnjF-Q.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">fake fetching function</figcaption></figure><h1 id="22e7" class="me mf jd bd mg mh mi mj mk ml mm mn mo ks mp kt mq kv mr kw ms ky mt kz mu mv bi translated">让我们继续阅读😃</h1><p id="02e3" class="pw-post-body-paragraph lb lc jd ld b le mw kn lg lh mx kq lj lk my lm ln lo mz lq lr ls na lu lv lw ig bi translated">你可以在这个链接 找到类似的样本和著述<a class="ae ja" href="https://onurdayibasi.com/react-lab/?6565c775aef6" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jn">。如果你喜欢这个故事。请👏👏和分享。</strong></a></p><p id="fd41" class="pw-post-body-paragraph lb lc jd ld b le lf kn lg lh li kq lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><em class="nb">更多内容请看</em><a class="ae ja" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld jn"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>