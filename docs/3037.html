<html>
<head>
<title>Get Yourself a Sweet React NavBar 🍫</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给自己一个甜蜜的反应导航条🍫</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/get-yourself-a-sweet-react-navbar-853d5fb2de52?source=collection_archive---------7-----------------------#2021-06-20">https://javascript.plainenglish.io/get-yourself-a-sweet-react-navbar-853d5fb2de52?source=collection_archive---------7-----------------------#2021-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6dda14210178985900ac8f11a6fe8318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uDFXVlyPtHF-jELu.jpg"/></div></div></figure><p id="a162" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当创建网页时，我总是先在导航栏上工作。这是为了确保我可以处理任何潜在的路线，并从上到下设计页面。在这篇博客中，我将介绍一种简洁的方式，你可以用一点消失(和出现)的动作来设计一个更现代的导航条！</p><h2 id="439f" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">玻璃态射👓</h2><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/d096ad21f2a77d4a66e3aa4d0e1059ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/0*5S1q0dw_RiTjhdiG.gif"/></div></figure><p id="bb12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">准备好跃入未来的设计与一些玻璃形态的吸引力！</p><p id="f8b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现代设计的趋势是玻璃变形，或者换句话说，磨砂玻璃外观在许多领先的用户界面中很流行。为了达到这个效果，我们只需要一个CSS技巧— <code class="fe lr ls lt lu b">backdrop-filter</code>。</p><p id="4d91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码显示了我们需要使用的CSS属性和过滤器:</p><pre class="ln lo lp lq gt lv lu lw lx aw ly bi"><span id="7e2f" class="kt ku in lu b gy lz ma l mb mc">backdrop-filter: blur(20px)</span></pre><p id="33a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这么简单！我们使用模糊来创建磨砂玻璃外观，并调整像素来获得我们想要的模糊效果。</p><h2 id="4d80" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">现在你看见我了，现在你看不见了！✨</h2><p id="7d7a" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">如果你想让用户体验你的网站或网络应用程序，而没有任何导航条阻挡潜在的完整视图，那么这是你最好的解决方案之一！</p><p id="83f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们想要创建一个导航条，它在向下滚动时消失，在向上滚动时出现。我们通过使用一些普通的JavaScript和React钩子来实现这一点。</p><p id="36d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要导入<code class="fe lr ls lt lu b">useState</code>和<code class="fe lr ls lt lu b">useEffect</code>，并设置如下所示的状态:</p><pre class="ln lo lp lq gt lv lu lw lx aw ly bi"><span id="cdaf" class="kt ku in lu b gy lz ma l mb mc">import React, { useState, useEffect } from 'react';<br/>import '../../styling/navbar.css';</span><span id="e89a" class="kt ku in lu b gy mi ma l mb mc"><br/>const NavBar = () =&gt; {  <br/>  const [prevScrollPos, setPrevScrollPos] = useState(0);  <br/>  const [visible, setVisibile] = useState(0);</span><span id="414f" class="kt ku in lu b gy mi ma l mb mc">  return (<br/>    ...<br/>  )</span><span id="650a" class="kt ku in lu b gy mi ma l mb mc">}</span></pre><p id="5246" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们添加一些样式来创建一个navbar消失时的平滑过渡，并将其添加到主navbar div，如下所示:</p><pre class="ln lo lp lq gt lv lu lw lx aw ly bi"><span id="b71a" class="kt ku in lu b gy lz ma l mb mc">import React, { useState, useEffect } from 'react';<br/>import '../../styling/navbar.css';<br/></span><span id="b424" class="kt ku in lu b gy mi ma l mb mc">const NavBar = () =&gt; {  <br/>  const [prevScrollPos, setPrevScrollPos] = useState(0);  <br/>  const [visible, setVisibile] = useState(0);</span><span id="b124" class="kt ku in lu b gy mi ma l mb mc">  const navbarStyles = { transition: 'top 0.6s' }</span><span id="c21e" class="kt ku in lu b gy mi ma l mb mc">  return (<br/>    &lt;div className='nav-bar' style={{ ...navbarStyles, top: visible ? '0' : '-100px' }}&gt;<br/>    ...<br/>  )</span><span id="7dc2" class="kt ku in lu b gy mi ma l mb mc">}</span></pre><p id="d4ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据导航条的长度，您将在三元运算符中相应地调整falsy值。由于我创建的导航条是<code class="fe lr ls lt lu b">100px</code>，我已经将它设置为<code class="fe lr ls lt lu b">-100px</code>，以便在向下滚动时完全隐藏导航条。</p><h2 id="68ec" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">去抖⛹🏼</h2><p id="6e24" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">为了创建我们酷的导航条功能，我们将使用一个用普通js编写的助手方法。然后，我们将把它导入到我们的<code class="fe lr ls lt lu b">NavBar</code>组件中加以利用。下面是helper方法的代码:</p><pre class="ln lo lp lq gt lv lu lw lx aw ly bi"><span id="1994" class="kt ku in lu b gy lz ma l mb mc">export function debounce(func, wait, immediate) { <br/>  let timeout; <br/>  return function() {  <br/>    let context = this, args = arguments;  <br/>    let later = function() {   <br/>      timeout = null;   <br/>      if (!immediate) func.apply(context, args);  <br/>    };  <br/>    let callNow = immediate &amp;&amp; !timeout;  <br/>    clearTimeout(timeout);  <br/>    timeout = setTimeout(later, wait);  <br/>    if (callNow) func.apply(context, args); <br/>  };<br/>};</span></pre><h2 id="9da2" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">回过神来🏃🏽</h2><p id="030d" class="pw-post-body-paragraph jv jw in jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">现在，我们需要创建我们的<code class="fe lr ls lt lu b">handleScroll</code>函数，使用<code class="fe lr ls lt lu b">debounce</code>作为参数，使用<code class="fe lr ls lt lu b">useEffect</code>来管理出现和消失行为:</p><pre class="ln lo lp lq gt lv lu lw lx aw ly bi"><span id="6d26" class="kt ku in lu b gy lz ma l mb mc">import React, { useState, useEffect } from 'react';<br/>import { debounce } from '../../utilities/helpers;<br/>import '../../styling/navbar.css';<br/></span><span id="a4c3" class="kt ku in lu b gy mi ma l mb mc">const NavBar = () =&gt; {  <br/>  const [prevScrollPos, setPrevScrollPos] = useState(0);  <br/>  const [visible, setVisibile] = useState(0);</span><span id="f76e" class="kt ku in lu b gy mi ma l mb mc">  const navbarStyles = { transition: 'top 0.6s' }</span><span id="859c" class="kt ku in lu b gy mi ma l mb mc">  const handleScroll = debounce(() =&gt; {<br/>    const currentScrollPos = window.pageYOffset;<br/>    setVisibile((prevScrollPos &gt; currentScrollPos &amp;&amp; prevScrollPos - currentScrollPos &gt; 70) || currentScrollPos &lt; 10);<br/>    setPrevScrollPos(currentScrollPos);  <br/>  }, 100)</span><span id="f935" class="kt ku in lu b gy mi ma l mb mc">  useEffect(() =&gt; {    <br/>    window.addEventListener('scroll', handleScroll);    <br/>    return () =&gt; window.removeEventListener('scroll', handleScroll);<br/>  }, [prevScrollPos, visible, handleScroll]);</span><span id="b5e2" class="kt ku in lu b gy mi ma l mb mc">  return (<br/>    &lt;div className='nav-bar' style={{ ...navbarStyles, top: visible ? '0' : '-100px' }}&gt;<br/>    ...<br/>  )</span><span id="b778" class="kt ku in lu b gy mi ma l mb mc">}</span></pre><p id="c5ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的<code class="fe lr ls lt lu b">handleScroll</code>函数中，我们将我们的滚动位置与之前的滚动位置进行比较，并给出我们希望导航条何时出现和消失的指针。在我们的<code class="fe lr ls lt lu b">useEffect</code>函数中，我们根据在<code class="fe lr ls lt lu b">handleScroll</code>中表达的滚动方向，寻找任何滚动以及导航条是否可见。</p><p id="9bd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这个小博客能在设计你自己的导航条时有所帮助，并给你的网站和/或网络应用程序带来更多的味道！</p><p id="e44d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">更多内容尽在</em><a class="ae mk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mj">plain English . io</em></a></p></div></div>    
</body>
</html>