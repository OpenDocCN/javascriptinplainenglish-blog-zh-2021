<html>
<head>
<title>Let’s Build a MERN Stack E-Commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立一个MERN堆栈电子商务网络应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-8b0ef902d25e?source=collection_archive---------2-----------------------#2021-02-27">https://javascript.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-8b0ef902d25e?source=collection_archive---------2-----------------------#2021-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c3b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第7部分:完成项目</h2></div><p id="c5be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最后一部分，我们将通过构建所有的React组件并使用Stripe Checkout接受付款来结束我们的应用程序。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/7c7eedc2bb2e998fcb62708b434fe583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TgkKOnE8jSy4njIu"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@robertocortese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Cortese</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bb77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">朋友们好！这是MERN堆栈系列的最后一部分。在前四部分中，我们详细讨论了应用程序的后端部分——从设置路线到通过stripe接受支付；我们在这四个部分做了所有的后台工作。然后，在第五和第六部分中，我们处理了Redux动作、reducers和存储，并构建了身份验证组件。</p><ol class=""><li id="8358" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><a class="ae lr" href="https://js.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener ugc nofollow" target="_blank">第1部分—建立项目</a></li><li id="7516" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://js.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-2-designing-the-models-e231b2454aba" rel="noopener ugc nofollow" target="_blank">第二部分——设计模式</a></li><li id="3fd8" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-d619f3374d73" rel="noopener ugc nofollow" target="_blank">第3部分—认证和物品路线和控制器</a></li><li id="7911" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-accb4c14ce71" rel="noopener ugc nofollow" target="_blank">第4部分——购物车和订单路线及控制器</a></li><li id="4ee8" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" href="https://js.plainenglish.io/lets-build-a-mern-stack-e-commerce-web-app-444082ae81bd" rel="noopener ugc nofollow" target="_blank">第5部分—设置客户端和Redux </a></li><li id="89b9" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/lets-build-a-mern-stack-e-commerce-web-app-f26613a344e1">第6部分—冗余减速器和认证组件</a></li></ol><p id="d898" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最后一部分，我们将通过构建这个项目所需的React组件来完成这个项目。</p><p id="b82b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将逐个构建所有组件。我们将在上一篇文章中创建的components文件夹中构建所有这些组件。</p><h2 id="8c69" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">AppNavbar</h2><p id="96ff" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这是我们要构建的第一个组件。导航栏将包含登录模式，注册模式，注销按钮，以及链接到我们网站上的各个页面。</p><p id="bf00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里使用Reactstrap组件来构建我们的Navbar组件。你可以用最适合你的。</p><p id="372f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们从auth文件夹导入LoginModal、Logout和RegisterModal。我们还导入了PropTypes和connect函数。</p><p id="ecde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义一个状态来评估导航条是否打开。我们有一个开关来改变打开和关闭，反之亦然。</p><p id="cf5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从auth props获取用户和isAuthenticated状态。然后我们检查我们是否被认证；如果是，那么我们显示用户名，链接到主页，购物车和订单，还有一个注销按钮。另一方面，如果我们没有被认证，我们得到注册和登录模式。</p><p id="6b81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还显示一个Navbar品牌，当我们通过认证时，我们显示认证链接，当我们没有通过认证时，我们显示访客链接。</p><p id="2340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们定义mapStateToProps并在其中添加auth状态。然后，我们将它连接到AppNavbar类。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="eb1c" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">主页</h2><p id="1d1f" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这是我们应用程序的主页，在这里我们显示所有的商品，并给用户一个将商品添加到购物车的选项。</p><p id="dedc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们从actions文件夹中引入getItems和addToCart函数，我们将使用它们来获取商品并将商品添加到购物车中。</p><p id="5c61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在挂载时，我们使用getItems函数获取所有项目。我们还定义了一个onAddToCart函数，当我们在任何产品中单击AddToCart按钮时就会触发该函数。它接收userId和productId，并具有addToCart函数，将这些值作为参数发送给该函数，并将添加的项数保持为1。我们当然可以给用户选择项目数量的选项，但是为了简单起见，我们没有在这里实现它。</p><p id="5b55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用基于网格的布局来显示我们的所有项目，所有项目都显示为卡片。我们使用映射功能来映射项目，并在其卡片中显示每个项目的数据。我们还为每个产品提供了一个“添加到购物车”按钮。仅当用户通过身份验证时，才会显示“添加到购物车”按钮。</p><p id="817f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还定义了mapStateToProps，其中定义了items、user和isAuthenticated。最后，我们使用connect函数将动作和mapStateToProps与Home组件绑定在一起。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="3cda" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">AddItem</h2><p id="d1fb" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">该组件用于向商店添加商品。我们没有将此页面链接到导航栏，因为我们不希望用户向我们的商店添加新项目。</p><blockquote class="nh ni nj"><p id="e5df" class="kf kg ng kh b ki kj jr kk kl km ju kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">虽然我们必须创建一个单独的卖家门户，并设置不同的访问安全措施，但由于这是一个初学者教程，我们不会走那么远，只会构建这个组件并允许任何人访问，尽管我们不会将它添加到Navbar中(只能通过URL访问)。</p></blockquote><p id="96c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个带有标题、描述、类别和价格的状态，这些都与产品相关。</p><p id="1fc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个类似的onChange函数和onSubmit函数，就像在注册或登录组件中一样，但有不同的变量和不同的函数(addItem)。</p><p id="8936" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个包含所有这些字段的表单和一个将商品添加到购物车的按钮。我们在添加时显示一个警告，尽管我们可以有更好的方法来处理这个问题，比如在发生错误时显示一个错误，或者在成功添加时重定向。</p><p id="9152" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有一个mapStateToProps，以及一个将它与AddItem组件链接起来的connect函数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="3db8" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">检验</h2><p id="3689" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这是我们创建的助手功能，用于通过Stripe Checkout处理支付。我们首先从react-stripe-checkout导入StripeCheckout函数。</p><p id="b03f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们添加Stripe可发布密钥，然后创建两个函数——onToken仅使用用户和令牌id进行结帐，checkout函数从购物车组件接收金额、用户和结帐，稍后我们将对其进行定义。</p><blockquote class="nh ni nj"><p id="285e" class="kf kg ng kh b ki kj jr kk kl km ju kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">在这里，checkout是我们通过props从Cart组件接收的一个函数。这是我们用来结帐的动作。</p></blockquote><p id="a583" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用StripeCheckout，金额为最低货币值(<em class="ng">我们乘以100，因为我们使用的是印度卢比，最低值是1派斯，等于1印度卢比，就像1美元有100美分)，</em>令牌、货币和条带密钥。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="cb0f" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">手推车</h2><p id="4b56" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这是显示用户购物车的组件。它显示了用户购物车中的所有商品，给出了从购物车中删除这些商品的选项，并给出了结帐的选项(为商品付款并订购)。</p><blockquote class="nh ni nj"><p id="cdd8" class="kf kg ng kh b ki kj jr kk kl km ju kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">在这篇文章中，我们没有一个好的方法来处理结账和付款后发生的事情。理想情况下，我们应该重定向到订单页面，这可以通过历史和路由器来完成。我们让您来决定在支付失败或支付成功的情况下该怎么做。</p></blockquote><p id="442a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了两个函数— getCartItems和onDeleteFromcart，这两个函数都具有获取所有购物车商品和从购物车中删除商品的功能。</p><p id="d7b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当用户被加载后，我们才能从购物车中获取商品。否则，我们将获取一个错误。然后，我们通过映射显示购物车中的所有商品，并显示一个删除按钮来从购物车中删除该商品。</p><p id="bd0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显示完所有商品后，我们就有了一个显示账单和我们之前定义的结帐组件的卡片。</p><p id="2666" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义mapStateToProps，然后将它与这个组件连接起来。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="109f" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">命令</h2><p id="d026" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这是显示用户到目前为止已经下的所有订单的页面。我们使用actions文件中的函数getOrders来做同样的事情。</p><p id="cd58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们通过了身份验证并拥有了一个用户，我们就可以获得所有的用户订单，并使用地图功能将它们显示在一个基于卡片的视图中。</p><p id="77a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们定义mapStateToProps，然后将函数和mapStateToProps与Orders组件连接起来。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="b683" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">主要的</h2><p id="198e" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在这个组件中，我们使用React路由器为每个组件定义各种路由。这有助于我们拥有一个多路线布局，不同的组件有自己的路线。</p><p id="182d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用withRouter、Switch、Route和Redirect来完成所有这些路由。最后，我们用withRouter函数包装了主要组件。</p><p id="b4fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多关于React路由器的信息，<a class="ae lr" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank">请访问官方指南</a>。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e4f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些就是我们需要在组件文件夹中定义的所有组件。</p><p id="d339" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将更新我们的App.js文件，以反映所有这些更改，并将其与Redux store连接。</p><h2 id="efb9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">应用</h2><p id="3223" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">当组件挂载时，我们调度loadUser函数。然后，我们用store={store}值将所有JSX代码包装在提供程序中。这里，商店是从我们在第5个教程中定义的商店导入的。</p><p id="cf5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还使用BrowserRouter用className App包装div，因为我们在应用程序中使用了Routing。</p><p id="dd44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在div中有了Main函数。我们在代码的最后一行导出应用程序。</p><pre class="lc ld le lf gt nn no np bn nq nr bi"><span id="aac5" class="ns mh iq no b be nt nu l nv nw">import { Component } from 'react';<br/>import { Provider } from 'react-redux';<br/>import 'bootstrap/dist/css/bootstrap.min.css';<br/>import Main from './components/Main';<br/>import store from './store';<br/>import {loadUser} from './actions/authActions';<br/>import { BrowserRouter } from 'react-router-dom';<br/><br/>class App extends Component {<br/>  componentDidMount(){<br/>    store.dispatch(loadUser());<br/>  }<br/>  render(){<br/>    return ( <br/>      &lt;Provider store={store}&gt;<br/>        &lt;BrowserRouter&gt;<br/>          &lt;div className="App"&gt;<br/>            &lt;Main/&gt;<br/>          &lt;/div&gt; <br/>        &lt;/BrowserRouter&gt;<br/>        &lt;/Provider&gt; <br/>    );<br/>  }<br/>}<br/><br/>export default App;</span></pre><p id="5f14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个系列到此结束。希望你在这个系列中学到了一些新的有用的东西，并且喜欢这个完整的系列。</p><p id="a49d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢大家阅读该系列。更多此类文章系列阅读:</p><div class="nx ny gp gr nz oa"><a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">使用Django Rest框架构建博客网站——概述(第1部分)</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">让我们使用Django Rest框架构建一个简单的博客网站，了解DRF和REST APIs如何工作，以及我们如何添加…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ll oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://towardsdatascience.com/build-a-job-search-portal-with-django-overview-part-1-bec74d3b6f4e" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">用Django构建求职门户——概述(第1部分)</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">让我们使用Django建立一个工作搜索门户，允许招聘人员发布工作和接受候选人，同时…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ll oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://towardsdatascience.com/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">使用Django构建一个社交媒体网站——设置项目(第1部分)</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">在第一部分中，我们集中在设置我们的项目和安装所需的组件，并设置密码…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo ll oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/build-a-blog-app-with-react-intro-and-set-up-part-1-ddf5c674d25b"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">使用React构建博客应用程序—介绍和设置</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">第1部分:在第一部分中，我们处理项目的基础并设置它。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oj l"><div class="or l ol om on oj oo ll oa"/></div></div></a></div><p id="8517" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ng">在</em> <a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="ng">获取更多内容</em></strong></a></p></div></div>    
</body>
</html>