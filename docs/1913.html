<html>
<head>
<title>Reimplementing Recoil’s Core APIs for Fun and Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了娱乐和学习，重新实现反冲的核心API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reimplementing-the-core-recoils-apis-for-fun-and-learning-eb1402c1daf9?source=collection_archive---------13-----------------------#2021-04-21">https://javascript.plainenglish.io/reimplementing-the-core-recoils-apis-for-fun-and-learning-eb1402c1daf9?source=collection_archive---------13-----------------------#2021-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6c50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我总是渴望探索学习途径(你可以在我的<a class="ae ki" href="https://medium.com/@NoriSte/choose-what-not-to-study-and-focus-on-one-thing-at-a-time-b7304ac2a125" rel="noopener">选择不学习什么和一次专注于一件事</a>文章中读到更多)，但是我仍然缺少重新实现API。肯特·c·多兹(Kent C. Dodds)的一篇文章启发了我，于是我们就有了这篇文章。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/e6ee3e8801c095b3e9f204a350ccc66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgOE2e66_VNneijvMwcYTg.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@pluyar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Shane Aldendorff</a> on <a class="ae ki" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c7ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在工作中使用<a class="ae ki" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>；这是<a class="ae ki" href="https://www.workwave.com/route-manager/" rel="noopener ugc nofollow" target="_blank"> WorkWave RouteManager的</a>下一个架构的核心元素。反冲具有很好的易用性，它消除了本地和全局状态管理之间的所有区别。它还不完美，但相对稳定。</p><p id="239e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kz">请注意:</em> </strong> <em class="kz">这篇文章八个月未发表。我应该重写它，因为我意识到代码和设计决策通过视觉更容易理解，把代码留在最后。但是既然</em> <strong class="jm io"> <em class="kz">做得不如做得完美，</em> </strong> <em class="kz">我决定照原样发表这篇文章。作为对自己的一个提醒，我认为</em> <a class="ae ki" href="https://mattperry.is/writing-code/layout-projection-animate-browser-layout-60fps" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> Maty Perry的《布局投影:以60fps制作浏览器布局动画的方法》</em> </a> <em class="kz">是如何写一篇技术文章的绝佳范例。</em></p><h1 id="b529" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">要求</h1><p id="9ce7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">目标是重新实现<code class="fe md me mf mg b">atom</code>和<code class="fe md me mf mg b">selector</code>API，只是同步版本。这意味着</p><ul class=""><li id="530d" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">实现<code class="fe md me mf mg b">atom</code> API来创建新的原子</li><li id="3d86" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">实现<code class="fe md me mf mg b">selector</code> API来创建依赖原子和其他选择器的新选择器</li><li id="8482" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">实现<code class="fe md me mf mg b">useRecoilValue</code> API来获取一个原子/选择器值，并订阅(也称为重新呈现)它们的更新</li><li id="a4c7" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">实现<code class="fe md me mf mg b">useRecoilState</code> API以获得所有<code class="fe md me mf mg b">useRecoilValue</code>特性并设置原子/选择器</li><li id="ee84" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">实现<code class="fe md me mf mg b">RecoilRoot</code> API以避免在不同的组件树之间共享状态(我需要它只是为了测试)</li></ul><p id="8e6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在深入研究代码之前，我们需要的是:</p><ol class=""><li id="8251" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mv mn mo mp bi translated"><strong class="jm io">存储原子的值</strong>:原子本身只是普通的物体，反冲存储器必须保持它们当前的状态</li><li id="c5d1" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated"><strong class="jm io">更新订阅的组件</strong>当一个Atom更新时，强制它们重新渲染</li><li id="8f65" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated">通过React挂钩公开API</li><li id="d9ab" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated">用id区分每个商店，因为每个反冲根都是独立的</li><li id="4744" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated">保持一个反冲根的ID私有，我们不想暴露内部实现细节</li></ol><h2 id="1e4c" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">可能的解决方案:</h2><ul class=""><li id="789e" class="mh mi in jm b jn ly jr lz jv ni jz nj kd nk kh mm mn mo mp bi translated">存储值(#1)将是普通对象</li><li id="ed72" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">对于#2，我们需要为每个用户注册一个回调</li><li id="0fed" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">#3我们可以强制组件重新呈现的唯一方法是保持一个内部状态并更新它。其他州立图书馆是怎么做的？看看它的内部，反冲是通过<code class="fe md me mf mg b">useState</code>实现的:</li></ul><pre class="kk kl km kn gt nl mg nm nn aw no bi"><span id="b057" class="mw lb in mg b gy np nq l nr ns">const [_, setValue] = useState({});<br/>forceUpdate = () =&gt; setValue({});</span></pre><p id="eb7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而Redux在内部通过<code class="fe md me mf mg b">useReducer</code>完成</p><pre class="kk kl km kn gt nl mg nm nn aw no bi"><span id="e718" class="mw lb in mg b gy np nq l nr ns">const [, forceRender] = useReducer(s =&gt; s + 1, 0)</span></pre><ul class=""><li id="310f" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">如今，我认为第四点是理所当然的😉</li><li id="c052" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">#5要求我们使用React上下文，由反冲根组件拥有</li><li id="ed89" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">我们将用一些包装核心函数的高阶函数来管理# 6(稍后，我将解释如何做到这一点)</li></ul><h2 id="90cb" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">选择器呢？</h2><ol class=""><li id="41d7" class="mh mi in jm b jn ly jr lz jv ni jz nj kd nk kh mv mn mo mp bi translated">选择器是无状态的。它们的<code class="fe md me mf mg b">get</code>是从其他原子和选择器中获取值的纯函数</li><li id="d42a" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated"><strong class="jm io">当选择器依赖的原子/选择器之一更新时，选择器必须更新</strong></li><li id="945b" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mv mn mo mp bi translated">选择器也可以写其他原子和选择器的值</li></ol><p id="e13d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此:</p><ul class=""><li id="1fa1" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">对于#1，我们需要一些糖围绕原子的核心功能</li><li id="08da" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">#2迫使我们找出选择器依赖的原子和选择器，并订阅它们</li><li id="6962" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">#3利用现有的Atom setters，仅此而已</li></ul><p id="1f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要点:在项目的核心，<strong class="jm io">商店必须收集价值和订户</strong>；订户可以是使用所提供的挂钩或选择器的组件。</p><p id="b480" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以<a class="ae ki" href="https://codesandbox.io/s/recoil-apis-gl2cb?file=/README.md" rel="noopener ugc nofollow" target="_blank">在CodeSandbox </a>上玩这个项目，或者在GitHub 上把它分叉<a class="ae ki" href="https://github.com/NoriSte/recoil-apis-codesandbox" rel="noopener ugc nofollow" target="_blank">。下面，我将指导您通过上下文分解相关代码:核心/公共类型、核心/公共API和钩子。</a></p><h2 id="08c7" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">类型</h2><p id="43de" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated"><em class="kz">如果想跳过解释:直接进入</em><a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/recoil/typings.ts" rel="noopener ugc nofollow" target="_blank"><em class="kz">GitHub</em></a><em class="kz">上的typings.ts文件。</em></p><p id="24f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在后面描述公开的API/类型。让我们先集中讨论需要在内部存储哪些数据。我将区分内部函数和前缀为<code class="fe md me mf mg b">core</code>的公共函数。</p><h2 id="bd01" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">核心反冲值</h2><p id="e937" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">内部反冲值。每个原子都应该:</p><ul class=""><li id="7891" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">有识别键</li><li id="19b8" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">有默认值</li><li id="30cf" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">有当前值</li><li id="460e" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">有一个更新时要通知的订阅者列表</li></ul><p id="a970" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然每个选择器应该:</p><ul class=""><li id="b662" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">有识别键</li><li id="0b93" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">有一个更新时要通知的订阅者列表</li></ul><p id="2112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以<code class="fe md me mf mg b">CoreRecoilValue</code>的签名如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The CoreRecoilValue signature. <a class="ae ki" href="https://gist.github.com/NoriSte/00a1aed85faccb8c635cc0d42869ee80" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><p id="f334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意:</p><ul class=""><li id="a4a5" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">我们不需要在创建Atom时传递<code class="fe md me mf mg b">T</code>,因为TypeScript可以从默认值中推断出它</li><li id="de74" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">有多种方法来设计这种类型，但是我认为有区别的联合非常简洁明了</li></ul><h2 id="0348" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">反冲储备</h2><p id="df37" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">每个<code class="fe md me mf mg b">RecoilRoot</code>必须有一个专门的商店和一个唯一的id。一个<code class="fe md me mf mg b">RecoilStore</code>是一个<code class="fe md me mf mg b">Record</code>,通过它们的键识别反冲值，而<code class="fe md me mf mg b">RecoilStores</code>是一个记录，通过它们的反冲id存储每个<code class="fe md me mf mg b">RecoilStore</code>。更容易看到代码😊</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The RecoilStores signature. <a class="ae ki" href="https://gist.github.com/NoriSte/8c5366fef7209a936d7a7aa1969368f9" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><h2 id="6e8e" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">公共类型</h2><p id="c026" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">关于公共类型没什么好说的，因为我是在复制反冲的类型定义😊</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The public types brought directly from Recoil. <a class="ae ki" href="https://gist.github.com/NoriSte/85520178804b9a1392d8521f42f81f8d" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><p id="d853" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在GitHub上看一下<a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/recoil/typings.ts" rel="noopener ugc nofollow" target="_blank">完整的typings.ts文件。</a></p><h1 id="28fd" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">核心API</h1><p id="a043" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated"><em class="kz">如果想跳过解释:直接去GitHub </em>  <em class="kz">上的</em><a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/recoil/core.ts" rel="noopener ugc nofollow" target="_blank"><em class="kz">core . ts文件。</em></a></p><p id="772e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">内部API和实用程序的混合，最终用户不会知道它们。</p><h2 id="5785" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">吸气剂</h2><p id="6984" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">最容易的函数是getters。他们应该:</p><ul class=""><li id="a74a" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">从<code class="fe md me mf mg b">RecoilStore</code>中检索原子的当前值或调用<code class="fe md me mf mg b">selector.get</code>函数</li><li id="a9b0" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">公开一个泛型<code class="fe md me mf mg b">coreGetRecoilValue</code>,它使用上面提到的专用getters</li><li id="94d3" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">高阶函数(<code class="fe md me mf mg b">createPublicGetRecoilValue</code>)，允许在不知道反冲id的情况下利用<code class="fe md me mf mg b">coreGetRecoilValue</code></li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The getters implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/8ec8bf8e4487edaee0a1914f56c25070" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><p id="d670" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意:</p><ul class=""><li id="0a54" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">核心函数被标记为<code class="fe md me mf mg b">@private</code>是为了强调最终用户不能导入它们。</li><li id="2537" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated"><code class="fe md me mf mg b">registerRecoilValue</code>是主动反冲存储器(组件所在的存储器)和原子本身的第一个接触点</li></ul><p id="b767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您不熟悉高阶函数模式，这是一种预先配置您稍后需要调用的函数的方法。此外，所有的核心函数都需要知道反冲id，但是，与此同时，它们的公共对应函数需要隐藏id。</p><p id="2699" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个超级简洁(没有箭头函数)的要点来说明这个想法。看看<code class="fe md me mf mg b">logId</code>和<code class="fe md me mf mg b">logIdWithoutKnowingIt</code>函数，它们做同样的事情，但是后者不需要id。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">A super-simple example of higher-order-functions. <a class="ae ki" href="https://gist.github.com/NoriSte/5d9ca4abdbffb7bc194be159898a7314" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><h2 id="e1c9" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">安装员</h2><p id="dc75" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">基本器械包功能包括:</p><ul class=""><li id="d0fc" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">设置原子的新值</li><li id="b787" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">调用所有订户</li><li id="6c66" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">在选择器的情况下，调用它们的<code class="fe md me mf mg b">set</code>函数(如果已定义)</li><li id="14b0" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">暴露了通常的反冲无id功能</li></ul><p id="ae64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The setters implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/96647da462a42172c838bfdd7bcef31e" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><h2 id="d0f4" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">注册和订阅</h2><p id="6345" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">到目前为止，一切都是普通的JS，让我们进入React的领域:注册和订阅。</p><p id="a648" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注册必须是幂等的(调用一次或多次的效果必须是一样的)。为什么？因为我们必须在需要时注册反冲值(因为反冲Id存储在React上下文中，我们无法提前知道)，可能的选项有:</p><ul class=""><li id="bd00" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">在尝试注册反冲值之前，检查反冲值是否已经注册</li><li id="3ef9" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">调用<code class="fe md me mf mg b">registerRecoilValue</code>而不关心之前的注册，它会检查自己</li></ul><p id="c5c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我选择了后者，使得<code class="fe md me mf mg b">registerRecoilValue</code>幂等。</p><p id="9b2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe md me mf mg b">subscribeToRecoilValueUpdates</code>必须只返回退订者，这里是注册和订阅的代码:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Registration and subscription implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/c30f3ac1bf73fc46c78d60e6b0db712c" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><p id="773b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在GitHub 上看一下整个<a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/recoil/core.ts" rel="noopener ugc nofollow" target="_blank"> core.ts文件。</a></p><h1 id="5051" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">反应API</h1><p id="fb13" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated"><em class="kz">如果想跳过解释:直接去GitHub </em>  <em class="kz">上的api.ts文件。</em></p><h2 id="3d8f" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">useRecoilValue和useRecoilState</h2><p id="5fc3" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这里是基本的API。<code class="fe md me mf mg b">useRecoilValue</code>必须:</p><ul class=""><li id="bb77" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">从由反冲根组件创建的React上下文中检索当前反冲Id</li><li id="997f" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">记录反冲值</li><li id="4a01" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">为组件订阅每一次Atom/Selector更新(就像官方那样)</li><li id="30cc" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">获取当前的后坐力值(像官方的一样)</li></ul><p id="3e70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe md me mf mg b">useRecoilState</code>利用<code class="fe md me mf mg b">useRecoilValue</code>检索当前值，然后它必须</p><ul class=""><li id="c3e5" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">为原子提供一个设置器</li><li id="cfa9" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">为选择器提供一个setter，这意味着调用选择器'<code class="fe md me mf mg b">set</code>(如果定义了的话)，向它传递一个反冲值getter和一个setter</li></ul><p id="24b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们之前定义的高阶函数的第一次使用。请记住，我们需要让消费者访问一些隐藏反冲Id的核心功能(如设置原子)，这就是我们创建<code class="fe md me mf mg b">createPublicGetRecoilValue</code>和<code class="fe md me mf mg b">createPublicSetRecoilValue</code>的原因。</p><p id="65d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是代码</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">UseRecoilValue and useRecoilState implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/e914c58d37ab6b34c5b962c169392ca4" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><h2 id="453b" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">签署</h2><p id="81d2" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">最后缺少的一点是组件如何订阅反冲值更新以及如何取消订阅。这个必要的行为是免费的。棘手的部分是从选择器中获取依赖关系树，并订阅每个反冲值更新:<code class="fe md me mf mg b">createDependenciesSpy</code>会这样做。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The subscription implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/bd57eebfb13ac859702c04803c09cd7c" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><p id="a5a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在GitHub 上看看完整的<a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/recoil/api.ts" rel="noopener ugc nofollow" target="_blank"> api.ts文件。</a></p><h2 id="f741" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">反冲根</h2><p id="6e64" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">每个反冲树的父树。它的唯一任务是在消耗反冲值的孩子周围创建反冲上下文。代码很简单。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The RecoilRoot implementation. <a class="ae ki" href="https://gist.github.com/NoriSte/f1c2b23730a13380feec25bc2d5f533e" rel="noopener ugc nofollow" target="_blank">Check it out on Gist</a>.</figcaption></figure><h2 id="49cb" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">有用！</h2><p id="9bf9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们到了！你可以<a class="ae ki" href="https://codesandbox.io/s/recoil-apis-gl2cb?file=/README.md" rel="noopener ugc nofollow" target="_blank">在CodeSandbox </a>上玩这个项目，或者在GitHub 上将它分叉<a class="ae ki" href="https://github.com/NoriSte/recoil-apis-codesandbox" rel="noopener ugc nofollow" target="_blank">。</a><a class="ae ki" href="https://github.com/NoriSte/recoil-apis/blob/master/src/App.tsx" rel="noopener ugc nofollow" target="_blank"> App.tsx </a>代码强调上述内容:</p><ul class=""><li id="4855" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">注册一些原子和选择器，就像你注册反冲一样</li><li id="868e" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">注册依赖于原子和选择器的选择器</li><li id="6165" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">提供选择器组</li><li id="9641" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">记录组件的每一次重新渲染，因为在使用应用程序时，您可以用眼睛检查所有内容是否都按预期更新，但您无法检查组件被重新渲染了多少次，所以看一下控制台</li></ul><h2 id="cfc8" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">试验</h2><p id="51ae" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">为了这个项目的缘故，我不想只检查一切是否如预期的那样工作，但我想确保组件不会比预期的更多地重新渲染。在项目开发过程中，我经常需要这样做，所以我编写了一些测试来自动化我的手工检查。</p><h2 id="0c86" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">常见问题</h2><p id="1a70" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated"><em class="kz">上述代码中是否存在一些未经测试的场景？</em></p><p id="c11f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，我手动测试了一切正常</p><ul class=""><li id="61d9" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">元件会动态更改其订阅的反冲值</li><li id="c8a6" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">一个选择器设置另一个选择器</li></ul><p id="c5aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">为什么要用双引号和分号？</em></p><p id="6c57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不在乎定制默认的CodeSandbox的漂亮配置😉</p><p id="774f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有其他方法吗？</p><p id="9f1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，看看贝内特·哈德威克的《<a class="ae ki" href="https://bennetthardwick.com/blog/recoil-js-clone-from-scratch-in-100-lines/" rel="noopener ugc nofollow" target="_blank">重写脸书的《反冲</a>》一文《从零开始反应库100行》。他使用一种更基于班级的方法。请检查一下！</p><h1 id="989b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="abaf" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我喜欢重新实现反冲API，因为</p><ul class=""><li id="dedb" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">它迫使我看一看反冲内部</li><li id="5cd1" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">这让我接触到了不同的问题，因此我开始思考更广泛的解决方案</li><li id="4f5e" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">这让我开始创作一种新型的博客，在那里我试图解释一些设计决策，我以前的文章大多是关于问题和解决方案，讲述我的经历，或者试图启发人们</li></ul><p id="8dcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不喜欢那样做，因为</p><ul class=""><li id="51a1" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">我知道做兼职项目对我来说并不理想，我有时是个完美主义者😁</li></ul><h2 id="2a5c" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated"><strong class="ak">我的更多文章，你可能会喜欢:</strong></h2><ul class=""><li id="8fce" class="mh mi in jm b jn ly jr lz jv ni jz nj kd nk kh mm mn mo mp bi translated">我与赛普拉斯的旅程:<a class="ae ki" href="https://medium.com/@NoriSte/choose-what-not-to-study-and-focus-on-one-thing-at-a-time-b7304ac2a125" rel="noopener">选择不学什么，一次专注一件事</a></li><li id="acd2" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">为什么测试是讲述你的代码故事的完美方式:<a class="ae ki" href="https://medium.com/@NoriSte/software-tests-as-a-documentation-tool-e1c463bad1be" rel="noopener">作为文档工具的软件测试</a></li><li id="5bdf" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">从前端测试世界获得即时结果(和满意度)的更简单的方法:<a class="ae ki" href="https://medium.com/@NoriSte/new-to-front-end-testing-start-from-the-top-of-the-pyramid-a0039615353c" rel="noopener">刚接触前端测试？从金字塔的顶端开始！</a></li></ul><p id="7ed4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">别忘了看看我在GitHub上的<a class="ae ki" href="https://github.com/NoriSte/ui-testing-best-practices" rel="noopener ugc nofollow" target="_blank"> UI测试最佳实践</a>的书。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h2 id="c345" class="mw lb in bd lc mx my dn lg mz na dp lk jv nb nc lo jz nd ne ls kd nf ng lw nh bi translated">关于我</h2><p id="b7c4" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">你好👋我是斯特凡诺·马尼，我是一个充满激情的<strong class="jm io">前端工程师</strong>，一个<strong class="jm io">柏树大使</strong>，一个<strong class="jm io">导师</strong>。我是WorkWave 的高级前端工程师。</p><p id="b847" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢创造高质量的产品，测试和自动化一切，学习和分享我的知识，帮助别人，在会议上发言，面对新的挑战。</p><p id="b03a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae ki" href="https://twitter.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ki" href="https://github.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ki" href="https://www.linkedin.com/in/noriste/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。你可以找到我最近所有的投稿/演讲等。关于<a class="ae ki" href="https://github.com/NoriSte/all-my-contributions" rel="noopener ugc nofollow" target="_blank">我的GitHub总结</a>。</p><p id="78b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">更多内容请看</em><a class="ae ki" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>