<html>
<head>
<title>Randomness: LFSR and Cryptography in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机性:JavaScript中的LFSR和密码学</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/randomness-lfsr-and-cryptography-in-javascript-9a7bc89edbe4?source=collection_archive---------22-----------------------#2021-04-16">https://javascript.plainenglish.io/randomness-lfsr-and-cryptography-in-javascript-9a7bc89edbe4?source=collection_archive---------22-----------------------#2021-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4b1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在之前的中，我写过用JavaScript实现一个流密码。我忽略了生成用于加密纯文本的比特流的复杂问题。坐了一个星期，我觉得我需要探索随机性的领域，以完成关于流密码的思考周期。</p><p id="4d65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种易于实现的算法是线性反馈移位寄存器(LFSR ),因为它在硬件和软件方面都有简单的解决方案。虽然它们并非没有缺陷(例如<a class="ae ki" href="https://en.wikipedia.org/wiki/Correlation_attack" rel="noopener ugc nofollow" target="_blank">关联攻击</a>，但它们代表了进入该领域的坚实的第一步，并在许多生产系统中使用(例如<a class="ae ki" href="https://en.wikipedia.org/wiki/A5/1" rel="noopener ugc nofollow" target="_blank"> A5/1 </a>)。</p><p id="3e77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该算法具有以下特征:一个<em class="kj">初始状态</em>(不能为0)，该状态应该由<em class="kj"> n个</em>位(每个位在<em class="kj">寄存器</em>中有一个位置)表示，一个移动这些位的<em class="kj">移位</em>周期，一个产生随机its的<em class="kj">输出</em>路径，一个向空出的点返回新位的<em class="kj">反馈</em>路径(来自移位和输出)，以及一个</p><p id="8806" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由算法产生的随机序列的最大数量被定义为2^n-1，并被称为<em class="kj">周期</em>。三位LFSR最多可以产生7个唯一序列，而四位LFSR最多可以产生15个唯一序列。您应该注意术语最大值:不是所有的3位、4位或n位LFSR都会产生最大数量的唯一序列——这取决于您选择的“抽头”(稍后将详细介绍)。</p><p id="f46f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LFSR算法有两种类型:内部算法，在寄存器之间引入位突变；和外部，其引入突变作为反馈循环的一部分。本文的剩余部分将关注外部LFSR。让我们通过图表来研究这些概念:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/9cddfe6fe4251e01d95de41041946c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SXKwhN634yQhAR_X"/></div></div></figure><p id="1c66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本例中有三个寄存器，需要3位初始状态，因此n=3。周期是2 -1 = 7个最大唯一序列。移位发生时，从寄存器2和寄存器0中抽取值，两者的XOR运算成为反馈，寄存器0中的值成为输出位。“移位”是将寄存器1的值移入寄存器0，将寄存器2的值移入寄存器1，最后将新计算的反馈位放入寄存器2的过程。比特流最终会重复。</p><p id="58c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[1，0，1]的初始寄存器将输出比特流:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="ce23" class="lb lc in kx b gy ld le l lf lg">10111001011100101110010111001011100101110010111001011100</span></pre><p id="e496" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在它重复之前。如果您将其切割成8位整数，我们将得到输出[185，114，229，203，151，46，92]，序列在185处重复。以下是确认测试的情况:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="9ef0" class="lb lc in kx b gy ld le l lf lg">consr reference = ' matching: https:<em class="kj">//cs.stackexchange.com/questions/3337/lfsr-sequence-computation'</em></span><span id="b825" class="lb lc in kx b gy lh le l lf lg">it('3 Bit LFSR of ' + taps[3].polynomial + reference<em class="kj">, () =&gt; {</em></span><span id="0147" class="lb lc in kx b gy lh le l lf lg">    const ring = ExternalLfsrByteRing(8, [1,0,1])<br/>    ring.next(<em class="kj">/*10111001*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(185)<br/>    ring.next(<em class="kj">/*01110010*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(114)<br/>    ring.next(<em class="kj">/*11100101*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(229)<br/>    ring.next(<em class="kj">/*11001011*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(203)<br/>    ring.next(<em class="kj">/*10010111*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(151)<br/>    ring.next(<em class="kj">/*00101110*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(46)<br/>    ring.next(<em class="kj">/*01011100*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(92)<br/><br/>    <em class="kj">// here is the the sequence restarting...</em><br/>    ring.next(<em class="kj">/*10111001*/</em>).should.be.an('object').to.have.<br/>        a.property('value').equal(185)<br/>})</span></pre><p id="c6bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能会注意到，在测试中有一个语句<strong class="jm io"> ring.next()。value </strong>语法，它应该提示我实现:生成器。我选择了一个生成器，因为下一个状态是前一个状态/寄存器值的一个因子。实现的核心实际上是两个函数:生成器本身和移位函数。</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="f8d0" class="lb lc in kx b gy ld le l lf lg"><em class="kj">// shifter</em><br/><em class="kj">//  shifts the bits outputting the next bit out in the register <br/>//   THEN calculating a new bit and feeding</em><br/><em class="kj">//  it back to the other side of the register (the input and output <br/>//   sides are dependent on the input functions / direction)</em><br/><em class="kj">//</em><br/><em class="kj">// shifter :: ( ([x] -&gt; x -&gt; [x]), ([x] -&gt; {[x], x}), [Number] ) -&gt;  //                [Bit] -&gt; {newRegister: [x], output: x}</em><br/>const shifter = (append, remove,  taps) =&gt;<br/>    register =&gt; {<br/>        const feedbackBit = calculateNewBit(taps, register)<br/>        const appendedRegister = append(register, feedbackBit)<br/>        const { output, array } = remove(appendedRegister)<br/><br/>        return { newRegister: array, output: output }<br/>    }<br/><br/><br/>﻿const ExternalLfsrByteRing = <br/>  function *(byteLength, initialRegisterBitArray) {<br/>    const n = initialRegisterBitArray.length<br/><br/>    <em class="kj">// shift :: [Bit] -&gt; {newRegister: [x], output: x}</em><br/>    const shift = buildShifter(LEFT_TO_RIGHT, tapLookup[n])<br/><br/>    <em class="kj">// register is an array representing the current state of bits</em><br/>    let register = initialRegisterBitArray ;<br/><br/>    <em class="kj">// shiftRegister</em><br/>    <em class="kj">//  shifts the bits in the register (CAUTION: MUTATES register)<br/>    //<br/>    // shiftRegister :: unit -&gt; Bit</em><br/>    const shiftRegister = () =&gt; {<br/>        const {newRegister, output} = shift(register)<br/>        <em class="kj">// side-effect here</em><br/>        register = newRegister<br/>        return output<br/>    }<br/><br/>    <em class="kj">// return a byte whenever asked</em><br/>    while(true) {<br/>        yield getNextByte(shiftRegister)(byteLength)<br/>    }<br/>}</span></pre><p id="7a75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关注生成器函数(ExternalLfsrByteRing)，最重要的位(双关语)是<strong class="jm io"> while </strong>语句。每当用户请求下一个字节时，我们使用移位寄存器作为位源和指定的字节长度(8)来聚合足够的位(getNextByte)。移位寄存器是一个很容易理解的函数，它调用shift并更新寄存器的状态，然后输出移位后的结果位。</p><p id="b0ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">shift函数(通过Shifter从buildShifter返回)以从左到右和从右到左的方式运行(使与其他项目的比较/ ab测试更容易)。因此，append和remove具有特定于方向的实现，就像要tap的寄存器的索引一样。这些函数只是计算新的输入，并将其附加到寄存器中，然后删除被移位的位。</p><p id="26d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于寄存器位数的元数据有助于实现这一切，因此我按照这种思路构建了一个简单的散列表:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="f75c" class="lb lc in kx b gy ld le l lf lg">{<br/>    "2": {<br/>        n: 2,<br/>        maxSequence: 3,<br/>        polynomial: "p(x) = x^2 + x^1 + 1",<br/>        taps: [<br/>            2,<br/>            1<br/>        ]<br/>    },<br/>    "3": {<br/>        n: 3,<br/>        maxSequence: 7,<br/>        polynomial: "p(x) = x^3 + x^2 + 1",<br/>        taps: [<br/>            3,<br/>            2<br/>        ]<br/>    },<br/>    "4": {<br/>        n: 4,<br/>        maxSequence: 15,<br/>        polynomial: "p(x) = x^4 + x^3 + 1",<br/>        taps: [<br/>            4,<br/>            3<br/>        ]<br/>    },...<br/>}</span></pre><p id="5cc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多项式中的指数和抽头之间有一种关系，这应该很容易看出。抽头和抽头索引之间的关系取决于寄存器方向(如附加和移除)，但是，这相当简单:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="9844" class="lb lc in kx b gy ld le l lf lg">const getDirectionalFunctions = (direction, n) =&gt; {<br/>    const subtractOne = x =&gt; x - 1<br/>    const subtractFromN = x =&gt; n - x<br/><br/>    const append = <br/>       (direction == LEFT_TO_RIGHT) ? appendLeft  : appendRight ;<br/>    const remove = <br/>       (direction == LEFT_TO_RIGHT) ? removeRight  : removeLeft ;<br/>    const tapIndexMapper = <br/>       (direction == LEFT_TO_RIGHT) ? subtractOne : subtractFromN ;<br/><br/>    return {<br/>      append, remove, tapIndexMapper<br/>    }<br/>}</span></pre><p id="bae0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个字节环可以替代我在文章开始提到的流密码，成为更安全的对称流解决方案(注意:重点是<em class="kj">更</em>安全，这是<strong class="jm io">而不是</strong>安全的解决方案——目的是展示复杂性是如何发展的)。</p><p id="f161" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://github.com/tb01923/understanding-cryptography/blob/master/prng/external-lfsr-byte-ring.js" rel="noopener ugc nofollow" target="_blank">代码</a>和<a class="ae ki" href="https://github.com/tb01923/understanding-cryptography/blob/master/test/prng/external-lfsr-byte-ring.test.js" rel="noopener ugc nofollow" target="_blank">测试</a>可供您选择！</p><p id="23fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">喜欢代码？—打电话给我我一直在寻找与合作者、共谋者和创新者会面和合作的机会。</em></p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><div class="kl km kn ko gt lp"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">Todd Brown-Liberty Mutual创新和敏捷工程副总裁兼高级总监…</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">www.linkedin.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ku lp"/></div></div></a></div></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="f09a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">最初发表于</em><a class="ae ki" href="https://www.linkedin.com/pulse/randomness-lfsr-cryptography-javascript-todd-brown/" rel="noopener ugc nofollow" target="_blank"><em class="kj">【https://www.linkedin.com】</em></a><em class="kj">。</em></p><p id="9f5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kj">plain English . io</em></a></p></div></div>    
</body>
</html>