<html>
<head>
<title>How to Use Utility Types for Transforming TypeScript Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用实用工具类型来转换TypeScript类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-utility-types-for-transforming-typescript-types-d916bbb99362?source=collection_archive---------21-----------------------#2021-05-20">https://javascript.plainenglish.io/how-to-use-utility-types-for-transforming-typescript-types-d916bbb99362?source=collection_archive---------21-----------------------#2021-05-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/53de037d8861a2d05c626c952719b006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uoulCxFf8pQTcStE.jpg"/></div></div></figure><p id="f64f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript提供了一些内置的实用工具类型，有助于将类型从一种形式转换为另一种形式。</p><p id="80f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些实用程序全球通用。它们在各种情况下都很方便。</p><h1 id="80bb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">类型脚本泛型</h1><p id="7e35" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在理解TypeScript实用工具类型之前，理解类型别名和泛型非常重要。您可以为TypeScript中的任何现有类型创建类型别名。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b8f8" class="mf ku in mb b gy mg mh l mi mj">type MyString = string;</span><span id="a9c7" class="mf ku in mb b gy mk mh l mi mj">let helloWorldMessage: MyString = 'Hello Wisdom Geek';</span></pre><p id="47b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类型泛型用于创建可重用的类型别名。假设我们有一个身份函数，它返回传入的任何值:</p><p id="367e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类型泛型用于创建可重用的类型别名。假设我们有一个身份函数，它返回传入的任何值:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f072" class="mf ku in mb b gy mg mh l mi mj">const identity = (arg: string): string =&gt; arg;</span></pre><p id="2b52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想对一个数字使用这个函数呢？我们可以用任何类型替换特定类型。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3d5c" class="mf ku in mb b gy mg mh l mi mj">const identity = (arg: any): any =&gt; arg;</span></pre><p id="1eb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这减少了参数的类型信息，从而失去了使用TypeScript的全部好处。我们希望以一种可以用来表示返回类型的方式来捕获参数的类型。这就是泛型的用武之地。我们将使用一个作用于类型而不是值的类型变量。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5e5c" class="mf ku in mb b gy mg mh l mi mj">const identity = (arg: Type): Type =&gt; arg;</span></pre><p id="c929" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在调用函数时指定函数的类型:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fabf" class="mf ku in mb b gy mg mh l mi mj">const output = identity&lt;string&gt;("Hello Wisdom Geek");</span></pre><p id="a407" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们知道了这些基础知识，让我们深入研究TypeScript中内置的实用程序类型函数。</p><h1 id="b501" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">TypeScript中的内置实用工具类型</h1><p id="7eb4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在我们进入实用程序类型之前，有一点很重要，那就是从4.0版本开始，这些都是可用的，不需要任何额外的包。</p><h1 id="4294" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部分的</h1><p id="0891" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Partial构造一个类型，该类型的所有属性都是可选的。例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ab44" class="mf ku in mb b gy mg mh l mi mj">type BlogPost = {<br/>  title: string;<br/>  author: string;<br/>}</span><span id="fb17" class="mf ku in mb b gy mk mh l mi mj">type PartialBlogPost = Partial&lt;BlogPost&gt;;<br/>/* same as {<br/>  title?: string;<br/>  author?: string;<br/>} */</span></pre><p id="0c4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种情况的一个常见用例是在更新项目时，您可能希望提供已更改属性的子集，而不是所有属性。</p><h1 id="3d96" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">需要</h1><p id="f680" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是Partial的反义词。它使得输入类型的所有属性都是必需的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d2f0" class="mf ku in mb b gy mg mh l mi mj">type PartialBlogPost = {<br/>  title?: string;<br/>  author?: string;<br/>}</span><span id="fa7c" class="mf ku in mb b gy mk mh l mi mj">type BlogPost = Required&lt;PartialBlogPost&gt;;<br/>/* same as {<br/>  title: string;<br/>  author: string;<br/>} */</span></pre><p id="44fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种情况的一个用例是，部分代码需要所有成员都存在，但它们在其他地方可以是可选的。在需要它们的地方，您可以显式地使用所需的内置实用程序类型来确保这些值已经初始化，并且您不必在该代码块中处理空值检查。</p><h1 id="3bb4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">只读</h1><p id="5537" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这将构造一个输入类型的所有属性都设置为只读的类型。不能重新分配返回类型的属性。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d45e" class="mf ku in mb b gy mg mh l mi mj">type BlogPost = {<br/>  title: string;<br/>  author: string;<br/>}</span><span id="74bc" class="mf ku in mb b gy mk mh l mi mj">type BlogPost = Readonly&lt;PartialBlogPost&gt;;<br/>/* same as {<br/>  readonly title: string;<br/>  readonly author: string;<br/>} */</span></pre><p id="c174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个的用法有点明显，冻结一个对象并防止编辑。</p><h1 id="f7cb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">挑选</h1><p id="3e5c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是一种更高级的实用程序类型。它只允许从输入类型中选择指定的键。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f91d" class="mf ku in mb b gy mg mh l mi mj">type Point3D = {<br/>  x: number,<br/>  y: number,<br/>  z: number,<br/>};</span><span id="ab70" class="mf ku in mb b gy mk mh l mi mj">type Point2D = Pick&lt;Point3D, 'x' | 'y'&gt;;<br/>/* same as {<br/>  x: number,<br/>  y: number<br/>} */</span></pre><h1 id="12b3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">省略</h1><p id="23ff" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">省略了Pick反义词。它允许排除不需要的属性。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7261" class="mf ku in mb b gy mg mh l mi mj">type Point3D = {<br/>  x: number,<br/>  y: number,<br/>  z: number,<br/>};</span><span id="466e" class="mf ku in mb b gy mk mh l mi mj">type Point2D = Omit&lt;Point3D, 'z'&gt;;<br/>/* same as {<br/>  x: number,<br/>  y: number<br/>} */</span></pre><h1 id="7901" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">记录</h1><p id="7ef5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">给定一组由键和相应的属性值指定的属性，得到的类型是键-值对的记录。因此，记录<keys type="">将提供一种机制，通过将键中指定的所有单元类型映射到指定的类型作为其值的类型来创建接口。</keys></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0c3b" class="mf ku in mb b gy mg mh l mi mj">type BlogPost = Record&lt;'title'| 'author', string&gt;</span><span id="64c6" class="mf ku in mb b gy mk mh l mi mj">/* same as {<br/>  title: string;<br/>  author: string;<br/>} */</span></pre><p id="017e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果所有类型都有相同的值，那么声明的记录版本会更简洁，可读性更好，因为很明显它们都有相同的类型。</p><h1 id="e615" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">提取</h1><p id="be47" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这通过仅包括在两个给定类型中都存在的键来提取类型。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fd79" class="mf ku in mb b gy mg mh l mi mj">type T0 = Extract&lt;"a" | "b" | "c", "a" | "f"&gt;;<br/>     // type T0 = "a"<br/>type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  <br/>     // type T1 = () =&gt; void</span></pre><p id="93ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以认为是两种类型的交集。在您想要找到两种类型的公共基础的情况下，它会很有用。</p><h1 id="03c4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">排除</h1><p id="2693" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是提取的反义词。它不包括给定类型中重复的键。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="040b" class="mf ku in mb b gy mg mh l mi mj">type T0 = Exclude&lt;"a" | "b" | "c", "a"&gt;;<br/>     // type T0 = "b" | "c"</span><span id="1fb2" class="mf ku in mb b gy mk mh l mi mj">type T1 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;<br/>     // type T2 = string | number</span></pre><h1 id="4ae8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">不可空</h1><p id="d17a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是从类型值中排除null和undefined的简单方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cb9d" class="mf ku in mb b gy mg mh l mi mj">type T0 = NonNullable&lt;string | number | undefined&gt;;<br/>     // type T0 = string | number</span><span id="7bbd" class="mf ku in mb b gy mk mh l mi mj">type T1 = NonNullable&lt;string[] | null | undefined&gt;;<br/>     // type T1 = string[]</span></pre><h1 id="fb7a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="8fb3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这些是转换TypeScript类型最常用的实用工具类型。还有一些其他类型，如Parameters、ConstructorParameters、ReturnType和InstanceType，它们存在但不经常使用。如果你有兴趣，你可以在这里查看它们的用法。</p><p id="c065" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对这些类型的用法有任何疑问，请在下面留言。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="7bf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mt">原载于2021年5月20日https://www.wisdomgeek.com</em><em class="mt">的</em> <a class="ae ml" href="https://www.wisdomgeek.com/development/web-development/typescript/using-utility-types-for-transforming-typescript-types/" rel="noopener ugc nofollow" target="_blank"> <em class="mt">。</em></a></p><p id="4dbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mt">更多内容请看</em><a class="ae ml" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mt">plain English . io</em></a></p></div></div>    
</body>
</html>