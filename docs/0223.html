<html>
<head>
<title>React and MobX-state-tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和MobX状态树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-and-mobx-state-tree-aa7d569395c2?source=collection_archive---------5-----------------------#2021-01-13">https://javascript.plainenglish.io/react-and-mobx-state-tree-aa7d569395c2?source=collection_archive---------5-----------------------#2021-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d6e4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用这个Redux的优秀替代品构建一个简单的应用程序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dc9de7b5d2ed3b36ca47880ef2d056b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K75sFhA-UzLlDyFXQpkosg.png"/></div></div></figure><p id="e015" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在过去的6年里，React一直是我开发web界面的首选解决方案。它的概念很容易掌握，我也喜欢它允许我围绕它构建自己的堆栈，以构建我需要专门适应每个用例的前端接口。</p><p id="3d7a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，这种灵活性是有代价的——应用程序的每个方面都有太多的选择，不可能开始尝试所有的选择来找出最适合网站的技术。</p><h1 id="3dbf" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">React的状态管理解决方案</h1><p id="890f" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">如今，前端web应用程序的行为更像桌面应用程序，而不是老式的学校应用程序。状态保存在浏览器上运行的代码内的变量中。随着React和Angular框架支持的单页面应用程序的出现，全局状态管理变得越来越重要。此外，前端应用程序变得越来越大，久而久之和行业继续前进。拥有用户偏好、站点范围内的选择和一个反应式的用户界面变得必不可少。很少有什么比状态管理的选择对您的项目有更大的影响。</p><p id="9383" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在过去5年左右的时间里，Redux(2013年开发)已经成为考虑状态管理系统时事实上的标准。它改变了React应用程序的开发方式(尽管它与框架无关)。它允许将React应用程序扩展到以前无法管理的水平，因为它的状态管理和props在前端应用程序的不同位置的组件之间传递非常复杂。</p><p id="6823" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它的大规模采用已经变得如此广泛，以至于许多人不知道他们为什么要使用它，并且不良做法到处都是。以至于Redux的创建者正式发表了一篇博客文章，解释说<a class="ae mh" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener"> Redux不是万能药</a>，你可能最终并不需要它。</p><p id="6ea8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…而且我不得不承认:我不会说我很喜欢Redux。我仍然在许多项目中使用它——我喜欢它与React及其挂钩的集成方式。但是，还有其他选择，如:</p><ul class=""><li id="bdcc" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated"><a class="ae mh" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> Mobx </a>及其衍生产品<a class="ae mh" href="https://mobx-state-tree.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX-state-tree </a></li><li id="54ed" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a></li><li id="c3c5" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://hookstate.js.org/" rel="noopener ugc nofollow" target="_blank">秋田</a></li><li id="3a7e" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> Vanilla React上下文API </a></li></ul><p id="032a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我肯定我忘了一些东西。我也不会告诉你我已经全部用完了。但我广泛使用过Mobx和Mobx-state tree，让我惊讶的是，它们并没有比现在更受欢迎。</p><h2 id="1cd7" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">为什么是Mobx-state-tree？</h2><p id="258f" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">MobX-state-tree是一个基于MobX的自以为是的状态管理框架。实际上，这可能是所有备选方案中最固执己见的一个，不一定是坏的。</p><p id="543e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就个人而言，我使用mobx-state-tree主要是因为我想:</p><ul class=""><li id="cc68" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">知道处理状态的代码在哪里——这对我来说非常重要，这让我对Redux非常恼火，因为状态代码被分割在reducers、action creators等之中。有了MobX状态树(<strong class="kq io"> MST从现在开始</strong>)，你的代码简洁明了，在一个地方。</li><li id="05d1" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">代码是可预测的和清晰的。使用MST，您将永远不会考虑如何构建您的模型，或者如何构建您的模型来更新您的用户界面。MST使用自己的数据类型，迫使您创建数据结构树。</li><li id="8c51" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">它是强类型的。即使使用Javascript，模型保存的数据也要进行类型检查。Typescript集成也很容易。</li></ul><h2 id="1679" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">Mobx和Mobx状态树的区别</h2><ul class=""><li id="8512" class="mi mj in kq b kr mc ku md kx ni lb nj lf nk lj mn mo mp mq bi translated">MST很固执己见。它迫使你以一种特殊的方式构建你的模型，并使用库的概念来使用它们。这是我更喜欢MST而不是普通Mobx的一个原因，但我明白这是个人偏好。</li><li id="0622" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">即使使用普通的Javascript，MST也会对模型的属性进行类型检查，而普通的Mobx则不会。这可能会有一点性能损失(尽管我没有任何具体的数据来支持这一点，也没有看到任何类似的指标)</li><li id="62cc" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">MST的设计围绕着一个包含子模型的集中模型。您在组件中使用这些子模型。在某种程度上，这更像是Redux的集中式存储方式。Mobx没有任何这样的限制，您可以创建任意数量的存储，并在任意位置使用它们。</li></ul><h1 id="af6e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">一个简单的应用</h1><p id="61ae" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们构建一个简单的应用程序来完成这些事情:</p><ul class=""><li id="5afa" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">使用https://restcountries.eu/的<a class="ae mh" href="https://restcountries.eu/rest/v2/all" rel="noopener ugc nofollow" target="_blank">API来检索可用国家的列表，并显示它们。这将给出如何使用MST执行异步操作的想法。</a></li><li id="ba2a" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">每60秒刷新一次列表。这将允许我们检查如何使用可变变量。</li><li id="b6ab" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">该列表将通过按下按钮或设置时间间隔来手动刷新，这可以通过用户输入来无效。</li></ul><p id="5597" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了构造我们的简单应用程序，我们将使用Typescript。我们也不会投资任何时间来格式化/使我们的应用程序更漂亮。我们示例的唯一目的是展示MST在React应用程序中的用法。</p><p id="f86c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从设置存储的代码开始，该存储将保存所有的变量。</p><h2 id="4668" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">应用脚手架</h2><p id="df3b" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们将开始使用一个简单的Create React App脚手架应用程序，<a class="ae mh" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank">设置为使用typescript </a>，</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="ada7" class="mw ll in nm b gy nq nr l ns nt">npx create-react-app my-app --template typescript</span><span id="fbe4" class="mw ll in nm b gy nu nr l ns nt"># or</span><span id="9eb0" class="mw ll in nm b gy nu nr l ns nt">yarn create react-app my-app --template typescript</span></pre><p id="61b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们需要添加一些开发应用程序其余部分所需的组件:</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="5cae" class="mw ll in nm b gy nq nr l ns nt">npm install --save axios mobx-react-lite mobx mobx-state-tree<br/># or<br/>yarn add axios mobx-react-lite mobx mobx-state-tree</span></pre><h2 id="4fcc" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">设置商店</h2><p id="30b5" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">下面的模型将描述每个国家的项目。注意，RESTCountries提供的完整API中有更多的变量，但是为了清楚起见，我决定不包括它们。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="c4ba" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">interface Country </em>{<br/>  name: <em class="nv">string</em>;<br/>  alpha2Code: <em class="nv">string</em>;<br/>  alpha3Code: <em class="nv">string</em>;<br/>  callingCodes: <em class="nv">string</em>[];<br/>  capital: <em class="nv">string</em>;<br/>  region: <em class="nv">string</em>;<br/>  population: <em class="nv">number</em>;<br/>  area: <em class="nv">number</em>;<br/>  gini: <em class="nv">number</em>;<br/>  borders: <em class="nv">string</em>[];<br/><br/>  currencies: <em class="nv">Array</em>&lt;{<br/>    code: <em class="nv">string</em>;<br/>    name: <em class="nv">string</em>;<br/>    symbol: <em class="nv">string</em>;<br/>  }&gt;;<br/>}</span></pre><p id="15d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将创建两个MST商店，一个保存国家，另一个保存国家的商店(根商店)。一般来说，预计会将MST模型嵌入到其他模型中，并使用一个RootStore，这就是我们在这里要做的事情(尽管对于这样一个小练习来说可能有点不必要)。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="6457" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">const </em>CountryStore = types.model({<br/>  countries: types.array(types.frozen&lt;<em class="nv">Country</em>&gt;()),<br/>});<br/><br/><em class="nv">export const </em>RootStore = types.model({<br/>  countryStore: CountryStore,<br/>});</span></pre><p id="d5b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在这里使用<code class="fe nw nx ny nm b">types.frozen</code>,作为保存API响应的一种方式。<code class="fe nw nx ny nm b">frozen</code>意在保存一个<strong class="kq io">可串行化</strong>且<strong class="kq io">不可变</strong>的值。对于这个例子，我们将这样对待它——因为我们不会改变响应的任何部分，但是响应确实是一个由普通值组成的JSON对象(因此是可序列化的)。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="ef7d" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">export function initializeStore</em>() {<br/>  _store = RootStore.create({<br/>    countryStore: { countries: [] },<br/>  });<br/>  <em class="nv">return </em>_store;<br/>}</span></pre><p id="ff4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们打算将<code class="fe nw nx ny nm b">RootStore</code>从应用程序的根元素传递给应用程序的所有其他元素。为此，我们将使用React的<code class="fe nw nx ny nm b">Provider</code> API。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="7378" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">const </em>RootStoreContext = <em class="nv">createContext</em>&lt;<em class="nv">null </em>| <em class="nv">RootInstance</em>&gt;(<em class="nv">null</em>);<br/><em class="nv">export const </em>Provider = RootStoreContext.Provider;</span></pre><p id="de5d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们将能够通过<code class="fe nw nx ny nm b">useContext</code>将它注入任何我们想要使用的元素中。让我们编写一个方法来安全地检索它(检查存储是否已经正确初始化。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="bb63" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">export function useStore</em>(): <em class="nv">Instance</em>&lt;<em class="nv">typeof </em>RootStore&gt; {<br/>  <em class="nv">const </em>store = <em class="nv">useContext</em>(RootStoreContext);<br/>  <em class="nv">if </em>(store === <em class="nv">null</em>) {<br/>    <em class="nv">throw new </em>Error("Store cannot be null, please add a context provider");<br/>  }<br/>  <em class="nv">return </em>store;<br/>}</span></pre><p id="142a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nw nx ny nm b">store.ts</code>初始版本的完整代码如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="dd9a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在希望初始化存储，并将其注入到我们的应用程序中，以便以后从任何组件中检索它。</p><p id="8f74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的<code class="fe nw nx ny nm b">App.ts</code>里面:</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="3382" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">const </em>store = <em class="nv">initializeStore</em>();<br/><br/><em class="nv">function App</em>() {<br/>  <em class="nv">return </em>(<br/>    &lt;Provider <em class="nv">value</em>={store}&gt;<br/>      &lt;div <em class="nv">className</em>="App"&gt;<br/>        &lt;CountriesList /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Provider&gt;<br/>  );<br/>}<br/><br/><em class="nv">export default App</em>;</span></pre><p id="73b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意CountriesList在类中的用法。这是一个组件，它将显示国家/地区列表，并将咨询<code class="fe nw nx ny nm b">Store</code>来完成此操作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b723" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个需要使用商店属性向UI填充数据的组件都需要是一个<code class="fe nw nx ny nm b">observer</code>。为了使它成为一个观察器，我们需要从<code class="fe nw nx ny nm b">mobx-react-lite</code>导入观察器的高阶组件。现在，我们可以使用我们在store.ts文件中创建的<code class="fe nw nx ny nm b">useStore</code>方法来获取我们商店的实例。记住，存储是通过使用React的<code class="fe nw nx ny nm b">Provider</code> API传递给任何组件的。然后，我们可以正常地使用商店的属性，就好像它是任何其他可观察的对象一样。</p><p id="500f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可能想知道我们在组件内部使用的这个<code class="fe nw nx ny nm b">countryStore.refreshCountries()</code>是什么。这是一个检索数据的操作。稍后会有更多的介绍。</p><p id="44ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们运行应用程序，现在可以看到一个空白页面。这是正确的，我们尚未检索到任何数据。</p><h2 id="ea73" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">用数据填充我们的列表</h2><p id="bcaa" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们现在需要做的是用从提要中检索到的数据填充我们的CountriesStore。我们将使用Axios执行查询，并从<code class="fe nw nx ny nm b">restcountries.eu</code>网站检索数据。还记得我们之前谈到的这个<code class="fe nw nx ny nm b">countryStore.refreshCountries()</code>吗？是时候为它写一些代码了，这样我们就可以在我们的组件中使用它。</p><p id="9622" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将需要执行一个异步操作来检索数据并将它们存储在我们的<code class="fe nw nx ny nm b">CountriesStore</code>中。请记住，在MST中，不能从任何地方更改模型的属性。MST固执己见的本质迫使我们从一个<code class="fe nw nx ny nm b">actions</code>方法内部改变状态。<code class="fe nw nx ny nm b">actions’</code> argument是一个回调函数，它将一个参数传递给调用者(姑且称之为<code class="fe nw nx ny nm b">self</code>)，调用者实际上是一个具有商店的<strong class="kq io">可变</strong>属性的对象。所以我们可以在没有MST抱怨的情况下做<code class="fe nw nx ny nm b">self.countries=…</code>。</p><p id="04ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，当我们需要处理一个异步操作时，我们需要在编写我们的操作时格外注意。Mobx在文档中解释了原因。</p><div class="ob oc gp gr od oe"><a href="https://mobx-state-tree.js.org/concepts/async-actions" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd io gy z fp oj fr fs ok fu fw im bi translated">异步操作MobX状态树</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">egghead.io第12课:使用egghead.io上托管的流定义异步流程</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">mobx-state-tree.js.org</p></div></div><div class="on l"><div class="oo l op oq or on os km oe"/></div></div></a></div><p id="1c02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要点如下:如果您想对MST模型的属性进行修改，您有以下几种选择:</p><ul class=""><li id="b0cb" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">使用良好的旧承诺，并调用单独的操作来设置模型属性的新值。</li><li id="cc10" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">使用发电机模拟<code class="fe nw nx ny nm b">async-await</code>操作的使用。</li></ul><p id="569f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将选择后者，因为这将保持代码简洁。除非有特殊的技术原因要遵循方法1，否则我总是选择使用用<code class="fe nw nx ny nm b">flow</code> HOC包装的生成器函数</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="0554" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">export const </em>CountryStore = types<br/>  .model({<br/>    countries: types.array(types.frozen&lt;<em class="nv">Country</em>&gt;())<br/>  })<br/>  .actions((self) =&gt; {<br/>    <em class="nv">const </em>refreshCountries = <em class="nv">flow</em>(<em class="nv">function</em>* () {<br/>      console.log("refreshing countries...")<br/>      <em class="nv">const </em>response: <em class="nv">Country</em>[] = <em class="nv">yield </em>axios<br/>        .get("https://restcountries.eu/rest/v2/all")<br/>        .then((value) =&gt; value.data);<br/><br/>      self.countries = <em class="nv">cast</em>(response);<br/>    });<br/><br/>    <em class="nv">return </em>{ refreshCountries };<br/>  });</span></pre><p id="c46a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<code class="fe nw nx ny nm b">actions</code>内部的代码，注意<code class="fe nw nx ny nm b">refreshCountries</code>是一个用<code class="fe nw nx ny nm b">flow</code>高阶函数包装的生成器函数。另外，请注意<code class="fe nw nx ny nm b">yield</code>的行为类似于<code class="fe nw nx ny nm b">await</code>关键字并接受<code class="fe nw nx ny nm b">Promise</code>，有效地允许我们在模型的动作中执行任何异步操作。</p><p id="6a07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们在浏览器中点击“刷新”,我们应该会看到列表已被填充。我们的组件绘制了一个由REST API异步检索的简单而难看的国家名称列表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ot"><img src="../Images/1a36d785da9c525bea533785f7c33d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q2UrwaQVIAFdNAwv9Mfhw.png"/></div></div></figure><p id="09eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以停在这里。然而，我还想介绍MST的另一个方面，因为它对我来说是一个不小的发现。</p><h2 id="2b98" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">在商店中添加自动刷新</h2><p id="425f" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们在我们的小应用程序中添加一个特性和一个新部分，它将具有以下特性:</p><ul class=""><li id="f5e9" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">显示代表我们调用REST API刷新国家列表的次数的计数。</li><li id="fafc" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">Allow是设置和拆除一个计时器，它将每X秒自动刷新一次列表。</li></ul><p id="c81a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">存储我们需要的数据的方法并不像听起来那么简单。我们需要存储一个<code class="fe nw nx ny nm b">intervalId</code>，这样我们就可以使用<code class="fe nw nx ny nm b">setInterval</code>来设置或取消它。我们不会把它和我们的其他财产放在一起，因为这不是一个可观察的价值。这是一个不稳定的值。MST在文档中介绍了这个概念<a class="ae mh" href="https://mobx-state-tree.js.org/concepts/volatiles" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="771a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nw nx ny nm b">actions</code>可以被链接，这是添加一些控制自己状态的动作和一些我们不希望其他人访问的私有值的完美方式。</p><p id="8d16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们给<code class="fe nw nx ny nm b">CountryStore</code>添加一个新属性来测量我们的列表被刷新了多少次，以及自动刷新的计时器当前是否处于活动状态。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="69bd" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">export const </em>CountryStore = types<br/>  .model({<br/>    countries: types.array(types.frozen&lt;<em class="nv">Country</em>&gt;()),<br/>    <strong class="nm io">timesRefreshed: types.number</strong>,<br/>    <strong class="nm io">autoRefreshActive: types.boolean</strong>,<br/>  }</span></pre><p id="f202" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，让我们添加另一个<code class="fe nw nx ny nm b">actions</code>部分，将设置和拆除自动刷新。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9c13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<code class="fe nw nx ny nm b">timeIntervalId</code>的用法。它保存了Javascript计时器的时间间隔ID。我们选择让这个变量作为局部作用域存在于<code class="fe nw nx ny nm b">actions</code>部分，因为它是不可见的，我们希望它是私有的。在MST术语中，这也称为“局部变量”。</p><p id="c8fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还需要更新我们的<code class="fe nw nx ny nm b">refreshCountries</code>方法，以便在每次刷新时递增<code class="fe nw nx ny nm b">timesRefreshed</code>计数器。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="f178" class="mw ll in nm b gy nq nr l ns nt"><em class="nv">const </em>refreshCountries = <em class="nv">flow</em>(<em class="nv">function</em>* () {<br/>  <em class="nv">const </em>response: <em class="nv">Country</em>[] = <em class="nv">yield </em>axios<br/>    .get("https://restcountries.eu/rest/v2/all")<br/>    .then((value) =&gt; value.data);<br/>  self.countries = <em class="nv">cast</em>(response);<br/>  <strong class="nm io">self.timesRefreshed += 1;</strong><br/>});</span></pre><p id="3f4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，让我们添加一个名为<code class="fe nw nx ny nm b">ListRefreshControl</code>的新组件，它的职责是管理国家列表的刷新，并为此设置/拆除计时器。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="76ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，让我们更新我们的<code class="fe nw nx ny nm b">App</code>组件来适应这个新组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="a34c" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">让我们运行应用程序。</h2><p id="1559" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">是时候运行应用程序了。在你的浏览器中访问<code class="fe nw nx ny nm b">localhost:3000</code>，你会看到下图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ot"><img src="../Images/a036971398e959cfc4660e9dda4f155d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jm7yMtluJ82BKlJDbrJsuA.png"/></div></div></figure><p id="9ebe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">按下“手动更新”按钮将刷新国家列表，并增加页面顶部的“更新次数”计数器。如果您按下“设置自动刷新”按钮，它将被禁用，计时器将开始计时。该列表将每10秒自动更新一次。按下“拆除自动刷新”按钮将使计时器无效，自动刷新将停止。</p><h2 id="512d" class="mw ll in bd lm mx my dn lq mz na dp lu kx nb nc lw lb nd ne ly lf nf ng ma nh bi translated">完整商店. ts</h2><p id="18c7" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">为了方便起见，这里是store.ts文件的源代码，包含了<strong class="kq io">我们讲过的一切</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="534d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="fe45" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">MobX-state-tree是Redux的一个优秀的自以为是的替代方案，它提供了良好的类型脚本支持、Javascript的类型检查、简洁性以及与React的良好集成。我发现自己越来越频繁地使用它，它帮助我大大减少了代码库的大小，同时仍然拥有开发全功能应用程序所需的所有功能。</p><p id="306f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我个人认为它甚至比普通的mobx更有吸引力，mobx在构建代码库和存储变量方面的自由选择意味着没有普遍接受的方式来做所有这些事情。</p><p id="40ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我建议你自己尝试一下，看看它是否适合你的项目。</p><p id="ed19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">参考资料:</p><ul class=""><li id="183b" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated"><a class="ae mh" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> Mobx </a></li><li id="28f3" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://mobx-state-tree.js.org/" rel="noopener ugc nofollow" target="_blank"> Mobx状态树</a></li><li id="fd10" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">还原</a></li><li id="5e54" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">你可能不需要redux</li><li id="1a4d" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated"><a class="ae mh" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文API </a></li></ul></div></div>    
</body>
</html>