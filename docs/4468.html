<html>
<head>
<title>Is a React Passive Effect an Artificial Event?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应被动效果是人为事件吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/is-a-react-passive-effect-an-artificial-event-2535977b9a91?source=collection_archive---------8-----------------------#2021-09-06">https://javascript.plainenglish.io/is-a-react-passive-effect-an-artificial-event-2535977b9a91?source=collection_archive---------8-----------------------#2021-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c466c2949134e226dedf8c5b775a0784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7VOx-39QQvLBooG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florian Olivo</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5bfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React passive effect与<code class="fe ky kz la lb b">useEffect</code>一起使用，它调用一个新的JavaScript任务，而回调中实现的所有东西仍然可以以同步方式运行。</p><p id="ff80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React完成渲染并提交之后。它收集光纤下的被动效应。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="b402" class="lk ll in lb b gy lm ln l lo lp">function enqueuePassiveEffectMount(fiber, effect) {<br/>  passiveEffectsMount.push(effect)</span><span id="d4b2" class="lk ll in lb b gy lq ln l lo lp">if (!rootDoesHavePassiveEffects) {<br/>    rootDoesHavePassiveEffects = true<br/>    scheduleCallback(() =&gt; { flushPassiveEffects() })<br/>  }<br/>}</span></pre><p id="e3bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是它不会立即调用每一个，相反，它做事情的方式有点不同。</p><p id="e524" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，它使用一个标志<code class="fe ky kz la lb b">rootDoesHavePassiveEffects</code>等待所有的效果被收集。它确保每次提交最多可以进行一次刷新。</p><p id="960c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其次，它使用一个调度器来调度刷新，类似于<code class="fe ky kz la lb b">setTimeout</code>(比那更复杂)，刷新被推迟到一个新的JavaScript任务。这通常被称为异步调用。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/e2514a86ca89f67a8d98b91ecb800a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXi1MPG822DMzmc8idXcBQ.png"/></div></div></figure><p id="51cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们树立了一个榜样。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="65a0" class="lk ll in lb b gy lm ln l lo lp">const Title = () =&gt; {<br/>  useEffect(() =&gt; {<br/>    setState(1)<br/>  }<br/>}</span></pre><p id="26c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上图中，有三个任务，标题在任务1中呈现，而<code class="fe ky kz la lb b">setState</code>在任务3中被调用。任务2是非常短暂的。但至少我们在这里非常清楚地看到了这种异步的本质。</p><h2 id="72aa" class="lk ll in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">什么是JavaScript任务？</h2><p id="994f" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">任务是任何由标准机制安排运行的JavaScript代码。在左边的第一个任务中，我们完成了一次更新的<em class="mo">渲染</em>和<em class="mo">提交</em>。通常这就是我们需要知道的关于在React中运行<em class="mo"> JavaScript </em>代码的全部内容。</p><p id="04a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，由于<em class="mo"> JavaScript </em>是单线程引擎，在当前任务执行期间，可以有更多的工作添加到挂起队列中。一个典型的例子是<code class="fe ky kz la lb b">setTimeout</code>调用，它将回调添加到队列中，而不是在同一个任务中立即调用它们。API 调用(承诺)通常也属于这一类。这是这些回调被称为异步操作的主要原因。</p><p id="9146" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有规定每项任务需要多长时间。当一个任务完成时，它会在挂起队列中查找所有工作，然后逐个调用它们，在所有工作完成后，它会再次查看挂起队列。这个过程永远重复着。</p><h2 id="3caa" class="lk ll in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">调度是同步的还是异步的？</h2><p id="9529" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">现在问题来了，调度呼叫，比如<code class="fe ky kz la lb b">setState</code>是同步还是异步呼叫？这不是一个简单的答案，因为要回答这个问题，我们必须有一个好的参考时间点。</p><p id="8ec0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们确实知道，一个<code class="fe ky kz la lb b">useEffect</code>回调在一个新的JavaScript任务中被调用，假设这个任务叫做Task 1。如果我们在内部调用<code class="fe ky kz la lb b">setState</code>，它将是同步代码，包括整个渲染和提交。</p><p id="cfba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么为什么我们有时会调用<code class="fe ky kz la lb b">state</code>更新的异步直到新的渲染？</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="3029" class="lk ll in lb b gy lm ln l lo lp">  useEffect(() =&gt; {<br/>    setState(1)<br/>    // state value hasn't been changed yet<br/>  }, [])</span></pre><p id="9fc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那是因为就在<code class="fe ky kz la lb b">setState</code>之后，这个值还没有改变。只有在<em class="mo">渲染</em>时，它才会被设置为新版本，但是调用<code class="fe ky kz la lb b">setState</code>异步操作不够准确(如果没有错的话)，因为所有的异步操作都是在同一个<em class="mo"> JavaScript </em>任务中执行的。</p><blockquote class="mp mq mr"><p id="848f" class="ka kb mo kc b kd ke kf kg kh ki kj kk ms km kn ko mt kq kr ks mu ku kv kw kx ig bi translated">我们在讨论中使用的是React17阻塞代码，而不是并发的React18代码。</p></blockquote><h2 id="9461" class="lk ll in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">人为事件？</h2><p id="c187" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">这让我怀疑被动效应是否真的是一个人为事件。我听到React文档称它们为被动的“事件”，但并不真正知道“事件”来自哪里。</p><p id="1ee7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是从调用回调的方式来看，当回调被调用时，它的行为实际上类似于<code class="fe ky kz la lb b">onClick</code>事件处理程序。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="9211" class="lk ll in lb b gy lm ln l lo lp">  const onClick = () =&gt; {<br/>    setState(1)<br/>    // state value hasn't been changed yet<br/>  }</span></pre><p id="fff6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该事件通常在新的JavaScript任务中被调用，因为除了用户之外，没有人能控制它们何时发生。但是一旦它被处理，里面的代码就以同步的方式运行，包括前面解释的<code class="fe ky kz la lb b">setState</code>。</p><p id="09c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应会带来几个效果，突变，布局以及被动。突变和布局效果都是作为同步操作来实现的，而被动的效果在新的JavaScript任务中被调用。它们被设计用来处理任何副作用。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="6035" class="lk ll in lb b gy lm ln l lo lp">  useEffect(() =&gt; {<br/>    ...<br/>  }, [a, b])</span></pre><p id="beaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据其实现，它只在依赖关系数组中的任何元素发生变化时被调用。在前一种情况下，<code class="fe ky kz la lb b">a</code>或<code class="fe ky kz la lb b">b</code>。所以这个回调依赖于状态变化，而不是用户事件。当然，状态变化通常也是由用户事件引起的。</p><h2 id="eeaf" class="lk ll in bd ls lt lu dn lv lw lx dp ly kl lz ma mb kp mc md me kt mf mg mh mi bi translated">摘要</h2><p id="20bc" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">事件是一个动作，状态是一个比动作更被动的值。但是，两者都可以作为物理事件来调用其他同步代码。如何处理回调的过程在reactor中非常相似。</p><p id="2e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mo">多内容于</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mo">中</em></strong></a></p></div></div>    
</body>
</html>