<html>
<head>
<title>Demystifying “==” and “===” in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript中“==”和“===”的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-and-57e2d5194a66?source=collection_archive---------22-----------------------#2021-09-06">https://javascript.plainenglish.io/demystifying-and-57e2d5194a66?source=collection_archive---------22-----------------------#2021-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d94de22ce1da9226a1e4b495653bc5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyKcANDXKQ3G6UJ4OjvhzA.png"/></div></div></figure><p id="6213" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个JavaScript开发人员在职业生涯中最常遇到的一个面试问题就是:<em class="kt">“</em><code class="fe ku kv kw kx b"><em class="kt">==</em></code><em class="kt">和</em> <code class="fe ku kv kw kx b"><em class="kt">===</em></code> <em class="kt">有什么区别？”嗯，我想大多数读到这里的人可能已经得出了最常见的答案</em></p><blockquote class="ky kz la"><p id="443d" class="jv jw kt jx b jy jz ka kb kc kd ke kf lb kh ki kj lc kl km kn ld kp kq kr ks ig bi translated">“==”比较值，“===”比较值和类型。</p></blockquote><p id="d394" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我说这不是正确的答案呢🙈。让我们深入了解一下幕后发生的事情。根据ECMA脚本规范，<code class="fe ku kv kw kx b">==</code>和<code class="fe ku kv kw kx b">===</code>都会检查变量的类型。如果类型相同，<code class="fe ku kv kw kx b">==</code>和<code class="fe ku kv kw kx b">===</code>工作完全相同，它们根据值返回<code class="fe ku kv kw kx b">true</code>或<code class="fe ku kv kw kx b">false</code>。当变量的类型不匹配时，两者是不同的。😳</p><p id="7971" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当类型不同时，<code class="fe ku kv kw kx b">==</code>进行隐式强制，而<code class="fe ku kv kw kx b">===</code>直接返回<code class="fe ku kv kw kx b">false</code>。隐式强制无非是将变量从一种类型转换为另一种类型。</p><p id="f439" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据ECMAScript规范，每当JavaScript遇到一个<code class="fe ku kv kw kx b">==</code>操作符，就会调用一个名为<code class="fe ku kv kw kx b">IsLooselyEqual ( x, y )</code>的抽象操作。类似地，当它遇到一个<code class="fe ku kv kw kx b">===</code>操作符时，就会执行一个叫做<code class="fe ku kv kw kx b">IsStrictlyEqual ( x, y )</code>的抽象操作。我知道这可能太多了，一时难以消化，但是让我们在一些代码片段的帮助下试着理解这两个操作。我们不会涵盖操作的所有情况，而是会尝试处理一些我们通常会遇到的常见场景。</p><h1 id="ed4d" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">案例1:</h1><pre class="mc md me mf gt mg kx mh mi aw mj bi"><span id="f8d7" class="mk lf in kx b gy ml mm l mn mo">var stringOne = '1';<br/>var numberOne = 1;</span><span id="f02b" class="mk lf in kx b gy mp mm l mn mo">if (stringOne == numberOne) {<br/>  console.log("IsLooselyEqual(x,y) is invoked");<br/>}</span></pre><p id="ee77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们有两个变量——类型分别为<code class="fe ku kv kw kx b">string</code>和<code class="fe ku kv kw kx b">number</code>的<code class="fe ku kv kw kx b">stringOne</code>和<code class="fe ku kv kw kx b">numberOne</code>。之后我们有一个条件语句，在这里我们使用<code class="fe ku kv kw kx b">==</code>操作符检查<code class="fe ku kv kw kx b">stringOne</code>和<code class="fe ku kv kw kx b">numberOne</code>是否相等。一旦JavaScript遇到<code class="fe ku kv kw kx b">==</code>操作符，它就应用<code class="fe ku kv kw kx b">IsLooselyEqual(x,y)</code>抽象操作。根据该操作，完成以下步骤。</p><ol class=""><li id="8d2b" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">检查<code class="fe ku kv kw kx b">stringOne</code>和<code class="fe ku kv kw kx b">numberOne</code>的类型是否相同。如果相同，则通过应用<code class="fe ku kv kw kx b">IsStrictlyEqual(x, y)</code> <a class="ae mz" href="https://tc39.es/ecma262/#sec-islooselyequal" rel="noopener ugc nofollow" target="_blank">(实际算法的第二步)</a>抽象运算返回值，其中<code class="fe ku kv kw kx b">x</code>分别为<code class="fe ku kv kw kx b">stringOne</code>和<code class="fe ku kv kw kx b">y</code>为<code class="fe ku kv kw kx b">numberOne</code>。</li><li id="7710" class="mq mr in jx b jy na kc nb kg nc kk nd ko ne ks mv mw mx my bi translated">如果类型不相同，则检查<code class="fe ku kv kw kx b">stringOne</code>的类型是否为<code class="fe ku kv kw kx b">String</code>类型，以及<code class="fe ku kv kw kx b">numberOne</code>的类型是否为<code class="fe ku kv kw kx b">Number</code>类型<a class="ae mz" href="https://tc39.es/ecma262/#sec-islooselyequal" rel="noopener ugc nofollow" target="_blank">(实际算法的步骤6)</a>。因为它是真的，所以它通过应用<code class="fe ku kv kw kx b">ToNumber(x)</code>抽象操作将<code class="fe ku kv kw kx b">stringOne</code>变量转换为<code class="fe ku kv kw kx b">Number</code>类型。<code class="fe ku kv kw kx b">ToNumber(x)</code>是另一个将变量转换成<code class="fe ku kv kw kx b">Number Type</code>变量的抽象操作。在这种情况下，<code class="fe ku kv kw kx b">stringOne</code>将是<code class="fe ku kv kw kx b">x</code>，应用<code class="fe ku kv kw kx b">ToNumber(x)</code>操作将是<code class="fe ku kv kw kx b">ToNumber(stringOne)</code>，其中<code class="fe ku kv kw kx b">stringOne</code>将基于此的<a class="ae mz" href="https://tc39.es/ecma262/#sec-tonumber" rel="noopener ugc nofollow" target="_blank">从<code class="fe ku kv kw kx b">String</code>类型转换为<code class="fe ku kv kw kx b">Number</code>类型。之后，它通过再次应用<code class="fe ku kv kw kx b">IsLooselyEqual(x, y)</code>抽象运算返回值，此时<code class="fe ku kv kw kx b">x</code>和<code class="fe ku kv kw kx b">y</code>属于同一类型。</a></li><li id="10c1" class="mq mr in jx b jy na kc nb kg nc kk nd ko ne ks mv mw mx my bi translated">由于两者属于同一类型，它通过应用<code class="fe ku kv kw kx b">IsStrictlyEqual(x,y)</code>抽象运算返回值。</li><li id="3cf2" class="mq mr in jx b jy na kc nb kg nc kk nd ko ne ks mv mw mx my bi translated"><code class="fe ku kv kw kx b"><a class="ae mz" href="https://tc39.es/ecma262/#sec-isstrictlyequal" rel="noopener ugc nofollow" target="_blank">IsStrictlyEqual(x,y)</a></code>检查<code class="fe ku kv kw kx b">x</code>和<code class="fe ku kv kw kx b">y</code>的类型是否相同。如果类型相同，检查<code class="fe ku kv kw kx b">x</code>和<code class="fe ku kv kw kx b">y</code>的值。如果值也相同，那么操作将返回一个<code class="fe ku kv kw kx b">true</code>，否则将返回一个<code class="fe ku kv kw kx b">false</code>。</li></ol><h1 id="8fa9" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">案例二:</h1><pre class="mc md me mf gt mg kx mh mi aw mj bi"><span id="fb21" class="mk lf in kx b gy ml mm l mn mo">var arrayOne = ['1'];<br/>var numberOne = 1;</span><span id="8b04" class="mk lf in kx b gy mp mm l mn mo">if (arrayOne == numberOne) {<br/>  console.log("IsLooselyEqual(x,y) is invoked");<br/>}</span></pre><p id="4941" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们有两个类型分别为<code class="fe ku kv kw kx b">object</code>和<code class="fe ku kv kw kx b">number</code>的变量<code class="fe ku kv kw kx b">arrayOne</code>和<code class="fe ku kv kw kx b">numberOne</code>。之后我们有一个条件语句，在这里我们使用<code class="fe ku kv kw kx b">==</code>操作符检查<code class="fe ku kv kw kx b">arrayOne</code>和<code class="fe ku kv kw kx b">numberOne</code>是否相等。JavaScript一遇到<code class="fe ku kv kw kx b">==</code>操作符，就会应用<code class="fe ku kv kw kx b">IsLooselyEqual(x,y)</code>抽象操作。根据该操作，完成以下步骤。</p><ol class=""><li id="8844" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">检查<code class="fe ku kv kw kx b">arrayOne</code>和<code class="fe ku kv kw kx b">numberOne</code>的类型是否相同。如果相同，则应用<code class="fe ku kv kw kx b">IsStrictlyEqual(x, y)</code>抽象运算返回值，其中<code class="fe ku kv kw kx b">x</code>分别为<code class="fe ku kv kw kx b">arrayOne</code>和<code class="fe ku kv kw kx b">y</code>分别为<code class="fe ku kv kw kx b">numberOne</code>。</li><li id="e1a1" class="mq mr in jx b jy na kc nb kg nc kk nd ko ne ks mv mw mx my bi translated">如果类型不相同，则检查<code class="fe ku kv kw kx b">arrayOne</code>的类型是否为<code class="fe ku kv kw kx b">Object</code>类型，以及<code class="fe ku kv kw kx b">numberOne</code>的类型是否为<code class="fe ku kv kw kx b">String, Number etc</code>类型<a class="ae mz" href="https://tc39.es/ecma262/#sec-islooselyequal" rel="noopener ugc nofollow" target="_blank">(实际算法的步骤12)</a>。因为这是真的，所以它通过应用<code class="fe ku kv kw kx b">ToPrimitive()</code>抽象操作将<code class="fe ku kv kw kx b">Object</code>类型变量转换为<code class="fe ku kv kw kx b">Primitive</code>类型。简而言之，该操作试图将<code class="fe ku kv kw kx b">Object</code>类型转换为<code class="fe ku kv kw kx b">Primitive</code>类型，该类型可以是<code class="fe ku kv kw kx b">String</code>或<code class="fe ku kv kw kx b">Number</code>类型<a class="ae mz" href="https://tc39.es/ecma262/#sec-toprimitive" rel="noopener ugc nofollow" target="_blank">(top primitive)</a>。</li><li id="02c2" class="mq mr in jx b jy na kc nb kg nc kk nd ko ne ks mv mw mx my bi translated">然后通过传递<code class="fe ku kv kw kx b">x</code>和<code class="fe ku kv kw kx b">y</code>应用<code class="fe ku kv kw kx b">IsLooselyEqual(x, y)</code>操作返回值，并重复相同的步骤，直到<code class="fe ku kv kw kx b">x</code>和<code class="fe ku kv kw kx b">y</code>的类型相等或者当<code class="fe ku kv kw kx b">IsLooselyEqual(x, y)</code>操作返回<code class="fe ku kv kw kx b">false</code>时。</li></ol><h1 id="53df" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">案例三:</h1><pre class="mc md me mf gt mg kx mh mi aw mj bi"><span id="180d" class="mk lf in kx b gy ml mm l mn mo">var objectOne = [];<br/>var booleanOne = true;</span><span id="ceed" class="mk lf in kx b gy mp mm l mn mo">if(objectOne) {<br/>  console.log("This check whether array is empty or not won't work !!")<br/>}</span></pre><p id="abd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们有两个类型分别为<code class="fe ku kv kw kx b">object</code>和<code class="fe ku kv kw kx b">boolean</code>的变量<code class="fe ku kv kw kx b">objectOne</code>和<code class="fe ku kv kw kx b">booleanOne</code>。之后，我们有一个条件语句，在这里我们检查<code class="fe ku kv kw kx b">objectOne</code>是否是<code class="fe ku kv kw kx b">true</code>。JavaScript一遇到这种情况，就会应用一个新的抽象操作<code class="fe ku kv kw kx b">ToBoolean(x)</code>。该操作根据<a class="ae mz" href="https://tc39.es/ecma262/#sec-toboolean" rel="noopener ugc nofollow" target="_blank"> (ToBoolean) </a>中的参考表将变量转换为<code class="fe ku kv kw kx b">Boolean</code>类型。</p><p id="4286" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于这个表，因为我们的变量是类型<code class="fe ku kv kw kx b">Object</code>的，所以不管数组是否为空，它都会返回给我们<code class="fe ku kv kw kx b">true</code>。这是我们在比较<code class="fe ku kv kw kx b">Object</code>类型时需要其他参数的主要原因。在我们的例子中，因为我们清楚地知道它是一个数组对象，我们可以使用<code class="fe ku kv kw kx b">length</code>属性。现在我们可以用下面的方法重构上面的代码来检查是否为空。</p><p id="99fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我希望您已经理解了JavaScript如何处理<code class="fe ku kv kw kx b">==</code>和<code class="fe ku kv kw kx b">===</code>操作符以及它们实际上不同时的情况。上述情况只是许多情况中的几个。如果你真的有兴趣深入挖掘，我会推荐你浏览一下<a class="ae mz" href="https://tc39.es/ecma262/#sec-islooselyequal" rel="noopener ugc nofollow" target="_blank"> ECMA规范</a>，在那里你会找到<code class="fe ku kv kw kx b">IsLooselyEqual(x,y)</code>和<code class="fe ku kv kw kx b">IsStrictlyEqual(x,y)</code>抽象操作的完整实现。我也鼓励你读这本书，如果你还没有- <a class="ae mz" href="https://github.com/getify/You-Dont-Know-JS/tree/1st-ed" rel="noopener ugc nofollow" target="_blank">你不知道由<a class="ae mz" href="https://www.linkedin.com/in/getify/" rel="noopener ugc nofollow" target="_blank">凯尔·辛普森</a>写的JS </a>。</p><h1 id="1f61" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">谢谢你</h1><p id="e31a" class="pw-post-body-paragraph jv jw in jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">希望你喜欢这篇关于<code class="fe ku kv kw kx b">==</code>和<code class="fe ku kv kw kx b">===</code>操作符以及JavaScript中如何进行比较的文章。现在，你可以利用这些知识在即将到来的面试中真正解决上述问题😜。请在下面的评论区告诉我你的想法。如果你觉得这篇文章是有用的，请展示你的爱，并与你能最大限度利用这篇文章的伙伴们分享。</p><p id="55d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请随时通过Twitter、LinkedIn或电子邮件与我联系。乐意尽一切可能提供帮助。😊</p><p id="16a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直到我们再次见面，Mallu Dev结束👋干杯！🥂</p><p id="6bd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容尽在</em><a class="ae mz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>