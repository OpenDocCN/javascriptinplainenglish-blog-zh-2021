<html>
<head>
<title>A Beginner’s Guide To JavaScript Under The Hood — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">底层JavaScript初学者指南—第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-beginners-guide-to-javascript-under-the-hood-part-2-89d34a6a09e1?source=collection_archive---------5-----------------------#2021-02-14">https://javascript.plainenglish.io/a-beginners-guide-to-javascript-under-the-hood-part-2-89d34a6a09e1?source=collection_archive---------5-----------------------#2021-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="56b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始这篇文章之前，让我们回顾一下到目前为止我们所学到的一切。</p><p id="f71e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当JavaScript想要运行一段代码时，它会创建一个全局执行上下文，该上下文包含两个部分，即。</p><ol class=""><li id="4257" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">记忆创造阶段</li><li id="14b7" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">代码执行阶段</li></ol><p id="3262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，内存<em class="kw">(堆)</em>被分配给所有变量，并被赋予未定义的值<strong class="jm io">。</strong></p><p id="c9a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当内存阶段结束，代码开始执行时，所有的变量都被赋值，每当一个函数需要执行时，它就被压入堆栈，在执行完函数后，它就被弹出。</p><p id="8ab5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript是单线程的，每个进程只有一个栈和一个堆。因此，如果任何其他程序想要执行某个东西，它必须等到前一个程序完全执行完。该线程俗称<strong class="jm io">主线程</strong>或<strong class="jm io">主执行线程</strong>。</p><p id="2b89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果浏览器发送HTTP请求，通过网络在网页上加载一些图像或数据怎么办？会发生什么？浏览器会因为是单线程的而冻结吗？</p><p id="cba6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">浏览器带有JavaScript引擎，负责执行web应用程序中的任何JavaScript。但是你猜怎么着，浏览器有更多的功能。</p><p id="f885" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">浏览器也有我们在开发项目中使用的这些Web APIs，比如AJAX、console <em class="kw">(也是console)</em>等等。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/628ec79e1bac3d316031e4298535aff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZnTJxGdNibqHvSpQveKzw.png"/></div></div></figure><p id="a7db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一开始会觉得有点不知所措，但请和我在一起；理解起来毫不费力。</p><p id="e7a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript运行时实际上由另外两个组件组成，即<strong class="jm io">事件循环</strong>和<strong class="jm io">回调队列</strong>。回调队列也被称为<strong class="jm io">消息队列</strong>或<strong class="jm io">任务队列。</strong></p><p id="800f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到我们的问题<em class="kw">如果我们发送AJAX请求，浏览器会冻结吗？</em></p><p id="3167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果浏览器在收到HTTP网络响应时不得不使用相同的JavaScript线程来执行任务，我们的用户体验将会非常糟糕，我们的网页甚至会几分钟都没有响应。</p><p id="f045" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，浏览器实现它们自己的逻辑来执行这些Web APIs操作，例如发送HTTP请求，或者使用<em class="kw"> setTimeout </em>或<em class="kw"> setInterval </em>来延迟执行。这些操作不会阻塞主执行线程，因为它们被分配到由浏览器管理的不同线程上。</p><p id="8653" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些API也被称为Web APIs，因为它们不是JavaScript的一部分，本质上是异步的。这意味着您可以让这些API在后台做一些事情，并在完成后返回数据，而不会中断主执行线程。</p><p id="a9c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，每当我们调用这些API时，我们必须做的一件事就是为它们提供一个<strong class="jm io">回调函数</strong>。回调函数的职责是在Web API完成工作后，在主线程中执行一些JavaScript代码。</p><p id="1338" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们把它们放在一起。</p><p id="3e9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，无论何时调用函数，它都会被推入堆栈。如果该函数包含Web API调用，JavaScript将通过回调函数将其控制权委托给Web API，然后继续执行剩余的代码。</p><p id="7357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，函数可能会命中return语句，并从堆栈中弹出，然后继续执行剩余的代码。</p><p id="4165" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同时，主执行线程正在完成它的工作；同时，Web API在后台完成它的工作，并记住与该工作相关的回调函数。一旦工作完成，Web API将该工作的结果绑定到回调函数，并将其发送到<strong class="jm io">回调队列</strong> <em class="kw">(还记得我们之前介绍的2部分1。</em> <strong class="jm io"> <em class="kw">事件循环</em> </strong> <em class="kw">和2。c</em><strong class="jm io"><em class="kw">all back queue</em></strong><em class="kw">)。</em></p><p id="28ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">事件循环</strong>的工作是检查堆栈是否为空，如果为空并且任务仍在<strong class="jm io">回调队列</strong>中，那么它会将其推入堆栈。稍后，堆栈将执行回调函数。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="0104" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它类似于我们之前理解的程序，唯一的变化是我们使用<em class="kw"> setTimeout </em>在2000毫秒后首先调用我们的函数。</p><p id="4949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们深入了解引擎盖下会发生什么。首先，<strong class="jm io">功能第三个</strong>将被推入堆栈，然后<strong class="jm io">功能第二个</strong>。一旦function second开始执行并调用<em class="kw"> setTimeout </em> API，JavaScript将把回调函数传递给Web API并继续执行。</p><p id="0849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为没有什么要执行的，所以第二个函数将从堆栈中弹出，第三个函数也是如此。同时，Web API将等待2秒钟。一旦时间结束，它将把回调函数传递给回调队列，回调队列将触发<strong class="jm io">事件循环</strong>，由于堆栈为空，事件循环将把这个回调函数推入堆栈，执行将开始。</p><p id="e274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢菲利普·罗伯斯制作了这个神奇的工具来直观地展示引擎盖下到底发生了什么。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lm"><img src="../Images/cda0b1d388c044bee4e02ecbb864b2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NTaijPRPev89mrrybNlVOQ.gif"/></div></div></figure><p id="7c33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件循环和回调队列不是JavaScript引擎的一部分，而是位于JavaScript引擎之外，由web浏览器或Node.js等运行时提供。</p><p id="07e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的解释还解释了<em class="kw"> setTimeout </em>将执行所需的最小时间作为参数，可能会花费更多时间，但绝不会减少。</p><p id="e5bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果堆栈忙于执行函数，<em class="kw"> setTimeout的回调</em>可能必须等待堆栈变空，因此作为参数提供的时间是回调执行所需的最小时间。</p><p id="04b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kw">感谢您的阅读和任何反馈意见。</em></p></div></div>    
</body>
</html>