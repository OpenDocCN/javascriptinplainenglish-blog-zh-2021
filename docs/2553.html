<html>
<head>
<title>Migrating a 150K LOC codebase to Vite and ESBuild: How? (Part 2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将150K LOC代码库迁移到Vite和ESBuild？(第2/3部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/migrating-a-150k-loc-codebase-to-vite-and-esbuild-how-part-2-3-91b0b873f388?source=collection_archive---------0-----------------------#2021-05-26">https://javascript.plainenglish.io/migrating-a-150k-loc-codebase-to-vite-and-esbuild-how-part-2-3-91b0b873f388?source=collection_archive---------0-----------------------#2021-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5b3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将我们的代码库迁移到Vite背后的细致工作，有助于尽快失败或以最辉煌的方式成功。</p><p id="ebd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是关于将React+TypeScript代码库从Webpack迁移到Vite的三篇文章系列的一部分。<a class="ae ki" href="https://noriste.medium.com/migrating-a-150k-loc-codebase-to-vite-and-esbuild-why-part-1-3-4ccd9bea2a61" rel="noopener">第1部分</a>是关于我们为什么决定迁移，<a class="ae ki" href="https://noriste.medium.com/migrating-a-150k-loc-codebase-to-vite-and-esbuild-is-it-worthwhile-part-3-3-5a12894bac96" rel="noopener">第3部分</a>是关于事后的考虑。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/bcb10b44d9c861d20ffd53f0809f90b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1asz_EDOb6l3XN7Fux74BQ.png"/></div></div></figure><h1 id="3610" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">迁移代码库</h1><p id="6db3" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我可以用以下步骤来总结迁移:</p><ol class=""><li id="34ad" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><strong class="jm io">兼容性</strong>:包括研究Vite，使用它，以及在实际代码库之外模拟我们的场景。</li><li id="bcdf" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">可行性:我们的项目在Vite下工作吗？让我们以最快的方式迁移代码库。</li><li id="83f6" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">标杆</strong>:Vite值得吗？我们早期的假设正确吗？</li><li id="8421" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">再现性</strong>:重复迁移，而不弄乱代码库，减少所需的变更。</li><li id="7bc4" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">稳定性</strong>:确保ESLint、TypeScript和测试对Vite和Webpack的更新代码库感到满意。</li><li id="8d34" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">自动化</strong>:准备自动跳转到Vite所需的代码模块。</li><li id="9ca5" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">迁移</strong>:收获前面步骤的好处。</li><li id="942b" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">收集反馈</strong>:团队喜欢吗？一旦经常使用会有什么局限性？</li></ol><p id="cdba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的章节中，我将深化每一步。</p><h1 id="14dd" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.和睦相处</h1><p id="ec45" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">可能是最简单的一步。Vite的文档非常简洁明了，开始使用Vite不需要任何东西。我的目标是熟悉该工具，并检查Vite是否以及如何与我们项目的关键方面很好地配合，这些方面是:</p><ul class=""><li id="a3fd" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">具有自定义配置的类型脚本</li><li id="77b8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">打字稿别名</li><li id="60e1" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">导入/导出类型</li><li id="b2da" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">指定出口</li><li id="24a1" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">出口总额</li><li id="c635" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">具有内部状态的web workers</li><li id="5ee4" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated"><a class="ae ki" href="https://github.com/GoogleChromeLabs/comlink" rel="noopener ugc nofollow" target="_blank"> Comlink </a>(用于工人之间的交流)</li><li id="5db5" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">快速刷新反应</li><li id="dd80" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">构建项目</li><li id="d606" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">浏览器兼容性</li><li id="9b13" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">React 17的JSX变换兼容性</li></ul><p id="03c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快速和肮脏，只是通过<code class="fe mn mo mp mq b">npm init @vitejs/app</code>创建一个启动项目，试验它，用所有上述选项模拟一个场景，并玩它。</p><p id="fe19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">老实说，我以为会有更多的麻烦，但一切顺利。对Vite的第一个影响是非常积极的😊。</p><h1 id="c718" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.可行性</h1><p id="a562" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">这一步只有一个明确的目标:<strong class="jm io">无论如何，将Vite添加到我们的代码库</strong>。说真的，<strong class="jm io">不管我破不破TypeScript，ESLint </strong>，。env变量和测试，我只想知道是否有技术问题阻止我们将项目转移到Vite。</p><p id="6d2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个疯狂而盲目的过程背后的原因不是以最优雅的方式成功，而是尽快失败。用最少的工作量，我必须知道我们是否可以将我们的项目移到Vite。</p><p id="3ed5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">甚至在阅读了ESBuild的文档后，对我们影响最大的变化是</p><ul class=""><li id="574d" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">向TypeScript配置中添加另外三个设置(影响大量导入并阻止使用枚举)</li></ul><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="b541" class="mv kw in mq b gy mw mx l my mz">"isolatedModules": true,<br/>"esModuleInterop": true,<br/>"allowSyntheticDefaultImports": true</span></pre><p id="7e64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ESBuild需要前两个。你可以在它的文档中找到原因。请记住，ESBuild会删除类型批注，而不会对它们进行验证。不是强制性的，但允许我们保持代码库与Vite和Webpack兼容(稍后会详细介绍)</p><ul class=""><li id="142e" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">更新TypeScript的别名:不再有<code class="fe mn mo mp mq b">@foo</code>别名，只有<code class="fe mn mo mp mq b">/@foo</code>或<code class="fe mn mo mp mq b">@/foo</code>，否则<a class="ae ki" href="https://github.com/vitejs/vite/issues/279#issuecomment-636110354" rel="noopener ugc nofollow" target="_blank"> Vite在node_modules目录</a>中查找导入的别名。</li></ul><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="fb47" class="mv kw in mq b gy mw mx l my mz">resolve: {<br/>  alias: {<br/>    '@/defaultIntlV2Messages': '/locales/en/v2.json',<br/>    '@/defaultIntlV3Messages': '/locales/en/v3.json',<br/>    '@/components': '/src/components',<br/>    '@/intl': '/src/intl/index.ts',<br/>    '@/atoms': '/src/atoms/index.ts',<br/>    '@/routing': '/src/routing/index.ts',<br/>    // ...<br/>  },<br/>},</span></pre><ul class=""><li id="4267" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">Vite自动将JSONs转换成命名导出模块。考虑设置<a class="ae ki" href="https://vitejs.dev/config/#json-stringify" rel="noopener ugc nofollow" target="_blank"> Vite的JSON.stringify </a>以防万一。</li></ul><p id="5560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅此而已。之后，我继续以最快的方式修复错误，唯一的目标是让代码库在Vite下工作。</p><p id="d46f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最烦人的部分是新的TypeScript配置,因为它需要手动修改</p><ul class=""><li id="5ba5" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">重新导出我们之前没有迁移的类型(<code class="fe mn mo mp mq b">export <strong class="jm io">type</strong> { Props } from</code>而不是<code class="fe mn mo mp mq b">export { Props } from</code>)</li><li id="d5e6" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">ESBuild不支持枚举，用字符串联合替换它们(更新:<code class="fe mn mo mp mq b">const enums</code>不支持，感谢<a class="ae ki" href="https://dev.to/kubajastrz/comment/1f3ld" rel="noopener ugc nofollow" target="_blank"> Jakub注意到它</a>)</li></ul><p id="c39c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后</p><ul class=""><li id="843d" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated"><code class="fe mn mo mp mq b">import * as</code>代替<code class="fe mn mo mp mq b">import</code>用于某些依赖关系</li><li id="082b" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated"><code class="fe mn mo mp mq b">import</code>代替<code class="fe mn mo mp mq b">import * as</code>为静态资产</li></ul><p id="3b4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他问题来自于仅由网络工作者使用的<strong class="jm io">依赖关系，因为:</strong></p><ul class=""><li id="81fe" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">每当Web Worker导入一个依赖项时，Vite都会优化它并重新加载页面。幸运的是，Vite公开了一个<code class="fe mn mo mp mq b">optimizeDeps</code>配置来处理这种情况，避免了重载循环。</li></ul><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="0605" class="mv kw in mq b gy mw mx l my mz">optimizeDeps: {<br/>  include: [<br/>    'idb',<br/>    'immer',<br/>    'axios',<br/>    // …<br/>  ],<br/>},</span></pre><ul class=""><li id="6faa" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">如果Web Worker在导入依赖项时出错，您就没有有意义的提示。这对我来说是一个巨大的痛苦，但是一旦发现<a class="ae ki" href="https://github.com/vitejs/vite/issues/2219" rel="noopener ugc nofollow" target="_blank">，Evan很快就解决了。</a></li></ul><p id="8539" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，几个小时后，我们的项目在Vite上运行了🎉它不关心我引入的肮脏和临时的攻击的数量(大约40次无序提交)，因为我现在100%确定我们的项目完全兼容Vite。</p><h1 id="fb16" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.标杆管理</h1><p id="4095" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">尽快达到这一步还有另一个好处:我们可以衡量表现来决定是继续Vite还是退出。</p><p id="333c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对我们来说Vite比Webpack快吗？这些是我早期的经验测量。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7c3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使代码库增长了——我们正在将整个25万LOC项目迁移到一个全新的架构上——这些早期的测量证实了押注Vite是有意义的。</p><p id="b4ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意</strong>:我们想降低风险。Vite吸引我们，Vite更快，Vite更现代…但是我们还不是专家。因此<strong class="jm io">我们保持了Vite和Webpack的兼容性。如果出现问题，我们可以随时使用Webpack。</strong></p><h1 id="c250" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.再现性</h1><p id="919c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">可行性步骤的收获是代码库需要迁移到Vite的一系列改变。现在，我寻找自信:如果我从<code class="fe mn mo mp mq b">master</code>分支开始，重新做同样的改变，一切都必须再次工作。这个阶段允许创建一个包含大约十个独立的显式提交的完美分支。显式提交允许<strong class="jm io">将我能在</strong><code class="fe mn mo mp mq b"><strong class="jm io">master</strong></code><strong class="jm io"/>上做的任何事情直接移动到基于Webpack的标准代码库中，以简化最终的迁移步骤。我说的是:</p><ul class=""><li id="128c" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">添加<strong class="jm io"> Vite依赖项</strong>:通过将它们移动到<code class="fe mn mo mp mq b">master</code>，我可以在每周依赖项更新期间保持它们的更新(我们安装了<code class="fe mn mo mp mq b">vite</code>、<code class="fe mn mo mp mq b">@vitejs/plugin-react-refresh</code>和<code class="fe mn mo mp mq b">vite-plugin-html</code>)</li><li id="6dbc" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">添加<strong class="jm io"> Vite类型</strong></li><li id="d5f4" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">用前述设置(<code class="fe mn mo mp mq b">isolatedModules</code>、<code class="fe mn mo mp mq b">esModuleInterop</code>、<code class="fe mn mo mp mq b">allowSyntheticDefaultImports</code>)更新<strong class="jm io">类型脚本配置</strong>，并相应地修改代码库</li><li id="36af" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">将我们的<code class="fe mn mo mp mq b">static-assets</code>目录转换成Vite的<code class="fe mn mo mp mq b">public</code>目录</li></ul><p id="24e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦完成，启动和运行Vite的步骤就少了一个数量级。</p><h1 id="f658" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">5.稳定性</h1><p id="268f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">因为大部分需要的修改已经在<code class="fe mn mo mp mq b">master</code>上了，所以我可以专注于最精细的部分。这就是为什么现在是时候</p><ul class=""><li id="c281" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">修复TypeScript(记住，不包括在Vite中)错误</li><li id="fc76" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">修复ESLint错误</li><li id="4628" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">修复失败的测试(主要是由于失败的导入)</li><li id="fbc7" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">添加Vite的。环境文件</li><li id="f465" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">添加团队将用于启动Vite、使用Vite构建项目、预览构建以及清除Vite缓存的脚本(参考:如果您使用yarn工作区，Vite的缓存存储在本地node_modules中)</li><li id="213e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">创建HTML模板</li><li id="22b8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">检查所有Webpack配置是否都有Vite副本</li></ul><p id="fa1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Env变量和文件值得注意。我们的项目使用了一些基于<code class="fe mn mo mp mq b">process.env</code>的变量，通过Webpack的Define插件进行估价。Vite有相同的<code class="fe mn mo mp mq b">define</code>选项，并有电池包括<a class="ae ki" href="https://vitejs.dev/guide/env-and-mode.html#env-files" rel="noopener ugc nofollow" target="_blank">。环境文件</a>。</p><p id="b904" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我选择了:</p><ul class=""><li id="c136" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">对不依赖于本地/开发/生产环境的env变量使用<code class="fe mn mo mp mq b">define</code>。一个例子</li></ul><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="530f" class="mv kw in mq b gy mw mx l my mz">define: {<br/>  'process.env.uuiVersion': JSON.stringify(packageJson.version),<br/>},</span></pre><ul class=""><li id="4f89" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">支持其余的<code class="fe mn mo mp mq b">import.meta</code>(Vite存储环境变量的地方)。</li></ul><p id="5359" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据我们支持Webpack和Vite的决定，我们最终得到了下面的类型定义(一个例子)</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="ecb7" class="mv kw in mq b gy mw mx l my mz">declare namespace NodeJS {<br/>  export interface ProcessEnv {<br/>    DISABLE_SENTRY: boolean<br/>  }<br/>}<br/>interface ImportMeta {<br/>  env: {<br/>    VITE_DISABLE_SENTRY: boolean<br/>  }<br/>}</span></pre><p id="6245" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及这个消耗env变量的类似弗兰肯斯坦的函数</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="ae45" class="mv kw in mq b gy mw mx l my mz">export function getEnvVariables() {<br/>  switch (detectBundler()) {<br/>    case 'vite':<br/>      return {<br/>        // <a class="ae ki" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-ignore<br/>        DISABLE_SENTRY: import.meta.env.VITE_DISABLE_SENTRY,<br/>      }<br/>    case 'webpack':<br/>      return {<br/>        DISABLE_SENTRY: process.env.DISABLE_SENTRY,<br/>      }<br/>  }<br/>}</span><span id="eb04" class="mv kw in mq b gy nc mx l my mz">function detectBundler() {<br/>  try {<br/>    // <a class="ae ki" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error import.meta not allowed under webpack<br/>    !!import.meta.env.MODE<br/>    return 'vite'<br/>  } catch {}<br/>  return 'webpack'<br/>}</span></pre><p id="d5af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不会说我喜欢上面的代码，但它是暂时的，仅限于少数情况。我们可以忍受。</p><p id="43f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这同样适用于导入Web Worker脚本</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="584f" class="mv kw in mq b gy mw mx l my mz">export async function create() {<br/>  switch (detectBundler()) {<br/>    case 'vite':<br/>      return createViteWorker()<br/>    case 'webpack':<br/>      return createWebpackWorker()<br/>  }<br/>}</span><span id="7c39" class="mv kw in mq b gy nc mx l my mz">async function createViteWorker() {<br/>  // TODO: the dynamic import can be replaced by a simpler, static<br/>  // import ViteWorker from './store/store.web-worker.ts?worker'<br/>  // once the double Webpack+Vite compatibility has been removed<br/>  // <a class="ae ki" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-ignore<br/>  const module = await import('./store/store.web-worker.ts?worker')<br/>  const ViteWorker = module.default<br/>  // <a class="ae ki" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-ignore<br/>  return Comlink.wrap&lt;uui.domain.api.Store&gt;(ViteWorker())<br/>}</span><span id="8784" class="mv kw in mq b gy nc mx l my mz">async function createWebpackWorker() {<br/>  if (!process.env.serverDataWorker) {<br/>    throw new Error('Missing `process.env.serverDataWorker`')<br/>  }<br/>  //@ts-ignore<br/>  const worker = new Worker('store.web-worker.ts', {<br/>    name: 'server-data',<br/>  })<br/>  return Comlink.wrap&lt;uui.domain.api.Store&gt;(worker)<br/>}</span></pre><p id="03f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于脚本:这里没有什么特别的，package.json现在包括</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="9c44" class="mv kw in mq b gy mw mx l my mz">"ts:watch": "tsc -p ./tsconfig.json -w",</span><span id="3785" class="mv kw in mq b gy nc mx l my mz">// launches both Vite and TSC in parallel<br/>"vite:start": "concurrently - names \"VITE,TSC\" -c \"bgMagenta.bold,bgBlue.bold\" \"yarn vite:dev\" \"yarn ts:watch\"",</span><span id="01d0" class="mv kw in mq b gy nc mx l my mz">"vite:dev": "yarn vite",<br/>"vite:build": "yarn ts &amp;&amp; vite build",<br/>"vite:build:preview": "vite preview",<br/>"vite:clearcache": "rimraf ./node_modules/.vite"</span></pre><p id="ecdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是:我没能让Vite忽略Webpack的<code class="fe mn mo mp mq b">*.tpl.html</code>文件。我最终移除了<code class="fe mn mo mp mq b">html</code>扩展以避免Vite验证它们。</p><h1 id="0097" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">6.自动化</h1><p id="5fec" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">由于前面的步骤，我可以用一些精选代码和一些正则表达式来迁移整个代码库。<a class="ae ki" href="https://github.com/facebook/codemod#:~:text=Fork%20189-,Codemod%20is%20a%20tool%2Flibrary%20to%20assist%20you%20with%20large,and%20released%20as%20open%20source." rel="noopener ugc nofollow" target="_blank"> Codemod </a>非常适合创建迁移脚本并以极快的速度运行RegExps。</p><p id="a781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我创作了一个剧本</p><ul class=""><li id="16ef" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh mm me mf mg bi translated">删除node_modules目录</li><li id="77c4" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">通过Codemod更新TypeScript别名来转换代码</li><li id="a1d7" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">重新安装依赖项</li><li id="14e0" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh mm me mf mg bi translated">承诺一切</li></ul><p id="767e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意<strong class="jm io">脚本必须是等幂的</strong>——也就是说运行一次或多次会产生相同的结果——这在多次启动脚本并将其应用于<code class="fe mn mo mp mq b">master</code>分支和打开的PRs时至关重要。</p><p id="e4b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是脚本的一小部分</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="7b6c" class="mv kw in mq b gy mw mx l my mz"># replace aliases pointing to directories (idempotent codemod)</span><span id="e8d0" class="mv kw in mq b gy nc mx l my mz">codemod -m -d . - extensions ts,tsx - accept-all \<br/>"'@(resources|components|features|journal)/" \<br/>"'@/\1/"</span><span id="e403" class="mv kw in mq b gy nc mx l my mz"><br/># replace assets imports (idempotent codemod)</span><span id="936e" class="mv kw in mq b gy nc mx l my mz">codemod -m -d ./app - extensions ts,tsx - accept-all 'import \* as(.*).(svg|png|jpg|jpeg|json)' 'import\1.\2'</span><span id="6766" class="mv kw in mq b gy nc mx l my mz"><br/># update some imports (idempotent codemods)</span><span id="3248" class="mv kw in mq b gy nc mx l my mz">codemod -m -d . - extensions ts,tsx - accept-all 'import \* as tinycolor' 'import tinycolor'</span><span id="71f8" class="mv kw in mq b gy nc mx l my mz">codemod -m -d . - extensions ts,tsx - accept-all 'import \* as classnames' 'import classnames'</span><span id="d4c3" class="mv kw in mq b gy nc mx l my mz">codemod -m -d ./apps/route-manager - extensions ts,tsx - accept-all 'import PIXI' 'import * as PIXI'</span></pre><p id="10ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://gist.github.com/NoriSte/0a138442e9c5a09ba469061325d3ca0a" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到整个剧本。还是那句话:在最终迁移之前，您在<code class="fe mn mo mp mq b">master</code>上包含的更改越多，效果就越好。</p><h1 id="2de0" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">7.移民</h1><p id="0322" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我设计了这个脚本来简化所有开放分支的迁移，但是我们选择关闭所有PRs并只在<code class="fe mn mo mp mq b">master</code>上操作。</p><p id="7a29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于之前的许多尝试和对脚本的改进，迁移代码库只不过是挑选“特殊”提交并启动Codemods。</p><h1 id="c1fc" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">按下红色按钮</h1><p id="be7e" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">最后，花了30个小时玩Vite，修复和完善，得到了回报:几分钟后，代码库在Vite和Webpack下都工作了！🎉🎉🎉</p><p id="aa2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的<strong class="jm io"> vite.config.ts </strong>文件如下</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e45d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，这</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="4229" class="mv kw in mq b gy mw mx l my mz">esbuild: { jsxInject: `import * as React from 'react'` }</span></pre><p id="905b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有当你像我们一样已经<a class="ae ki" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" rel="noopener ugc nofollow" target="_blank">将你的代码库升级到新的React 17的JSX变换</a>时才有帮助。升级的要点是从JSX/TSX的文件中删除<code class="fe mn mo mp mq b">import * as React from 'react'</code>。ESBuild不支持新JSX变换，必须注入<a class="ae ki" href="https://github.com/evanw/esbuild/issues/334#issuecomment-760427837" rel="noopener ugc nofollow" target="_blank">React</a>。<a class="ae ki" href="https://vitejs.dev/guide/features.html#jsx" rel="noopener ugc nofollow" target="_blank"> Vite故意暴露</a>T3。或者，Alec Larson刚刚发布了<a class="ae ki" href="https://twitter.com/alecdotbiz/status/139655066421448295" rel="noopener ugc nofollow" target="_blank"> vite-react-jsx </a>，它的效果非常好。</p><p id="226d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是:目前，我还不能利用<a class="ae ki" href="https://github.com/aleclarson/vite-tsconfig-paths#readme" rel="noopener ugc nofollow" target="_blank"> vite-tsconfig-paths </a>来避免在vite的配置中硬编码TypeScript别名，因为在我们也支持Webpack之前，路径中“public”的存在会让Vite抱怨</p><pre class="kk kl km kn gt mr mq ms mt aw mu bi"><span id="5755" class="mv kw in mq b gy mw mx l my mz">// Webpack version:<br/>"@/defaultIntlV2Messages": ["./apps/route-manager/public/locales/en/v2.json"]</span><span id="d234" class="mv kw in mq b gy nc mx l my mz">// Vite version:<br/>'@/defaultIntlV2Messages': '/locales/en/v2.json'</span></pre><h2 id="12e5" class="mv kw in bd kx nd ne dn lb nf ng dp lf jv nh ni lj jz nj nk ln kd nl nm lr nn bi translated">柏树试验</h2><p id="d725" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">无关但有用:如果你的代码库中有基于Cypress的组件测试，你可以毫无问题地跳到Vite上，看看我的这篇推文<a class="ae ki" href="https://twitter.com/NoriSte/status/1383721527347056643" rel="noopener ugc nofollow" target="_blank">我解释了如何做。</a></p><h1 id="3a9d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">基准和结论</h1><p id="0c85" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">最终的基准测试证实了Vite的整体速度</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="19b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种比较是无情的，但公平吗？不算是。Vite的表现优于Webpack，但是，如前所述，我们在Webpack内部运行TypeScript和ESLint，而Vite不允许我们这样做。</p><p id="6862" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Webpack在较轻的配置下表现如何？我们能在没有Vite的情况下利用ESBuild的速度吗？哪一个能提供最好的开发者体验？我在<a class="ae ki" href="https://noriste.medium.com/migrating-a-150k-loc-codebase-to-vite-and-esbuild-is-it-worthwhile-part-3-3-5a12894bac96" rel="noopener">第三部分</a>中回答了这些问题。</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="4250" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨！我是斯特凡诺·马尼，我是一个充满激情的<strong class="jm io">前端工程师</strong>，一个<strong class="jm io">演讲者</strong>和一个<strong class="jm io">讲师</strong>。我作为高级前端工程师/团队领导为<a class="ae ki" href="https://www.workwave.com/" rel="noopener ugc nofollow" target="_blank">工作波</a>远程工作。</p><p id="9e34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢创造高质量的产品，测试和自动化一切，学习和分享我的知识，帮助别人，在会议上发言，面对新的挑战。</p><p id="9d66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在<a class="ae ki" href="https://twitter.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ki" href="https://github.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ki" href="https://www.linkedin.com/in/noriste/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。你可以找到我最近所有的投稿/演讲等。关于<a class="ae ki" href="https://github.com/NoriSte/all-my-contributions" rel="noopener ugc nofollow" target="_blank">我的GitHub总结</a>。</p><p id="20b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nv">更多内容请看</em><a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nv">plain English . io</em></a></p></div></div>    
</body>
</html>