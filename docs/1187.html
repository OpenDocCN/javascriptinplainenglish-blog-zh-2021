<html>
<head>
<title>Everything You Need To Know About Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于递归你需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-recursion-e790021a08bd?source=collection_archive---------16-----------------------#2021-03-12">https://javascript.plainenglish.io/everything-you-need-to-know-about-recursion-e790021a08bd?source=collection_archive---------16-----------------------#2021-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fd0bb435e0b2ae32c67dae76acb1fe13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00F8eYJOEc7APH6hAQfxOw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Everything You Need To Know About Recursion</figcaption></figure><p id="ab6c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">递归最常见的实现在<a class="ae kx" href="https://en.wikipedia.org/wiki/Mathematics" rel="noopener ugc nofollow" target="_blank">数学</a>和<a class="ae kx" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中。定义函数的地方是在它的定义中应用，虽然这将定义无限数量的实例，但它通常是以这样的方式完成的，不会触发无限循环或无限引用链。</p><h2 id="31c7" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">目录</h2><ul class=""><li id="05a4" class="lr ls in kb b kc lt kg lu kk lv ko lw ks lx kw ly lz ma mb bi translated">为什么你应该学习它</li><li id="9479" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">威尔，我需要递归吗？</li><li id="cde2" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">性能以及为什么在使用递归之前应该思考？</li><li id="748d" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">理解它并使用它</li><li id="da56" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">循序渐进的例子</li><li id="b3c2" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">Factorial(调用堆栈)分步示例</li><li id="51e5" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">真实世界的例子</li><li id="d51f" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">循序渐进的例子</li><li id="c041" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">丰富多彩的例子</li><li id="7348" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">快速排序(调用堆栈)分步示例</li><li id="7bd3" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">奖金</li><li id="bbad" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated">结论</li></ul><h2 id="a15f" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">为什么你应该学习它</h2><p id="0990" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">像谷歌、脸书、亚马逊这样的大公司经常在编码面试中使用递归。</p><p id="48f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它无处不在，你可能在不知情的情况下使用了它。下面是一些例子:“document.getElementById”、“JSON.stringify / JSON.parse。”</p><p id="7f61" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">递归思维帮助你将大问题分解成小问题。通常，递归解比迭代解更容易阅读。几乎每一种语言都一直在使用它。</p><p id="f55b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">递归思维是编程学习数据结构和算法所必需的。</p><h2 id="fc8e" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">威尔，我需要递归吗？</h2><p id="7029" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">这要看情况而定</p><p id="05e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为任何递归解决的问题也可以用迭代来解决。(迭代意味着使用循环，比如for和while)</p><p id="f41a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是一些数据结构和算法使用它，如果你试图绕过它，那么它将是不同的(数据结构或算法)</p><p id="5887" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下是一些例子:</p><ul class=""><li id="2ef5" class="lr ls in kb b kc kd kg kh kk mk ko ml ks mm kw ly lz ma mb bi translated"><strong class="kb io">举一个例子</strong>:对一棵树的遍历，这种只有父子链接的遍历永远不能用非递归算法来执行。实际上，如果你没有在这些方法中使用递归，那么你就有点疯狂了(即使对于命令式语言):</li></ul><blockquote class="mn"><p id="ef02" class="mo mp in bd mq mr ms mt mu mv mw kw dk translated">树遍历</p><p id="9c27" class="mo mp in bd mq mr mx my mz na nb kw dk translated">图表</p><p id="7486" class="mo mp in bd mq mr mx my mz na nb kw dk translated">从语法上分析</p><p id="eaf8" class="mo mp in bd mq mr mx my mz na nb kw dk translated">整理</p></blockquote><ul class=""><li id="6940" class="lr ls in kb b kc nc kg nd kk ne ko nf ks ng kw ly lz ma mb bi translated">固有递归算法的另一个例子是众所周知的快速排序算法。快速排序总是递归的，它永远不会变成非递归算法。因为如果你成功地做到了这一点，那么它将不再是快速排序了。这将是一个完全不同的算法。</li></ul><p id="3091" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个在unity游戏引擎中用C#语言构建的Sierpinski三角形的例子</p><p id="e6ff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">参见<a class="ae kx" href="https://i.stack.imgur.com/HAEZW.gif" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="nh">图片链接</em> </strong> </a></p><p id="1358" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可以用递归画出一个非常简单的例子，其中调用栈分支到三个方向:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="c6e5" class="ky kz in nn b gy nr ns l nt nu">private void Vertices(double x, double y, double l) {<br/>    if (l &gt; 0.002) {<br/>        mesh.Positions.Add(new Point3D(x, y + l, -l));<br/>        mesh.Positions.Add(new Point3D(x - l, y - l, -l));<br/>        mesh.Positions.Add(new Point3D(x + l, y - l, -l));<br/>        l *= 0.5;<br/>        Vertices(x, y + l, l);<br/>        Vertices(x - l, y - l, l);<br/>        Vertices(x + l, y - l, l);<br/>    }<br/>}</span></pre><p id="3444" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用迭代做同样的事情，我想你会发现需要更多的代码来完成。其他常见的用例可能包括遍历层次结构、网站爬虫、目录比较等。</p><h2 id="4937" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">性能以及为什么在使用递归之前应该思考？</h2><p id="9d05" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">一、复杂递归代码是<strong class="kb io"><em class="nh"/></strong>难以理解和<strong class="kb io"> <em class="nh">更新</em> </strong>。这需要“挠头”，直到一个人“明白”另一方面，好的代码，如使用循环，非常简单，易于更新。</p><p id="9e8f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以，有时候递归编程在内存上更昂贵，有时候它更清晰更可读，使用循环提高了性能。你应该重新思考问题，想出如何用迭代来解决。</p><p id="7ebe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，递归有时对程序员和他的性能更好，因为一些动态问题可以通过递归而不是for循环来轻松解决，但是用for循环来解决一些问题是困难的或者是完全不可能的，例如，“JSON”解析，“XML”解析等等。</p><p id="9418" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">决定用什么(<strong class="kb io">递归</strong>还是<strong class="kb io">迭代</strong>)取决于你想用什么，什么对你更重要(<strong class="kb io">可读性</strong>？还是<strong class="kb io">性能</strong>？)，问用递归还是迭代，不知何故就像问优雅还是性能。</p><h2 id="bd1b" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">理解它并使用它</h2><p id="d261" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">递归是指函数在其定义内部调用自身。</p><p id="7a2e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一种基于分而治之思想的解决问题的方法，基本上是你把原始问题分成更小的(更容易解决的)实例，解决这些更小的实例(通常通过再次使用相同的算法)，然后把它们重新组合成最终的解决方案。</p><p id="3b9f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每个递归函数都有两个部分:</p><ul class=""><li id="1767" class="lr ls in kb b kc kd kg kh kk mk ko ml ks mm kw ly lz ma mb bi translated"><strong class="kb io">一个简单的<em class="nh">基本情况</em></strong>——在满足条件时返回某个值的情况。</li><li id="ddf3" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated"><strong class="kb io">一个<em class="nh">递归步骤</em></strong>——一组规则，将所有的连续案例减少到基础案例。</li></ul><p id="9441" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是一个例子<strong class="kb io">使用<strong class="kb io">迭代</strong>生成n </strong>的阶乘</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="f03a" class="ky kz in nn b gy nr ns l nt nu">function <!-- -->Factorial<!-- -->(n) {<br/>  let fact = 1;</span><span id="a30f" class="ky kz in nn b gy nv ns l nt nu">  for(let i = 2; i &lt;= n; i++) {<br/>    fact = fact * i;<br/>  }</span><span id="6ede" class="ky kz in nn b gy nv ns l nt nu">  return fact;<br/>};</span></pre><p id="a5be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是上面同样的例子，使用了<strong class="kb io">递归</strong></p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="92b2" class="ky kz in nn b gy nr ns l nt nu">function <!-- -->Factorial<!-- -->(n) {<br/>  if( n &lt; 2 ) return 1;</span><span id="8ba1" class="ky kz in nn b gy nv ns l nt nu">  return n * <!-- -->Factorial<!-- -->( n - 1 );<br/>};</span></pre><p id="d750" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该功能的第一部分被称为<strong class="kb io">基础案例</strong>。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="9746" class="ky kz in nn b gy nr ns l nt nu">if( n &lt; 2 ) return 1;</span></pre><p id="7c3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这也是阻止算法永远运行的原因。每当调用值为1或更小的函数时，它只返回值1。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="7887" class="ky kz in nn b gy nr ns l nt nu">return n * <!-- -->Factorial<!-- -->( n - 1 );</span></pre><p id="efaf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第二部分被称为<strong class="kb io">递归步骤</strong>。这里我们调用相同的方法，只是稍微修改了参数(我们将其减1) <strong class="kb io"> <em class="nh"> n-1 </em> </strong>然后将结果乘以我们的n的副本。</p><p id="f3ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="nh">侧注:</em> </strong></p><blockquote class="nw nx ny"><p id="b071" class="jz ka nh kb b kc kd ke kf kg kh ki kj nz kl km kn oa kp kq kr ob kt ku kv kw ig bi translated">当定义一个循环(for或while循环)时，使用一个条件在预期的输出处停止它，这个条件在递归中称为基本情况。</p></blockquote><h2 id="8e46" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">循序渐进的例子</h2><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="9c1c" class="ky kz in nn b gy nr ns l nt nu">// In <!-- -->Factorial<!-- -->(5)<br/>return 5 * <!-- -->Factorial<!-- -->( 5 - 1 );</span><span id="b9f5" class="ky kz in nn b gy nv ns l nt nu">// which is<br/>return 5 * <!-- -->Factorial<!-- -->(4);</span></pre><p id="e285" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个例子应该会给你一个线索，让你知道最终的解决方案是如何得出的，我们将快速跟踪并展示下一步的每一步:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="f29e" class="ky kz in nn b gy nr ns l nt nu">return 5 * (4 * <!-- -->Factorial<!-- -->(3));<br/>return 5 * (4 * (3 * <!-- -->Factorial<!-- -->(2)));<br/>return 5 * (4 * (3 * (2 * <!-- -->Factorial<!-- -->(1))));<br/>return 5 * (4 * (3 * (2 * (1))));</span></pre><p id="b4d4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当基本情况被触发时，最后的替换发生了。</p><p id="a2e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">值得注意的是，每次调用该方法都会导致触发一个基本用例，或者调用参数更接近基本用例的同一个函数。</p><p id="e0cf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你弄乱了<strong class="kb io">基础用例</strong>，那么这个方法将永远运行下去。</p><h2 id="aeaa" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">Factorial(调用堆栈)分步示例</h2><p id="57f1" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">当我们编写递归函数时，我们不断地把新的函数推到调用堆栈上。下面是一个基本的例子:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="468e" class="ky kz in nn b gy nr ns l nt nu"><strong class="nn io">Factorial</strong><strong class="nn io">(5)</strong><br/>return 5 * <strong class="nn io">Factorial</strong><strong class="nn io">(4)</strong><br/>           return 4 * <strong class="nn io">Factorial</strong><strong class="nn io">(3)</strong><br/>                      return 3 * <strong class="nn io">Factorial</strong><strong class="nn io">(2)</strong><br/>                                 return 2 * <strong class="nn io">Factorial</strong><strong class="nn io">(1)</strong><br/>                                            return <strong class="nn io">1</strong></span><span id="d7af" class="ky kz in nn b gy nv ns l nt nu">now that we have Factorial(1) === 1<br/>return 5 * <strong class="nn io">Factorial</strong><strong class="nn io">(4)</strong><br/>           return 4 * <strong class="nn io">Factorial</strong><strong class="nn io">(3)</strong><br/>                      return 3 * <strong class="nn io">Factorial</strong><strong class="nn io">(2)</strong><br/>                                 return 2 * <strong class="nn io">1</strong></span><span id="0894" class="ky kz in nn b gy nv ns l nt nu">now that we have Factorial(2) === 2<br/>return 5 * <strong class="nn io">Factorial</strong><strong class="nn io">(4)</strong><br/>           return 4 * <strong class="nn io">Factorial</strong><strong class="nn io">(3)</strong><br/>                      return 3 * <strong class="nn io">2</strong></span><span id="1741" class="ky kz in nn b gy nv ns l nt nu">now that we have Factorial(3) === 6<br/>return 5 * <strong class="nn io">Factorial</strong><strong class="nn io">(4)</strong><br/>           return 4 * <strong class="nn io">6</strong></span><span id="bec7" class="ky kz in nn b gy nv ns l nt nu">now that we have Factorial(4) === 24<br/>return 5 * <strong class="nn io">24</strong></span><span id="b9cf" class="ky kz in nn b gy nv ns l nt nu">now that we have Factorial(5) === 120<br/>return <strong class="nn io">120</strong></span></pre><h2 id="b242" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">真实世界的例子</h2><p id="df61" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">阶乘的例子是递归的“hello world”。现在要知道现实世界的方法是如何工作的，我们需要解决其中的一个问题。</p><p id="5254" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">快速排序</strong>是计算机行业使用最广泛的排序算法之一。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="e0f3" class="ky kz in nn b gy nr ns l nt nu">function quick_sort(arr, left = 0, right = arr.length -1) {<br/>  if (left &lt; right) {<br/>    let pivot_Index = pivot(arr, left, right);<br/>    // left<br/>    quick_sort(arr, left, pivot_Index -1);<br/>    // right<br/>    quick_sort(arr, pivot_Index +1, right);<br/>  }<br/>  return arr;<br/>};</span></pre><p id="809b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所见，我没有定义<strong class="kb io">枢纽</strong>函数，因为这无关紧要，让我告诉你为什么:</p><ul class=""><li id="4d62" class="lr ls in kb b kc kd kg kh kk mk ko ml ks mm kw ly lz ma mb bi translated">首先，这篇文章是关于递归的，如果我教你所有关于快速排序的知识，只会让这篇文章更复杂。</li><li id="1fdb" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated"><strong class="kb io">其次</strong>，我们只关心快速排序中递归的用法</li><li id="4e29" class="lr ls in kb b kc mc kg md kk me ko mf ks mg kw ly lz ma mb bi translated"><strong class="kb io">最后是</strong>，如果你关心“<strong class="kb io"> pivot </strong>函数是做什么的？<br/>它的工作原理是选择一个元素(称为“pivot”)并在排序数组中找到pivot应该结束的索引。此外，枢纽将改变原来的数组，给我们一个新的。这里有一个例子:</li></ul><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d2ce" class="ky kz in nn b gy nr ns l nt nu">let arr = [ 5, 2, 1, 8, 4, 7, 6, 3 ]<br/>let p = pivot(arr, 0, arr.length -1)<br/> <br/>----------- after the variable p -----------<br/> <br/>the array will change to [ 3, 2, 1, 4, <strong class="nn io">5</strong>, 7, 6, 8 ]<br/>also, it will return arr[0], the number 5 in the correct index</span><span id="cbee" class="ky kz in nn b gy nv ns l nt nu">will change the array to [ 3, 2, 1, 4, <strong class="nn io">5</strong>, 7, 6, 8 ]<br/>will return arr[0], the number 5 in the correct index</span><span id="b30c" class="ky kz in nn b gy nv ns l nt nu">when the array fully sorted, you will find that the number (5) will have an index of 4</span></pre><ul class=""><li id="40a6" class="lr ls in kb b kc kd kg kh kk mk ko ml ks mm kw ly lz ma mb bi translated">如果你关心如何学习快速排序，我向你保证，我会找时间写一篇关于它的文章，让你足够自豪地教它。</li></ul><h2 id="8a88" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">循序渐进的例子</h2><p id="0889" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">“<strong class="kb io"> pivot </strong>”将改变原始数组，也是通过选择一个元素并找到“<strong class="kb io"> pivot </strong>”在排序后的数组中应该结束的索引来实现的。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="1d85" class="ky kz in nn b gy nr ns l nt nu"><strong class="nn io">quick_sort</strong>([1, 3, 5, 7, -9, 2, 6, 11])<br/>  if (left &lt; right) { // left = 0, right = 7<br/>   // check arr[left] where this should end up in the sorted array<br/>   let pivot_Index = pivot(arr, left, right)// 1<br/>   // array changed to [-9, 1, 5, 7, 3, 2, 6, 11 ]<br/>   // pivot_Index is now (1) and left=0<br/>   <strong class="nn io">quick_sort</strong>(arr, left, pivot_Index -1)<br/>     // arr is [-9, 1, 5, 7, 3, 2, 6, 11 ]<br/>     // left=0, right=0 because ((pivot_Index=1) -1 = 0)<br/>     if (left &lt; right) // false<br/>     return arr;<br/>   <strong class="nn io">quick_sort</strong>(arr, pivot_Index +1, right)<br/>     // arr is [-9, 1, 5, 7, 3, 2, 6, 11 ]<br/>     // right=7, left=2 because ((pivot_Index=1) +1 = 2)<br/>     if (left &lt; right) { // true<br/>      // check arr[left], as arr[2] will sort number (5)<br/>      let pivot_Index = pivot(arr, left, right)// 4<br/>      // array changed to [-9, 1, 2, 3, 5, 7, 6, 11 ]<br/>      // pivot_Index is now (4) and left=2<br/>      <strong class="nn io">quick_sort</strong>(arr, left, pivot_Index -1)<br/>        // arr is [-9, 1, 2, 3, 5, 7, 6, 11 ]<br/>        // left=2, right=3 because ((pivot_Index=4) -1 = 3)<br/>        if (left &lt; right) { // true<br/>         // check arr[left], arr[2] is already sorted<br/>         let pivot_Index = pivot(arr, left, right)// 2<br/>         // array did not change ([-9, 1, 2, 3, 5, 7, 6, 11 ])<br/>         // pivot_Index is now (2) and left=2<br/>         <strong class="nn io">quick_sort</strong>(arr, left, pivot_Index -1)<br/>           // arr is [-9, 1, 2, 3, 5, 7, 6, 11 ]<br/>           // left=2, right=1 because ((pivot_Index=2) -1 = 1)<br/>           if (left &lt; right) // false<br/>           return arr;<br/>         <strong class="nn io">quick_sort</strong>(arr, pivot_Index +1, right)<br/>           // arr is [-9, 1, 2, 3, 5, 7, 6, 11 ]<br/>           // left=3, right=3 because ((pivot_Index=2) +1 = 3)<br/>           if (left &lt; right) // false<br/>           return arr;<br/>        }<br/>        return arr;<br/>      <strong class="nn io">quick_sort</strong>(arr, pivot_Index +1, right)<br/>        // arr is [-9, 1, 2, 3, 5, 7, 6, 11 ]<br/>        // right=7, left=5 because ((pivot_Index=4) +1 = 5)<br/>        if (left &lt; right) { // true<br/>         // check arr[left], as arr[5] will sort number (7)<br/>         let pivot_Index = pivot(arr, left, right)// 6<br/>         // array changed to [-9, 1, 2, 3, 5, 6, 7, 11 ]<br/>         // pivot_Index is now (6) and left=5<br/>         <strong class="nn io">quick_sort</strong>(arr, left, pivot_Index -1)<br/>           // arr is [-9, 1, 2, 3, 5, 6, 7, 11 ]<br/>           // left=5, right=5 because ((pivot_Index=6) -1 = 5)<br/>           if (left &lt; right) // false<br/>           return arr;<br/>         <strong class="nn io">quick_sort</strong>(arr, pivot_Index +1, right)<br/>           // arr is [-9, 1, 2, 3, 5, 6, 7, 11 ]<br/>           // left=7, right=7 because ((pivot_Index=6) +1 = 7)<br/>           if (left &lt; right) // false<br/>           return arr;<br/>        }<br/>        return arr;<br/>     }<br/>     return arr;<br/>  }<br/>  return arr;</span></pre><h2 id="e77d" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated"><strong class="ak">丰富多彩的例子</strong></h2><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/9172ebd2879d6be7b96c6fc0464340df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpX-xSP3ZWlxsbi5yusr9A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Recursion A step-by-step example (quick-sort)</figcaption></figure><h2 id="f4e9" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">快速排序(调用堆栈)分步示例</h2><p id="dba5" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">展示每个递归步骤的示例</p><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/5d6f554abba9191306a37d9b2eef16f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YM4YpCkuApRe0nkmTxHclQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Quick-sort (call stack) in recursion</figcaption></figure><p id="f065" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你不能理解快速排序算法，不要担心，因为这是一篇递归文章。你只需要了解递归调用是如何进行的。</p><h2 id="082f" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">奖金</h2><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cedd0325445104cbc9719f57efb2deb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*-t8He1GMW4xpBHdFCZ9sXQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Chinese Folk Tales</figcaption></figure><h2 id="01d8" class="ky kz in bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">结论</h2><p id="9f05" class="pw-post-body-paragraph jz ka in kb b kc lt ke kf kg lu ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">实际上，每当需要迭代分支时，递归是最有意义的。</p><p id="df96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">递归很好学，谁说不是他的错而是教他的老师的错。</p><p id="bf4b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">阿尔伯特·爱因斯坦<strong class="kb io"> </strong>说:“<strong class="kb io"> <em class="nh">如果你不能向一个六岁的孩子解释清楚，那你自己也不明白。</em> </strong></p><p id="e8d5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望你有一个美好的一天，并随时问任何问题。</p></div></div>    
</body>
</html>