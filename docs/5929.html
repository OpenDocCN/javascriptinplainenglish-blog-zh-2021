<html>
<head>
<title>Let’s try to clarify different “rendering approaches” for web applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们试着阐明web应用程序的不同“呈现方法”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-try-to-clarify-different-rendering-approaches-for-web-applications-96ea0a1c8453?source=collection_archive---------5-----------------------#2021-12-20">https://javascript.plainenglish.io/lets-try-to-clarify-different-rendering-approaches-for-web-applications-96ea0a1c8453?source=collection_archive---------5-----------------------#2021-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/84089829d31f74faf7674e03cd7fcca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vN6r_J57SPC9giYwyEgRTg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="1d1b" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">什么是服务器端渲染，客户端渲染，预渲染，静态站点，通用应用，它们之间的JAMstack在哪里</h2></div><p id="01e2" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">有很多关于这个主题的文章，但是我仍然听到很多开发人员在理解这些技术上有困难。此外，随着新工具的出现，情况变得越来越复杂，所以我决定写下我对这个主题的想法。</p><p id="4ea4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我会试着一个一个的简单解释，突出利弊，举一些例子，工具，和其他文章的链接来深入一些方面。希望帮助其他人更清楚地选择你的下一个项目。</p><h1 id="2849" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">介绍</h1><p id="c9fb" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">曾几何时，web很简单(或者至少更简单)。最初，web仅仅是由HTML文件构成的，但是随着时间的推移，工具发生了很大的变化，社区创建了许多解决方案来使其他开发人员的生活更容易，并提供更好(和更复杂)的站点体验。这种发展自然引发了新的方法，因此服务于HTML文件的东西变成了在服务器端(服务器端呈现或预呈现)、在客户端(客户端呈现)或在两个地方(通用应用)构建应用程序。</p><p id="a595" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">一些新事物没有一个很好的不言自明的名字(看看你的JAMstack ),所以没有跟上新趋势的开发人员很容易被这些名字弄糊涂。</p><h1 id="2a30" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">服务器端呈现(SSR)</h1><p id="c21c" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">这是最古老的技术，不包括简单的静态文件主机(实际上是预渲染，但我们会谈到这一点)，因此很容易理解。</p><p id="9316" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">当客户端打开浏览器并请求一个网页时，服务器通过填充所有必要的信息(HTML标签、从数据库或其他地方获取的填充数据、CSS等)来构建HTML响应。浏览器收到的响应是一个完整的HTML文件，其中已经包含了它需要的所有内容。</p><p id="dfdd" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这意味着当响应到达浏览器时，他只需解析和呈现响应，没有其他事情要做。</p><blockquote class="mg mh mi"><p id="41e6" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">意大利风格<a class="ae mn" href="https://www.dictionary.com/e/slang/eli5/" rel="noopener ugc nofollow" target="_blank"> ELI5 </a>:你是一个人(浏览器)，你从一家披萨店(服务器)点了一份意大利香肠披萨(请求页面)。如果比萨饼是服务器端呈现的，你将收到一个完美的意大利香肠比萨饼，就像你从送货员那里要求的那样，你只需打开它并吃掉它(展示给最终用户)。</p><p id="49a9" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">但是，如果你想吃稍有不同的比萨饼(导航到另一页)，你必须再次打电话给比萨饼店，让另一个完整的比萨饼送来</p></blockquote><p id="cf4a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们来看一个简单的服务器端渲染app的响应。</p><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mo"><img src="../Images/ab9af7ceb46e4e3491197416b8a7e3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-C4hOcP-Ane1lQQCWbVMA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Response of a sample app created with Nuxt and SSR</figcaption></figure><p id="adde" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是一个使用SSR用Nuxt构建的简单待办app的响应。如果这不是你自言自语，不要担心，许多开发人员(我是:D的一员)并不真正了解，或者说并不完全理解现代框架的输出，原因之一是这些框架做了很多事情。总之，我们在这个例子中真正需要注意的是，HTML的<em class="mj">主体</em>包含一些数据，在这个例子中，它只是一个待办事项列表(来自服务器发出的API调用)，由标签和复选框表示，但在这里可以有任何内容。</p><p id="c0d4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">同样在头部，有一些元元素，那些可以用来丰富SEO和其他有用的东西。所有这些都可能包含特定于用户的数据，因为使用SSR构建的每个响应可能因用户而异，这是最重要的事情。</p><h2 id="06bc" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">赞成的意见</h2><p id="cec0" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">为什么要考虑SSR？这么多年了还有用吗？是的，它是！</p><ul class=""><li id="c6c1" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated"><strong class="kp iz"> SEO友好</strong>:在客户端渲染应用几年前开始兴起后，这是导致软件工程师选择SSR而不是CSR的主要原因(现在仍然如此)。由于响应完全填充了数据，每个SEO爬虫(即使它没有Javascript引擎)都能够读取响应，分析它并理解那里有什么，从而导致更好的索引，索引应用程序的每个URL的可能性，等等。</li><li id="48b4" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">快速加载时间</strong>:如前所述，当响应到达浏览器时，呈现阶段非常简单，因为HTML结构和数据已经存在，所以浏览器需要做的工作更少(至少与CSR相比，稍后会详细介绍)。</li></ul><h2 id="f0af" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">骗局</h2><p id="f917" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">缺点是什么？为什么会“发明”客户端渲染？</p><ul class=""><li id="ac12" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated"><strong class="kp iz">成本</strong>:您必须有一台全天候运行的服务器来处理客户端请求。你可以找到一些便宜的服务器托管，但这仍然是一个成本，这是会有的(对于高流量的应用程序来说，一个便宜的服务器是不够的)。</li><li id="f64f" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">页面过渡较慢</strong>:我喜欢把这个解释为“老旧的导航体验”。当应用程序以这种方式提供服务时，当你点击一个链接导航到另一个页面(同一网站)时，该页面将完全重新加载，你不可能有“平稳过渡”。</li><li id="ff8c" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">缓存</strong>:在SSR应用上配置缓存通常比较困难，尤其是对于没有经验的开发人员(相信我，对于有经验的开发人员也是如此)。</li><li id="a7bd" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz"> It <em class="mj">可能</em>有很长的交互时间</strong>:如果你使用Vue或React之类的框架为应用服务，这是真的，因此会有一个水合阶段，用户看到一个漂亮的页面，但不能与之交互(我们将在下面的预渲染章节中更多地讨论这一点，但如果你对水合感兴趣，请阅读<a class="ae mn" href="https://blog.julien-maury.dev/en/what-the-hell-are-hydration-and-rehydration/#so-what-is-hydrationrehydration-" rel="noopener ugc nofollow" target="_blank">这一章</a></li></ul><blockquote class="mg mh mi"><p id="3703" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">计算机科学只有两个硬东西:缓存失效和事物命名。<br/> —菲尔·卡尔顿</p></blockquote><h2 id="dd50" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">工具</h2><p id="6950" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">作为最古老的方法，有数以千计的选择，从<em class="mj">心爱的</em> <a class="ae mn" href="https://it.wordpress.org/" rel="noopener ugc nofollow" target="_blank"> WordPress </a>到广泛使用的<a class="ae mn" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a> for node lovers(但是它<a class="ae mn" href="https://www.reddit.com/r/node/comments/l67u0t/what_is_the_current_status_of_express_js_project/" rel="noopener ugc nofollow" target="_blank">没有主动维护</a>，所以我会考虑<a class="ae mn" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> koa </a>或<a class="ae mn" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> fastify </a>。但是真的有太多的选择，对于你能想到的每一种语言(可能不是T21有趣的语言，比如ArnoldC，对不起，Schwarz的粉丝)，将会有一些框架/库来创建一个web服务器，只需要几个步骤。</p><h2 id="a3e1" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">它的伟大之处在于</h2><p id="82d6" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">我在需求中首先考虑的是SEO，如果SEO不是一个需求，我可能不会选择这种方法，主要是因为成本/维护，但如果你来自后端背景，实际上SSR对你来说更容易。</p><p id="b4e4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">它非常适合需要SEO和具有高度动态内容的应用程序(例如，不是个人博客，因为我会选择预渲染，稍后解释)。</p><h1 id="6d6c" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">客户端渲染(CSR)</h1><p id="48ac" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">这通常也被称为<strong class="kp iz">单页应用</strong>，看起来它从21世纪初就已经存在了(感觉很老了吗？).</p><p id="b2c6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">与SSR相比，这几乎是相反的方法:客户端向服务器发出网站请求，服务器获取一个静态文件(通常是一个几乎为空的HTML文件)，然后立即将其发送回客户端。</p><p id="89db" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请注意，在这种情况下，服务器没有构建HTML，没有填充任何内容，它只是发送文件，这是一个关键部分，因为只需返回一个静态文件就意味着我们可以通过CDN存储和提供这些文件，无需服务器保持运行。</p><p id="0c4a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">当浏览器收到这个响应时，它会阅读这个响应，通常，他必须“构建页面”。</p><p id="3363" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我构建页面是什么意思？浏览器需要解析文件，这通常只包含一些到其他静态资产的链接，如js和css文件，他获取它们，解释并执行javascript。这就是了。构建页面的所有逻辑都在js文件中。它们包含从外部API获取必要数据的逻辑、处理结果的逻辑、基于这些响应动态构建HTML的代码等等。</p><blockquote class="mg mh mi"><p id="ab88" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">所以意大利式的ELI5应该是:你还是以前的那个人，你点了一份意大利香肠比萨饼。送货员拿着一个空盘子和比萨饼的食谱来到你面前，食谱上还列有配料的去处(所有的链接和你可能需要的其他文件)。然后，您必须去检索这些并为自己制作比萨饼(构建HTML并呈现所有内容)。</p><p id="2eae" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">好的一面是，如果你以后需要添加一种配料(导航到另一个页面),你只需要去取回那种配料，并把它放在比萨饼上，你不需要重新订购一切</p></blockquote><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/ef19ffdc19ede0e4974590e671ba2e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoZtMVHI6Dr3m3dcJqxiYA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Response of a sample app created with Nuxt and CSR</figcaption></figure><p id="26e5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是一个CSR应用程序的示例响应。</p><p id="3820" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请注意，在这种情况下，页面主体几乎是空的，它只包含一些要加载的脚本。正如我之前所说，这些脚本将负责“构建页面”。在客户端呈现的应用程序中，这个文件将被提供给每个客户端请求，不管是谁请求的。因此，在这种情况下，待办事项元素还没有呈现，因为API调用和相关HTML的创建将稍后在浏览器中完成。</p><h2 id="e023" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">赞成的意见</h2><p id="42b9" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">让我们看看为什么客户端渲染应用程序在过去十年里变得如此流行:</p><ul class=""><li id="5f4e" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated"><strong class="kp iz">更平滑(看起来更自然)的页面转换</strong>:当一个页面应用程序被渲染时，所有后续的导航都由客户端处理，不再需要点击重新加载页面。用这种方式浏览应用程序感觉更“自然”和快捷。</li><li id="60fa" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">缓存</strong>:正如我们所说的，服务器只需要返回相同的HTML(然后还有其他静态文件，js，CSS等等……)。这意味着我们可以更容易、更主动地缓存文件，缓存策略中隐含的逻辑更少。</li><li id="d41c" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">成本</strong>:即使这在之前的观点中已经暗示了，我还是想明确指出这一点。要托管一个单页应用程序，你只需要静态托管，到今天为止，你几乎可以在任何地方找到免费的服务，所以这是一个非常便宜的解决方案(对业余爱好项目来说很棒)。</li></ul><h2 id="f739" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">骗局</h2><p id="dc5c" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">显然，不是所有闪光的都是金子</p><ul class=""><li id="e9fe" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated">对SEO不友好:与SSR相反，这可能是主要的弱点。从服务器返回的文件几乎是空的(总是一样的，不能包含动态数据)，所以爬虫需要一个JavaScript引擎来获取一些信息，但即使这样，SEO也不会很好地工作，或者至少不容易预测</li><li id="fac6" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">较慢的初始加载</strong>:应用程序的第一次加载比所有其他方法都慢(因为浏览器需要做所有繁重的工作)。</li></ul><h2 id="4f07" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">它的伟大之处在于</h2><p id="f13d" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">我通常为所有不需要SEO的应用程序选择CSR，并且我不想增加一层复杂性(对于前端开发人员来说，这些应用程序通常更容易推理)，例如，在我看来，所有应用程序都受登录保护的B2B应用程序非常适合这里。</p><h2 id="850c" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">工具</h2><p id="654f" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">我认为这是工具和框架大爆发的地方。在过去的10年里，前端生态系统<strong class="kp iz">进化了如此之多</strong>…所以那里又有了成千上万的选择。在我看来，最著名、最现代、最成熟的是(我不会描述这些，但我会链接他们的网站):</p><ul class=""><li id="3542" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated"><a class="ae mn" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应过来</a></li><li id="4156" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><a class="ae mn" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a></li><li id="5e7c" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><a class="ae mn" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">有角度的</a></li><li id="9a5a" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><a class="ae mn" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">苗条</a>(有点新，用的少，但是有前途)</li></ul><p id="d2f0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">有大量的文章助长了“前端框架战争”，我个人认为所有这些框架都很神奇，这就是它们如此成立的原因)。</p><p id="e6ac" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我必须指出，这些框架也让您能够构建SSR应用程序，但这超出了本文的范围，它们并不是简单地开箱即用。</p><h1 id="739d" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">预渲染</h1><p id="b9e0" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">我觉得这比它的兄弟们更晚成为时尚。</p><p id="8246" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我认为它是在2008年由<a class="ae mn" href="https://jekyllrb.com/" rel="noopener ugc nofollow" target="_blank"> Jekyll </a>推广开来的(但我不是很确定)，并在过去的5-7年里变得非常流行。</p><p id="2b1a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这有点像SSR和CSR之间的融合，对于某些用例来说特别好(但是对于其他用例来说，就像每一种技术一样)。</p><p id="b224" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">预渲染实际上是一种服务器端渲染技术(页面不在客户端机器上渲染，所以是服务器端的)，主要区别在于渲染部分是在构建时完成的，而不是在用户请求页面时完成。当开发人员制作网站时，作为他构建网站的最后一步(使用适当的工具)，在这一阶段，生成的静态文件填充了所有的数据等，这正是当客户端请求网页时SSR中发生的事情，但这一次是在构建时完成的，而不是在客户端请求时。这具有巨大的影响:</p><ul class=""><li id="11b8" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated">输出是一组静态文件，所以我们可以只使用静态托管来托管构建的应用程序(如此容易缓存、便宜等……)，就像客户端呈现的应用程序一样</li><li id="cfbd" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">每个路由在生成时都必须是已知的。这是这种方法的最大缺点，如果你有一个电子商务应用程序，其中每个项目都有自己的详细页面，在URL中有id，预呈现并不容易，因为你应该在每次添加项目时重建和部署应用程序(这是可能的，有<a class="ae mn" href="https://www.netlify.com/blog/2019/01/17/how-to-scale-massive-react-static-sites-with-incremental-builds/" rel="noopener ugc nofollow" target="_blank">新技术</a>可以帮助你做到这一点，但这并不容易)，否则它的详细页面就不会存在。</li><li id="1b77" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">生成的文件不能在构建时插入特定于用户的数据(否则每个用户都会收到相同的数据，如果是特定于用户的，那就不太好了)，因此要启用该功能，需要该信息的部分将在客户端呈现，这就是为什么在我看来static generated是CRS和SSR应用程序的混合。客户端接收到一个已经填充了所有与用户无关的信息的页面，剩下的由他来处理。</li></ul><blockquote class="mg mh mi"><p id="6ffb" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">那么这在意大利人的刻板印象中会是怎样的呢？</p><p id="6697" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">比萨店只为你提供玛格丽塔比萨，但他们也会给你配方和信息来“改善”你的比萨。所以你得到了一份完美的(已经做好的)玛格丽塔，然后你只需要去取其他的配料，把它们放在披萨上。如果你不需要将披萨个性化，你会非常喜欢他们送的玛格丽塔。</p></blockquote><p id="2090" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是一个响应示例:</p><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ny"><img src="../Images/863373161a4871d98cdb26782e246443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxQQf8OPOO2IVIKvRrAVyA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Response of a sample app created with Nuxt in static generation mode</figcaption></figure><p id="62e9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这和你用SSR得到的结果差不多。不同之处在于，这个文件是在构建时生成的，而SSR是在用户请求页面时生成的。</p><h2 id="cbcd" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">赞成的意见</h2><p id="137e" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">这种方法具有CSR的大部分好处，因为托管应用程序与托管CSR应用程序是一样的，所以:</p><ul class=""><li id="0872" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated"><strong class="kp iz">易于缓存</strong></li><li id="7be9" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">便宜(不需要启动和运行服务器)</strong></li><li id="7402" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">这种方法实际上也是对SEO友好的，因为你有一个预先填充的HTML文件用于每个生成的路径，所以一旦爬虫分析了站点，SEO数据就会出现。</li><li id="b87e" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">另一个优点是<strong class="kp iz">快速初始渲染</strong>(通常使用这种技术可以实现所有技术的更快初始渲染)，因为在SSR中，页面已经填充了数据，但它是由具有良好缓存功能的cdn提供的。</li></ul><h2 id="26db" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">骗局</h2><p id="13ae" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">通过阅读优点，这似乎是最好的方法，但让我们看看有什么缺点:</p><ul class=""><li id="7d5b" class="nj nk iy kp b kq kr kt ku kw nl la nm le nn li no np nq nr bi translated">如果有大量的<strong class="kp iz">动态数据或特定于用户的数据</strong>，那么<strong class="kp iz">可能会很困难:网站是在构建时构建的，对于每条路线都会有一个相关的HTML文件。这些文件填充了必要的数据，但它们只能包含非特定于用户的数据或动态数据，不能有登录用户的用户名，否则，每个用户都会收到具有相同用户名的HTML。或者，例如，如果您想根据当前用户的阅读量向他显示一篇建议的博客文章，您就不能在构建时再这样做了。因此，所有这类逻辑都必须在客户端处理(通过API获取必要的数据，然后在页面上构建所需的部分。如果你有很多这样的逻辑，预渲染实际上会让你的日子更难过)。</strong></li><li id="c830" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">更多部署</strong>:一个例子胜过千言万语。假设您以这种方式构建了您的博客(这不是一个随机的例子，博客是预渲染应用程序的完美例子，它们非常适合)，当您添加一篇新的博客文章时，您将必须构建并部署整个应用程序，以将新的静态文件关联到新的博客文章。<br/>所以如果你有一个高度动态的网站，这可能是一个问题(这些天来<a class="ae mn" href="https://vercel.com/docs/concepts/next.js/incremental-static-regeneration" rel="noopener ugc nofollow" target="_blank">正在被一些框架</a>认真解决)。</li><li id="ad81" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">该网站是<strong class="kp iz">不是</strong>将是<strong class="kp iz">立即互动</strong>:当响应到达浏览器时，它将立即呈现和漂亮。但是js代码将在渲染阶段完成时被解析，这意味着当页面很漂亮时，用户期望的所有点击监听器和其他逻辑实际上还没有出现。因此，如果用户试图立即与一个按钮进行交互，网站就有可能什么也不做(这一阶段称为水合，你可以在<a class="ae mn" href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" rel="noopener ugc nofollow" target="_blank">为web渲染</a>和<a class="ae mn" href="https://addyosmani.com/blog/rehydration/" rel="noopener ugc nofollow" target="_blank">水合的成本</a>中了解更多信息)。这似乎不是一个大问题，但是如果你有一个大的应用程序，这可能会有点奇怪，在某些情况下，你需要做一些事情来防止用户变得沮丧(比如显示一个加载器或什么的)。</li></ul><h2 id="cd52" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">什么是伟大的</h2><p id="de17" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">预渲染是一项伟大的技术，在最近几年变得非常流行，显然，没有什么灵丹妙药。对于受益于SEO且不严重依赖用户特定数据的应用程序，我选择预渲染。例如技术博客(你可以注册，但是大部分内容/布局并不依赖于登录的用户)。</p><p id="ae36" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果由于成本原因你不想使用SSR，但你仍然想改善应用程序的加载时间，这可能是有用的(阅读更多关于<a class="ae mn" href="https://web.dev/first-contentful-paint/" rel="noopener ugc nofollow" target="_blank"> first contentful paint </a></p><h2 id="d318" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">工具</h2><p id="412b" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">最近几年(<a class="ae mn" href="https://www.netlify.com/jamstack/" rel="noopener ugc nofollow" target="_blank">也要感谢Netlify </a>)诞生了很多静态站点生成器，你可以在每种语言中找到一些(javascript也有很多)。我认为在这里可以找到一个很好的列表<a class="ae mn" href="https://jamstack.org/generators/" rel="noopener ugc nofollow" target="_blank"/>，但是如果你偏爱一个框架，你可以谷歌一下“vue静态站点生成器”这样的东西，大多数时候你不会失望的。</p><h1 id="7f3a" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">JAMstack</h1><p id="471c" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">那么JAMstack是什么，是“竞争对手”CSR、SSR等吗？</p><p id="b4dd" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">没有。我立即离开<a class="ae mn" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank">源</a>去了解更多的情况。</p><p id="441c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果我没记错的话，JAMstack是Netlify现任CEO ( <a class="ae mn" href="https://twitter.com/biilmann" rel="noopener ugc nofollow" target="_blank">马蒂亚斯·比尔曼</a>)创造的一个“词”。</p><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c7a000449d3035ed52fd6c890a9c9bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*TMx7lZN7ekMpreTilQZAuw.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Tom Preston (co-founder and former CEO of Netlify) tweet about his prediction about JAMstack</figcaption></figure><p id="3ca3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">再次，另一个<a class="ae mn" href="https://www.netlify.com/jamstack/" rel="noopener ugc nofollow" target="_blank"> Netlify网站很好地解释了这一点</a>。</p><p id="c33b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从字面上看，JAMstack的意思是“Javascript Api Markdown Stack”，所以这可以应用于许多(已经存在的)项目，你可能正在进行一个JAMstack项目，而你甚至不知道它。</p><p id="c23a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">但它真正的意思(至少在我看来是这样，但Netlify devs和CEO在<a class="ae mn" href="https://remotelyinteresting.transistor.fm/episodes/the-jamstack-can-do-that-be-the-future" rel="noopener ugc nofollow" target="_blank">这个精彩的播客</a>中证实了这一点，我建议所有剧集都是这样)是一种web开发方法，其中许多功能(如身份验证)被外包给第三方API(与前端应用程序分离)，HTML和CSS被预渲染(尽可能多)。</p><p id="990d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">所以实际上JAMstack使用了预渲染并实施了其他原则。我不会深入探讨这个问题，但是如果你感兴趣，我认为这篇文章<a class="ae mn" href="https://www.takeshape.io/articles/a-history-and-overview-of-the-jamstack/" rel="noopener ugc nofollow" target="_blank">中有一篇关于这个问题的非常好的文章</a>作者是<a class="ae mn" href="https://twitter.com/thisisjesschin" rel="noopener ugc nofollow" target="_blank">杰西卡·陈</a>。</p><blockquote class="mg mh mi"><p id="0948" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">前端开发人员能够专注于他们的专业领域，而不是试图成为所有行业的大师。马蒂亚斯·比尔曼菲尔·霍克斯沃思</p></blockquote><h1 id="9d5f" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">通用应用</h1><p id="3a8b" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">你有没有注意到CRS和SSR是完全相反的(不仅它们的工作方式完全不同，而且它们的优缺点也完全相反)？</p><blockquote class="mg mh mi"><p id="7260" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">“通用应用进入游戏”</p></blockquote><p id="a99b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">你也可以找到它们所谓的<a class="ae mn" href="https://en.wikipedia.org/wiki/Isomorphic_JavaScript" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="mj"/></strong></a><strong class="kp iz"><em class="mj">。</em>T9】</strong></p><p id="0ccf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">基本上，这是两个世界的融合，试图利用各自的优势，所以当客户端请求一个通用应用程序时，服务器会用一个完整的页面(构建在服务器上，所以在服务器端呈现)来响应，这就获得了SEO优势，速度等。例如，当客户端点击链接进入另一个页面(同一个应用程序)时，这种导航是在客户端处理的，因此转换是平滑的，不需要刷新。</p><p id="ec21" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这基本上融合了两个世界的精华，由于Next、Nuxt和其他框架帮助您以这种方式构建，而不需要在键盘上敲敲打打就能工作，所以它最近被广泛使用。</p><blockquote class="mg mh mi"><p id="f905" class="kn ko mj kp b kq kr jz ks kt ku kc kv mk kx ky kz ml lb lc ld mm lf lg lh li ig bi translated">意大利语:你可以点你想要的比萨饼，送货员会送来一个完美的现成的比萨饼，以及你需要改变它的食谱和信息。<br/>你真的不能再渴望更多了</p></blockquote><h2 id="026a" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">赞成的意见</h2><ul class=""><li id="9839" class="nj nk iy kp b kq mb kt mc kw oa la ob le oc li no np nq nr bi translated"><strong class="kp iz"> SEO友好</strong></li><li id="4176" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">快速加载时间</strong></li><li id="6a9c" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated"><strong class="kp iz">平滑页面过渡</strong></li></ul><h2 id="31dd" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">骗局</h2><ul class=""><li id="5cd2" class="nj nk iy kp b kq mb kt mc kw oa la ob le oc li no np nq nr bi translated"><strong class="kp iz">成本</strong>:和SSR一样，你需要一个启动并运行的服务器来完成这项工作</li><li id="a43a" class="nj nk iy kp b kq ns kt nt kw nu la nv le nw li no np nq nr bi translated">复杂性:这种方法比其他方法稍微复杂一点，因为每个页面都可以在客户端和服务器端呈现。这意味着，有时在执行某些代码之前，您必须检查您所处的环境(例如，您不能安全地使用浏览器API，因为代码可能正在服务器上运行)。</li></ul><h2 id="4cd7" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">它有什么好处</h2><p id="b96b" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">嗯，在我看来，这些应用程序几乎对任何事情都很好，它们确实比SSR和CSR应用程序都好。但是，总是有但是…我认为，如果你的应用程序可以是一个简单的客户端渲染应用程序，增加复杂性是不值得的(例如，如果你不需要SEO)，我相信任何复杂性的增加必须权衡其收益，所以总是把利弊放在你的上下文的平衡中。另一个例子是在我看来更适合静态渲染方法的博客或其他应用程序。</p><h2 id="ed41" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">工具</h2><p id="1474" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">这可能只是我缺乏知识，但在我看来，这里的景观不像其他情况下那样完整，我知道Next.js和Nuxt.js对此很棒，我从未尝试过Svelte Kit，但我肯定它也很棒。</p><p id="edbc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这里有另一个很有前途的框架，叫做<a class="ae mn" href="https://astro.build/" rel="noopener ugc nofollow" target="_blank"> Astro </a>，它是框架不可知的，承诺给客户端提供更少的javascript，但是我也从来没有尝试过。</p><p id="4e58" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我确信还有更多通用的工具，但是我现在想不起来了，欢迎在评论区添加它们</p><h1 id="5ba9" class="lj lk iy bd ll lm ln lo lp lq lr ls lt ke lu kf lv kh lw ki lx kk ly kl lz ma bi translated">结论</h1><p id="c015" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">我希望这能对某人有所帮助。正如我在开头所说的，这些只是我的观点，你可以自由地对每一点提出不同意见(万一我们在评论区谈论它或者在Twitter上联系我<a class="ae mn" href="https://twitter.com/albertodeago88" rel="noopener ugc nofollow" target="_blank"/>)。</p><h2 id="180d" class="mx lk iy bd ll my mz dn lp na nb dp lt kw nc nd lv la ne nf lx le ng nh lz ni bi translated">放弃</h2><p id="c455" class="pw-post-body-paragraph kn ko iy kp b kq mb jz ks kt mc kc kv kw md ky kz la me lc ld le mf lg lh li ig bi translated">在本文写作期间，没有意大利人受到虐待或被迫吃菠萝披萨。</p><p id="f0f2" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果你想知道你<a class="ae mn" href="https://c.tenor.com/rVITf4xkgrkAAAAC/steve-carell-no.gif" rel="noopener ugc nofollow" target="_blank">是否应该把菠萝放在披萨上</a> …</p><p id="fcc7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="mj">更多内容看</em> <a class="ae mn" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="mj">说白了就是</em> </strong> </a> <strong class="kp iz"> <em class="mj">。</em> </strong> <em class="mj">报名参加我们的</em> <a class="ae mn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="mj">免费每周简讯点击这里</em> </strong> </a> <strong class="kp iz"> <em class="mj">。</em> </strong></p></div></div>    
</body>
</html>