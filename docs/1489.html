<html>
<head>
<title>Build a Collapsible Menu in React with Intersection Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在与交叉点观察器反应中构建可折叠菜单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-collapsible-menu-in-react-with-intersection-observer-64f355df9f0c?source=collection_archive---------4-----------------------#2021-03-30">https://javascript.plainenglish.io/building-collapsible-menu-in-react-with-intersection-observer-64f355df9f0c?source=collection_archive---------4-----------------------#2021-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/9c0d40669ac645106c8302e3c1457039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nm3AoQpk4PgdrzaBvKzBhg.png"/></div></div></figure><div class=""/><p id="99e6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当人们谈论交叉点观察器时，想到的最常见的用例是<strong class="jx iz">懒惰加载图像</strong>和<strong class="jx iz">无限滚动</strong>。然而，交叉点观察器可以用在更多的交互中。</p><p id="4c0b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将实现一个这样的交互，这是一个<strong class="jx iz">可折叠菜单，</strong>，其中只有可以占用可用空间的项目才会显示在最前面，其余的将放在溢出菜单中。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi kt"><img src="../Images/408ee25aebc0da75ab313288a1414935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BKfEoqhbLtAmrKekj1N1mA.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Collapsible menu</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="7c02" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">为什么是交集观察者？</strong></p><blockquote class="lj lk ll"><p id="c2d3" class="jv jw lm jx b jy jz ka kb kc kd ke kf ln kh ki kj lo kl km kn lp kp kq kr ks ig bi translated">交叉点观察器API提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>的交叉点变化的方法。—<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">developer.mozilla.org</a></p></blockquote><p id="5f28" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于我们的设计，IntersectionObserver可能是一个很好的选择，因为它可以提供关于溢出容器的菜单项(即在容器中不可见)的信息。</p><h2 id="1524" class="lr ls iy bd lt lu lv dn lw lx ly dp lz kg ma mb mc kk md me mf ko mg mh mi mj bi translated">开始吧！</h2><p id="415c" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">我们的分析:</p><ul class=""><li id="03a3" class="mp mq iy jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">我们需要知道容器中存在的所有元素。</li><li id="af78" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">我们还需要关于哪些是可见的，哪些在调整大小时溢出容器的信息。</li><li id="ad72" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">一旦我们有了这两个信息，我们就可以用CSS控制元素的可见性，并在溢出菜单中呈现溢出的项目。</li></ul><p id="43d7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们从最初的代码块开始，它将菜单项呈现为容器中的子级。出于本文的目的，我使用静态内容的Material-UI，但是同样的概念也可以扩展到任何组件库或定制组件和动态内容。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Rendering our menu items as child elements to IntersectionObserverWrapper</figcaption></figure><p id="96ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，我们正在将唯一属性<strong class="jx iz"> data-targetid </strong>传递给<strong class="jx iz">intersection observer wrapper、</strong>的每个子对象<strong class="jx iz">。</strong></p><p id="6364" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们深入核心逻辑，在这里我们将实现<strong class="jx iz">intersection observer wrapper</strong>。</p><ul class=""><li id="6c26" class="mp mq iy jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">创建一个<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">的新实例intersect observer</strong></a><strong class="jx iz">。</strong></li><li id="9166" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">传递根元素作为子元素的容器。(我们示例中的navRef.current)</li><li id="d682" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">将阈值设置为1。这意味着，在100%的目标可见性中的任何变化，我们的观察者回调都将被执行。</li><li id="3c6c" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">在观察者回调中，我们将更新一个状态图来跟踪元素的可见性。</li><li id="ec45" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">创建完观察者后，我们需要观察我们的目标，即菜单项。为此，我们获得祖先节点的所有子节点，在我们的例子中，它是用navRef引用的，并且只有当它具有一个<strong class="jx iz"> data-targetid </strong>属性时，才作为目标添加。</li><li id="e96f" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">创建观察者和添加目标的逻辑都可以添加到运行后期初始渲染的<strong class="jx iz"> useEffect </strong>中。</li><li id="e215" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">记得在卸载组件时断开观察器。</li></ul><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Basic implementation of IntersectionObserverWrapper with IntersectionObserver setup</figcaption></figure><p id="28ee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经准备好处理维护可见性状态的逻辑了(<strong class="jx iz"> visibilityMap </strong>)。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">IntersectionObserver callback</figcaption></figure><p id="8388" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经有了每个菜单项的可见性状态，我们可以通过使用<a class="ae lq" href="https://reactjs.org/docs/react-api.html#cloneelement" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">React.cloneElement</strong></a>添加额外的<strong class="jx iz">类名</strong>来控制它们在渲染过程中的可见性(是的，必须使用react . cloneelement，对于静态子元素不能用其他方式)。可见性可以通过设置CSS属性<strong class="jx iz">可见性</strong>或<strong class="jx iz">不透明性</strong>来控制。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Render menu items with additional className property based on visibilityMap</figcaption></figure><p id="b322" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们的实现如下所示:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nf"><img src="../Images/46b18632aece2fd5aa032469e0c0d9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0yDZXJjjHo62kzetiEYW_w.gif"/></div></div></figure><h2 id="a2c0" class="lr ls iy bd lt lu lv dn lw lx ly dp lz kg ma mb mc kk md me mf ko mg mh mi mj bi translated">坚持住。它还没有完成…</h2><p id="b94a" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">让我们实现溢出菜单</p><p id="c940" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于溢出菜单，我们需要将所有菜单项及其可见性状态作为道具传递下去。</p><p id="e6f0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">注意</strong>:我们可以选择在所有情况下在容器外部或者容器内部呈现溢出菜单，这样它就在最后一个可见元素的旁边，而不是总是在容器的末尾。对于这个演示，我将把它添加到容器中，因为它比在容器外渲染要复杂得多。</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="985b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，我们没有将prop <strong class="jx iz"> data-targetid </strong>传递给<strong class="jx iz"> OverflowMenu </strong>组件，因为我们不希望我们的IntersectionObserver在上面进行观察。</p><p id="6fdc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">溢出菜单的呈现逻辑很简单，我们只过滤和呈现菜单中可见的元素</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">OverflowMenu rendering logic</figcaption></figure><p id="3f77" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，将溢出菜单对齐到最后一个可见元素右侧的关键是使用带有订单属性的<strong class="jx iz"> flexbox。可见元素的顺序值小于溢出菜单的顺序值，不可见元素的顺序值大于溢出菜单的顺序值。</strong></p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Our CSS styles</figcaption></figure><p id="6fc7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是构建可折叠菜单所需的一切！</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="ng ne l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">CodeSandbox Playground</figcaption></figure><h2 id="cb15" class="lr ls iy bd lt lu lv dn lw lx ly dp lz kg ma mb mc kk md me mf ko mg mh mi mj bi translated"><strong class="ak">结论</strong></h2><p id="fa04" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">我们在react中成功做了一个可折叠菜单。我们的应用程序只呈现容器中可见的项目，溢出的元素呈现在溢出菜单中。</p><p id="05d3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里看一下代码<a class="ae lq" href="https://github.com/mayankshubham/react-collapsible-menu/tree/main/src" rel="noopener ugc nofollow" target="_blank">的完整实现</a>。</p><p id="28e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lm">更多内容看</em><a class="ae lq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="lm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>