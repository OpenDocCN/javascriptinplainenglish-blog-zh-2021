<html>
<head>
<title>Configuring and using the Apollo client in a Next.js TypeScript application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Next.js类型脚本应用程序中配置和使用Apollo客户端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/configuring-and-using-the-apollo-client-in-a-next-js-typescript-application-9de6b2258943?source=collection_archive---------3-----------------------#2021-02-24">https://javascript.plainenglish.io/configuring-and-using-the-apollo-client-in-a-next-js-typescript-application-9de6b2258943?source=collection_archive---------3-----------------------#2021-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近一直在围绕<a class="ae kl" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">next . js</a>T11】graph QL做一些研究。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b02f30baf021ea519c07d401ea9f14af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlEAIs4LUqIe4EQ-1PIpGA.png"/></div></div></figure><p id="48b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在研究了后端之后(我将改天再写)，我想测试一些用于查询我的GraphQL API的库。</p><p id="d18e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，因为我是在后端使用Apollo，所以在“客户端”也使用Apollo是有意义的。</p><p id="dc09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将解释如何将它集成到我的Next.js应用程序中。既然你认识我，那么应用程序使用TypeScript应该是很明显的！</p><p id="c9ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<strong class="jp ir">我不是Next.js专家</strong>(也不是React one :p)，因此，我可能在很多事情上都是错的；你已经被警告了！:)</p><p id="9be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们走吧！</p><h2 id="9ef5" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">概观</h2><p id="2d94" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在Next.js应用程序中开始使用Apollo需要几个步骤:</p><ul class=""><li id="ce55" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">安装依赖项</li><li id="5e14" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">编写设置客户端的代码(较难的部分)</li><li id="bffe" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">用非极性溶剂包装部件(或不用)</li><li id="d05c" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">疯狂查询&amp;盈利！</li></ul><p id="da25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js让这个过程变得更复杂的是，它<a class="ae kl" href="https://nextjs.org/docs/basic-features/pages" rel="noopener ugc nofollow" target="_blank">支持</a>不同的“呈现模式”:完全静态的站点生成(SSG)、“增量静态再生”(这听起来是不是很伟大？)、服务器端渲染(SSR)等。有些页面可能在构建时获取一次数据，并在任何时候都以静态方式提供，而其他页面可能是动态的，并在运行时呈现一次或多次。入门有点棘手，但这是Next.js最酷的部分。</p><p id="9d66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为相同的代码将在不同的环境中执行，所以我们需要考虑这个事实，正如我们将在Apollo客户机设置中看到的那样。</p><p id="c5ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这是如何工作的…</p><h2 id="3874" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">属国</h2><p id="40e1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">通常你只需要一个依赖项:<code class="fe mk ml mm mn b">@apollo/client</code>。对于本文，我使用的是版本3.3.7。</p><h2 id="4d6e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Apollo客户端设置</h2><p id="245b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Apollo最大的优势之一是它的文档(在它令人瞠目结舌的特性列表旁边):<a class="ae kl" href="https://www.apollographql.com/docs/react/get-started/" rel="noopener ugc nofollow" target="_blank">https://www.apollographql.com/docs/react/get-started/</a>。如果你对阿波罗还不熟悉，那么就从那里开始，以后再回来；-)</p><p id="f172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是(在这个时间点上)，这些文档只关注React，没有针对Next.js的具体官方指导。我确实在Apollo博客上找到了<a class="ae kl" href="https://www.apollographql.com/blog/building-a-next-js-app-with-apollo-client-slash-graphql/" rel="noopener ugc nofollow" target="_blank">一篇帮助我开始的帖子，但它是用js写的，所以它只能让我到目前为止。至少它帮助我理解了不同的步骤！</a></p><p id="b330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想跟进，可以创建一个apollo.tsx文件。这是我使用的完整代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我一步一步地解释。</p><p id="fad9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个有趣的函数是<code class="fe mk ml mm mn b">createApolloClient</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="afde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数是唯一真正创建Apollo客户机实例的函数。返回类型还可以改进，但这只是一个开始。请注意，服务器端渲染模式仅在有意义时<em class="mq">才启用。知道<em class="mq">代码当前在哪里运行的最简单的方法是检查全局<code class="fe mk ml mm mn b">window</code>对象是否可用。如果不是，那么我们可以认为我们运行在“服务器端”(即构建时或实际上在服务器上)。</em></em></p><p id="db82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，客户端的链接是使用<code class="fe mk ml mm mn b">createIsomorphicLink</code>设置的。该函数如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="813c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码再次检查<em class="mq">代码当前运行的位置</em>，并根据我们所处的情况创建不同的模式链接。如果代码在服务器上运行(同样，要么实际上在服务器上运行，要么在构建时运行)，那么函数使用<code class="fe mk ml mm mn b">require</code>调用来直接加载GraphQL模式。相反，如果代码运行在客户端，那么这个函数使用一个<code class="fe mk ml mm mn b">HttpLink</code>来代替，使用HTTP加载GraphQL模式。</p><p id="ed2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是<code class="fe mk ml mm mn b">initializeApollo</code>功能:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b8eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数接受一些初始状态，并可以用它来合并Apollo客户机。首先，如果没有可用的实例，它将检索一个<code class="fe mk ml mm mn b">ApolloClient</code>实例。这一点很重要，因为它避免了浪费时间/资源，不必要地重新创建新实例。</p><p id="afd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果传入了一个初始状态，那么它将被放入Apollo缓存。</p><p id="41e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果代码没有在浏览器环境中运行，那么就返回Apollo客户机实例。否则，将保留对客户端的引用，以便可以重用它(和缓存)。</p><p id="6512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个函数<code class="fe mk ml mm mn b">useApollo</code>是一个钩子，它用<code class="fe mk ml mm mn b">useMemo</code>包装了前面的<code class="fe mk ml mm mn b">initializeApollo</code>函数，这<a class="ae kl" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">可能是也可能不是一个好主意</a>；-)</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fc14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，<code class="fe mk ml mm mn b">withApollo</code>函数是一个特设函数，可用于用<code class="fe mk ml mm mn b">ApolloProvider</code>包装Next.js页面/组件，使Apollo客户机可用，而不必用它包装整个应用程序。</p><p id="7d0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这基本上是在Next.js应用程序中使用Apollo客户端库的基本“工具箱”。TypeScript类型当然可以改进，但我将在这里就此打住。</p><h2 id="0d16" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">用非极性溶剂包装组件(或不用)</h2><p id="42ec" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在我能找到的各种例子中，人们似乎用<code class="fe mk ml mm mn b">_app.tsx</code>文件中的<code class="fe mk ml mm mn b">ApolloProvider</code>来包装他们的整个Next.js应用程序，就像这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们使用了之前看到的<code class="fe mk ml mm mn b">useApollo</code>钩子。</p><p id="22c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我不确定在<code class="fe mk ml mm mn b">_app.tsx</code>文件中这样做是否是个好主意。如果您在任何地方都使用Apollo，并且不想担心细节，这是有意义的，但是在完全不需要GraphQL的页面/组件周围添加它对我来说感觉很脏。</p><p id="de1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管怎样，正如我之前解释的，你也可以选择使用我包含的特设文件，并把阿波罗从你的<code class="fe mk ml mm mn b">_app.tsx</code>文件中删除。</p><p id="1c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，您就可以查询您的GraphQL APIs了！</p><h2 id="d5b3" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">疯狂查询&amp;盈利！</h2><p id="0c5e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">既然Apollo客户机已经配置好了，并且可以在需要的地方使用，那么就可以与GraphQL APIs进行交互了。</p><p id="5126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在本文开始时所讨论的，让Next.js变得真正酷的是这样一个事实:你可以控制<em class="mq">何时获取数据以及如何构建页面。您可以决定在构建时获取一次数据，并拥有一个超高性能的SEO友好的静态页面，您可以选择在运行时在服务器端呈现一次页面，动态地重新呈现它，等等。</em></p><p id="d39b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据不同的场景，您可以使用<code class="fe mk ml mm mn b">useQuery</code> Apollo <a class="ae kl" href="https://www.apollographql.com/docs/react/get-started/#request-data" rel="noopener ugc nofollow" target="_blank">钩子</a>来发送查询(假设<code class="fe mk ml mm mn b">ApolloProvider</code>正在包装您的当前页面/组件)，使用<code class="fe mk ml mm mn b">useApollo</code>钩子来直接检索客户端，或者使用<code class="fe mk ml mm mn b">getServerSideProps</code>或<code class="fe mk ml mm mn b">getStaticProps</code>中的<code class="fe mk ml mm mn b">getApolloClient</code>函数(<code class="fe mk ml mm mn b">initializeApollo</code>函数的别名)来检索<em class="mq">Apollo客户端实例并使用它。</em></p><p id="ce28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个使用<code class="fe mk ml mm mn b">getServerSideProps</code>的例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fc02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，对每个请求都执行查询。</p><p id="dfa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便注意一下Next.js 提供的很酷的<code class="fe mk ml mm mn b">InferGetServerSideProps</code>实用类型<a class="ae kl" href="https://nextjs.org/docs/basic-features/data-fetching#typescript-use-getserversideprops" rel="noopener ugc nofollow" target="_blank">的用法。得益于此，组件的道具与<code class="fe mk ml mm mn b">getServerSideProps</code>函数的输出相匹配。整洁！</a></p><p id="de1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是一些有用/相关的链接:</p><ul class=""><li id="caa7" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated"><a class="ae kl" href="https://www.freecodecamp.org/news/how-to-fetch-graphql-data-in-next-js-with-apollo-graphql/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/如何获取-graph QL-data-in-next-js-with-Apollo-graph QL/</a></li><li id="32c8" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=oxUPXhZ1t9I" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=oxUPXhZ1t9I</a></li><li id="3192" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae kl" href="https://nextjs.org/docs/basic-features/data-fetching" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs/basic-features/data-fetching</a></li></ul><h2 id="12c4" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">结论和下一步行动</h2><p id="48f4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">瞧。你可以走了。如果你对Next.js和Apollo足够熟悉，剩下的就应该很有趣了；-)</p><p id="bdf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我讲述了我最近学到的关于如何在TS Next.js应用程序中设置/配置Apollo客户机的知识。</p><p id="54f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据代码在哪里执行，初始化Apollo客户端并正确地水合它有点困难。如果您不习惯Next.js是如何工作的(像我一样:p ),那就太不简单了。</p><p id="45ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这个到位，我认为这是相当好的，但它有点太涉入我的意见。这就是为什么我要继续探索，看看在Next.js应用程序中<a class="ae kl" href="https://github.com/FormidableLabs/urql" rel="noopener ugc nofollow" target="_blank"> urql </a>和<a class="ae kl" href="https://github.com/vercel/swr" rel="noopener ugc nofollow" target="_blank"> SWR </a>与Apollo client相比如何。</p><p id="ac77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天就到这里吧！</p><p id="2167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附言:如果你想了解很多关于软件/网络开发的很酷的事情，那就看看我即将出版的书吧，订阅我的时事通讯吧，在推特上打个招呼吧！</p></div></div>    
</body>
</html>