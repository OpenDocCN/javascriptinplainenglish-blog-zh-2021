<html>
<head>
<title>Positioning &amp; Arranging View Components In React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中定位和排列视图组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/view-component-in-react-native-positioning-arranging-feac009b5661?source=collection_archive---------2-----------------------#2021-01-21">https://javascript.plainenglish.io/view-component-in-react-native-positioning-arranging-feac009b5661?source=collection_archive---------2-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1126" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对齐项目并构建出色的视图组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95997b8afb82cbfa206b7e095793bb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRiesp0q9ftiV9vCTfGDTg.png"/></div></div></figure><p id="ee7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几年前，当我开始学习React Native时，在视图组件中对齐项目曾经是一个很大的疑问，像<strong class="kt ir"> alignItems </strong>、<strong class="kt ir">align content</strong>&amp;<strong class="kt ir">justify content</strong>这样的道具在开始时总是有相同的意义，但通过正确的方法，随着一些实践，它真的很容易理解。在理解如何在<strong class="kt ir">视图</strong>组件中对齐和排列项目的同时，我们将查看一些实践。</p><blockquote class="ln lo lp"><p id="ffab" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">在我们深入概念之前，注意我们需要定义<strong class="kt ir">宽度&amp;高度</strong>或<strong class="kt ir">背景颜色</strong>来渲染一个视图，否则你不会观察到屏幕上正在渲染的任何东西。</p></blockquote><h2 id="a619" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">弯曲</h2><p id="66dc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">flex属性决定了项目将如何填充主轴上的可用区域，在<strong class="kt ir"> React Native </strong>中，flex的工作方式与在<strong class="kt ir"> CSS </strong>中不同，这里flex只是一个数字而不是一个字符串，并根据<a class="ae ms" href="https://github.com/facebook/yoga" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Yoga </strong> </a> <em class="lq">(实现flexbox的跨平台布局引擎)</em>布局引擎工作。</p><ul class=""><li id="062b" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">Flex是一个正数，它使组件灵活，组件的大小总是与其<strong class="kt ir"> flex值</strong>成比例。</li><li id="53b5" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">例如，带有flex:2的组件将占据两倍于带有flex:1的组件的位置。</li><li id="52d9" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">当flex为0时，组件根据其<strong class="kt ir">高度</strong> &amp; <strong class="kt ir">宽度</strong>属性调整大小。</li><li id="ef68" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">当flex: -1时，组件尺寸通常根据其<strong class="kt ir">高度</strong> &amp; <strong class="kt ir">宽度</strong>确定，但是如果没有足够的空间容纳组件，它将收缩到其高度&amp;宽度的最小可能值(<strong class="kt ir">最小高度&amp;最小宽度</strong>)。</li></ul><p id="d0e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lq">例如:</em> </strong></p><p id="8a10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个普通的视图组件，带有<strong class="kt ir"> flex: </strong> 1和<strong class="kt ir">background color:</strong>‘番茄’</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/ce40b5bfdb8c9c44c141cdb8070ce309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2xAFdN5-_ddh55Vs4SBww.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk"><strong class="bd nm">A Basic View Component</strong></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17b299831403ce4e0c2fb775e0002f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LV3yam7CesfjzPWNigiDnQ.png"/></div></div></figure><p id="6942" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果我们做一些改变，设置<strong class="kt ir"> flex: 0.5 </strong>，视图组件只覆盖了一半的可用空间。</p><h2 id="6a00" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">弯曲方向</h2><p id="b26b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">flexDirection属性控制容器的子容器的增长方向，<strong class="kt ir"> <em class="lq">行</em> </strong>从左到右，<strong class="kt ir"> <em class="lq">列</em> </strong>从上到下。</p><ul class=""><li id="cc86" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated"><strong class="kt ir">行:</strong>从左到右对齐子项。</li><li id="758e" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">列:</strong>上下对齐子节点<strong class="kt ir"> <em class="lq">(默认值)</em> </strong>。</li><li id="1f31" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir"> row-reverse: </strong>从右向左对齐子节点。</li><li id="a108" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">列-反转:</strong>从下到上对齐子项。</li></ul><p id="bc4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，如果我们没有定义<strong class="kt ir"> flexDirection </strong>，默认情况下，它在<strong class="kt ir"> React Native中被设置为<strong class="kt ir"> <em class="lq">列</em> </strong>。</strong>为了便于理解，我们举了一个例子，我们在一个<strong class="kt ir"> parentView </strong>组件中呈现了4个<strong class="kt ir"> childView </strong>组件，然后我们在parentView组件中定义了flexDirection。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7411f55e46bf7ef87b4ee18520368442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LP90Y88upptm6iqnrUUI8Q.png"/></div></div></figure><blockquote class="ln lo lp"><p id="a964" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">请注意，我们没有为parentView 中的<strong class="kt ir">列</strong> <em class="iq">定义flexDirection，因为默认情况下已经定义了它</em></p></blockquote><p id="4c8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们将flexDirection定义为row时，我们的4个<strong class="kt ir">子视图</strong>组件就会以row的方式排列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92516019b7d9bccc0b5a831d11787ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5kJiVl5VdXxIB3hZStwNg.png"/></div></div></figure><h2 id="796c" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">调整内容</h2><p id="a1b0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">描述子元素如何在容器的主轴内对齐，我们可以使用该属性在容器内水平对齐子元素，并将<strong class="kt ir"> flexDirection </strong>设置为row，反之亦然。</p><ul class=""><li id="655d" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated"><strong class="kt ir"> flex-start: </strong>将子项与容器主轴的起点对齐。</li><li id="c295" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir"> flex-end: </strong>将子项与容器主轴的末端对齐。</li><li id="9ab4" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">中心:</strong>在容器主轴的中心对齐子对象。</li><li id="cea1" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir"> space-between: </strong>在容器的主轴上均匀分布子元素。</li></ul><p id="8b44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，在上面的演示中，如果我们将<strong class="kt ir"> justifyContent </strong>定义为<strong class="kt ir"><em class="lq">space-between</em></strong>，那么所有的4个<strong class="kt ir"> childView </strong>组件都会占用这个空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36273241539a1cd70a6d901965ff5748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Bwd1tBcTYVEwnvjzllGuQ.png"/></div></div></figure><h2 id="9b6e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">alignItems</h2><p id="d64c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">该属性类似于<strong class="kt ir"> justifyContent </strong>，但是这里的项目沿着<strong class="kt ir">横轴</strong>对齐，而不是像我们在justifyContent中那样沿着主轴对齐项目。</p><ul class=""><li id="1899" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated"><strong class="kt ir"> flex-start: </strong>在容器横轴的起点对齐。</li><li id="74f5" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">弯曲端:</strong>对准容器横轴的末端。</li><li id="3a12" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">中心:</strong>对准容器横轴的中心。</li><li id="2e69" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">基线:沿着一条共同的基线对齐。</li><li id="74f4" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated"><strong class="kt ir">拉伸:</strong>(默认值):拉伸子对象，以匹配容器横轴的高度。</li></ul><h2 id="229b" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">自我调整</h2><p id="7ffe" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">该属性与alignItems非常相似，但我们可以使用该属性对齐单个子组件，而不是对齐父容器中的子组件，因为它覆盖了父容器设置的任何选项。</p><p id="02bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们可以通过将<strong class="kt ir"> alignSelf </strong>定义为<strong class="kt ir"> flex-end </strong>来将红色容器移动到屏幕的末端。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e26ef8e18c4ef642e57aac8146d1a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCHplGscLH8YOF686x4PKg.png"/></div></div></figure><h2 id="483d" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">align内容</h2><p id="195e" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">该属性定义了沿着<strong class="kt ir">横轴</strong>的线分布，并且仅当使用<strong class="kt ir"> flexWrap </strong>将项目包装成多条线时有效。请注意，仅当您将flexWrap应用到父容器时，它才起作用。</p><p id="031c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们将<strong class="kt ir"><em class="lq">felx wrap:</em></strong>wrap&amp;align content:center应用到我们的<strong class="kt ir"> parentView </strong>组件，我们将获得以下结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/83421ed582642578d94dc86e6f741c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kmzm24eiG9iMArLBJwiO_A.png"/></div></div></figure></div></div>    
</body>
</html>