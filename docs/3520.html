<html>
<head>
<title>From Zero to Dijkstra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到迪克斯特拉</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/from-zero-to-dijkstra-5c00c929ceab?source=collection_archive---------9-----------------------#2021-07-15">https://javascript.plainenglish.io/from-zero-to-dijkstra-5c00c929ceab?source=collection_archive---------9-----------------------#2021-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1cb9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第四部分:结束</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b8d030d4e458ea78926a5c9680c98e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K-q3L3xtcq-Pj6Hw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@joshriemer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Riemer</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9b0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们到了。祝贺你在博客系列中走到这一步，但是最艰难的战斗还在后面。让我们看看到目前为止我们已经实现了什么。</p><h1 id="6515" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">我们学到了什么</h1><ul class=""><li id="7d19" class="mh mi in kv b kw mj kz mk lc ml lg mm lk mn lo mo mp mq mr bi translated">二进制堆</li><li id="950f" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">优先级队列</li><li id="71d9" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">图表(加权和未加权)</li><li id="a773" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">图形遍历</li></ul><p id="4072" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了所有这些知识，我们应该只需要一点计划和预先考虑就能够实现Dijkstra算法。让我们用伪代码和图表来完成一些步骤。</p><h1 id="c75c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">设置</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2e853d2ec6f541ba02131f0c46635f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*ETMx32pGeDu1cQCerQBM1Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Weighted Graph</figcaption></figure><p id="854b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们的加权图。为了我们算法的目的，假设我们想要找到从<strong class="kv io"> A </strong>到<strong class="kv io"> E. </strong>的最短距离，这些是我们Dijkstra算法需要的自变量，a <strong class="kv io">开始</strong>和a <strong class="kv io">结束</strong>。我们如何着手解决这个问题？嗯，我们需要实现一个修改过的图遍历方法，查看A的每个邻居，找到A和邻居之间的最短距离。然后，我们对每个<em class="my">的邻居</em>重复这个过程，总是更新从A到顶点的最短距离。</p><div class="kd ke kf kg gt ab cb"><figure class="mz kh na nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/9d2d63d8ef8b9b77bf580472b0b26a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Hw9kBc-tBNklhXrrD2-Sww.png"/></div></figure><figure class="mz kh nf nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/d99b384fc1ec3053e40c40007bcb25ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*iwy4KJry68ozNkcCCmlsDQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk ng di nh ni">Tracking our shortest distance and the pathway to get there</figcaption></figure></div><p id="d891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在左边，我们正在记录从A开始到任意顶点的最短距离。到目前为止，我们只知道从A到A的距离是0。其余的可以使用<strong class="kv io">无穷大</strong>作为占位符，因为当我们穿越图表时，我们将用当时最小的距离替换那个无穷大(当找到更短的路线时，它可以改变多次，但我们只是从无穷大开始)。</p><p id="ea80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">右侧在记录我们正在走的路线。因为我们是邻居到邻居的旅行，我们只需要跟踪<strong class="kv io">前一个</strong>节点。因为从A到D的最短路径是通过C，所以我们的对象应该是这样的:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="7773" class="no lq in nk b gy np nq l nr ns">{<br/>'A': null,<br/>'C': 'A',<br/>'D': 'C'<br/>}</span></pre><p id="f41f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了更清楚起见，我省略了其他节点，但是您可以看到，如果我们沿着路径中的“前一个”节点，我们最终会回到A(它总是将<strong class="kv io"> null </strong>作为它的前一个节点，这让我们可以打破我们的一个循环)。</p><h1 id="e526" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">演练</h1><p id="2d18" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc nt le lf lg nu li lj lk nv lm ln lo ig bi translated">让我们通过第一次迭代来查看A的邻居，看看这如何改变我们的图表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2e853d2ec6f541ba02131f0c46635f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*ETMx32pGeDu1cQCerQBM1Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Weighted Graph</figcaption></figure><p id="3e0c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还记得第三部分中的<strong class="kv io">邻接表</strong>吗？我们可以通过遍历键“A”处的邻接表来遍历A的邻居。我们前往<strong class="kv io"> B </strong>，记录到达那里的距离。我们看到目前是<strong class="kv io"> 3 </strong>。然后，我们检查3是否小于最短距离表中的值。嗯，这是我们第一次通过，所以它是当前的无限和3小于无限。我们更新我们的表并更新我们的<strong class="kv io">先前的</strong>对象。</p><p id="ab2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们做的最后一件事是<strong class="kv io">将</strong>这段距离放入<strong class="kv io">优先级队列中。</strong>优先级队列很有帮助，因为每当我们将一个节点排入队列时，它都会重新排列自己，使其始终具有到顶端的最短距离<strong class="kv io">【bubble up()】</strong>。现在，当我们选择下一个要看的顶点时(在看了A的所有邻居之后)，它将是离A的下一个最短距离。</p><p id="4286" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在查看了A的两个邻居后，我们来看看我们的表:</p><div class="kd ke kf kg gt ab cb"><figure class="mz kh nw nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/2480d861c1ccbc1d4ca26136315b25b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*mOZ7aFERgpTt555sOHPxYg.png"/></div></figure><figure class="mz kh nx nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/15c5f816f40d42b123ce557f6e4932b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*hMYAnlOqRexJLkBKO6hJ1Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk ny di nz ni">Updated Distances and Previous Object</figcaption></figure></div><p id="785a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们再看一遍，看看它是如何更新我们的表的。查看我们的图表，我们可以看到<strong class="kv io"> C </strong>目前是距离A的下一个最短距离(A在这一点上已经<strong class="kv io">出列</strong>，所以下一个最短距离是2)。现在，我们对C的邻居重复这个过程。</p><p id="962e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们知道A到C已经更新了，所以不会改变，但是我们可以追踪到D和e的距离。记住，我们追踪的是从A到D的最短距离<strong class="kv io">！</strong>因此，我们在挨家挨户拜访时，必须将其他短距离加起来。C →D是1，C →E是4，因此，加上我们已知的“C距离”,我们的新表将如下所示:</p><div class="kd ke kf kg gt ab cb"><figure class="mz kh oa nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/fe9c25ac73d4b812a09d2bfbec8b1944.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*ETMx32pGeDu1cQCerQBM1Q.png"/></div></figure><figure class="mz kh ob nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/2f867e5ab124852fe41118561d0f9991.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*7YjCC9tWcUnH4uYxEBmzRQ.png"/></div></figure><figure class="mz kh oc nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/0d7f09d7415b9d0568516fd198a5bb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*VcCUIYzmUQZupCifXG5HoQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk od di oe ni">Updated Charts</figcaption></figure></div><p id="dec7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以看到，当我们比较时，如果我们注意到有更好的路径，我们将更新我们的最短距离。比如，我们可以看到，到E的最短距离显然是从A-C-D-E，一旦迭代D的邻居，图表就会更新。</p><p id="ce01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">重要提示:</strong>一个可能难以理解的重要概念是“我们何时知道何时停止循环？”我们必须确保我们只将被发现为<strong class="kv io">更短路径的邻居排队，</strong>这样我们就可以不断地重新检查最短路径，看看它是否比我们当前的路径更有效。我们当前到E的路径似乎是完整的，但是当我们迭代B和D的邻居时，我们将很快看到E将被更新。一旦E到达队列的顶部，我们将结束，因为我们知道E是在最短的距离(优先级队列将没有更短的距离来检查)。</p><p id="806c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们将已经采取的步骤改写成一些(非常宽泛的)伪代码:</p><h1 id="e689" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">伪代码</h1><ol class=""><li id="abcb" class="mh mi in kv b kw mj kz mk lc ml lg mm lk mn lo of mp mq mr bi translated">该函数应该接受一个<strong class="kv io">开始</strong>和<strong class="kv io">结束</strong>顶点作为参数</li><li id="ec8e" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo of mp mq mr bi translated">创建一个<strong class="kv io">距离</strong>对象，看起来像我们的初始距离表</li><li id="205d" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo of mp mq mr bi translated">创建一个类似上面的<strong class="kv io">前一个</strong>对象</li><li id="ebcf" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo of mp mq mr bi translated">将每个顶点添加到<strong class="kv io">优先级队列</strong></li><li id="d965" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo of mp mq mr bi translated">只要优先级队列有值，就开始一个循环</li></ol><ul class=""><li id="0dee" class="mh mi in kv b kw kx kz la lc og lg oh lk oi lo mo mp mq mr bi translated">让一个顶点出列，并遍历它的每个邻居(使用<strong class="kv io">邻接表</strong>)。如果顶点是我们的<strong class="kv io">终点，</strong>我们就大功告成了！</li><li id="3f0f" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">计算<strong class="kv io">起点</strong>和我们当前顶点之间的距离</li><li id="ee4d" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">如果该距离小于我们存储的距离:</li></ul><ol class=""><li id="9c71" class="mh mi in kv b kw kx kz la lc og lg oh lk oi lo of mp mq mr bi translated">更新<strong class="kv io">距离</strong>和<strong class="kv io">先前的</strong>对象，并用新的更小的距离将该顶点排队。</li></ol><p id="c0a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">代码</strong></p><p id="72f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，让我们设置我们的对象和变量。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="216b" class="no lq in nk b gy np nq l nr ns">function Dijkstra(start, finish) {<br/>    const queue = new PriorityQueue();<br/>    const distances = {};<br/>    const previous = {};<br/>    <br/>    let path = []; // to return at the end<br/>    let smallest;</span></pre><p id="4818" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你遵循伪代码，这是很容易理解的，但是我们正在初始化我们的临时<strong class="kv io">最小</strong>变量，以便在测试不同路径时与我们的<strong class="kv io">距离</strong>对象进行比较。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="829e" class="no lq in nk b gy np nq l nr ns">for (let vertex in this.adjacencyList) {<br/>    if (vertex === start) {<br/>        distances[vertex] = 0;<br/>        queue.enqueue(vertex, 0);<br/>    } else {<br/>        distances[vertex] = Infinity;<br/>        queue.enqueue(vertex, Infinity);<br/>    }<br/>    previous[vertex] = null;<br/>}</span></pre><p id="e008" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个块只是初始化我们的<strong class="kv io">先前的</strong>和<strong class="kv io">距离</strong>对象，看起来像上面的图表。它使我们的起始顶点的距离保持为0，而其他顶点的距离为无穷大。</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="425c" class="no lq in nk b gy np nq l nr ns">while (queue.values.length) {<br/>    smallest = queue.dequeue().val;</span><span id="475b" class="no lq in nk b gy oj nq l nr ns">    if (smallest === finish) {<br/>        //INSERT CODE TO END THE LOOP. WE'RE DONE<br/>    }    </span><span id="b460" class="no lq in nk b gy oj nq l nr ns">    if (smallest || distances[smallest] !== Infinity) {   </span><span id="53da" class="no lq in nk b gy oj nq l nr ns">        for (let neighbor in this.adjacencyList[smallest]) {<br/>            let nextNode = this.adjacencyList[smallest][neighbor]</span><span id="00f4" class="no lq in nk b gy oj nq l nr ns">        ................        </span></pre><p id="23ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们开始循环。我们出列并设置最小的等于该节点的<em class="my">值</em>。记住，队列中的节点看起来像<code class="fe ok ol om nk b">{val: 'A', priority: 0}</code></p><p id="2f75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们为我们将返回的<code class="fe ok ol om nk b">smallest === finish</code>设置一个占位符。然后，我们检查以确保我们实际上是将一个值出队，并且距离不是无穷大(以处理可能出现的错误，并确保我们的循环不会永远继续下去)。</p><p id="c1e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们遍历当前顶点的邻接表中的每个<code class="fe ok ol om nk b">neighbor</code>。我们创建了一个名为<code class="fe ok ol om nk b">nextNode</code>的变量，看起来有点像<code class="fe ok ol om nk b">{node: 'B', weight: 3}</code></p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="6ab5" class="no lq in nk b gy np nq l nr ns">..............<br/>// Calculate the distance between this node and 'start'</span><span id="0174" class="no lq in nk b gy oj nq l nr ns">let candidate = distances[smallest] + nextNode.weight;<br/>let neighborValue = nextNode.node;</span><span id="ecbc" class="no lq in nk b gy oj nq l nr ns">if (candidate &lt; distances[neighborValue]) {<br/>    // update 'distances' object<br/>    distances[neighborValue] = candidate;</span><span id="a109" class="no lq in nk b gy oj nq l nr ns">    // update 'previous' object<br/>    previous[neighborValue] = smallest;</span><span id="c446" class="no lq in nk b gy oj nq l nr ns">    // enqueue priority queue with new smallest distance<br/>    queue.enqueue(neighborValue, candidate)<br/>}</span></pre><p id="1b91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个部分通过添加当前顶点的最小距离并将其添加到<code class="fe ok ol om nk b">nextNode.weight</code>来创建一个<code class="fe ok ol om nk b">candidate</code>变量，T6是当前顶点和我们正在循环的邻居之间的距离。</p><p id="a25b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，它检查这个<code class="fe ok ol om nk b">candidate</code>是否小于我们当前拥有的。如果是这样，它更新<strong class="kv io">距离</strong>和<strong class="kv io">先前的</strong>对象，以显示我们新的最短路径，并且<strong class="kv io">将该顶点排队</strong>回到队列中。我们将它加入队列，因为现在我们已经更新了到我们所在节点的一条更短路径的信息，所以我们将想要再次循环通过那个顶点，即使我们之前已经到达过它。</p><p id="3723" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们回到完成循环的代码块:</p><pre class="kd ke kf kg gt nj nk nl nm aw nn bi"><span id="a565" class="no lq in nk b gy np nq l nr ns">if (smallest === finish) {<br/>    while(previous[smallest]) {<br/>        path.push(smallest);<br/>        smallest = previous[smallest];<br/>    }<br/>    break;<br/>}</span><span id="a52a" class="no lq in nk b gy oj nq l nr ns">.............</span><span id="bf73" class="no lq in nk b gy oj nq l nr ns">return path.concat(smallest).reverse();</span></pre><p id="5648" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到，我们只是循环遍历我们的<strong class="kv io">前一个</strong>对象，并沿着最短路径向后，将每个值推入我们的<code class="fe ok ol om nk b">path</code>数组。最后，我们必须连接<strong class="kv io">开始</strong>变量(它将是while循环结束时最小的<strong class="kv io">变量),然后反转它，因为我们向后进行了操作。</strong></p><p id="1a34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在函数结束时，<code class="fe ok ol om nk b">path</code>数组将从<code class="fe ok ol om nk b">['E', 'D', 'C']</code>到<code class="fe ok ol om nk b">['A', 'C', 'D', 'E']</code>显示最短的路径。</p><p id="3dc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">唷！这需要考虑很多，并且可能会与<code class="fe ok ol om nk b">neighborValue</code>和<code class="fe ok ol om nk b">nextNode</code>变量混淆，但是如果你在自己构建时<code class="fe ok ol om nk b">console.log()</code>这些变量，你会看到一切是如何组合在一起的。</p><p id="5443" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们最后看一下组合在一起的代码。</p><div class="kd ke kf kg gt ab cb"><figure class="mz kh on nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/d12122fb201ed3fc22d9634e73dde3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*6SA3nsz7eSUzeijj8uZq1A.png"/></div></figure><figure class="mz kh oo nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/49abf2b467f75f0aae6626f84c42333a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*AwbPRkoVCUAWn_iM_CkkyQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk op di oq ni">Dijkstra’s Algorithm</figcaption></figure></div><p id="b01a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">就是这样！如果你通过了这个博客系列，我祝贺你。Dijkstra的算法很难理解，但是你花在数据结构和算法上的时间越多，它就越有意义。对于真实世界的应用程序来说，这是一个很棒的工具，它可能会帮助你搞定下一次编码面试。</p><p id="bf6a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一如既往，我很乐意回答你在评论中提出的任何问题。编码快乐！</p><p id="0f65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="my">更多内容请看</em><a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="my">plain English . io</em></strong></a></p></div></div>    
</body>
</html>