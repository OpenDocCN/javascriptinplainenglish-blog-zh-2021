<html>
<head>
<title>How to Implement OAuth2 Facebook Authentication using Angular, Node.js, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Angular、Node.js和MongoDB实现OAuth2脸书认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-oauth2-facebook-using-angular-node-and-mongo-db-88e852bb9e80?source=collection_archive---------1-----------------------#2021-10-05">https://javascript.plainenglish.io/implementing-oauth2-facebook-using-angular-node-and-mongo-db-88e852bb9e80?source=collection_archive---------1-----------------------#2021-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3584955299bbd232c957af4ce65767f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9UpqY7R4QwopGNwP"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9473" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文展示了如何在Angular应用程序中添加基于脸书的OAuth2身份验证。本文假设您了解OAuth2和Passport npm模块的工作原理。</p><p id="f495" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我来总结一下OAuth2中的角色，以及每个角色的作用。</p><ol class=""><li id="dc29" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">与应用程序交互的最终用户(Express/Angular)是<strong class="kc io">资源所有者</strong>。</li><li id="fc9e" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">脸书是<strong class="kc io">资源服务器</strong>，它存储受保护的资源，即终端用户的详细信息。</li><li id="1755" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">Angular /Express应用程序是代表资源所有者请求访问受保护资源的<strong class="kc io">客户端</strong>。</li><li id="511a" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">脸书也是授权服务器。它对资源所有者进行身份验证，并在获得授权后，向客户端颁发访问令牌。</li></ol><p id="18ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">客户端将使用访问令牌来生成JWT令牌，以便使用JWT令牌而不是访问令牌来认证角度应用和快速服务器之间的所有进一步交互。</p><p id="32d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">流程步骤:</strong></p><ol class=""><li id="6832" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">资源所有者/最终用户选择通过脸书登录应用程序。</li><li id="173b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">脸书将使用用户名和密码验证资源所有者。</li><li id="8830" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">身份验证成功后，脸书会向客户端颁发一个访问令牌。</li><li id="afe5" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">客户端使用接入令牌来生成具有特定有效期的JWT令牌。</li><li id="f1f8" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">JWT令牌存储在浏览器的cookie中，这样资源所有者发出的进一步请求将根据令牌有效性进行身份验证。</li><li id="88ec" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">客户端能够调用脸书API <strong class="kc io"> /me </strong>来获取资源所有者的脸书配置文件细节。</li></ol><p id="6cc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一步:向脸书开发者应用注册并创建一个新应用。</strong></p><p id="a7ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要先登录<a class="ae jz" href="https://developers.facebook.com/app" rel="noopener ugc nofollow" target="_blank">https://developers.facebook.com/app</a>。这需要一个脸书帐户。</p><p id="d166" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个类型为<strong class="kc io"> None </strong>的新应用程序。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/ed7f607c3665514d5fdf25b3be33826c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7slbPFFRd9xVuIC7QZAj8w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Create App</figcaption></figure><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/c2e5df5869eeec3f7e4698bc531ba129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnMtNtaI1luenhUjv8EDiQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Give App Name and Contact Email</figcaption></figure><p id="6b52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦创建了您的应用程序，您将看到一个新的屏幕，顶部显示有<strong class="kc io">应用程序Id </strong>。这些信息对OAuth2至关重要。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/62463a8eeb81140e01bae83db3c44ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGy0VTuhr1zUIDoNVsGEsA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">App Id</figcaption></figure><p id="ed20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进入设置= &gt;基本，您可以查看<strong class="kc io">应用程序秘密</strong>，这是另一条重要信息。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/9d5c77810c7c086ce4e0e5fddaaef103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqvVGkhuByNdf1Ad2Vd_Ug.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">App Secret</figcaption></figure><p id="3b7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在屏幕的底部，有一个<strong class="kc io">添加平台</strong>的选项。我选择了网站，因为我们正在创建的是一个基本的网络应用程序。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/cb42d69e273fbf3f268cd0986a855609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*hvUIep_VlPv2S8DKcnSd4A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Add Platform</figcaption></figure><p id="a337" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">选择平台后，输入站点URL作为Angular应用程序URL:<a class="ae jz" href="https://localhost:4200" rel="noopener ugc nofollow" target="_blank">https://localhost:4200</a></p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/9d3196876953f7ef891ee4166244d49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgpaSi3rhaektOtpdst7Hw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Site URL</figcaption></figure><p id="045b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用脸书实现OAuth2，重要的是一个<strong class="kc io">安全站点</strong>访问它以使它工作，因为脸书只接受来自安全(HTTPS)站点的请求。</p><p id="90ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想知道如何添加一个HTTPS连接到你的本地角度和节点应用程序，你可以看看下面的故事。</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/setting-up-a-free-trusted-https-connection-for-your-local-express-server-d6716ad2cf69"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">为本地Express服务器和Angular Dev服务器设置HTTPS连接</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">我最近试图使用脸书作为授权和资源服务器来实现OAuth2。有很多…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jt lz"/></div></div></a></div><p id="6b02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在基本设置中更新应用程序域。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/e6844f5df70738900d808b0ba297a8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQacqrUTdqBiFckzNEzh1g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">App domains</figcaption></figure><p id="1878" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在在高级设置中，启用本机或桌面应用程序。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/1b94ea8eedcbcf5b77f0935045f97141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWQJQuDKpWTBLTJi7DOEZg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Advanced Settings</figcaption></figure><p id="58fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第二步:建立你的Node Express项目。</strong></p><p id="4c17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我总是喜欢使用<strong class="kc io"> express-generator </strong> npm模块来生成项目的框架。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/835785f644fc7042c11c32679a6a4066.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*klBywIzHyYfIm0nSzrUDqA.png"/></div></figure><p id="78a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们只需要检查4个文件:routes/users.js、authenticate.js、models/users.js和config.js</p><p id="8317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> config.js </strong></p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="a064" class="mw mx in ms b gy my mz l na nb">//centralising all config info<br/>module.exports={<br/>secretKey:’12345–67890–12345–67890', //secret key for signing jwt<br/>mongoUrl:’mongodb://localhost:27017/conFusion’,<br/><strong class="ms io">facebook:{<br/>clientId:”362253228721012", //facebook App Id<br/>clientSecret:”put your FB client secret here”<br/>}</strong><br/>}</span></pre><p id="992b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是不言自明的。我们已经导出了3条重要信息，供其他模块使用。</p><ol class=""><li id="e09b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe nc nd ne ms b">secretKey</code>为JWT代币签名。该令牌是在验证由脸书生成的访问令牌之后生成的。</li><li id="99e4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><code class="fe nc nd ne ms b">mongoUrl</code>是连接到数据库时使用的Mongo DB URL。</li><li id="8e8f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">当我们在脸书开发者网站上创建应用程序时，脸书向我们提供了应用程序Id和应用程序密码。</li></ol><p id="1e6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> userModel.js </strong></p><p id="8c18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们为通过脸书或传统用户名/密码认证登录应用程序的用户编写了模式。最后，我们导出这个模式的<strong class="kc io">用户模型</strong>，用于其他模块与<strong class="kc io">用户集合</strong>进行交互。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="a3f7" class="mw mx in ms b gy my mz l na nb">const mongoose = require(‘mongoose’);<br/>const schema = mongoose.Schema;<br/>const passportLocalMongoose = require(‘passport-local-mongoose’);</span><span id="295d" class="mw mx in ms b gy nf mz l na nb">const userSchema = new schema({<br/>firstName: {<br/>type: String,default: ‘’<br/>},<br/>lastName: {<br/>type: String,default: ‘’<br/>},<br/>facebookId: String,<br/>admin: {<br/>type: Boolean,<br/>default: false<br/>}<br/>})</span><span id="1b92" class="mw mx in ms b gy nf mz l na nb">userSchema.plugin(passportLocalMongoose);<br/>module.exports = mongoose.model(‘User’, userSchema);</span></pre><p id="e316" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> routes/users.js </strong></p><p id="f7df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们写了一个路由，它接受由脸书后身份验证提供的访问令牌作为查询参数。</p><p id="0d87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个路由执行由中间件中的<strong class="kc io">passport-Facebook-token</strong>模块提供的策略，以验证访问令牌并执行更多的动作，我们将在讨论身份验证模块时很快看到这些动作。</p><p id="2fb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">策略成功执行后，我们使用authenticate模块的<strong class="kc io"> getToken() </strong>生成一个<strong class="kc io"> JWT令牌</strong>。现在就把它当作一个黑盒，当被调用时，它会生成一个JWT令牌。令牌是使用用户集合中记录的<strong class="kc io"> _id字段</strong>作为有效负载生成的。这个字段对于集合中的每条记录都是惟一的，当一条记录被插入到集合中时，由MongoDB自动生成。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="142c" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">userRouter.get(‘/facebook/token’, passport.authenticate(‘facebook-token’), function (req, res, next) {</strong><br/>if (req.user) {<br/><strong class="ms io">let token = authenticate.getToken({ _id: req.user._id }); </strong></span><span id="ac2b" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">res.cookie('jwt',token,{secure:true,httpOnly:true});<br/>res.cookie('adm',req.user.admin,{secure:true});<br/>res.cookie('user',`${req.user.firstName} ${req.user.lastName}`,{secure:true});</strong></span><span id="07b9" class="mw mx in ms b gy nf mz l na nb">res.status(200).send();<br/>}<br/>})</span></pre><p id="120b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能想知道用户。_id属性存在于req对象中。脸书护照策略，成功验证后将用户信息序列化到会话中，即将以下对象添加到req.user中</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="cf6b" class="mw mx in ms b gy my mz l na nb">{ <br/>firstName: ‘Ramya’,<br/>lastName: ‘Balasubramanian’,<br/>admin: false,<br/>_id: 6156c32ac6e16619402588ff,<br/>username: ‘Ramya Balasubramanian’,<br/>facebookId: ‘115670914164322’,<br/>__v: 0 <br/>}</span></pre><p id="bb8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">贴出来，我们在浏览器上设置了3个cookies:jwt，adm和user。</p><p id="97ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">存储JWT令牌的cookie仅在安全连接上传输(安全标志确保这一点，并防止中间人攻击)，并且不能被浏览器上的JavaScript访问(httpOnly标志确保这一点)。</p><p id="6853" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">剩下的2个cookies包含管理员和用户的名字和姓氏，它们只有安全标志，因为它们需要被JavaScript访问以在屏幕上显示用户名，并且需要管理员信息来确定显示/隐藏哪些功能。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/36bf3a73bc5046aa08267ea9800bfa4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-ggS29dRRhSQXJ6svL3_w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Cookies</figcaption></figure><p id="8909" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，这个JWT令牌将用于将来客户端和服务器之间的所有交互，以进行身份验证。将不再使用访问令牌。</p><p id="132d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面截图中的会话id cookie对应于基于服务器的<strong class="kc io">快速会话npm模块</strong>，我们已经使用该模块在服务器端安全地存储CSRF秘密信息，并且仅在浏览器上存储会话id细节。CSRF令牌与这里的讨论无关，因此被省略了。</p><p id="afd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> authenticate.js </strong></p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="80ff" class="mw mx in ms b gy my mz l na nb">const passport = require(‘passport’);<br/>const userModel = require(‘./models/users’);<br/><strong class="ms io">const jwt = require(‘jsonwebtoken’);<br/>const facebookTokenStrategy = require(‘passport-facebook-token’);</strong></span><span id="8e20" class="mw mx in ms b gy nf mz l na nb">const config = require(‘./config’);</span><span id="fb0d" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">passport.serializeUser(userModel.serializeUser());<br/>passport.deserializeUser(userModel.deserializeUser());</strong></span><span id="f52c" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">//Facebook strategy<br/>passport.use(new facebookTokenStrategy({<br/>clientID: config.facebook.clientId,<br/>clientSecret: config.facebook.clientSecret<br/>}, function (accessToken, refreshToken, profile, done) {</strong><br/>userModel.findOne({ facebookId: profile.id }, function (err, user) {<br/>if (err) {<br/>console.log(err);<br/>return done(err, false);<br/>}<br/>else {<br/>if (user) {<br/>return done(null, user);<br/>}<br/>else{<br/>let newUser = new userModel({<br/>username: profile.displayName<br/>})<br/>newUser.facebookId = profile.id;<br/>newUser.firstName = profile.name.givenName;<br/>newUser.lastName = profile.name.familyName;<br/>newUser.save(function (err, user) {<br/>if (err) {<br/>return done(err, false);<br/>}<br/>else {<br/>return done(null, user);<br/>}})}}})<br/>}))</span><span id="52f7" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">exports.getToken = function (user) {</strong><br/>//user is the _id of the document in the users collection<br/>//user is the user info i.e payload which will be signed by secret //key. Token will expires in 360 sec<br/>return jwt.sign(user, config.secretKey, {<br/>expiresIn: ‘360s’<br/>})<br/>}</span></pre><ol class=""><li id="2dff" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">护照-脸书-令牌</strong>模块:</li></ol><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="f975" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">passport.use(new facebookTokenStrategy({<br/>clientID: config.facebook.clientId,<br/>clientSecret: config.facebook.clientSecret<br/>}, function (accessToken, refreshToken, profile, done) {</strong><br/>console.log(accessToken);<br/>userModel.findOne({ facebookId: profile.id }, function (err, user) {<br/>if (err) {<br/>console.log(err);<br/>return done(err, false);<br/>}<br/>else {<br/>if (user) {<br/>return done(null, user);<br/>}<br/>else{<br/>let newUser = new userModel({<br/>username: profile.displayName<br/>})<br/>newUser.facebookId = profile.id;<br/>newUser.firstName = profile.name.givenName;<br/>newUser.lastName = profile.name.familyName;<br/>newUser.save(function (err, user) {<br/>if (err) {<br/>return done(err, false);<br/>}<br/>else {<br/>return done(null, user);<br/>}})}}})<br/>}))</span></pre><p id="a623" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述策略在调用<strong class="kc io">passport . authenticate(‘Facebook-token’)</strong>时执行。正如我们已经看到的，这在<strong class="kc io"> /facebook/token </strong>路线中被称为中间件。该策略从请求中的查询参数提取访问令牌，并使用提供给该策略的客户机id和机密作为参数来验证它。</p><p id="695d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">访问令牌也可以在头或主体中传递，而不是作为查询参数传递。请检查下面的链接，看看它是如何在标题或正文中传递的。</p><div class="lw lx gp gr ly lz"><a href="https://www.npmjs.com/package/passport-facebook-token" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">护照-Facebook-令牌</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">使用OAuth 2.0 API通过脸书访问令牌进行身份验证的Passport策略。本模块让您…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.npmjs.com</p></div></div><div class="mi l"><div class="nh l mk ml mm mi mn jt lz"/></div></div></a></div><p id="0704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在回调函数中，我们能够提取用户配置文件的详细信息。我们在用户集合的<strong class="kc io"> facebookId </strong>字段中寻找一个匹配的配置文件Id。如果返回一个匹配，并且没有遇到错误，则返回done (null，user)。如果没有匹配，那么我们将在Users集合中为这个概要文件创建一个新的用户记录。</p><p id="e8d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面这段代码将解释如何将用户信息序列化到会话(req.user)中，以及如何从会话(req.user)中反序列化。Passport模块提供的方法提供了这种功能。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="6033" class="mw mx in ms b gy my mz l na nb">passport.serializeUser(userModel.serializeUser());<br/>passport.deserializeUser(userModel.deserializeUser());</span></pre><p id="22dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="kc io"> jsonwebtoken </strong>模块:使用用户集合的_id字段作为有效负载来生成JWT令牌时，此模块是必需的。我们在下面的方法中使用了该模块来生成一个有效期为360秒的令牌。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="460b" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">exports.getToken = function (user) {</strong><br/>//user is the _id of the document in the users collection<br/>//user is the user info i.e payload which will be signed by secret //key. Token will expires in 360 sec<br/>return <strong class="ms io">jwt.sign(user, config.secretKey, {<br/>expiresIn: ‘360s’<br/>})</strong><br/>}</span></pre><p id="b923" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第三步:使用脸书登录SDK设置Angular应用程序。</strong></p><p id="2b94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在控制面板中，我们有一个设置脸书登录的选项。点击setup = &gt; Select Web as platform = &gt;输入<a class="ae jz" href="https://localhost:4200" rel="noopener ugc nofollow" target="_blank"> https://localhost:4200 </a>作为您站点的URL。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/c51836d4fc4309249f75183c7dfa63fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8WbEzzYlJUEDt0p6lu5cg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Facebook Login</figcaption></figure><p id="4f58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将向您展示在angular应用程序中配置脸书登录的几个步骤。假设你已经准备好了你的角度计划，让我们从这些步骤开始。</p><p id="4306" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">加载脸书SDK并检查登录状态。</p><p id="19a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> app.module.ts </strong>中，在导入之后和NgModule定义开始之前，添加下面这段代码。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="9996" class="mw mx in ms b gy my mz l na nb">declare const FB:any;</span><span id="0da3" class="mw mx in ms b gy nf mz l na nb">function <strong class="ms io">appInitializer</strong>(loginService: LoginService) {<br/>return ()=&gt; new Promise((resolve, reject) =&gt; {<br/>// wait for facebook sdk to initialize before starting the angular //app<br/><strong class="ms io">window[‘fbAsyncInit’] = function () {<br/>FB.init({<br/>appId: environment.facebookAppId,<br/>cookie: true,<br/>xfbml: true,<br/>version: ‘v11.0’<br/>});<br/>FB.AppEvents.logPageView();<br/>}</strong></span><span id="fdde" class="mw mx in ms b gy nf mz l na nb">// auto authenticate with the api if already logged in with facebook<br/>loginService.getFacebookLoginStatus().then((authResponse:any)=&gt;{<br/>if (authResponse) {<br/>console.log(authResponse);<br/>loginService.setFacebookAuthStatus(authResponse);<br/>resolve(true);<br/>} else {<br/>resolve(true);<br/>}<br/>});</span><span id="f2b3" class="mw mx in ms b gy nf mz l na nb">// load facebook sdk script<br/><strong class="ms io">(function (d, s, id) {<br/>var js, fjs = d.getElementsByTagName(s)[0];<br/>if (d.getElementById(id)) { return; }<br/>js = d.createElement(s); js.id = id;<br/>js.src = “https://connect.facebook.net/en_US/sdk.js";<br/>fjs.parentNode.insertBefore(js, fjs);<br/>}(document, ‘script’, ‘facebook-jssdk’));<br/>});</strong><br/>}</span></pre><p id="908f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> appInitializer </strong>函数中，注入了对LoginService(我们很快就会看到)的引用，以访问服务中的方法。</p><p id="b65c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，在@NgModule definitions，providers部分添加appInitializer函数，如下所示。appInitializer函数将在app初始化时执行。除非函数中的承诺没有解决，否则应用程序初始化不会完成。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="dac0" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">providers: [<br/>{<br/>provide: APP_INITIALIZER,<br/>useFactory: appInitializer,<br/>deps: [LoginService],<br/>multi: true<br/>}<br/>],</strong></span></pre><p id="025b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">environment . facebook appid</strong>是我们之前在Facebook开发者应用中创建应用时看到的应用Id。我已经用下面提到的应用ID在脸书开发者上创建了一个应用。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="5b11" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">//environment.ts</strong><br/>export const environment = { <br/>production: false, <br/>baseUrl:”https://localhost:3443/oauth/", clientUrl:”http://localhost:4200", <br/><strong class="ms io">facebookAppId</strong>:”<strong class="ms io">362253228721012</strong>"};</span></pre><p id="daf4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是从<strong class="kc io">环境. ts </strong>文件中导出的。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="2e1c" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">//app.module.ts</strong><br/><strong class="ms io">loginService.getFacebookLoginStatus()</strong>.then((authResponse:any)=&gt;{<br/>if (authResponse) {<br/>console.log(authResponse);<br/><strong class="ms io">loginService.setFacebookAuthStatus(authResponse);</strong><br/>resolve(true);<br/>} else {<br/>resolve(true);<br/>}<br/>});</span></pre><p id="ae03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当在浏览器中点击<a class="ae jz" href="https://localhost:4200" rel="noopener ugc nofollow" target="_blank"> https://localhost:4200 </a>时，随着应用程序初始化，我们在服务中调用方法<strong class="kc io">getFacebookLoginStatus()</strong>来检查脸书用户的身份验证状态。一旦成功接收到状态，承诺在app.module.ts中解析，我们调用LoginService中的<strong class="kc io">setfacebooktauthstatus()</strong>方法来基于状态执行一些操作。一旦我们理解了脸书发送的用户的认证状态，我们将在后面看到这一点。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="583a" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">//LoginService</strong><br/><strong class="ms io">getFacebookLoginStatus</strong>(): Promise&lt;any&gt; {<br/>return new Promise((resolve, reject) =&gt; {<br/><strong class="ms io">FB.getLoginStatus((authResponse) =&gt; {<br/>resolve(authResponse);<br/>})</strong><br/>})<br/>}</span></pre><p id="b2b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经在LoginService中在导入之后和class关键字之前声明了FB，如下所示。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="217f" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">declare const FB: any;</strong><br/>@Injectable({<br/>providedIn: ‘root’<br/>})<br/>export class LoginService {<br/>//constructor,methods and instance variables<br/>}</span></pre><p id="091d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">FB.getLoginStatus()</code>将触发对脸书的调用，以获得如下所示的登录状态。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="2be6" class="mw mx in ms b gy my mz l na nb">{<br/> status: ‘connected’,<br/> authResponse: {<br/> accessToken: ‘…’,<br/> expiresIn:’…’,<br/> signedRequest:’…’,<br/> userID:’…’<br/> }<br/>}</span></pre><p id="624e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">status属性指定应用程序使用者的登录状态。状态可以是下列之一:</p><p id="9d97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">connected</code> -此人已登录脸书，并已登录您的应用程序。</p><p id="222d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">not_authorized</code> -此人已登录脸书，但尚未登录您的应用程序。</p><p id="d72a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">unknown</code> -此人没有登录脸书，所以你不知道他们是否登录过你的应用程序，或者之前是否呼叫过<code class="fe nc nd ne ms b">FB.logout()</code>，因此无法连接到脸书。</p><p id="1b5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> authResponse </strong>如果状态为已连接，则包含属性，该属性由以下内容组成:</p><p id="de34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">accessToken</code> -包含应用程序使用者的访问令牌。</p><p id="6530" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">expiresIn</code> -表示令牌过期并需要续订的UNIX时间。</p><p id="c11c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">signedRequest</code> -一个有符号的参数，包含应用程序使用者的信息。</p><p id="0a72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nc nd ne ms b">userID</code> -应用程序使用者的ID。</p><p id="8f2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，为了基于authResponse中的登录状态执行进一步的操作，我们调用<strong class="kc io">setfacebooktauthstatus()。</strong></p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="b582" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">setFacebookAuthStatus</strong>(response: any) {<br/>if (response.status === “connected”) {<br/> this.fb_authenticated=true;<br/> console.log(“The person is logged into Facebook, and has logged into your webpage.”);<br/> <strong class="ms io">this.generateJWTTokenForFB(response.authResponse.accessToken)</strong>.subscribe((data: any) =&gt; {<br/> this.<strong class="ms io">getFacebookUserInfo()</strong>.then(() =&gt; {<br/> this.<strong class="ms io">setUserAuthenticationStatus(true);</strong><br/> })<br/> .catch(err =&gt; console.log(err))<br/> })<br/> }<br/> else if (response.status === “not_authorized”) {<br/> console.log(“The person is logged into Facebook, but has not logged into your webpage.”);<br/> }<br/> else {<br/> //unknown status<br/> console.log(“The person is not logged into Facebook, so you don’t know if they have logged into your webpage.”)<br/> }<br/> }</span></pre><p id="55f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果能在浏览器上看到这个方法中发生的事情就太好了。为此，让我们看看我们的登录用户界面。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/5ff79c21f8cbb6753a5a4000f7f74453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*No-HiEgZV9-B3-mKPJTyRQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Unauthenticated Screen</figcaption></figure><p id="cb3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击登录按钮打开一个对话框。这是登录对话框的样子。如果用户喜欢传统的用户名/密码验证，它会有一个用户名和密码字段。否则，有一个继续与脸书按钮，以验证使用脸书。我们将重点关注OAuth2脸书认证，而不是传统的用户名/密码认证。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/20d25125255a12675ab3dd0352715fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1y9FC4pqM8uXVJHVE05lw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Login Dialogue</figcaption></figure><p id="459d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">登录决策模态模板:</strong>我已经单独包含了登录动作的模板。包括注册动作也会造成混乱。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="3911" class="mw mx in ms b gy my mz l na nb">&lt;form class=”form-group form-horizontal” [formGroup]=”<strong class="ms io">loginForm</strong>”&gt;<br/>&lt;div class=”form-group”&gt;<br/>&lt;label class=”col-form-label req”&gt;Username:&lt;/label&gt;<br/>&lt;input type=”text” class=”form-control” <strong class="ms io">formControlName=”username”</strong>&gt;&lt;/div&gt;</span><span id="b34e" class="mw mx in ms b gy nf mz l na nb">&lt;div class=”form-group”&gt;<br/>&lt;label class=”col-form-label req”&gt;Password:&lt;/label&gt;<br/>&lt;input type=”password” class=”form-control” <strong class="ms io">formControlName=”password”</strong>&gt;<br/>&lt;/div&gt;</span><span id="57a3" class="mw mx in ms b gy nf mz l na nb">&lt;div class=”form-group”&gt;<br/>&lt;button [disabled]=”!loginForm.valid”<br/>class=”btn btn-primary btn-block” (click)=”submit(action)”&gt;<strong class="ms io">Submit</strong>&lt;/button&gt;</span><span id="f343" class="mw mx in ms b gy nf mz l na nb">&lt;button class=”btn btn-primary btn-block” (click)=”<strong class="ms io">loginWithFB()</strong>”&gt;&lt;i class=”fab fa-facebook-square”&gt;&lt;/i&gt;<strong class="ms io">Continue with Facebook</strong>&lt;/button&gt;</span><span id="6280" class="mw mx in ms b gy nf mz l na nb">&lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="1f28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">登录决策模态组件</strong></p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="c1a8" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">declare const FB: any;</strong></span><span id="671b" class="mw mx in ms b gy nf mz l na nb">@Component({<br/>selector: 'app-login-decision-modal',<br/>templateUrl: './login-decision-modal.component.html',<br/>styleUrls: ['./login-decision-modal.component.scss']<br/>})<br/>export class <strong class="ms io">LoginDecisionModalComponent </strong>implements OnInit {</span><span id="baa2" class="mw mx in ms b gy nf mz l na nb">public <strong class="ms io">loginForm </strong>= new FormGroup({<br/>username: new FormControl(“”, [Validators.required]),<br/>password: new FormControl(“”, [Validators.required]),<br/>firstName: new FormControl(“”), //for signup<br/>lastName: new FormControl(“”) //for signup<br/>})</span><span id="3f3e" class="mw mx in ms b gy nf mz l na nb">ngOnInit() {<br/><strong class="ms io">FB.Event.subscribe(‘auth.login’, this.fbLogin_event.bind(this));</strong><br/>}</span><span id="1bb1" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">loginWithFB()</strong> {<br/>console.log(“logging in with FB”);<br/><strong class="ms io">FB.login();</strong><br/>}</span><span id="14e8" class="mw mx in ms b gy nf mz l na nb"><strong class="ms io">fbLogin_event(response)</strong> {<br/>console.log(response);<br/><strong class="ms io">this.loginService.setFacebookAuthStatus(response);</strong><br/>this.loginDecision.emit({ action: “fbLogin”, response: response, type: “success” });<br/>this.close(); //closes the dialogue<br/>}</span><span id="1c53" class="mw mx in ms b gy nf mz l na nb">}</span></pre><p id="744d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当引导模式打开时，我们首先订阅一个脸书事件:<strong class="kc io"> auth.login. </strong>每当事件触发时，就会调用<strong class="kc io"> fbLogin_event() </strong>。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="bd81" class="mw mx in ms b gy my mz l na nb">ngOnInit() {<br/><strong class="ms io">FB.Event.subscribe(‘auth.login’, this.fbLogin_event.bind(this));</strong><br/>}</span></pre><p id="993a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户点击<strong class="kc io">继续脸书</strong>按钮时，调用<strong class="kc io"> loginWithFB() </strong>，进而调用<strong class="kc io"> FB.login() </strong>。这将触发一个对话框来继续登录过程。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="07c3" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">loginWithFB()</strong> {<br/>console.log(“logging in with FB”);<br/><strong class="ms io">FB.login();</strong><br/>}</span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/4b907dd880cf024d8704317033bff296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q0DhfCAEoCN5T17-R4MIA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Facebook login dialogue</figcaption></figure><p id="098f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输入用户名和密码并点击<strong class="kc io"> Please login </strong>按钮后，将触发<strong class="kc io"> auth.login </strong>事件，调用<strong class="kc io"> fbLogin_event() </strong>，并记录用户的登录状态，如下图浏览器控制台所示。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="cf03" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">fbLogin_event(response)</strong> {<br/>console.log(response);<br/><strong class="ms io">this.loginService.setFacebookAuthStatus(response);</strong><br/>this.loginDecision.emit({ action: “fbLogin”, response: response, type: “success” });<br/>this.close(); //closes the dialogue<br/>}</span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/2f130dc86026dd0f01b4dfadb0371727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6OUpHGfV37LUIzpnDiBzg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Facebook Authentication Response</figcaption></figure><p id="53a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，响应的结构与我们之前讨论的完全相同。脸书已经提供了访问令牌，我们将使用该令牌在express节点服务器(应用服务器)中生成JWT令牌。用户将使用此JWT令牌与express服务器进行进一步的交互。我们现在将看到这是如何发生的。</p><p id="6965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦记录了响应，我们就调用<strong class="kc io">setfacebooktauthstatus()</strong>将认证响应作为参数传递。我们现在可以详细了解在这种方法中发生了什么。这个方法的定义前面已经提到过了。</p><p id="39d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为响应的status属性是“connected”，所以执行第一个if块。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="6522" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">if (response.status === “connected”) {</strong><br/> this.fb_authenticated=true;<br/> console.log(“The person is logged into Facebook, and has logged into your webpage.”);<br/> <strong class="ms io">this.generateJWTTokenForFB(response.authResponse.accessToken)</strong>.subscribe((data: any) =&gt; {<br/> this.<strong class="ms io">getFacebookUserInfo()</strong>.then(() =&gt; {<br/> this.<strong class="ms io">setUserAuthenticationStatus(true);</strong><br/> })<br/> .catch(err =&gt; console.log(err))<br/> })<br/> }</span></pre><p id="dce1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们调用另一个方法<strong class="kc io"> generateJWTTokenForFB() </strong>传递由facebook生成的访问令牌，以生成JWT令牌。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="8047" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">generateJWTTokenForFB(fbAccess_Token: string) {<br/></strong>const url = <strong class="ms io">`${environment.baseUrl}users/facebook/token?access_token=${fbAccess_Token}`</strong>;</span><span id="199b" class="mw mx in ms b gy nf mz l na nb">return this.http.get(url).pipe(response =&gt; response, catchError(this.handleError));</span><span id="d572" class="mw mx in ms b gy nf mz l na nb">}</span></pre><p id="2f24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们已经看到的，<strong class="kc io"> facebook/token </strong>路由用于验证访问令牌并为将来的交互生成JWT令牌。这个JWT令牌将存储在浏览器上一个安全的httpOnly cookie中。</p><p id="a2ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过脸书的成功认证后，我们在<strong class="kc io"> getFacebookUserInfo() </strong>中调用一个脸书API <strong class="kc io"> /me </strong>来获取用户资料细节并记录下来。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="bb78" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">getFacebookUserInfo</strong>() {<br/> let that = this;<br/> return new Promise((resolve, reject) =&gt; {<br/> FB.api(‘/me’, function (response, err) {<br/> if (err) {<br/> reject(err);<br/> }<br/> else {<br/> console.log(‘Successful login for: ‘ + response.name);<br/> <strong class="ms io">that.setUser();</strong><br/> resolve(true);<br/> }<br/> });<br/> })</span><span id="1dec" class="mw mx in ms b gy nf mz l na nb">}</span></pre><p id="810f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还调用<strong class="kc io"> setUser() </strong>从cookie中提取用户详细信息，即名字、姓氏和管理信息，并通过<strong class="kc io"> user </strong> subject将其传递给组件。该组件将使用这些信息来隐藏/显示基于管理员状态的功能，并在屏幕上显示用户的名字和姓氏。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="fa40" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">setUser() {</strong><br/> let list = document.cookie.split(“;”);<br/> let cookieObj: any = {}<br/> list.forEach(cookie =&gt; {<br/> let trimmedCookie=cookie.trim();<br/> let cookieName = trimmedCookie.trim().substring(0, trimmedCookie.indexOf(“=”));<br/> cookieObj[cookieName] = decodeURIComponent(trimmedCookie.substring(trimmedCookie.indexOf(“=”)+1));<br/> //The purpose of decodeURI is to remove any kind of encoding<br/> })<br/> this.user.next(cookieObj);<br/> }</span></pre><p id="e259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">setUserAuthenticationStatus(true)</strong>将通过subject authenticationCheck将身份验证状态传递给组件。身份验证成功后，该组件进行API调用来检索菜肴的详细信息。</p><pre class="ln lo lp lq gt mr ms mt mu aw mv bi"><span id="e325" class="mw mx in ms b gy my mz l na nb"><strong class="ms io">setUserAuthenticationStatus</strong>(status) {<br/>this.authenticationCheck.next(status);}</span></pre><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/2f1651f45876a3177a217bdaaa673314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iINPGXv2hGC3iy0fTgGw6w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">successful oauth2 authentication</figcaption></figure><p id="528f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！都安排好了。</p><p id="9117" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在下面的链接查看角度和表达代码。</p><p id="b0b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/ramya22111992/coursera_Oauth2.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ramya22111992/coursera_Oauth2.git</a></p><p id="f032" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/ramya22111992/coursera-angular.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ramya22111992/coursera-angular.git</a></p><p id="210b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nm">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nm">plain English . io</em></strong></a></p></div></div>    
</body>
</html>