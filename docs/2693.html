<html>
<head>
<title>Tired of Boring Static Dashboards? Let’s Build a Fully Customizable Dashboard in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">厌倦了枯燥的静态仪表盘？让我们在React中构建一个完全可定制的仪表板</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tired-of-boring-static-dashboards-lets-build-a-fully-customizable-dashboard-in-react-88cb5369cfe1?source=collection_archive---------4-----------------------#2021-06-03">https://javascript.plainenglish.io/tired-of-boring-static-dashboards-lets-build-a-fully-customizable-dashboard-in-react-88cb5369cfe1?source=collection_archive---------4-----------------------#2021-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d5d46fa87ccdecf7338b13b5144e8fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*juz38i4oj7MEVL4tk9j2Ow.gif"/></div></div></figure><p id="4f00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在任何市场搜索仪表板模板，我可以保证您会发现几乎所有的结果看起来都是一样的。顶部有几个指标，底部有两三个图表。没有定制的余地。感觉好过时！我们能做得更好吗？好吧，让我们来看看。</p><h1 id="6a4a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">初始设置</h1><p id="122e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">说到外观，我并不太喜欢材质——UI。但是，总的来说，作为一个设计系统，它是最好的之一。我们将在这个应用程序中使用<a class="ae lw" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>,这样我们就可以在使用Material-UI的预构建组件的同时专注于可定制的仪表板部分。我创建了下面的样板文件让我们开始。它是一个带有Material-UI的基本React应用程序。它非常适合原型开发，如果您想在自己的项目中使用它，可以随意使用它。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/06dd595950fec64d92457bfc68c62ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rrmRrXLIFopNw1g6cyZNzg.gif"/></div></div></figure><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="3ee5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak"> React网格布局</strong></h1><p id="cccd" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将使用<a class="ae lw" href="https://github.com/react-grid-layout/react-grid-layout" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> React网格布局</strong> </a>为我们的应用程序创建小部件。React网格布局是一个可拖动和可调整大小的网格布局，带有用于<strong class="jx io"> React的响应断点。我们可以使用下面的npm命令安装它。</strong></p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="d4e5" class="mj ku in mf b gy mk ml l mm mn">npm install react-grid-layout</span></pre><p id="315a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们使用<strong class="jx io"> React网格布局</strong>时，我们需要从<strong class="jx io">节点模块</strong>文件夹中导入两个<strong class="jx io"> CSS </strong>文件。如果我们想要定制样式，我们可以将这些<strong class="jx io"> CSS </strong>文件中的内容复制到我们的本地样式文件中。</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="e2d2" class="mj ku in mf b gy mk ml l mm mn">/node_modules/react-grid-layout/css/styles.css<br/>/node_modules/react-resizable/css/styles.css</span></pre><p id="af88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用内容组件<strong class="jx io"> </strong>中的<strong class="jx io"> React网格布局报告</strong>的第一个例子来测试一切是否正常。我为每个项目添加了不同的背景颜色，这样在视觉上更容易区分。</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="3818" class="mj ku in mf b gy mk ml l mm mn">import React from 'react';<br/>import GridLayout from 'react-grid-layout';</span><span id="25aa" class="mj ku in mf b gy mo ml l mm mn">export default function Content() {<br/>  const layout = [<br/>    { i: 'a', x: 0, y: 0, w: 1, h: 2, static: true },<br/>    { i: 'b', x: 1, y: 0, w: 3, h: 2, minW: 2, maxW: 4 },<br/>    { i: 'c', x: 4, y: 0, w: 1, h: 2 },<br/>    { i: 'd', x: 0, y: 2, w: 2, h: 2, isDraggable: false },<br/>  ];<br/>  return (<br/>    &lt;GridLayout<br/>      className="layout"<br/>      layout={layout}<br/>      cols={12}<br/>      rowHeight={60}<br/>      width={1200}<br/>    &gt;<br/>      &lt;div key="a"&gt;<br/>        &lt;Widget id="a" backgroundColor="#867ae9" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="b"&gt;<br/>        &lt;Widget id="b" backgroundColor="#fff5ab" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="c"&gt;<br/>        &lt;Widget id="c" backgroundColor="#ffcead" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="d"&gt;<br/>        &lt;Widget id="d" backgroundColor="#c449c2" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/GridLayout&gt;<br/>  );<br/>}</span><span id="5a68" class="mj ku in mf b gy mo ml l mm mn">function Widget({ id, backgroundColor }) {<br/>  return (<br/>    &lt;div style={{ width: '100%', height: '100%', backgroundColor }}&gt;{id}&lt;/div&gt;<br/>  );<br/>}</span></pre><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/7a0faa1f089118afaac4b07a164000a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xCviOAF19eScXQlJ9p5Ecw.gif"/></div></div></figure><p id="d6fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们深入研究一下代码。<strong class="jx io">布局</strong>数组保存所有的初始位置和尺寸值。需要注意的一点是，我们不能使用<strong class="jx io"> CSS </strong>单位，如<strong class="jx io"> px </strong>或<strong class="jx io"> rem </strong>作为位置值。我们需要使用网格单位来代替。网格单位是使用我们提供给<strong class="jx io"> GridLayout的<strong class="jx io"> cols </strong>和<strong class="jx io"> rowHeight </strong>属性计算的。</strong>我们还可以提供一些可选值，如<strong class="jx io"> minW </strong>、<strong class="jx io"> static </strong>、<strong class="jx io">、</strong>和<strong class="jx io">is debragable</strong>，这些值都是不言自明的。</p><p id="e160" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们有了<strong class="jx io"> GridLayout </strong>组件<strong class="jx io">。</strong>它将版面作为<strong class="jx io">道具</strong>，我们也可以在这里指定版面宽度。请注意，在上面的例子中，当我将<strong class="jx io">小部件C </strong>向右拖动时，<strong class="jx io"> </strong>如何返回？这是因为<strong class="jx io"> GridLayout </strong>组件不会占用所有可用的宽度，它只会扩展到我们指定为<strong class="jx io"> prop </strong>的宽度。同样，使用<strong class="jx io"> GridLayout </strong>，我们只能为所有断点指定一个布局。因此，对于响应式使用，我们必须使用来自<strong class="jx io"> React网格布局的适当命名的<strong class="jx io">响应式</strong>组件。</strong></p><h1 id="3bc6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">响应性使用</h1><p id="405c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">因此，让我们使用<strong class="jx io"> React网格布局</strong>中的<strong class="jx io">响应</strong>组件，并且为<strong class="jx io">响应</strong>组件提供宽度，我们可以使用<strong class="jx io"> React网格布局中的<strong class="jx io">宽度提供者</strong>高阶组件。有了<strong class="jx io">响应式</strong>组件，我们可以对每个断点使用多个布局，而不是一个布局。如果我们只提供<strong class="jx io">最大</strong>断点的布局，<strong class="jx io">反应网格布局</strong>将<strong class="jx io">插入</strong>其余断点的尺寸。我们将为"<strong class="jx io"> lg" </strong>断点指定布局，稍后将探索如何为其他断点定制布局并保存它，这样我们就不必一开始就为所有断点设置布局。</strong></p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="b52f" class="mj ku in mf b gy mk ml l mm mn">import React from 'react';<br/>import { Responsive, WidthProvider } from 'react-grid-layout';</span><span id="39aa" class="mj ku in mf b gy mo ml l mm mn">const ResponsiveGridLayout = WidthProvider(Responsive);</span><span id="f10d" class="mj ku in mf b gy mo ml l mm mn">export default function Content() {<br/>  const layouts = {<br/>    lg: [<br/>      { i: 'a', x: 0, y: 0, w: 1, h: 2 },<br/>      { i: 'b', x: 1, y: 0, w: 3, h: 2 },<br/>      { i: 'c', x: 4, y: 0, w: 1, h: 2 },<br/>      { i: 'd', x: 0, y: 2, w: 2, h: 2 },<br/>    ],<br/>  };<br/>  return (<br/>    &lt;ResponsiveGridLayout<br/>      className="layout"<br/>      layouts={layouts}<br/>      breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}<br/>      cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}<br/>      rowHeight={60}<br/>    &gt;<br/>      &lt;div key="a"&gt;<br/>        &lt;Widget id="a" backgroundColor="#867ae9" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="b"&gt;<br/>        &lt;Widget id="b" backgroundColor="#fff5ab" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="c"&gt;<br/>        &lt;Widget id="c" backgroundColor="#ffcead" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div key="d"&gt;<br/>        &lt;Widget id="d" backgroundColor="#c449c2" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/ResponsiveGridLayout&gt;<br/>  );<br/>}</span><span id="2aa6" class="mj ku in mf b gy mo ml l mm mn">function Widget({ id, backgroundColor }) {<br/>  return (<br/>    &lt;div style={{ width: '100%', height: '100%', backgroundColor }}&gt;{id}&lt;/div&gt;<br/>  );<br/>}</span></pre><p id="6a1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在一切似乎都很好。但是当我们关闭抽屉时，小部件不会扩展到剩余的宽度，我们不能移动任何超过先前宽度的东西。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/ebf3b177d230259bdc9bd9f8cee3af46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FGugRup25sauh7LAYu7Wgw.gif"/></div></div></figure><p id="cd86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为正如文件中提到的，</p><blockquote class="mp mq mr"><p id="8ee6" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">WidthProvider非常简单，只监听窗口的“resize”事件。</p></blockquote><p id="8b91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有几个React库可以用来替代<strong class="jx io">width provider</strong>。在这个应用中，我们将使用<a class="ae lw" href="https://github.com/ctrlplusb/react-sizeme" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> react-sizeme。</strong> </a> <strong class="jx io"> </strong>我们可以使用</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="ee8f" class="mj ku in mf b gy mk ml l mm mn">npm install react-sizeme</span></pre><p id="1d60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<strong class="jx io"> react-sizeme </strong>中的<strong class="jx io">和</strong> HOC来为我们的组件提供宽度。</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="c9ba" class="mj ku in mf b gy mk ml l mm mn">import React from 'react';<br/>import { Responsive as ResponsiveGridLayout } from 'react-grid-layout';<br/>import { withSize } from 'react-sizeme';</span><span id="3b1b" class="mj ku in mf b gy mo ml l mm mn">function Content({ size: { width } }) {<br/>...<br/>...<br/>  return (<br/>    &lt;ResponsiveGridLayout<br/>      className="layout"<br/>      layouts={layouts}<br/>      breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}<br/>      cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}<br/>      rowHeight={60}<br/>      width={width}<br/>    &gt;<br/>    ...<br/>    ...<br/>    &lt;/ResponsiveGridLayout&gt;<br/>  );<br/>}</span><span id="58fd" class="mj ku in mf b gy mo ml l mm mn">export default withSize({ refreshMode: 'debounce', refreshRate: 60 })(Content);<br/>...<br/>...</span></pre><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/aec17638be9d283aa0bf7e410dc192d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_z2oDJobIx4U8Tn4IXEtEQ.gif"/></div></div></figure><p id="739d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你仔细观察，你会注意到当抽屉/侧边栏移动时，我们的小部件不会调整大小，只有当抽屉移动完成时才会改变大小。如果将<strong class="jx io">刷新模式</strong>和<strong class="jx io">刷新速率</strong> <strong class="jx io">支柱</strong>从<strong class="jx io">与尺寸夹具</strong>中移除，抽屉移动时尺寸会发生变化。但是我们故意设置了这两个道具，因为以后当我们在小部件上使用图表时，在每一帧上设置动画大小会弄乱图表库的内部动画。</p><h1 id="526d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">保存布局</h1><p id="bbb4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们现在有可调整大小和可移动的部件。让我们看看如何保存布局。为了保存布局，首先，我们需要知道当前布局的配置是什么。到目前为止，我们的<strong class="jx io"> layouts </strong>变量提供了初始布局配置，然后<strong class="jx io"> React Grid Layout </strong>管理它内部的布局更改，我们没有任何东西记录它。在每次布局改变时，<strong class="jx io"> Responsive </strong>组件触发<strong class="jx io"> onLayoutChange </strong>回调，其中<strong class="jx io"> currentLayout </strong>和<strong class="jx io"> allLayouts </strong>作为<strong class="jx io">参数</strong>。我们可以使用这个<strong class="jx io"> allLayouts </strong>值来存储当前布局的配置<strong class="jx io">。</strong></p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="3df5" class="mj ku in mf b gy mk ml l mm mn">...</span><span id="5e6a" class="mj ku in mf b gy mo ml l mm mn">const initialLayouts = {<br/>  lg: [<br/>    ...<br/>  ],<br/>};<br/>function Content({ size: { width } }) {<br/>  const [layouts, setLayouts] = useState(initialLayouts);<br/>  const onLayoutChange = (_, allLayouts) =&gt; {<br/>    setLayouts(allLayouts);<br/>  };<br/>  return (<br/>    &lt;ResponsiveGridLayout<br/>      ...<br/>      onLayoutChange={onLayoutChange}<br/>    &gt;<br/>     ...<br/>    &lt;/ResponsiveGridLayout&gt;<br/>  );<br/>}<br/>...</span></pre><p id="4ce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了当前布局的记录。我们可以将它发送到后端，保存为用户首选项。如果你需要自动保存布局，你可以在<strong class="jx io"> onLayoutChange </strong>函数中创建一个后端请求。否则，您可以等待用户点击按钮或其他事件，然后使用当前布局调用后端API。此外，您可以在组件安装上获取用户偏好的布局。为简单起见，我们将把当前配置保存在本地存储器上。</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="b758" class="mj ku in mf b gy mk ml l mm mn">...</span><span id="20d2" class="mj ku in mf b gy mo ml l mm mn">const initialLayouts = {<br/> ...<br/>};<br/>function Content({ size: { width } }) {<br/>  const [layouts, setLayouts] = useState(<br/>    getFromLS('layouts') || initialLayouts,<br/>  );<br/>  const onLayoutChange = (_, allLayouts) =&gt; {<br/>    setLayouts(allLayouts);<br/>  };<br/>  const onLayoutSave = () =&gt; {<br/>    saveToLS('layouts', layouts);<br/>  };<br/>...<br/>}</span><span id="0ae5" class="mj ku in mf b gy mo ml l mm mn">...<br/>function getFromLS(key) {<br/>  let ls = {};<br/>  if (global.localStorage) {<br/>    try {<br/>      ls = JSON.parse(global.localStorage.getItem('rgl-8')) || {};<br/>    } catch (e) {}<br/>  }<br/>  return ls[key];<br/>}</span><span id="b1eb" class="mj ku in mf b gy mo ml l mm mn">function saveToLS(key, value) {<br/>  if (global.localStorage) {<br/>    global.localStorage.setItem(<br/>      'rgl-8',<br/>      JSON.stringify({<br/>        [key]: value,<br/>      }),<br/>    );<br/>  }<br/>}</span></pre><h1 id="ae71" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">添加和移除小部件</h1><p id="06bc" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">添加和删除项目非常简单。我们需要保存一个选择的项目列表，然后只需要在添加和删除操作中添加或删除列表中的项目。在<strong class="jx io"> ResponsiveGridLayout，</strong>中，我们可以遍历所选项目，只显示那些项目。</p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="d3e6" class="mj ku in mf b gy mk ml l mm mn">..<br/>const originalItems = ['a', 'b', 'c', 'd'];</span><span id="a99c" class="mj ku in mf b gy mo ml l mm mn">...<br/>function Content({ size: { width } }) {<br/>  const [items, setItems] = useState(originalItems);<br/>  ...<br/>  const onRemoveItem = (itemId) =&gt; {<br/>    setItems(items.filter((i) =&gt; i !== itemId));<br/>  };<br/>  const onAddItem = (itemId) =&gt; {<br/>    setItems([...items, itemId]);<br/>  };</span><span id="d2e6" class="mj ku in mf b gy mo ml l mm mn">return (<br/>    &lt;&gt;<br/>      &lt;TopBar<br/>        onLayoutSave={onLayoutSave}<br/>        items={items}<br/>        onRemoveItem={onRemoveItem}<br/>        onAddItem={onAddItem}<br/>        originalItems={originalItems}<br/>      /&gt;<br/>      &lt;ResponsiveGridLayout<br/>        ...<br/>      &gt;<br/>        {items.map((key) =&gt; (<br/>          &lt;div<br/>            key={key}<br/>            className="widget"<br/>            data-grid={{ w: 3, h: 2, x: 0, y: Infinity }}<br/>          &gt;<br/>            &lt;Widget<br/>              id={key}<br/>              onRemoveItem={onRemoveItem}<br/>              backgroundColor="#867ae9"<br/>            /&gt;<br/>          &lt;/div&gt;<br/>        ))}<br/>      &lt;/ResponsiveGridLayout&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="fa87" class="mj ku in mf b gy mo ml l mm mn">...</span></pre><p id="4bf4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我用带有关闭按钮的材质UI卡替换了我们的彩色小部件，并添加了一个弹出窗口来选择小部件。因为它与核心功能无关，所以我没有在这里添加代码。如果你好奇怎么做<em class="ms">可以参考下面的<strong class="jx io"> codesandbox </strong>。</em></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/56538dd5a11b0121f34224285b1edef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*idUk7fzri-U5xoNn4J7f5w.gif"/></div></div></figure><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="cef1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">自定义小部件</h1><p id="6144" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">就是这样。我们有一个完全可定制的仪表板。您可以自由地用您喜欢的任何组件填充小部件。这是一个CodeSandbox示例，我添加了几个来自<a class="ae lw" href="https://recharts.org/en-US/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"/></a><strong class="jx io">的图表。</strong></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/69d134d55900ae984c7303f86c9ec8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fv6lWG99A-UjL9r2I8R9aQ.gif"/></div></div></figure><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="4faf" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">结论</strong></h1><p id="f1f6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">就像我在图表示例中展示的那样，您可以将任何组件作为小部件添加。唯一的问题是，根据您添加的内容，您可能需要调整<strong class="jx io"> CSS </strong>和其他属性，以便在调整小部件大小时您的内容能够响应。这就是本教程的内容。希望你喜欢。</p><p id="b55b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ms">更多内容请看</em><a class="ae lw" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ms">plain English . io</em></a></p></div></div>    
</body>
</html>