<html>
<head>
<title>An Easy Introduction to IndexedDB in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器中IndexedDB的简单介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/indexeddb-cfb55e3e26d8?source=collection_archive---------10-----------------------#2021-09-14">https://javascript.plainenglish.io/indexeddb-cfb55e3e26d8?source=collection_archive---------10-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef7c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">添加、获取和删除数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/422999adab833083a0c93978fda05074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0zghBaNvPlDu97RkJiDdQ.png"/></div></div></figure><p id="2039" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你肯定知道本地存储和饼干。两者都允许我们在浏览器中永久保存数据。然而，这两个特性都基于键值对方法。假设我们想要保存一个用户的年龄，我们将使用用户名或ID作为键——值就是年龄本身。</p><p id="5a8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这对于存储更结构化的数据很有用，但不是最佳选择。结构化数据？浏览器支持我们。然而，所谓的索引数据库并不像cookies和本地存储那样流行。是时候更详细地了解这个经常被误解但功能强大的特性了——是时候开始使用IndexedDB了。</p><h1 id="b31a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">IndexedDB是如何工作的？</h1><p id="7757" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">正如我之前所说，IndexedDB不是键值对存储。顾名思义，它可能与指数有关——事实也的确如此。数据库系统允许我们保存通过索引识别的对象。</p><p id="6470" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们直接看一个例子。IndexedDB数据库的结果结构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/6b5b1c9888b57fbf9d2bc95a9187e8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHXZx2shC_9x86-4FD3C1w.png"/></div></div></figure><p id="5f3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们用相同的键存储了三个JavaScript对象——虽然键的值不需要唯一，但id必须唯一。</p><p id="3654" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在浏览器中运行这个例子。</p><h1 id="a124" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">IndexedDB入门</h1><p id="1918" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">IndexedDB在浏览器中的<code class="fe ml mm mn mo b">window</code>对象上可用。然而，使用它比使用本地存储或cookies更难。一个重要的区别是，我们通过连接访问数据库，并且有特定的事件。我们将在实践中看到这一点:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="9f17" class="mt lo iq mo b gy mu mv l mw mx">let db<br/>const dbConnection = indexedDB.open('Database', 1)</span></pre><p id="3b70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们定义一个全局变量“db”。通过这个变量，我们将在不同事件的范围内访问数据库本身。如果数据库已经存在，<code class="fe ml mm mn mo b">open </code>函数将打开名为“database”的数据库。如果它不存在，函数将创建它。第二个参数，即“1”，是版本。现在，我们保留这个值，因为版本控制是一个更复杂的主题。</p><p id="fe0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能注意到了，到目前为止，我们没有给全局“db”变量赋值。这就是事件发生的地方。数据库连接<code class="fe ml mm mn mo b">dbConnection</code>知道多个事件。当数据库首次创建或版本号更改时，将触发“需要升级时”事件。因为我们没有触及版本号，所以现在，在创建数据库时运行以下代码:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="ea39" class="mt lo iq mo b gy mu mv l mw mx">dbConnection.onupgradeneeded = (event) =&gt; {}</span></pre><p id="358c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在arrow函数内部，我们分配给事件，我们提供建立数据库所需的代码。到目前为止，只设置了数据库的名称。</p><p id="1c38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个IndexedDB数据库可以保存多个所谓的对象存储。您可以将对象存储想象成SQL中的一个表。本文旨在为用户创建一个表—包含ID、姓名和用户年龄的字段。</p><p id="3456" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是设置它的代码。我会引导你通过它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5f1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我所说的，我们在函数中提供的代码在创建数据库时运行。我们做的第一件事是将DB赋给全局变量。然后，用<code class="fe ml mm mn mo b">createObjectStore</code>我们创建一个你可以想象的类似表格的东西——“用户”是它的名字，我们命名需要提供“id”的索引字段。</p><p id="621c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦创建了表，就会触发相关的“oncomplete”事件——在我们提供的函数中，我们创建了第一个数据库条目。为了使事情尽可能复杂，我们调用表上的事务函数，将其保存在一个变量中，最后通过这个变量添加一个条目。我们提供的id由我们自己决定—我们只是强迫自己使用“id”作为数据库的必要索引。</p><p id="d554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，整个代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9bbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果在浏览器中运行代码，可以看到创建并填充的数据库。打开Chrome开发工具中的“应用程序”标签，转到“存储”部分，打开IndexedDB:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/54033f2cb554ce83f30702fd2a64b569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_lzqdEUv-EMVD21RzfLMA.png"/></div></div></figure><p id="0a0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，一切顺利——但是剧透一下，有一个问题。</p><p id="cf82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得全局“db”变量吗？我们需要它来访问所有代码的数据库。在事件函数中，我们将实际的数据库分配给它。问题:“onupgradeneeded”只运行来创建数据库。由于它是永久存储，重新加载页面不会创建新的数据库。因此，“onupgradeneeded”不会被执行，全局“db”变量仍未定义。</p><p id="22d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，听起来很复杂，抱歉。总结一下这个问题:我们需要一个在数据库已经存在时触发的数据库连接事件:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="d757" class="mt lo iq mo b gy mu mv l mw mx">dbConnection.onsuccess = (event) =&gt; {<br/>  db = event.target.result<br/>}</span></pre><p id="b316" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为在这种情况下已经建立了数据库，所以我们只需要将DB赋给变量。现在，重新加载页面工作得很好——在第一次加载时，建立了只有一个条目的数据库，在每次重新加载时，不会改变数据库。</p><p id="2b0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是目前为止的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="3b07" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">添加、删除和获取数据库条目</h1><p id="7703" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为了将用户添加到“users”表中，我们创建了一个名为“addUser”的函数。让事情变得更复杂的是，我们在分配给变量的表上实例化一个事务。通过这个变量，我们将数据添加到表中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ea60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您运行这个函数时，请记住传递一个惟一的id —例如，“user-2”。最后，您需要在Application选项卡中刷新数据库以查看更改。</p><p id="5c22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们看看如何从IndexedDB中检索对象:</p><p id="b5e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">和以前一样，我们使用事务函数来访问数据库。我们的函数通过ID检索相关对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="93c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行该函数，我们得到相关的JavaScript对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/510e7490f4494464226747d57362f67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfnT59SVlLvGSYWhhjfBsw.png"/></div></div></figure><h2 id="8ab1" class="mt lo iq bd lp nc nd dn lt ne nf dp lx la ng nh lz le ni nj mb li nk nl md nm bi translated">从索引中删除某些内容b</h2><p id="95a5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">最后但同样重要的是，让我们去掉一些条目。要删除一个用户，类似于获取一个用户，我们使用它的id。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5ec8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会注意到，我们只是增加了从数据库获取用户的代码——事实上，我们使用了一个“请求”变量，并监听它以获得成功。这在获取数据时是必要的，但是对于删除和添加数据，我们也可以使用这样的请求。它使我们能够在交易完成后执行代码。作为最后一个简单的例子，我们可以很容易地重写删除函数来使用请求。然后，当删除事务完成时，它将console.log:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7f02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>