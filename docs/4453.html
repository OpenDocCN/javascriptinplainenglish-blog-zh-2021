<html>
<head>
<title>Write Decentralized Applications in JavaScript — Libp2p Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写分散式应用程序— Libp2p基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-decentralized-applications-in-javascript-libp2p-basics-4fa46c5dae8a?source=collection_archive---------3-----------------------#2021-09-05">https://javascript.plainenglish.io/writing-decentralized-applications-in-javascript-libp2p-basics-4fa46c5dae8a?source=collection_archive---------3-----------------------#2021-09-05</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><figure class="gm go jm jn jo jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj jl"><img src="../Images/9b967cdf8abce861214dcf92640aeb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AuA85p_yVe-6lZYTw9K_A.png"/></div></div><figcaption class="jw jx gk gi gj jy jz bd b be z dk">Source: <a class="ae ka" href="https://discuss.libp2p.io/" rel="noopener ugc nofollow" target="_blank">https://discuss.libp2p.io/</a></figcaption></figure><p id="8970" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated"><a class="ae ka" href="https://libp2p.io/" rel="noopener ugc nofollow" target="_blank"> Libp2p </a>是最著名的p2p图书馆之一。它是<a class="ae ka" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank">星际文件系统</a>的基础，也将是<a class="ae ka" href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md" rel="noopener ugc nofollow" target="_blank">以太网2.0 </a>的基础，所以如果您想开发分散的应用程序，这是一个很好的选择。</p><p id="20fa" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">在本文中，我将展示libp2p的基本概念，我们将使用libp2p和vue.js的JavaScript实现开发一个基于浏览器的(不需要自己的服务器)聊天应用程序。</p><h2 id="471b" class="kz la io bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">PeerId</h2><p id="70e1" class="pw-post-body-paragraph kb kc io kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky ih bi translated"><a class="ae ka" href="https://docs.libp2p.io/concepts/peer-id/" rel="noopener ugc nofollow" target="_blank"> PeerId </a>是libp2p的主要元素之一。它有点像比特币或以太网地址，由密钥的公钥部分生成。像比特币地址一样，它是唯一的，可以通过私钥对消息进行签名，私钥可以通过与peerId关联的公钥进行验证。您可以通过<a class="ae ka" href="https://www.npmjs.com/package/peer-id" rel="noopener ugc nofollow" target="_blank">对等id </a>实用程序生成一个peerId。</p><p id="5b51" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">您可以通过npm简单地安装对等id:</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="e2fc" class="kz la io mc b gz mg mh l mi mj">sudo npm i peer-id -g</span></pre><p id="cf1a" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">安装后，您只需通过对等id CLI工具生成自己的对等id:</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="579c" class="kz la io mc b gz mg mh l mi mj">peer-id<br/>{</span><span id="a9a3" class="kz la io mc b gz mk mh l mi mj">“id”: “QmPMKmmRyepsh4Wq24msEdeGJQWSszy7eWNSjL53bxz3sS”,</span><span id="4535" class="kz la io mc b gz mk mh l mi mj">“privKey”: “CAASqAkwggSkAgEAAoIBAQC6/4DQXtW9HYbx5wPNbcsNbwMITH8Mg70O+zhQ9t9w/9Z7BuOzwQqu/ABaRclkl1FIuGfIayKSzqkczYkdY3I6bMUtn8dyHuJi1JzJj5PtaGfK81ra6hNvkVRqttYKJdgpPdGWCa6ouRbFPf3l0w2sK0ejf1Im/h4bAL1ltgZK7G+fXZTlUdAoEvQJja3bl9b47zqWiq+oVaez7uBhemrJQ6Ao09Tlr/RpVfbsc48NAczuDqh9nZzUq27LQEu9OXOf6xk/hPaDcof0ubQs9REXDCcDq01Cg6dQ5odKKHcT9hTeytZlvzfZZgleU8pME9r1EVpG5aEMn5qC0zfoe3PTAgMBAAECggEAWBoa+ZFEyHYJ5xy9WOMaoLilyBoqXZ4Py+gmj1bQzS9sQMhtLXqM6waFsAJjMUZtoIJpOy7muh4t5QkdScBZyBcJC0bVM/pDFOcw+3Hu8xKWnDLtomhYQd9J04FS9LMB1eRvQ25KYOnbRZDAd7BpJ624cdqBvSdKzdQaZ7pL2q4d/P1DUVLVfNDHzHlHyiLoxL1Ilm5YQtGGA3PwTLmSMqWGPvrzK4n0qL2rXUMbio0wf7w3lWDnBNQpncwdcPqUSTPDItwa2GNImH5yZRIF/vP2Qdky7LvNoxIzr+UhyQ6s2YSfRLwgnSPNL4IRuRaUWCtFprdaMd/x65xkBDVP2QKBgQDqXV922hbpMWgGPUco0uv7C8UApWiA/TP95pDzJuoD/SL0pn15QQrPMYTbOf32DrwC/sVMuuIbStqJd8RSApTsQO48KiPgmJM6WgD35umlYpmPQh8djvhPTe3nCadoxy+40i7NuuDde9AtvDlqwti4t1E/6lnYNZecbrXnT3ELZwKBgQDMQryboWcrUS+pfrJADtNiBOBtAAIQz7aHZRmk9ZFY7L8ekSB1Cuee4/FXswkrie+jE1rGbV97OQ1f6qW10SkoN64OIs8AVx408MxLdEejLg0vLwjEqEVXE2Wc1/TkOuEOpsrniKgisIZThrdC2RhmOqtaKRnAWz761ypCluP8tQKBgQCzqzV+Zh9eUpQPBHdDIr/qS9GRdz0wdeyf31yMK+8Hc86Sg/h5NpXU1X+mmUTKl+0m1q3m7vZcOfxjmr+Up4oHvJdm5F9w1Uc5WrqXUh0Yvwg+PVChVnOiSHnzvwDqYJmDNQ7QhU3SPhMQnNXftNR0d4UAXObXy+4Y7P7i/5IITQKBgQCtIxh6Frq7lep/kjwHXknA+P8+hVY658YBSCoPkHOuW6a4gy1u6FpibTZCLyjjtdzhbuNv9H+NlFOI7P2fevaW93Na2hh6Yl3hZAbXIm4inENirkyRXUzBPVjRNKCI4HuqDqlIzqYuGVES9crbJ+etp6ddGh+Q1AczWjShEwOXTQKBgF2cuW8w7ghAXapb2BKQU9bZTMAevohw6cxEmajNngVGSGMQJIJdhEoaGUXdtBOpOxAfYdycegf9VkPraVERXAbCMDk5mAh4Aor1SsHUDnQ7VKMLQfGzH3Jfk2TpXqy/11rJlLAl05LCyAeHGLVM4CQrvpLOIeM5n6j/3QWO3Jdh”,</span><span id="7375" class="kz la io mc b gz mk mh l mi mj">“pubKey”: “CAASpgIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6/4DQXtW9HYbx5wPNbcsNbwMITH8Mg70O+zhQ9t9w/9Z7BuOzwQqu/ABaRclkl1FIuGfIayKSzqkczYkdY3I6bMUtn8dyHuJi1JzJj5PtaGfK81ra6hNvkVRqttYKJdgpPdGWCa6ouRbFPf3l0w2sK0ejf1Im/h4bAL1ltgZK7G+fXZTlUdAoEvQJja3bl9b47zqWiq+oVaez7uBhemrJQ6Ao09Tlr/RpVfbsc48NAczuDqh9nZzUq27LQEu9OXOf6xk/hPaDcof0ubQs9REXDCcDq01Cg6dQ5odKKHcT9hTeytZlvzfZZgleU8pME9r1EVpG5aEMn5qC0zfoe3PTAgMBAAE=”</span><span id="0767" class="kz la io mc b gz mk mh l mi mj">}</span></pre><p id="c8b7" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">调用peer-id将生成一个JSON，该JSON包含私钥和公钥，id是一个多哈希公钥。此id是您唯一的对等地址。</p><h2 id="9cba" class="kz la io bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">多重散列</h2><p id="5f11" class="pw-post-body-paragraph kb kc io kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky ih bi translated"><a class="ae ka" href="https://docs.libp2p.io/reference/glossary/#multihash" rel="noopener ugc nofollow" target="_blank"> Multihash </a>是libp2p和IPFS使用的一种面向未来的哈希格式。它由两部分组成。前2个字符是定义哈希算法的哈希头，第二部分是哈希本身。在上面的例子中(在peerId JSON的id部分)，Qm表示它是一个SHA-256哈希，第二部分是base58编码的256位哈希。</p><h2 id="2984" class="kz la io bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">多地址</h2><p id="b877" class="pw-post-body-paragraph kb kc io kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky ih bi translated"><a class="ae ka" href="https://docs.libp2p.io/reference/glossary/#multiaddr" rel="noopener ugc nofollow" target="_blank">多地址</a>类似于一个HTTP URL，但是它更通用。多地址是可以指向主机、服务、对等体等的协议/值对的列表。让我们看看一些例子:</p><p id="fd2d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">/ip4/1 . 2 . 3 . 4-此多地址指向一台主机</p><p id="96bc" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">/ip4/1.2.3.4/tcp/80 —这指向主机的tcp端口80</p><p id="569d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">/DNS 4/example . com/udp/123-这指向example.com的UDP端口123</p><p id="7ccf" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">/P2P/qmbekwsuzandmwjffgyq8 uaqrmkjasat 8 vagockv1x—这指向一个peerId</p><p id="42f2" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">/ip4/7 . 7 . 7 . 7/tcp/4242/P2P/qmyyqso 1 C1 ym 7 orwxlyvcrrm 2 emxftanf8 wxmme 7 dwjhx5n—此多地址准确地指向一个主机和一个TCP端口，我们可以在此端口与给定的对等方通信</p><p id="0ce5" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在我们知道了基础知识，让我们继续实现。Libp2p是一个模块化的网络堆栈，有许多实现。在本文中，我将使用可以在node.js或您的浏览器中的服务器端运行的JavaScript实现。让我们看一些代码来理解js-libp2p是如何工作的:</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="f403" class="kz la io mc b gz mg mh l mi mj">‘use strict’<br/>const Libp2p = require(‘libp2p’)<br/>const TCP = require(‘libp2p-tcp’)<br/>const { NOISE } = require(‘@chainsafe/libp2p-noise’)<br/>const createNode = async () =&gt; {<br/>  const node = await Libp2p.create({<br/>    addresses: {<br/>      listen: [‘/ip4/0.0.0.0/tcp/4321’]<br/>    },<br/>    modules: {<br/>      transport: [ TCP ],<br/>      connEncryption: [ NOISE ]<br/>    }<br/>  })<br/>  await node.start()<br/>  return node<br/>}</span></pre><p id="567d" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">上面的例子展示了如何启动一个libp2p节点。Libp2p.create方法在这里有两个选项。第一个是节点将监听的地址。在这种情况下，节点将监听每个IP地址和4321端口。第二个选项是模块的定义。Libp2p是一个强模块化的堆栈。每个模块都由一个接口定义，你可以自由选择使用哪个，或者你可以创建自己的模块。堆栈的每个部分都是模块化的。您可以定义传输层、加密，您可以定义自己的对等点发现机制，等等。在这种情况下，我们将使用TCP传输和噪声加密。</p><p id="05b8" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">上面的代码在node.js中运行良好，但是在web浏览器中，不可能打开服务器端口。为了解决这个问题，libp2p可以使用中继服务器，中继服务器可以打开所需的服务器端口，并将流量转发到浏览器。</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="b761" class="kz la io mc b gz mg mh l mi mj">this.libp2p = await Libp2p.create({<br/>  addresses: {<br/>    listen: [<br/>     "/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star",<br/>     "/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star",<br/>    ],<br/>  },<br/>  modules: {<br/>    transport: [Websockets, WebRTCStar],<br/>    connEncryption: [NOISE],<br/>    streamMuxer: [Mplex],<br/>    peerDiscovery: [Bootstrap],<br/>    dht: KadDHT,<br/>  },<br/>  config: {<br/>    peerDiscovery: {<br/>      [Bootstrap.tag]: {<br/>      enabled: true,<br/>      list: [<br/>"/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",<br/>"/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",<br/>"/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",<br/>"/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",<br/>"/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",<br/>      ],<br/>      },<br/>    },<br/>    dht: {<br/>      enabled: true,<br/>    },<br/>  },<br/>});</span></pre><p id="45cc" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这个更复杂的示例使用wrtc-star1.par.dwebops.pub和wrtc-star2.sjc.dwebops.pub服务器作为通过webrtc协议的中继。这些服务器是由libp2p社区提供的，仅用于测试。如果你正在构建一个真实世界的应用程序，你应该<a class="ae ka" href="https://github.com/libp2p/js-libp2p-webrtc-star/blob/master/DEPLOYMENT.md" rel="noopener ugc nofollow" target="_blank">安装你自己的webrtc star服务器</a>。</p><p id="0d33" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">另一个新事物是引导节点。这些节点是对等点发现的起点。当您的节点启动时，它将首先连接到这些节点。在连接之后，我们的节点将获得也连接到引导节点的其他节点地址，并且它将连接其中一些节点，因此在引导之后，不再需要引导节点，p2p网络自动构建。示例中的引导节点也是由libp2p社区提供的。通过定义不同的引导节点，您可以定义自己的独立p2p网络。</p><p id="e181" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">我最后想说的是DHT。<a class="ae ka" href="https://en.wikipedia.org/wiki/Distributed_hash_table" rel="noopener ugc nofollow" target="_blank">分布式哈希表</a>是存储在节点上的分布式键/值存储。这个键/值存储用于存储peerId的当前互联网地址。它有点像DNS系统，DNS服务器存储域名的IP地址。DNS也像DHT一样是分布式的，但是在这种情况下，我们使用peerId代替域，使用端点的多地址代替IP。</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="7747" class="kz la io mc b gz mg mh l mi mj">let peerId = PeerId.parse(this.otherPeerId);<br/>let result = await this.libp2p.peerRouting.findPeer(peerId);<br/>this.otherPeerMultiaddrs = result.multiaddrs;</span></pre><p id="035b" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">上面的例子说明了，如何通过peerId找到一个对等体。peerRouting模块的findPeer方法试图通过peerId发现对等体，如果找到了，则多地址将出现在结果中。</p><p id="1935" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在，我们可以在浏览器中启动自己的节点，并找到其他对等点。下一步是与他们沟通。</p><p id="5306" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">首先，我们必须定义一个协议并处理传入的连接。这有点像在传统客户机-服务器应用程序中打开服务器端口。</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="495e" class="kz la io mc b gz mg mh l mi mj">this.libp2p.handle('/chat/1.0.0', <br/>  ({ connection, stream, protocol }) =&gt; { <br/>    this.remotePeerId = connection.remoteAddr.getPeerId(); <br/>    pipe( <br/>      stream, <br/>      (source) =&gt; { <br/>        return (async function* () { <br/>         for await (const buf of source) <br/>           yield array2str(buf.slice()); <br/>        })(); <br/>      }, <br/>      async (source) =&gt; { <br/>       for await (const msg of source) { <br/>        this.messages.push(“&gt; “ + msg); <br/>       } <br/>      } <br/>    ); <br/>});</span></pre><p id="a733" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">上面的代码定义了“chat/1.0.0”(这是协议的标准格式)协议，并处理到它的传入连接。处理函数有3个参数，其中2个。是最重要的，来流。JavaScript流是非常棘手的事情，但是希望有一些好的工具来处理它们。在本例中，我们使用了管道函数。管道的第一个参数是流，最后一个参数是消费者。中间的参数可以是流转换器。在我们的例子中，我们通过array2str函数转换流元素，因为流是二进制的，我们需要简单的UTF8字符串。最后一个函数(消费者)只是从流中读取消息并将它们写出来。</p><p id="febb" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在我们在浏览器中有了可以互相查找的节点，并且我们有了一个聊天协议处理器。最后一步是从一个对等体连接到另一个对等体，并在聊天协议上发送一些消息。</p><pre class="lx ly lz ma gu mb mc md me aw mf bi"><span id="1c85" class="kz la io mc b gz mg mh l mi mj">const { stream, protocol } = await this.libp2p.dialProtocol( <br/>  peerId, chatProtocol <br/>); <br/>this.chatQueue = pushable(); <br/>pipe( <br/>  this.chatQueue, <br/>  (source) =&gt; { <br/>    return (async function* () { <br/>      for await (const msg of source) yield str2array(msg); <br/>    })(); <br/>  }, <br/>  stream <br/>);</span></pre><p id="cc54" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">Libp2p有一个dialProtocol方法用于连接其他对等点。该方法有两个参数。目标peerId和协议标识符。方法的结果是一个流，所以我们再次使用管道函数。管道的第一个参数是可推送的。Pushable是一个可以作为流读取的队列。我们会将聊天消息推送至该队列。管道的第二个阶段是一个转换器，它调用str2array将字符串消息转换为二进制形式。管道的最后一级是流本身。</p><p id="427f" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">让我们看看完整的代码。我用的是Vue，因为它简洁易读。</p><figure class="lx ly lz ma gu jp"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="02c2" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">可以在<a class="ae ka" href="https://thebojda.github.io/js-libp2p-browser-chat/index.html" rel="noopener ugc nofollow" target="_blank">https://thebojda . github . io/js-libp2p-browser-chat/index . html</a>上在线测试。在2个浏览器选项卡上打开此URL。将一个选项卡的peerId复制到另一个选项卡，然后按“查找”按钮。如果一切顺利，浏览器节点将在其他选项卡中找到另一个节点。然后按下“拨号协议”按钮，您就可以开始在两个选项卡之间聊天。</p><p id="480a" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">Libp2p是很多p2p应用的基础。我希望这个简短的介绍能帮助你开始开发自己的p2p应用程序(也许是一个新的共享经济应用程序，或者是你自己的新区块链)。所以，让我们开始编码吧…</p><p id="46d7" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated"><em class="mn">更多内容尽在</em><a class="ae ka" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>