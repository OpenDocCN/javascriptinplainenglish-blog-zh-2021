<html>
<head>
<title>JonScript: a better JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JonScript:更好的JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/jonscript-a-better-javascript-a7ebe55707b9?source=collection_archive---------1-----------------------#2021-04-06">https://javascript.plainenglish.io/jonscript-a-better-javascript-a7ebe55707b9?source=collection_archive---------1-----------------------#2021-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="523c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我创造了自己的JavaScript替代语言。</h2></div><h1 id="36a1" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">介绍</h1><p id="5226" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">你好！你喜欢JavaScript吗？如果没有，请不要点击离开。作为一名JS开发人员，当你不得不使用它时，我理解你的痛苦，我想我可能有一个解决方案:一种编译成JavaScript的新语言！我知道这种说法本身已经成为一种迷因，经常被开发者模仿。但是，听我说完:这一次，可能会有所不同。</p><p id="d9ff" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我想你可能听说过JS开发出错的恐怖故事。这些恐怖故事已经遍布整个编程世界，并催生了许多让我们JS开发人员笑而不哭的模因:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/bf9a7b8f843736c7d17f4f3e496c0324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XSLtjn3brfpMgMKr"/></div></div></figure><p id="5db9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="mh">来源:</em><a class="ae mi" href="https://dev.to/damxipo/javascript-versus-memes-explaining-various-funny-memes-2o8c" rel="noopener ugc nofollow" target="_blank"><em class="mh">https://dev . to/damxipo/JavaScript-vs-memes-explaining-variable-滑稽-memes-2o8c </em> </a></p><p id="8240" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">另一方面，JavaScript是世界上最流行的语言，而且已经流行了一段时间。它是web开发的主干，有许多令人惊叹的特性，以及各种各样的框架和扩展。这种流行的最重要的原因是JS与网络浏览器的紧密联系。在无处不在的网络应用时代，运行在网络浏览器中的语言必然会流行起来。当然，JS持续流行的另一个重要原因是它已经存在的用户群:人们使用JS是因为它受欢迎。</p><p id="6554" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">而且有些人气甚至是赚来的！例如，JS是一种很好的原型语言。如果你想坐下来写一个快速的应用程序来测试一个想法，JS将为你工作。它还增加了许多简洁的函数式编程特性，使许多常见类型的样板模式消失了。还有一个由有用的包和框架组成的完整生态系统，使web开发变得更加容易。</p><p id="c29b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">所以有理由不讨厌它。</p><p id="1e8e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">但是有很多理由讨厌它。让我们一个一个地检查大的。</p><p id="0bbf" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">一个。做同一件事有太多的方法。我能说出两三种创建对象的方法，三种定义变量的方法，三四种定义函数的方法。种类繁多可能会让人不知所措，但是一个有经验的开发人员可能会说:<em class="mh">“但是这些只是细节！我们应该关注代码做了什么，而不是语法“</em>”。然而，事情并没有那么简单。</p><p id="dbe9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">不仅仅是语法上的差异，在运行时还有实际的、微妙的和危险的差异。对我来说，它们基本上是一种引入微妙但重要的错误的机制。但不要相信我的话，互联网上到处都是试图帮助人们应对这些变化的帖子。<em class="mh"> ⁰ </em></p><p id="debc" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">两个。标准库不一致。有很多例子，但是考虑一下如何使用JavaScript的Date类来表示2021年4月1日。大概是这样的，对吧:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="fc2e" class="mo kd in mk b gy mp mq l mr ms">new Date(2021, 4, 1)</span></pre><p id="df9d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">不，当然不是。这显然是5月1日，因为月份(只有月份)是零索引的。甚至写它的人也洗手不干了。<em class="mh">“嗯，其实”</em><em class="mh">我已经听你说过了，“这是有原因的。程序员用这样的方式来表示月份是一个由来已久的传统。毕竟，月份实际上不是一个数字，它只是一个枚举类型的数字表示。这里，看看POSIX localtime。”也许这是我们应该摒弃的有害传统之一。</em></p><p id="374d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">三个。不是数字就是数字。当您执行与数字相关的无效操作时，结果可能是<em class="mh"> NaN </em>。如果您尝试对这样的值进行类型检查，它的行为就好像它是一个常规数字一样。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="b067" class="mo kd in mk b gy mp mq l mr ms">typeof NaN === “number” // is true</span></pre><p id="04e2" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">它像数字一样相加，像数字一样相除，更重要的是，它像数字一样打印和连接(有时)。但是你不想让“<em class="mh"> NaN% </em>”出现在你的网站上。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mt"><img src="../Images/86756d3cd8ebfd05172f0d3281a85cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iyk_Cu3FAo7jndMR"/></div></div></figure><p id="812a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="mh">来源:</em><a class="ae mi" href="https://www.pse.cz/en/detail/CZ0009004792" rel="noopener ugc nofollow" target="_blank"><em class="mh">https://www.pse.cz/en/detail/CZ0009004792</em></a><em class="mh">，布拉格证券交易所网站</em></p><p id="dcf9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">没有它，JS开发人员会过得更好。</p><p id="5b34" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">四个。有很多很多奇怪的语义。例如，与所有数学定律相反，一个JS对象既不同于另一个相同的对象，同时又大于等于和小于等于它。<em class="mh">“但是！”</em>你可能会说<em class="mh">“数学是一回事，但是这些符号在JavaScript中并不意味着它们在数学中的相同操作。如果你读过标准中对这些操作的描述，就会明白了。”</em>但是⁴有很多这样的陷阱，我们不能指望每个人都能马上发现它们，尤其是对JavaScript新手来说。</p><p id="1586" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">五个。课程并不像它们看起来的那样。ES6给语言增加了几个关键词。其中一个是<em class="mh">级</em>。这是因为这种语言需要更受新开发人员的欢迎。</p><p id="de6a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">但这是一把双刃剑⁷.当开发人员看到单词class时，他们会做出几个隐含的假设。其中最重要的是:方法不能重定义，对象不能在运行时改变类，类没有动态生成的属性。这就是Java、C++、Python和其他他们可能熟悉的语言中类的工作方式。</p><p id="943c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">但是在JS中，这些假设是不正确的。JavaScript没有基于类的继承系统。JavaScript使用它自己版本的原型继承，⁸，这允许更多的灵活性，但是很容易被误解。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="c91d" class="mo kd in mk b gy mp mq l mr ms"><em class="mh">class Bitcoin {<br/> constructor(value) {<br/>    this.value = value;<br/> }<br/> valueOf = () =&gt; this.value;<br/>}</em></span><span id="e04d" class="mo kd in mk b gy mu mq l mr ms"><em class="mh">// Define another public function<br/>Bitcoin.prototype.next = function() { return this.value * 2; }</em></span></pre><p id="7819" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这看起来像一个带有公共函数的类定义，对吗？</p><p id="0ffd" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">假设这是一个类，你会认为这个定义是不可变的，对吗？</p><p id="bbad" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这些假设最终可能会破坏一个新的JS devs应用程序——因此导致许多令人头疼的问题。</p><h1 id="bcbc" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我和其他人</h1><p id="7ee4" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">好吧，但也许只是我。也许成为一名JavaScript专家意味着毫不费力地在这些危险的浅滩中航行，所有真正高级的JavaScript开发人员都会觉得我的反对很奇怪。幸运的是，我碰巧和一些专业的JavaScript开发人员一起工作，他们的简历很长，令人印象深刻，所以我问了他们。</p><p id="a7eb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我用12个问题做了一个测试，检查对语义的理解，每个问题都是为开发人员设置的一个狡猾的陷阱。这是一个选择题，每个问题有三个可能的答案，其中一个是正确的。这些问题给出了代码示例，并要求受害者参与者解释JavaScript及其标准库的语义。参与者有无限的时间来回答每个问题。这里有一个问题示例:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="4de5" class="mo kd in mk b gy mp mq l mr ms">If `window` has 222 properties, what is the value of variable `c` after executing:<br/> <br/> console.log(t); const c = Object.keys(window).length; var t = 1;</span></pre><ol class=""><li id="174e" class="mv mw in kw b kx lq la lr ld mx lh my ll mz lp na nb nc nd bi translated"><em class="mh">未定义</em></li><li id="aafb" class="mv mw in kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><em class="mh">第222章</em></li><li id="ee46" class="mv mw in kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><em class="mh"> 223 </em></li></ol><p id="e9bc" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">你可以在这里看到所有的问题——<a class="ae mi" href="https://ivlv.me/kNgHW" rel="noopener ugc nofollow" target="_blank">https://ivlv.me/kNgHW</a>以及它们背后的推理。你也可以试着回答这些问题。(但不准作弊！)当然，这不是最科学的研究，但我认为结果很能说明问题。</p><p id="e01f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">最高分是12分中的7分，其他都低于4分。来自我的小型焦点小组的结果表明，即使是有经验的JavaScript开发人员也很难区分语言原语、它们的类副本、执行上下文相关的函数、日期和对象类的行为、<em class="mh">类型的</em> ⁵和<em class="mh">实例的</em> ⁶操作符等等。</p><p id="a362" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">因此，即使是经验丰富的JavaScript猴子也总是出错。这重要吗？也许这些奇怪的情况不会经常出现，这只是一些琐事，但这些微妙之处似乎会导致现实世界的错误(我可以再次指出布拉格证券交易所)。</p><p id="cf76" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">链接:<a class="ae mi" href="http://www.ece.ubc.ca/~frolino/docs/js_bugs_study_paper.pdf" rel="noopener ugc nofollow" target="_blank">http://www.ece.ubc.ca/~frolino/docs/js_bugs_study_paper.pdf</a></p><h1 id="c479" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">这是怎么回事？</h1><p id="bc3d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">好吧，所以语言不好。但更重要的是，在无休止地列举我的不满时，一个问题出现了。JavaScript为什么会这样？它并不是不在一些非常有能力的人的管理之下。鉴于互联网的现状，他们并不是不知道这些问题的存在。</p><p id="b836" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">JavaScript是一种通用语言，对其实现没有太多的控制，但对向后兼容性负有巨大的责任，因为如果JavaScript突然停止支持某个特性或改变语义，我们可能会发现这是一个半个互联网都依赖的死角。换句话说，这比让一些开发者高兴要高得多。⁹</p><p id="5810" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">ES5人员提出的一个解决方案是在JavaScript中引入一种可选模式，这种模式会限制您的操作，但在其他方面会向后兼容。我认为这是朝着正确的方向前进。例如，严格模式⁰不允许您分配只读变量或删除类的原型。好东西。另一方面，严格模式不会解决我上面列出的任何问题。</p><p id="5c35" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">那么，除了遵守纪律，希望生产你的产品所依赖的那个模块的公司没有雇用任何轻率的开发人员，还剩下什么呢？解决方案可以通过语言扩展或者编译成JavaScript的语言的形式找到。像打字稿、咖啡稿、琥珀等项目。</p><p id="9c7f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">Typescript引入了编译时键入来防止错误，咖啡脚本从JS中删除了类似Java的语法，以使其更像FP，Amber是SmallTalk的一种方言，它会将文件传输到JS中(因此完全避免了JS语法)。</p><p id="2d4c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">虽然这些项目是朝着正确方向迈出的一步，但我认为这些语言没有解决一些问题。让我们复习一下。</p><p id="7952" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">打字稿</strong>。虽然它有着惊人的用户群，而且许多JS项目现在都有了打字功能，使它们与ts兼容，但它不会阻止您遇到许多运行时问题。这是由于TS的理念:从不影响运行时，只给出编译时信息。这方面的一个例子可能还是你网站上显示的可怕的<em class="mh"> NaN% </em>。</p><p id="1754" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">咖啡脚本</strong>。虽然它可以随心所欲——从JavaScript中删除Java语法，但它也增加了一些令人惊讶的特性。例如，有中缀条件，如<em class="mh"> doSomething()(如果条件== true </em>)，以及字符<em class="mh"> @ </em>而不是访问器this。这是有问题的，因为大多数主流开发人员不习惯这种陌生的语法。更糟糕的是，咖啡脚本也无法保护您免受网站上显示的可怕的<em class="mh"> NaN% </em>😃</p><p id="d675" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">琥珀色</strong>。虽然SmallTalk在某些圈子里是一种非常流行的语言(想到的是大学)，但它是一个小社区。Amber是这种神秘语言的一种方言，它受到这种情况的困扰，因为它几乎没有得到社区的支持。因此，很难了解或专业使用它。</p><p id="a9bb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">不过，琥珀实际上会保护您免受可怕的<em class="mh"> NaN% </em>问题的困扰！而是崩溃并显示错误信息。这是不合适的，因为它可能会阻止用户看到您网站上的任何内容。</p><h1 id="f6db" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我对此做了什么？</h1><p id="518e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所以，我决定发展我自己的语言。我把它命名为<strong class="kw io"> JonScript </strong>，因为我的名字是Jon，它会编译成JavaScript。JonScript做了一些不同的事情。它结合了Typescript中的类型、Coffeescript中的函数式编程，并致力于解决JavaScript操作符和标准API长期存在的问题。</p><p id="30bc" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">需要考虑的重要一点是，JonScript使用类型化不仅仅是作为编译类型的帮助，而是影响语言在运行时的行为。由于这种类型依赖性，JonScript只需要TS包。由于Typescript在⁴非常流行，而且许多家用JS包都与TS兼容，这应该不是问题。</p><p id="d2c3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">以下是JonScript的指导原则:</p><ol class=""><li id="596a" class="mv mw in kw b kx lq la lr ld mx lh my ll mz lp na nb nc nd bi translated"><strong class="kw io">一致性</strong>:做事只有一种方式；</li><li id="5230" class="mv mw in kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><strong class="kw io">兼容性</strong>:使用类型脚本库，使用类型脚本代码；和</li><li id="f51d" class="mv mw in kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">可用性:当前的JavaScript开发者应该能够快速理解这门语言。</li></ol><p id="ce9e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">接下来，让我们讨论一下JonScript的主要特性，以及为什么我认为熟悉它是个好主意。请记住，JonScript <strong class="kw io">还处于alpha阶段——还没准备好全面生产。尽管如此，它仍然有效，你已经可以在上面写字了。如果您想亲自试用JonScript，请下载npm包<strong class="kw io"> jonscript </strong> ( <a class="ae mi" href="https://npmjs.com/package/jonscript" rel="noopener ugc nofollow" target="_blank">链接</a> ) <strong class="kw io"> </strong>，然后像这样建立一个基本的webpack ⁰构建:</strong></p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="df69" class="mo kd in mk b gy mp mq l mr ms">const path = require(“path”);<br/>module.exports = {<br/>   entry: {<br/>      <strong class="mk io">“jons”: “./src/index.jons”,</strong><br/>      “index”: “./src/index.ts”,<br/>   },<br/>   mode: “development”,<br/>   module: {<br/>      rules: [<br/>          <strong class="mk io">{<br/>             test: /\.jons$/,<br/>             use: “jonscript”,<br/>             exclude: /node_modules/,<br/>          },<br/>          </strong>{<br/>             test: /\.tsx?$/,<br/>             use: “ts-loader”,<br/>             exclude: /node_modules/,<br/>          },<br/>      ],<br/>   },<br/>   resolve: {<br/>      extensions: [ “.tsx”, “.ts”, “.js”, <strong class="mk io">“.jons” </strong>],<br/>   },<br/>   output: {<br/>      filename: “[name].js”,<br/>      path: path.resolve(__dirname, “dist”),<br/>   },<br/>};</span></pre><p id="5d36" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这将把JonScript编译成TS文件。接下来你需要做的就是从jons-temp文件夹中导入它们并运行应用程序。如果第一次构建失败，再试一次——web pack可能没有注意到正在解析的JonScript文件。我会尽快解决这个问题。</p><p id="2e52" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">接下来，让我们看看JonScripts最重要的特性:</p><h1 id="e94f" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">只是一种功能</h1><p id="acd1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在JonScript中创建或执行的所有函数的行为都类似于箭头函数。这是通过在编译期间检测函数并自动绑定它们的执行上下文来实现的。这包括标准API函数和从任何模块导入的所有函数。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="91e7" class="mo kd in mk b gy mp mq l mr ms">Module {<br/>    TestClass() {<br/>        privateProperty: [1, 2, 3, 4],<br/>        // .map function will be bound to privateVariable<br/>        privateMethod: privateProperty.map,<br/>        {<br/>           publicMethod: () =&gt; privateMethod(i =&gt; i + 1),<br/>        }<br/>    }<br/>}</span></pre><p id="5014" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">虽然这可能会破坏依赖于这种行为的遗留包，但是有一个解决方案。JonScript允许从ts文件导入。这意味着JonScript不会限制您使用标准的JavaScript特性——它只是试图引导您走上一条更安全、更好的道路。</p><h1 id="60ea" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">只是一种空</h1><p id="8704" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">所有的nulls和nan都转换成一种类型:undefined。未定义的值将在连接过程中转换为空字符串。从对象中删除所有空值键。此外，由于下面进一步讨论的操作符中的修复，您永远不需要担心未定义的属性会出现在您的网站上。未定义的值作为“nil”原语存在。类似地，TS开发人员知道的“空”类型也简单地变成了“零”。</p><p id="8934" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">以下是实际情况:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="b3df" class="mo kd in mk b gy mp mq l mr ms">Module {<br/>   TestClass() {<br/>      {<br/>          // Converts NaN into undefined<br/>          publicMethod: () =&gt; (0 / 0), <br/>          // Returns simply “%”<br/>          otherPublicMethod: () =&gt; publicMethod() + “%”,<br/>      }<br/>   }<br/>}</span></pre><h1 id="8eaf" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">模式匹配算子</h1><p id="7d9c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">JonScript引入了一个新的二元运算符<em class="mh">是</em>。is操作符有效地充当了typeof和instanceof的替换，但不仅仅如此。它也是一种类型强制的方式，类似于Typescript中的is谓词。</p><p id="890c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">首先，我们来谈谈JS中的<em class="mh">实例和</em>的<em class="mh">类型的区别以及我为什么删除它们:</em></p><ul class=""><li id="3bb6" class="mv mw in kw b kx lq la lr ld mx lh my ll mz lp nj nb nc nd bi translated"><em class="mh"> typeof </em>是一元前缀运算符，返回变量的类型。<br/>可以返回“未定义”、“字符串”、“数字”、“bigint”、“对象”、“函数”或“符号”。您可能会注意到列表中缺少了array和null它们都是对象。数字类和字符串类呢？它们也是物品。为了找出一个对象实际上代表什么，你必须做进一步的检查。</li></ul><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="b4d8" class="mo kd in mk b gy mp mq l mr ms">typeof null === “object”<br/>/* and */<br/>typeof [] === “object” /* is true */</span></pre><p id="737d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这也导致了不直观的区别:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="793f" class="mo kd in mk b gy mp mq l mr ms">typeof 2 === “number”<br/>/* is true */<br/>typeof new Number(2) === “number” /* is false */</span></pre><ul class=""><li id="9844" class="mv mw in kw b kx lq la lr ld mx lh my ll mz lp nj nb nc nd bi translated">instanceof是一个二元中缀运算符，它试图访问一个对象的<em class="mh"> __proto </em>属性。JS就是这样决定一个对象属于哪个类的。</li></ul><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="6cdf" class="mo kd in mk b gy mp mq l mr ms">[1, 2, 3] instanceof Array<br/>/* is true */<br/>2 instanceof Number /* is false */</span></pre><ul class=""><li id="0be4" class="mv mw in kw b kx lq la lr ld mx lh my ll mz lp nj nb nc nd bi translated">这很奇怪。为什么number不是Number的实例？！这就更奇怪了，因为你可以在原语上调用方法！原来instanceof只对函数和对象类型有效。</li></ul><p id="d234" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">既然你知道JS是如何做类型检查的，现在让我们来谈谈TS中的is谓词。</p><p id="2f1c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">TS中的is谓词充当类型保护。你用它代替函数的返回类型。该函数必须返回一个布尔值。当在条件中执行此函数时，Typescript会将传递给函数的参数视为强制参数。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="2e46" class="mo kd in mk b gy mp mq l mr ms">const isFish(<br/>   pet: Fish | Bird<br/>): pet is Fish =&gt; (pet as Fish).swim !== undefined;</span><span id="98c5" class="mo kd in mk b gy mu mq l mr ms">let pet = getSmallPet();</span><span id="2d99" class="mo kd in mk b gy mu mq l mr ms">// Both calls to ‘swim’ and ‘fly’ are now okay.<br/>if (isFish(pet)) {<br/>   pet.swim();<br/>} else {<br/>   pet.fly();<br/>}</span></pre><p id="b7d5" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="mh">来源:</em><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank"><em class="mh">https://www . typescriptlang . org/docs/handbook/advanced-types . html</em></a><em class="mh">。</em></p><p id="2685" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">JonScript将的<em class="mh">类型、</em>的<em class="mh">实例的功能结合到一个操作符中。它既进行类型强制，又在同一级别上处理原语和类。但是它变得更好了——一种模式匹配算法被用来使JonScript比以上的组合更强大。我不想在这里讨论这个算法的细节，因为它有点复杂。因此，为了展示JonScript可以匹配什么，下面是它的模式匹配的一个小例子:</em></p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="b6a6" class="mo kd in mk b gy mp mq l mr ms">Module {<br/>   TestClass() {{<br/>      value1: 2,<br/>      value2: “Hello”,<br/>      value3: {{ value1, value2 }},<br/>      pattern1: Number,<br/>      pattern2: String,<br/>      pattern3: {{ value1: Number }},<br/>      pattern4: {{ value2: String }},<br/>      pattern5: {{ value2: Number }},<br/>      results: [<br/>         value1 is pattern1, // true<br/>         value2 is pattern2, // true<br/>         value3 is pattern3, // true<br/>         value3 is pattern5, // false<br/>         value2 is pattern1, // false<br/>      ],<br/>   }}<br/>}</span></pre><p id="a737" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">使用名为matchto的库来实现。⁹ NPM使用版本控制系统来确保对这个库的随机更新不会改变JonScript的行为。</p><h1 id="d266" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">自动插入新关键字</h1><p id="4f26" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Typescript可以确定对函数的调用是否具有类签名。我们用这个来简化语言语法，以便插入新的关键字，这样JonScript开发人员就不需要这么做了。</p><p id="6b3f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这对运行时也有实际好处:根据测试，大多数JS开发人员认为<em class="mh"> new </em>关键字是简单的语法糖。这是不对的。</p><p id="1347" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">例如，调用<em class="mh"> Date() </em>和<em class="mh"> new Date </em>会产生不同的结果。如果您想知道为什么在调用<em class="mh"> new Date </em>时没有括号，您可能会同意从语言中删除new关键字是有益的。</p><h1 id="5b3d" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">自动异步关键字插入</h1><p id="fde1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们使用Typescript来检查表达式是否返回承诺。我们用它来简化语言语法，以便在需要的地方插入async关键字。JonScript的语法中甚至不需要那个关键字。</p><p id="cf7d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">Async确保函数返回的任何值都采用承诺的形式。这使得在JonScript中使用promise更加安全:</p><p id="5ea2" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在这里，您可以看到一个函数示例，如果您尝试使用promise回调，该函数可能会在JS中崩溃:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="4e85" class="mo kd in mk b gy mp mq l mr ms">const funct = (i) =&gt; i &gt; 5 ? 5 : new Promise(then =&gt; then(5));</span></pre><h1 id="eeb5" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">一类</h1><p id="6f85" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">JonScript有一种类和一种继承——原型继承。它没有利用JS中使用的原型对象。相反，它分析表达式的类型，类或对象从这些表达式中继承并定义适当的局部变量，然后将这些变量的值作为类的公共属性添加。这里有一个简单的例子:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="3c32" class="mo kd in mk b gy mp mq l mr ms">// imports a class with single public property of “a”<br/>import { parentClass } from ”./parentClass”<br/>Module {<br/>   TestClass() {<br/>      privatePropertyOfClass: 5,<br/>      …parentClass(), // TestClass inherits from parentClass<br/>      {<br/>         publicMethod: () =&gt; {<br/>             privatePropertyOfObject: ”Hello”,<br/>             {<br/>                // 1, 2 property “a” from parentClass<br/>                publicPropertyOfObject: [1, 2, a],<br/>             }<br/>         },<br/>         // You can also access “a” from instance of TestClass<br/>      }<br/>   }<br/>}</span></pre><h1 id="3e76" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">简单递归</h1><p id="517c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这个特性对于有经验的Typescript开发人员来说是一个额外的好处。JonScript允许所有JonScript对象和类的递归类型定义。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="bf09" class="mo kd in mk b gy mp mq l mr ms">Module {<br/>   TestClass() {{<br/>      publicObject: {{<br/>         publicObjectProperty: 5,<br/>      }},<br/>      publicMethod: (parameter: Class&lt;TestClass&gt;) =&gt; parameter,<br/>      anotherPublicMethod: (<br/>         parameter: Object&lt;publicObject&gt;<br/>      ) =&gt; parameter,<br/>   }}<br/>}</span></pre><h1 id="3775" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">宽恕是正确的</h1><p id="0934" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">与JavaScript类似，JonScript是一种宽容的语言，但更好。访问、调用、做加法等。在nil值上产生一个简单的nil值(除了串联——nil+“Hello”产生“Hello”字符串)。所有不兼容的操作，例如，比较字符串和数字，从数字中减去字符串等。结果也是零。</p><p id="3d3d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">操作员超载和合理强制</strong></p><p id="9f3e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我们知道JS运算符很奇怪。在实现JonScript时，我想到的一个目标是:如果在类上使用操作符(如string或Number ),应该得到一个类——在JavaScript中，包含String类对象的字符串连接会产生一个String原语。这样比较一致和直观。</p><p id="ff7d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">未定义的操作，如字符串相减、对象相乘或对数组取模，应该返回Undefined(在JonScript中为nil)。与JS类似，JonScript使用<em class="mh"> + </em>操作符作为连接和加法。</p><p id="8ae5" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">JonScript支持运算符重载。重载是通过在对象或类上定义这些方法之一来完成的:加、减、除、乘、模或比较(对于比较操作，如果对象相等，则返回0，如果左大于右，则大于0，如果相反，则小于0)。所有重载方法都必须用单个参数定义。</p><p id="bf70" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">操作员重载在左侧和右侧都起作用:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="6ce5" class="mo kd in mk b gy mp mq l mr ms">overloaded + “hello” /* same as */ “hello” + overloaded</span></pre><p id="9686" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">有一个例外。当使用两个重载对象时，应用左侧。下面是算术运算和结果类型的表格。切换左手边和右手边不会影响结果的类型。表中的字符串/字符串和数字/数字术语表示字符串和数字原语及其类对应物之间的差异。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2b2aa4bf1ef0daf193d3914fcc5d5d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*3U11n-rUTQXjqKY0hFJFrg.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">Table of arithmetic operations</figcaption></figure><p id="d530" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">接下来，我们来谈谈比较运算符。他们有相似的常识性规则。强制是有限度的:可以比较string/String和number/Number，得到的结果就像比较两个原语一样。字符串和数字之间的交叉比较总是会导致错误。任何对象比较，除了预期的相等之外，也总是导致false。</p><p id="2022" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">用于比较的运算符重载的工作方式与算术运算相同。对象的相等和不相等的决定方式与JavaScript中的相同(指针比较)。</p><h1 id="a8ac" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">还需要做什么？</h1><p id="280a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这就是JonScript。</p><p id="b820" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我希望我有无限的时间和资源来完善JonScript。可悲的现实是，JonScript的alpha版本还有很长的路要走。以下是它的问题:</p><h1 id="7a68" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">将修复</h1><p id="ef79" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">由于时间限制，这些问题/特性没有添加到JonScript中。我将把它们和该语言的未来版本一起发布，或者将它们放在一个实用程序包中发布。</p><p id="1c6f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">插值字符串转义不足</strong></p><p id="8521" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">为了对插值字符串中的字符“$”、“{”或“}”进行转义，需要使用“\”。在普通JS中，只需要转义“$”。这将在未来版本中通过更好的解析得到解决。</p><p id="1976" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">没有JSX的支持</strong></p><p id="ff45" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">JonScript的未来版本将包含完整的JSX ⁶支持和默认的React导入。</p><p id="b9b8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">标准api修复不足</strong></p><p id="2ce7" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">虽然在<em class="mh"> Object.keys </em>、values和entries以及<em class="mh"> Array.push </em>方法的类型和执行方面存在修复，但这绝不是对std的完全修复。API。未来的版本将包含更全面的修复。这些修复保证只会直接影响JonScript中代码的执行，而不会破坏与TS库的兼容性。</p><p id="a3de" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">地图文件</strong></p><p id="526d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">映射文件允许程序员通过将transpiled代码映射回原始代码来调试它。未来版本的JonScript将包含一个与webpack兼容的地图文件生成器。</p><p id="2c01" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io"> Visual Studio代码扩展</strong></p><p id="c8c0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">Visual studio code是微软开发的一款开源、可扩展的IDE。未来将推出一个JonScript扩展。最重要的功能是:语法高亮，调试和代码参考。</p><h1 id="8c8b" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">可能修复</h1><p id="3d06" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这些问题需要更多的研究时间，而我目前没有时间。它们可能会在未来的版本中修复，这取决于大众的需求以及是否有可能修复它们。该列表还包括具有多个可能解决方案的问题。</p><p id="545f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">可空类型有时会导致类型问题</strong></p><p id="064f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">由于语言中存在空值宽恕，TS有时会错误地将这种宽恕解释为可能的空值，并抛出一个错误。这些错误可以通过使用可空类型或空检查来避免。这将在未来的版本中得到解决，要么只允许显式可空类型，要么将JonScript中的所有类型都设为可空⁵.</p><p id="4c4f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">操作员是否无法将对象与原型类进行匹配</strong></p><p id="ed2d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如前所述，JonScript只使用原型继承。这产生了一个有趣的问题:想象一下试图在原型继承系统上使用像instanceof这样的操作符。每个类可以有多个父类，每个父类可以重写其他父类的属性和方法。每个类也可以移除/覆盖父类的方法。因此，您可以构建一个没有其父方法的类。</p><p id="8495" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">因此，判断一个对象是否属于某个类没有什么价值。虽然is操作符支持instanceof操作，但同样的支持并没有扩展到JonScript类。相反，您可以简单地使用一个类的属性作为在模式匹配过程中使用的指示器。这在未来可能会改变。</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="969b" class="mo kd in mk b gy mp mq l mr ms">// Can't do this yet<br/>testClassInstance is TestClass<br/>// But CAN do this - and Typescript will take care of rest<br/>testClassInstance is {{ testProperty: "correctValue" }}</span></pre><p id="6c3d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">构建流程需要优化</strong></p><p id="3058" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">构建过程需要多长时间还有很大的改进空间。当使用类继承时，编译速度会大大降低，我将在以后讨论这个问题。</p><h1 id="3f52" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">不会修复</h1><p id="909f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这些问题与JS引擎、兼容性或执行速度有关。我不太可能修好这些。</p><p id="02ac" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">无深度对象清理</strong></p><p id="38b0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">当在JonScript中创建对象时，您有几个保证—递归类型，没有空值键。⁷当从JonScript外部导入一个对象时，既没有递归类型，也没有直接清理。这样做是出于兼容性和性能的原因。但是，如果使用对象的属性，该属性将被自动清理。</p><p id="159c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">原始人和他们的同类⁸之间的细微差别</strong></p><p id="3eff" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">虽然从JonScript中完全删除了Boolean类，但是有一个很好的理由:</p><pre class="lw lx ly lz gt mj mk ml mm aw mn bi"><span id="2211" class="mo kd in mk b gy mp mq l mr ms">new Boolean(false) == false<br/>/* is true, but: */<br/>!new Boolean(false) /* is false!!! */</span></pre><p id="aa29" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">字符串和数字类获得了额外的用途——运算符重载和模式匹配。但是你需要小心:空字符串的字符串类和零的数字类不是假的，而它们的原始对应物是假的。也不可能重载原始值的属性，比如boolean、string或number(或者在继承中使用它们)。</p><h1 id="1b6a" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">结论</h1><p id="2801" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">有许多工作要做。已经做了很多工作。JonScript允许我探索JavaScript的深度。我希望这篇文章对任何寻求更好地理解JS和JS替代品的开发人员有所帮助。我希望我让您相信了JonScript是一个有趣的项目，并且它具有未来的潜力。也许你会试一试！</p><p id="03f0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">JonScript是我硕士论文的一部分。当我完成工作后，我会在这里添加一个链接来获得更多信息。</p><p id="2ce3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">辛西娅·李。什么时候(以及为什么)应该使用ES6箭头功能，什么时候不应该使用。<a class="ae mi" href="https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-should nt-3d 851 D7 f0b 26/</a></p><p id="f19a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注2: <br/>胡安克鲁兹马丁内斯。何时不使用JavaScript函数。<a class="ae mi" href="https://livecodestream.dev/post/when-not-to-use-javascript-arrow-functions/" rel="noopener ugc nofollow" target="_blank">https://livecodestream . dev/post/when-not-to-use-JavaScript-arrow-functions/</a></p><p id="0da0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注3: <br/>安德鲁·克尼格-包蒂斯塔。3个何时不使用JavaScript箭头函数的示例<br/><a class="ae mi" href="https://betterprogramming.pub/3-examples-of-when-not-to-use-javascript-arrow-functions-90eebfbf7bb0" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/3-示例-何时不使用-JavaScript-Arrow-Functions-90 eeb BF 7 bb 0</a></p><p id="78c7" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注4: <br/>德米特里·帕夫卢丁。何时‘不’使用箭头功能。<br/><a class="ae mi" href="https://dmitripavlutin.com/when-not-to-use-arrow-functions-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://dmitripavlutin . com/when-not-to-use-arrow-functions-in-JavaScript/</a></p><p id="9cdb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注5: <br/>德米特里·帕夫卢丁。Arrow函数和常规函数的区别。<br/><a class="ae mi" href="https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/" rel="noopener ugc nofollow" target="_blank">https://dmitripavlutin . com/differences-between-arrow-and-regular-functions/</a></p><p id="bf65" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注6: <br/>德米特里·帕夫卢丁。编写高质量JavaScript变量的5个最佳实践。<a class="ae mi" href="https://dmitripavlutin.com/javascript-variables-best-practices/" rel="noopener ugc nofollow" target="_blank">https://dmitripavlutin . com/JavaScript-variables-best-practices/</a></p><p id="9a13" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注7: <br/>亚什·阿格拉瓦尔。在ES6+ JavaScript中声明变量。<a class="ae mi" href="https://codeburst.io/declaring-variables-in-es6-javascript-60ea37e38765" rel="noopener" target="_blank">https://code burst . io/declaring-variables-in-es6-JavaScript-60ea 37 e 38765</a></p><p id="08c4" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">克里斯·恩万巴。声明JavaScript变量:var，let和const<br/><a class="ae mi" href="https://scotch.io/courses/10-need-to-know-javascript-concepts/declaring-javascript-variables-var-let-and-const" rel="noopener ugc nofollow" target="_blank">https://scotch . io/courses/10-need-to-know-JavaScript-concepts/declaring-JavaScript-Variables-var-let-and-const</a></p><p id="f80a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注9: <br/>达南杰·库马尔。用JavaScript创建对象(4种不同的方式)。<br/><a class="ae mi" href="https://www.geeksforgeeks.org/creating-objects-in-javascript-4-different-ways/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/creating-objects-in-JavaScript-4-different-ways/</a></p><p id="6074" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注10: <br/> Ashutosh K Singh。用JavaScript创建对象的三种不同方式。<br/><a class="ae mi" href="https://betterprogramming.pub/three-different-ways-to-create-objects-in-javascript-d3595d693296" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/three-different-way-to-create-objects-in-JavaScript-d 3595d 693296</a></p><p id="c5a0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注11:<br/><a class="ae mi" href="https://twitter.com/BrendanEich/status/771006397886533632" rel="noopener ugc nofollow" target="_blank">https://twitter.com/BrendanEich/status/771006397886533632</a></p><p id="0120" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注12: <br/>当地时间(3)<br/><a class="ae mi" href="https://linux.die.net/man/3/localtime" rel="noopener ugc nofollow" target="_blank">https://linux.die.net/man/3/localtime</a></p><p id="613a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注13: <br/>明科·格切夫。JavaScript，奇怪的部分。<br/><a class="ae mi" href="https://blog.mgechev.com/2013/02/22/javascript-the-weird-parts/" rel="noopener ugc nofollow" target="_blank">https://blog . mge chev . com/2013/02/22/JavaScript-the-verged-parts/</a></p><p id="a775" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注14: <br/>标准ECMA-262。5.1版/2011年6月。ECMAScript语言规范。第11.8节:关系运算符。<br/><a class="ae mi" href="https://262.ecma-international.org/5.1/#sec-11.8.3" rel="noopener ugc nofollow" target="_blank">https://262.ecma-international.org/5.1/#sec-11.8</a></p><p id="9d69" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注15: <br/>操作员文档类型<br/><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Javascript/Reference/Operators/type of</a></p><p id="0bf6" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注16: <br/>操作员文档实例<br/><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Javascript/Reference/Operators/instance of</a></p><p id="3d51" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注17: <br/>为什么不使用类<br/><a class="ae mi" href="https://everyday.codes/javascript/please-stop-using-classes-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://daily . codes/JavaScript/please-stop-using-classes-in-JavaScript/</a></p><p id="7c9e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注18:<br/>JavaScript中的原型继承<br/><a class="ae mi" href="https://www.educative.io/blog/understanding-and-using-prototypal-inheritance-in-javascript" rel="noopener ugc nofollow" target="_blank">https://www . educative . io/blog/understanding-and-use-Prototypal-inheritage-in-JavaScript</a></p><p id="1707" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注19: <br/>。JavaScript无法修复！<br/><a class="ae mi" href="https://medium.com/javascript-non-grata/as-others-have-noted-the-fundamental-problem-with-web-development-is-that-javascript-is-a-broken-7f9675048c77" rel="noopener">https://medium . com/JavaScript-non-grata/as-others-noted-the-fundamental-problem-with-web-development-is-the-JavaScript-is-a-broken-7f 9675048 c77</a></p><p id="aa89" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注20:<br/>AP hinya Dechalert<br/><a class="ae mi" href="https://dottedsquirrel.com/javascript/how-javascript-still-hasnt-broken-the-internet-just-yet/" rel="noopener ugc nofollow" target="_blank">https://dottedsquirrel . com/JavaScript/how-JavaScript-still-has nt-has nt-broken-the-internet-just-yet/</a></p><p id="e9be" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注21: <br/>打字稿<br/><a class="ae mi" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/</a>，</p><p id="9a8c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注22:<br/>coffee script<br/><a class="ae mi" href="https://coffeescript.org/" rel="noopener ugc nofollow" target="_blank">https://coffeescript.org/</a></p><p id="bfe0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注23: <br/>琥珀<br/>T22】https://www.npmjs.com/package/amber</p><p id="9339" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注24:<br/>Typescript popularity<br/><a class="ae mi" href="https://venturebeat.com/2020/12/02/github-python-and-typescript-gain-popularity-among-programming-languages/" rel="noopener ugc nofollow" target="_blank">https://venturebeat . com/2020/12/02/github-python-and-Typescript-gain-popularity-in-programming-languages/</a></p><p id="e2ad" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注25: <br/>高级类型脚本类型<br/><a class="ae mi" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/Advanced-types . html</a></p><p id="4120" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注26: <br/>反应<br/><a class="ae mi" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/introducing-jsx.html</a></p><p id="5feb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注27:<br/>JS对象结构内的问题示例<br/><a class="ae mi" href="https://dmitripavlutin.com/check-if-object-has-property-javascript/" rel="noopener ugc nofollow" target="_blank">https://dmitripavlutin . com/check-if-object-has-property-JavaScript/</a></p><p id="b551" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注28: <br/>字符串与字符串的区别<br/><a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Javascript/Reference/Global _ Objects/String</a></p><p id="ed54" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注29: <br/>马契托库<br/>https://www.npmjs.com/package/matchto T2</p><p id="3b3f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">脚注30:【https://www.npmjs.com/package/webpack】网络包<br/>T6</p></div></div>    
</body>
</html>