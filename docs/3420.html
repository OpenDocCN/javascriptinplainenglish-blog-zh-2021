<html>
<head>
<title>Build Your Own Realtime Chat App with MERN Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MERN堆栈构建您自己的实时聊天应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-realtime-chat-app-with-mern-stack-c5908ba75126?source=collection_archive---------2-----------------------#2021-07-11">https://javascript.plainenglish.io/build-your-own-realtime-chat-app-with-mern-stack-c5908ba75126?source=collection_archive---------2-----------------------#2021-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b52" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:设置后端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a90a79921142613bba9cafd7f5a808ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zr3HBTPgK2ipqWrV"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lunarts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Volodymyr Hryshchenko</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="664b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我第一次开始开发web应用程序时，我真的很喜欢重新创建我日常使用的应用程序，如社交媒体应用程序、消息应用程序或简单的游戏。在研究实时数据流时，我遇到了Socket.io，并决定试一试，尝试创建一个类似WhatsApp的实时聊天应用程序。</p><p id="7b3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是3部分的故事。在第一部分中，我们将使用NodeJS创建应用程序的后端，在第二部分中，我们将使用React构建我们的前端，最后在第三部分中，我们将部署我们的应用程序，以便您可以使用您创建的应用程序与您的朋友聊天。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/ab6bd49d9c362e74835eface44f796eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULm9IMGQqUZAPdOkl6J6sQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here is the final app I created. You can try it from <a class="ae kv" href="https://5f077488f4de1a93ec3c9cd9--xenodochial-goldberg-be9fd0.netlify.app/" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><h1 id="32e5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们将在本教程中使用的技术</h1><h2 id="efc6" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">节点. js</h2><p id="dcf5" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在构建后端时，我们将在Node.js的基础上构建它。因此，请确保您的计算机上安装了Node.js。如果不是，可以从<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><h2 id="b415" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">表达</h2><p id="7edf" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Express将帮助我们构建REST API来响应来自前端的请求。</p><h2 id="3bf0" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">Socket.io</h2><p id="ea98" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这个库使得创建实时应用程序非常容易。我们将使用Socket.io在客户端之间接收和发送消息。在幕后，Socket.io使用WebSockets API来提供实时数据流。你可以从他们的网站上了解更多信息。</p><h2 id="7f6e" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">克-奥二氏分级量表</h2><p id="f18f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这个小小的库可以让我们毫无问题地将我们的后端与任何其他前端一起使用。你可以从<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多。</p><h2 id="efa3" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">Nodemon(开发依赖性)</h2><p id="1b61" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">每当我们进行更改时，Nodemon都会重新启动服务器，这样我们就不必每次都手动执行。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="0812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过在项目根目录中键入<code class="fe nj nk nl nm b">npm init -y</code>来开始我们的项目。然后使用下面的代码片段安装所需的依赖项。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="ce25" class="ml lu iq nm b gy nr ns l nt nu">npm install express socket.io cors --save<br/>npm install nodemon --save-dev</span></pre><p id="5cc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们可以在根目录下创建我们的主文件<code class="fe nj nk nl nm b">server.js</code>，并配置<code class="fe nj nk nl nm b">package.json</code>文件。在<code class="fe nj nk nl nm b">package.json</code>中，我们将删除<code class="fe nj nk nl nm b">test</code>脚本，添加<code class="fe nj nk nl nm b">start</code>和<code class="fe nj nk nl nm b">dev</code>脚本，如下所示:</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="f9c6" class="ml lu iq nm b gy nr ns l nt nu">...<br/>"main": "server.js",<br/>"scripts": {<br/>  "start": "node server",<br/>  "dev": "nodemon server",<br/>},<br/>... </span></pre><p id="b2fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以动手做一些编码工作了。让我们打开<code class="fe nj nk nl nm b">server.js</code>文件，要求所有必要的库，并定义我们的<code class="fe nj nk nl nm b"><strong class="ky ir">PORT</strong></code>。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="58f6" class="ml lu iq nm b gy nr ns l nt nu">const express = require("express")<br/>const http = require("http")<br/>const socketio = require("socket.io")<br/>const cors = require("cors")</span><span id="c165" class="ml lu iq nm b gy nv ns l nt nu">const <strong class="nm ir">PORT</strong> = process.env.PORT || 5000</span></pre><p id="c8f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义<code class="fe nj nk nl nm b"><strong class="ky ir">PORT</strong></code>时，首先检查<code class="fe nj nk nl nm b">process.env.PORT</code>很重要，因为当我们部署应用程序时，它将是真正的端口号。</p><p id="9c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了所有的导入，是时候通过调用<code class="fe nj nk nl nm b">express</code>来创建express应用程序了。然而，由于我们将在Socket.io中使用它，我们应该创建一个封装在<code class="fe nj nk nl nm b">http.createServer()</code>中的服务器。因此，将<code class="fe nj nk nl nm b">app</code>传递给<code class="fe nj nk nl nm b">createServer</code>方法，并将其命名为<code class="fe nj nk nl nm b">server</code>或任何您想要的名称。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="9752" class="ml lu iq nm b gy nr ns l nt nu">const app = express()<br/>const server = http.createServer(app)</span></pre><p id="c561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，在<code class="fe nj nk nl nm b">server</code>使用<code class="fe nj nk nl nm b">listen</code>方法启动服务器。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="cf27" class="ml lu iq nm b gy nr ns l nt nu">server.listen(PORT, () =&gt;<br/>  console.log(`Server is up and running on port ${PORT}...`)<br/>)</span></pre><p id="ea4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在根目录下运行<code class="fe nj nk nl nm b">npm run dev</code>，您应该会看到这些提示，我们的服务器现在已经启动并运行了。恭喜你。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b398cd7952ed299b2a072d478a93b6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*RT3uztsRoy7I3odcS8FLUw.png"/></div></figure><p id="743b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了检查我们是否可以通过我们的浏览器访问它，让我们在<code class="fe nj nk nl nm b">listen</code>方法的右边写一个<code class="fe nj nk nl nm b">GET</code>处理程序并发送一条消息。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="20f7" class="ml lu iq nm b gy nr ns l nt nu">app.get("/", (req, res) =&gt; res.send("Hello World"))</span></pre><p id="8a26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你使用浏览器访问<code class="fe nj nk nl nm b">http://localhost:5000/</code>地址，你会在屏幕上看到<em class="nx"> Hello World </em>的提示。太完美了。我们的服务器现在能够响应请求了。在处理实时数据之前还有一件小事要做，就是<code class="fe nj nk nl nm b">cors</code>。在初始化<code class="fe nj nk nl nm b">app</code>变量之后，编写这个代码片段，并将<code class="fe nj nk nl nm b">cors</code>添加到express应用程序中。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="c9b9" class="ml lu iq nm b gy nr ns l nt nu">app.use(cors())</span></pre><h1 id="e92c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">设置实时数据功能</h1><p id="94b7" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在上一节中，我们导入了Socket.io库，并将其命名为<code class="fe nj nk nl nm b">socketio</code>。现在，我们将使用它来接收和向连接到特定房间的客户端发送消息。首先使用下面的代码片段初始化<code class="fe nj nk nl nm b">server</code>变量下的库。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="a59c" class="ml lu iq nm b gy nr ns l nt nu">const io = socketio(server, { wsEngine: "ws" })</span></pre><p id="6973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以在<code class="fe nj nk nl nm b">io</code>变量上使用<code class="fe nj nk nl nm b">on</code>方法编写一个<em class="nx">连接</em>处理程序。该方法的第一个参数是事件名称，第二个参数是一个回调，它为我们提供了一个已连接的套接字实例。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="0a2f" class="ml lu iq nm b gy nr ns l nt nu">io.on("connection", socket =&gt; {...})</span></pre><p id="27b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以访问各个客户端的套接字实例，我们可以在这个单独的实例上使用相同的<code class="fe nj nk nl nm b">on</code>方法来监听来自前端的特殊定制事件，例如<em class="nx">消息、send-message、join、left </em>。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="41cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，处理用户加入。在<code class="fe nj nk nl nm b">io.on</code>的回调函数体内，监听一个名为<em class="nx"> join </em>的事件。不要忘记，这些事件是自定义的，因此它们的名称可以是您想要的任何名称，但是在这种情况下，将其称为<em class="nx"> join是非常符合逻辑的。</em>回调采用两个参数。第一个是通过来自前端的事件传递的数据，以及来自前端的回调。在这种情况下，我们将发送用户名和房间名作为数据，因为我们不会使用回调，所以我们不会发送它。</p><p id="0247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了存储所有的实用函数，比如<code class="fe nj nk nl nm b">addUser, removeUser, getUsers</code>，让我们创建一个名为<code class="fe nj nk nl nm b">utils.js</code>的文件。并从中导入<code class="fe nj nk nl nm b">addUser</code>函数。我们稍后将创建这些函数。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="8ea9" class="ml lu iq nm b gy nr ns l nt nu">socket =&gt; {<br/>  socket.on("join", (data) =&gt; {<br/>    const { name, room } = data<br/>    const { user, error } = addUser({ id: socket.id, name, room })<br/>    <br/>    if (error) <strong class="nm ir">return</strong> <br/>  })<br/>}</span></pre><p id="efb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们可以发出自定义事件来通知用户，比如谁已经加入或者问候。</p><p id="de2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="nx">加入</em>事件体中，我们将发出一个<em class="nx">消息</em>事件来问候加入的用户，另一个事件用于通知其他用户该用户已经加入。要向仅加入的套接字发出事件，我们将在套接字上使用<code class="fe nj nk nl nm b">emit</code>方法，要向房间中的所有用户发出事件，有一个<code class="fe nj nk nl nm b">broadcast</code>方法。</p><p id="bb67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了将用户与房间关联起来，我们将使用<code class="fe nj nk nl nm b">join</code>方法，并将<code class="fe nj nk nl nm b">room</code>作为参数传递，并用<em class="nx">房间数据</em>事件发回房间数据。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="18fb" class="ml lu iq nm b gy nr ns l nt nu">socket.on("join", data =&gt; {<br/>  ...</span><span id="69d9" class="ml lu iq nm b gy nv ns l nt nu">  socket.emit("message", {<br/>    user: "admin",<br/>    text: `${user.name}, it's great to see you in here.`<br/>  })</span><span id="0754" class="ml lu iq nm b gy nv ns l nt nu">  socket.broadcast.to(user.room).emit("message", {<br/>    user: "admin",<br/>    text: `${user.name} has just landed to the room.`<br/>  }) </span><span id="c28c" class="ml lu iq nm b gy nv ns l nt nu">  socket.join(user.room)</span><span id="495a" class="ml lu iq nm b gy nv ns l nt nu">  io.to(user.room).emit("room-data", {<br/>    room: user.room,<br/>    users: getAllUsers(user.room),<br/>  })<br/>})</span></pre><p id="ea0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nj nk nl nm b">utils.js</code>内部，让我们创建第一个效用函数<code class="fe nj nk nl nm b">addUser</code>并将其导出。为了存储当前活跃的用户，我们将不使用数据库，因为这是一个相对简单的项目。</p><p id="5355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们将创建一个名为<code class="fe nj nk nl nm b">users</code>的数组，并将用户对象放入其中。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="9eae" class="ml lu iq nm b gy nr ns l nt nu">// utils.js</span><span id="26e7" class="ml lu iq nm b gy nv ns l nt nu">let users = []</span><span id="d9b3" class="ml lu iq nm b gy nv ns l nt nu">const addUser = ({id, name, room}) =&gt; {<br/>  name = name.trim().toLowerCase();<br/>  room = room.trim().toLowerCase();</span><span id="6f1a" class="ml lu iq nm b gy nv ns l nt nu">  const userExists = users.find(user =&gt; <br/>    user.name === name &amp;&amp; user.room === room<br/>  )</span><span id="4782" class="ml lu iq nm b gy nv ns l nt nu">  if (!user || !room || userExists) <br/>    return { error: "error" }</span><span id="e8ed" class="ml lu iq nm b gy nv ns l nt nu">  const user = { id, name, room }<br/>  users = [...users, user]</span><span id="d6ca" class="ml lu iq nm b gy nv ns l nt nu">  <strong class="nm ir">return </strong>{ user }<br/>}</span><span id="6544" class="ml lu iq nm b gy nv ns l nt nu">module.exports = { addUser }</span></pre><p id="3678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我没有费心按类型处理所有的错误和响应。但是您可以将这个功能添加到您的系统中，并根据错误类型发出定制事件，比如<em class="nx">用户已经存在的</em>。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="875f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们可以将用户添加到房间中，我们应该在他们失去连接或离开房间时删除他们。该过程将类似于添加它们。</p><p id="3872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将监听一个名为<em class="nx"> left </em>的事件，在主体中，如果用户存在，我们将从<code class="fe nj nk nl nm b">users</code>数组中删除它，断开套接字并发出消息通知其余的用户。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="9143" class="ml lu iq nm b gy nr ns l nt nu">socket.on("left", () =&gt; {<br/>  const user = removeUser(socket.id)</span><span id="7185" class="ml lu iq nm b gy nv ns l nt nu">  user &amp;&amp; io.to(user.room).emit("message", {<br/>    user: "admin",<br/>    text: `${user.name} has just left!`<br/>  })<br/>}</span></pre><p id="4f75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而这就是<code class="fe nj nk nl nm b">utils.js</code>中的<code class="fe nj nk nl nm b">removeUser</code>功能。基本上，用户从<code class="fe nj nk nl nm b">users</code>中移除并返回以通知房间中的其他人。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="d36a" class="ml lu iq nm b gy nr ns l nt nu">// utils.js</span><span id="5768" class="ml lu iq nm b gy nv ns l nt nu">const removeUser = id =&gt; {<br/>  const i = users.findIndex(user =&gt; user.id === id)<br/><strong class="nm ir">  return </strong>i !== -1 ? users.splice(i, 1)[0] : null<br/>}</span></pre></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="3184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们设置了大部分后端，但仍然有一个功能缺失，这是一种(！)对这个项目很重要。监听<em class="nx">发送消息</em>事件，并将消息发送到适当的聊天室。</p><p id="7feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我们将再次在<code class="fe nj nk nl nm b">socket.on("connection", ...)</code>的主体中创建一个事件监听器，并发出带有作为数据传递的文本消息的<em class="nx">消息</em>事件。</p><p id="2690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将使用<code class="fe nj nk nl nm b">socket.id</code>获取用户信息。因为我们将数组用作数据库，所以没有必要编写一个异步函数并等待数据库的响应——但是如果您这样做了，您应该尝试一些异步编程。</p><p id="9e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获得用户信息后，现在我们可以发出带有适当数据(消息、用户名、房间……)的<em class="nx">消息</em>事件，这样我们就可以在前端将其捕获回来。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="0de9" class="ml lu iq nm b gy nr ns l nt nu">socket.on("send-message", (message) =&gt; {<br/>  const user = getUser(socket.id)</span><span id="ce4a" class="ml lu iq nm b gy nv ns l nt nu">  io.to(user.room).emit("message", { <br/>    user: user.name, <br/>    text: message <br/>  })</span><span id="900d" class="ml lu iq nm b gy nv ns l nt nu">  io.to(user.room).emit("room-data", { <br/>    room: user.room, <br/>    users: getAllUsers(user.room)<br/>  })<br/>})</span></pre><p id="8eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，有两个实用函数:一个用于获取用户对象，另一个用于获取当前房间中的所有用户。</p><pre class="kg kh ki kj gt nn nm no np aw nq bi"><span id="c33c" class="ml lu iq nm b gy nr ns l nt nu">// utils.js</span><span id="0a12" class="ml lu iq nm b gy nv ns l nt nu">const getUser = id =&gt; users.filter(user =&gt; user.id === id)[0]<br/>const getAllUsers = room =&gt; users.filter(user =&gt; user.room === room)</span></pre></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做到了！您已经完成了本系列的第一部分，现在您已经拥有了实时聊天应用程序的全功能后端。在下一部分中，我们将设置项目的客户端，并使用React创建用户界面。如果你愿意，你可以在Github库<a class="ae kv" href="https://github.com/XenoverseUp/chatter" rel="noopener ugc nofollow" target="_blank">这里</a>找到代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://mailchi.mp/a45f8fb96cc9/subscribe"><div class="gh gi ny"><img src="../Images/9617ff4f7d33119c4d4e3d20c90708a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtX3EIdGpUqGCOW6LtO42Q.png"/></div></a><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Subscribe to get your <strong class="bd nz">free <em class="oa">subscriber-exclusive</em></strong> story.</figcaption></figure><p id="0f6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你已经发现这是有用的。感谢您阅读<strong class="ky ir">。</strong>敬请关注文章接下来的部分。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-realtime-chat-app-with-mern-stack-f203af2e066e"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使用MERN堆栈构建您自己的实时聊天应用程序</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">第2部分:用React创建前端</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><h2 id="27ec" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">进一步阅读</h2><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/i-built-a-serverless-live-chat-app-with-next-js-fauna-and-wundergraph-for-graphql-live-queries-b671d9646f6"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">我用Next.js、Fauna和WunderGraph为GraphQL实时查询构建了一个无服务器的实时聊天应用程序</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">使用无服务器技术创建可扩展的实时聊天应用程序的分步指南，来自…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="ot l op oq or on os kp oe"/></div></div></a></div><p id="027e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">更多内容请看</em><a class="ae kv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>