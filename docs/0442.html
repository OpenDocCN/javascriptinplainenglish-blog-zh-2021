<html>
<head>
<title>Understanding Insertion Sort so good that you could teach it to others</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解插入排序非常好，你可以把它教给别人</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-insertion-sort-so-good-that-you-could-teach-it-to-others-6f81abb84aa0?source=collection_archive---------11-----------------------#2021-01-26">https://javascript.plainenglish.io/understanding-insertion-sort-so-good-that-you-could-teach-it-to-others-6f81abb84aa0?source=collection_archive---------11-----------------------#2021-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/7db7dbc83927950b10db69272a5d6cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*FGZMjL-QIs16Qh0RgtQHcg.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Insertion sort</figcaption></figure><p id="3033" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">插入排序</strong>是一个简单的<a class="ae kt" href="https://en.wikipedia.org/wiki/Sorting_algorithm" rel="noopener ugc nofollow" target="_blank">排序算法</a>，它一次一个项目地构建最终的<a class="ae kt" href="https://en.wikipedia.org/wiki/Sorted_array" rel="noopener ugc nofollow" target="_blank">排序数组</a>(或列表)。它在大型列表上的效率比更高级的算法低得多，例如<a class="ae kt" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>、<a class="ae kt" href="https://en.wikipedia.org/wiki/Heapsort" rel="noopener ugc nofollow" target="_blank">堆排序</a>或<a class="ae kt" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">合并排序</a>。</p><p id="07d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，插入排序有几个优点:</p><ul class=""><li id="337f" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">简单的实现。</li><li id="49c4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">对(相当)小的数据集有效，很像其他二次排序算法。</li><li id="b6b1" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">在实践中比大多数其他简单的二次<a class="ae kt" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"/></a><strong class="jx io">(<em class="li">n</em>2)</strong>算法更有效，如<a class="ae kt" href="https://en.wikipedia.org/wiki/Selection_sort" rel="noopener ugc nofollow" target="_blank">选择-排序</a>或<a class="ae kt" href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener ugc nofollow" target="_blank">冒泡排序</a>。</li><li id="7476" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Adaptive_sort" rel="noopener ugc nofollow" target="_blank">自适应</a>，对于已经基本排序的数据集高效:当输入中的每个元素距离其排序位置不超过<em class="li"> k </em>位时，<a class="ae kt" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>为<a class="ae kt" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">O</strong></a><strong class="jx io">(<em class="li">kn</em>)</strong></li><li id="b768" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Stable_sort" rel="noopener ugc nofollow" target="_blank">稳定</a>；不改变具有相等键的元素的相对顺序。</li><li id="f5f3" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank">到位</a>；只需要恒定数量的<strong class="jx io"> O(1) </strong>的额外存储空间。</li><li id="2753" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Online_algorithm" rel="noopener ugc nofollow" target="_blank">在线</a>；可以在收到列表时对其进行排序。</li></ul><p id="5aaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当人们在桥牌手动排序卡片时，大多数使用类似于插入排序的方法。</p><h2 id="5e40" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">循序渐进的例子</h2><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5212" class="lj lk in mh b gy ml mm l mn mo"><strong class="mh io"><em class="li">Each Pass</em></strong><br/>( 3* <strong class="mh io">7</strong>  4  9  5  2  6  1 ) → ( <strong class="mh io">3</strong>  7  4  9  5  2  6  1 )<br/>( 3  7* <strong class="mh io">4</strong>  9  5  2  6  1 ) → ( 3  <strong class="mh io">4 </strong> 7  9  5  2  6  1 )<br/>( 3  4* 7  <strong class="mh io">9</strong>  5  2  6  1 ) → ( 3  4  7  <strong class="mh io">9 </strong> 5  2  6  1 )<br/>( 3  4  7  9* <strong class="mh io">5</strong>  2  6  1 ) → ( 3  4  5  7  9  <strong class="mh io">2</strong>  6  1 )<br/>( 3  4  5* 7  9  <strong class="mh io">2</strong>  6  1 ) → ( 2  3  4  5  7  9  <strong class="mh io">6</strong>  1 )<br/>( 2* 3  4  5  7  9  <strong class="mh io">6</strong>  1 ) → ( 2  3  4  5  6  7  9  <strong class="mh io">1</strong> )<br/>( 2  3  4  5  6* 7  9  <strong class="mh io">1</strong> ) → ( 1  2  3  4  5  6  7  9 )<br/>( 1* 2  3  4  5  6  7  9 )</span><span id="6815" class="lj lk in mh b gy mp mm l mn mo">Starting at index 1 each time we check if the previous value is smaller, and keep continue growing the list until we find value smaller then we check where should we put it see here:<br/>( 3  4  5 7  9  <strong class="mh io">2</strong>  6  1 ) → ( <strong class="mh io">2</strong> 3  4  5  7  9  6  1 )</span><span id="f0e5" class="lj lk in mh b gy mp mm l mn mo"><strong class="mh io">Extra Step-by-step example</strong><br/>[ 3  7  4  9  5  2  6  1 ]<br/><strong class="mh io">#(i=1)</strong> 7 will remain at its position as all previous elements in, are smaller than 7<br/>( 3  <strong class="mh io">7</strong>  4  9  5  2  6  1 )<br/><strong class="mh io">#(i=2)</strong> Since 4 is smaller than 7, move 7 and insert 4 before 7<br/>( 3  4<strong class="mh io"> </strong> <strong class="mh io">7</strong>  9  5  2  6  1 )<br/><strong class="mh io">#(i=3)</strong> 9 will remain at its position as all previous elements in, are smaller than 9<br/>( 3  4  7  <strong class="mh io">9 </strong> 5  2  6  1 )<br/><strong class="mh io">#(i=4)</strong> Since 5 is smaller will check with previous value and keep checking (j-1) until we find a smaller value than 5 and move it<br/>( 3  4  <strong class="mh io">5</strong>  7  9  2  6  1 )<br/><strong class="mh io">#(i=5)</strong> Since 2 is smaller will check with previous value and keep checking (j-1), and in this case 2 is smallest value so far so will move to the beginning and all other elements will move one position ahead of their current position.<br/>( <strong class="mh io">2</strong>  3  4  5  7  9  6  1 )<br/><strong class="mh io">#(i=6)</strong> Since 6 is smaller will check with previous value and keep checking (j-1) until we find smaller value than 6 and move it<br/>( 2  3  4  5  <strong class="mh io">6</strong>  7  9  1 )<br/><strong class="mh io">#(i=7)</strong> Since 1 is smaller will check with previous value and keep checking (j-1), and in this case 1 is smallest value so far so will move to the beginning and all other elements will move one position ahead of their current position.<br/>( <strong class="mh io">1</strong>  2  3  4  5  6  7  9 )</span></pre><h2 id="36e1" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">另一个循序渐进的例子</h2><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/da2c1878a618a512bf644a8eebf66bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKS8eQHZrwdLPfc8RLP8pA.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Insertion sort — example</figcaption></figure><h2 id="3b7c" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">现在有了代码</h2><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/4f744884054b449da5b19ac0d56dd608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ot28VUgP3gNtwegvLEffQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Step 1</figcaption></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mw"><img src="../Images/5a526537f33b389671d1c4b90fbd81cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdBxjGeeuUA849iUOAucvQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Step 2</figcaption></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mx"><img src="../Images/f0616b406d651106c919c788e9dce1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-9Gyra5albTAXOb_GnF3A.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Step 3</figcaption></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi my"><img src="../Images/1f66d2f961cb2c58f4c32538d3c98fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jr3_9mfuw9g-gkqGYnXCw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Insertion sort implementation</figcaption></figure><h2 id="1673" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">表演</h2><p id="3685" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">最好的输入是已经排序的数组。在这种情况下，插入排序具有线性运行时间<strong class="jx io"> O( <em class="li"> n </em> ) </strong>。在每次迭代中，输入的第一个剩余元素只与数组中排序后的子部分的最右边的元素进行比较。</p><p id="08d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最简单的最坏情况输入是一个逆序排序的数组。所有最坏情况输入的集合由所有阵列组成，其中每个元素是其前面的最小或第二小元素。在这些情况下，在插入下一个元素之前，内循环的每次迭代都将扫描并移动数组的整个已排序的子部分。这给了插入排序二次运行时间<strong class="jx io"> O( <em class="li"> n </em> 2) </strong>。</p><p id="226e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般情况下也是二次的<strong class="jx io"> O( <em class="li"> n </em> 2) </strong>，这使得插入排序对于大型数组来说不切实际。然而，插入排序是对非常小的数组进行排序的最快算法之一，甚至比快速排序还要快。事实上，好的<a class="ae kt" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>实现对小于某个阈值的数组使用插入排序，当出现子问题时也是如此；确切的阈值必须通过实验确定，并且取决于机器，但是通常在10左右。</p><h2 id="95b0" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">奖金</h2><p id="9a41" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">这里有一个思考排序的好例子。想象你正在玩一个纸牌游戏。你手里拿着的是牌，这些牌是经过排序的。庄家给你一张新牌。你必须把它放到正确的位置，这样你手里的牌仍然是分类的。在selection-sort中，添加到已排序子数组中的每个元素都不小于已排序子数组中的元素。但是在我们的卡片例子中，新卡可能比你已经有的一些卡片小，所以你继续下去，比较新卡和你手中的每张卡片，直到你找到放它的地方。你把新卡插入正确的位置，你的手又一次握着完全分类的卡片。然后庄家给你另一张牌，你重复同样的过程。然后是另一张牌，另一张牌，如此类推，直到庄家不再给你牌。</p><h2 id="d218" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">结论</h2><p id="06e5" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">最好的输入是已经排序的数组。这就是<strong class="jx io">插入排序</strong>背后的想法。从索引1开始，循环遍历数组中的位置。每个新位置就像是添加给你的新值，你需要把它插入到排序后的子数组中该位置左边的正确位置。</p></div></div>    
</body>
</html>