<html>
<head>
<title>Open Source Series: Version Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开源系列:版本管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/open-source-series-version-management-dc91424aa63d?source=collection_archive---------7-----------------------#2021-02-11">https://javascript.plainenglish.io/open-source-series-version-management-dc91424aa63d?source=collection_archive---------7-----------------------#2021-02-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b4646f15621d1a930991c96119493f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6k7J2Dj1iz0c901UExzjWg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="ddff" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">关于突破性变化和支持</h2></div><p id="b6ca" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在我的 <a class="ae lk" href="https://www.justjeb.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="lj">个人博客</em> </a> <em class="lj">上可以免费获得这篇文章和其他文章。请务必注册以获得最新最棒的！</em></p><p id="ee43" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">嘿，这几个月过得很艰难，但是我们又在这里谈论开源了。在这一章(也是本系列的总结部分)我们将讨论版本管理。您将了解版本符号、重大变更、后向端口等等。</p><p id="e997" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在阅读本章之前，我强烈建议您熟悉我们之前讨论过的主题，尤其是最后一个，关于自动化:</p><h1 id="d0eb" class="ll lm iy bd ln lo lp lq lr ls lt lu lv ke lw kf lx kh ly ki lz kk ma kl mb mc bi translated">目录</h1><ul class=""><li id="4d14" class="md me iy kp b kq mf kt mg kw mh la mi le mj li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/owning-an-open-source-part-1-b63abc60236" rel="noopener">简介</a></li><li id="bcfa" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/owning-an-open-source-project-part-2-2b55810aeb8" rel="noopener">开始一个项目</a></li><li id="c886" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/open-source-series-documentation-96ed1420ce81" rel="noopener">文档</a></li><li id="c818" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/open-source-series-publicity-8b3be7d65c17" rel="noopener">宣传</a></li><li id="2ce5" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/open-source-series-issues-and-prs-8cb1de880fd4" rel="noopener">问题和PRs </a></li><li id="652a" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><a class="ae lk" href="https://medium.com/@justjeb/open-source-series-automation-fe826e365b54" rel="noopener">自动化</a></li><li id="fde0" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><strong class="kp iz">版本管理</strong></li></ul><h2 id="566e" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated">软件版本控制</h2><p id="721e" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">让我们看看维基百科对软件版本有什么说法。</p><blockquote class="ni nj nk"><p id="3c6e" class="kn ko lj kp b kq kr jz ks kt ku kc kv nl kx ky kz nm lb lc ld nn lf lg lh li ig bi translated"><strong class="kp iz">软件升级版本化</strong>是给<a class="ae lk" href="https://en.wikipedia.org/wiki/Computer_software" rel="noopener ugc nofollow" target="_blank">计算机软件</a>的唯一状态分配唯一<em class="iy">版本名</em>或唯一<em class="iy">版本号</em>的过程。</p><p id="51fe" class="kn ko lj kp b kq kr jz ks kt ku kc kv nl kx ky kz nm lb lc ld nn lf lg lh li ig bi translated">现代计算机软件通常使用两种不同的软件版本控制方案来跟踪，一种是可能在一天内增加多次的<a class="ae lk" href="https://en.wikipedia.org/wiki/Software_versioning#Internal_version_numbers" rel="noopener ugc nofollow" target="_blank">内部版本号</a>，如修订控制号；另一种是通常很少改变的<em class="iy">发布版本</em>，如语义版本控制<a class="ae lk" href="https://en.wikipedia.org/wiki/Software_versioning#cite_note-semver-1" rel="noopener ugc nofollow" target="_blank"/>、或<a class="ae lk" href="https://en.wikipedia.org/wiki/Code_name#Project_code_name" rel="noopener ugc nofollow" target="_blank">项目代码名称</a>。</p></blockquote><p id="5d0a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">事实上，有多种方法可以唯一地识别您的软件产品版本。</p><p id="5558" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">最广为人知的方法是给它一个名字。</p><p id="07cf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">地球上的绝大多数人，甚至那些间接与技术相关的人，可能都听说过Android冰淇淋三明治和棉花糖或Mac OS Leopard，它的冷冻表亲雪豹和大苏尔。</p><p id="2fe2" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">程序员们可能听说过月食及其天体月球、火星和光子。</p><p id="a9b9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">所有这些都是软件产品的主要版本。</p><p id="68c9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">虽然名字对营销很有帮助，但有时也会让人困惑。<br/>事实上，谷歌已经不再在安卓版本名称中使用糖果，因为他们:</p><blockquote class="ni nj nk"><p id="4b9e" class="kn ko lj kp b kq kr jz ks kt ku kc kv nl kx ky kz nm lb lc ld nn lf lg lh li ig bi translated">多年来，我从用户那里听到的反馈是，这些名称并不总是能被全球社区中的每个人直观地理解</p></blockquote><p id="9de1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这是理所当然的，但也许我们还没有进化到足以从动物物种中推断出版本号，尽管雪豹比美洲豹酷多了。</p><p id="135d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">天体和糖果是更容易理解的概念，但前提是你要按字母顺序命名它们(就像Android和Eclipse那样)。但有一点是肯定的——没有比数字更好的确定接班人的方法了。</p><p id="4411" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因此，如果你把你的软件产品的第一个版本命名为“产品1 ”,第二个版本命名为“产品2 ”,很直观的说第二个版本是更新的，不是吗？</p><p id="7718" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然而，与不公开API的独立软件产品不同，被其他软件消费的软件(像大多数OSS产品一样)需要更好的版本控制，而不仅仅是一系列数字。</p><p id="e71a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">例如，如果我们使用一个简单的数字序列来进行版本控制，用户如何区分一个bug修复和一个破坏现有API的变更？</p><p id="5aaf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">答案是…</p><h2 id="5148" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated">语义版本控制</h2><p id="1046" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">语义版本(也称为SemVer)是一种广泛采用的版本方案，它使用以下格式的3位数序列:<code class="fe no np nq nr b">MAJOR.MINOR.PATCH</code>。<br/>规则很简单——给定一个版本号<code class="fe no np nq nr b">MAJOR.MINOR.PATCH</code>，递增:</p><figure class="nt nu nv nw gt ip gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fb522ded6c65d990f54174f4cf59f631.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/0*jYezoiMbLruKRlGM.png"/></div></figure><ul class=""><li id="e0c4" class="md me iy kp b kq kr kt ku kw nx la ny le nz li mk ml mm mn bi translated"><code class="fe no np nq nr b">MAJOR</code>版本时做出不兼容的API修改</li><li id="7044" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><code class="fe no np nq nr b">MINOR</code>以向后兼容的方式添加功能时的版本</li><li id="27cc" class="md me iy kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><code class="fe no np nq nr b">PATCH</code>版本的时候你做了向后兼容的bug修正。</li></ul><p id="2247" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">预发布和构建元数据的附加标签可作为<code class="fe no np nq nr b">MAJOR.MINOR.PATCH</code>格式的扩展。</p><p id="f0f0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">它提供了一种清晰而简洁的方式来将软件产品中的变更传达给用户。</p><p id="0650" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">但最重要的是，它被各种包管理器和构建工具广泛采用(像<a class="ae lk" href="https://docs.npmjs.com/about-semantic-versioning#using-semantic-versioning-to-specify-update-types-your-package-can-accept" rel="noopener ugc nofollow" target="_blank"> NPM </a>和<a class="ae lk" href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8903" rel="noopener ugc nofollow" target="_blank"> Maven </a>，它允许用户依赖于特定的<strong class="kp iz">版本范围</strong>而不是特定的版本。</p><p id="e926" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">例如，指定版本范围<code class="fe no np nq nr b">^2.2.1</code>而不是明确的版本<code class="fe no np nq nr b">2.2.1</code>将让用户接受任何向后兼容的错误修复或在版本<code class="fe no np nq nr b">2.2.1</code>之上发布的新功能。</p><p id="277f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">也就是说，构建工具和包管理器依赖于用户和包所有者之间的契约——一个由SemVer定义的契约。<br/>这意味着责任是<em class="lj">你的</em>——你是定义什么是重大改变，什么是微小改变的人。<br/>您可能会意外地发布一个重大变更作为bug修复(补丁版本),它<em class="lj">将</em>破坏依赖于某个范围的构建。</p><p id="c4a5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">破坏构建是一件可怕的事情，所以我建议您使用带有预定义消息格式的<code class="fe no np nq nr b">semantic-release</code>和提交格式强制工具。<br/>我们<a class="ae lk" href="https://medium.com/@justjeb/open-source-series-automation-fe826e365b54/#d927" rel="noopener">确实在<a class="ae lk" href="https://medium.com/@justjeb/open-source-series-automation-fe826e365b54" rel="noopener">自动化</a>章节中涉及到了</a>，所以如果你还没看，现在是时候了。</p><p id="ef79" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">你可以在semver.org的官方网站<a class="ae lk" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">找到更多关于语义版本的信息。</a></p><p id="1ceb" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，我们已经了解了<em class="lj">识别</em>突破性变化，让我们谈谈<em class="lj">介绍</em>它们。</p><h2 id="9418" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated">重大变化</h2><p id="770d" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">突破性变更是对您的公共API的变更，以不兼容的方式删除、重命名或更改您与用户的合同。</p><p id="952e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">理想情况下，您应该在代码中保持向后兼容性，并且永远不会引入任何突破性的变化。但是当你醒来时，你会发现一个残酷的现实。</p><p id="5557" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">软件在发展，你的代码也在发展。用户的需求在变化，你的API也在变化。你作为开发者成长，你的产品也是如此。因此，尤其是作为一个不拿工资的开源开发者，你不能允许自己维护项目中所有的遗留代码。有时候，你需要摆脱它。</p><p id="4887" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">问题是怎么做？</p><p id="409f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">一如既往，这是一种权衡。您会更好地了解这种或那种变化对用户的影响。<br/>你不需要<em class="lj">有</em>来不惜一切代价保持向后兼容，也不需要在每一个老版本中实现所有的新功能。但是这肯定是你应该考虑的事情。</p><p id="89f8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果迁移成本对用户来说相对较低，那么做一个突破性的改变是很好的，在旧版本中不支持这个特性是很合理的。然而，如果迁移成本很高，并且绝大多数用户无法承担这一工作，那么您可能应该考虑首先使这一更改向后兼容，并发布反对警告。</p><p id="8688" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">弃用警告通常与新API一起发布，而旧API仍然受支持。这样，用户就有时间进行迁移，一旦迁移完成，在下一个主要版本中，就可以安全地删除弃用警告和旧的API。</p><p id="cf69" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在任何情况下，无论何时引入突破性的变更，都要确保您有一份迁移指南，其中有一步一步的迁移说明。</p><p id="cb36" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">此外，出于礼貌，如果你能给用户时间来准备一个突破性的改变，尤其是在没有宽限期的情况下(新旧API都支持)。解释突破性变化、其背后的原因和预期时间框架的一点提示。<br/>它可以是一条推文、一篇博客文章，甚至是带有弃用警告的产品的一个新的次要版本。</p><p id="079e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请记住，突破性的变化本质上是一种负面体验，而突然的<em class="lj">突破性的变化是一种极其</em>负面的体验。</p><h2 id="5c54" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated">自动迁移</h2><p id="b8b1" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">我们可以将重大变更分为两类——非确定性和确定性。<br/>不确定性是指您无法预测迁移工作的结果，例如当您完全删除某个API的某个部分时。<br/>在这种情况下，由用户决定是用其他第三方库替换它，自己实现它，还是将其贬值。</p><p id="5cf1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">确定性变更是那些给定代码<code class="fe no np nq nr b">X</code>和用户输入<code class="fe no np nq nr b">I</code>允许你将其转换成代码<code class="fe no np nq nr b">Y</code>的变更。例如，更改函数名或导入语句。</p><p id="8bf1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果你引入了决定性的突破性改变，你可以编写一个自动化程序来改变用户的代码库并调整它以适应新的API。有了这种自动化，您将不必关心向后兼容性和详细的迁移指南。你为用户提供了一种升级他们代码的方法，而他们一点也不费力，这在软件更新中是至关重要的。</p><p id="32ed" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然而，这里也有一个内在的权衡。编写代码需要时间，就像编写迁移指南一样。当然，编写将复杂代码流迁移到新API的代码比编写用新函数名替换函数名的代码要花费更多的时间。<br/>有时候你就是承受不起这种努力。</p><p id="7798" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果你决定去做，有一些工具可以帮助你实现你想要的。</p><p id="d882" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">最广为人知和语言不可知的是脸书的<a class="ae lk" href="https://github.com/facebook/codemod" rel="noopener ugc nofollow" target="_blank">代码模式</a>。</p><blockquote class="ni nj nk"><p id="e178" class="kn ko lj kp b kq kr jz ks kt ku kc kv nl kx ky kz nm lb lc ld nn lf lg lh li ig bi translated">codemod是一个工具/库，帮助您进行大规模的代码库重构，这些重构可以部分自动化，但仍然需要人工监督和偶尔的干预。</p></blockquote><p id="544b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">还有使用<a class="ae lk" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>的更复杂的工具，可以用于更复杂的任务，而不仅仅是寻找&amp;替换。<br/>例如，另一个名为<a class="ae lk" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"> JSCodeShift </a>的脸书库(特定于JS/TS)。<br/>或<a class="ae lk" href="https://github.com/ranyitz/code-migrate" rel="noopener ugc nofollow" target="_blank">code-migrate</a>——一个工具(也是JS/TS专用的),它允许您相对容易地编写一个引导式迁移，并为用户提供基于CLI的漂亮提示。</p><figure class="nt nu nv nw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oa"><img src="../Images/ed50d8f2f07fe8e82a4f073a9b1dc626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFlF8Vx0-thA0EutbBgiUA.png"/></div></div></figure><p id="53e9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">一些大型OSS项目甚至有他们自己的解决方案。<br/>这种解决方案的一个例子是<a class="ae lk" href="https://angular.io/guide/schematics" rel="noopener ugc nofollow" target="_blank">Angular schematics</a>——一个支持复杂逻辑的基于模板的代码生成器。</p><p id="e390" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">自动代码迁移可以作为一个单独的包发布(像<code class="fe no np nq nr b">my-cool-oss-migrate-v4-v5</code>)，并在迁移指南中作为一个步骤提及。或者，迁移可以是包含重大变更的主版本的一部分，并在用户代码库中安装该版本时执行。选择权在你。</p><h2 id="dd4c" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated">反向移植</h2><p id="6616" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">另一种常见的做法是将重要的更改移植到以前的版本。例如，在一个主要版本(有突破性的改变)之后发现了一个严重的错误，但是它也适用于以前的版本。</p><p id="b56a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这种情况下，您不能期望您的用户因为一个bug而执行冗长乏味的迁移。另一方面，签出旧版本，在其上实现修复，并将其作为旧版本的小改动发布可能会很麻烦。</p><blockquote class="ob"><p id="3d3d" class="oc od iy bd oe of og oh oi oj ok li dk translated"><em class="ol">解决方案:每个主要版本都有一个受保护的分支。</em></p></blockquote><p id="a8b2" class="pw-post-body-paragraph kn ko iy kp b kq om jz ks kt on kc kv kw oo ky kz la op lc ld le oq lg lh li ig bi translated">每当你计划发布一个主版本时，你从主分支中创建一个名为<code class="fe no np nq nr b">c.x.x</code>的分支，其中<code class="fe no np nq nr b">c</code>是当前的主版本号。<br/>你把所有这样的树枝都保护起来(就像主枝一样)，这样你就不会不小心折断它们。然后，任何时候你必须从一个新的主要版本中支持一个特性或者一个bug修复，你要么在这个分支上重新实现它，要么(如果可能的话)从主分支中挑选提交。</p><p id="bebe" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">此外，一个值得一提的策略是为下一个主要版本<em class="lj">建立一个单独的分支(而不是只为以前的主要版本建立分支)。<br/>这通常与大规模项目(如Webpack或Babel)相关，这些项目在每个新的主要版本中都有很多变化。为即将到来的主要版本建立一个单独的分支允许对其进行处理并发布以供测试，同时仍然在主分支中保留最相关的版本(并对其进行处理)。一旦发布了新的主要版本，它的分支就变成了主分支，并且为下一个主要版本创建了一个新的分支。</em></p><h1 id="2239" class="ll lm iy bd ln lo lp lq lr ls lt lu lv ke lw kf lx kh ly ki lz kk ma kl mb mc bi translated">最后的想法</h1><p id="4a24" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">这一章是关于版本管理的，但也是本系列的总结部分。所以我想和你分享一件事，当你拥有一个开源项目时，你应该永远记住。</p><h2 id="47b2" class="mt lm iy bd ln mu mv dn lr mw mx dp lv kw my mz lx la na nb lz le nc nd mb ne bi translated"><strong class="ak">倾听你的用户</strong></h2><p id="520b" class="pw-post-body-paragraph kn ko iy kp b kq mf jz ks kt mg kc kv kw nf ky kz la ng lc ld le nh lg lh li ig bi translated">这听起来可能违背直觉，但这是事实——你不是唯一定义路线图的人，用户也定义它。事实上，大部分是用户定义的。如果你拥有一个开源项目，那么你这样做是为了帮助别人，而不是你自己。</p><p id="209f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">拥有多个反馈渠道。有些用户只有一个简短的问题，你可以在一秒钟内给出答案。有一些潜在的贡献者想讨论路线图，但不想公开讨论。给他们一个联系你的方式。提供懈怠或不和谐的链接，分享你的Twitter账户等。渠道越多越好。</p><p id="86bc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果你喜欢我的文章，学到了新的或有见地的东西，或者如果你不想错过我的下一篇文章，请确保你在Twitter或Medium上关注我。干杯！</p></div></div>    
</body>
</html>