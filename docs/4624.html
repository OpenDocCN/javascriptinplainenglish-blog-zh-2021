<html>
<head>
<title>Pie Chart Using Angular and HTML Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度和HTML画布的饼图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pie-chart-using-angular-and-html-canvas-part-one-9164f4b09956?source=collection_archive---------24-----------------------#2021-09-14">https://javascript.plainenglish.io/pie-chart-using-angular-and-html-canvas-part-one-9164f4b09956?source=collection_archive---------24-----------------------#2021-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ab3a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:如何创建可缩放的HTML画布饼图</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2fca79474615945988e62ba8f1feffb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kGbZSGA9fowHRCBipL2Lg.jpeg"/></div></div></figure><blockquote class="ko kp kq"><p id="0b30" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">饼图是数据展示中常见的图表。在本教程中，您将学习如何创建一个HTML画布饼图，您可以根据自己的喜好缩放！</p></blockquote><p id="1653" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">让我们完全诚实地说，数据是好的，有很多东西要接受！是的，你不能通过简单地查看原始数据来理解数据。这就是为什么需要有呈现数据的方式和方法——最基本的方法之一是使用饼图。</p><p id="7cd0" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">数据表示最好使用图表，在本教程中，我们将学习如何从头开始创建饼图！是的，没错，我们将使用Angular来这样做，尽管你可以在其他框架中使用相同的逻辑，甚至是普通的java脚本。那么，事不宜迟，我们开始吧！</p><h2 id="ad41" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">我们将使用什么</h2><p id="f610" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lo mm ld le lp mn lh li lq mo ll lm ln ig bi translated">您可以想出许多现成的方法来创建饼图，但在这种情况下，我们将使用HTML Canvas来创建我们的饼图。</p><p id="458c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">由于本教程将包含其他形式的图表，我们将使用创建饼图作为一个<strong class="ku io">库</strong>，并简单地将其导入到更大的项目中。</p><p id="ba00" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">最后，我们将使用一个理论案例研究，我们需要了解学生的总体成绩以及他们在每次考试中的表现。</p><h2 id="3b43" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">定义数据</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/f110b3b8f560f397dd5b96397c9c5c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*xQJuKIVZ16BKVkCr.jpg"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Defining the data.</figcaption></figure><p id="8c20" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">我明白，我们并不都喜欢数据准备，但是相信我，最好是尽早准备数据并定义它，这样我们就能在脑海中想象出我们的饼状图会是什么样子。因此，既然我们正在做一个饼图角度教程，那么在这种情况下，我们将使用接口来定义数据的外观。因此，我们将有几个接口:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="5aec" class="lr ls in mv b gy mz na l nb nc">// IExam<br/>export interface IExam {<br/>    uuid: string;<br/>    label: string;<br/>    subjects: ISubject[];<br/>}<br/><br/>// ISubject<br/>export interface ISubject {<br/>    name: string;<br/>    unitCode: string;<br/>    score: number;<br/>    maxScore: number;<br/>    percentage: number;<br/>}<br/><br/>// IArc<br/>export interface IArc {<br/>    x: number;<br/>    y: number;<br/>    startAngle: number;<br/>    endAngle: number;<br/>    direction: boolean;<br/>    color: string;<br/>}</span></pre><p id="b4f3" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io">注意:当然，你可以以最适合你的数据的方式自由地改变你的接口定义，但是在这样做的时候，记住在剩下的代码中改变你如何定义你的接口，以免你收到一个编译错误！</strong></p><h2 id="0efa" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">准备画布</h2><p id="0622" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lo mm ld le lp mn lh li lq mo ll lm ln ig bi translated">嗯，就像每个艺术家一样，我们需要一个地方来绘制我们的内容。因此，我们将定义一个画布，然后像这样将其标记为引用元素，这是因为它是一个饼图角度教程，否则，您可以使用另一种方法来引用您的画布元素。</p><p id="851b" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在，在组件上，我们将像这样获得被引用的canvas元素。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="4517" class="lr ls in mv b gy mz na l nb nc">import { ElementRef, Input, OnInit, ViewChild } from '@angular/core';<br/><br/>// Code snippet<br/><br/>export class PieChartComponent implements OnInit {<br/>  @Input() data: IExam[] = [];<br/>  @Input() radius!: number;<br/><br/>  @ViewChild('canvasRef', {static: true})<br/>  private _canvasRef!: ElementRef;<br/><br/>  // More code here<br/>}</span></pre><h2 id="bac4" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">在画布上绘制之前，先对其进行一些样式设计</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/831c85eba9fcd163176947a30aee73c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*13xM9qEWcgGWusmC.jpg"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Styling the canvas a bit before drawing onto it.</figcaption></figure><p id="ae95" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在画布已经准备好了，在我们开始创建饼图之前，我们需要确保画布已经准备好了，这样我们的饼图就可以舒服地放在上面。既然我们正在创建一个饼图角度教程，那么这意味着我们正在与组件。因此，一个组件基本上可以接受输入形式的配置，一个这样的输入，除了<strong class="ku io">数据</strong>就是<strong class="ku io">半径</strong>。这将是我们希望饼图具有的<strong class="ku io">半径</strong>大小。</p><p id="63df" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">因此，我们将把它传递到我们的饼状图组件中，或者您可以使用任何其他方式与组件通信，但关键是，我们需要使我们的绘图区域变得更大<strong class="ku io">，其大小与所需饼状图的半径</strong>相同。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="c38e" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>private _styleCanvas(): void {<br/>    this._canvasRef.nativeElement.width += this.radius;<br/>    this._canvasRef.nativeElement.height += this.radius;<br/>    this._canvasRect = this._canvasRef.nativeElement.getBoundingClientRect();<br/>    this._renderer2.setStyle(this._canvasRef.nativeElement, 'background-color', this._canvasBackgroundFill);<br/>}</span></pre><p id="da26" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">请注意，我们这样做，而不是使用<strong class="ku io">渲染器2 </strong>，然后将宽度和高度设置为像素。这样做的原因是，将其设置为像素会使我们的渲染产生不希望的结果。所以最好是没有单位的值。</p><h2 id="480c" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">将原始数据转换成弧线</h2><p id="af16" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lo mm ld le lp mn lh li lq mo ll lm ln ig bi translated">现在，下一个重要的部分是将数据转换成弧线，因为我们将使用HTML Canvas arcs来创建一个漂亮的Angular饼图。因此，正如你在上面的界面中看到的，我们需要做一些数据转换。这些是:</p><p id="55fc" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io">计算考试可能的总分。</strong></p><p id="f0d2" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">在给定的时间，我们将查看给定检查的结果。因此，我们需要计算学生在那次考试中可能得到的最高分。为此，我们将使用以下方法:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="8c15" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>private _calculateTotalPossibleScore(): void {<br/>    this._totalPossibleScore = this._examBeingViewed.subjects.map(subject =&gt; subject.maxScore).reduce((prev, current) =&gt; {<br/>        return prev + current;<br/>    });<br/>}</span></pre><p id="f41d" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io">计算主题百分比。</strong></p><p id="b74d" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在，下一个重要的部分是将科目转换为总可能分数的百分比。嗯，这有点棘手，也不直截了当。所以，我们需要做的是:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="ab7b" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>private _calculateSubjectScoreAsPercentageOfTotal(): void {<br/>    const studentTotalScore = this._examBeingViewed.subjects.map(subject =&gt; subject.score).reduce((prev, current) =&gt; {<br/>        return prev + current;<br/>    })<br/>    const studentScoreOutOfTotal = studentTotalScore / this._totalPossibleScore;<br/>    this.data.forEach(exam =&gt; {<br/>        exam.subjects.forEach(subject =&gt; {<br/>        subject.percentage = ((subject.score / this._totalPossibleScore) * 100) / studentScoreOutOfTotal;<br/>        });<br/>    });<br/>}</span></pre><p id="9bcc" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">所以，我们要做的第一件事是计算学生的总成绩，为考试做准备。接下来，我们找出学生的分数，占他们在考试中可能达到的总分数的比率。然后，我们将每个受试者的分数表示为总可能分数的百分比，然后除以他们的总分数与总可能分数的比率。</p><p id="b54c" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">这将给出一个反映值，即学生在每个科目上的分数与总累积分数的比值。当然，你可以想出其他方法来表示一个分数相对于可能的总分数，但这是我们将在这个饼图角度教程中使用的。</p><p id="d6c8" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io">将主题转换成弧线。</strong></p><p id="9cfb" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在，下一步是将主题转换成弧线。这一点我们将使用下面的方法:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="76ab" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>private _createArcsForSubject(): void {<br/>    const circleCenterY: number = this._canvasRect.height / 2;<br/>    const circleCenterX: number = this._canvasRect.width / 2;<br/>    this._examBeingViewed.subjects.forEach((subject, index) =&gt; {<br/>        let startAngle: number = 0;<br/>        let arcDegree = (subject.percentage / 100) * 360;<br/>        const lastArc = this._arcs.slice(-1)[0];<br/>        if (lastArc) {<br/>        startAngle = lastArc.endAngle;<br/>        arcDegree = lastArc.endAngle + arcDegree;<br/>        }<br/>        this._arcs.push({<br/>        y: circleCenterY,<br/>        x: circleCenterX,<br/>        startAngle: startAngle,<br/>        endAngle: arcDegree,<br/>        direction: false,<br/>        color: this._arcColors[index]<br/>        })<br/>    })<br/>}</span></pre><p id="5062" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">为了解释，每个弧都需要一个参考点来开始绘制。这就是为什么我们在X轴<strong class="ku io">和Y轴</strong>都使用画布的中心。现在，对于每个主题，我们将计算起始角度和终止角度。</p><p id="2dc1" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">因此，对于第一个主题，startAngle为0，那么endAngle将是主题在饼图上显示时的大小，我们通过<strong class="ku io"> subject.percentage * 360 </strong>来实现，我们称之为arcDegree。</p><p id="9a3f" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在，对于除了第一个对象之外的每个对象，起始角度将是添加到我们的弧列表中的最后一个弧的终止角度。至于endAngle，这将是最后一个弧的endAngle加上这个对象的arcDegree。</p><p id="2cec" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">之后，我们继续设置方向(顺时针或逆时针)和颜色——这两个只是为了让事情变得更好，你可以自由地与它们互动，并根据你的需要改变它们。</p><h2 id="ad91" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">绘制画布</h2><p id="9d78" class="pw-post-body-paragraph kr ks in ku b kv mk jo kx ky ml jr la lo mm ld le lp mn lh li lq mo ll lm ln ig bi translated">现在，是时候让我们的代码在画布上做一些绘制了。这里，我们将使用下面的代码:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="0c7d" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>private _renderContentOnCanvas(): void {<br/>    const ctx = this._canvasRef.nativeElement.getContext('2d');<br/>    this._arcs.forEach((arc, index) =&gt; {<br/>        if (ctx) {<br/>        const startRad = (arc.startAngle / 180) * Math.PI;<br/>        const endRad = (arc.endAngle / 180) * Math.PI;<br/>        ctx.beginPath();<br/>        ctx.moveTo(arc.x, arc.y);<br/>        ctx.arc(arc.x, arc.y, this.radius / 2, startRad, endRad);<br/>        ctx.fillStyle = arc.color;<br/>        ctx.strokeStyle = this._canvasBackgroundFill;<br/>        ctx.lineWidth = 10 / this._examBeingViewed.subjects.length;<br/>        ctx.fill();<br/>        ctx.stroke();<br/>        }<br/>    });<br/>    if (ctx) {<br/>        ctx.font = '20px Snippet';<br/>        ctx.fillStyle = '#000000';<br/>        ctx.fillText(this._examBeingViewed.label, 40, 40)<br/>    }<br/>}</span></pre><p id="aed7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">我们要做的第一件事是首先掌握画布的上下文。由于我们正在做一个饼图角度二维饼图，我们将使用<strong class="ku io">‘2d’</strong>上下文。之后，我们将继续渲染画布上的每个弧线<strong class="ku io">一个接一个</strong>。重要的是注意到<strong class="ku io">一个接一个的</strong>强调。这是因为画布绘制是如何发生的。</p><p id="35c7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">因此，在循环中，我们将首先计算每个主题的度数的弧度表示，然后将它们存储为startRad和endRad。之后，我们现在做<strong class="ku io"> ctx.beginPath() </strong>，这实际上是真实的交易，你可以试着注释掉它，看看会发生什么。</p><p id="bb31" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">beginPath()要做的是发出正在绘制的前一条路径的闭包，然后发出正在绘制的另一条路径的开始信号！这是一个非常重要的概念，相信我，它几乎抓住了我！</p><p id="ceeb" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">之后，我们将执行<strong class="ku io"> ctx.moveTo() </strong>，指定我们想要从哪里绘制弧线，注意，这意味着对于每个弧线，一旦我们发出我们想要beginPath()，我们将从moveTo()位置开始。</p><p id="65e6" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">然后我们现在将绘制我们的弧<strong class="ku io"> ctx.arc(cx，cy，radius / 2，startInRadian，endInRadian) </strong>这将绘制我们的弧。但是你可能想知道为什么<strong class="ku io"> radius / 2 </strong>，这是因为我们希望我们的饼状图适合我们的HTML画布！现在你差不多完成了。</p><p id="f358" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">现在，接下来的步骤非常简单:</p><ul class=""><li id="b3cb" class="ne nf in ku b kv kw ky kz lo ng lp nh lq ni ln nj nk nl nm bi translated">CTX . fill style = arc . color-设置用于填充此弧线的填充颜色。</li><li id="c480" class="ne nf in ku b kv nn ky no lo np lp nq lq nr ln nj nk nl nm bi translated">ctx.strokeStyle = this。_canvasBackgroundFill —设置您想要的笔触样式，我们将使用与画布背景相似的样式。</li><li id="3e09" class="ne nf in ku b kv nn ky no lo np lp nq lq nr ln nj nk nl nm bi translated">ctx.lineWidth = 10 / this。_ exam being viewered . subjects . length-设置在画布上绘制的线条的粗细。</li><li id="505d" class="ne nf in ku b kv nn ky no lo np lp nq lq nr ln nj nk nl nm bi translated">CTX . fill()-现在填充绘制的圆弧。</li><li id="32de" class="ne nf in ku b kv nn ky no lo np lp nq lq nr ln nj nk nl nm bi translated">CTX . stroke()-删除弧线。</li></ul><p id="5a68" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io">需要注意的是，我们正在为每个绘制的弧配置上下文。这是因为一个上下文将使用它拥有的最后一个配置</strong>。记住这一点，你就会明白我们为什么要这样做。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="b2da" class="lr ls in mv b gy mz na l nb nc">// This method should be inside a component, this is just a snippet<br/>if (ctx) {<br/>    ctx.font = '20px Snippet';<br/>    ctx.fillStyle = '#000000';<br/>    ctx.fillText(this._examBeingViewed.label, 40, 40)<br/>}</span></pre><p id="36e0" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">在我们在画布上写东西之前，上面的代码将设置我们希望ctx拥有的样式。如果我们不这样做，那么fillStyle之类的东西将采用应用于上下文的最后一个fillStyle。</p><p id="dc28" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">所以，是时候看看结果了…<strong class="ku io"> <em class="kt">鼓卷！！！！</em>T19】</strong></p><h2 id="aca8" class="lr ls in bd lt lu lv dn lw lx ly dp lz lo ma mb mc lp md me mf lq mg mh mi mj bi translated">结论</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2539d96736d858834ef1aca1fe5f86b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*GMyzhogwJk5HxGMA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Conclusion</figcaption></figure><p id="8863" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">最后，在本教程中，您已经学习了如何创建角度饼图。您可以通过该链接找到该代码的链接:<a class="ae nt" href="https://github.com/benwainaina/charts." rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="kt">【https://github.com/benwainaina/charts】</em></strong>。</a>您可以随意尝试代码并与之交互。</p><p id="0fe7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated">记住要注意教程的下一部分，我们将对饼图进行样式化，使其具有标签并接受更多的数据！</p><p id="43be" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lo lc ld le lp lg lh li lq lk ll lm ln ig bi translated"><strong class="ku io"> <em class="kt">快乐编码！</em> </strong></p><blockquote class="ko kp kq"><p id="b246" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你有兴趣学习<strong class="ku io">角度</strong>？在我的网站上查看类似的精彩文章:<a class="ae nt" href="https://bingeoncode.com/category/angular" rel="noopener ugc nofollow" target="_blank">疯狂代码&gt;有角度</a></p></blockquote></div></div>    
</body>
</html>