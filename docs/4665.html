<html>
<head>
<title>What are Timing Attacks and How to Prevent them using Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是计时攻击，如何利用Node.js防范？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-timing-attacks-and-how-to-prevent-them-using-nodejs-158cc7e2d70c?source=collection_archive---------3-----------------------#2021-09-17">https://javascript.plainenglish.io/what-are-timing-attacks-and-how-to-prevent-them-using-nodejs-158cc7e2d70c?source=collection_archive---------3-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0d0b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">网络安全</h2><div class=""/><div class=""><h2 id="7cbb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">直到有人向我证明我的代码易受攻击，我才意识到这个安全漏洞。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4848cd10fc979de0004b0a7af5cc591f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tb8pb5-WMUlYbR36A3rN_A.png"/></div></div></figure><p id="47b2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在玩secret和network的时候，你可能会被经典的三重等式验证所诱惑。</p><p id="e665" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">假设您有一个API路由，它需要一些带有API键的报头/有效负载才能被访问(例如:<code class="fe lw lx ly lz b">*4wyU1O!aSZECZXz$1NYymtGBX</code>)。</p><p id="cceb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们可能有以下代码:</p><pre class="kp kq kr ks gt ma lz mb mc aw md bi"><span id="714c" class="me mf iq lz b gy mg mh l mi mj">// This is a Typescript file, body is a JSON object with given shape<br/>function onRequest(body: {secret: string}) {<br/>  if(body.secret !== "*4wyU1O!aSZECZXz$1NYymtGBX") {<br/>    throw new AccessDeniedException();<br/>  }<br/>  <br/>  // Do something else and be considered granted<br/>}</span></pre><p id="0aa6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">乍一看，这段代码看起来完美地工作着，事实上，它正在从根本上工作。真正的真相除了这段代码及其漏洞之外，还要恶毒得多。</p><p id="56df" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是为什么呢？让我们首先深入了解一下计时攻击的目的以及Node.js中字符串比较的行为。</p><h1 id="06b6" class="mk mf iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">什么是定时攻击？</h1><blockquote class="nb"><p id="c8fe" class="nc nd iq bd ne nf ng nh ni nj nk lv dk translated">在<a class="ae nl" href="https://en.wikipedia.org/wiki/Cryptography" rel="noopener ugc nofollow" target="_blank">密码术</a>中，<strong class="ak">定时攻击</strong>是一种<a class="ae nl" href="https://en.wikipedia.org/wiki/Side-channel_attack" rel="noopener ugc nofollow" target="_blank">旁道攻击</a>，攻击者试图通过分析执行密码算法所花费的时间来危害<a class="ae nl" href="https://en.wikipedia.org/wiki/Cryptosystem" rel="noopener ugc nofollow" target="_blank">密码系统</a>。</p></blockquote><p id="0cda" class="pw-post-body-paragraph la lb iq lc b ld nm ka lf lg nn kd li lj no ll lm ln np lp lq lr nq lt lu lv ij bi translated">字符串比较是一个根据输入需要不同时间处理的函数，因此容易受到计时攻击。</p><p id="fe3b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在大多数情况下，无论何时你的代码，你都不依赖于外部敏感数据，但是当你比较一些终端用户提供的外部秘密时，比如一个API密匙，你可能是脆弱的。</p><h2 id="7597" class="me mf iq bd ml nr ns dn mp nt nu dp mt lj nv nw mv ln nx ny mx lr nz oa mz iw bi translated">Node.js中的字符串比较是如何工作的</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/c4d2b8329c3dfdaa1326e907a5ac1eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uw5pWDqXZn113en9.jpeg"/></div></div></figure><p id="3024" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当您使用三重等式<code class="fe lw lx ly lz b">===</code>时，JavaScript引擎将遍历每个字母并比较相同索引处的字符。<strong class="lc ja">第一次不匹配</strong>，<strong class="lc ja">返回假。</strong></p><p id="2f15" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这意味着如果在后面的字符失败，计算通常会花费更多的时间。</p><p id="34eb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用这种技术，当一个好的字母匹配时，我们可以检测到处理时间的变化，并且我们可以继续前进，直到我们得到完整的字符串相等。</p><h2 id="e50e" class="me mf iq bd ml nr ns dn mp nt nu dp mt lj nv nw mv ln nx ny mx lr nz oa mz iw bi translated">如何防止Node.js中的计时攻击？</h2><p id="72bf" class="pw-post-body-paragraph la lb iq lc b ld oc ka lf lg od kd li lj oe ll lm ln of lp lq lr og lt lu lv ij bi translated">为了解决这个暴力破解的问题，我们需要一种比较技术，无论是否有字符的早期不匹配，它都需要相同的时间安全。使用安全的比较功能，检查字符串长度的差异，并始终一致地比较所有字符。</p><p id="a889" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样，比较两个不同的字符串总要花费相同的时间。</p><p id="b4b5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在Node.js的<code class="fe lw lx ly lz b">crypto</code>模块中，我们有一个<code class="fe lw lx ly lz b">timingSafeEqual</code>函数来实现这个目的。这里是一个使用<code class="fe lw lx ly lz b">passport-js</code>策略实现的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c008" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="oj">更多内容看</em><a class="ae nl" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja"><em class="oj">plain English . io</em></strong></a></p></div></div>    
</body>
</html>