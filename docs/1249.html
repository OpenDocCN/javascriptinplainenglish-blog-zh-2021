<html>
<head>
<title>Build Your Own Proxy Server from Scratch with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js从头开始构建自己的代理服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-forward-and-reverse-proxy-server-using-node-js-from-scratch-eaa0f8d69e1f?source=collection_archive---------2-----------------------#2021-03-16">https://javascript.plainenglish.io/build-your-own-forward-and-reverse-proxy-server-using-node-js-from-scratch-eaa0f8d69e1f?source=collection_archive---------2-----------------------#2021-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b66b515933601377d8c0f63954e2bc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kt2gWicorOSZih4JWgGNwQ.png"/></div></div></figure><p id="c6e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代理是客户端和整个互联网之间的网关。但是代理有几个用例。例如:如果你在一个公司网络中，有99%的可能性你在一个代理后面，这个代理通过允许和限制你能访问什么和不能访问什么来控制你对互联网的访问。这种代理被称为<em class="kt">转发代理。</em></p><p id="6563" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们讨论服务器端，假设您有一个应用程序部署在一些服务器上，并暴露在internet上，但您希望实现一个中间人来防止您的应用程序服务器直接暴露在internet上，您可能希望有一个代理服务器，它可以从internet上的客户端接收请求，并将它们转发到您的应用程序服务器，然后将响应发送回它们。这种代理被称为<em class="kt">反向代理</em>。</p><h1 id="057d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">前向代理的概念</h1><p id="a728" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们通过一个简单的例子来理解这一点。你在一家拥有计算机A、B和C的公司，这些计算机想要访问网站X，但是为了公司安全，管理员已经阻止了对因特网的直接访问，但是他已经设置了代理服务器P，通过该代理服务器可以访问因特网。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/e7aebeab738d506eef72ea8330eb02ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Db_LRtXsHcYs7v7Ou-8Dg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Forward proxy graphical representation</figcaption></figure><p id="6176" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述场景中的代理服务器是<em class="kt">转发代理</em>服务器。</p><h1 id="776c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">反向代理的概念</h1><p id="e7c1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">假设你是一个客户端C，正在访问一个网站w。但是网站管理员阻止了对服务器的直接访问，并实现了一个代理P，它接收来自你的请求并将其转发给实际的服务器，然后接收它们的响应并发送给你。您以为您是在直接访问网站C -&gt; W，但实际上，您是在访问代理服务器，而代理服务器又将您的请求转发给实际的应用服务器，即C -&gt; P -&gt; W。表示如下:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/027cac0e65e7ed058e54e122485ac24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khx_iAorE8zkcMATdSpDBA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Reverse proxy graphical representation</figcaption></figure><p id="66d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面场景中提到的代理服务器是<em class="kt">反向代理</em>服务器。</p><h1 id="57be" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">代理服务器编码</h1><p id="b2c7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><strong class="jx io">完整代码可以在github找到:</strong><a class="ae mh" href="https://github.com/kasattejaswi/nodejs-proxy-server" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">https://github.com/kasattejaswi/nodejs-proxy-server</strong></a></p><p id="2c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理论讲够了，让我们直接进入代理服务器的编码。对于开发，我们将使用网络的某些node.js内置模块。第一个是<strong class="jx io">网络模块，</strong>第二个是<strong class="jx io">流模块。</strong>在继续编码之前，先看一下这些模块是很重要的。有关这些模块的文档和精确解释，您可以参考以下链接:</p><h2 id="f5f0" class="mi kv in bd kw mj mk dn la ml mm dp le kg mn mo li kk mp mq lm ko mr ms lq mt bi translated">网络模块:</h2><ol class=""><li id="43c7" class="mu mv in jx b jy ls kc lt kg mw kk mx ko my ks mz na nb nc bi translated">官方文件:<a class="ae mh" href="https://nodejs.org/api/net.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/net.html</a></li></ol><h2 id="8560" class="mi kv in bd kw mj mk dn la ml mm dp le kg mn mo li kk mp mq lm ko mr ms lq mt bi translated">流模块:</h2><ol class=""><li id="4d15" class="mu mv in jx b jy ls kc lt kg mw kk mx ko my ks mz na nb nc bi translated">官方文件:<a class="ae mh" href="https://nodejs.org/api/stream.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/stream.html</a></li><li id="dbb1" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">很干脆的解释:<a class="ae mh" href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/node-js-streams-everything-you-need-to-know-c 9141306 be 93/</a></li></ol><p id="b191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，为了开始，请确保您的系统中已经安装了node.js，并且所有IDE都已准备好。</p><p id="62d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们将把net模块导入到代码中，并调用createServer()</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/86aa3a79ce4d837a6b4cf4f83a224cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUEo3dZ7IA5wcsyD6Ta0uw.png"/></div></div></figure><p id="4b0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们的服务器被初始化，我们可以监听0.0.0.0主机(用于接受来自所有IP的传入请求)和8080端口，并且在回调中，我们可以记录服务器正在0.0.0.0:8080上运行</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/7bb1013a88fcc2ebd51401cb1e5b1890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-zj1UFm5_ulxhmjwAQe2A.png"/></div></div></figure><p id="4822" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当新的请求到达服务器时，Net模块就触发某些事件。现在我们要监听“连接”、“错误”和“关闭”事件。对于这些，我们来补充一些听众。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/cebe3e788eb7da97d987c082d66284b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9uiJPpLnT3-YcFNIFcFiQ.png"/></div></div></figure><p id="ed0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">连接事件为我们提供了一个socket对象，其中包含了服务器捕获的请求的详细信息。错误事件为我们提供了一个在回调中传递的错误。所以在上面的例子中，我们已经记录了数据。</p><p id="743d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，一旦收到数据，clientToProxySocket还会触发一个事件“data”。对于每个请求，因为我们只需要获取一次数据，所以我们将只监听一次“数据”事件，只监听第一次，并从中收集足够的数据。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/e5ec500d601ee9726b217842585f9943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sq6xw7o012H1XdacUjAJrQ.png"/></div></div></figure><p id="22ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至此，我们已经设置了一个简单的服务器，它将接收请求并在控制台中打印请求的详细信息。为了测试它，我们需要首先设置我们的测试环境。</p><h2 id="8f2c" class="mi kv in bd kw mj mk dn la ml mm dp le kg mn mo li kk mp mq lm ko mr ms lq mt bi translated">设置测试环境</h2><p id="14a9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为此，我将使用Mozilla Firefox。然而，您可以使用任何浏览器，程序将是相同的。</p><p id="0786" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在地址栏中，输入about:preferences，一个设置页面就会打开</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a289fbe9727fcac6660a60f5f27bec29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWS_ByTniXN5MDyXm_PLxA.png"/></div></div></figure><p id="f497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在搜索框中搜索代理，代理选项将被过滤掉。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/2b09fa481e7e77e1b8c4ebbe0f55379b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9cGWqt0luzeucfvwW4nvQ.png"/></div></div></figure><p id="2fc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击设置，代理设置页面将会打开。选择“手动代理配置”。在中，对于HTTP代理，将本地主机和端口指定为8080，并选中“也将此代理用于FTP和HTTPS”复选框。它们现在看起来会像这样。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/6fb8c42318028175f482358b4a873fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVh-qkEjbcB86GK5JKfWpw.png"/></div></div></figure><p id="0dff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单击OK，您就完成了测试环境的设置。</p><h2 id="dc0d" class="mi kv in bd kw mj mk dn la ml mm dp le kg mn mo li kk mp mq lm ko mr ms lq mt bi translated">获取请求详细信息</h2><p id="0e82" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在，既然我们的基本服务器和测试环境已经准备好了，让我们第一次运行它，看看我们在请求中得到什么细节。我们将发出两个请求——一个是http，另一个是https。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/5edfc595b98c4aff7bfbd6debba5ecfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qY1wGs90eCrWVYnDjCd28w.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Running our server file named proxy.js in console</figcaption></figure><p id="c0db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在这里看到的，我们的服务器监听日志现在已经打印出来了，可以接受传入的请求了。</p><p id="a2f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了测试，我们将使用linkedin.com作为http和https URL。</p><p id="dedb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们进入linkedin.com时，我们得到了以下数据:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/4fa18acb6d65a24619cc507af51104ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQr_NxPIwb06Sy-wV3gYdA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Data on entering linkedin.com in firefox</figcaption></figure><p id="fd45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们试试https://linkedin.com的<a class="ae mh" href="https://linkedin.com." rel="noopener ugc nofollow" target="_blank">。</a>我们得到了以下数据:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/4b5b36aca1e358bd04ede01129445095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqN8e5XLgJdZd1mKETMayA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Data on entering https://linkedin.com in firefox</figcaption></figure><p id="a50d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，两个请求有一个主要的不同。对于http，我们得到了地址中包含http的GET请求。对于https，我们使用443端口号进行连接。因此，我们将使用它来检查请求是http还是https，并相应地分配端口。我们将假设目标网站遵循标准方法，使用端口80进行http连接，使用端口443进行https连接。我们现在不会涉及自定义端口，但可以通过类似的方式获得它们。</p><p id="f0e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，如果你检查你的浏览器窗口，页面将继续加载和加载，并最终超时，因为它从来没有得到我们的代理服务器的响应。</p><p id="0eea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了检查连接是http还是https，我们将使用请求中的连接字符串。让我们添加代码。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/9b7d497e3e9da996156d8645bf1cbded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCJvfrtvCH59BBUCTDK3Yg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Further code for fetching address and port details from request</figcaption></figure><p id="0f4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至此，我们已经获得了将请求转发到目的地的所有必要信息。但是怎么做呢？答案是node.js streams。如果我们谈论从客户端到代理服务器的请求，它是一个<em class="kt">可读流</em>，如果我们谈论到目的地的代理，它是一个<em class="kt">可写流</em>。但是当数据从目的地接收到代理时，它将是一个<em class="kt">可读流</em>，然后当它从代理服务器发送回客户端时，它将是一个<em class="kt">可写流</em>。如果我们执行管道，我们可以将请求转发到两端。</p><p id="b953" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们从使用createConnection()方法创建一个从代理服务器到目的地的连接开始，使用net模块和我们从客户机请求中提取的主机和端口。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/ad3f049d32a7ea4eba2b71264e6357b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Af73v5_Gg6X_kPbplDB44g.png"/></div></div></figure><p id="b6e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以简单地通过管道传输流，并捕获客户端到代理和代理到目的地的任何错误。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/580bf8baaef1ae6431b73ba768a86a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LXswy1aTja7ZnPzgtjf4g.png"/></div></div></figure><p id="9b75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仅此而已。我们成熟的代理服务器已经准备好了。</p><p id="b2fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在运行它并访问我们的网站。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/7d5cc6f0de830deb0d155c1837d7104b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaMAx6axBTa_idaFcfWUeQ.png"/></div></div></figure><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/82f88d3b1e103f3534101bfc9ff8a20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogx4YP8wLojN_90p_eUgtg.png"/></div></div></figure><p id="47f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Linkedin页面已成功打开。如果我们看到控制台，我们正在打印大量的请求。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/521b43b04f02e0b748eeb78bd0bfe13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7EJeC8Ajqy0w_LnCYKa1g.png"/></div></div></figure><p id="968b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这表明我们的代理服务器工作正常。在这段代码中，我们还可以做更多的增强。我们可以通过在服务器上运行它并相应地定制它来将其用作反向代理。</p><p id="6a44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的代码可以在github找到:<a class="ae mh" href="https://github.com/kasattejaswi/nodejs-proxy-server" rel="noopener ugc nofollow" target="_blank">https://github.com/kasattejaswi/nodejs-proxy-server</a></p><p id="246e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">感谢您阅读本文，如果您想阅读更多关于JavaScript的文章，请不要忘记关注:</em><a class="ae mh" href="https://thejsway.medium.com/" rel="noopener"><em class="kt">https://thejsway.medium.com/</em></a></p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h2 id="6bbc" class="mi kv in bd kw mj mk dn la ml mm dp le kg mn mo li kk mp mq lm ko mr ms lq mt bi translated">进一步阅读</h2><div class="oa ob gp gr oc od"><a href="https://plainenglish.io/blog/how-to-integrate-proxy-with-python-requests" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">如何将代理与Python请求集成</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">本教程将向您展示如何使用代理服务器来利用Python请求模块。为了避免他们的IP…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">简明英语. io</p></div></div><div class="om l"><div class="on l oo op oq om or jt od"/></div></div></a></div></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="2a22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae mh" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a><em class="kt">。报名参加我们的</em> <a class="ae mh" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">免费周报</em> </strong> </a> <em class="kt">。关注我们关于</em><a class="ae mh" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">Twitter</em></strong></a><em class="kt">和</em><a class="ae mh" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">LinkedIn</em></strong></a><em class="kt">。查看我们的</em> <a class="ae mh" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">社区不和谐</em> </strong> </a> <em class="kt">加入我们的</em> <a class="ae mh" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="kt">人才集体</em> </strong> </a> <em class="kt">。</em></p></div></div>    
</body>
</html>