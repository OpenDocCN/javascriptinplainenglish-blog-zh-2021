<html>
<head>
<title>Let’s Demystify Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们揭开JavaScript中提升的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-demystify-hoisting-in-javascript-84e18b9f6569?source=collection_archive---------12-----------------------#2021-09-16">https://javascript.plainenglish.io/lets-demystify-hoisting-in-javascript-84e18b9f6569?source=collection_archive---------12-----------------------#2021-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e128" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的提升是什么，它是如何工作的？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f7e308b8bda349baecde3712fc5f26bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6nKc31zj_yGBhuzMUYAgA.png"/></div></div></figure><p id="8458" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">提升是JavaScript中的一个特性，它将所有的变量和函数声明移动到代码的顶部(这个声明并不意味着代码被物理地移动到顶部。).众所周知，JavaScript引擎创建了一个<em class="lk">执行上下文</em>，在这里运行JavaScript代码。</p><p id="bbaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">执行上下文中有两个阶段——创建阶段和执行阶段。创建阶段是提升发生的阶段。现在，让我们试着借助例子来理解吊装是如何工作的。</p><h1 id="8673" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">可变提升</h1><p id="b47e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">JavaScript有三种方法来声明变量。分别是<strong class="kq io"> var </strong>、<strong class="kq io"> let、</strong>和<strong class="kq io"> const </strong>。它们中的每一个在用途、范围和提升方面都与其他的不同。你可以在这里阅读更多关于<a class="ae mi" href="https://themallu.dev/demystifying-var-let-and-const" rel="noopener ugc nofollow" target="_blank">的变量声明。这里需要注意的重要一点是，在变量提升期间，只有变量声明部分会被移动到代码的顶部，留下赋值。</a></p><h1 id="7fb5" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">案例1</h1><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="1116" class="mo lm in mk b gy mp mq l mr ms"><br/>console.log(icecream); // Prints undefined<br/>var icecream = “Vanilla”;<br/></span></pre><p id="e862" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的代码片段中，我们试图在声明变量之前就使用它。这看起来会抛出一个错误。但是真的吗？这就是吊装的用武之地。</p><p id="d219" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行这段代码的JavaScript引擎首先创建一个执行上下文。一旦创建了执行上下文，它就从创建阶段开始。在创建阶段，引擎解析代码，将声明和初始化分成两条语句，并将所有声明移到代码的顶部。所有使用<strong class="kq io"> var </strong>关键字声明的变量在被提升时将被初始化为默认值<strong class="kq io"> undefined </strong>。这就是它在JavaScript执行上述代码时打印出<strong class="kq io">未定义</strong>而不是错误的原因。</p><h1 id="44e9" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">案例2</h1><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="158e" class="mo lm in mk b gy mp mq l mr ms"><br/>console.log(icecream); // Prints ReferenceError: icecream is not defined<br/>let icecream = “Vanilla”;</span></pre><p id="6006" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当JavaScript引擎执行上述代码时，它会抛出一个引用错误。为什么会这样？不是应该打印<strong class="kq io">未定义</strong>吗？<strong class="kq io"> let </strong>声明的变量真的被吊起来了吗？嗯，<strong class="kq io">让</strong>变量也被提升，但与<strong class="kq io"> var </strong>相比，它们有一点不同。</p><p id="4b3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行这段代码的JavaScript引擎会创建一个执行上下文。一旦创建了执行上下文，它就从创建阶段开始。在创建阶段，引擎解析代码，将声明和初始化分成两条语句，并将所有声明移到代码的顶部。</p><p id="cc94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在区别来了:所有使用<strong class="kq io"> let </strong>关键字声明的变量将不会有像<strong class="kq io"> var </strong>那样的默认值；相反，当它们被提升时，它们将被标记为处于<strong class="kq io"> TDZ(时间死区)</strong>模式。这只是意味着变量确实存在，但在用一个值初始化之前，它们是不可访问的。这就是当<strong class="kq io">让</strong>声明的变量被提升时，JavaScript抛出引用错误的原因。</p><h1 id="7fc9" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">案例3</h1><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="24c5" class="mo lm in mk b gy mp mq l mr ms"><br/>console.log(icecream); // Prints ReferenceError: icecream is not defined<br/>const icecream = “Vanilla”;<br/></span></pre><p id="e377" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么<strong class="kq io"> const </strong>声明的变量呢？常量变量也被提升，它们的工作方式和提升<strong class="kq io"> let </strong>完全一样。这就是当<strong class="kq io"> const </strong>声明的变量也被提升时，我们得到相同错误的原因。</p><h1 id="b2c0" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">功能提升</h1><p id="2d4e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">将函数声明移到代码顶部的提升称为函数提升。</p><h1 id="8c82" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">案例1</h1><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="cad0" class="mo lm in mk b gy mp mq l mr ms"><br/>getIcecream(); // Prints Vanilla Icecream<br/>function getIcecream() {<br/> console.log(“Vanilla Icecream”),<br/>}<br/></span></pre><p id="71c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行上述代码的JavaScript引擎创建一个执行上下文，并开始创建阶段。在创建阶段，它将所有的变量和函数声明移到代码的顶部。在这种情况下，函数声明<strong class="kq io">geticestream</strong>将被移到代码的顶部。在创建阶段之后不久，执行阶段就开始了，在那里代码将被执行。由于函数<strong class="kq io">geticestream</strong>已经在创建阶段声明，调用<strong class="kq io">geticestream</strong>将打印预期的输出，而不是错误。</p><h1 id="91ac" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">案例2</h1><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="8161" class="mo lm in mk b gy mp mq l mr ms"><br/>icecream(); // Prints TypeError: icecream is not a function<br/>var icecream = function () {<br/> console.log(“Vanilla Icecream”)<br/>}<br/></span></pre><p id="493d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行上述代码的JavaScript引擎创建一个执行上下文，并开始创建阶段。在创建阶段，它将所有的变量和函数声明移到代码的顶部。在这个例子中，<strong class="kq io"> var icecream </strong>被赋值给一个函数，这个语句叫做函数表达式。当引擎识别出<strong class="kq io"> var变量</strong> icecream时，它将声明移到代码的顶部，并分配一个默认值<strong class="kq io"> undefined </strong>，留下函数代码。在执行阶段，当它遇到语句<strong class="kq io"> icecream() </strong>时，它将抛出一个类型错误，因为引擎期望一个函数，但却得到一个未定义的。这就是函数表达式不吊的原因。箭头函数呢？同样的事情也适用于箭头函数。这意味着箭头功能也不会被提升。</p><p id="cd6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望这清楚了提升在JavaScript中是如何工作的。如果你觉得这篇文章有用，请展示你的爱，并通过你的社交媒体与你的同伴分享，他们可以最大限度地利用这篇文章。请随时通过Twitter、LinkedIn或电子邮件与我联系。</p><p id="20c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">直到我们再次见面，<strong class="kq io">马卢开发</strong>结束👋干杯！🥂</p><p id="59d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">更多内容请看</em><a class="ae mi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="lk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>