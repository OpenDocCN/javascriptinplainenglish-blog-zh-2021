<html>
<head>
<title>Top 10 Tips for Configuring Automated Plugins to Enhance DevOps in Webpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">配置自动化插件以增强Webpack中DevOps的10大技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-10-tips-of-automated-plugins-you-can-configurate-to-enhance-devops-in-webpack-de1495c725b5?source=collection_archive---------19-----------------------#2021-05-03">https://javascript.plainenglish.io/top-10-tips-of-automated-plugins-you-can-configurate-to-enhance-devops-in-webpack-de1495c725b5?source=collection_archive---------19-----------------------#2021-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6e0bd7da91ac34e485d38a4b84068ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvMgMZlU9DRC1m5ZiOTk5g.png"/></div></div></figure><div class=""/><p id="f9b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Webpack是一个打包工具，它的目的是打包所有的静态资源。有人会问为什么需要webpack？Webpack是现代前端技术的基石。jQuery、HTML、CSS静态网页开发等常规开发方法已经落后。现在是MVVM和数据驱动界面的时代。Webpack打包了现代JavaScript开发中各种新的有用的技术。</p><p id="d7b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试图描述webpack可能会让人不知所措，所以我不会浪费大家的时间。看懂这张图就知道webpack的生态系统了:</p><h1 id="d2ca" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 1。加载器列表</strong></h1><p id="f414" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://webpack.js.org/loaders/raw-loader/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"/></a>:加载文件的原始内容(UTF-8) <br/> <a class="ae lz" href="https://webpack.js.org/loaders/file-loader/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">文件加载器</strong> </a>:将文件输出到一个文件夹，在代码中使用相对URL引用输出文件(处理图片和字体)<br/><a class="ae lz" href="https://webpack.js.org/loaders/url-loader/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">URL-loader</strong></a>:类似于文件加载器，不同的是用户可以设置一个阈值，如果阈值大于阈值， 它将被移交给文件加载器进行处理，并且当阈值小于阈值时， 它将返回文件base64格式编码(处理图片和字体)<br/> <strong class="ka jc"> source-map-loader </strong>:加载额外的源文件以便断点调试<br/> <strong class="ka jc"> svg-inline-loader </strong>:将压缩的svg内容注入代码<br/> <strong class="ka jc"> image-loader </strong>:加载并压缩图像文件<br/> json-loader加载json文件(默认包含) <br/> <strong class="ka jc">车把-加载器</strong>:将车把模板编译成函数返回<br/> <strong class="ka jc"> babel-loader </strong>:将ES6转换成ES5 <br/> <strong class="ka jc"> ts-loader </strong>:将typescript转换成JavaScript<br/><strong class="ka jc">awesome-TypeScript-loader</strong>:将TypeScript转换成JavaScript，性能优于ts-loader<br/><strong class="ka jc">SASS-loader</strong>:转换SCSS 以及通过DOM操纵<br/> <strong class="ka jc">加载css——post CSS-loader</strong>:扩展CSS语法，使用下一代CSS， 并用autoprefixer插件<br/> <strong class="ka jc"> eslint-loader </strong>自动填充CSS3前缀:通过ESLint<br/><strong class="ka jc">ts lint-loader</strong>检查JavaScript代码:通过ts lint<br/><strong class="ka jc">mocha-loader</strong>检查TypeScript代码:加载Mocha测试用例<br/> <strong class="ka jc"> coverjs-loader </strong>代码:计算测试<br/><strong class="ka jc">vue-loader</strong>的覆盖率</p><h1 id="06be" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 2。Webpack仪表板</strong></h1><p id="0cf2" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当使用webpack时，尤其是对于一个开发服务器，您可能习惯于看到很长很难阅读的东西。但是，webpack dashboard可以帮助您节省阅读实际配置的时间:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/02405121eb9d2fd6cba1eec48f4295a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aV1RmH1NcMKYWZQs"/></div></div></figure><p id="b4f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="f04f" class="mk kx jb mg b gy ml mm l mn mo">$ npm install --save-dev webpack-dashboard<br/># ... or ...<br/>$ yarn add --dev webpack-dashboard</span></pre><p id="7ada" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9361" class="mk kx jb mg b gy ml mm l mn mo">// Import the plugin:<br/>const DashboardPlugin = require("webpack-dashboard/plugin");<br/><br/>// Add it to your webpack configuration plugins.<br/>module.exports = {<br/>  // ...<br/>  plugins: [new DashboardPlugin()];<br/>  // ...<br/>};</span></pre><h1 id="b804" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 3。网络包合并</strong></h1><p id="734e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://www.npmjs.com/package/webpack-merge" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> webpack-merge </strong> </a>提供了一个<code class="fe mp mq mr mg b">merge</code>函数，用于连接数组和合并对象，创建一个新对象。如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回值包装在函数中。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/70929634c2373ecae8dedd77c87f7414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3JiR700_PZ2DVvwpVocBqA.gif"/></div></div></figure><p id="c059" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种行为在配置webpack时特别有用，尽管它还有其他用途。每当你需要合并配置对象时，<strong class="ka jc"> webpack-merge </strong>就能派上用场。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2190" class="mk kx jb mg b gy ml mm l mn mo">const { merge } = require('webpack-merge');<br/><br/>// Default API<br/>const output = merge(object1, object2, object3, ...);<br/><br/>// You can pass an array of objects directly.<br/>// This works with all available functions.<br/>const output = merge([object1, object2, object3]);<br/><br/>// Keys matching to the right take precedence:<br/>const output = merge(<br/>  { fruit: "apple", color: "red" },<br/>  { fruit: "strawberries" }<br/>);<br/>console.log(output);<br/>// { color: "red", fruit: "strawberries"}</span></pre><h1 id="d0ca" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 4。速度测量插件</strong></h1><p id="62ca" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">优化你的webpack构建速度的第一步是要知道你的注意力集中在哪里。</p><p id="84ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个插件测量您的webpack构建速度，给出如下输出:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/aae60b411fa0aa0e4284f021801e7743.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*EfyFV0EaZ00MFZ7e.png"/></div></figure><p id="fcf2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="af8c" class="mk kx jb mg b gy ml mm l mn mo">npm install --save-dev speed-measure-webpack-plugin</span><span id="65dd" class="mk kx jb mg b gy mu mm l mn mo">yarn add -D speed-measure-webpack-plugin</span></pre><p id="9de6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b94f" class="mk kx jb mg b gy ml mm l mn mo">const webpackConfig = {<br/>  plugins: [new MyPlugin(), new MyOtherPlugin()],<br/>};</span></pre><h1 id="cef9" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 5。尺寸插件</strong></h1><p id="5ca3" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">打印webpack资产的gzipped大小以及自上次构建以来的更改。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/316fcbe270379e20b73957ab87285b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_-v-g2F-qavukMUi"/></div></div></figure><p id="3f0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9fd8" class="mk kx jb mg b gy ml mm l mn mo"><br/>Install <!-- -->size-plugin<!-- --> as a development dependency using npm:</span><span id="c0e4" class="mk kx jb mg b gy mu mm l mn mo">npm i -D size-plugin</span></pre><p id="c503" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4e71" class="mk kx jb mg b gy ml mm l mn mo">// webpack.config.js<br/>+ const SizePlugin = require('size-plugin');<br/><br/>module.exports = {<br/>  plugins: [<br/>+    new SizePlugin()<br/>  ]<br/>}</span></pre><h1 id="6efc" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 6。热模块替换插件</strong></h1><p id="b4bd" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Webpack的热更新也叫热模块替换，缩写为HMR。这种机制可以用新改变的模块替换旧模块，而无需刷新浏览器。</p><p id="dc65" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HMR的核心是客户端从服务器获取更新的文件。准确的说是chunk diff(需要更新的那部分chunk)。事实上，在WDS和浏览器之间维护着一个Websocket。当本地资源发生变化时，WDS会将更新推送到浏览器，并在构建时带来哈希，以便客户端可以与上一个资源进行比较。在比较了差异之后，客户端将向WDS发起一个Ajax请求，以获取更改的内容(文件列表、哈希)，这样客户端就可以使用这些信息继续向WDS发起一个jsonp请求，以获取块的增量更新。</p><p id="f28a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后续部分—如何处理增量更新？应该保留哪个状态？哪些需要更新？—由HotModulePlugin完成，它提供了相关的API供开发者针对自己的场景进行处理，比如react-hot-loader和Vue-loader使用这些API实现HMR。</p><div class="ip iq gp gr ir mw"><a href="https://webpack.js.org/plugins/hot-module-replacement-plugin/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd jc gy z fp nb fr fs nc fu fw ja bi translated">HotModuleReplacementPlugin | web pack</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">webpack是一个模块捆绑器。它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但它也…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">webpack.js.org</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ix mw"/></div></div></a></div><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="14f3" class="mk kx jb mg b gy ml mm l mn mo">config.plugins = config.plugins.concat([<br/> <strong class="mg jc">new</strong> webpack.optimize.OccurenceOrderPlugin(),<br/> <strong class="mg jc">new</strong> webpack.<a class="ae lz" href="https://www.codota.com/code/javascript/functions/webpack/HotModuleReplacementPlugin" rel="noopener ugc nofollow" target="_blank"><strong class="mg jc">HotModuleReplacementPlugin</strong></a>(),<br/> <strong class="mg jc">new</strong> webpack.NoErrorsPlugin()<br/>]);</span></pre><h1 id="8af3" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 7。文件哈希</strong></h1><p id="24b3" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka jc"> Hash </strong>:与整个项目的构建相关，只要修改项目文件，整个项目构建的Hash值就会改变</p><p id="6f5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> Chunkhash </strong>:与Webpack打包的组块有关。不同的条目会产生不同的chunkhash。</p><p id="d0b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> Contenthash </strong>:根据文件内容定义hash。如果文件的内容不变，contenthash也不变</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="56b6" class="mk kx jb mg b gy ml mm l mn mo">module.exports = {<br/>  entry: {<br/>  app: './scr/app.js',<br/>  search: './src/search.js'<br/>},<br/>  output: {<br/>  filename: '[name][chunkhash:8].js',<br/>  path:__dirname + '/dist'<br/>  }<br/>}</span></pre><h1 id="0c47" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 8。CSS自动修复</strong></h1><p id="abe9" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">postcss中的autoprefixer可以用来给CSS3中一些需要兼容编写的属性添加响应前缀，这样可以节省我们很多时间因为它也是一个加载器，我们也需要先安装它:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fc0b" class="mk kx jb mg b gy ml mm l mn mo">npm i postcss-loader autoprefixer -D</span></pre><p id="ed4c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建<strong class="ka jc"> postcss.config.js </strong>并导入webpack配置:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2271" class="mk kx jb mg b gy ml mm l mn mo">module.exports = { plugins: [require('autoprefixer')]  }</span></pre><p id="0ded" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3394" class="mk kx jb mg b gy ml mm l mn mo">module.exports = {<br/>    module: {<br/>        rules: [<br/>            {<br/>                test: /\.css$/,<br/>                use: ['style-loader', 'css-loader', 'postcss-loader']<br/>            }<br/>        ]<br/>    }<br/>}</span></pre><h1 id="5d79" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 9。Webpack捆绑包分析器</strong></h1><p id="86a0" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用交互式可缩放树状图可视化webpack输出文件的大小。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/99d376fb52c8d90b677c5e1060a39ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cQGCCuaVDpXOgpRd.gif"/></div></div></figure><p id="1292" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="903d" class="mk kx jb mg b gy ml mm l mn mo"># NPM<br/>npm install --save-dev webpack-bundle-analyzer<br/># Yarn<br/>yarn add -D webpack-bundle-analyzer</span></pre><p id="eaf7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="46c1" class="mk kx jb mg b gy ml mm l mn mo">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;<br/><br/>module.exports = {<br/>  plugins: [<br/>    new BundleAnalyzerPlugin()<br/>  ]<br/>}</span></pre><h1 id="3f55" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak"> 10。进度条Webpack插件</strong></h1><figure class="mb mc md me gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/dda4787a2f9416d83cb997d8329a6fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/0*lI54xycS-X7zq7YO.gif"/></div></figure><p id="a1ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1ff7" class="mk kx jb mg b gy ml mm l mn mo">npm i -D progress-bar-webpack-plugin</span></pre><p id="6835" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将配置添加到webpack:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0a74" class="mk kx jb mg b gy ml mm l mn mo">var ProgressBarPlugin <strong class="mg jc">=</strong> require('progress-bar-webpack-plugin');</span><span id="6d6c" class="mk kx jb mg b gy mu mm l mn mo">plugins<strong class="mg jc">:</strong> [</span><span id="2219" class="mk kx jb mg b gy mu mm l mn mo"><strong class="mg jc">new</strong> ProgressBarPlugin({      <br/>    format: 'build [:bar] ' + chalk.green.bold(':percent') + '(:elapsed seconds)', clear: false    })</span><span id="8766" class="mk kx jb mg b gy mu mm l mn mo">]</span></pre><p id="3620" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我们已经完成了基本的配置。但这并不完美，或者有时候，我们会有一些其他的需求。下一篇关于webpack配置的文章将介绍一些其他情况。感谢您的阅读。</p><p id="f07c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">更多内容请看</em><a class="ae lz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>