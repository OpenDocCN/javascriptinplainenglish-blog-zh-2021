<html>
<head>
<title>How To Measure And Optimize The Performance Of A Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何衡量和优化Web应用程序的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-measure-and-optimize-the-performance-of-a-web-app-52beb20aabba?source=collection_archive---------8-----------------------#2021-02-01">https://javascript.plainenglish.io/how-to-measure-and-optimize-the-performance-of-a-web-app-52beb20aabba?source=collection_archive---------8-----------------------#2021-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c27122fb1813d098f6836dab8bee5160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BSmQec8cRCBT_Tam.jpg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="46ea" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="la">原载于</em><a class="ae lb" href="https://leandrotk.github.io/2021/01/optimizing-the-performance-of-a-react-progressive-web-app/index.html" rel="noopener ugc nofollow" target="_blank"><em class="la">https://leandrotk . github . io</em></a></p><p id="48f2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在最后一个季度，我开始在一个有着不同业务目标的新团队中工作。这是一个伟大的团队，一起工作真的很有趣，我们做了很多令人惊叹的工作，我对此感到自豪。</p><p id="967a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在过去的4个月中，我们管理的一个项目是我们正在开发的应用程序的web性能改进。这篇文章旨在分享我们在这个过程中所做的改进和学到的东西。</p><h1 id="14e8" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">语境</h1><p id="2b28" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">在我们开始讨论web性能之前，展示这项工作背后的背景是很重要的。</p><p id="6c35" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我想提到的第一件事是，我们开始工作的应用程序(PWA)拥有(实际上它仍然拥有)2年前编写的代码库的大部分。是一个使用Webpack 3，Babel 6，react-redux 5等等的React PWA。少量挂钩。大多数类组件。</p><p id="d868" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">该项目没有真正的团队所有权或负责的工程师来照顾代码库。不同的团队需要在PWA中到处添加功能，但实际上并不拥有代码库。效果:代码库在特性、错误和技术债务方面不断增长，但是它既没有改进也没有重构。</p><p id="bafc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在这种情况下，我们已经有很多空间来改进代码库。这个项目是我们的焦点，也开始成为我们自己的责任。</p><p id="8bec" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我和我的同事成为了这个项目的“服务所有者”。“服务所有者”的想法是某个人(或者在本例中是两个人)作为焦点来清除疑问、管理技术债务、问题、bug等。基本上，负责一个项目的人。</p><p id="cf7e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的团队致力于为房屋所有者(房东)提供最佳体验:让他们更容易理解产品，注册新的房屋或公寓，管理房屋的出租和出售。</p><p id="25cb" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">与产品经理和设计师一起，我们创建了我们希望在该季度发布的功能路线图。同时，性能是为用户提供良好体验的关键因素。我们可以从两个基本的“指标”开始:页面加载和交互时间。这些指标和用户体验之间存在相关性(有时是因果关系)。</p><p id="491a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们还希望进行A/B测试，并确保性能不是一个会影响这些测试结果的变量。基本上，我们希望防止性能退化，以免影响测试(但是我们需要度量标准——我们很快就会谈到它！).</p><p id="db12" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的团队不是性能专家团队。但该公司有一个名为核心UX的团队，主要专注于网络性能。在2020年前三个季度拥有前端性能经验的团队。</p><h1 id="9ebd" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">该过程</h1><p id="2a47" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">我们的第一个想法是了解我们想要跟踪和关注的指标，并执行“发现”任务，以了解潜在的问题以及我们如何改善用户体验和应用性能。除此之外，我们还尝试与web性能团队建立一个渠道来进行讨论，向他们学习，提出问题，并尝试发现性能问题并解决它们。</p><p id="2399" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">因此，我们开设了一个新的Slack频道来缓解整个想法，并与他们举行两周一次的会议，以展示我们正在做什么，他们正在做什么，讨论提高性能的可能性，并有时间提出问题和展开讨论。</p><p id="0850" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">有了这种开放的关系，我们可以学得更快，并优先考虑低挂水果类的任务，以获得更快的结果，而几乎不用付出任何努力。我们将在性能改进部分深入讨论这一点。</p><p id="e0b7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">整个过程都有文档记录:会议、我们的学习、我们的发现以及性能修复。</p><h1 id="50b4" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">度量和测量</h1><p id="ed41" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">我们第一次讨论了我们想要跟踪的指标，我的团队开始了解更多。对于不太熟悉的我们来说，起初，这是一堆我们并不真正理解的缩写词。FCP，LCP，FID？那是什么？</p><p id="3454" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">为了理解这些术语，我喜欢先理解用户体验指标，因为它们都是联系在一起的。</p><p id="1aaf" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">因此，对于用户体验指标，我喜欢谷歌的这篇以用户为中心的性能指标文章，其中定义了这些指标:</p><ul class=""><li id="99f8" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io">感知加载速度</strong>:一个页面可以多快地加载并呈现所有的视觉元素到屏幕上。</li><li id="4076" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">加载&amp;运行时响应</strong>:页面加载和执行任何所需JavaScript代码的速度，以便组件快速响应用户交互</li><li id="783f" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">视觉稳定性</strong>:页面上的元素会以用户意想不到的方式移动，并潜在地干扰他们的交互吗？</li><li id="6942" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">平滑度:过渡和动画是否以一致的帧速率呈现，并且从一个状态流畅地过渡到下一个状态？</li></ul><p id="0bf2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我喜欢这个，因为它很有共鸣。作为网站用户，我们可以理解这些指标(以及在使用一些“性能差”的网站时可能遇到的挫折)。</p><p id="725a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这也很有趣，因为我们可以将以用户为中心的指标映射到我们常见的性能指标。</p><ul class=""><li id="9424" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io">First contentful paint(FCP)</strong>:测量从页面开始加载到页面内容的任何部分呈现在屏幕上的时间。</li><li id="e4cb" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">最大内容绘制(LCP) </strong>:测量从页面开始加载到屏幕上呈现最大文本块或图像元素的时间。</li><li id="c0ff" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">首次输入延迟(FID) </strong>:测量从用户第一次与您的网站交互(即，当他们点击链接、点击按钮或使用自定义的JavaScript支持的控件)到浏览器实际能够响应交互的时间。</li><li id="eea7" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">交互时间(TTI) </strong>:测量从页面开始加载到可视化呈现、加载初始脚本(如果有)以及能够快速可靠地响应用户输入的时间。</li><li id="6486" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">总阻塞时间(TBT) </strong>:测量FCP和TTI之间主线程被阻塞足够长时间以阻止输入响应的总时间。</li><li id="5da7" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">累积布局偏移(CLS) </strong>:测量从页面开始加载到其生命周期状态变为隐藏之间发生的所有意外布局偏移的累积分数。</li></ul><p id="716a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我构建了一个简单的表格，将性能指标映射到以用户为中心的指标，以便更容易理解每个缩写。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/d0d5c60cd540ba76f197c8433951b450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KuaJnDzHxYbJLS3M.png"/></div></div></figure><p id="89d8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">正如我前面说过的，这种关系非常有趣，让我们不仅关注比特和字节，还关注整体的用户体验。</p><h1 id="6e9d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">工具、审计和知识共享</h1><p id="bf23" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">在对用户体验和性能指标有了更好的理解之后，我们想开始跟踪它们。实验室和现场指标是有区别的。根据谷歌的说法:</p><ul class=""><li id="4044" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io">实验室指标:</strong>使用工具在一致、受控的环境中模拟页面负载。</li><li id="1103" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">字段指标</strong>:关于实际加载页面并与之交互的真实用户。</li></ul><h1 id="4e71" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">实验室指标</h1><p id="10b0" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">对于实验室指标，我们使用<a class="ae lb" href="https://github.com/GoogleChrome/lighthouse-ci" rel="noopener ugc nofollow" target="_blank"> Lighthouse CI </a>在CI中设置Lighthouse。因此，对于每个打开的Pull请求(PR ),我们运行Lighthouse来收集与性能相关的数据，并锁定PR，直到我们修复了性能问题。</p><p id="cc66" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">使用这个工具，我们可以验证PWA的各个方面(可访问性、SEO、最佳实践和性能)，而且还可以添加断言，以便在超出我们设置的预算阈值时打破PRs。</p><p id="44e0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">例如，我们可以添加与JavaScript和图像大小(以字节为单位)相关的断言:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4e7b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这个JavaScript对象是我们可以用来收集关于性能的不同信息的配置的一部分。为了更好地理解Lighthouse CI的配置，请看一下这个文档:<a class="ae lb" href="https://github.com/GoogleChrome/lighthouse-ci/blob/master/docs/configuration.md" rel="noopener ugc nofollow" target="_blank"> Lighthouse CI配置</a>。</p><p id="17d7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们正在使用的另一个非常酷的工具是速度曲线。设置和开始收集数据非常简单。这个工具对“未登录页面”更有效，因为我们添加了网站的URL，并且基于网站负载和交互，它将收集性能指标。</p><p id="2cca" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">速度曲线仪表板非常灵活，可以显示(或隐藏)我们想要关注的指标。在我们的例子中，我们希望看到JavaScript总大小、第一次内容丰富的绘制、最大内容丰富的绘制、累积布局移位、JS总阻塞时间、后端(TTFB)时间和Lighthouse性能分数的变化。</p><p id="021d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这对于我们的登陆和主页来说非常酷。</p><p id="0df2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们设置的最后一个工具是性能团队构建的内部工具。这是一款分析应用捆绑包的工具，它现在有3个主要功能:</p><ul class=""><li id="05f6" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io"> Bundle Analyze Report </strong>:收集并保存bundle analyzer HTML结果。</li><li id="52ce" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">捆绑包预算</strong>:设置预算配置，为捆绑包大小添加阈值。如果一个包的大小超过了阈值，它就会破坏PR。</li><li id="a66f" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io"> Bundle Changes: </strong>显示PR和主(或主要)分支之间的Bundle大小变化。它帮助我们很容易地回答“它增加/减少了X的包大小吗？”</li></ul><p id="e43b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这个工具在我们的CI管道中为每个PR运行，结果显示在Github PR中(它使用<a class="ae lb" href="https://github.com/danger/danger-js" rel="noopener ugc nofollow" target="_blank">危险</a>在它后面)。</p><p id="3760" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这些工具非常有趣，因为</p><ul class=""><li id="ba45" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated">它帮助我们防止性能退化</li><li id="8533" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated">它还创造了关于网络性能、其度量标准和共享知识的意识</li></ul><h1 id="cdce" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">字段度量</h1><p id="f626" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">目前，我们正在使用<a class="ae lb" href="https://www.instana.com/" rel="noopener ugc nofollow" target="_blank"> Instana </a>来收集真实的用户性能相关数据。</p><p id="d758" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">真实用户监控(RUM)的下一步是在我们的应用中跟踪更多的用户行为，以在PWA流中收集<a class="ae lb" href="https://github.com/GoogleChrome/web-vitals" rel="noopener ugc nofollow" target="_blank"> web生命指标</a>。</p><h1 id="b307" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">性能改进</h1><p id="b9f8" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">在这一节中，我想详细介绍我们为提高应用程序的性能和用户体验所做的每个发现和修复背后的过程。</p><h1 id="152d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">登录页面</h1><p id="11c1" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">我们从登录页面开始。第一个动作是使用<a class="ae lb" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> Webpack Bundle Analyzer </a>分析JavaScript bundle的大小。</p><p id="5546" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">补充说明</strong>:两年前，负责登录页面的团队决定使用react工具开发登录页面，但在构建时，我们从应用程序中删除了react，以减少登录页面中的包大小。</p><p id="642c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这是我们得到的结果:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/1f6f5182ceb728a407eaa44ca145453c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jD5MJO925qnw97PG.png"/></div></div></figure><p id="6bf9" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们可以在这里分析很多东西，但是引起我们注意的是我们的登录页面包中的React库。正如我上面所写的，在边注中，React没有被用于生产，我们无意中在生产中提供了它，使我们的用户无需这样做就可以下载库。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f564" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们在React组件文件中有一个常量。我们在登录页面中导入了这个常量。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0d46" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">所以引入这个常数，我们也引入了React。</p><p id="380f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">一个简单的解决方法是将这个常量从React组件文件中分离出来，并从这个新文件中导入它。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f94c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">并从新文件中导入常量:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e147" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">让我们看看这一变化对包大小的影响:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/a5a22930ce472ef85dfb73963866c147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5YL1354yhpU-g4YQ.png"/></div></div></figure><p id="5a6e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们减少了95KB！在仔细分析了我们的包之后，想到我们可以对一个小的变化产生巨大的影响，这很有趣。这将是我们在本文余下部分所做的每一项改进背后的过程:</p><ol class=""><li id="92f4" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz nc ml mm mn bi translated">分析捆绑包</li><li id="e14c" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz nc ml mm mn bi translated">修复性能问题</li><li id="2a6f" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz nc ml mm mn bi translated">收集结果并跟踪指标</li></ol><p id="5cd6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们再次运行捆绑包分析器，得到了这个结果:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/7dc9554170b3480250d6460445cba31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-B4Q3b7XDiaLFHq-.png"/></div></div></figure><p id="9156" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">首先引起我们注意的是<code class="fe ne nf ng nh b">appboy.min.js</code>和<code class="fe ne nf ng nh b">transit.js</code>库。<code class="fe ne nf ng nh b">appboy</code>是Braze，一个我们用于通信的库，<code class="fe ne nf ng nh b">transit</code>是一个将JSON格式数据转换成我们的应用程序状态的库。</p><p id="466c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe ne nf ng nh b">Braze</code>库与React库非常相似。这是一个文件中的<code class="fe ne nf ng nh b">import</code>语句，登录页面正在使用它，但并没有真正使用<code class="fe ne nf ng nh b">Braze</code>。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b591" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">它在文件中导入Braze并使用实例作为函数的默认值。简单的解决方案是删除import语句，并强制每个使用<code class="fe ne nf ng nh b">aFunction</code>函数的地方都要通过braze实例。因此，我们不需要导入Braze并为参数添加默认值:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7532" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">再次运行包分析器，我们得到了一个惊人的结果。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/d32e7fc15adda5bf59543f20ea101c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-vYE_W2VVnLvkJLv.png"/></div></div></figure><p id="dd7f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">AnnounceYourHouse登录页面已缩减至90 KB。我们可以移除将近50%的主着陆舱。</p><p id="ab32" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们还改进了价格建议登录页面的捆绑包大小。从115 KB到4 KB是一个惊人的结果。</p><p id="b0a3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">对于<code class="fe ne nf ng nh b">transit</code>库，我们做了一个临时的解决方案。它导入库来转换保存在本地存储中的字符串JSON，以便从该对象的单个属性中获取信息。</p><p id="20a2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">临时的解决方案是验证字符串是否包含我们想要的信息，并且不再需要使用<code class="fe ne nf ng nh b">transit</code>库。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/4eef574f3aa4f4498f9d066b0e6ba2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CS1GzTfg08nmA5g_.png"/></div></div></figure><p id="4a88" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们可以大大改善主平台的管束尺寸。去掉了几乎50%的束。</p><p id="58cd" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">正如我们在指标部分看到的，我们已经设置了速度曲线来跟踪一些页面在整个过程中的性能。因此，对于我们在应用程序中所做的每一项改进，我们都会跟踪这些工具中的指标。</p><p id="c56d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">登录页面的总大小急剧减少:-2.16 MB。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/98871bbfb1135f4edc732a20538c5413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SXt3vo6rogPXf5_v.png"/></div></div></figure><p id="2694" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">灯塔的表现得分从73分到97分:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/d713ca01e35300913d2eb3b1e1577ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A5K1bpLAK5So_L0W.png"/></div></div></figure><p id="1119" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">最大的内容丰富的油漆在1秒内改进:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/d37f3bf59e291931867cf6c27ea19f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1pQ5o8wv_4duOZA8.png"/></div></div></figure><h1 id="1ce7" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">供应商区块</h1><p id="12bc" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">当运行<code class="fe ne nf ng nh b">npm run bundle:analyzer</code>时，我们还注意到我们的供应商块中有很大的依赖性。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/e395f6c91a98218627537e17117a68da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_zwewAJNkbGUzHUu.png"/></div></div></figure><p id="9649" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在供应商块中，我们注意到了来自Material UI的所有图标。每次用户进入网站，如果块没有缓存在浏览器中，它将需要下载整个块。如果下载量很大，会影响性能，进而影响用户体验。</p><p id="1b5f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这是在反应组件中导入材质用户界面图标时的一个<a class="ae lb" href="https://material-ui.com/guides/minimizing-bundle-size/" rel="noopener ugc nofollow" target="_blank">常见问题</a>。</p><p id="f009" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的组件之一是使用内部组件库，该库使用“命名导入”样式来导入材料用户界面图标。在没有合适的巴贝尔插件的情况下，这也将剩余的未使用图标添加到了供应商块中。</p><p id="a9aa" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们提出了两种解决方案:</p><ol class=""><li id="c758" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz nc ml mm mn bi translated">修复从这个内部组件库的导入，我们已经停止使用命名导入。</li><li id="9266" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz nc ml mm mn bi translated">添加巴贝尔插件，并配置应用程序不添加未使用的模块。</li></ol><p id="b4b8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">由于这个内部组件库是我们设计系统的第一个也是被弃用的版本，我们不想继续维护它。最好的方法是不再使用这个库，并将所有的代码库转移到使用新的设计系统库(我们正在开发这个库！).</p><p id="7482" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这个性能项目不是我们本季度的主要项目，所以在sprint中我们没有太多时间关注它。巴贝尔插件在当时对我们来说是一个更简单明了的解决方案。</p><p id="94da" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们基本上需要添加这个新的巴别塔插件<code class="fe ne nf ng nh b">babel-plugin-transform-imports</code>并配置<code class="fe ne nf ng nh b">babelrc</code>:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e453" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">有了它，我们就可以防止在供应商块中完全导入库。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/56362927c3bd723c1a0ea636906eabce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*obPytLXC91Oe4RWw.png"/></div></div></figure><p id="f525" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">供应商变得越来越小。我们在主要部分也有一些影响(下一部分将很快讨论)。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/0a17716d3d952e360954228c6af91e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fAiLNFFgklZt6QGg.png"/></div></div></figure><p id="86da" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">通过这种简单的分析和配置，我们可以将供应商块减少50%以上(仍然是2.83 MB，可以改进)。我们以后再说！)和28%的主要部分。</p><p id="1c52" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">对整个应用程序来说，这是一个巨大的进步，因为这些块被下载到了每一页上，如果没有缓存在浏览器中的话。</p><h1 id="5b8c" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">主组块</h1><p id="2458" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">主块在应用程序的所有部分中都有一些公共模块。但是在运行束分析器之后，我们得到了这个:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cb47aa87f8cedb65f483e6768ec7f2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EugmKuTXMHZZ6TDb.png"/></div></div></figure><p id="7f03" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">主块是捆绑包中的左下块。引起我们注意的一件事是捆绑包中的一些容器和组件。为什么有些组件只针对一个页面，而我们却让我们的用户下载整个主要部分？</p><p id="4d9e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">问题很简单:我们的代码拆分工作不正常。</p><p id="da52" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们最初的想法是确保所有路由都有动态导入，以便我们的组件在每个路由器入口点进行代码分割。这就是问题所在:并不是所有的路由入口点都有可加载的组件，所以它们被加入到主块中，而不是为特定的路由和页面创建自己的块。</p><p id="6a68" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在这个应用程序中，我们当时使用的是<code class="fe ne nf ng nh b">react-loadable</code>，所以想法是简单地创建这些可加载项:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8bf9" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">并将它们用于每个路径入口点。</p><p id="cb6d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">运行bundle analyzer，我们得到了这个:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2e1618144cb2cdf3e7b449fc793e5df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V7qCAjmhrT-MOToo.png"/></div></div></figure><p id="2925" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">主块要小得多，Webpack也创建了更多特定于页面的块。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/2a390f126cf4238a2da238a9a65aee0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNKMyvfVWrX6u5kA.png"/></div></div></figure><p id="554c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">结果是巨大的。主要部分缩小了50%以上，供应商部分也减少了29%。</p><h1 id="d050" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">缓存最大的依赖项</h1><p id="748a" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">阅读本文时，您可能会在我们的包中看到一些大的依赖项，如firebase、braze、immutable等等。</p><p id="f9a0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">每次我们发布新产品时，我们的构建系统都会生成一个新的捆绑包。如果与供应商块相关的任何内容发生变化，Webpack将为该块生成一个新的散列。所以浏览器不会有这个块的缓存版本，它会让用户再次下载它。</p><p id="f2d0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">但是有时候，或者大多数时候，我们并没有真正改变这些最大的依赖关系(只有当依赖关系升级时)，我们让我们的用户为这一大块买单。</p><p id="086a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们的想法是将这些最大的依赖拆分到它自己的块中，并确保浏览器有这个块的缓存版本，并且用户在需要它之前不需要再次下载它。</p><p id="e158" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">因为我们当时使用的是Webpack 3，所以我们需要使用<code class="fe ne nf ng nh b">CommonsChunkPlugin</code>来将这些依赖项拆分到它自己的块中。</p><p id="d7f8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们创建了所有最大依赖项的列表:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/52a376d8ff7c71a3014c837e2ac2bddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/0*sW5Iz1f2ztAw3hOl.png"/></div></figure><p id="5877" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在我们的Webpack配置中，它也被映射为列表数据结构:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b712" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">与<code class="fe ne nf ng nh b">CommonsChunkPlugin</code>一起，我们只需要遍历这个列表来创建每个块。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/7cd5b88fed2357ae2d70c349dd74caa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wPJr0lkLm_WwO909.png"/></div></div></figure><p id="7dc3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们可以看到，供应商块变得更小，一些新的块被创建。</p><p id="f8e5" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">运行应用程序时，我们还可以测试每个独立块的下载。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/ebe90499ed824cc69c791335dff2c004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4DasXAAcmvSsD_85.png"/></div></div></figure><p id="b391" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们得到了一个非常酷的结果:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/5907eac7604ede786a5684a0774fc034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ZU7MgQVMK8eCd5v.png"/></div></div></figure><p id="0578" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">用户仍然需要下载依赖项，但在第一次下载后，浏览器会缓存它们，直到我们删除它们的版本，它们才需要再次下载。如果我们更改供应商块，Webpack只会为供应商生成一个新的散列，而不会更改其他依赖项。</p><p id="2d14" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们在速度曲线仪表板上看到了一些不错的改进:</p><p id="2cf2" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">正如所料，我们看到了JavaScript大小的巨大改进:-1.43 MB</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/0c59360632a7cc40cbb030ca6429dc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pG_JLxUTs3-HhFmF.png"/></div></div></figure><p id="8210" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">减少JavaScript大小还会影响用户被阻止与页面交互的总时间:-1.2s</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/7f266471c9d665d00e61f4e354b5ecac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*35FPbXloVobdYwYT.png"/></div></div></figure><p id="3aef" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">速度指数是一个显示网页内容可见填充速度的指标。我们改进了页面，加载速度加快了2.2s。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/cd6dc65b310b3372ddff77e543058730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BXhk_ifJyY0WOQOw.png"/></div></div></figure><p id="1345" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">最有争议的油漆从6s变成了3.75s</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/e0d52bb3bd3a3f80bc0ada3dd695ef52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F5_91Y2q4kooFoQE.png"/></div></div></figure><h1 id="1def" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">概述</h1><p id="e109" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">为了概括我们在本文中所看到的内容，让我们来看看我们在这次旅程中所做的事情列表:</p><ul class=""><li id="f097" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io">度量</strong>:度量是绩效改进的基础。</li><li id="8b8c" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">锁</strong>:防止退步&amp;缩放性能知识。</li><li id="6f51" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">分析</strong>:用数据和指标，分析可能出现的问题。</li><li id="747a" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">改进</strong>:代码。</li><li id="13b1" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">冲击</strong>:测量前后画面。</li></ul><p id="8737" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果可能的话，我还会建议与在这一性能领域更有经验的人交谈。</p><h1 id="f1a4" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">后续步骤</h1><p id="ce28" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">我们有更多的事情要做，但在最后一个季度，我们没有时间专注于这些事情。这是我现在想到的一系列事情:</p><ul class=""><li id="6da9" class="mf mg in ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke io">更多指标</strong>:记录页面的rum、ux指标(参与度、跳出率)、业务指标(转化率)。</li><li id="e191" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">管理请求</strong>:服务器请求缓存。</li><li id="5129" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">更多分析</strong>:后端、组块、预取等。</li><li id="cca0" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">可移除依赖关系</strong>:分析可以移除或替换的大依赖关系</li><li id="f0da" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io"> Webpack升级</strong> : bump到V5——缓存、优化、代码拆分、树抖动。</li><li id="69e2" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io"> Webpack优化</strong>:需要构建得更快。</li><li id="e7f1" class="mf mg in ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke io">不断学习</strong>:多学习发现更多机会。</li></ul><h1 id="399e" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">资源</h1><p id="54fb" class="pw-post-body-paragraph kc kd in ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ig bi translated">我有一些我在做这个项目的过程中使用的资源。希望对你也有帮助:<a class="ae lb" href="https://github.com/leandrotk/web-performance-studies" rel="noopener ugc nofollow" target="_blank"> Web性能研究</a>。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="d704" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><em class="la">原载于2021年1月21日</em><a class="ae lb" href="https://leandrotk.github.io/2021/01/optimizing-the-performance-of-a-react-progressive-web-app/index.html" rel="noopener ugc nofollow" target="_blank"><em class="la">https://leandrotk . github . io</em></a><em class="la">。</em></p></div></div>    
</body>
</html>