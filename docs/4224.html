<html>
<head>
<title>Keynotes for useEffect (React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用要点效果(反应)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useeffect-key-notes-react-8fa1b3d92ce4?source=collection_archive---------4-----------------------#2021-08-22">https://javascript.plainenglish.io/useeffect-key-notes-react-8fa1b3d92ce4?source=collection_archive---------4-----------------------#2021-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/98a124a84a5854e5cfb1b80faa5ed7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq_xUySrcOf8k4ZwSeMzDw.jpeg"/></div></div></figure><p id="9067" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在使用React的钩子系统，那么您正在使用useEffect生命周期方法来代替基于类的组件通常使用的componentDidMount方法。在这种方法中，几乎总是有与您发出的HTTP请求相关的代码。这篇文章的目的是展示和解释一些关于useEffect的简洁要点，为你的应用程序增添趣味。</p><h2 id="4553" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak"> useEffect的第二个参数:</strong></h2><p id="5894" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">与我在以前的文章中展示的每个示例一样，它将采用简单搜索组件的形式:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/a87cb7d7a48f21aa0c6809a033ca68f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnRyQO8SLP1SK-9HyJ9xMQ.png"/></div></div></figure><p id="26d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意在最后还有第二个参数<code class="fe lw lx ly lz b">[term]</code>。下面是useEffect的第二个参数的规则:</p><ul class=""><li id="b208" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">第二个参数只能是以下三种情况之一:<strong class="jx io">空白</strong>、空数组<strong class="jx io">或元素在</strong>内的<strong class="jx io">数组。</strong></li><li id="4508" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">如果第二个参数是<strong class="jx io"> blank </strong>，那么useEffect将只在组件的初始渲染上运行。</li><li id="443b" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">如果第二个参数是一个<strong class="jx io">空数组</strong>，那么useEffect将在初始渲染和每次重新渲染时运行</li><li id="2ad3" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">如果第二个参数是一个填充了元素的<strong class="jx io">数组，那么如果</strong>数组中的数据发生变化，useEffect将在初始渲染和每次重新渲染<strong class="jx io">时运行。</strong></li></ul><p id="1b4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这与搜索功能有什么关系？</p><p id="1e2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看一下第二个参数，它是一个数组，里面有一个元素叫做<code class="fe lw lx ly lz b">term</code>。在这个假想的应用程序中的某个地方，有一个<code class="fe lw lx ly lz b">onChange</code>事件记录着这个术语(每个字符的变化)。</p><p id="d98c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个参数允许我们在不需要<code class="fe lw lx ly lz b">onSubmit</code>事件的情况下发出请求。这是一个给你的应用程序添加一些特色的好方法。每次按键都会自动为你搜索。</p><p id="afad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。useEffect的返回语句:</strong></p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/ddfc1d1a12bd29122470cc152350c0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*1DUnkYb5ywaA9Q8uaW_hXA.png"/></div></figure><p id="cd27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lw lx ly lz b">return</code>的使用效果非常独特。它只有一条规则:</p><ul class=""><li id="a59f" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">只能返回一个箭头函数。</li></ul><p id="c743" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初呈现组件时，不会调用<code class="fe lw lx ly lz b">return</code>，但会保存对函数的引用。当组件重新呈现时，也就是在其他任何东西运行之前调用返回的时候。用<code class="fe lw lx ly lz b">console.log</code>自己试试。</p><p id="ee4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个怎么用？</p><p id="2e1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于示例中的搜索组件，每次按键都会执行一次搜索，这会产生大量您不一定想发出的请求。为了解决这个问题，你可以做一个简单的<code class="fe lw lx ly lz b">setTimeOut</code>来延迟按键后的搜索时间。但是，这样做的问题是，计时器不会每次按键都重置，而是从第一次按键开始，并在该按键的准确时间结束。因此，如果你键入“电动汽车”，它可能会在中间进行搜索，只搜索“电动”，因为计时器仍在运行。</p><p id="ea73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们如何解决这个问题？</p><p id="878f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，你可以增加计时器的持续时间或者打得更快。但是在每次重新渲染后清除它会更实际。这就是上面例子中的return语句的作用。每次按键后，计时器会重置，这样你就可以输入长单词/句子，比如“我如何使用useEffect？”而不需要计时器在中间调用搜索。试试看！</p><p id="0c6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">更多内容尽在</em><a class="ae mq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="mp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>