<html>
<head>
<title>Inheritance Vs. Composition in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的继承与组合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inheritance-vs-composition-in-javascript-174142a25bc3?source=collection_archive---------13-----------------------#2021-09-14">https://javascript.plainenglish.io/inheritance-vs-composition-in-javascript-174142a25bc3?source=collection_archive---------13-----------------------#2021-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="bcbc" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">代码速赢</h2><div class=""/><div class=""><h2 id="e958" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">两种面向对象编程技术的简要比较。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/36e636d925d353295023feb3e62b016b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jIZL8HJqrsuu4lPo"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@christian_crocker?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Crocker</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d71" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当我开始学习编码时，使用<strong class="le ix">继承</strong>向我解释了面向对象编程，这是一种使用父子层次结构组织类的技术。子类从其父类获得<strong class="le ix">状态</strong>和<strong class="le ix">行为</strong>，然后可以添加额外的状态和行为，变得更加具体。</p><p id="1223" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">例如:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5c1d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在上面的例子中，<code class="fe ma mb mc md b">Jedi</code>和<code class="fe ma mb mc md b">Sith</code>类都可以使用<code class="fe ma mb mc md b">forcePush</code>方法，因为它们都继承了它们共享的父类<code class="fe ma mb mc md b">ForceUser</code>的能力。然而，只有<code class="fe ma mb mc md b">Sith</code>类可以使用<code class="fe ma mb mc md b">forceChoke</code>方法，只有<code class="fe ma mb mc md b">Jedi</code>类可以使用<code class="fe ma mb mc md b">mindTrick</code>方法。</p><h2 id="18a2" class="me mf in bd mg mh mi dn mj mk ml dp mm ll mn mo mp lp mq mr ms lt mt mu mv it bi translated"><em class="mw">这种继承方式有什么好处？</em></h2><ul class=""><li id="d316" class="mx my in le b lf mz li na ll nb lp nc lt nd lx ne nf ng nh bi translated">我不必重写<code class="fe ma mb mc md b">forcePush</code>方法，因为它会自动提供给<code class="fe ma mb mc md b">ForceUser</code>类的所有子类。</li><li id="2186" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">我创建了一个代码层次结构，清楚地表示了父母、子女和兄弟姐妹之间的关系。</li></ul><p id="a86d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">但事实是，原力比这更微妙。我严格的等级制度不公平。</p><p id="71af" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当我在高中玩<em class="nn">星球大战绝地武士:绝地学院</em>的时候，绝地大师凯尔·卡塔恩告诉他的学生，绝地武士拥有原力的所有能力。你如何使用这些能力决定了你的定位。</p><p id="ae97" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">也就是说，我显然遇到了继承模型的问题。我无法创造一个能强行窒息的绝地。只有西斯类有那个能力。蹩脚。</p><p id="9626" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我:</p><ul class=""><li id="8ba4" class="mx my in le b lf lg li lj ll no lp np lt nq lx ne nf ng nh bi translated">只需复制一些代码并将<code class="fe ma mb mc md b">forceChoke</code>方法添加到<code class="fe ma mb mc md b">Jedi</code>类中？</li><li id="036d" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">把<code class="fe ma mb mc md b">forceChoke</code>加到<code class="fe ma mb mc md b">ForceUser</code>类就行了？这样，绝地和西斯都继承了它？</li></ul><p id="ad14" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这两种选择都有点糟糕。</p><p id="da86" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">第一个选项意味着我将有两个<code class="fe ma mb mc md b">forceChoke</code>的实现。如果我需要更新那个方法呢？我现在必须在两个地方做。我失去了唯一的真相来源。另外，我复制了代码。一般来说，这通常是值得避免的。</p><p id="52f5" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">第二个选项意味着所有绝地和西斯都可以使用<code class="fe ma mb mc md b">forceChoke</code>。但是实际上有多少绝地武士需要这种能力呢？我现在给了所有绝地一种能力，他们中的大多数人永远不会使用。我正朝着“上帝对象”的方向前进——移动祖先的行为和状态层次，以便更多的子类可以继承它们。那是一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">码气味</a>。</p><p id="7bd3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这就是组合优于继承的论点出现的地方。</p><p id="e629" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">组合是指当你以这样的方式编写代码时，对象/类是按照它们能做什么来组织的，而不是试图完全决定/预测它们现在和将来是什么。</p><p id="cefd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">对于继承，当你第一次计划你的代码时，你必须做猜测。有了组合，你可以在不牺牲灵活性的情况下混合和匹配行为。</p><p id="0e94" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">下面是一个使用函数合成的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6a0f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在上面的例子中:</p><ul class=""><li id="2f95" class="mx my in le b lf lg li lj ll no lp np lt nq lx ne nf ng nh bi translated">我定义了一些函数，这些函数返回(作为对象文字)我想要组合在一起的行为。</li><li id="a649" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">我定义了一个<code class="fe ma mb mc md b">ForceUser</code>函数，给它传递了一个名字，并将这个名字保存在一个名为<code class="fe ma mb mc md b">state</code>的对象中。</li><li id="cae6" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated"><code class="fe ma mb mc md b">ForceUser</code>返回一个对象(使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank"> spread语法</a>)，由我想要提供的行为组成。现在，<code class="fe ma mb mc md b">kyle</code>是一个拥有我想要的所有行为的对象。而且，由于一个<a class="ae lb" href="https://medium.com/swlh/quick-wins-with-code-closures-in-javascript-deda4113055c" rel="noopener">闭包</a>，这些行为都可以永久地引用来自<code class="fe ma mb mc md b">state</code>对象的任何值。</li></ul><p id="eb44" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我现在有了一个<code class="fe ma mb mc md b">ForceUser</code>的实现，只有它需要的行为。</p><p id="492c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们不再受绝地、西斯等概念的限制。</p><p id="2198" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我在互联网上已经看到了前面例子的很多变体。我很少发现在使用ES6类语法的同时使用复合的例子。</p><p id="d686" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我想尝试一下如何做到这一点。如果这对你有帮助，很好。如果这冒犯了你的感情，我道歉。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9384" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在本例中:</p><ul class=""><li id="7534" class="mx my in le b lf lg li lj ll no lp np lt nq lx ne nf ng nh bi translated">我从定义一些函数开始，这些函数将行为作为对象文字返回。我决定将<code class="fe ma mb mc md b">state</code>重命名为<code class="fe ma mb mc md b">self</code>，不过，我会说到的。</li><li id="9f68" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">我定义了一个<code class="fe ma mb mc md b">ForceUser</code>类。注意，我仍然将<code class="fe ma mb mc md b">forcePush</code>定义为该类的一个方法。那是因为我相当有信心一个<code class="fe ma mb mc md b">ForceUser</code>应该永远有那个能力。</li><li id="8b3e" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">为了添加额外的状态和行为，我在构造函数中做了一些设置工作。我创建了一个名为<code class="fe ma mb mc md b">addToClass</code>的方法，它接受状态或行为，并使用<code class="fe ma mb mc md b">this</code>关键字将其添加到类实例中。这是一种低级的帮助方法，当我创建一个类的实例时，它允许我从对象文字中添加状态或行为。</li><li id="ae94" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">当<code class="fe ma mb mc md b">stateObj</code>被传递到<code class="fe ma mb mc md b">addToClass()</code>时，这是非常简单的。然而，当我传递<code class="fe ma mb mc md b">behaviorComposer</code>时，我传递的是一个回调函数。然后在构造函数内部调用它，并通过<code class="fe ma mb mc md b">this</code>传递该实例的上下文。这样，所有行为都可以访问状态。所以无论你在哪里看到引用的<code class="fe ma mb mc md b">self</code>，都等同于<code class="fe ma mb mc md b">this</code>。</li></ul><p id="e3bb" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我现在有一个<code class="fe ma mb mc md b">ForceUser</code>类，它将<code class="fe ma mb mc md b">forcePush</code>赋予每个人，其他行为可以按菜单添加。</p><p id="7cc9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我喜欢这种方法，但是<code class="fe ma mb mc md b">addToClass</code>方法与<code class="fe ma mb mc md b">ForceUser</code>完全无关。我觉得以某种方式分离出来是值得的，实际上我最终使用了继承。将较低级别的功能分离到它自己的父类中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4d7c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我更喜欢这个实现。使用继承来根据抽象层次分离逻辑，似乎是创建父子关系的一个不太好的理由。现在，我的<code class="fe ma mb mc md b">ForceUser</code>课感觉真的很精瘦。在这种情况下，我甚至不需要定义构造函数(有一个默认的用于派生类的构造函数)。</p><p id="5b68" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我还选择将我的<code class="fe ma mb mc md b">behaviorComposer</code>回调参数内联，而不是在我创建类实例的地方之外定义它。那只是个人喜好的事情。</p><h1 id="c3e4" class="nr mf in bd mg ns nt nu mj nv nw nx mm kc ny kd mp kf nz kg ms ki oa kj mv ob bi translated">离别的思绪</h1><ul class=""><li id="60ad" class="mx my in le b lf mz li na ll nb lp nc lt nd lx ne nf ng nh bi translated">我喜欢星球大战。</li><li id="373a" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">比起继承，我更喜欢作曲，但是两者可能都有时间和地点。</li><li id="3ffe" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated">尽管如此，你还是应该坚持写作。希望这篇文章能帮助你理解这样做的一些方法。</li></ul><p id="29e8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">感谢阅读！😄看看我在quickwinswithcode.com的一些早期文章</p></div><div class="ab cl oc od hr oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ig ih ii ij ik"><h2 id="9441" class="me mf in bd mg mh mi dn mj mk ml dp mm ll mn mo mp lp mq mr ms lt mt mu mv it bi translated">资源:</h2><ul class=""><li id="5a3d" class="mx my in le b lf mz li na ll nb lp nc lt nd lx ne nf ng nh bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">码闻</a></li><li id="b086" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">传播语法</a></li><li id="671f" class="mx my in le b lf ni li nj ll nk lp nl lt nm lx ne nf ng nh bi translated"><a class="ae lb" href="https://medium.com/swlh/quick-wins-with-code-closures-in-javascript-deda4113055c" rel="noopener">关闭</a></li></ul><p id="18ed" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><em class="nn">更多内容请看</em><a class="ae lb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="le ix"><em class="nn">plain English . io</em></strong></a></p></div></div>    
</body>
</html>