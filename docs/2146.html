<html>
<head>
<title>Testing code with Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Axios测试代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-closures-with-axios-4423b300541a?source=collection_archive---------18-----------------------#2021-05-05">https://javascript.plainenglish.io/using-closures-with-axios-4423b300541a?source=collection_archive---------18-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/48d53615e2d548b250d2ec131b30c3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOTOJeEOdqfKw8iTrN9SVQ.png"/></div></div></figure><div class=""/><p id="8ec0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我一直致力于与订阅/支付网关的集成(这并不简单，但这是另一篇文章)。</p><p id="189a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望能够测试我的web hook代码，而不需要从网关重复触发事件。我以JSON格式存储传入的事件，这很好——但是我当然需要获取存储的事件并对它们做一些事情。</p><p id="dc7a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想记下我从哪里开始以及如何到达终点可能会很有趣。我已经包括了我在这个过程中所犯的错误，所以如果你读了一点并认为“那不行！”—我可能在下一段中发现了这一点。</p><h2 id="ad24" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">开始</h2><p id="7b99" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">从简单开始——将文件读入一个对象数组，然后循环打印每个事件的一些详细信息，这样我们就知道它加载得很好。</p><p id="e404" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这是测试代码，我将使用readFile 的同步版本<a class="ae lu" href="https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options" rel="noopener ugc nofollow" target="_blank">来保持代码简单——没有回调，我们可以将<code class="fe lv lw lx ly b">readFileSync</code>的结果直接输入到<code class="fe lv lw lx ly b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" rel="noopener ugc nofollow" target="_blank">JSON.parse</a></code>中，就像这样:</a></p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="ae9b" class="kw kx jb ly b gy mh mi l mj mk">const fs = require('fs');<br/><br/>function run()  {<br/>    const json = JSON.parse(fs.readFileSync(__dirname + "/events.json"))<br/><br/>	for (const event of json) {<br/>        console.log("event: ", event.id, event.event_type);<br/>    }<br/>}<br/><br/>run()</span></pre><p id="6fcc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">果然，我们得到了我们所期望的。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="54c0" class="kw kx jb ly b gy mh mi l mj mk">$ node post-events.js<br/>event: 1 Hello<br/>event: 2 World</span></pre><p id="548b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是可行的，但是循环会很快地发布事件。我更倾向于将它们分隔开来——这样更容易观察接收代码，并且我不打算在这一点上对其进行压力测试。</p><h2 id="fdf3" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">逐渐发送它们</h2><p id="29d0" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://nodejs.org/dist/latest-v14.x/docs/api/timers.html#timers_settimeout_callback_delay_args" rel="noopener ugc nofollow" target="_blank">setTimeout</a></code>很好地为将来要执行的函数排队。等待时间最简单的方法是使用数组中的位置。<code class="fe lv lw lx ly b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a></code>构造没有给出索引，所以我们必须使用不同的方法。</p><p id="1bbc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a> </code>既能给我们条目又能给我们索引，所以让我们利用这一点。只是循环发生了变化——文件读取和JSON解析保持不变，所以我不会重复。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="e416" class="kw kx jb ly b gy mh mi l mj mk">json.forEach((event, index) =&gt; {<br/>    console.log(`Event ${event.id}: ${event.event_type}`);<br/>    console.log(`Will delay ${(index + 1) * 1000} ms`);<br/>})</span></pre><p id="2b4d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，我们很好:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2f97" class="kw kx jb ly b gy mh mi l mj mk">$ node post-events.js<br/>Event 1: Hello<br/>Would delay 1000 ms<br/>Event 2: World<br/>Would delay 2000 ms</span></pre><h2 id="f1e7" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行程安排</h2><p id="6f94" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">现在我们只需要安排一些事情。让我们先试试<a class="ae lu" href="https://ronjeffries.com/xprog/articles/practices/pracsimplest/" rel="noopener ugc nofollow" target="_blank">最简单的东西</a>——对于每个事件，将一个以<code class="fe lv lw lx ly b">event</code>为参数的函数排队，以打印出事件id。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="dbd4" class="kw kx jb ly b gy mh mi l mj mk">json.forEach((event, index) =&gt; {<br/>	const timeout = (index + 1) * 1000;<br/>    console.log(`Event ${event.id}: ${event.event_type}`);<br/>    console.log(`Will delay ${timeout} ms`);<br/>	setTimeout(event =&gt; console.log("Posting", event.id), timeout);<br/>})</span></pre><p id="7888" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9ca8" class="kw kx jb ly b gy mh mi l mj mk">$ node post-events.js<br/>Event 1: Hello<br/>Will delay 1000 ms<br/>Event 2: World<br/>Will delay 2000 ms<br/>post-events.js:10<br/>		setTimeout(event =&gt; console.log("Posting", event.id), timeout);<br/>		                                                 ^<br/>TypeError: Cannot read property 'id' of undefined<br/>    at Timeout._onTimeout (post-events.js:10:52)<br/>    at listOnTimeout (node:internal/timers:557:17)<br/>    at processTimers (node:internal/timers:500:7)</span></pre><p id="12b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仔细想想，这是有道理的，我真的应该知道更好。</p><p id="672b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当功能运行时，读取<code class="fe lv lw lx ly b">event</code>参数<strong class="ka jc">。由于超时，函数在循环结束后运行——此时<code class="fe lv lw lx ly b">event</code>不再被定义，这就是我们所看到的。</strong></p><h2 id="a92d" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">关闭</h2><p id="d6a2" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们能做的是创建一个所谓的<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>。一个闭包本质上是一个函数以及它被创建时的环境。幸运的是，JavaScript让这变得简单了。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="23b5" class="kw kx jb ly b gy mh mi l mj mk">function makeFunc(event) {<br/>	console.log("Making func for", event);<br/>    return async function() {<br/>        console.log("Posting", event.event_type);<br/>    }<br/>}</span></pre><p id="4ee6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们循环的另一个版本:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="d403" class="kw kx jb ly b gy mh mi l mj mk">json.forEach((event, index) =&gt; {<br/>	const timeout = (index + 1) * 1000;<br/>    console.log(`Setting timeout for Event ${event.id}; delay ${timeout} ms.`);<br/>	setTimeout(event =&gt; makeFunc(event), timeout);<br/>})</span><span id="d53d" class="kw kx jb ly b gy ml mi l mj mk">$ node post-events.js<br/>Setting timeout for Event 1; delay 1000 ms.<br/>Setting timeout for Event 2; delay 2000 ms.<br/>Making func for undefined<br/>Making func for undefined</span></pre><p id="cb27" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯……那里出了点问题。所发生的是因为我们写了<code class="fe lv lw lx ly b">event =&gt; makeFunc(event)</code>，对<code class="fe lv lw lx ly b">makeFunc</code>的调用没有立即发生，而是被延迟了——这给了我们和以前一样的问题。让我们马上打电话:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="7718" class="kw kx jb ly b gy mh mi l mj mk">json.forEach((event, index) =&gt; {<br/>	const timeout = (index + 1) * 1000;<br/>    console.log(`Setting timeout for Event ${event.id}; delay ${timeout} ms.`);<br/>	setTimeout(makeFunc(event), timeout);<br/>})</span></pre><p id="a18d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看这是怎么做到的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="75c8" class="kw kx jb ly b gy mh mi l mj mk">$ node post-events.js<br/>Setting timeout for Event 1; delay 1000 ms.<br/>Making func for { id: 1, event_type: 'Hello' }<br/>Setting timeout for Event 2; delay 2000 ms.<br/>Making func for { id: 2, event_type: 'World' }<br/>Posting Hello<br/>Posting World</span></pre><h2 id="8b6a" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">帖子请求</h2><p id="b8ba" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这还差不多。我们将使用axios对HTTP端点进行POST。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1ec7" class="kw kx jb ly b gy mh mi l mj mk">const fs = require('fs');<br/>const axios = require("axios");<br/><br/>const client = axios.create()<br/><br/>function makeFunc(event) {<br/>    return async function() {<br/>        console.log("Posting", event.event_type);<br/>        const res = await client.post("http://localhost:8000",event);<br/>        if (res.isAxiosError) {<br/>            console.error("Error posting");<br/>        }<br/>    }<br/>}<br/><br/>function run()  {<br/>    const json = JSON.parse(fs.readFileSync(__dirname + "/events.json"))<br/><br/>	json.forEach((event, index) =&gt; {<br/>		const timeout = (index + 1) * 1000;<br/>	    console.log(`Setting timeout for Event ${event.id}; delay ${timeout} ms.`);<br/>		setTimeout(makeFunc(event), timeout);<br/>	})<br/>}<br/><br/>run()</span></pre><h2 id="941d" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">查看输出</h2><p id="0e78" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">你可以使用类似于<a class="ae lu" href="https://requestbin.io/" rel="noopener ugc nofollow" target="_blank"> requestbin.io </a>的服务，作为一种简单的方法来查看帖子的样子。为此，我决定使用<a class="ae lu" href="https://github.com/fiatjaf/requestbin" rel="noopener ugc nofollow" target="_blank"> fiatjaf的request bin</a>——它小而简单。</p><p id="ca93" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里——正确的数据，间隔一秒钟，如我们所料。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1be8" class="kw kx jb ly b gy mh mi l mj mk">$ ./requestbin -port 8000<br/>Listening for requests at 0.0.0.0:8000<br/><br/>=== 18:00:00 ===<br/>POST / HTTP/1.1<br/>Host: localhost:8000<br/>User-Agent: axios/0.21.1<br/>Content-Length: 29<br/>Accept: application/json, text/plain, */*<br/>Connection: close<br/>Content-Type: application/json;charset=utf-8<br/><br/>{"id":1,"event_type":"Hello"}<br/><br/>=== 18:00:01 ===<br/>POST / HTTP/1.1<br/>Host: localhost:8000<br/>User-Agent: axios/0.21.1<br/>Content-Length: 29<br/>Accept: application/json, text/plain, */*<br/>Connection: close<br/>Content-Type: application/json;charset=utf-8<br/><br/>{"id":2,"event_type":"World"}</span></pre><p id="d13a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望那能帮助某人。即使我们只是遇到了同样的“糟糕”时刻，我们也一起犯过错误。感谢您的阅读。</p><p id="322f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mm">更多内容看</em> <a class="ae lu" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="mm">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>