<html>
<head>
<title>Understand React State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解反应状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-react-state-management-e2c31f7839f3?source=collection_archive---------5-----------------------#2021-09-09">https://javascript.plainenglish.io/understand-react-state-management-e2c31f7839f3?source=collection_archive---------5-----------------------#2021-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bfe2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我应该使用哪个图书馆？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d691baaeb00a7c7e3b4e0d98865d01c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fus1LIqHlscfCn4Q_qw5-g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="69ed" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">React应该使用什么状态管理库？这是一个我作为react开发者听过几百遍的问题。本文将帮助您回答这个问题。首先，我们必须了解一点历史。React于2013年5月推出。它的范式转变是你的用户界面是你的状态的函数。给定某个组件的状态，React可以确定该组件的外观。从一开始，React就建立在状态的概念之上，但是React中的状态管理一直是最难理解的部分之一。</p><p id="41f4" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我们在2014年首次看到了Flux架构。这种模式首先由脸书提出，然后由一个名为Redux的库推广。这期间出现了一堆不同的类似Flux的库，赢的是Redux。如果你看看这张NPM趋势图，你会发现Redux仍然非常受欢迎和广泛使用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lv"><img src="../Images/1cf5b04798a0a6aadfeb5564bcfbb325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juhYuu5HBWHmazT3THFNug.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><p id="1fd5" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这张图显然没有涵盖所有内容，但至少让您大致了解Redux今天仍在使用。你可能也注意到了，我在比较图中的其他库，其中一些你可能认为相关，也可能不相关。这是因为当Redux问世时，它封装了许多不同类型的状态。为了帮助解释这一点，让我们定义两个重要的术语— UI状态和服务器缓存状态。UI状态用于控制我们应用程序的交互部分，比如模态，甚至是亮模式或暗模式。服务器缓存状态是指我们调用一些API，返回一个响应，然后缓存结果供客户端使用。看看下面的图片。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lw"><img src="../Images/8931ba22d5b4c9f32a05ea3d7400356a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UMQnHw9oZoRY1O36jOeLw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><p id="c35a" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在这个使用SWR的例子中，它是一个做这件事的库，你可以看到你会调用这个API用户，获取一些数据，然后响应('/api/user/123 ')被转换为在我们客户端的多个地方使用。</p><p id="69ab" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在React的早期，很多这种状态管理只是获取一些API，存储结果，然后在应用程序中的某个地方使用它，主要是服务器现金状态。正因为如此，社区非常依赖Redux，因为没有专门针对该服务器缓存状态的库，但所有这些都随着React挂钩而改变。有了一种简单的方法来封装逻辑并在应用程序中共享，像SWR和React-query这样的新库出现了，它们允许你只管理服务器缓存状态。服务器缓存状态和UI状态是完全不同的问题，当你合并一个库的时候，事情开始变得有点混乱。网络请求的弹性有很多复杂性，最好听从专家的意见，使用专门的库。</p><p id="4d09" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">React状态管理历史上的另一个重大转变是React上下文。有了React 16.3，我们有了一个跨多个不同组件共享逻辑的一流解决方案。这防止了从一个组件到另一个组件向下传递值，有些人称之为prop drilling。请记住，React上下文本身并不是一个状态管理解决方案。当您将它与像useState和useReducer这样的挂钩配对时，它就变成了一个完整的状态管理解决方案。React context只是在许多不同组件之间传输数据的手段。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="0a22" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">希望这段历史能让你更好地理解我们如何走到2021年的今天，以及React的状态管理现状。既然我们已经了解了不同类型的状态，我们就有了针对特定用例的更细粒度的库。第一个是状态机。状态机只是计算机科学的话题。它们不是React特有的，但是它们确实帮助我们用React解决了现代状态管理问题。</p><p id="f72e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">状态机只是您的状态随时间变化的显式模型。把交通灯想成一个真实世界的例子。它从绿色变成黄色，再变成红色，但是它从来没有从绿色变成红色。我认为状态机变得流行的原因是，必须显式地写出你的所有状态有助于你思考边缘情况，并可能发现一些你错过的错误。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="0d87" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我想谈一谈为什么在React生态系统中创建了这么多的状态管理库。让我们来看看Figma，它是浏览器中的一个设计工具，它是复杂状态的一个很好的用例。所以如果你点击屏幕中间的一个元素，你会发现本地状态的概念没有意义。你在右边和左边有工具栏，当你改变这些工具栏中的任何东西时，它也必须更新中间。在这样做的时候，它还需要非常，非常高的性能。</p><p id="c92a" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">创建像Figma这样具有复杂状态管理需求的web应用程序，需要开发人员跳出框框思考如何处理状态管理。这导致了一系列不同的库和实验，试图找出处理状态管理的最佳方式。拥有复杂的状态并不一定意味着必须使用第三方库。您总是可以从React或JavaScript开始。看看这会让你走多远，如果你开始注意到性能问题，那么也许可以选择这些解决方案中的一个来优化。除非有明确的需求，否则不要选择这些库中的任何一个。</p><p id="bb6f" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">状态管理世界中另一个有趣的争论是不可变状态的概念。一方面，你有一个不可变的阵营，说如果你直接改变那个状态，你将会有更多的错误。另一方面，可变阵营认为有一大堆样板文件可以做到这一点。事实上，双方都有点道理。直接操纵总是不如间接操纵安全，但这是便利和风险之间的权衡。所以这真的取决于你的团队。</p><p id="639e" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">有趣的是，像Immer这样的解决方案，它允许你编写可变的代码，然后不变地执行它。Immer的基本思想是，你有一个当前的状态，你想做一些改变。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lx"><img src="../Images/f005ab4de0a6538275eda52a1051a06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hw5IMHgDnuMu48PxxkpAVg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by Author</figcaption></figure><p id="566d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">它产生这个临时的草稿状态，这是你当前状态的一个代理。然后它理解你想要做的改变，并根据这些改变产生下一个状态。实际上，这意味着您以可变的方式获得一个代码，产生一个不可变的结果。</p><p id="3dd6" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">另一种需要快速接触的状态是URL状态。假设您正在一家图书电子商务商店搜索一本React图书，您希望按四星及以上进行筛选。您会注意到，当您这样做时，该状态会保留在URL中。因此，如果你刷新页面并与他人分享，他们将始终看到与你相同的状态——查看通过四星及以上过滤的React书籍。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="d1be" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">您可能听过人们谈论React上下文作为状态管理解决方案的性能问题。他们所谈论的是，如果你有一个非常大的应用程序，并且整个东西都被一个上下文提供者所包围，那么无论何时你对那个状态做出改变，它都会重新呈现嵌套在那个提供者下的所有东西。这可能会使交互感觉很慢，这就是为什么你经常看到人们通过添加像useMemo这样的东西来进行性能优化，如果值从不改变，它就不会重新呈现组件。</p><p id="ba54" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">展望React状态管理的未来，React核心团队提出了一个名为use selected context的新挂钩，它将为您处理这种性能优化。我对此感到兴奋，因为我认为React标准库中良好的缺省值将对刚刚学习如何使用React的人大有帮助。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="4890" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">您应该使用哪种状态管理解决方案？嗯……这要看情况。我知道这是一种逃避，但这是非常复杂的，它需要大量的思考。对于form state，您可以作为小型项目的初学者使用useState，或者作为中型项目的初学者使用Formik。如果你在一个大型团队中工作，我确信技术主管将是这方面的决策者。如果你是一个中级或有经验的开发人员，状态机非常好用。</p><p id="c41b" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">对于UI状态，对于入门级的中小型项目，可以使用useState、useContext + useReducer。对于中级开发人员，您可以使用React Toolkit或者使用Context + useReducer来开发中小型项目。对于一个高级开发人员来说，你可以使用useContext + useReducer、Jotai、Valtio和反冲来开发大中型项目。如果您正在使用GraohQL，Relay也是一个不错的选择。</p><p id="75da" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">对于服务器缓存状态，SWR或React查询都是非常好的解决方案。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="dc90" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">总而言之，使用你觉得合适的，并且你可以根据自己的水平适当管理的。其中一些状态管理库需要一段时间来学习和应用。慢慢来。一步一步来。我希望这篇文章给了你一些有用的见解，或者帮助你缩小了学习状态管理的道路。</p><p id="8dcc" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><em class="ly">更多内容看</em><a class="ae lz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb io"><em class="ly">plain English . io</em></strong></a></p></div></div>    
</body>
</html>