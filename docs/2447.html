<html>
<head>
<title>A Deep Dive into React Class Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React类生命周期方法的深入探讨</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-lifecycle-methods-a-deep-dive-f97c4553c5c2?source=collection_archive---------6-----------------------#2021-05-20">https://javascript.plainenglish.io/react-lifecycle-methods-a-deep-dive-f97c4553c5c2?source=collection_archive---------6-----------------------#2021-05-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0080" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">安装、更新、卸载和错误处理阶段方法</h2></div><h1 id="50ee" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">什么是React生命周期方法？</h1><blockquote class="ku kv kw"><p id="02ec" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated">你可以把React生命周期方法看作是从React组件诞生到死亡的一系列事件。</p></blockquote><p id="97af" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">React中的每个组件都经历一个事件生命周期。我喜欢把它们想象成经历出生、成长和死亡的循环。</p><ul class=""><li id="e9fa" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><strong class="la io">安装— </strong>您的组件的诞生。这是将<em class="kz">组件插入DOM </em>的阶段。</li><li id="e297" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><strong class="la io">更新</strong> —你的组件的成长。这是<em class="kz">组件的状态和属性可以改变</em>的阶段，导致使用更新的状态/属性重新渲染组件的过程</li><li id="d66a" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><strong class="la io">卸载</strong> —组件死亡。这是组件生命周期的最后一个阶段，在这个阶段，它被从DOM 中<em class="kz">移除。</em></li></ul><p id="63f7" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">现在我们已经了解了一系列生命周期事件，让我们进一步了解它们是如何工作的。</p><h1 id="49af" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">组件生命周期</h1><p id="ae2e" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">每个组件都有几个“生命周期方法”，您可以覆盖这些方法，以便在流程中的特定时间运行代码。<strong class="la io">你可以用</strong> <a class="ae mq" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener ugc nofollow" target="_blank"> <strong class="la io">这张生命周期图</strong> </a> <strong class="la io">作为备忘单。</strong>在下表中，常用的生命周期方法标记为<strong class="la io">粗体</strong>。其余的用于相对罕见的用例。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/7c4d925eba91e472922ecf9ae1d8f673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d25u0_0n_LJD_yEuT5NUA.png"/></div></div></figure><h1 id="a2d9" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">增加</h1><p id="09e5" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">当一个组件的实例被创建并插入到DOM中时，这些方法按以下顺序被调用:</p><ul class=""><li id="0628" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">constructor()</strong></code></li><li id="ca66" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b">static getDerivedStateFromProps()</code></li><li id="3c14" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">render()</strong></code></li><li id="ab43" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">componentDidMount()</strong></code></li></ul><blockquote class="ku kv kw"><p id="7312" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><strong class="la io">注意:</strong>这些方法被认为是遗留的，你应该<a class="ae mq" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" rel="noopener ugc nofollow" target="_blank">在新代码中避免它们</a>:<code class="fe nd ne nf ng b">UNSAFE_componentWillMount().</code></p></blockquote><h1 id="0e18" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">1.构造函数()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="83a1" class="nl kd in ng b gy nm nn l no np">constructor(props)</span></pre><p id="8310" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">React组件的构造函数在挂载之前被调用。当实现一个<code class="fe nd ne nf ng b">React.Component</code>子类的构造函数时，你应该在任何其他语句之前调用<code class="fe nd ne nf ng b">super(props)</code>。否则，<code class="fe nd ne nf ng b">this.props</code>将在构造函数中未定义，这可能会导致bug。</p><p id="10b9" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">通常，在React中，构造函数只用于两个目的:</p><ul class=""><li id="d0bf" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">通过向<code class="fe nd ne nf ng b">this.state</code>分配一个对象来初始化本地状态。</li><li id="0617" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">将事件处理程序方法绑定到实例。</li></ul><p id="f411" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">你<strong class="la io">不应该在<code class="fe nd ne nf ng b">constructor()</code>中调用</strong>T0。相反，如果你的组件需要使用一个本地状态，<strong class="la io">在构造函数中直接将初始状态赋值给</strong> <code class="fe nd ne nf ng b"><strong class="la io">this.state</strong></code>:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="03cc" class="nl kd in ng b gy nm nn l no np">constructor(props) {<br/>  super(props);<br/>  // Don't call this.setState() here!<br/>  this.state = { counter: 0 };<br/>  this.handleClick = this.handleClick.bind(this);<br/>}</span></pre><p id="e0c6" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">如果不初始化状态，也不绑定方法，就不需要为React组件实现构造函数。</strong></p><p id="ae24" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">构造函数是唯一应该直接赋值<code class="fe nd ne nf ng b">this.state</code>的地方。在所有其他方法中，您需要使用<code class="fe nd ne nf ng b">this.setState()</code>来代替。</p><p id="c840" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">避免在构造函数中引入任何副作用或订阅。对于那些用例，用<code class="fe nd ne nf ng b">componentDidMount()</code>代替。</p><p id="f6cf" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">注意:避免复制道具进入状态！这是一个常见的错误:</strong></p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="bdf0" class="nl kd in ng b gy nm nn l no np">constructor(props) {<br/> super(props);<br/> // Don't do this!<br/> this.state = { color: props.color };<br/>}</span></pre><p id="8a5a" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">问题是它既没必要(你可以直接用<code class="fe nd ne nf ng b">this.props.color</code>代替)，又会产生bug(对<code class="fe nd ne nf ng b">color</code>道具的更新不会反映在状态中)。<strong class="la io">仅当您有意忽略适当更新时，才使用此模式。</strong></p><p id="0e9a" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">构造函数最常见的用例:</strong>设置状态、创建引用和方法绑定。</p><h1 id="c787" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">2.静态getDerivedStateFromProps()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="7024" class="nl kd in ng b gy nm nn l no np">static getDerivedStateFromProps(props, state)</span></pre><p id="1bbe" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><code class="fe nd ne nf ng b">getDerivedStateFromProps</code>在调用render方法之前被调用，无论是初始挂载还是后续更新。这种方法存在于<a class="ae mq" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" rel="noopener ugc nofollow" target="_blank">罕见的用例</a>，其中状态依赖于道具随时间的变化。</p><p id="c82e" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这是一个<em class="kz">静态</em>函数，它不能访问“<em class="kz"> this </em>”。<em class="kz">getDerivedStateFromProps()</em>返回一个对象来更新<em class="kz">状态</em>以响应<em class="kz">属性</em>的变化。如果状态没有变化，它可以返回一个空值。</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="bf12" class="nl kd in ng b gy nm nn l no np">static getDerivedStateFromProps(props, state) {<br/>    if (props.currentRow !== state.lastRow) {<br/>      return {<br/>        isScrollingDown: props.currentRow &gt; state.lastRow,<br/>        lastRow: props.currentRow,<br/>      };<br/>    }<br/>    // Return null to indicate no change to state.<br/>    return null;<br/>  }</span></pre><p id="63e0" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这种方法可能派上用场的一个用例是一个<transition>组件，它比较它的上一个和下一个子组件，以决定哪些子组件要动画进出。</transition></p><p id="73ef" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">请记住，这个生命周期方法在每次渲染时都会在<strong class="la io">上触发，不管原因是什么。这与<code class="fe nd ne nf ng b">UNSAFE_componentWillReceiveProps</code>形成对比，后者仅在父对象导致重新渲染时触发，而不是作为局部<code class="fe nd ne nf ng b">setState</code>的结果。</strong></p><p id="a094" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">派生状态会导致冗长的代码，并使您的组件难以理解。确保您熟悉更简单的替代方案:</p><ul class=""><li id="a6da" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">如果您需要<strong class="la io">执行副作用</strong>(例如，数据获取或动画)来响应道具的变化，请使用<code class="fe nd ne nf ng b">componentDidUpdate</code>生命周期。</li><li id="d3b4" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">如果您希望<strong class="la io">仅在属性改变时重新计算一些数据</strong>，请使用记忆辅助程序。</li></ul><p id="2a30" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">派生状态用于确保仅当输入改变时才重新计算<code class="fe nd ne nf ng b">render</code>中使用的昂贵值。这种技术被称为<a class="ae mq" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>。使用派生状态进行记忆并不一定是坏的，但通常不是最好的解决方案。管理派生状态存在固有的复杂性，并且这种复杂性随着每个附加属性而增加。例如，如果我们向组件状态添加第二个派生字段，那么我们的实现将需要分别跟踪对这两个字段的更改。</p><p id="bf9f" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">让我们看一个组件的例子，它接受一个属性——一个条目列表——并呈现与用户输入的搜索查询相匹配的条目。我们可以使用派生状态来存储过滤列表:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="e994" class="nl kd in ng b gy nm nn l no np">class Example extends Component {<br/>  state = {<br/>    filterText: "",<br/>  };</span><span id="a883" class="nl kd in ng b gy nq nn l no np">  // *******************************************************<br/>  // NOTE: this example is NOT the recommended approach.<br/>  // See the examples below for our recommendations instead.<br/>  // *******************************************************</span><span id="0d1a" class="nl kd in ng b gy nq nn l no np">  static getDerivedStateFromProps(props, state) {<br/>    // Re-run the filter whenever the list array or filter text change.<br/>    // Note we need to store prevPropsList and prevFilterText to detect changes.<br/>    if (<br/>      props.list !== state.prevPropsList ||<br/>      state.prevFilterText !== state.filterText<br/>    ) {<br/>      return {<br/>        prevPropsList: props.list,<br/>        prevFilterText: state.filterText,<br/>        filteredList: props.list.filter(item =&gt;     item.text.includes(state.filterText))<br/>      };<br/>    }<br/>    return null;<br/>  }</span><span id="6405" class="nl kd in ng b gy nq nn l no np">  handleChange = event =&gt; {<br/>    this.setState({ filterText: event.target.value });<br/>  };</span><span id="9ac4" class="nl kd in ng b gy nq nn l no np">  render() {<br/>    return (<br/>      &lt;Fragment&gt;<br/>        &lt;input onChange={this.handleChange} value={this.state.filterText} /&gt;<br/>        &lt;ul&gt;{this.state.filteredList.map(item =&gt; &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;)}&lt;/ul&gt;<br/>      &lt;/Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0bae" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这种实现避免了不必要的重新计算<code class="fe nd ne nf ng b">filteredList</code>。但是它比需要的更复杂，因为它必须分别跟踪和检测属性和状态的变化，以便正确地更新过滤列表。我们可以添加一个记忆助手来避免不必要的重新过滤列表:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="46e2" class="nl kd in ng b gy nm nn l no np">import memoize from "memoize-one";</span><span id="5b63" class="nl kd in ng b gy nq nn l no np">class Example extends Component {<br/>  // State only needs to hold the current filter text value:<br/>  state = { filterText: "" };</span><span id="08d9" class="nl kd in ng b gy nq nn l no np">  // Re-run the filter whenever the list array or filter text changes:<br/>  filter = memoize(<br/>    (list, filterText) =&gt; list.filter(item =&gt; item.text.includes(filterText))<br/>  );</span><span id="682f" class="nl kd in ng b gy nq nn l no np">  handleChange = event =&gt; {<br/>    this.setState({ filterText: event.target.value });<br/>  };</span><span id="7e0e" class="nl kd in ng b gy nq nn l no np">  render() {<br/>    // Calculate the latest filtered list. If these arguments haven't changed<br/>    // since the last render, `memoize-one` will reuse the last return value.<br/>    const filteredList = this.filter(this.props.list, this.state.filterText);</span><span id="63ba" class="nl kd in ng b gy nq nn l no np">    return (<br/>      &lt;Fragment&gt;<br/>        &lt;input onChange={this.handleChange} value={this.state.filterText} /&gt;<br/>        &lt;ul&gt;{filteredList.map(item =&gt; &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;)}&lt;/ul&gt;<br/>      &lt;/Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="cd11" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这要简单得多，执行起来和派生状态版本一样好！</p><p id="fb05" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">使用记忆化时，请记住几个约束:</p><ol class=""><li id="8c1e" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt nr md me mf bi translated">在大多数情况下，你会希望<strong class="la io">将内存化的函数附加到组件实例</strong>。这可以防止组件的多个实例重置彼此的记忆键。</li><li id="9cb2" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt nr md me mf bi translated">通常情况下，为了防止随着时间的推移出现内存泄漏，您会希望使用一个具有有限缓存大小的内存化助手。(在上面的例子中，我们使用了<code class="fe nd ne nf ng b">memoize-one</code>,因为它只缓存最近的参数和结果。)</li><li id="4ec2" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt nr md me mf bi translated">如果每次父组件渲染时都重新创建<code class="fe nd ne nf ng b">props.list</code>,那么本节中显示的所有实现都将不起作用。但是在大多数情况下，这种设置是合适的。</li></ol><ul class=""><li id="9217" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">如果你想在道具改变时<strong class="la io">“重置”某个状态</strong>，考虑用<code class="fe nd ne nf ng b">key</code>替代使一个组件完全受控或完全不受控。</li></ul><p id="74a4" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">完全受控的组件— </strong>避免上述问题的一种方法是从我们的组件中完全移除状态。如果邮箱地址只是作为道具存在，那么我们就不用担心和state冲突了。我们甚至可以将<code class="fe nd ne nf ng b">EmailInput</code>转换成重量更轻的功能组件:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="1c77" class="nl kd in ng b gy nm nn l no np">function EmailInput(props) {<br/>  return &lt;input onChange={props.onChange} value={props.email} /&gt;;<br/>}</span></pre><p id="dd4d" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这种方法简化了组件的实现，但是如果我们仍然想存储一个草稿值，父表单组件现在需要手动完成。</p><p id="ec69" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">带有</strong> <code class="fe nd ne nf ng b"><strong class="la io">key</strong></code> <strong class="la io">的完全不受控制的组件— </strong>另一种选择是我们的组件完全拥有“草稿”电子邮件状态。在这种情况下，我们的组件仍然可以接受一个用于初始<em class="kz">值的属性，但是它会忽略对该属性的后续更改:</em></p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="3f8c" class="nl kd in ng b gy nm nn l no np">class EmailInput extends Component {<br/>  state = { email: this.props.defaultEmail };</span><span id="d55c" class="nl kd in ng b gy nq nn l no np">  handleChange = event =&gt; {<br/>    this.setState({ email: event.target.value });<br/>  };</span><span id="5a37" class="nl kd in ng b gy nq nn l no np">  render() {<br/>    return &lt;input onChange={this.handleChange} value={this.state.email} /&gt;;<br/>  }<br/>}</span></pre><p id="b892" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">为了在移动到不同的项目时重置该值，我们可以使用名为<code class="fe nd ne nf ng b">key</code>的特殊React属性。当一个<code class="fe nd ne nf ng b">key</code>改变时，React将<em class="kz">创建</em>一个新的组件实例，而不是<em class="kz">更新</em>当前的组件实例。键通常用于动态列表，但在这里也很有用。在我们的例子中，我们可以使用用户ID在任何时候选择新用户时重新创建电子邮件输入:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="46dc" class="nl kd in ng b gy nm nn l no np">&lt;EmailInput<br/>  defaultEmail={this.props.user.email}<br/>  key={this.props.user.id}<br/>/&gt;</span></pre><p id="bbb9" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">每次ID改变时，<code class="fe nd ne nf ng b">EmailInput</code>将被重新创建，其状态将被重置为最新的<code class="fe nd ne nf ng b">defaultEmail</code>值。</p><p id="af75" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">getDerivedStateFromProps(挂载期间)最常见的用例:</strong>返回基于初始属性的状态对象。</p><h1 id="8642" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">3.渲染()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="905b" class="nl kd in ng b gy nm nn l no np">render()</span></pre><p id="7a17" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><code class="fe nd ne nf ng b">render()</code>方法是类组件中唯一需要的方法。</p><p id="e083" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">当被调用时，它应该检查<code class="fe nd ne nf ng b">this.props</code>和<code class="fe nd ne nf ng b">this.state</code>并返回以下类型之一:</p><ul class=""><li id="4128" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><strong class="la io">反应元素。</strong>通常通过<a class="ae mq" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>创建。例如，<code class="fe nd ne nf ng b">&lt;div /&gt;</code>和<code class="fe nd ne nf ng b">&lt;MyComponent /&gt;</code>是React元素，分别指示React呈现一个DOM节点或另一个用户定义的组件。下面是React中一个简单的<em class="kz"> render() </em>的例子。</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="4870" class="nl kd in ng b gy nm nn l no np">class Hello extends Component{<br/>   render(){<br/>      return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;<br/>   }<br/>}</span></pre><ul class=""><li id="b083" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><strong class="la io">数组和片段。</strong>让你从渲染中返回多个元素。</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="47e6" class="nl kd in ng b gy nm nn l no np">class Hello extends Component{<br/> render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;ChildA /&gt;<br/>        &lt;ChildB /&gt;<br/>        &lt;ChildC /&gt;<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><ul class=""><li id="552e" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><strong class="la io">门户</strong>。允许您将子对象呈现到不同的DOM子树中。</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="9541" class="nl kd in ng b gy nm nn l no np">class Hello extends Component{<br/> render() {<br/>    return ReactDOM.createPortal(<br/>        this.props.children,<br/>        domNode  <br/>    );<br/> } <br/>}</span><span id="2015" class="nl kd in ng b gy nq nn l no np">// React does *not* create a new div. It renders the children into `domNode`.<br/>// `domNode` is any valid DOM node, regardless of its location in the DOM.</span></pre><ul class=""><li id="e554" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><strong class="la io">字符串和数字。这些在DOM中呈现为文本节点。</strong></li><li id="9aa8" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><strong class="la io">布尔人或</strong> <code class="fe nd ne nf ng b"><strong class="la io">null</strong></code>。不渲染任何内容。(主要是为了支持<code class="fe nd ne nf ng b">return test &amp;&amp; &lt;Child /&gt;</code>模式，其中<code class="fe nd ne nf ng b">test</code>是布尔型的。)</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="9025" class="nl kd in ng b gy nm nn l no np">class Hello extends Component {<br/>  render() {<br/>    return null;<br/>  }<br/>}</span></pre><p id="81be" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><code class="fe nd ne nf ng b">render()</code>函数应该是纯的，这意味着它不修改组件状态，每次调用它都返回相同的结果，并且它不直接与浏览器交互。这意味着你不能在一个<em class="kz"> render()中<em class="kz"> setState() </em>。</em></p><p id="20bb" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">渲染最常见的用例:</strong>返回组件JSX。</p><h1 id="42d8" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">4.componentDidMount()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="caa9" class="nl kd in ng b gy nm nn l no np">componentDidMount()</span></pre><p id="0a5e" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">现在您的组件已经被挂载并准备好了，这就是下一个React生命周期方法<strong class="la io"><em class="kz">componentDidMount()</em></strong>开始发挥作用的时候了。如果需要从远程端点加载数据，这是启动API调用的好地方。</p><p id="7585" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">与<em class="kz"> render() </em>方法不同，<em class="kz">componentidmount()</em>允许使用<em class="kz"> setState() </em>。不要在这里直接调用<em class="kz"> setState() </em>，除非是在你发送一个HTTP请求之后的一个promise的then块中。但是<strong class="la io">不要在这里同步调用<em class="kz">setState()</em></strong>。因此，您肯定可以设置一些将来执行的代码，然后更新状态。</p><p id="8443" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">在这里直接调用<em class="kz">setState()</em><em class="kz"/>将会更新状态并导致另一次渲染，但这将发生在浏览器更新UI之前。这是为了确保用户不会看到双重呈现的任何UI更新。</p><blockquote class="ku kv kw"><p id="d945" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">您可以在</em>componentidmount()<em class="in">中修改组件状态，但要小心使用。</em></p></blockquote><p id="4e61" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">注意:</strong>建议您谨慎使用此模式，因为它可能会导致性能问题。最佳实践是确保在<em class="kz">构造函数()中分配您的状态。【React允许在这个生命周期方法中使用<em class="kz"> setState() </em>的原因是为了特殊情况，比如工具提示、模态和类似的概念，当你需要在渲染依赖于它的位置的东西之前测量一个DOM节点时。</em></p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="f327" class="nl kd in ng b gy nm nn l no np">componentDidMount() {<br/>    fetch(`<a class="ae mq" href="https://api.mydomain.com/" rel="noopener ugc nofollow" target="_blank">https://api.mydomain.com/</a>`)<br/>      .then(res =&gt; res.json())<br/>      .then(json =&gt; this.setState({ data: json }));<br/>}</span><span id="323a" class="nl kd in ng b gy nq nn l no np">async componentDidMount() {<br/>    const response = await fetch(`<a class="ae mq" href="https://api.mydomain.com/" rel="noopener ugc nofollow" target="_blank">https://api.mydomain.com/</a>`<!-- -->);<br/>    const json = await response.json();<br/>    this.setState({ data: json });<br/>}</span></pre><p id="1b2c" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">componentidmount最常见的用例:</strong>启动AJAX调用为组件加载数据。另外，如果你需要<strong class="la io">初始化任何依赖于DOM的东西，</strong>你可以在这里完成(比如初始化像D3这样的第三方库)。最后但同样重要的是，您可以<strong class="la io">在componentDidMount中添加事件监听器</strong>。</p><h1 id="447d" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">5.UNSAFE_componentWillMount()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="0c90" class="nl kd in ng b gy nm nn l no np">UNSAFE_componentWillMount()</span></pre><blockquote class="ku kv kw"><p id="e704" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注:<br/>这个生命周期之前被命名为</em> <code class="fe nd ne nf ng b"><em class="in">componentWillMount</em></code> <em class="in">。该名称将一直使用到版本17。使用</em><code class="fe nd ne nf ng b"><a class="ae mq" href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles" rel="noopener ugc nofollow" target="_blank"><em class="in">rename-unsafe-lifecycles</em></a></code><a class="ae mq" href="https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles" rel="noopener ugc nofollow" target="_blank"><em class="in">codemod</em></a><em class="in">来自动更新你的组件。</em></p></blockquote><p id="6837" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">在挂载发生之前调用<code class="fe nd ne nf ng b">UNSAFE_componentWillMount()</code>。它在<code class="fe nd ne nf ng b">render()</code>之前被调用，因此在这个方法中同步调用<code class="fe nd ne nf ng b">setState()</code>不会触发额外的渲染。一般情况下，我们建议使用<code class="fe nd ne nf ng b">constructor()</code>代替初始化状态。</p><p id="3469" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">对于我们来说,<code class="fe nd ne nf ng b">componentWillMount()</code>是一个处理配置、更新状态以及为第一次渲染做准备的机会。至此，道具和初始状态定义完毕。我们可以安全地查询<code class="fe nd ne nf ng b">this.props</code>和<code class="fe nd ne nf ng b">this.state</code>，确切地知道它们是当前值。这意味着我们可以开始根据正确的值进行计算或处理。</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="2dcd" class="nl kd in ng b gy nm nn l no np">componentWillMount() {<br/>    let mode;<br/>    if (this.props.age &gt; 70) {<br/>      mode = 'old';<br/>    } else if (this.props.age &lt; 18) {<br/>      mode = 'young';<br/>    } else {<br/>      mode = 'middle';<br/>    }<br/>    this.setState({ mode });<br/>  }</span></pre><p id="8d95" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">在上面的例子中，我们调用<code class="fe nd ne nf ng b">this.setState()</code>并在渲染前更新我们的当前状态。如果我们需要在<code class="fe nd ne nf ng b">props</code>中传递的计算的状态值，这就是我们应该做逻辑的地方。</p><p id="4ed5" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">避免在这种方法中引入任何副作用或订阅。对于那些用例，使用<code class="fe nd ne nf ng b">componentDidMount()</code>代替。</p><p id="f74b" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">例外情况是任何只能在运行时完成的设置——即连接到外部API。例如，如果你的应用程序使用Firebase，当你的应用程序第一次挂载时，你需要设置它。</p><p id="bd1a" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">但关键是，这样的配置应该在你的应用程序的最高层组件(根组件)完成。这意味着99%的组件可能不应该使用componentWillMount。</p><p id="de08" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这是在服务器渲染上调用的唯一生命周期方法。</p><p id="6134" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>你的根组件中的App配置<strong class="la io">，</strong>注册到一个Flux store之类的全局事件。如果您的组件需要响应全局本机UI事件，比如<code class="fe nd ne nf ng b">window</code>调整大小或焦点改变，这是一个很好的地方</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ns"><img src="../Images/067beec4e1ec5d9da3f46130e9f17119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbQEsPTK9h1wWO-mTtceDQ.png"/></div></div></figure><p id="89b5" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这里的副作用指的是发送HTTP请求或在本地存储中存储一些东西或向Google Analytics发送分析。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h1 id="0537" class="kc kd in bd ke kf oa kh ki kj ob kl km jt oc ju ko jw od jx kq jz oe ka ks kt bi translated">更新</h1><p id="7ff6" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">属性或状态的更改可能会导致更新。当组件被重新渲染时，按以下顺序调用这些方法:</p><ul class=""><li id="f988" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b">static getDerivedStateFromProps()</code></li><li id="234b" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b">shouldComponentUpdate()</code></li><li id="1375" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">render()</strong></code></li><li id="8024" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b">getSnapshotBeforeUpdate()</code></li><li id="761b" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">componentDidUpdate()</strong></code></li></ul><blockquote class="ku kv kw"><p id="286e" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:<br/>这些方法被认为是遗留的，你应该</em> <a class="ae mq" href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" rel="noopener ugc nofollow" target="_blank"> <em class="in">在新代码中避免使用</em></a><em class="in">:</em><code class="fe nd ne nf ng b">UNSAFE_componentWillUpdate()</code><em class="in">和</em> <code class="fe nd ne nf ng b">UNSAFE_componentWillReceiveProps()</code></p></blockquote><h1 id="7643" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">1.shouldComponentUpdate()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="853a" class="nl kd in ng b gy nm nn l no np">shouldComponentUpdate(nextProps, nextState)</span></pre><p id="ba1b" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">当您不想让React呈现您状态或适当的更改时，这个生命周期有时会很方便。默认行为是在每次状态改变时重新渲染，在大多数情况下，您应该依赖默认行为。</p><ul class=""><li id="1fac" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">当接收到新的属性或状态时，在渲染之前调用<code class="fe nd ne nf ng b">shouldComponentUpdate()</code>。默认为<code class="fe nd ne nf ng b">true</code>。初始渲染或使用<code class="fe nd ne nf ng b">forceUpdate()</code>时不调用该方法。</li><li id="79b4" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">该方法仅作为<strong class="la io">性能优化而存在。不要依靠它来“阻止”渲染，因为这会导致错误。<strong class="la io">考虑用内置的</strong> <code class="fe nd ne nf ng b"><a class="ae mq" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"><strong class="la io">PureComponent</strong></a></code>代替手写<code class="fe nd ne nf ng b">shouldComponentUpdate()</code>。执行道具和状态的浅层比较，减少你跳过必要更新的机会。</strong></li><li id="5e64" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">如果你确信你想要手写，你可以比较<code class="fe nd ne nf ng b">this.props</code>和<code class="fe nd ne nf ng b">nextProps</code>以及<code class="fe nd ne nf ng b">this.state</code>和<code class="fe nd ne nf ng b">nextState</code>并返回<code class="fe nd ne nf ng b">false</code>来告诉React可以跳过更新。注意，当<em class="kz">的</em>状态改变时，返回<code class="fe nd ne nf ng b">false</code>不会阻止子组件重新渲染。</li></ul><p id="6e04" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">我们不建议进行深度相等检查或在<code class="fe nd ne nf ng b">shouldComponentUpdate()</code>中使用<code class="fe nd ne nf ng b">JSON.stringify()</code>。这是非常低效的，并且会损害性能。</p><p id="1d44" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">目前，如果<code class="fe nd ne nf ng b">shouldComponentUpdate()</code>返回<code class="fe nd ne nf ng b">false</code>，那么<code class="fe nd ne nf ng b">UNSAFE_componentWillUpdate()</code>、<code class="fe nd ne nf ng b">render()</code>、<code class="fe nd ne nf ng b">componentDidUpdate()</code>将不会被调用。将来，React可能会将<code class="fe nd ne nf ng b">shouldComponentUpdate()</code>视为一个提示，而不是一个严格的指令，返回<code class="fe nd ne nf ng b">false</code>仍然可能导致组件的重新呈现。</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="6ce1" class="nl kd in ng b gy nm nn l no np">shouldComponentUpdate(nextProps, nextState) {<br/> return this.props.title !== nextProps.title || <br/>        this.state.input !== nextState.input <br/>}</span></pre><p id="3ec6" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">如上例所示，这个生命周期应该总是返回一个布尔值给问题，“<strong class="la io"> <em class="kz">我应该重新渲染我的组件吗？</em> </strong>”。</p><p id="9fce" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>精确控制组件何时重新渲染。</p><h1 id="2fec" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">2.getSnapShotBeforeUpdate()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="6797" class="nl kd in ng b gy nm nn l no np">getSnapshotBeforeUpdate(prevProps, prevState)</span></pre><ul class=""><li id="b1c2" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b">getSnapshotBeforeUpdate()</code>在最近渲染的输出提交到DOM之前被调用。它使您的组件能够在DOM发生潜在变化之前捕获一些信息(例如滚动位置)。这个生命周期方法返回的任何值都将作为参数传递给<code class="fe nd ne nf ng b">componentDidUpdate()</code>。</li><li id="8707" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">这种用例并不常见，但它可能出现在像聊天线程这样需要以特殊方式处理滚动位置的用户界面中。</li><li id="e363" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">应该返回一个快照值(或<code class="fe nd ne nf ng b">null</code>)。</li></ul><p id="2282" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">例如:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="7dea" class="nl kd in ng b gy nm nn l no np">class ScrollingList extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.listRef = React.createRef();<br/>  }</span><span id="68b7" class="nl kd in ng b gy nq nn l no np">  getSnapshotBeforeUpdate(prevProps, prevState) {<br/>    // Are we adding new items to the list?<br/>    // Capture the scroll position so we can adjust scroll later.<br/>    if (prevProps.list.length &lt; this.props.list.length) {<br/>      const list = this.listRef.current;<br/>      return list.scrollHeight - list.scrollTop;<br/>    }<br/>    return null;<br/>  }</span><span id="3470" class="nl kd in ng b gy nq nn l no np">  componentDidUpdate(prevProps, prevState, snapshot) {<br/>    // If we have a snapshot value, we've just added new items.<br/>    // Adjust scroll so these new items don't push the old ones out of view.<br/>    // (snapshot here is the value returned from getSnapshotBeforeUpdate)<br/>    if (snapshot !== null) {<br/>      const list = this.listRef.current;<br/>      list.scrollTop = list.scrollHeight - snapshot;<br/>    }<br/>  }</span><span id="7795" class="nl kd in ng b gy nq nn l no np">  render() {<br/>    return (<br/>      &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="89ac" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">在上面的例子中，读取<code class="fe nd ne nf ng b">getSnapshotBeforeUpdate</code>中的<code class="fe nd ne nf ng b">scrollHeight</code>属性很重要，因为在“呈现”阶段生命周期(如<code class="fe nd ne nf ng b">render</code>)和“提交”阶段生命周期(如<code class="fe nd ne nf ng b">getSnapshotBeforeUpdate</code>和<code class="fe nd ne nf ng b">componentDidUpdate</code>)之间可能会有延迟。</p><p id="6646" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">请记住，这种方法也应该很少使用或根本不使用。</p><p id="4af4" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">当<em class="kz">getSnapshotBeforeUpdate()</em>可用时，在异步渲染期间调整窗口大小是一个很好的用例。</p><p id="0dda" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>查看当前DOM的一些属性，并将该值传递给<code class="fe nd ne nf ng b">componentDidUpdate</code>。</p><h1 id="9bdb" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">3.componentDidUpdate()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="612d" class="nl kd in ng b gy nm nn l no np">componentDidUpdate(prevProps, prevState, snapshot)</span></pre><ul class=""><li id="6f05" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">更新发生后立即调用<code class="fe nd ne nf ng b">componentDidUpdate()</code>。初始呈现时不调用此方法。</li><li id="e9f6" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">当组件被更新时，利用这个机会对DOM进行操作。这也是一个进行网络请求的好地方，只要你将当前的属性与以前的属性进行比较(例如，如果属性没有改变，网络请求可能是不必要的)。</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="d9d5" class="nl kd in ng b gy nm nn l no np">componentDidUpdate(prevProps) {<br/>  // Typical usage (don't forget to compare props):<br/>  if (this.props.userID !== prevProps.userID) {<br/>    this.fetchData(this.props.userID);<br/>  }<br/>}</span></pre><p id="7ae7" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">你<strong class="la io">可以在<code class="fe nd ne nf ng b">componentDidUpdate()</code>中立即调用</strong><code class="fe nd ne nf ng b"><strong class="la io">setState()</strong></code><strong class="la io"/>，但是要注意<strong class="la io">必须像上面的例子一样用条件</strong>包起来，否则会导致无限循环。同样，不要在这里直接调用<em class="kz"> setState() </em>,除非是在发送HTTP请求后的承诺的then块中。这是一些异步任务的结果，但是<strong class="la io">不要在这里同步调用<em class="kz">setState()</em></strong>。如果被调用，它还会导致额外的重新呈现，这虽然对用户不可见，但会影响组件性能。如果你试图把一些状态“镜像”到一个来自上面的道具，考虑直接使用道具。</p><p id="2eb8" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">如果您的组件实现了<code class="fe nd ne nf ng b">getSnapshotBeforeUpdate()</code>生命周期(这种情况很少见)，它返回的值将作为第三个“快照”参数传递给<code class="fe nd ne nf ng b">componentDidUpdate()</code>。否则，该参数将未定义。</p><blockquote class="ku kv kw"><p id="0680" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:</em> <code class="fe nd ne nf ng b"><em class="in">componentDidUpdate()</em></code> <em class="in">如果</em> <code class="fe nd ne nf ng b"><em class="in">shouldComponentUpdate()</em></code> <em class="in">返回false则不会调用。</em></p></blockquote><p id="4935" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>更新DOM以响应属性或状态变化，更新第三方UI库，如D3，以传递新数据。</p><h1 id="ea9a" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">4.UNSAFE _ componentWillReceiveProps()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="4c2c" class="nl kd in ng b gy nm nn l no np">UNSAFE_componentWillReceiveProps(nextProps)</span></pre><blockquote class="ku kv kw"><p id="4495" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:这个生命周期之前被命名为</em> <code class="fe nd ne nf ng b"><em class="in">componentWillReceiveProps</em></code> <em class="in">。该名称将一直使用到版本17。使用</em> <code class="fe nd ne nf ng b"><em class="in">rename-unsafe-lifecycles</em></code> <em class="in"> codemod自动更新您的组件。</em></p></blockquote><ul class=""><li id="1e75" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b">UNSAFE_componentWillReceiveProps()</code>在安装的组件接收新的属性之前被调用。如果您需要更新状态以响应适当的更改(例如，重置它)，您可以比较<code class="fe nd ne nf ng b">this.props</code>和<code class="fe nd ne nf ng b">nextProps</code>，并在此方法中使用<code class="fe nd ne nf ng b">this.setState()</code>执行状态转换。</li><li id="52ff" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">请注意，如果父组件导致您的组件重新呈现，即使props没有更改，也会调用此方法。如果您只想处理更改，请确保比较当前值和下一个值。</li><li id="5ef8" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">React在挂载时不会用初始道具调用<code class="fe nd ne nf ng b">UNSAFE_componentWillReceiveProps()</code>。只有当组件的一些属性可能更新时，它才调用这个方法。呼叫<code class="fe nd ne nf ng b">this.setState()</code>一般不会触发<code class="fe nd ne nf ng b">UNSAFE_componentWillReceiveProps()</code>。</li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="938c" class="nl kd in ng b gy nm nn l no np">componentWillReceiveProps(nextProps){<br/>   if(this.props.id !== nextProps.id){<br/>      this.setState({<br/>         id: nextProps.id,<br/>         pastId: this.props.id<br/>      })<br/>   }<br/>}</span></pre><p id="3c42" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>作用于特定的道具变化来触发状态转换，即如果你有一个状态是由多个道具计算出来的，你可以在这里进行计算。</p><h1 id="7fd7" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">5.UNSAFE_componentWillUpdate()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="c773" class="nl kd in ng b gy nm nn l no np">UNSAFE_componentWillUpdate(nextProps, nextState)</span></pre><blockquote class="ku kv kw"><p id="3912" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:这个生命周期以前被命名为</em> <code class="fe nd ne nf ng b"><em class="in">componentWillUpdate</em></code> <em class="in">。该名称将一直使用到版本17。使用</em> <code class="fe nd ne nf ng b"><em class="in">rename-unsafe-lifecycles</em></code> <em class="in"> codemod来自动更新你的组件。</em></p></blockquote><ul class=""><li id="b74e" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated">当接收到新的道具或状态时，在渲染之前调用<code class="fe nd ne nf ng b">UNSAFE_componentWillUpdate()</code>。利用这一机会，在更新发生之前做好准备。初始呈现时不调用此方法。</li><li id="c6d9" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated">注意这里不能调用<code class="fe nd ne nf ng b">this.setState()</code>；在<code class="fe nd ne nf ng b">UNSAFE_componentWillUpdate()</code>返回之前，您也不应该做任何会触发React组件更新的事情(例如，调度Redux动作)。</li></ul><p id="3302" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">通常这种方法可以用<code class="fe nd ne nf ng b">componentDidUpdate()</code>代替。如果您用这种方法从DOM中读取(例如，保存一个滚动位置)，您可以将该逻辑移到<code class="fe nd ne nf ng b">getSnapshotBeforeUpdate()</code>。</p><blockquote class="ku kv kw"><p id="f894" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:</em> <code class="fe nd ne nf ng b"><em class="in">UNSAFE_componentWillUpdate()</em></code> <em class="in">如果</em> <code class="fe nd ne nf ng b"><em class="in">shouldComponentUpdate()</em></code> <em class="in">返回false，则不会调用。</em></p></blockquote><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="580d" class="nl kd in ng b gy nm nn l no np">// dispatching an action based on state change<br/>componentWillUpdate(nextProps, nextState) {<br/>  if (nextState.open == true &amp;&amp; this.state.open == false) {<br/>    this.props.onWillOpen();<br/>  }<br/>}</span></pre><p id="107f" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><strong class="la io">最常见的用例:</strong>代替componentWillReceiveProps用在也有shouldComponentUpdate(但不能访问以前的Props)的组件上，根据状态变化设置变量，调度事件/动作，启动动画。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi of"><img src="../Images/7a5e6fa044c422c7d7083e096b765be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhGiGvx4_-H1pz4cekJVgQ.png"/></div></div></figure></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h1 id="2934" class="kc kd in bd ke kf oa kh ki kj ob kl km jt oc ju ko jw od jx kq jz oe ka ks kt bi translated">卸载</h1><p id="796c" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">当组件从DOM中移除时，调用此方法:</p><ul class=""><li id="dbc0" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b"><strong class="la io">componentWillUnmount()</strong></code></li></ul><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="468f" class="nl kd in ng b gy nm nn l no np">componentWillUnmount()</span></pre><p id="de3a" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><code class="fe nd ne nf ng b">componentWillUnmount()</code>在组件被卸载和销毁之前立即被调用。在该方法中执行任何必要的清理，例如使计时器失效、清除存储器中的任何缓存、取消网络请求或清理在<code class="fe nd ne nf ng b">componentDidMount()</code>中创建的任何订阅。</p><p id="6727" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">你<strong class="la io">不应该调用<code class="fe nd ne nf ng b">componentWillUnmount()</code>中的</strong> <code class="fe nd ne nf ng b"><strong class="la io">setState()</strong></code>，因为组件永远不会被重新渲染。一旦组件实例被卸载，它将永远不会被再次装载。</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="52e4" class="nl kd in ng b gy nm nn l no np">componentWillUnmount() {<br/>  clearInterval(this.interval);<br/>}</span><span id="d61f" class="nl kd in ng b gy nq nn l no np">componentWillUnmount() {<br/> window.removeEventListener('resize', this.resizeListener)<br/>}</span></pre></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h1 id="a70e" class="kc kd in bd ke kf oa kh ki kj ob kl km jt oc ju ko jw od jx kq jz oe ka ks kt bi translated">错误处理</h1><p id="f145" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">当呈现过程中、生命周期方法中或任何子组件的构造函数中出现错误时，将调用这些方法。</p><ul class=""><li id="39b0" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt mc md me mf bi translated"><code class="fe nd ne nf ng b">static getDerivedStateFromError()</code></li><li id="6d55" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt mc md me mf bi translated"><code class="fe nd ne nf ng b">componentDidCatch()</code></li></ul><p id="9ed0" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">错误边界是React组件，它捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示一个回退UI，而不是崩溃的组件树。错误边界在渲染期间、在生命周期方法中以及在它们下面的整个树的构造函数中捕捉错误。</p><p id="7cff" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">如果一个类组件定义了生命周期方法<code class="fe nd ne nf ng b">static getDerivedStateFromError()</code>或<code class="fe nd ne nf ng b">componentDidCatch()</code>中的一个(或两个),它就会成为一个错误边界。通过更新这些生命周期的状态，您可以在下面的树中捕获未处理的JavaScript错误，并显示回退UI。</p><p id="f6c4" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">仅使用错误边界从意外异常中恢复；<strong class="la io">不要试图用它们来控制流程。</strong></p><blockquote class="ku kv kw"><p id="aa97" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:错误边界只捕捉树中</em>  <em class="in">下</em> <strong class="la io"> <em class="in">组件中的错误。错误边界不能捕捉自身内部的错误。</em></strong></p></blockquote><h1 id="6fcc" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">静态getDerivedStateFromError()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="7daf" class="nl kd in ng b gy nm nn l no np">static getDerivedStateFromError(error)</span></pre><p id="a543" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这个生命周期是在子代组件抛出错误后调用的。它接收作为参数抛出的错误，并应该返回值以更新状态。</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="ff8f" class="nl kd in ng b gy nm nn l no np">class ErrorBoundary extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { hasError: false };<br/>  }<br/>  static getDerivedStateFromError(error) {    <br/>     // Update state so the next render will show the fallback UI.  <br/>     return { hasError: true };  <br/>  }<br/>  render() {<br/>    if (this.state.hasError) {      <br/>        // You can render any custom fallback UI      <br/>        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    <br/>    }<br/>    return this.props.children;<br/>  }<br/>}</span></pre><blockquote class="ku kv kw"><p id="0808" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:</em> <code class="fe nd ne nf ng b"><em class="in">getDerivedStateFromError()</em></code> <em class="in">是在“渲染”阶段调用的，所以不允许有副作用。对于那些用例，用</em> <code class="fe nd ne nf ng b"><em class="in">componentDidCatch()</em></code> <em class="in">代替。</em></p></blockquote><h1 id="ef78" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">componentDidCatch()</h1><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="0793" class="nl kd in ng b gy nm nn l no np">componentDidCatch(error, info)</span></pre><p id="f69d" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">这个生命周期是在子代组件抛出错误后调用的。它接收两个参数:</p><ol class=""><li id="a857" class="lx ly in la b lb lc le lf lu lz lv ma lw mb lt nr md me mf bi translated"><code class="fe nd ne nf ng b">error</code> -抛出的错误。</li><li id="8194" class="lx ly in la b lb mg le mh lu mi lv mj lw mk lt nr md me mf bi translated"><code class="fe nd ne nf ng b">info</code> -带有<code class="fe nd ne nf ng b">componentStack</code>键的对象，包含关于哪个组件抛出错误的<a class="ae mq" href="https://reactjs.org/docs/error-boundaries.html#component-stack-traces" rel="noopener ugc nofollow" target="_blank">信息。</a></li></ol><p id="e317" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><code class="fe nd ne nf ng b">componentDidCatch()</code>是在“提交”阶段调用的，所以副作用是允许的。它应该用于记录错误:</p><pre class="ms mt mu mv gt nh ng ni nj aw nk bi"><span id="ea8c" class="nl kd in ng b gy nm nn l no np">class ErrorBoundary extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { hasError: false };<br/>  }</span><span id="2c84" class="nl kd in ng b gy nq nn l no np">  static getDerivedStateFromError(error) {<br/>    // Update state so the next render will show the fallback UI.<br/>    return { hasError: true };<br/>  }</span><span id="61ac" class="nl kd in ng b gy nq nn l no np">  componentDidCatch(error, info) {       <br/>     // Example "componentStack":    <br/>     // in ComponentThatThrows (created by App)    <br/>     // in ErrorBoundary (created by App)    <br/>     // in div (created by App)    <br/>     //  in App       <br/>     logComponentStackToMyService(info.componentStack);  <br/>  }</span><span id="6b8d" class="nl kd in ng b gy nq nn l no np">  render() {<br/>    if (this.state.hasError) {<br/>      // You can render any custom fallback UI<br/>      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;<br/>    }</span><span id="af46" class="nl kd in ng b gy nq nn l no np">    return this.props.children;<br/>  }<br/>}</span></pre><p id="0d23" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">React的生产和开发版本在处理错误的方式上略有不同。</p><p id="a6a6" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">在开发过程中，错误会上升到<code class="fe nd ne nf ng b">window</code>，这意味着任何<code class="fe nd ne nf ng b">window.onerror</code>或<code class="fe nd ne nf ng b">window.addEventListener('error', callback)</code>都会拦截被<code class="fe nd ne nf ng b">componentDidCatch()</code>捕获的错误。</p><p id="2300" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">相反，在生产中，错误不会冒泡，这意味着任何祖先错误处理程序将只接收没有被<code class="fe nd ne nf ng b">componentDidCatch()</code>显式捕获的错误。</p><blockquote class="ku kv kw"><p id="c577" class="kx ky kz la b lb lc jo ld le lf jr lg lh li lj lk ll lm ln lo lp lq lr ls lt ig bi translated"><em class="in">注意:如果出现错误，您可以通过调用</em> <code class="fe nd ne nf ng b"><em class="in">setState</em></code> <em class="in">使用</em> <code class="fe nd ne nf ng b"><em class="in">componentDidCatch()</em></code> <em class="in">呈现回退UI，但在未来的版本中将不再支持这种做法。改用</em> <code class="fe nd ne nf ng b"><em class="in">static getDerivedStateFromError()</em></code> <em class="in">处理回退渲染。</em></p></blockquote></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h1 id="2b50" class="kc kd in bd ke kf oa kh ki kj ob kl km jt oc ju ko jw od jx kq jz oe ka ks kt bi translated">结论</h1><p id="1b34" class="pw-post-body-paragraph kx ky in la b lb ml jo ld le mm jr lg lu mn lj lk lv mo ln lo lw mp lr ls lt ig bi translated">我们已经介绍了React组件的生命周期由三个阶段组成:安装、更新和卸载。</p><p id="2258" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">此外，您还了解了React在每个阶段调用一组特定的生命周期方法。您可以根据您想要实现的用例来使用它们。</p><p id="8b68" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated">感谢阅读！</p><p id="b3de" class="pw-post-body-paragraph kx ky in la b lb lc jo ld le lf jr lg lu li lj lk lv lm ln lo lw lq lr ls lt ig bi translated"><em class="kz">更多内容请看</em><a class="ae mq" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="kz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>