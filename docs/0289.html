<html>
<head>
<title>Using “switch” is not an anti-pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“开关”不是反模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-switch-is-not-an-anti-pattern-d8d03ac8ebc3?source=collection_archive---------5-----------------------#2021-01-17">https://javascript.plainenglish.io/using-switch-is-not-an-anti-pattern-d8d03ac8ebc3?source=collection_archive---------5-----------------------#2021-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8b83649ece59c193e11eba32572107b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5rW5qju0I0fvlG1u.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">It’s a switch. Use it.</figcaption></figure><h1 id="b9fb" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">摘要</h1><ul class=""><li id="345b" class="la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">基本枚举上的Switch语句有很多缺点。</li><li id="02db" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">许多限制可以通过使用动态调度或访问者模式来克服，这取决于您的用例。</li><li id="05dd" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">在本地支持sum类型的语言中，考虑使用这些类型而不是visitor模式。</li></ul><h1 id="297c" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="b067" class="pw-post-body-paragraph lx ly iq lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln ij bi translated">我最近看过几篇文章，认为<code class="fe mm mn mo mp b">switch</code>语句(甚至<code class="fe mm mn mo mp b">if</code>语句)是面向对象编程最佳实践的反模式。在某种程度上，这种情绪通常是好的，但我不认为这些文章真正讲述了完整的故事。让我们从函数式编程中吸取教训，找出什么时候使用<code class="fe mm mn mo mp b">switch</code>是可以的。</p><p id="a3fd" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">我将在本文中使用TypeScript，因为它支持所有必要的语言特性，并且通常非常易于阅读。</p><h1 id="500c" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">反对switch语句的论点</h1><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea29fb364e74ed7b5ac57a37642b8b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s4jaFGttIulDIwAX.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Trust me, it’s not.</figcaption></figure><p id="a238" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">在基本用法中，switch语句通常非常有限，用于匹配整数，有时是字符串。假设我们有两个函数<code class="fe mm mn mo mp b">draw</code>和<code class="fe mm mn mo mp b">area</code>，它们可以取一个单位正方形(边长为1)或一个单位圆(半径为1)。使用switch语句，代码如下所示:</p><pre class="mv mw mx my gt mz mp na nb aw nc bi"><span id="7bf9" class="nd kd iq mp b gy ne nf l ng nh"><strong class="mp ir">enum</strong> Shape {<br/>    UnitSquare,<br/>    UnitCircle<br/>}</span><span id="35fb" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> area <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">switch</strong> (shape) {<br/>        <strong class="mp ir">case</strong> Shape.UnitSquare:<br/>            <strong class="mp ir">return</strong> 1;<br/>        <strong class="mp ir">case</strong> Shape.UnitCircle:<br/>            <strong class="mp ir">return</strong> Math.PI;<br/>        <strong class="mp ir">default</strong>:<br/>            <strong class="mp ir">throw</strong> <strong class="mp ir">new</strong> Error("not a shape");<br/>    }<br/>}</span><span id="00ea" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> draw <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">switch</strong> (shape) {<br/>        <strong class="mp ir">case</strong> Shape.UnitSquare:<br/>            console.log("drawing a unit square");<br/>            <strong class="mp ir">return</strong>;<br/>        <strong class="mp ir">case</strong> Shape.UnitCircle:<br/>            console.log("drawing a unit circle");<br/>            <strong class="mp ir">return</strong>;<br/>        <strong class="mp ir">default</strong>:<br/>            <strong class="mp ir">throw</strong> <strong class="mp ir">new</strong> Error("not a shape");<br/>    }<br/>}</span><span id="7ea7" class="nd kd iq mp b gy ni nf l ng nh"><em class="nj">// usage</em><br/><strong class="mp ir">const</strong> doStuff <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    console.log(area(shape));<br/>    draw(shape);<br/>}<br/>doStuff(Shape.UnitSquare);<br/>doStuff(Shape.UnitCircle);</span></pre><p id="02d8" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">这段代码有许多问题:</p><ul class=""><li id="a0ef" class="la lb iq lc b ld mq lf mr lh nk lj nl ll nm ln lo lp lq lr bi translated"><code class="fe mm mn mo mp b">enums</code>只是整数，所以你不能设置正方形的边长或圆的半径。</li><li id="f517" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">如果添加另一个形状，您必须搜索所有代码，以找到不能涵盖所有情况的switch语句。如果您错过了一个，您可能会得到运行时错误。</li></ul><p id="e638" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">这段代码不好的原因可能更多。我会不情愿地承认它有一个好处:就其现状而言，代码非常容易阅读。没有魔法，它的布局方式非常清楚它的作用。</p><p id="219b" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">目前，我们有两个函数，每个函数都接受两个变量。我们可以交换一下，有两种变体，每种都有两种功能:</p><pre class="mv mw mx my gt mz mp na nb aw nc bi"><span id="3d15" class="nd kd iq mp b gy ne nf l ng nh"><strong class="mp ir">interface</strong> Shape {<br/>    <strong class="mp ir">area</strong>: () <strong class="mp ir">=&gt;</strong> <strong class="mp ir">number</strong>;<br/>    <strong class="mp ir">draw</strong>: () <strong class="mp ir">=&gt;</strong> <strong class="mp ir">void</strong>;<br/>}</span><span id="548a" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">class</strong> Circle {<br/>    <strong class="mp ir">private</strong> radius: <strong class="mp ir">number</strong>;</span><span id="6c97" class="nd kd iq mp b gy ni nf l ng nh">    <strong class="mp ir">constructor</strong> (radius: <strong class="mp ir">number</strong>) {<br/>        <strong class="mp ir">this</strong>.radius <strong class="mp ir">=</strong> radius;<br/>    }</span><span id="ecdb" class="nd kd iq mp b gy ni nf l ng nh">    area() {<br/>        <strong class="mp ir">return</strong> Math.PI <strong class="mp ir">*</strong> <strong class="mp ir">this</strong>.radius <strong class="mp ir">*</strong> <strong class="mp ir">this</strong>.radius;<br/>    }</span><span id="a226" class="nd kd iq mp b gy ni nf l ng nh">    draw() {<br/>        console.log("drawing a circle");<br/>    }<br/>}</span><span id="cdca" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">class</strong> Rectangle {<br/>    <strong class="mp ir">private</strong> width: <strong class="mp ir">number</strong>;<br/>    <strong class="mp ir">private</strong> height: <strong class="mp ir">number</strong>;</span><span id="c2cf" class="nd kd iq mp b gy ni nf l ng nh">    <strong class="mp ir">constructor</strong> (width: <strong class="mp ir">number</strong>, height: <strong class="mp ir">number</strong>) {<br/>        <strong class="mp ir">this</strong>.width <strong class="mp ir">=</strong> width;<br/>        <strong class="mp ir">this</strong>.height <strong class="mp ir">=</strong> height;<br/>    }</span><span id="d903" class="nd kd iq mp b gy ni nf l ng nh">    area() {<br/>        <strong class="mp ir">return</strong> <strong class="mp ir">this</strong>.width <strong class="mp ir">*</strong> <strong class="mp ir">this</strong>.height;<br/>    }</span><span id="efc1" class="nd kd iq mp b gy ni nf l ng nh">    draw() {<br/>        console.log("drawing a rectangle");<br/>    }<br/>}</span><span id="855c" class="nd kd iq mp b gy ni nf l ng nh"><em class="nj">//usage</em><br/><strong class="mp ir">const</strong> doStuff <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    console.log(shape.area());<br/>    shape.draw();<br/>}</span><span id="4da1" class="nd kd iq mp b gy ni nf l ng nh">doStuff(<strong class="mp ir">new</strong> Circle(2));<br/>doStuff(<strong class="mp ir">new</strong> Rectangle(2, 5));</span></pre><p id="cc6d" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">我们提供了一个接口，而不是一个<code class="fe mm mn mo mp b">enum</code>。<code class="fe mm mn mo mp b">Circle</code>和<code class="fe mm mn mo mp b">Rectangle</code>类实现了这个接口。这解决了最初提出的两个目标:</p><ul class=""><li id="3b05" class="la lb iq lc b ld mq lf mr lh nk lj nl ll nm ln lo lp lq lr bi translated"><code class="fe mm mn mo mp b">Circle</code>有半径，<code class="fe mm mn mo mp b">Rectangle</code>现在有高度和宽度。</li><li id="48bd" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">我们可以轻松地添加新类型的形状，而不必到处修改switch语句。</li></ul><p id="83cf" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">所以一切都很好，我们可以收工了，对吗？</p><h1 id="b2ad" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">游客</h1><p id="b259" class="pw-post-body-paragraph lx ly iq lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln ij bi translated">在我知道第二种形式是编写特定代码的最佳方式之前，我必须问一个关于我的程序的未来的问题:<strong class="lc ir"> <em class="nj">我是否更有可能向</em> </strong> <code class="fe mm mn mo mp b"><strong class="lc ir"><em class="nj">Shape</em></strong></code> <strong class="lc ir"> <em class="nj">接口添加新方法，或者我是否更有可能添加新类型？对于本文的其余部分，我将假设您更有可能添加新的行为而不是新的类型。如果这不是你的用例，那么你可以停止阅读，使用如上所示的界面，对<code class="fe mm mn mo mp b">switch</code>说再见。如果你不确定，那么继续阅读，你可能会学到一些新东西。</em></strong></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/857f49300f93e1c815667c48ef658b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YvKhhEgNuk5stB9H.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">I’m just here to fix the elevator.</figcaption></figure><p id="0436" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">向一个接口添加更多类型很容易:只需定义一个新类并实现该接口。您不必修改任何现有代码，只需添加新功能即可。但是，如果你想给<code class="fe mm mn mo mp b">Shape</code>接口添加一个新方法，那么<em class="nj">每一个实现</em>T3的类都需要修改。</p><p id="4a18" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">与我们使用switch语句的第一个代码示例相比。添加一个方法很容易，但是添加一个新的类型需要修改所有现有的代码。</p><p id="4ff6" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">与第二个例子相比，第一个例子具有完全相反的好处。然而，为了解决第一个例子的一些其他限制，一个OO爱好者可能会认识到我们可以使用访问者模式:</p><pre class="mv mw mx my gt mz mp na nb aw nc bi"><span id="b4a5" class="nd kd iq mp b gy ne nf l ng nh"><strong class="mp ir">interface</strong> ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong> {<br/>    circle: (circle: Circle) <strong class="mp ir">=&gt;</strong> T;<br/>    <strong class="mp ir">rectangle</strong>: (rectangle: Rectangle) <strong class="mp ir">=&gt;</strong> T;<br/>}</span><span id="d633" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">interface</strong> Shape {<br/>    <strong class="mp ir">visit</strong>: <strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>(visitor: ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>) <strong class="mp ir">=&gt;</strong> T;<br/>}</span><span id="f325" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">class</strong> Circle {<br/>    <strong class="mp ir">radius</strong>: <strong class="mp ir">number</strong>;</span><span id="c930" class="nd kd iq mp b gy ni nf l ng nh">    <strong class="mp ir">constructor</strong> (radius: <strong class="mp ir">number</strong>) {<br/>        <strong class="mp ir">this</strong>.radius <strong class="mp ir">=</strong> radius;<br/>    }</span><span id="ab77" class="nd kd iq mp b gy ni nf l ng nh">    visit <strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>(visitor: ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>) {<br/>        <strong class="mp ir">return</strong> visitor.circle(<strong class="mp ir">this</strong>);<br/>    }<br/>}</span><span id="a11e" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">class</strong> Rectangle {<br/>    <strong class="mp ir">width</strong>: <strong class="mp ir">number</strong>;<br/>    <strong class="mp ir">height</strong>: <strong class="mp ir">number</strong>;</span><span id="5c51" class="nd kd iq mp b gy ni nf l ng nh">    <strong class="mp ir">constructor</strong> (width: <strong class="mp ir">number</strong>, height: <strong class="mp ir">number</strong>) {<br/>        <strong class="mp ir">this</strong>.width <strong class="mp ir">=</strong> width;<br/>        <strong class="mp ir">this</strong>.height <strong class="mp ir">=</strong> height;<br/>    }</span><span id="574c" class="nd kd iq mp b gy ni nf l ng nh">    visit <strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>(visitor: ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>) {<br/>        <strong class="mp ir">return</strong> visitor.rectangle(<strong class="mp ir">this</strong>);<br/>    }<br/>}</span><span id="f95e" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> area: ShapeVisitor<strong class="mp ir">&lt;number&gt;</strong> <strong class="mp ir">=</strong> {<br/>    circle: (circle) <strong class="mp ir">=&gt;</strong> Math.PI <strong class="mp ir">*</strong> circle.radius <strong class="mp ir">*</strong> circle.radius,<br/>    rectangle: (rectangle) <strong class="mp ir">=&gt;</strong> rectangle.width <strong class="mp ir">*</strong> rectangle.height<br/>}</span><span id="9297" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> draw: ShapeVisitor<strong class="mp ir">&lt;void&gt;</strong> <strong class="mp ir">=</strong> {<br/>    circle: (_circle) <strong class="mp ir">=&gt;</strong> console.log("drawing a circle"),<br/>    rectangle: (_rectangle) <strong class="mp ir">=&gt;</strong> console.log("drawing a rectangle")<br/>}</span><span id="df7b" class="nd kd iq mp b gy ni nf l ng nh"><em class="nj">// usage</em></span><span id="c66e" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> doStuff <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    console.log(shape.visit(area));<br/>    shape.visit(draw);<br/>}</span><span id="e4b3" class="nd kd iq mp b gy ni nf l ng nh">doStuff(<strong class="mp ir">new</strong> Circle(2));<br/>doStuff(<strong class="mp ir">new</strong> Rectangle(2, 5));</span></pre><p id="71ef" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">访问者模式相当复杂，但它确实有效。</p><ul class=""><li id="cc85" class="la lb iq lc b ld mq lf mr lh nk lj nl ll nm ln lo lp lq lr bi translated">圆有半径，矩形有边长。</li><li id="b847" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">无需修改现有代码即可添加新功能。</li><li id="ada7" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">(奖金福利！)如果我们添加了一个新的变体(比如说我们添加了一个三角形)，那么编译器会给所有的访问者指出我们需要修改代码的地方，直到我们修复了代码才会编译。</li></ul><p id="0c4e" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">访问者模式实际上是从函数式编程书籍中抽出的一页:它是伪装的sum类型的教会编码。这听起来像是胡言乱语，但对我们人类来说，这意味着我们可以更简洁地编写访问者示例。请注意，我不赞成在有用的程序中使用教会编码，但我想把它包括在内，以证明它是多么不可读:</p><pre class="mv mw mx my gt mz mp na nb aw nc bi"><span id="2348" class="nd kd iq mp b gy ne nf l ng nh"><strong class="mp ir">interface</strong> ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong> {<br/>    circle: (radius: <strong class="mp ir">number</strong>) <strong class="mp ir">=&gt;</strong> T;<br/>    <strong class="mp ir">rectangle</strong>: (width: <strong class="mp ir">number</strong>, height: <strong class="mp ir">number</strong>) <strong class="mp ir">=&gt;</strong> T;<br/>}</span><span id="139c" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">interface</strong> Shape {<br/>    <strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>(visitor: ShapeVisitor<strong class="mp ir">&lt;</strong>T<strong class="mp ir">&gt;</strong>): T;<br/>}</span><span id="1150" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> Circle <strong class="mp ir">=</strong> (radius: <strong class="mp ir">number</strong>): Shape <strong class="mp ir">=&gt;</strong> <br/>    ({ circle }) <strong class="mp ir">=&gt;</strong> circle(radius);<br/><strong class="mp ir">const</strong> Rectangle <strong class="mp ir">=</strong> (width: <strong class="mp ir">number</strong>, height: <strong class="mp ir">number</strong>): Shape <strong class="mp ir">=&gt;</strong> <br/>    ({ rectangle }) <strong class="mp ir">=&gt;</strong> rectangle(width, height);</span><span id="8c67" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> area: ShapeVisitor<strong class="mp ir">&lt;number&gt;</strong> <strong class="mp ir">=</strong> {<br/>    circle: (radius) <strong class="mp ir">=&gt;</strong> Math.PI <strong class="mp ir">*</strong> radius <strong class="mp ir">*</strong> radius,<br/>    rectangle: (width, height) <strong class="mp ir">=&gt;</strong> width <strong class="mp ir">*</strong> height<br/>}</span><span id="6161" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> draw: ShapeVisitor<strong class="mp ir">&lt;void&gt;</strong> <strong class="mp ir">=</strong> {<br/>    circle: () <strong class="mp ir">=&gt;</strong> console.log("drawing a circle"),<br/>    rectangle: () <strong class="mp ir">=&gt;</strong> console.log("drawing a rectangle")<br/>}</span><span id="0986" class="nd kd iq mp b gy ni nf l ng nh"><em class="nj">// usage</em></span><span id="75b0" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> doStuff <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    console.log(shape(area));<br/>    shape(draw);<br/>}</span><span id="5ae5" class="nd kd iq mp b gy ni nf l ng nh">doStuff(Circle(2));<br/>doStuff(Rectangle(2, 5));</span></pre><p id="5041" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">在这个例子中，我们放弃了类，而是使用闭包。这具有访问者模式的所有优点，但是更不可读。教会编码不是编程的好方法。</p><h1 id="a7af" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">总和类型</h1><p id="a2f9" class="pw-post-body-paragraph lx ly iq lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln ij bi translated">在上面的例子中，我们提到了“求和类型”。sum类型可以是这样或那样的东西。例如，<code class="fe mm mn mo mp b">boolean</code>是<code class="fe mm mn mo mp b">true</code>和<code class="fe mm mn mo mp b">false</code>的和类型，因为它可以是<code class="fe mm mn mo mp b">true</code>也可以是<code class="fe mm mn mo mp b">false</code>。<code class="fe mm mn mo mp b">Shape</code>也是一个sum类型:它可以是<code class="fe mm mn mo mp b">Circle</code>也可以是<code class="fe mm mn mo mp b">Rectangle</code>。</p><p id="0bad" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">在上面的例子中，我们对sum类型使用了“教堂编码”。当您的语言本身不支持sum类型时，Church编码是一种可以使用的方法。幸运的是，TypeScript <em class="nj">不支持sum类型，所以我们更喜欢:</em></p><pre class="mv mw mx my gt mz mp na nb aw nc bi"><span id="f664" class="nd kd iq mp b gy ne nf l ng nh"><strong class="mp ir">type</strong> Shape <strong class="mp ir">=</strong> Circle <strong class="mp ir">|</strong> Rectangle</span><span id="bfed" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">interface</strong> Circle {<br/>    <strong class="mp ir">variant</strong>: 'circle';<br/>    <strong class="mp ir">radius</strong>: <strong class="mp ir">number</strong>;<br/>}<br/><strong class="mp ir">const</strong> Circle <strong class="mp ir">=</strong> (radius: <strong class="mp ir">number</strong>): Circle <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">return</strong> { variant: 'circle', radius };<br/>}</span><span id="42a2" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">interface</strong> Rectangle {<br/>    <strong class="mp ir">variant</strong>: 'rectangle';<br/>    <strong class="mp ir">width</strong>: <strong class="mp ir">number</strong>;<br/>    <strong class="mp ir">height</strong>: <strong class="mp ir">number</strong>;<br/>}<br/><strong class="mp ir">const</strong> Rectangle <strong class="mp ir">=</strong> (width: <strong class="mp ir">number</strong>, height: <strong class="mp ir">number</strong>): Rectangle <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">return</strong> { variant: 'rectangle', width, height };<br/>}</span><span id="f777" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> unreachable <strong class="mp ir">=</strong> (_x: never) <strong class="mp ir">=&gt;</strong> {};</span><span id="eb18" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> area <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">switch</strong> (shape.variant) {<br/>        <strong class="mp ir">case</strong> 'circle':<br/>            <strong class="mp ir">return</strong> Math.PI <strong class="mp ir">*</strong> shape.radius <strong class="mp ir">*</strong> shape.radius;<br/>        <strong class="mp ir">case</strong> 'rectangle':<br/>            <strong class="mp ir">return</strong> shape.width <strong class="mp ir">*</strong> shape.height;<br/>        <strong class="mp ir">default</strong>:<br/>            <strong class="mp ir">return</strong> unreachable(shape);<br/>    }<br/>}</span><span id="84a1" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> draw <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    <strong class="mp ir">switch</strong> (shape.variant) {<br/>        <strong class="mp ir">case</strong> 'circle':<br/>            console.log("drawing a rectangle");<br/>            <strong class="mp ir">return</strong>;<br/>        <strong class="mp ir">case</strong> 'rectangle':<br/>            console.log("drawing a circle");<br/>            <strong class="mp ir">return</strong>;<br/>        <strong class="mp ir">default</strong>:<br/>            <strong class="mp ir">return</strong> unreachable(shape);<br/>    }<br/>}</span><span id="86c2" class="nd kd iq mp b gy ni nf l ng nh"><em class="nj">// usage</em></span><span id="752f" class="nd kd iq mp b gy ni nf l ng nh"><strong class="mp ir">const</strong> doStuff <strong class="mp ir">=</strong> (shape: Shape) <strong class="mp ir">=&gt;</strong> {<br/>    console.log(area(shape));<br/>    draw(shape);<br/>}</span><span id="2cca" class="nd kd iq mp b gy ni nf l ng nh">doStuff(Circle(2));<br/>doStuff(Rectangle(2, 5));</span></pre><p id="72e5" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">有趣的<code class="fe mm mn mo mp b">unreachable</code>函数被用作静态断言。如果存在到达<code class="fe mm mn mo mp b">unreachable</code>函数的有效代码路径，程序将不会编译。我们不再需要在切换分支中抛出错误，因为编译器可以静态地确定默认分支永远不会被执行。这意味着如果你添加了一个新的变量(比如一个三角形),程序不会编译，除非你修改了所有相关的<code class="fe mm mn mo mp b">switch</code>语句。</p><h1 id="8956" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="1bec" class="pw-post-body-paragraph lx ly iq lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln ij bi translated">我们又兜了一圈。我们经历了漫长的旅程，但我们又回到了<code class="fe mm mn mo mp b">switch</code>声明。上面的代码本质上具有原始visitor示例的所有优点，因为语义上它们描述的是同一件事。</p><ul class=""><li id="13a1" class="la lb iq lc b ld mq lf mr lh nk lj nl ll nm ln lo lp lq lr bi translated">我们从enum上的交换机开始，发现它有很多缺点。</li><li id="81a1" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">我们可以通过使用访问者模式来解决这些缺点。</li><li id="a028" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">visitor模式是一种在不支持sum类型的语言中使用Church编码来描述sum类型的方法。</li><li id="3ba9" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">在支持sum类型的语言中，考虑直接使用它们。</li></ul><p id="327e" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">第一个和最后一个示例之间的区别是:</p><ul class=""><li id="8d9b" class="la lb iq lc b ld mq lf mr lh nk lj nl ll nm ln lo lp lq lr bi translated">switch语句匹配sum类型的变量，而不是基本的<code class="fe mm mn mo mp b">enum</code>。</li><li id="ab4f" class="la lb iq lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">由于<code class="fe mm mn mo mp b">unreachable</code>功能，switch语句是详尽的。</li></ul><p id="19f9" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">因此，如果你的语言支持sum类型，并且你认为你更有可能向现有类添加新功能，而不是添加新类型，那么考虑使用<code class="fe mm mn mo mp b">switch</code>。</p><h1 id="49a4" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">离别赠言</h1><p id="0c10" class="pw-post-body-paragraph lx ly iq lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln ij bi translated">在本身不支持sum类型的语言中，不要害怕使用访问者。毕竟，这是一种公认的设计模式。如果您发现自己需要基于类型进行分支，或者需要使用向下转换，那么可以考虑使用访问者作为替代。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="a51d" class="pw-post-body-paragraph lx ly iq lc b ld mq lz ma lf mr mb mc lh ms me mf lj mt mh mi ll mu mk ml ln ij bi translated">这篇文章最初发表在安德鲁的记事本上</p></div></div>    
</body>
</html>