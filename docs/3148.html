<html>
<head>
<title>Shallow and Deep Copy in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的浅层和深层复制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/copies-of-javascript-shallow-and-deep-copy-ac7f8dcd1dd0?source=collection_archive---------0-----------------------#2021-06-26">https://javascript.plainenglish.io/copies-of-javascript-shallow-and-deep-copy-ac7f8dcd1dd0?source=collection_archive---------0-----------------------#2021-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="08ed" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解并学习JavaScript中深层和浅层拷贝的区别</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/689b2893b1c37ea14f9417da25cd95fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JxlM1z-BtkGhPmlM"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="87f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript是一种高级动态类型语言。像大多数其他编程语言一样，JavaScript提供并允许支持深度复制和浅层复制的概念。就复制对象而言，将JavaScript与其他编程语言进行比较有点棘手。</p><p id="4cee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从高层次来看，复制品只是看起来像旧的东西，但不是。当您更改副本时，您希望原始内容保持不变，而副本却发生了变化。</p><p id="8f1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在编程语言中，我们将值存储在变量中。制作副本意味着您用相同的值初始化一个新变量。然而，在浅层拷贝和深层拷贝之间有一个很大的陷阱需要考虑。</p><p id="7b8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">浅拷贝</strong>:表示某些值或子值仍然与原变量相连。基本上，如果对象的任何字段被其他对象引用，它们共享相同的内存地址。</p><p id="9044" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们举个例子来更好地理解——</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b9f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">深度复制</strong>:与浅层复制不同，深度复制复制旧对象的所有属性，并为新对象分配单独的内存地址。这有助于我们创建一个克隆对象，而不用担心更改旧对象的值。根据对象结构的不同，创建深层副本的方法有很多种，但适用于所有类型的方法是JSON.parse()和JSON.stringify()。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b7be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们真的需要理解复制，我们必须了解如何在JavaScript中存储值。</p><h1 id="e0cc" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">原始数据类型</strong></h1><ul class=""><li id="e757" class="mj mk in kv b kw ml kz mm lc mn lg mo lk mp lo mq mr ms mt bi translated">数字(常数a = 1)</li><li id="bba8" class="mj mk in kv b kw mu kz mv lc mw lg mx lk my lo mq mr ms mt bi translated">字符串(const a = 'string ')</li><li id="5906" class="mj mk in kv b kw mu kz mv lc mw lg mx lk my lo mq mr ms mt bi translated">布尔值(常数a =真)</li><li id="89db" class="mj mk in kv b kw mu kz mv lc mw lg mx lk my lo mq mr ms mt bi translated">未定义(常数a =未定义)</li><li id="a7ce" class="mj mk in kv b kw mu kz mv lc mw lg mx lk my lo mq mr ms mt bi translated">null(常数a = null)</li></ul><p id="45da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您创建原始数据类型的副本时，您不需要担心，因为它们与变量紧密耦合。所以它将永远是一个真正的副本。让我们看一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><h1 id="38d1" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">复合数据类型</strong></h1><ul class=""><li id="6e93" class="mj mk in kv b kw ml kz mm lc mn lg mo lk mp lo mq mr ms mt bi translated">数组(从技术上来说，它们也是对象，所以它们的行为是一样的)。</li><li id="5b42" class="mj mk in kv b kw mu kz mv lc mw lg mx lk my lo mq mr ms mt bi translated">目标</li></ul><p id="457c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当您创建一个复合数据类型时，这些值实际上在实例化时被存储一次，分配一个变量只是创建一个对该值的引用。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="f9b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的例子中，我们实际上做了一个对象的浅层拷贝。这通常是有问题的，因为我们期望旧的变量有原始值，而不是改变的值。因为很多开发人员并不真正理解这个概念，也不希望对象发生变化。</p><p id="8718" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看复制复合数据类型的不同方法</p><h1 id="d17c" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">数组</strong></h1><p id="e3a3" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">对于复制，数组类似于复制对象，因为数组也是对象。</p><h2 id="0e0e" class="nc ls in bd lt nd ne dn lx nf ng dp mb lc nh ni md lg nj nk mf lk nl nm mh nn bi translated">传播算子</h2><p id="ab9b" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">从技术上讲，它不提供完整的深层拷贝。仅当数组不是嵌套数组或2D或3D等时，它才提供深度复制。如果数组是嵌套数组，它提供值的第一个实例的深层副本，所有嵌套数组都是浅层副本。为了更好地理解，我举了一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b982" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">数组方法——映射、ForEach和切片</strong></p><p id="89b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些方法都返回一个新数组，但它们不提供完整的深度复制，类似于spread运算符，它不为嵌套数组提供深度复制。下面是一个例子:</p><p id="0deb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">地图:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9f94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">切片:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9f85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">ForEach:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="df2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> JSON解析和Stringify方法</strong></p><p id="a327" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">毫无顾虑地复制对象的最好方法是JSON方法，它提供了完整的<strong class="kv io">深度复制</strong>。但是您可以为嵌套数组的深层副本创建自己的自定义函数，或者使用外部库，如JQuery和lodash。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><h1 id="80ac" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">目标</h1><p id="6c03" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">复制对象有很多种方法。</p><p id="25fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用assign方法时，我们必须确保对象至少复制第二个参数。通常你只需要传递一个空的对象作为第一个参数。它不提供类似于spread操作符的完整深度拷贝。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="b322" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Object.create() <br/>现有对象可用作原型，使所有属性可用于新对象。但是在复制方面，它提供了部分深度复制，如赋值和扩展操作符。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="d39e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">传播算子</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="8529" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们知道嵌套对象的深度，我们可以使用嵌套扩展操作符来实现深度复制。但是如果深度未知，那么最好避免对深度拷贝使用spread操作符。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="1262" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> JSON解析和Stringify方法</strong></p><p id="9bf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">毫无顾虑地复制对象的最好方法是JSON方法，它提供了完整的深度复制。但是您可以为嵌套数组的深层副本创建自己的自定义函数，或者使用外部库，如JQuery和lodash。下面是一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9da0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript中复制对象的唯一缺陷是嵌套值。</p><p id="ba31" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更多关于<strong class="kv io"> JSON解析和Stringify方法的见解:</strong><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/create-your-own-implementation-of-json-stringify-simiplied-version-8ab6746cdd1">https://JavaScript . plain English . io/create-your-own-implementation-of-JSON-Stringify-simi applied-version-8ab 6746 CD D1</a></p><p id="78b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="no">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="no">plain English . io</em></strong></a></p></div></div>    
</body>
</html>