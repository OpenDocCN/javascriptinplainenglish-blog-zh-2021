<html>
<head>
<title>How to Optimize Long Tasks (Blocking Javascript) in Browsers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化浏览器中的长任务(阻塞Javascript)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-optimize-long-tasks-blocking-javascript-in-browsers-d49508f72c9?source=collection_archive---------5-----------------------#2021-07-11">https://javascript.plainenglish.io/how-to-optimize-long-tasks-blocking-javascript-in-browsers-d49508f72c9?source=collection_archive---------5-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b744" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何优化可能在浏览器中阻塞和减慢操作的JavaScript任务。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bb7f53e8eb8a9fffd96b5c5c2642757d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zlGKHOCb5fqNnlAu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danial Igdery</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ec3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将了解JavaScript执行如何阻止浏览器执行的重要操作。其中一些对于增强<strong class="kv io"><em class="lp"/></strong>用户体验的<strong class="kv io"><em class="lp"/></strong><strong class="kv io"/>核心Web生命周期非常关键，尤其是对100ms内的用户交互做出响应(稍后将详细介绍)。</p><p id="442b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还将介绍如何找到这些阻塞任务以及优化它们的策略。这将导致一个更高性能的网站，从而更好的用户体验。</p><h1 id="a429" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">浏览器中是什么阻塞了Javascript还是一个长任务？</h1><p id="be9a" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">浏览器使用单线程，也称为<strong class="kv io"> <em class="lp">主线程</em> </strong>，来执行多种操作，如解析HTML、javascript执行、样式计算、重排、将像素渲染到屏幕等。</p><p id="5f51" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每当这个主线程忙于执行一个需要超过<strong class="kv io"><em class="lp">50毫秒</em> </strong>才能完成的任务时，这个主线程就被称为<strong class="kv io"><em class="lp"/></strong>阻塞，这个任务就被称为<strong class="kv io"> <em class="lp">长任务。</em> </strong></p><p id="b48e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在其他任务中，主线程最常见和最繁重的任务通常是Javascript  的<strong class="kv io"> <em class="lp">解析和执行。不足为奇的是，通常是javascript执行阻塞了主线程(需要超过50毫秒才能完成)。</em></strong></p><h1 id="98e1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">什么原因导致JavaScript任务需要超过50毫秒才能完成？</h1><p id="f946" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">最常见的情况是，在两种情况下，javascript执行需要超过50毫秒才能完成:</p><ol class=""><li id="4b91" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">一个<strong class="kv io"> <em class="lp">同步</em> </strong>函数，可能会被递归调用或做一些繁重的处理等。</li><li id="8ff2" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">具有多个<code class="fe nb nc nd ne b"><strong class="kv io">.then</strong></code> <strong class="kv io"> </strong>(或<code class="fe nb nc nd ne b">.catch</code> ) <strong class="kv io"> </strong>处理程序的承诺链。由于promise处理程序在微任务队列中排队，并且微任务队列中的任务被连续执行，直到队列为空，它可能最终阻塞主线程的时间超过50毫秒(我们将在后面的示例中看到这一点)。</li></ol><p id="4c96" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">为什么选择50ms作为长任务的阈值？这将在下一节中介绍。</em></p><h1 id="f6e1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">我们为什么要关心这些漫长的任务？</h1><p id="07d0" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">如前所述，大多数任务都是由主线程完成的。如果我们的主线程被javascript执行阻塞，比如在页面加载的初始阶段，一些重要的任务可能会被延迟。这可能会对<a class="ae ks" href="https://web.dev/vitals/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">核心网页要害</strong> </a> <strong class="kv io"> </strong>事件产生不利影响，像<a class="ae ks" href="https://web.dev/fcp/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">第一内容油漆</strong> </a>和<a class="ae ks" href="https://web.dev/lcp/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">最大内容油漆</strong> </a>这些事件对页面排名起主要作用。<em class="lp">通常，一些长任务属于第三方库。</em></p><p id="d615" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，根据<a class="ae ks" href="https://web.dev/rail/#response:-process-events-in-under-50ms" rel="noopener ugc nofollow" target="_blank"> RAIL模型</a>，如果用户在100毫秒内没有对他们的输入、按钮点击等行为做出任何反应，他们倾向于认为网站缓慢或滞后。</p><p id="4599" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">这就是选择50毫秒作为长任务阈值的原因。这个想法是允许主线程每隔50毫秒(如果没有长任务)处理一次用户输入的事件处理程序。执行这些事件处理程序可能需要一些时间，为此，我们保留了50毫秒的缓冲时间，因此用户输入和网站反应之间的总延迟达到100毫秒。</em></p><p id="5a19" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这在这个<a class="ae ks" href="https://web.dev/rail/#response:-process-events-in-under-50ms" rel="noopener ugc nofollow" target="_blank">页面</a>上有详细介绍，值得一读！</p><h2 id="8178" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">网速或CPU速度慢</h2><p id="4f14" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">除了我们的代码，对网站性能起重要作用的另外两个主要因素是网络速度和CPU能力。并非所有用户都拥有最佳的网络速度或CPU能力，尤其是移动用户。</p><p id="e417" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">比方说，如果长任务由于CPU速度慢而阻塞了主线程，主线程可能没有机会处理用户输入。如果网站没有针对这种情况进行优化，用户可能会不耐烦并很快离开。</p><h2 id="c73e" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">灯塔绩效评分</h2><p id="927b" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">除了上面提到的对第一内容油漆和最大内容油漆的潜在影响，长任务是降低灯塔测试中测量的<a class="ae ks" href="https://web.dev/tbt/" rel="noopener ugc nofollow" target="_blank">总阻塞时间</a> (TBT)的主要因素。</p><p id="bbf9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TBT测量从第一次内容丰富的绘画(FCP)到<a class="ae ks" href="https://web.dev/interactive/" rel="noopener ugc nofollow" target="_blank">交互时间</a> (TTI)之间执行的所有长任务(每个任务的50毫秒阈值除外)所用的总时间。优化它们的另一个原因。</p><h1 id="f46e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">我如何找到或衡量这些长时间的任务？</h1><p id="8934" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">根据经验，我们应该在优化之前进行测量。为了实现这个目标，我们有两个选择</p><ol class=""><li id="4674" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Long_Tasks_API" rel="noopener ugc nofollow" target="_blank">长任务API</a>(Firefox尚不支持)</li><li id="c9ba" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">Chrome DevTools  (Firefox在DevTools中有一个名为“Performance”的对等词)</li></ol><p id="e1ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我发现Chrome DevTools中的Performance标签对此更方便，所以我将用它来分享细节。然而，<em class="lp"> Chrome DevTools可能会很快与你的RAM发生激烈的争论</em>，如果你明白我的意思的话。</p><h2 id="a824" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">使用Chrome DevTools进行性能分析</h2><p id="5d5f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">你可以在这个<a class="ae ks" href="https://developer.chrome.com/docs/devtools/evaluate-performance/" rel="noopener ugc nofollow" target="_blank">页面</a>的Chrome DevTools中的Performance选项卡上找到所有细节。它有大量的特性可以帮助你更好地理解和分析你的网站的性能，但是它超出了本文的范围。</p><p id="3022" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们继续我们需要采取的步骤来确定长期任务—</p><p id="97d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">按<code class="fe nb nc nd ne b">F12</code>打开Chrome中的DevTools，点击Performance选项卡，你会看到类似下面截图的东西。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/8eda310122996d3431d5c69eed921280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuVDdz2nHuih8Y0rFFxPZw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The position of the Performance Tab might be different in your case as you can re-order these tabs by simple drag-n-drop. Yeah, chrome does make it convenient for us!</figcaption></figure><p id="de96" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">点击第二排右上角的<em class="lp">档位</em>图标，如下图(红色高亮显示)，选择<strong class="kv io">网速:<em class="lp">快速3G </em> </strong>和<strong class="kv io"> CPU节流:<em class="lp"> 4x或6x减速</em> </strong> <em class="lp">。</em>建议在记录性能之前调节CPU和网络速度，以模拟更真实的环境。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/1d9132fb7e3ec0c538b7d2e261b969ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TcUh7y6-Mi5m63izJ3W4Q.png"/></div></div></figure><h2 id="1209" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">同步码的性能分析</h2><p id="5e2d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">创建一个HTML文件，其中包含一个简单的按钮和一个事件处理程序<code class="fe nb nc nd ne b">handleButtonClick</code>，附加到它的click事件。<code class="fe nb nc nd ne b">handleButtonClick</code>函数通过运行while循环(同步代码)来保持主线程忙碌。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/da1fab9682a0503792d02895c93b88a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDI8rL6fbeXl57KPV-2k0w.png"/></div></div></figure><p id="9587" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，在浏览器中打开页面后，打开Chrome DevTools中的Performance选项卡，按下<em class="lp">记录按钮</em>。录音时，点击“点击我”按钮，约2秒后点击<em class="lp">停止</em>按钮停止录音。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/823fd04306cfa8f93ce895ce46c89595.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*G4cu2kDgoxbq55dGNEWSiw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Use the stop button to stop the recording</figcaption></figure><p id="b3c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦报告准备好了，chrome将显示类似下面的结果。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/0ada9b68ea80d3380c680e18a154c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4a1OR2gERF-CYqo4dp7riA.png"/></div></div></figure><p id="ae37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这份报告中有很多细节，但我们将把重点放在对我们来说重要的那些上。首先确保我们已经展开了<strong class="kv io"> <em class="lp">主</em> </strong>部分，其中包含了由主线程执行的任务<em class="lp">的<em class="lp">火焰图</em>。<br/>在下面的截图中，你可以看到右上角有一个带有<strong class="kv io">红色标记</strong>的<strong class="kv io">任务</strong>块。这个标记是Chrome加的，代表一个长任务。该块也用红色斜线<strong class="kv io">部分突出显示</strong>,表示长任务占用的50毫秒以上的阻塞时间。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/214308ea0b518ac6cbaa1496b0900155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*FcKi9jP3_mhulUoL_RzqqQ.png"/></div></figure><p id="d481" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以通过单击这些模块来查看更多详细信息。将打开一个类似于下面截图的部分，其中包含一些有用的见解。例如，通过点击<em class="lp">函数调用</em>块，我可以简单地看到这里指的是哪个函数(注意下面右边截图中的<code class="fe nb nc nd ne b">handleButtonClick @ index.html:20</code>)。</p><p id="d2d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">您还可以查看提供嵌套函数调用信息的其他选项卡，以及每个函数调用花费了多长时间来完成</em></p><div class="kd ke kf kg gt ab cb"><figure class="nx kh ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/39209229b601b1862585ac468a99f9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*0hchCIC00u_JFsGMt-nygA.png"/></div></figure><figure class="nx kh od nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/caf6d1101e477a0d728d46a0324624e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*odKAsaAdDl3v6CJR_eT7jg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk oe di of og">Details for Task Block (Left) | Details for Function Call (Right)</figcaption></figure></div><p id="613d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么这个任务最终变成了一个漫长的任务？<br/><code class="fe nb nc nd ne b">handleButtonClick</code>函数内的while循环保持主线程阻塞，直到<code class="fe nb nc nd ne b">counter</code>变为0。</p><h2 id="48f9" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">异步代码的性能分析</h2><p id="bbf7" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">让我们看一个承诺链的例子。考虑下面的HTML片段，它有一个承诺链，其中每个<code class="fe nb nc nd ne b">.then</code>处理程序阻塞主线程50毫秒。尽管如此，<code class="fe nb nc nd ne b">handleButtonClick</code>函数阻塞主线程的时间超过200毫秒。summary选项卡显示了该任务块所用的<em class="lp">总时间:216ms(承诺链为200ms)。</em></p><div class="kd ke kf kg gt ab cb"><figure class="nx kh oh nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/1975063fb7687d0aefbc9b37f52dccf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*5L-twLs0D3kkcJ3sTUbvfw.png"/></div></figure><figure class="nx kh oi nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/29e6760d76315518c57aadb2c6e01eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*LQNddIMritlOuB8n3e4qGw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk oj di ok og">How .then handlers in the Promise chain can block the main thread</figcaption></figure></div><p id="2d36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">为什么这个任务最后变成了一个长任务？<br/> </strong>一旦调用栈为空，事件循环就检查<em class="lp">微任务队列</em>，它是<em class="lp"> CPU密集型的</em>。所有的承诺处理者都在这里排队。如果有任务在这里等待，事件循环会执行所有的任务，并保持主线程阻塞，直到队列变空。</p><p id="437c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nb nc nd ne b">handleButtonClick</code>由一个包含4个对<code class="fe nb nc nd ne b">keepMainThreadBusy</code>函数调用的承诺链组成，最终被添加到<em class="lp">微任务队列</em>。因为这4个调用都是连续执行的，所以总时间加起来大约为200毫秒，而单个调用花费了大约50毫秒。</p><h1 id="eb92" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">那么，如何优化这些长任务呢？</h1><h2 id="5d51" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">网络工作者</h2><p id="3d03" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">优化某事最简单的方法就是不去做。考虑周到，不是吗？我们可以通过<strong class="kv io"> <em class="lp">不使用主线程</em> </strong>来实现这种优化。浏览器允许我们使用单独的线程通过<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> Web Workers </a>来执行。然而，这也有一些限制，比如缺少对DOM的直接访问，等等。</p><h2 id="4a34" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">在宏任务队列中调度回调</h2><p id="0a32" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在<em class="lp">宏任务队列</em>中排队的任务被区别对待。与<em class="lp">微任务队列</em>不同，事件循环在一个周期内只执行<em class="lp">宏任务队列</em>中的一个任务。我们可以利用这些知识尽可能地将长时间运行的任务分解成更小的任务。想法是保持这些较小任务的执行时间≤50毫秒</p><ul class=""><li id="dc65" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ol mt mu mv bi translated"><strong class="kv io">同步代码分解成较小任务的例子<br/> </strong>这里有一个我们如何分解潜在阻塞任务并批量执行它们的人为例子。请注意下图中的小块，它们代表批处理调用</li></ul><div class="kd ke kf kg gt ab cb"><figure class="nx kh om nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/5e1ff81ba646547563147918b73dfc07.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*iQpngVH8LbIRxpwmRmwPAA.png"/></div></figure><figure class="nx kh on nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/74538c7dbcbe47ca5a51be0c53acedd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*7tho3uIDBZzuUJtlFf5Aow.png"/></div></figure></div><ul class=""><li id="88f4" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ol mt mu mv bi translated"><strong class="kv io">异步代码分解成更小任务<br/> </strong>的例子这里有一个用<code class="fe nb nc nd ne b">setTimeout</code>调用<code class="fe nb nc nd ne b">keepMainThreadBusy()</code>的例子。因为传递给<code class="fe nb nc nd ne b">setTimeout</code>的回调被添加到<em class="lp">宏任务队列</em>中，所以<em class="lp">事件循环的每个周期只执行一个回调。这允许主线程执行其他操作，如执行事件处理程序和响应用户交互(如果有的话)。</em></li></ul><div class="kd ke kf kg gt ab cb"><figure class="nx kh oo nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/5250cf39bbade4092cfca10d3ad87625.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*epwC6LUDQRScjXL1jZn0mQ.png"/></div></figure><figure class="nx kh op nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/5c543136b157f1cd1e7febcbdbd340a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Pmvq57LAlDmC2hRXX7ZKhw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk oq di or og">Calling the function with setTimeout allows the browser to use the main thread for other important operations</figcaption></figure></div><h1 id="c812" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结论</h1><p id="afe0" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">使用我们讨论过的两种方法，我们可以实现更好的性能、用户体验，更重要的是更好的页面排名(核心Web生命分数):</p><ol class=""><li id="ab31" class="mn mo in kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated">通过在单独的线程上使用Web Workers执行我们的代码，并允许主线程专注于其他重要任务，如HTML解析、准备渲染树、渲染像素、响应用户输入等。</li><li id="fc3e" class="mn mo in kv b kw mw kz mx lc my lg mz lk na lo ms mt mu mv bi translated">或者使用<code class="fe nb nc nd ne b">setTimeout</code>函数将我们的javascript代码(特别标记为长任务)分解成更小的任务。这将使主线程尽可能有效地工作，并在没有任何不可接受的延迟的情况下执行所有操作</li></ol><p id="9655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然这种策略确实把长任务分解成了小任务，但是你可能想聪明地分解任务。对于长任务，javascript任务一次执行完毕，中间没有中断。然而，在使用了<code class="fe nb nc nd ne b">setTimeout</code>之后，中断的JavaScript任务可能会在两个较小的任务之间有一些额外的延迟，因为浏览器可能会使用主线程来执行不同的操作。确保您了解您正在中断什么任务，以及它会对整体功能产生什么影响。</p><p id="f8ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望这个策略能帮助你减少长任务的数量，改善你的总阻塞时间，从而改善用户体验。</p><p id="2a36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">如果你觉得这篇文章有帮助，可以考虑分享和鼓掌</em>:)</p><h2 id="3b3b" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">关于作者</h2><p id="3acd" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated"><a class="ae ks" href="https://www.linkedin.com/in/divyanshubhatnagar/" rel="noopener ugc nofollow" target="_blank"><em class="lp">Divyanshu bhat nagar</em></a>是<a class="ae ks" href="http://adpushup.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> AdPushup </em> </a>的软件工程师，这是一个收入优化平台，帮助出版商使用自动化A/B测试、标题竞价、创新广告格式和adblock恢复来增加广告收入。AdPushup正在积极招聘JavaScript工程师。如果你感兴趣，你可以在这里查看空缺职位。</p><p id="4dd6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">更多内容请看</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>