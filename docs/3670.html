<html>
<head>
<title>Algorithm: Rotated Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:旋转数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithm-rotated-array-94d976be0ff3?source=collection_archive---------12-----------------------#2021-07-23">https://javascript.plainenglish.io/algorithm-rotated-array-94d976be0ff3?source=collection_archive---------12-----------------------#2021-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="eefe" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">二分搜索法猛地一扭</h2></div><p id="5c7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我解决所有现存算法的旅程中，我在Leetcode等网站上遇到了许多有趣的问题。我最近遇到了一个非常标准的搜索算法，它有一个有趣的变化，让我停下了脚步。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/8bc2b37047d579f5f25338b5e1468b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xdEWTjszhHy7nGnn"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Dziedzic</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c246" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">问题是</h1><blockquote class="mh mi mj"><p id="9822" class="kc kd mk ke b kf kg jo kh ki kj jr kk ml km kn ko mm kq kr ks mn ku kv kw kx ig bi translated">编写一个名为<strong class="ke io">findroatedindex</strong>的函数，它接受一个排序数字和一个整数的旋转数组。该函数应该返回数组中整数的索引。如果找不到该值，则返回-1。</p></blockquote><p id="68c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来是个很标准的问题，对吧？让我们强行通过它，遍历整个数组，然后早点回家，好吗？不对！如果我们走捷径，我们就不是软件工程师了(另外，这个问题需要我们以O(log n)的时间复杂度来解决)。</p><h1 id="2cbd" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">分析</h1><p id="87ab" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">首先，什么是旋转数组？它只是一个经过移位的有序数组，所以数组中的最小值不在索引[0]处。</p><pre class="kz la lb lc gt mt mu mv mw aw mx bi"><span id="b167" class="my lq in mu b gy mz na l nb nc">// Regular array<br/>[1, 2, 3, 4, 5, 6]</span><span id="5a45" class="my lq in mu b gy nd na l nb nc">// Rotated array<br/>[3, 4, 5, 6, 1, 2]</span></pre><p id="fb72" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们不能简单地用二分搜索法方法。对于那些不熟悉的人来说，二分搜索法就是将数组一分为二，将中点与目标值进行比较。如果目标值小于中点，您可以将数组向左对半切割，否则，您可以向右对半切割。重复这个步骤几次，直到你锁定你的目标值。由于每次迭代都将数组减半，这大大减少了搜索时间，达到O (log n)，这正是我们想要的！</p><p id="be00" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，二分搜索法在旋转阵列上的问题是，我们不能确定这个旋转阵列的支点到底在哪里。在那之后，我们做什么？让我们开始吧。</p><h1 id="ffae" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">第一步:找到支点</h1><p id="317e" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">找到支点的第一步是分析一个旋转的数组，并思考关于每个旋转的数组的一些不变的事实。</p><ul class=""><li id="7e9f" class="ne nf in ke b kf kg ki kj kl ng kp nh kt ni kx nj nk nl nm bi translated">旋转后的数组可以围绕一个轴心点分成两半。</li><li id="4bec" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated">左边部分的每个值总是大于右边部分的每个值。</li></ul><p id="a073" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一项是关键。如果左边部分的每个值都大于右边部分的值，并且数组是以其他方式排序的，那么我们总是可以通过比较任意随机值和数组最右边的值来判断我们在哪个部分。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ns"><img src="../Images/755784be5f69107a08bc1965f2fb08de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVtcotI-Kzint559LELJsA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Rotated Array (A)</figcaption></figure><p id="efb5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">案例一:</strong>支点在中点的<em class="mk">右侧</em>。我们看到6是这个数组的中点。我们还可以看到，由于6比2(右边的点)大<em class="mk">，我们的中点是数组左边部分的一部分。我也用颜色标记了。因为6大于2，我们可以截掉数组的左半部分，就像二分搜索法一样，因为我们知道支点总是我们右半部分的开始。</em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nt"><img src="../Images/7e472857a48fe5eaf8f6315cc3742a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkRVh8RfQB51A5jx0zxrdg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Rotated Array (B)</figcaption></figure><p id="6c02" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">情况二:</strong>支点在左侧<em class="mk">或等于中点的</em>。我说“或等于”，因为如果我们将中间值与4(我们最右边的值)进行比较，绿色部分的任何值都将小于4，包括枢轴。在这种情况下，我们可以截掉数组的右半部分，用数组一半的大小重复循环。</p><p id="45ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这两种情况下，我们都将有新的数组，新的红绿部分的比例，但原则保持不变，直到我们缩小到支点。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nu"><img src="../Images/1121c2af9f0de98d1251e88f15c5dcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnDjJ_qezKA6FLJYapzTlQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Rotated Array (A)</figcaption></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nv"><img src="../Images/83f07f4ff207d8ccb59287f3451254d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLysySBUKBnxjqMxGoyQzg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Rotated Array (B)</figcaption></figure><p id="17ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以看到(特别是在例子B中)，原则上我们仍然保留了旋转数组，只是它们的尺寸缩小了。在示例A中，我们潦草地写下了6，因为我们确信它在红色部分，而不是我们所需要的。剩下要做的就是继续我们的循环，直到我们制作的<strong class="ke io">左</strong>和<strong class="ke io">右</strong>指针汇聚到支点上。</p><p id="f186" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码如下所示:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5a8c350d036c85b77fd6e241a2419608.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*My11_SkjPPIA2MCp4wn1tA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Find the pivot</figcaption></figure><p id="1f6d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以看到，场景A和B分别出现在第10行和第12行的条件语句中。</p><h1 id="4d05" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">步骤2:找到保存目标值的部分</h1><p id="8e39" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">现在我们有了支点(当我们退出循环时，它应该是我们的<strong class="ke io"> left </strong>值留下的值)，我们可以看到目标数字是在数组的绿色部分还是红色部分。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ns"><img src="../Images/755784be5f69107a08bc1965f2fb08de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVtcotI-Kzint559LELJsA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Example (A) — Target is ‘4’</figcaption></figure><p id="9721" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们试图找到<strong class="ke io"> 4的索引值。</strong>我们可以查看该值是否在中枢值和我们最右边的值之间，如果是，我们可以操作绿色部分，如果不是，我们操作红色部分。</p><p id="b400" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码如下:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/74af1ffb2b7bcac1719e94be6e9eb30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*Ey4ypHofvl1nQr8PQPtUMA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Picking our portion of the array.</figcaption></figure><p id="cfc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以在第16行看到，我们将<strong class="ke io"> pivot </strong>的值设置为<strong class="ke io"> left </strong>，因为我们认为这是步骤1中的情况。然后我们通过比较枢轴和最右边的目标<strong class="ke io"> num </strong>来检查它是否在数组的绿色部分。如果它在两者之间，它就在绿色部分，我们可以这样分割我们的数组，否则，我们将分割它，只看到红色部分。</p><h1 id="1a4f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">第三步:二分搜索法</h1><p id="3ba4" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">现在剩下的就是表演二分搜索法了。无论我们是对绿色部分还是红色部分进行操作，我们都有一个带有目标值的排序数组。</p><p id="ed91" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码如下:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9d3838336b5887afd8a15d4da24fbc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*gKE7atqhTtHBSP87UH7LqA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Binary Search</figcaption></figure><p id="2d91" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对那些从未见过这段代码的人的解释是:</p><p id="46ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们循环<code class="fe nz oa ob mu b">while (left &lt; right)</code>是因为我们不断地将数组减半，一旦左右相遇，我们要么找到了目标值，要么它不存在于循环中，所以我们可以突围。我们通过将左值和右值的底值相加并除以2来找到中间值(我们也可以计算上限，重要的是我们保持一致)。</p><p id="f28d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第28行，我们检查我们的中点是否是我们的值，如果是，我们完成并返回索引值。</p><p id="9c11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，我们检查目标是在中点的右边还是左边，并相应地对数组进行切片。最终，我们要么找到我们要找的目标，要么发现它不在数组中，我们的一生都是一个谎言。</p><p id="933d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我们旋转数组的完整代码:</p><div class="kz la lb lc gt ab cb"><figure class="oc ld od oe of og oh paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/947c6df596ac34b132960d4321f7ad34.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*qV-GezXDPqAmskaLwhiwDA.png"/></div></figure><figure class="oc ld oi oe of og oh paragraph-image"><img src="../Images/aa1b74129af36fd2c87a52e7590df698.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*w3zzn4NhCtOATTO-NuVOGw.png"/><figcaption class="lk ll gj gh gi lm ln bd b be z dk oj di ok ol">findRotatedIndex()</figcaption></figure></div><h1 id="3d6f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">概述</h1><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ns"><img src="../Images/755784be5f69107a08bc1965f2fb08de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVtcotI-Kzint559LELJsA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Rotated Array Example (A)</figcaption></figure><p id="330f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们意识到一个旋转的数组可以被分解成两部分，并找到一个支点。我们还发现右边部分必须总是小于左边部分的任何数字。这允许我们使用一个修改的二分搜索法来寻找支点。之后，我们将轴心点周围的数组分成绿色或红色部分(取决于我们的目标值)。最后，我们执行二分搜索法来找到我们的目标值。</p><p id="16e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这看起来比简单地遍历数组寻找目标值要复杂得多(对我们来说确实如此)，但实际上用二分搜索法来做要快得多。<strong class="ke io"> O(n) </strong>和<strong class="ke io"> O(log n) </strong>的差别是天文数字。如果数组中有1，000，000个数字，可能需要1，000，000次迭代，但是对于二分搜索法，最多需要20次。</p><p id="0a60" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您阅读本博客，并一如既往地在下面留下任何问题或评论。编码快乐！</p><p id="fb31" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mk">更多内容尽在</em><a class="ae lo" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="mk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>