<html>
<head>
<title>Redux Vs. Recoil: Why I’ve Moved from Redux to Recoil for State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux与反冲:为什么我从Redux转向反冲来进行状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/moving-from-redux-to-recoil-42aa9d9cfaad?source=collection_archive---------0-----------------------#2021-09-29">https://javascript.plainenglish.io/moving-from-redux-to-recoil-42aa9d9cfaad?source=collection_archive---------0-----------------------#2021-09-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/3b0c8659fc3bc8131142d32383357c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*fdA_8KAUC9hdKFnQCdGQow.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Recoil.js VS Redux.jS</figcaption></figure><p id="a9c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇博客解释了为什么React开发者需要从<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>转移到<a class="ae kt" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>。</p><h1 id="abb7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="6a03" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">管理应用程序状态总是一项困难的任务。React直到最近才拥有自己的状态管理工具。React开发人员添加了一个新的状态管理API，称为Context API。它有很多限制，并且只存储一个值。如果我们需要有多个状态，那么我们需要有多个<code class="fe lx ly lz ma b">context providers</code>。这使得React组件树相互嵌套。这使得代码难以阅读。对于开发人员来说，使用上下文API管理复杂的状态也是一项困难的任务。</p><p id="9b74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用第三方状态管理库，像Redux有一定的局限性。设置Redux的样板文件很复杂。用Redux设置React需要写很多东西。使用Redux管理具有巨大状态的复杂应用程序也很困难。</p><p id="2ff1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">反冲(React.js的新状态管理库)解决了这些问题。这是很容易和最少的设置。它认为状态是原子。原子可以用在任何反应组分中。</p><p id="2ac9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了用Redux区分反冲，我用两个库创建了同一个app。林挺的反冲需要多达56行代码，而Redux的相同应用需要多达100行代码。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="bbf0" class="ku kv in bd kw kx mo kz la lb mp ld le lf mq lh li lj mr ll lm ln ms lp lq lr bi translated">什么是后坐力？</h1><p id="8fb7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">反冲是一个React的状态管理库。</p><ul class=""><li id="9044" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">很容易设置。</li><li id="ecc2" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">它像React一样工作和思考。</li><li id="4065" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">它使用钩子来检索状态和更新状态。</li><li id="152d" class="mt mu in jx b jy nc kc nd kg ne kk nf ko ng ks my mz na nb bi translated">它使用纯函数来查询异步数据。</li></ul><h1 id="ebcc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">原子</h1><p id="2766" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">它储存了真理的来源(状态)。它可以是任何JavaScript类型，比如对象、数组或简单的数字。</p><ul class=""><li id="951a" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">通过将带有<strong class="jx io">键</strong>和<strong class="jx io">默认</strong> <em class="nh">属性</em>的对象传递给<code class="fe lx ly lz ma b">atom</code>函数来定义原子。</li></ul><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ni mg l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Recoil atom</figcaption></figure><ul class=""><li id="5efe" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">状态(存储在原子中)可以在任何反应组件中使用。</li></ul><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ni mg l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">using Recoil value</figcaption></figure><ul class=""><li id="16d3" class="mt mu in jx b jy jz kc kd kg mv kk mw ko mx ks my mz na nb bi translated">状态(存储在atoms中)可以更新！注意，我们使用了<code class="fe lx ly lz ma b">useRecoilState</code>钩子来代替<code class="fe lx ly lz ma b">useRecoilValue</code>。</li></ul><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ni mg l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">updating Recoil state</figcaption></figure><h1 id="0d60" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">反冲根</h1><p id="a944" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了使用使用反冲值的<code class="fe lx ly lz ma b">UsersList</code>组件，我们需要将它包装在反冲库中的<code class="fe lx ly lz ma b">RecoilRoot</code>组件中。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="ni mg l"/></div></figure><h1 id="686e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="0fd8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">作为一名React开发人员，我转向反冲，因为它非常容易使用。设置状态管理不需要复杂的样板文件。它使用钩子来读取或更新组件内部的状态。值得一试。</p><p id="d296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有更多关于反冲的问题需要解决，比如<code class="fe lx ly lz ma b">selectors</code>(衍生状态)。要找到更多关于后坐力的信息，请访问<a class="ae kt" href="https://recoiljs.org/docs/introduction/motivation" rel="noopener ugc nofollow" target="_blank">后坐力官方文档</a>，其中涵盖了更多概念。</p><p id="3089" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nh">更多内容尽在</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>