<html>
<head>
<title>A Quick Introduction to Immutable.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可变. js快速介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/immutable-js-efe6b42e122f?source=collection_archive---------12-----------------------#2021-07-09">https://javascript.plainenglish.io/immutable-js-efe6b42e122f?source=collection_archive---------12-----------------------#2021-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="190d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及JavaScript中不变性的含义</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/11c60bd53c5828f224ae76e9bdb2b401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRaJXlVyrlfrKtE3Z98a4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by the author from <a class="ae kv" href="http://immutable-js.com" rel="noopener ugc nofollow" target="_blank">immutable-js.com</a></figcaption></figure><p id="fd90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为不变性是最容易被误解的概念之一——尤其是对于JavaScript。然而，这并不困难。</p><p id="0028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">维基百科</a>上，是这样定义的:</p><blockquote class="ls lt lu"><p id="0939" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">[…]不可变对象(不可改变的对象)是一个对象，它的状态在创建后不能被修改。</p></blockquote><p id="c6f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不变性？在JavaScript中，我们有const关键字，对吗？嗯，没那么容易。我们来举个例子。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="5f5a" class="me mf iq ma b gy mg mh l mi mj">const person = "Max"<br/>person = "Tim" <br/>// error! </span></pre><p id="c782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将抛出一个错误，因为我们将<em class="lv"> person </em>定义为一个常量。我们不能重新分配用<code class="fe mk ml mm ma b">const</code>声明的变量。这就是问题的关键:许多人认为这是不变性——他们错了。</p><p id="4632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不能重新赋值并不意味着它是不可变的。<br/>下面是另一个例子:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="a3c0" class="me mf iq ma b gy mg mh l mi mj">const person = { name: "Max", age: 25 }<br/>person.name = "Tim"</span><span id="83e6" class="me mf iq ma b gy mn mh l mi mj">console.log(person) // { name: "Tim", age: 25 }</span></pre><p id="86a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mk ml mm ma b">const</code>可以保证不变性，我们就不能改变这里的<code class="fe mk ml mm ma b">name</code>属性。但事实正好相反:运行代码会非常好。</p><p id="ee6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象person现在包含“Tim”作为名称——我们改变了我们的对象，尽管我们使用了const关键字。然而，重新分配变量的以下代码不起作用:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="a727" class="me mf iq ma b gy mg mh l mi mj">const person = { name: "Max", age: 25 }</span><span id="9291" class="me mf iq ma b gy mn mh l mi mj">person = { name: "Karl", age: 22 }</span></pre><p id="2fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">const-keyword只防止重分配，不防止变异。</strong></p><p id="7c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们的物体可以如此容易地变异。为了使它完整，JavaScript中任何不是原始类型的东西都可以变异。JavaScript中的基本类型有字符串、数字、布尔等等。</p><p id="ec61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他所有东西，像数组甚至函数，基本上都是对象——正如我们刚刚学到的，它们可以在JavaScript中变异。</p><p id="87c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想你现在明白不变性到底是什么了。</p><h1 id="aea3" class="mo mf iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">试图使我们的对象在普通JS中不可变</h1><p id="4b40" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">好的，我们的目标是让我们的对象不可变——因为数组、集合、映射等等也是对象，我也指的是一般意义上的对象。</p><h2 id="400f" class="me mf iq bd mp nk nl dn mt nm nn dp mx lf no np mz lj nq nr nb ln ns nt nd nu bi translated">第一种方法—控制属性访问</h2><p id="d9fa" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">说实话，我知道这个功能还没那么久。当手动定义对象的属性时，我们可以控制它是否可写。</p><p id="d905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是例子。正如我们之前所学的，我们可以简单地改变一个对象的属性。让我们让老好人马克斯再高一点。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="33e1" class="me mf iq ma b gy mg mh l mi mj">const person = { name: “Max”, age: 25, height: 5.9 }</span><span id="1e2e" class="me mf iq ma b gy mn mh l mi mj">person.height = 6.1</span></pre><p id="bd35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这没有任何问题——高度属性现在是6.1。如果我们想避免改变值的可能性，我们可以将属性设置为writable: false。以下是方法:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="db90" class="me mf iq ma b gy mg mh l mi mj">const person = { name: “Max”, age: 25, height: 5.9 }</span><span id="2940" class="me mf iq ma b gy mn mh l mi mj">Object.defineProperty(person, “height”, {<br/>  writable: false<br/>})</span><span id="93d6" class="me mf iq ma b gy mn mh l mi mj">person.height = 6.1</span></pre><p id="566d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe mk ml mm ma b">person.height</code>仍然是5.9——即使我们试图改变属性，它也不会工作。然而，也没有警告(在严格模式下，它会导致错误)。变异根本不起作用。</p><p id="6c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法有点麻烦。尤其是因为我们只能让对象的一个属性不可变。如果我们想让所有的属性都不可变，我们就必须遍历所有的属性。当然，有更好的方法。</p><h2 id="59d4" class="me mf iq bd mp nk nl dn mt nm nn dp mx lf no np mz lj nq nr nb ln ns nt nd nu bi translated">第二种方法——冻结物体</h2><p id="b6e8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">早些时候，我们禁止进入个人财产。但是在defineProperty()旁边，还有一个函数，使得整个对象不可变。</p><p id="db09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再说一次，麦克斯是我们的小白鼠。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="53d4" class="me mf iq ma b gy mg mh l mi mj">const person = { name: “Max”, age: 25, height: 5.9 }</span><span id="54e9" class="me mf iq ma b gy mn mh l mi mj">Object.freeze(person)</span><span id="24c7" class="me mf iq ma b gy mn mh l mi mj">person.height = 6.1</span></pre><p id="42ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">身高属性仍然是5.9——同样，改变年龄或名字也不起作用。如你所见，我们成功地冻结了这个物体。此外，添加新的属性不再可能。</p><p id="5e86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，当试图改变任何东西时，都会导致错误，但只是在严格模式下。</p><h1 id="2dee" class="mo mf iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">不可变的. js——也许是更优雅的解决方案</h1><p id="1f9b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">不可变的. js是一个非常著名的JavaScript库，帮助我们实现不变性。然而，图书馆经常被误解。首先，重要的是理解一切都围绕着地图和列表——即使是“普通”的对象，比如我们的<em class="lv">人物</em>，也被视为这些数据结构。</p><p id="d96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，我们不要急着做任何事。首先，我们需要用<code class="fe mk ml mm ma b">npm install immutable</code>安装它。那我们就可以走了。</p><p id="1476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，有两种方法可以将我们的person-object从普通的JavaScript转换成不可变的. js对象，顾名思义，不可变的。</p><p id="4e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们可以把它定义为“从无到有”:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="4384" class="me mf iq ma b gy mg mh l mi mj">const { Map, fromJS } = require("immutable") </span><span id="32f6" class="me mf iq ma b gy mn mh l mi mj">const personIm = Map({ name: "Max", age: 25, height: 5.9 })</span></pre><p id="dff2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们只是使用Immutable.js的Map来包装我们的对象。</p><p id="3445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法是，将我们的plain-js对象转换成Immutable.js对象:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="fbea" class="me mf iq ma b gy mg mh l mi mj">const person = { name: "Max", age: 25, height: 5.9 }</span><span id="218b" class="me mf iq ma b gy mn mh l mi mj">const personIm = fromJS(person)</span></pre><p id="206c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者导致相同的结果。当我们想得到一个属性的值时，现在情况有点不同了。</p><p id="97db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到，在创建不可变的. js对象的第一种方法中，我们使用了库的Map-object。当我们使用<code class="fe mk ml mm ma b">fromJS</code>时，我们也接收到了Map-object。顾名思义，它基本上像我们从普通JavaScript中了解的<code class="fe mk ml mm ma b">map</code>一样工作。为了得到一个属性的值，我们写:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="5aa0" class="me mf iq ma b gy mg mh l mi mj">personIm.get("name") // "Max"</span></pre><p id="887c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要更改属性的值，有一个<code class="fe mk ml mm ma b">set</code>函数。但是由于我们的对象是不可变的，下面的代码不应该改变我们的对象:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="973b" class="me mf iq ma b gy mg mh l mi mj">const person = { name: "Max", age: 25, height: 5.9 }</span><span id="7f42" class="me mf iq ma b gy mn mh l mi mj">const personIm = fromJS(person)</span><span id="c4ce" class="me mf iq ma b gy mn mh l mi mj">personIm.set("name", "Carl")</span><span id="10a4" class="me mf iq ma b gy mn mh l mi mj">console.log(personIm.get("name")) // "Max"</span></pre><p id="bd14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！我们的人-物现在是不变的。当我们试图改变它时，什么也没有发生——也没有错误。原因很简单:这是被通缉的行为。实际上，当试图改变我们的对象时，会发生一些事情。但这不是要改变原来的物体。</p><blockquote class="ls lt lu"><p id="e2e2" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">试图改变一个不可变的对象，并不会改变这个对象——它会创建一个改变的副本</strong></p></blockquote><p id="3ad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们稍微修改一下代码时，我们可以更好地看到这一点:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="d4ce" class="me mf iq ma b gy mg mh l mi mj">const personCopy = personIm.set("name", "Carl")</span><span id="51d1" class="me mf iq ma b gy mn mh l mi mj">console.log(personIm.get("name"))     // "Max"<br/>console.log(personCopy.get("name"))   // "Carl"</span></pre><p id="dd9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，试图改变对象会创建一个副本。这就是Immutable.js的全部哲学——同样，当我们想给对象添加一个新属性时，它会返回一个新属性。</p><p id="f6c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅适用于Immutable.js中的<code class="fe mk ml mm ma b">Map</code>对象，也适用于它提供的其他数据结构——例如，Set或List。甚至<code class="fe mk ml mm ma b">delete</code>或<code class="fe mk ml mm ma b">update</code>函数也不会改变原始对象。</p><p id="a168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们总是返回原始对象的修改过的副本。</p><p id="3ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="lv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>