<html>
<head>
<title>Meet Clio: A Language for Easy Multithreading and More That Compiles to JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认识一下Clio:一种用于简单多线程和编译成JavaScript的语言</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/clio-3bd586052d9f?source=collection_archive---------12-----------------------#2021-10-06">https://javascript.plainenglish.io/clio-3bd586052d9f?source=collection_archive---------12-----------------------#2021-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b850" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解平行、管道、贴图等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/312e9f99847104f1bace41353dd75284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMM_0aBnUboVzer4wzgGUg.png"/></div></div></figure><p id="2b56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Clio是一种非常年轻的编程语言。一种编译成JavaScript的编程语言——不管是用于浏览器还是Node.js。虽然TypeScript“只是”JavaScript的超集，但Clio是一种全新的东西。它有令人兴奋的特性。</p><p id="293c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Clio是一种函数式编程语言。即使你不确定这意味着什么，也不要担心。Clio使入门变得相对容易。语法不难理解，不会向您介绍太多新的词汇，我们可以使用很多我们从JavaScript中了解到的东西。</p><p id="c012" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是为什么要给Clio一个机会呢？</p><h1 id="9e5a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">是什么让Clio如此有趣？</h1><p id="de51" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Clio想要实现几个目标。一会儿我会详细说明它们。</p><ul class=""><li id="6bcf" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">在前端和后端执行高性能的JavaScript代码。</li><li id="1754" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">通过网络使代码可重用，并通过这种方式使编写微服务变得容易。</li><li id="723e" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">提供可读、灵活、安全的功能代码。</li></ul><p id="bad1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道你被表演的事情炒作。尽管Clio最终会编译成JavaScript，但在某些情况下它仍能提供更好的性能。一个原因是编写并行执行代码非常容易。另一个原因是Clio正在进行的大量优化。</p><p id="d3a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个例子是递归函数的尾部调用优化。这种优化技术有助于避免在使用递归时滥发调用堆栈。说到性能，这可能会改变游戏规则。</p><p id="ab99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看下一点:Clio的目标是让代码可重用。函数式代码的哲学是编写可重用的函数。Clio允许我们托管它们，所以它们可以通过网络使用。甚至重用用其他编程语言编写的函数的能力也在计划之中。</p><p id="9b29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有以前的好处应该可以在一个整体，易于阅读和使用的语法。Clio提供这个。当读到Clio是一种函数式语言时，我一开始是持怀疑态度的。我以前用过Haskell和PureScript，两者都不是那么容易上手。另一方面，我发现Clios语法对初学者很友好。易用性的一个巨大好处是可以选择使用我们已经知道的JavaScript元素。我们稍后会谈到这一点。</p><h1 id="bd2b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">安装、运行和构建Clio</h1><p id="7922" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">安装这种语言很容易。就像对于PureScript，或者其他语言，编译成JS，我们用NPM: <code class="fe my mz na nb b">npm install -g clio</code>。</p><p id="e1ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装此软件将为您提供用于创建、运行和构建项目的CLI。以下是方法。</p><p id="1710" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要创建新项目，请使用:</p><p id="bb84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe my mz na nb b">clio new &lt;project-name&gt;</code></p><p id="de97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择名字由你决定。因为Clio是为浏览器和Node.js两者而设计的，所以template标签允许我们选择在哪个平台上构建代码。默认值是Node.js，我们保留它。</p><p id="0e16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目初始化后，您可以在编辑器中打开它。在“src”目录下，有一个名为<code class="fe my mz na nb b">main.clio</code>的文件。这是我们写代码的地方。</p><p id="4297" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，这里应该有一些“hello world”代码。可以用<code class="fe my mz na nb b">clio run</code>运行。</p><p id="5535" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将你的Clio代码编译成JavaScript可以和<code class="fe my mz na nb b">clio build</code>一起工作。执行此操作时，会出现一个名为“build”的目录。要运行编译后的JavaScript代码:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="0193" class="ng lo iq nb b gy nh ni l nj nk">node build/.clio/index.js</span></pre><p id="0015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我之前提到的，我们初始化了Node.js模板——而不是用于web的模板。准备好开始学习Clio的基础知识了吗？</p><h1 id="4fd0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">声明常数</h1><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ee53" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv:<br/> "Max" =&gt; name <br/> "Hello, "+ name -&gt; console.log</span></pre><p id="ee72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将Clio编译成JavaScript时，使用“const”关键字将常量转换成变量。</p><h1 id="0eb4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">理解函数</h1><p id="7808" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">函数就像在PureScript中一样工作——它们没有return关键字。相反，等号右边的所有内容都是返回的内容。至少，这是人们可以想象的。由于我们可以将表达式相互链接，实际上，最后一个求值的表达式是在Clio函数中返回的。</p><p id="a346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们没有把我们的论点放在括号里，而是把它们列出来，用空格隔开。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="b4f5" class="ng lo iq nb b gy nh ni l nj nk">fn multiply a b: <br/>  a * b</span><span id="c63a" class="ng lo iq nb b gy nl ni l nj nk">export fn main argv:<br/>  result = multiply 2 3<br/>  result -&gt; console.log<br/>  multiply 6 2 -&gt; console.log</span></pre><p id="390c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我们可以将函数调用存储在一个变量中并记录下来。或者，我们只记录函数调用。在上面的例子中，你可以看到两种方式。</p><p id="f7e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在控制台中，应该会出现“6”和“12”。</p><p id="1bea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你注意到我们在调用函数时使用了两种不同的语法吗？当我们写下后面的“乘法”函数的参数时，我们使用一个箭头将参数分配给<code class="fe my mz na nb b">console.log</code>。</p><p id="9f2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这并不是因为功能迫使我们这样做。我只想告诉你有两种方法。我们一会儿会谈到用箭的技巧。当然，我们也可以把<code class="fe my mz na nb b">console.log</code>称为另一种方式:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="3c9e" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv:<br/> console.log "Hello world"</span></pre><h1 id="3492" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">平静的</h1><p id="d804" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">管道就是我们用箭头做的，给函数赋值参数。实际上，我们可以结合管道(使用箭头)和其他方式来传递参数:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="0b3a" class="ng lo iq nb b gy nh ni l nj nk">fn minus a b: <br/>  a — b</span><span id="30e2" class="ng lo iq nb b gy nl ni l nj nk">export fn main argv:<br/> result = 6 -&gt; minus 2<br/> result -&gt; console.log</span></pre><p id="1ab8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果是“4”——因此您可以看到语法<code class="fe my mz na nb b">result = 6 -&gt; minus 2</code>与<code class="fe my mz na nb b">result = minus 6 2</code>相同。</p><p id="28b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">管道允许我们链接我们的函数调用。这是一个很好的例子:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="09c7" class="ng lo iq nb b gy nh ni l nj nk">fn add a b: <br/>  a + b</span><span id="0440" class="ng lo iq nb b gy nl ni l nj nk">fn double a: <br/>  a * 2</span><span id="dd30" class="ng lo iq nb b gy nl ni l nj nk">export fn main argv:<br/>  result = add 2 2 -&gt; double <br/>  result -&gt; console.log</span></pre><p id="7083" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">控制台中的结果是“8”。首先，将2和2相加，然后将结果4加倍。</p><p id="54ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说到管道，我们还可以用它来做别的事情。让我解释一下。方法是绑定到类的函数。因为几乎所有我们可以在数组、字符串和其他对象上使用的东西都被绑定到类，所以我们在这里说方法。使用管道语法，可以在Clio中对对象调用这些方法。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="4fb9" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv:<br/>  [1 2 3] -&gt; .reverse -&gt; console.log</span></pre><p id="f83b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将在控制台中打印“[3 2 1]”。请注意实际方法前面的点。上面的JS代码应该是:<code class="fe my mz na nb b">[1, 2, 3].reverse()</code>。因此，正如你所看到的，我们在这个上下文中没有使用管道来传递一些参数，而是调用一个对象上的方法。</p><h1 id="e43b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">如果，否则，否则如果</h1><p id="83c1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这些关键字几乎存在于所有的编程语言中。Clio也是如此。</p><p id="4246" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为这个例子说明了一切:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8349" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv:<br/>  10 =&gt; n<br/>  if n &lt; 5: "Less than 5" -&gt; console.log <br/>  else if n &lt; 8: "Less than 8" -&gt; console.log<br/>  else: "More than 8 and 5" -&gt; console.log</span></pre><h1 id="75ac" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">递归</h1><p id="f130" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">递归是函数式编程的核心概念。像许多其他函数式语言一样，Clio不提供循环。相反，我们使用递归来解决这类问题。因为我们刚刚知道了如何使用if、else和else if，所以我们有了编写递归函数的所有东西。</p><p id="9ddc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">斐波那契函数总是递归的一个很好的例子。它有助于强调您需要了解的关于Clio语法的内容:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="100c" class="ng lo iq nb b gy nh ni l nj nk">export fn fib n:<br/>  if n &lt; 2: n<br/>  else: (fib n — 1) + (fib n — 2)</span></pre><p id="888a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，完全相同的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2db9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在Clio中写递归的唯一问题是关于括号的。</p><p id="8861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我们不把参数放在括号中，但有时，我们需要把整个函数调用放在括号中。你可以在上面的Clio代码中看到我们做到了。这两个函数调用都需要包装。当我们在一行中有不止一个函数调用时，情况总是如此——至少，据我所知是这样。</p><h1 id="ab02" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">平行</h1><p id="3881" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这就是Clio大放异彩的地方。假设我们有一个数字数组，我们想对每个数字运行Fibonacci函数作为参数。在普通JavaScript中，我们可以使用forEach依次执行4个调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5c4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的机器上执行这段代码(以及Clio中的相同代码)大约需要10.3秒。这并不过分，但是执行四次相同的功能是并行计算的一个好例子。Clio让这变得简单。但是首先，为了了解它有多简单，让我们看看Clio中的非并行代码:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="530e" class="ng lo iq nb b gy nh ni l nj nk">export fn fib n:<br/>  if n &lt; 2: n<br/>  else: (fib n — 1)<br/>    + (fib n — 2)</span><span id="a306" class="ng lo iq nb b gy nl ni l nj nk">export fn main argv: <br/>  [42 42 42 42]<br/>    -&gt; * fib<br/>    -&gt; * (console.log @it)</span></pre><p id="aa98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将连续运行斐波那契函数——也需要大约10.3秒。通过使用所谓的三明治语法，我们初始化了fib函数调用的并行执行:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8163" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv: <br/>  [42 42 42 42]<br/>    -&gt; * [await] |fib|<br/>   -&gt; * (console.log @it)</span></pre><p id="2f60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并行函数是异步的，这就是为什么我们需要对它们使用await。除此之外，唯一改变的是在fib函数调用周围使用了“|”。就是这样。</p><p id="3ac1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的机器上执行这段代码只需要3.3秒。差别真大！</p><h1 id="f41b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">地图</h1><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="78eb" class="ng lo iq nb b gy nh ni l nj nk">fn double x: <br/>  x * 2</span><span id="093e" class="ng lo iq nb b gy nl ni l nj nk">export fn main argv:<br/>  [1 2 3] -&gt; * double -&gt; console.log</span></pre><p id="e184" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们只是在箭头后面添加了一个星号。为什么？</p><p id="c9b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为将整个数组应用于double函数是行不通的。我们需要将数组的每个元素传递给函数——可以说，我们将其映射到函数。</p><p id="972f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打印数组的每个值的方式是一样的:我们需要使用星号。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="f76d" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv: <br/>  arr = [4 2 6]<br/>  arr -&gt; * console.log</span></pre><h1 id="edf7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关于阵列的更多信息</h1><p id="4712" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">由于数组是如此重要的数据结构，我想在Clio中更多地介绍它。</p><p id="7193" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我提到的，Clio可以使用许多原生JavaScript特性。我之前展示过我们如何在一个数组上运行一个默认的数组方法:<br/> <code class="fe my mz na nb b">[1 2 3] -&gt; .reverse -&gt; console.log</code></p><p id="ee3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但这不是唯一的方法。此外，您可能想知道如何访问数组的默认对象属性，例如<code class="fe my mz na nb b">length</code>。幸运的是，我们可以使用原始的JavaScript语法来完成剩下的工作。那么，使用储备功能:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="733c" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv: <br/>  arr = [1 2 3]<br/>  arr.reverse() -&gt; console.log</span></pre><p id="2f7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想调用数组的对象属性:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="34c0" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv: <br/>  arr = [1 2 3]<br/>  arr.length -&gt; console.log</span></pre><p id="5071" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们想访问数组中的某个元素时，我们用前面显示的相同方法:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="c46a" class="ng lo iq nb b gy nh ni l nj nk">arr = [1 2 3]<br/>arr[0] -&gt; console.log</span></pre><p id="3c00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了帮助我们生成数组，我们可以使用range，就像在Python中一样:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="a060" class="ng lo iq nb b gy nh ni l nj nk">export fn main argv: <br/>  1..4 -&gt; .toArray -&gt; console.log</span></pre><p id="43c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将生成数组<code class="fe my mz na nb b">[1, 2, 3]</code>,因此范围总是不包括我们提供的第二个数字。</p><p id="e2a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Clio的基础就是这样。虽然不推荐在生产中使用Clio，但是关注这个项目可能是值得的。在我看来，潜力是巨大的——到目前为止，我喜欢这门语言。</p><p id="e9a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p><p id="6e4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想阅读更多关于JS中函数式编程的内容:</p><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-javascript-17032a113930"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">函数式JavaScript——一篇文章中的所有重要概念</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">了解原因和方式</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/purescript-cheatsheet-9ba7da3d393f"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">PureScript:编译成JavaScript的函数式语言</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">PureScript基础:对象、递归、映射等等</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oa l"><div class="og l oc od oe oa of kp nr"/></div></div></a></div><p id="ada5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="oh">更多内容尽在</em><a class="ae oi" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="oh">plain English . io</em></strong></a></p></div></div>    
</body>
</html>