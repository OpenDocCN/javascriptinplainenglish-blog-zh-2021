<html>
<head>
<title>The JavaScript Execution Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript执行模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-javascript-execution-model-part-1-448e62628f23?source=collection_archive---------3-----------------------#2021-03-09">https://javascript.plainenglish.io/the-javascript-execution-model-part-1-448e62628f23?source=collection_archive---------3-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="667e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:调用堆栈，事件循环</h2></div><p id="c77f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">这篇文章中的动画可视化是用</em><a class="ae kz" href="https://jsv9000.app/." rel="noopener ugc nofollow" target="_blank"><em class="ky">https://jsv 9000 . app</em></a><em class="ky">创建的——一个旨在帮助你可视化和了解事件循环的工具。</em></p><p id="43b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我写JavaScript已经有一段时间了。我用Express编写过web服务，用React编写过web应用，用React Native编写过移动应用，我还编写过库，比如<code class="fe la lb lc ld b"><a class="ae kz" href="https://github.com/Hopding/pdf-lib" rel="noopener ugc nofollow" target="_blank">pdf-lib</a></code>。</p><p id="d159" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，在开发<code class="fe la lb lc ld b">pdf-lib</code>时，我发现自己在处理一些长时间运行的同步代码。我对这段代码进行了优化，以尽可能快地运行。然而，当这段代码运行时，它有时会冻结网页，并导致浏览器警告用户某个脚本降低了速度。</p><p id="b0ad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我意识到这个功能需要以某种方式分解。它需要是异步的，以便允许其他工作在它完成之前完成。但是函数本身并没有做任何基本的异步工作(它没有发出任何HTTP请求或者执行任何文件I/O)。</p><p id="c620" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如何将一个基本同步的任务变成异步的呢？我不知道该怎么做。为了弄清楚这一点，我花了一些时间学习复杂的<code class="fe la lb lc ld b">setTimeout()</code>、<code class="fe la lb lc ld b">Promise.resolve()</code>、事件循环以及JavaScript的<a class="ae kz" href="https://en.wikipedia.org/wiki/Execution_model" rel="noopener ugc nofollow" target="_blank">执行模型</a>。</p><p id="1b2a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我写这一系列帖子的目的是分享我学到的东西。通读之后，我希望你能对JavaScript的执行模型有更好的理解，以及async JavaScript实际上是如何工作的。</p><h1 id="13b1" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">一个工作实例</h1><p id="2032" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们先写一些代码来重现我在制作<code class="fe la lb lc ld b">pdf-lib</code>时遇到的问题。我们大多数人都熟悉<a class="ae kz" href="https://en.wikipedia.org/wiki/Prime_number" rel="noopener ugc nofollow" target="_blank">素数序列</a>，所以让我们写一个函数来计算它:</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="de75" class="mj lf in ld b gy mk ml l mm mn"><strong class="ld io">function</strong> isPrime(n) {<br/>  <strong class="ld io">for</strong> (<strong class="ld io">let</strong> i = 2; i &lt; n; i++) {<br/>    <strong class="ld io">if</strong> (n % i === 0) <strong class="ld io">return</strong> <strong class="ld io">false</strong>;<br/>  }<br/>  <strong class="ld io">return</strong> <strong class="ld io">true</strong>;<br/>}<br/><br/><strong class="ld io">function</strong> computePrimes(onPrime, startAt = 2) {<br/>  <strong class="ld io">let</strong> currNum = startAt;<br/>  <strong class="ld io">while</strong> (<strong class="ld io">true</strong>) {<br/>    <strong class="ld io">if</strong> (isPrime(currNum)) onPrime(currNum);<br/>    currNum += 1;<br/>  }<br/>}</span></pre><ul class=""><li id="526b" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated"><code class="fe la lb lc ld b">isPrime()</code>功能非常简单。如果一个数是质数，它返回<code class="fe la lb lc ld b">true</code>，如果不是，则返回<code class="fe la lb lc ld b">false</code>。</li><li id="fa1a" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><code class="fe la lb lc ld b">computePrimes()</code>功能无限期运行。它检查从1到无穷大的每个数，看它是否是质数。每当找到一个，它就被传递给<code class="fe la lb lc ld b">onPrime</code>回调。</li></ul><p id="ec4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们试一试:</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="035c" class="mj lf in ld b gy mk ml l mm mn">computePrimes(prime =&gt; {<br/>  console.log(prime);<br/>});<br/><em class="ky">// =&gt; 1 2 3 5 7 11 13 ...</em></span></pre><p id="63fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(如果您在节点REPL中运行它，您必须按ctrl-c来停止它。在浏览器中，您只需关闭选项卡)</p><p id="aff6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记录素数很有趣，但我更希望看到我们计算出了多少个素数，而不是这些值本身。让我们做一个简单的网站来为我们渲染一个现场计数！</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="7bca" class="mj lf in ld b gy mk ml l mm mn">&lt;!DOCTYPE html&gt;<br/><strong class="ld io">&lt;html&gt;</strong><br/>  <strong class="ld io">&lt;head&gt;&lt;meta</strong> charset="utf-8" <strong class="ld io">/&gt;&lt;/head&gt;</strong><br/><br/>  <strong class="ld io">&lt;body&gt;</strong><br/>    <strong class="ld io">&lt;button</strong> onclick="startComputingPrimes()"<strong class="ld io">&gt;</strong>Start Computing Primes<strong class="ld io">&lt;/button&gt;</strong><br/>    <strong class="ld io">&lt;div</strong> id="primes-count"<strong class="ld io">&gt;&lt;/div&gt;</strong><br/>  <strong class="ld io">&lt;/body&gt;</strong><br/><br/>  <strong class="ld io">&lt;script</strong> type="text/javascript"<strong class="ld io">&gt;</strong><br/>    <em class="ky">/* Insert isPrime() and computePrimes() here... */</em><br/><br/>    <strong class="ld io">let</strong> primesCount = 0;<br/>    <strong class="ld io">const</strong> primesCountDiv = document.getElementById('primes-count');<br/><br/>    <strong class="ld io">function</strong> startComputingPrimes() {<br/>      computePrimes((prime) =&gt; {<br/>        primesCount += 1;<br/>        <strong class="ld io">if</strong> (primesCount % 500 === 0) {<br/>          <strong class="ld io">const</strong> msg = `Total Primes Found: ${primesCount}`;<br/>          primesCountDiv.textContent = msg;<br/>          console.log(msg);<br/>        }<br/>      });<br/>    }<br/>  <strong class="ld io">&lt;/script&gt;</strong><br/><strong class="ld io">&lt;/html&gt;</strong></span></pre><p id="85ad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您在浏览器中载入此网页时，您会看到以下内容:</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/5ad4909242f2d02c52af4b7e55fb4d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwjM5izm7FxBKqd1_784Sg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Webpage after first loading</em></figcaption></figure><p id="0844" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们点击“开始计算素数”按钮，看看会发生什么:</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/a494786d92290f464f27359c0a49c63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gf1jKWGE458QK5n23B29gg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Webpage after running for a short time</em></figcaption></figure><p id="05b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哦，那太糟糕了。我们没有实时的“找到的素数总数”计数。相反，浏览器警告我们网页运行缓慢，并给我们机会停止它。</p><p id="968c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的代码肯定在运行，你可以从它打印的日志中看到这一点。这意味着我们的<code class="fe la lb lc ld b">primesCountDiv.textContent = msg;</code>行也在执行。那么为什么我们的<code class="fe la lb lc ld b">primes-count</code> div不更新呢？而且不仅是我们的div卡住了，按钮还呈现按下的状态！由于某种原因，网页似乎没有重新呈现…</p><p id="8bac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看能否用魔法解决这个问题🎩🐇✨.把<code class="fe la lb lc ld b">computePrimes()</code>函数改写成这样:</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="5b6e" class="mj lf in ld b gy mk ml l mm mn"><strong class="ld io">function</strong> computePrimes(onPrime, startAt = 2) {<br/>  <strong class="ld io">let</strong> currNum = startAt;<br/>  <strong class="ld io">while</strong> (<strong class="ld io">true</strong>) {<br/>    <strong class="ld io">if</strong> (isPrime(currNum)) onPrime(currNum);<br/>    currNum += 1;<br/>    <strong class="ld io">if</strong> (currNum % 500 === 0) <strong class="ld io">break</strong>;<br/>  }<br/>  setTimeout(() =&gt; computePrimes(onPrime, currNum), 0); <em class="ky">// Magic‽</em><br/>}</span></pre><p id="a729" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当我们点击“开始计算质数”按钮时会发生什么？</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/5499559b8e9feb6cdf52d8efdea2a8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrRBBJqnca4dBg0nGcWRWQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Webpage after running with magic</em></figcaption></figure><p id="4805" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有用！但是为什么…？要回答这个问题，我们需要说说JavaScript的<strong class="ke io">调用栈</strong>和<strong class="ke io">事件循环</strong>。让我们从调用堆栈开始。</p><h1 id="b7a8" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">调用堆栈</h1><p id="1700" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">调用栈是JavaScript语言的基础部分。它是一个记录保存结构，允许我们执行函数调用。每个函数调用都被表示为调用堆栈上的一个<strong class="ke io">帧</strong>。这就是JavaScript引擎跟踪哪些函数被调用以及调用顺序的方式。JS引擎使用这些信息来确保在函数返回后，执行在正确的位置重新开始。</p><p id="9710" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当JavaScript程序第一次开始执行时，调用堆栈是空的。当进行第一次函数调用时，一个新的框架被推到调用堆栈的顶部。当该函数返回时，它的框架被弹出调用堆栈。让我们看一个例子。</p><p id="155d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑下面的代码片段:</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="d17b" class="mj lf in ld b gy mk ml l mm mn">function main() {<br/>  doStuff('baz');<br/>}<br/><br/><strong class="ld io">function</strong> doStuff(x) {<br/>  doThings(x);<br/>  foo();<br/>}<br/><br/><strong class="ld io">function</strong> doThings(y) {<br/>  console.log('Things done', y);<br/>}<br/><br/><strong class="ld io">function</strong> foo() {<br/>  <strong class="ld io">return</strong> 'bar';<br/>}<br/><br/>main();</span></pre><p id="73bd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看在执行上述代码片段时调用堆栈中进行的每个转换:</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/781edb5dbad1105a782023a414ff48fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*As8PYy4uq4RQ_vhLdV_flA.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Visualization of the Call Stack. Created with </em><a class="ae kz" href="https://jsv9000.app/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://jsv9000.app/</em></a></figcaption></figure><p id="5871" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种调用堆栈的可视化对我们大多数人来说都很熟悉。我们都对这里发生的事情有直观的感觉。然而，调用栈只是JavaScript执行模型的一部分。它没有讲述全部的故事。考虑以下片段:</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="3a13" class="mj lf in ld b gy mk ml l mm mn">function logA() { console.log('A') }<br/><strong class="ld io">function</strong> logB() { console.log('B') }<br/><strong class="ld io">function</strong> logC() { console.log('C') }<br/><br/>logA();<br/>setTimeout(logB, 100);<br/>logC();<br/><br/><em class="ky">// =&gt; A C B</em></span></pre><p id="d139" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe la lb lc ld b">B</code>怎么会是最后登录的？调用堆栈总是按顺序工作。但是我们在这里看到的是无序发生的。</p><p id="15cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe la lb lc ld b">setTimeout</code>负责我们看到的无序日志记录。我们所做的是告诉JavaScript在100毫秒内调用<code class="fe la lb lc ld b">logB</code>。因为计算机速度很快，所以在100毫秒之前，<code class="fe la lb lc ld b">logC()</code>就会被调用。</p><p id="07a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们通过了0毫秒的超时呢？</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="bdc3" class="mj lf in ld b gy mk ml l mm mn">logA();<br/>setTimeout(logB, 0);<br/>logC();<br/><em class="ky">// =&gt; A C B</em></span></pre><p id="d08b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有意思！同样的事情还是会发生。要理解为什么，我们需要理解<code class="fe la lb lc ld b">setTimeout</code>在幕后实际上在做什么。显然，这不是你的典型功能。它的行为不能仅用调用堆栈来解释。为了解释<code class="fe la lb lc ld b">setTimeout</code>是如何工作的，我们需要谈谈<strong class="ke io">事件循环</strong>。</p><h1 id="135d" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">事件循环</h1><p id="5340" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果调用堆栈跟踪现在正在执行的函数，那么事件循环跟踪将来将要执行的函数。术语<strong class="ke io">事件循环</strong>指的是两件事:</p><ul class=""><li id="3bc5" class="mo mp in ke b kf kg ki kj kl mq kp mr kt ms kx mt mu mv mw bi translated"><strong class="ke io">任务队列</strong>，任务的FIFO队列。</li><li id="580d" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">处理任务队列中任务的循环算法。</li></ul><p id="a262" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">任务</strong>是同步代码块。你可以把它们想象成<code class="fe la lb lc ld b">Function </code>物体。</p><p id="20b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事件循环通过连续循环任务队列并逐个处理它包含的任务来工作。事件循环的一次迭代称为<strong class="ke io">滴答</strong>。</p><pre class="mb mc md me gt mf ld mg mh aw mi bi"><span id="967b" class="mj lf in ld b gy mk ml l mm mn">while (EventLoop.waitForTask()) {<br/>  EventLoop.processNextTask();<br/>}</span></pre><p id="4727" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了处理一个任务，事件循环调用与之相关的<code class="fe la lb lc ld b">Function</code>。当任务运行时，它对调用堆栈具有独占访问权。事件循环等待处理下一个任务，直到当前任务完成，并且调用堆栈为空。</p><p id="c400" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当任务正在运行时，它可以将其他任务排入队列，以便在事件循环的后续节拍中进行处理。有几种方法可以做到这一点，其中最简单的是<code class="fe la lb lc ld b">setTimeout(taskFn, 0)</code>。任务也可以来自外部资源，如DOM和网络事件。</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nq"><img src="../Images/51fc576a37c113806a08e59d56a61cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruJn_MQsIIaEDpH2eJvXsg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">The JavaScript Event Loop</em></figcaption></figure><p id="30bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用调用堆栈和任务队列来可视化我们的最后一个代码片段:</p><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nr"><img src="../Images/db972211b5ef6ad1e4a60989a3c4d0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WTjgOc1RWsLG5UqAKDGl7A.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Visualization of the Call Stack. Created with </em><a class="ae kz" href="https://jsv9000.app/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://jsv9000.app/</em></a></figcaption></figure><h1 id="7832" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">一次一个事件</h1><p id="54f0" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JavaScript只有一个调用栈。因此，事件循环一次只允许处理一个任务。这形成了一个相对简单的执行模型，避免了JavaScript的大量并发问题。</p><p id="6370" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑<a class="ae kz" href="https://en.wikipedia.org/wiki/Reentrancy_(computing)" rel="noopener ugc nofollow" target="_blank">重入</a>，维基百科定义如下:</p><blockquote class="ns nt nu"><p id="47d6" class="kc kd ky ke b kf kg jo kh ki kj jr kk nv km kn ko nw kq kr ks nx ku kv kw kx ig bi translated">…如果一个计算机程序或子例程可以在执行过程中被中断，然后在其前一次调用完成之前被安全地再次调用(“重新进入”)，则该程序或子例程称为可重入的。中断可能是由内部动作(如跳转或调用)或外部动作(如中断或信号)引起的。一旦重入的调用完成，先前的调用将恢复正确的执行。</p></blockquote><p id="64a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript程序员不必担心让他们的函数可重入，因为它们永远不会被中断！JS函数总是运行到完成。</p><p id="fc59" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这个简单的执行模型并不是没有风险的。</p><p id="7c96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设一个“流氓”任务进入了调用堆栈。这个流氓任务永远不会结束运行，并无限期地占用调用堆栈。如果发生这种情况，流氓任务将阻止所有其他任务被处理。这意味着所有其他工作都将停止，阻碍关键任务，如重新渲染！</p><p id="1948" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，web浏览器会监控任务在调用堆栈上花费的时间。如果任务需要很长时间才能完成，浏览器会提醒用户并给他们“停止它”的选项，即从调用堆栈中删除任务并允许处理其他事件。</p><h1 id="f3e0" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">我们的魔法是如何运作的</h1><p id="e356" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们回到我们的例子。在我们添加魔法之前，我们的代码会导致网页冻结。过了一会儿，浏览器给了我们停止它的选项。这是因为我们的<code class="fe la lb lc ld b">computePrimes()</code>函数出了问题。在它被放入调用堆栈后，它就再也没有完成运行。它阻塞了调用堆栈并阻止处理呈现任务。</p><p id="fdf5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过添加一些魔法来解决这个问题。当然，这并不是<em class="ky">真正的</em>魔法。现在我们已经讨论了调用堆栈和事件循环，我们可以理解它实际上是如何工作的。</p><p id="04c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从一个无限长的任务开始。我们的魔法将它分解成一系列短时间运行的任务。每个任务将计算500个素数，然后让一个新任务排队来计算接下来的500个素数(使用<code class="fe la lb lc ld b">setTimeout(computePrimes, 0))</code>)。这允许JS引擎处理在素数计算之间排队的其他任务。</p><h1 id="ffca" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">没有魔法</h1><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ny"><img src="../Images/f27507b043e335f5368341bde2324fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9p_EzZAa4Iw1AG7jO9foZw.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Visualization of Naive Primes Implementation. Created with </em><a class="ae kz" href="https://jsv9000.app/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://jsv9000.app/</em></a></figcaption></figure><p id="0868" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意事件循环是如何一直停留在脚本评估步骤的。无论脚本运行多长时间，都不会移动到后续步骤重新渲染。</p><h1 id="32af" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">用魔法</h1><figure class="mb mc md me gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ny"><img src="../Images/23ed42f37ab6fd869d926fc6e9e5b1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bqyKb5cxGVx9aRMe6kWfLg.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk"><em class="no">Visualization of Primes with Tasks Implementation. Created with </em><a class="ae kz" href="https://jsv9000.app/" rel="noopener ugc nofollow" target="_blank"><em class="no">https://jsv9000.app/</em></a></figcaption></figure><p id="38a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意事件循环是如何通过它的每个阶段的。在检查了三个数字是否是质数之后，一个新的任务被加入队列，事件循环能够允许重新呈现。</p><h1 id="bd44" class="le lf in bd lg lh li lj lk ll lm ln lo jt lp ju lq jw lr jx ls jz lt ka lu lv bi translated">结论</h1><p id="a704" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">JavaScript是一种单线程、非阻塞、异步编程语言。作为JavaScript开发人员，我们每天都要处理这些语言特性。我们倾向于对如何编写和使用异步JavaScript有一个直观的理解。</p><p id="50f1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，对于我们中的许多人来说，这种直观的理解并没有得到对JavaScript的执行模型以及它如何在幕后工作的深刻理解的支持。这是不幸的，因为它会导致在不应该关心的事情上浪费精力(例如，使函数可重入)。它还会妨碍我们理解如何解决某些性能问题(例如，长时间运行的同步函数)。</p><p id="4d42" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章能帮助你更好地理解JavaScript的执行模型！请考虑阅读本系列的<a class="ae kz" href="https://andrewjdillon.medium.com/the-javascript-execution-model-part-2-467c7b9b42fa" rel="noopener">第二篇文章</a>，了解承诺是如何融入画面的。</p></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><p id="f6f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【2019年2月写了这篇文章。原来这里贴的是<a class="ae kz" href="https://qdivision.io/javascript/" rel="noopener ugc nofollow" target="_blank"><em class="ky"/></a><em class="ky">。</em></p><p id="b411" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ky">这篇文章关注的是调用栈和事件循环。</em> </strong> <a class="ae kz" href="https://andrewjdillon.medium.com/the-javascript-execution-model-part-2-467c7b9b42fa" rel="noopener"> <strong class="ke io"> <em class="ky">第二部分</em> </strong> </a> <strong class="ke io"> <em class="ky">以此为基础，讨论承诺如何融入画面。</em> </strong></p><h2 id="1aac" class="mj lf in bd lg og oh dn lk oi oj dp lo kl ok ol lq kp om on ls kt oo op lu oq bi translated">脚注</h2><p id="4c7d" class="pw-post-body-paragraph kc kd in ke b kf lw jo kh ki lx jr kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">[1]:这并不完全正确。例如，生成器和递归函数可以在其初始调用完成之前再次输入。然而，这不是运行时强加给开发人员的并发问题。所以这个场景并不代表开发人员通常关心的可重入性。</p><h2 id="3a92" class="mj lf in bd lg og oh dn lk oi oj dp lo kl ok ol lq kp om on ls kt oo op lu oq bi translated">额外阅读和观看</h2><ul class=""><li id="310d" class="mo mp in ke b kf lw ki lx kl or kp os kt ot kx mt mu mv mw bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li><li id="77fd" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/" rel="noopener ugc nofollow" target="_blank">https://blog . rising stack . com/writing-a-JavaScript-framework-execution-timing-beyond-settimeout/</a></li><li id="3b8b" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener ugc nofollow" target="_blank">https://jakearchibald . com/2015/tasks-micro tasks-queues-and-schedules/</a></li><li id="606d" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/event loop</a></li><li id="274f" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/microtask-and-macro task-a-hands-on-approach-5d 77050 e 2168</a></li><li id="7c92" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Tools/Performance/Scenarios/Intensive _ JavaScript</a></li></ul><h2 id="9950" class="mj lf in bd lg og oh dn lk oi oj dp lo kl ok ol lq kp om on ls kt oo op lu oq bi translated">主要来源</h2><ul class=""><li id="b7e4" class="mo mp in ke b kf lw ki lx kl or kp os kt ot kx mt mu mv mw bi translated"><a class="ae kz" href="https://www.ecma-international.org/ecma-262/9.0/index.html" rel="noopener ugc nofollow" target="_blank"> JavaScript语言规范</a></li><li id="53ba" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://www.w3.org/TR/html52/webappapis.html" rel="noopener ugc nofollow" target="_blank"> HTML脚本规范</a></li></ul><h2 id="7be6" class="mj lf in bd lg og oh dn lk oi oj dp lo kl ok ol lq kp om on ls kt oo op lu oq bi translated">二手来源</h2><ul class=""><li id="142b" class="mo mp in ke b kf lw ki lx kl or kp os kt ot kx mt mu mv mw bi translated"><a class="ae kz" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/event-loop-timers-and-next tick/</a></li><li id="a2cd" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://www.quora.com/Does-JavaScript-in-the-browser-have-the-equivalent-of-process-nextTick-or-setImmediate-in-node-js-or-do-we-just-have-setTimeout" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/Does-JavaScript-in-the-browser-have-the-equivalent-of-process-next tick-or-set immediate-in-node-js-or-do-we-just-have-setTimeout</a></li><li id="d3cd" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/26615966/how-to-make-non-blocking-javascript-code" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/26615966/how-to-make-non-blocking-JavaScript-code</a></li><li id="3016" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated">【http://latentflip.com/loupe/ T4】</li><li id="6dd3" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/38752620/promise-vs-settimeout" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/38752620/promise-vs-settimeout</a></li><li id="79cc" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/24117267/nodejs-settimeoutfn-0-vs-setimmediatefn" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/24117267/nodejs-settimeoutfn-0-vs-setimmediate fn</a></li><li id="c91b" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/779379/why-is-settimeoutfn-0-有时有用</a></li><li id="7194" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16" rel="noopener ugc nofollow" target="_blank">https://es discuse . org/topic/the-initial ization-steps-for-web-browsers # content-16</a></li><li id="fc35" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="noopener ugc nofollow" target="_blank">https://blog . session stack . com/how-JavaScript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f 077 c 4438 b 5</a></li><li id="d4d2" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a" rel="noopener ugc nofollow" target="_blank">https://blog . session stack . com/how-JavaScript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c 0757 f6a</a></li><li id="09c5" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2734025/is-JavaScript-guaranteed-to-be-single-threaded/2734311 # 2734311</a></li><li id="b373" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://en.m.wikipedia.org/wiki/Reentrancy_(computing)" rel="noopener ugc nofollow" target="_blank">https://en . m . Wikipedia . org/wiki/Reentrancy _(计算)</a></li><li id="3d4f" class="mo mp in ke b kf mx ki my kl mz kp na kt nb kx mt mu mv mw bi translated"><a class="ae kz" href="https://stackoverflow.com/a/19699970" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/19699970</a></li></ul></div></div>    
</body>
</html>