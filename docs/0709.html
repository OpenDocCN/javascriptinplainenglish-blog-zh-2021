<html>
<head>
<title>5 Strange JavaScript Quirks Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘5个奇怪的JavaScript怪癖</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-5-strange-javascript-quirks-demystified-61edd3e1f3a9?source=collection_archive---------9-----------------------#2021-02-13">https://javascript.plainenglish.io/top-5-strange-javascript-quirks-demystified-61edd3e1f3a9?source=collection_archive---------9-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="02d9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript可能很奇怪。我们来揭秘一些怪癖吧！</h2></div><p id="c093" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种有趣的语言，有着不可思议的可能性。然而，它不是没有怪癖的，不是吗？让我们来看看JavaScript中一些我们最喜欢的有趣的怪癖。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ac68c4501a2667eaa9df63b5b699b1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p99gSmcOZfIeBvCM"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f0eb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.逻辑比较</h1><p id="e047" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果<code class="fe mw mx my mz b">a == b</code>和<code class="fe mw mx my mz b">b == c</code>，那么肯定，<code class="fe mw mx my mz b">a == c</code>，对吗？让我们找出并打开我们的JavaScript控制台。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="bc68" class="ne ma iq mz b gy nf ng l nh ni">&gt; 0 == "0"<br/><strong class="mz ir">&lt; true</strong></span><span id="9c3c" class="ne ma iq mz b gy nj ng l nh ni">&gt; 0 == []<br/><strong class="mz ir">&lt; true</strong></span><span id="9feb" class="ne ma iq mz b gy nj ng l nh ni">&gt; "0" == []<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="7bc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，JavaScript并不总是这样！只有两个等号的抽象比较将根据等式左边和右边的数据类型而不同地工作。因为我们使用不同的数据类型，所以行为会有所不同。</p><p id="3a24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以深入研究<a class="ae lr" href="https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank"> EcmaScript抽象等式文档</a>。在这里，我们将找到不同数据类型的等式背后的确切逻辑。</p><p id="11f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么在JavaScript中使用抽象等式通常不是一个好的实践。如果我们用严格的等式进行同样的尝试，我们应该会得到更稳定的结果。让我们来看看。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="5c17" class="ne ma iq mz b gy nf ng l nh ni">&gt; 0 === "0"<br/><strong class="mz ir">&lt; false</strong></span><span id="f937" class="ne ma iq mz b gy nj ng l nh ni">&gt; 0 === []<br/><strong class="mz ir">&lt; false</strong></span><span id="cb5c" class="ne ma iq mz b gy nj ng l nh ni">&gt; "0" === []<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="0bff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个看起来好多了。数据类型都不一样，所以严格的等式总是会返回<code class="fe mw mx my mz b">false</code>。尽可能使用严格的等式。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4117" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">2.真的，还假的？</h1><p id="84c2" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在这个例子中，让我们对一个字符串做一些等式检查。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="248a" class="ne ma iq mz b gy nf ng l nh ni">&gt; "abc" == true<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="a343" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个字符串不是真的，我们不会期望有什么不同。这是有道理的。如果为假，下面的if语句就不应该执行，对吗？</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="14f3" class="ne ma iq mz b gy nf ng l nh ni">&gt; if ("abc") { console.log("'abc' is true!"); }<br/><strong class="mz ir">&lt; 'abc' is true!</strong></span></pre><p id="55b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等等，我们不是刚看到结果是假的吗？那么为什么要执行这条语句呢？如果我们使用双重否定技巧把它转换成一个布尔值，让我们也来看看这个值。如果你对此不熟悉，这将返回变量的负值，通过再次取反，我们得到变量的布尔值。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="69e7" class="ne ma iq mz b gy nf ng l nh ni">&gt; !!"abc"<br/><strong class="mz ir">&lt; true</strong></span></pre><p id="d5b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，这是真的？让我们把这些方程放在一起，试着弄清楚。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="0d93" class="ne ma iq mz b gy nf ng l nh ni">&gt; "abc" == true<br/><strong class="mz ir">&lt; false</strong></span><span id="aed9" class="ne ma iq mz b gy nj ng l nh ni">&gt; !!"abc"<br/><strong class="mz ir">&lt; true</strong></span><span id="cfea" class="ne ma iq mz b gy nj ng l nh ni">&gt; if ("abc") { console.log("'abc' is true!"); }<br/><strong class="mz ir">&lt; 'abc' is true!</strong></span></pre><p id="5166" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么变量是不是既有<code class="fe mw mx my mz b">true</code>又有<code class="fe mw mx my mz b">false</code>？不完全是。当我们用一个<code class="fe mw mx my mz b">if</code>比较一个字符串的值时，JavaScript会比较实际的字符串值。非空字符串将返回<code class="fe mw mx my mz b">true</code>，空字符串将返回<code class="fe mw mx my mz b">false</code>。在我们的例子中，<code class="fe mw mx my mz b">"abc"</code>不为空，返回<code class="fe mw mx my mz b">true</code>。</p><p id="11ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，但是<code class="fe mw mx my mz b">"abc" == true</code>返回<code class="fe mw mx my mz b">false</code>呢？类似于我们解释的第一个JavaScript怪癖，EcmaScript对抽象等式有一个定义，根据变量类型的不同，行为会有所不同。在本例中，<code class="fe mw mx my mz b">"abc" == true</code>，两边都将被转换成数字，根据EcmaScript定义。</p><p id="ca2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在我们这边模拟这个数字转换，使用<code class="fe mw mx my mz b">Number(obj)</code>函数。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="85ba" class="ne ma iq mz b gy nf ng l nh ni">&gt; Number("abc")<br/><strong class="mz ir">&lt; NaN</strong></span><span id="64e6" class="ne ma iq mz b gy nj ng l nh ni">&gt; Number(true)<br/><strong class="mz ir">&lt; 1</strong></span><span id="9bc0" class="ne ma iq mz b gy nj ng l nh ni">&gt; NaN === 1<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="b621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这类似于JavaScript正在做的事情，解释了<code class="fe mw mx my mz b">false</code>值。</p><p id="f88a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，严格的平等不会解决这个问题。这不是一个真正的问题，而是JavaScript的一个特性。当你在一个if中使用一个字符串时，它会检查这个字符串是否为空，这使得字符串值的检查变得容易。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="24a0" class="ne ma iq mz b gy nf ng l nh ni">let termsAndConditions = "Nobody really reads this!";</span><span id="7f17" class="ne ma iq mz b gy nj ng l nh ni">if (termsAndConditions) {<br/>    showTermsAndConditions();<br/>}</span></pre><p id="9110" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常有用的特性，但是开发人员应该注意比较中的不同行为，这在开始时可能会非常混乱。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bccd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">3.一个数组，不是一个数组？</h1><p id="2098" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们确实希望编程语言有逻辑意义。让我们深入JavaScript控制台，测试一些逻辑。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="1278" class="ne ma iq mz b gy nf ng l nh ni">&gt; 1 == 1<br/><strong class="mz ir">&lt; true</strong></span></pre><p id="2c41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很有道理，<code class="fe mw mx my mz b">1</code>应该等于本身，一。接下来看看<code class="fe mw mx my mz b">1</code>是否不等于<code class="fe mw mx my mz b">1</code>。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="7f5f" class="ne ma iq mz b gy nf ng l nh ni">&gt; 1 != 1<br/><strong class="mz ir">&lt; false</strong></span><span id="cddd" class="ne ma iq mz b gy nj ng l nh ni">&gt; 1 == !1<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="143d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前为止一切顺利，JavaScript！简单的逻辑做得很好。</p><p id="b56b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是数组呢？让我们看看一个数组是否等于它自己。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="d621" class="ne ma iq mz b gy nf ng l nh ni">&gt; [] == []<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="d8ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组不是数组？等一下！数组通过引用工作，这意味着我们实际上是在比较引用。由于我们实例化了两个空数组，所以它们在内存中的地址会不同，比较的结果会是<code class="fe mw mx my mz b">false</code>。为了真正地将数组与其自身进行比较，我们必须先将数组赋给一个变量，然后才能进行比较。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="1266" class="ne ma iq mz b gy nf ng l nh ni">&gt; let array = [];<br/>&gt; array == array<br/><strong class="mz ir">&lt; true</strong></span></pre><p id="c477" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，一个数组等于它自己！让我们继续进行与<code class="fe mw mx my mz b">1</code>相同的测试。接下来让我们试试阴性测试。我们现在知道了<code class="fe mw mx my mz b">[] == [] -&gt; false</code>，那么<code class="fe mw mx my mz b">[] != []</code>应该就是<code class="fe mw mx my mz b">true</code>了吧？既然是相反的，大部分逻辑都是这样的。让我们找出答案。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="efb2" class="ne ma iq mz b gy nf ng l nh ni">&gt; [] == ![]<br/><strong class="mz ir">&lt; true</strong></span><span id="d90f" class="ne ma iq mz b gy nj ng l nh ni">&gt; [] != []<br/><strong class="mz ir">&lt; true</strong></span></pre><p id="257a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，有道理。一个<code class="fe mw mx my mz b">false</code>方程的反义词是<code class="fe mw mx my mz b">true</code>。但是，这里不是有语义上的奇怪吗？</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="38b6" class="ne ma iq mz b gy nf ng l nh ni">&gt; [] == ![]<br/><strong class="mz ir">&lt; true</strong></span></pre><p id="efdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个数组，是，嗯..不是数组！<strong class="kh ir">JavaScript确认，并加盖批准章。</strong></p><p id="76ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解幕后发生的事情，我们需要看一下抽象等式的EcmaScript定义。</p><p id="f89b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们遵循这个流程，我们知道左边的数组将被转换成一个原始的数字类型，类似于我们之前讨论的怪癖。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="3275" class="ne ma iq mz b gy nf ng l nh ni">&gt; [] == ![]<br/><em class="nk">&gt; Number([]) == Number(![])<br/>&gt; 0 == 0</em><br/><strong class="mz ir">&lt; true</strong></span></pre><p id="69bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Denys Dovhan 在<a class="ae lr" href="https://github.com/denysdovhan/wtfjs#-is-equal-" rel="noopener ugc nofollow" target="_blank"> Wtfjs中也解释了这个JavaScript怪癖，这是一个非常大的JavaScript怪癖列表。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="446f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">4.A+数学！</h1><p id="c000" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">让我们来测试你的数学！什么是<code class="fe mw mx my mz b">0.1 + 0.2</code>？这是一个经典，但我不得不把它包括在这篇文章中。</p><p id="b3ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">准备好答案后向下滚动。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nl"><img src="../Images/d81f8c8ec860ac6149f88d36d7ca63aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AndubSXoA6TKd_RQ"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@glvrdru?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maxim Ilyahov</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ffdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你认为<code class="fe mw mx my mz b">0.3</code>，那么你错了，至少按照JavaScript的标准是这样的！让我们再次将它放入JavaScript控制台。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="866f" class="ne ma iq mz b gy nf ng l nh ni">&gt; (0.1 + 0.2) == 0.3<br/><strong class="mz ir">&lt; false</strong></span></pre><p id="626c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们在学校教我们的数学一直都是错的。JavaScript知道得更多。那么<code class="fe mw mx my mz b">0.1 + 0.2</code>到底是什么呢？</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="d580" class="ne ma iq mz b gy nf ng l nh ni">&gt; 0.1 + 0.2<br/><strong class="mz ir">&lt; 0.30000000000000004</strong></span></pre><p id="e56d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，这个很明显。当然<code class="fe mw mx my mz b">0.1 + 0.2</code>等于<code class="fe mw mx my mz b">0.30000000000000004</code>。就像<code class="fe mw mx my mz b">0.3 + 0.3</code>等于<code class="fe mw mx my mz b">0.60000000000000008</code>一样，对吧？</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="d40b" class="ne ma iq mz b gy nf ng l nh ni">&gt; 0.3 + 0.3<br/><strong class="mz ir">&lt; 0.6</strong></span></pre><p id="a8f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许不是，这看起来像是另一个JavaScript怪癖，等待去神秘化！别担心，我们的数学知识是安全可靠的。为了好玩，我们再试一次。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="fb2b" class="ne ma iq mz b gy nf ng l nh ni">&gt; 0.1 + 0.2<br/><strong class="mz ir">&lt; 0.30000000000000004</strong></span><span id="2e30" class="ne ma iq mz b gy nj ng l nh ni">&gt; (0.1 + 0.2) * 2<br/><strong class="mz ir">&lt; 0.6000000000000001</strong></span></pre><p id="b759" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript只是在嘲笑我们！小数，<code class="fe mw mx my mz b">4 * 2</code>当然等于<code class="fe mw mx my mz b">10</code>..那么，这里到底发生了什么？</p><p id="93b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算机计数的方式和人类不太一样，尤其是十进制数。我们习惯于使用以10为基数的十进制系统，然而，计算机使用以2为基数的十进制系统，使用位和字节。这个系统不能很好地处理低位小数。对于幕后发生的事情的更详细的解释，我强烈推荐TechTalkBook 的这篇文章。</p><p id="f886" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，在JavaScript中，十进制计算并不总是准确的。为了解决这个，可以使用额外的npm包比如<a class="ae lr" href="https://www.npmjs.com/package/big.js" rel="noopener ugc nofollow" target="_blank"> big.js </a>，它会进行更精确的小数计算。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="49f7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">5.加号不是减号的反义词？</h1><p id="e04e" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">让我们来玩玩JavaScript中的加号和减号，然后打开控制台。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="bbf6" class="ne ma iq mz b gy nf ng l nh ni">&gt; '9' - 1<br/><strong class="mz ir">&lt; 8</strong></span></pre><p id="fba3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很有希望，JavaScript理解一个字符串<code class="fe mw mx my mz b">'9'</code>可以是一个数字<code class="fe mw mx my mz b">9</code>，并减去1。虽然这种方法可行，但是要注意数据类型，这绝对不是推荐的方法。如果它和负号一起工作，它应该和正号一起工作，对吗？让我们试一试。</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="af85" class="ne ma iq mz b gy nf ng l nh ni">&gt; '9' + 1<br/><strong class="mz ir">&lt; "91"</strong></span></pre><p id="74a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到一个带有值<code class="fe mw mx my mz b">"91"</code>的字符串结果，这不是我们所期望的，因为加号是减号的反义词。</p><p id="2e83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是<code class="fe mw mx my mz b">+</code>操作符不仅仅是一个加号。它也是JavaScript中的串联运算符。JavaScript很困惑，因为通常一个字符串和一个<code class="fe mw mx my mz b">+</code>组合在一起会导致串联，但另一个参数是一个数字。因此，JavaScript试图将数字转换成字符串，并将它们连接在一起。</p><p id="408c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是JavaScript中数据类型的又一个陷阱。注意始终使用正确的数据类型，并在必要时进行显式转换。</p><p id="e06a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Wtfjs也在他们的列表中描述了这个行为。他们的怪癖清单真的很完整。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6c59" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="3bc8" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">JavaScript是一种有无数可能性的语言。因为它提供了一些自由，所以它也有一些怪癖。</p><p id="f447" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从上述怪癖中吸取一些教训:</p><ul class=""><li id="a94b" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated">作为开发人员，尽可能避免抽象等式<code class="fe mw mx my mz b">==</code>，使用严格等式<code class="fe mw mx my mz b">===</code>代替。</li><li id="8c74" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">虽然一个语句可以计算为<code class="fe mw mx my mz b">true</code>，但是在<code class="fe mw mx my mz b">if</code>中使用一个变量会有不同的结果，并且通常是在变量非空的情况下。</li><li id="058d" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">当处理小十进制数时，使用库来确保数学是准确的。</li><li id="4eab" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">注意数据类型，确保在必要时转换数据类型，并尽量避免混合数据类型。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="95ff" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">额外资源</h1><p id="34f1" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果你渴望更多的怪癖和它们的解释，看看下面的资源。</p><ul class=""><li id="d65e" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated"><a class="ae lr" href="https://github.com/denysdovhan/wtfjs" rel="noopener ugc nofollow" target="_blank">Wtfjs:Denys dov Han</a><a class="ae lr" href="https://github.com/denysdovhan" rel="noopener ugc nofollow" target="_blank">的一长串JavaScript怪癖</a></li><li id="9c04" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated"><a class="ae lr" href="https://dorey.github.io/JavaScript-Equality-Table/" rel="noopener ugc nofollow" target="_blank"> JavaScript等式表</a>由<a class="ae lr" href="https://github.com/dorey" rel="noopener ugc nofollow" target="_blank"> Dorey </a></li><li id="0c8a" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated"><a class="ae lr" href="http://big.js" rel="noopener ugc nofollow" target="_blank"> Big.js </a>，由<a class="ae lr" href="https://github.com/MikeMcl" rel="noopener ugc nofollow" target="_blank"> MikeMcl </a>开发的精确数学库</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="8b5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://kevinvr.medium.com/membership" rel="noopener">订阅我的媒介</a>到<strong class="kh ir">解锁</strong> <strong class="kh ir">所有</strong> <strong class="kh ir">文章</strong>。通过使用我的链接订阅，你是支持我的工作，没有额外的费用。你会得到我永远的感激。</p></div></div>    
</body>
</html>