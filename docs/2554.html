<html>
<head>
<title>Solving Complex Filters with the Chain of Responsibility Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript中的责任链设计模式解决复杂过滤器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-complex-filters-with-the-chain-of-responsibility-design-pattern-in-javascript-698907e06556?source=collection_archive---------1-----------------------#2021-05-26">https://javascript.plainenglish.io/solving-complex-filters-with-the-chain-of-responsibility-design-pattern-in-javascript-698907e06556?source=collection_archive---------1-----------------------#2021-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/04814d56f897bb3dc400448a28afd286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrWKLzySQ7rVB4mQZiZzLA.jpeg"/></div></div></figure><p id="2455" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将使用功能性更强的责任链设计模式，为基础对象上的重要过滤器创建干净、可维护和清晰的设计。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="ad98" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><ul class=""><li id="afb0" class="ly lz in jx b jy ma kc mb kg mc kk md ko me ks mf mg mh mi bi translated"><strong class="jx io"> <em class="mj">什么是责任链？</em>T3】</strong></li><li id="15b8" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"> <em class="mj">理解问题</em> </strong></li><li id="1fa0" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"> <em class="mj">动手</em> </strong></li><li id="87c1" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"> <em class="mj">结论</em> </strong></li></ul></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="313c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">责任链是什么？</h1><p id="483b" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">正如在《设计模式:可重用面向对象软件的元素》一书中所描述的，它是一种行为模式，允许你将一个请求(可以是一个原始参数、一个HTTP请求、一个对象等)传递给一系列操作器(隔离的函数或方法)。</p><p id="1ce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">收到请求后，处理程序决定是处理还是继续处理链中的下一个处理程序。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/f2abe308aa8504d77f2b20a5b4739278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXhNMp3RaaCxWJsFnZZx9Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">1.0 — Representation of the Chain of Responsibility Design Pattern.</figcaption></figure><p id="9e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上图所示，我们将左边的圆圈作为<strong class="jx io">请求</strong>。中间三个方块是<strong class="jx io">处理者</strong>，决定是否处理<strong class="jx io">请求</strong>。最后，三角形说明了调用的<strong class="jx io">结果。</strong></p><p id="b2ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重要的是要记住:操作者需要尊重相同的界面。</p><h1 id="e99a" class="la lb in bd lc ld nb lf lg lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx bi translated">理解问题</h1><p id="cf20" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">假设我们正在为餐馆开发软件，并且有一个<strong class="jx io"> customerOrder </strong>对象，包含客户购买的详细信息。</p><p id="007d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要过滤一个包含这些对象的列表，过滤器将基于精确的业务规则，这些规则是:</p><ul class=""><li id="ebc1" class="ly lz in jx b jy jz kc kd kg ng kk nh ko ni ks mf mg mh mi bi translated">通过外部链接访问系统的用户下的订单。</li><li id="712f" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated">交给收银员但尚未付款的订单。</li><li id="5edb" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated">在收银台确认的订单—收银员关闭订单，确定客户以现金、借记卡或信用卡支付的金额。</li></ul><p id="57f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了上面列出的这些首要要求，它们可能会根据<strong class="jx io">利益相关方的反馈</strong>而增加或改变。</p><h1 id="a0ee" class="la lb in bd lc ld nb lf lg lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx bi translated">亲自动手</h1><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">2.0 — Data structure that will be used in the example.</figcaption></figure><p id="bc7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一个<strong class="jx io"> protocols.js </strong>文件中，我们将拥有将要被过滤的数据结构。</p><p id="d7b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> byAccess </strong>属性引用发出请求的位置——由<strong class="jx io">本机应用</strong>或由<strong class="jx io">外部链接访问</strong>。</p><p id="9b18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随后，<strong class="jx io"> closeLocal </strong>引用客户下订单的地点——<strong class="jx io">收银台</strong>或由<strong class="jx io"> app </strong>自己付款。</p><p id="98e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<strong class="jx io"> justifications </strong>是一个包含对象的属性，其中包含支付信息。<strong class="jx io">如果是一个对象</strong>，你会有现金、借记卡或信用卡支付的金额。如果订单尚未支付，<strong class="jx io">将为空</strong>。</p><p id="ac40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面我们有另一个<strong class="jx io">字典文件</strong>，包含一些数字的规范——只是为了使实现代码更具解释性。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">2.1 — Numeric property specifications.</figcaption></figure><p id="c57f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们有实现本身。我将根据代码行解释每一点。</p><p id="6010" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注:当时如果要保存三个文件运行代码，在一个支持<strong class="jx io"> ES6模块</strong>的<strong class="jx io"> Node.js </strong>环境下运行。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">2.2 — Implementation of the Chain of Responsibility pattern.</figcaption></figure><p id="c280" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">处理对象【第4行】</strong>包含过滤规则。<strong class="jx io">每个规则都是一个在模式</strong>的解释中描述的处理程序。</p><p id="651e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，我们可以将规则视为规范，清楚地了解在该函数中要过滤的对象需要什么。</p><p id="5fff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在官方阅读中，示例倾向于使用尊重单个接口的方法(来自面向对象的偏见)。在这种情况下，最好是将一种方法与另一种方法联系起来，以实现目标。</p><p id="5aa3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的上下文中，函数之间的手动传递由过滤器总结。</p><p id="0451" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在函数<strong class="jx io">handleCustomerOrders[line 21]</strong>中，我们有一个实现，用于整个<em class="mj">【sick】</em>的工作。</p><p id="3a8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们执行<strong class="jx io"> Object.values </strong>方法时，我们将<strong class="jx io">句柄</strong>对象的值转换为一个函数数组。之后，只要击中目标。使用<strong class="jx io"> some </strong>方法，我们检查参数中的任何对象是否满足任何要求。</p><h1 id="3d80" class="la lb in bd lc ld nb lf lg lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx bi translated">结论</h1><p id="29c4" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">想象一下，这些规则位于一个超级复杂的对象之上，其中嵌套了许多子对象。</p><p id="c9a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者甚至在一个更大的环境中，我们可以接收一个服务请求，必须触发几个复杂的不同的规则，这些规则可以由业务团队不断发展？</p><p id="e10d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了责任链，我们能够将这些规则从较低层次的实现中分离出来，具有可维护性、单元可测试性和可扩展性。</p><h1 id="2dac" class="la lb in bd lc ld nb lf lg lh nc lj lk ll nd ln lo lp ne lr ls lt nf lv lw lx bi translated">参考</h1><ul class=""><li id="e4c2" class="ly lz in jx b jy ma kc mb kg mc kk md ko me ks mf mg mh mi bi translated">设计模式:可重用面向对象软件的元素。</li></ul><p id="b4f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">更多内容请看</em><a class="ae nl" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mj">plain English . io</em></a></p></div></div>    
</body>
</html>