<html>
<head>
<title>Obsidian 4.0.0 Technical Brief</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑曜石4.0.0技术简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/obsidian-4-0-0-technical-brief-7dbcdf46d9ce?source=collection_archive---------12-----------------------#2021-12-16">https://javascript.plainenglish.io/obsidian-4-0-0-technical-brief-7dbcdf46d9ce?source=collection_archive---------12-----------------------#2021-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5da5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Deno的首个GraphQL缓存解决方案中增加了服务器端缓存失效功能</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7899995cc07f553e94fee290596396f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnjhZs2mc7x7ASC0Kf9nsA.png"/></div></div></figure><h1 id="2288" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="cfc6" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Obsidian是Deno的第一个GraphQL缓存解决方案，使用浏览器缓存为React组件提供客户端缓存，使用Redis缓存为Oak路由器提供服务器端缓存。</p><h2 id="e1e2" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">脑海中的高性能缓存</h2><p id="6b78" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">因为GraphQL响应可以是任意大的和嵌套的，所以这些API调用有可能是昂贵的。在系统架构中引入GraphQL缓存策略提供了一种比调用GraphQL更便宜的替代方法:缓存检查。</p><blockquote class="mo"><p id="ce24" class="mp mq in bd mr ms mt mu mv mw mx mb dk translated">请求时间=缓存检查(命中率)+服务调用时间(1-命中率)+缓存写入(1-命中率)</p></blockquote><p id="3133" class="pw-post-body-paragraph lg lh in li b lj my jo ll lm mz jr lo lp na lr ls lt nb lv lw lx nc lz ma mb ig bi translated">当缓存命中时，请求时间相当于缓存检查时间。</p><p id="15bf" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">当存在缓存未命中时，请求时间相当于GraphQL调用时间和缓存写入时间。</p><p id="7faa" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">为了拥有一个高性能的缓存，Obsidian的首要任务是:<br/> 1)最小化昂贵的GraphQL服务调用<br/> 2)最大化缓存命中率</p><h1 id="099c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">缓存权衡</h1><p id="881c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">管理缓存空间和缓存一致性是缓存最具挑战性的方面，因为优先考虑其中一个会有所取舍。Obsidian 4.0.0为服务器端缓存引入了一个强大的缓存失效策略和一个免费的缓存回收策略。</p><h2 id="3539" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">缓存失效</h2><p id="929b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">假设对数据库中的所有科幻电影进行查询，不在缓存中，并且添加到缓存中。对这些科幻电影之一的后续改变(即创建、更新或删除)会使整个缓存响应失效。</p><p id="bc76" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">突变带来了一个挑战:如果缓存是静态的，不仅不可能知道什么是陈旧的，而且如果发生正确的突变，缓存中的所有内容都完全可能变得陈旧。</p><h2 id="d470" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">缓存回收</h2><p id="3be8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当缓存内存不足时，必须决定收回哪些空间来腾出空间。探讨的两个策略是最近最少使用和最少使用的策略。虽然两者的实现对于内置的Redis函数来说都是微不足道的，并且在用户选择哪种策略时，Obsidian路由器是不受影响的，但还是决定默认使用其中一种。</p><h1 id="9fb9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">黑曜石4.0.0:实现和原理</h1><blockquote class="mo"><p id="5df1" class="mp mq in bd mr ms mt mu mv mw mx mb dk translated">计算机科学中只有两个难题:缓存失效和事物命名</p></blockquote><p id="b9a9" class="pw-post-body-paragraph lg lh in li b lj my jo ll lm mz jr lo lp na lr ls lt nb lv lw lx nc lz ma mb ig bi translated">缓存失效和回收的优先级首先是最小化昂贵的服务调用，其次是最大化命中率。工程决策是通过这些优先级的透镜做出的。</p><h2 id="97f7" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">缓存失效</h2><p id="9e17" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">它们不是存储静态的GraphQL响应，而是在缓存之前被转换成引用。读取时，高速缓存块被反转换，然后被返回。如果缓存写入和缓存读取变得更加昂贵，会有什么样的补偿性权衡？</p><p id="a1db" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">这允许用户在发生突变时避免进行昂贵的GraphQL调用。如果存储的响应中只有一个元素发生了突变，就没有必要使整个响应无效。相反，只有一个元素是无效的。因为响应被转换成引用，所以反转换过程返回准确的响应。</p><p id="1809" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">为了使GraphQL响应缓存动态，实现了一个规范化的缓存。GraphQL响应被规范化，每个组件都用引用名添加到缓存中。这些引用在缓存之前替换GraphQL响应中的相应值。</p><p id="d128" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">变异查询及其响应永远不会被缓存。然而，它们正在运行。查询的GraphQL抽象语法树被检查以识别它是否是一个变异。此外，如果在缓存中发现了突变的响应，Obsidian会推断这是一个删除突变，并从缓存中删除该引用。在所有其他情况下，添加或更新突变，引用被写入缓存。</p><h2 id="a595" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">缓存回收</h2><p id="89a1" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">LFU是大多数驱逐策略的绝佳候选。它确保保留命中可能性较高的缓存片段，并驱逐未命中可能性较高的片段。因为LFU在Redis中优化了命中率和易于实现性，所以LFU是基本案例。黑曜石4.0.0决定默认使用LRU的原因是它更好地补充了新的缓存失效策略。</p><p id="1b5a" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">因为引用将比GraphQL响应本身更频繁地被读取，所以LRU是防止它们被驱逐的缺省值，因为它们比它们的引用组件更少被使用。虽然用户可以更改此默认设置，但强烈建议保持设置为LRU。</p><h2 id="17bb" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">重构的服务器端缓存逻辑</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/f9b653fc77805c8e198357c5a0e187b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pd3dn8Ld_vDxZZ63TGbwgA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Figure 1: Overall server-side cache logic flow diagram</figcaption></figure><p id="1bf0" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">有五种情况:<br/> 1)查询被缓存，并且没有引用被驱逐或删除<br/> 2)查询被缓存，并且至少有一个引用被驱逐或删除<br/> 3)查询没有被缓存，并且是读查询<br/> 4)查询没有被缓存，并且是删除变异<br/> 5)查询没有被缓存，并且是创建或更新变异</p><p id="4454" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">最好的情况是查询被缓存，没有引用被收回。这使得用户不必调用GraphQL，而是用廉价的缓存读取来代替该操作。所有其他场景都需要GraphQL调用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c3f811172828b60d1d1e53b3af04a47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*FcB7HkVn6TexlpPCJqnwVA.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Figure 2: Redesigned function flow of server-side caching logic which incorporates cache invalidation</figcaption></figure><p id="dd21" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">服务器端缓存逻辑经过重新设计，加入了缓存失效功能。最初，设计涉及两条独立的路径:一条用于缓存命中，一条用于缓存未命中。经过进一步的考虑，很明显，被驱逐或删除的引用需要运行查询。因为另一种选择是返回不完整的响应，所以GraphQL调用的这种折衷是值得的。</p><p id="afb6" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在缓存命中并且在缓存中找到所有引用的情况下，detrasformation进程从缓存的引用中动态地重建预期的GraphQL响应。</p><p id="0ad1" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在缓存命中的情况下，如果在缓存中没有找到至少一个引用(即，它被逐出或删除了)，则进行GraphQL服务调用，其响应被附加到Obsidian的响应体，引用值被重新写入缓存。</p><p id="e0a7" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在缓存未命中的情况下，会进行GraphQL服务调用，其响应会附加到Obsidian的响应体。为缓存执行后续操作。GraphQL响应是规范化的，对读取查询、删除变异和所有其他操作执行单独的操作。</p><p id="b8ce" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在read查询的情况下，GraphQL响应被转换成一个引用对象，并使用它的查询字符串作为Redis散列进行缓存。此外，每个引用对象都以其引用字符串作为Redis散列进行缓存。</p><p id="3e8f" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在删除突变的情况下，引用从GraphQL响应中提取，并通过删除从缓存中失效。</p><p id="2ace" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在所有其他情况下——不管是创建变异还是更新变异——每个引用对象都用其引用字符串作为Redis散列进行缓存。如果引用已经存在，它将被更新的值覆盖。</p><h2 id="bf88" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">规范化、转换和去转换</h2><p id="f74f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">举例来说，下面的GraphQL响应将通过核心功能为缓存做准备。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4c3cdfb94035c97ff2926a9e7218efe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*6Dt19hd4GTuzGL2k5Vh7_Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Figure 3: GraphQL response to be processed</figcaption></figure><p id="c86a" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">新的服务器端缓存逻辑的支柱是递归规范化算法。任意嵌套的GraphQL响应在线性时间内被展平为唯一引用字符串键的对象及其对应的对象。</p><p id="4637" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">这些引用字符串由默认为“id”和“__typename”数组的唯一标识符创建。如果一个对象包含所有的唯一标识符作为属性，那么它就被认为是可散列的。这将被剪切并添加到规范化对象中，直到任何嵌套点。嵌套是通过递归调用函数来遍历的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4576891b30f1a291607ef02c282824f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*VOXmNDGbxHLNs2-UkyzGrQ.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Figure 4: Normalized GraphQL response with references and corresponding values</figcaption></figure><p id="1dbf" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">在转换过程中，对象被替换为引用。嵌套是通过递归调用来遍历的。检查每个对象是否可散列的方式与在规范化算法中确定的方式相同。如果可散列，则用其引用替换。去转化撤销了这个过程。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/a70873728d58e72ec6310c9473bc1175.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*cdxwyNd42xfr8bx7jqqH6A.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Figure 5: Transformed dynamic GraphQL response object</figcaption></figure><h2 id="a64d" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">条件高速缓存无效技术</h2><p id="64d9" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">GraphQL查询字符串被转换成抽象语法树，以检查操作是否属于突变类型。如果是这样，就调用变异，并对GraphQL响应进行规范化。突变的种类是通过阅读Redis的参考文献推断出来的。</p><p id="1807" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">如果Redis返回空值，则推断出创建的变异。新引用被写入缓存。</p><p id="2eba" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">如果Redis值和GraphQL响应彼此非常相等，则推断出删除突变。该引用将从缓存中删除。</p><p id="15bb" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">如果相等为假，则推断出更新突变。引用将被更新后的值覆盖。</p><h2 id="0d7d" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">测试驱动开发</h2><p id="d8e7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">为了确保可靠性，采用了测试驱动的开发方法。上述功能的每个主要部分(规范化、转换、反转换和缓存无效)都必须通过预定义的测试，才能被合并和发布。</p><h1 id="f95a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">未来功能和改进的注意事项</h1><h2 id="c876" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">通过分片水平扩展缓存</h2><p id="b8e3" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">选择LRU驱逐策略的理由是防止有价值的GraphQL响应被驱逐。拥有一个分片缓存，其中一个分片保存GraphQL响应，一个分片保存引用，这将是一个主要的缓存回收改进。这将不仅允许每个相应的高速缓存具有其自己的驱逐策略，而且将防止这两类高速缓存相互干扰。事实上，LFU缓存将优化各个碎片的命中率，同时能够在更具可比性的信息片段之间进行比较。</p><h2 id="ce3d" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">使缓存中的GraphQL响应无效:<em class="nr">避免添加突变后响应不足</em></h2><p id="d485" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">目前没有办法使GraphQL响应无效。只有引用是无效的。如果有一个要从数据库中读取的查询，后面跟着一个添加的突变，那么要读取的同一个查询可能会从缓存中响应不完整的数据。要读取的原始查询不会将这个最近添加的引用包含在转换后的缓存值中。尽管避免了GraphQL调用，但Obsidian将会响应不足。</p><h2 id="94e4" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">使缓存中的GraphQL响应无效:避免过度响应</h2><p id="3ad5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">尽管过度响应不像响应不足那样有问题，但还是值得注意的。如果缓存了一个查询，并且后续查询从第一个查询请求了较少的字段，那么转换过程会欺骗曜石认为两个响应应该是相同的。这是因为黑曜石没有办法区分包含“发行年份”属性的“~ 7 ~电影”引用和不包含它的“~ 7 ~电影”引用。它总是缓存有更多字段的那个。</p><p id="72d1" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">虽然使响应无效可以解决这个问题，但是在使来自缓存的昂贵的GraphQL响应无效之前，应该首先探索其他方法。对于用户来说，简单地意识到这种细微差别可能更好。</p><h2 id="b99b" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">并行处理Obsidian的响应和写入缓存</h2><p id="2150" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">GraphQL的响应附在黑曜石收到时的响应中。缓存是在之后执行的。因为它们互不依赖，所以这些路径可以并行化。这样做会带来性能优势。</p><h2 id="2948" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated">选择性地查询逐出或删除的引用</h2><p id="ed04" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果Redis中由于驱逐或删除而丢失了任何引用，则会进行整个GraphQL调用。相反，对缺失的引用进行成本较低的调用也会带来性能优势。</p><p id="cd23" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">如果redis中有不止一个键没有找到，那么最好将返回我们正在寻找的响应的查询分组，并作为一个查询发送，以减少我们向GraphQL发出的网络请求的数量。</p><h2 id="9756" class="mc kp in bd kq md me dn ku mf mg dp ky lp mh mi la lt mj mk lc lx ml mm le mn bi translated"><em class="nr">自动化端到端测试</em></h2><p id="55b4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在执行端到端测试的同时，自动化这些测试将会改善Obsidian的内部开发体验。至少，对五个场景中的每一个进行一次测试是有益的，因为这些测试需要在开发团队中进行，以确保Obsidian的行为符合预期。</p><p id="26b4" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">进行查询和突变的不同组合的额外测试也将改善未来的交付周期。</p><h1 id="cc76" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">入门指南</h1><p id="b72b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">用我们的<a class="ae ns" href="https://github.com/oslabs-beta/obsidian-demo-3.2" rel="noopener ugc nofollow" target="_blank">简单易用的演示</a>来尝试黑曜石令人兴奋的新功能。阅读我们的<a class="ae ns" href="https://github.com/open-source-labs/obsidian" rel="noopener ugc nofollow" target="_blank">文档</a>，开始将黑曜石整合到你自己的应用中。这是我们免费赠送的<a class="ae ns" href="https://discord.com/channels/909826935780151327/909826935780151332/920878212047851550" rel="noopener ugc nofollow" target="_blank">发布文章</a>。</p><p id="79f3" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated">黑曜石是在技术加速器<a class="ae ns" href="https://opensourcelabs.io/" rel="noopener ugc nofollow" target="_blank">开源实验室</a>下生产的开源产品。我们欢迎通过<a class="ae ns" href="https://github.com/open-source-labs/obsidian" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的贡献和反馈。</p><p id="2819" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated"><strong class="li io"> <em class="nt">其他关于黑曜石的文章:</em> </strong></p><p id="2968" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated"><a class="ae ns" href="https://medium.com/@travisfrank/introducing-obsidian-graphql-built-for-deno-6f97a31f4af3" rel="noopener">黑曜石1.0 </a> <br/> <a class="ae ns" href="https://obsidian-deno-gql.medium.com/obsidian-2-0-launch-f66515d4f1b" rel="noopener">黑曜石2.0 </a> <br/> <a class="ae ns" href="https://christygomez-49559.medium.com/obsidian-3-0-launch-1742af1b1fe9" rel="noopener">黑曜石3.0 </a> <br/> <a class="ae ns" href="https://justinwmckay.medium.com/launch-obsidian-3-1-30429f3026c2" rel="noopener">黑曜石3.1 </a> <br/> <a class="ae ns" rel="noopener ugc nofollow" target="_blank" href="/obsidian-the-caching-solution-for-graphql-in-deno-runtime-130254b4233b">黑曜石3.2 </a> <br/> <a class="ae ns" href="https://medium.com/@mikechin37/obsidian-4-0-0-launch-deno-graphql-caching-solution-3588558e2d2a" rel="noopener">黑曜石4.0</a><a class="ae ns" href="https://yogi-paturu.medium.com/obsidian-4-0-0-technical-brief-7dbcdf46d9ce?source=friends_link&amp;sk=9b3ee33f0ec5186e3023e029af848e43" rel="noopener">黑曜石4.0</a></p><p id="d860" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated"><strong class="li io"> <em class="nt">黑曜石团队合著:<br/> </em> </strong>萨尔多·阿赫梅多夫| <a class="ae ns" href="https://github.com/sarkamedo" rel="noopener ugc nofollow" target="_blank"> GitHub </a> <br/>迈克尔·钦|<a class="ae ns" href="https://github.com/mikechin37" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae ns" href="https://www.linkedin.com/in/michael-chin-00432485/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<br/>达纳·弗瑞| <a class="ae ns" href="https://github.com/dmflury" rel="noopener ugc nofollow" target="_blank"> GitHub </a> <br/>约吉·帕图鲁|<a class="ae ns" href="https://github.com/YogiPaturu" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae ns" href="https://www.linkedin.com/in/yogi-paturu/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></p><p id="62ee" class="pw-post-body-paragraph lg lh in li b lj nd jo ll lm ne jr lo lp nf lr ls lt ng lv lw lx nh lz ma mb ig bi translated"><em class="nt">更多内容看</em> <a class="ae ns" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">说白了就是</em> </a> <em class="nt">。报名参加我们的</em> <a class="ae ns" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">免费每周简讯</em> </a> <em class="nt">。在我们的</em> <a class="ae ns" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nt">社区不和谐</em> </a> <em class="nt">获得独家获取写作机会和建议。</em></p></div></div>    
</body>
</html>