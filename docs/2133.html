<html>
<head>
<title>Develop Drag n Drop Functionality in Your Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Web应用程序中开发拖放功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/forget-the-browser-drag-drop-api-this-library-is-perfect-to-add-drag-and-drop-feature-f2a1a9e7d8e3?source=collection_archive---------5-----------------------#2021-05-05">https://javascript.plainenglish.io/forget-the-browser-drag-drop-api-this-library-is-perfect-to-add-drag-and-drop-feature-f2a1a9e7d8e3?source=collection_archive---------5-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">与“反应DnD”合作，为您的网站添加拖放功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b31529e34bff9fac4148bda3686e1a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zysFl2-ncBMgy-bkLGn9mQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Demo of the project we will be developing</figcaption></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="547a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">在后台</h1><p id="9cba" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">去年，我致力于web应用程序中的拖放功能，那时候，我使用简单的浏览器API来创建两个组件拖放组件，并使用浏览器拖放API手动处理每一种情况。</p><p id="135c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我并不讨厌这个web API，但是为了开发一个简单的项目，必须编写大量的代码，并且必须覆盖边缘案例。</p><p id="94af" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">今年我得到了一个项目，一个现实世界的问题，解决方案是向用户提供拖放功能。我不想回到那些Web API，因为这一次项目稍微大了一点，在添加拖放功能的同时要处理很多情况。</p><p id="3369" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我知道从头开始开发每件东西会让高度可伸缩的解决方案更有优势，但有时需要花费时间和大量精力。所以在寻找替代者后，我找到了一个，最好的，反应DnD。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="3519" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">概观</h1><p id="b29f" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">今天我们将与<a class="ae mv" href="https://react-dnd.github.io/react-dnd/docs/overview" rel="noopener ugc nofollow" target="_blank"><strong class="lw ir">react and</strong></a>图书馆合作。这使得添加拖放功能变得非常简单。出于样式和SSR的目的，我将再次使用Next JS和Tailwind CSS。添加链接以创建您自己的安装信息库。</p><div class="mw mx gp gr my mz"><a href="https://medium.com/nerd-for-tech/2-minute-2-steps-for-installing-tailwind-css-in-react-8dd420d81647" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">在React中安装Tailwind CSS需要2分钟和2个步骤</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在下一个JS项目中开始使用Tailwind CSS</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="680a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">克隆存储库后，安装reactor DnD软件包。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="8b43" class="nt ld iq np b gy nu nv l nw nx">yarn add <!-- -->react-dnd react-dnd-html5-backend</span></pre><p id="16f8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">您需要<strong class="lw ir"> HTML5 </strong>后端包作为浏览器依赖和兼容性。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="63e0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">反应DnD原料药</h1><p id="0af6" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">为了执行拖放功能，反作用DnD提供了两个高阶组件(ad)，一个是拖放，另一个是拖放。每个拖放组件都是可以拖动的组件，而单个拖放组件是收集这些拖动组件的组件。</p><p id="14b7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了执行拖放反应，DnD提供了钩子，一个可重用的函数如下-</p><ul class=""><li id="f39c" class="ny nz iq lw b lx mq ma mr md oa mh ob ml oc mp od oe of og bi translated"><strong class="lw ir">使用拖动</strong>-使用类型帮助拖动元素及其内容</li><li id="4837" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated"><strong class="lw ir">useDrop</strong>-使用类型帮助收集被拖动的元素及其内容</li><li id="6ff1" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated"><strong class="lw ir">监视器</strong>-帮助存储道具并将道具传递给被拖动的元素和掉落的组件。</li><li id="545c" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated"><strong class="lw ir">收集器</strong> —不言自明，收集器帮助收集被拖动元素的细节。</li><li id="71c9" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated"><strong class="lw ir"> ItemTypes </strong> —每个被拖动的元素都应该用被拖放的组件容易识别的类型来定义。</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="f91d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">反应DnD逻辑</h1><p id="ed4e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">反应DnD在引擎盖下使用Redux。您有2个组件，例如-</p><ul class=""><li id="acb6" class="ny nz iq lw b lx mq ma mr md oa mh ob ml oc mp od oe of og bi translated"><strong class="lw ir">拖动源</strong> —包含待拖动元素或可拖动元素的组件。</li><li id="d6f0" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated"><strong class="lw ir"> Drop Targets </strong> —组件收集并呈现拖放到其中的元素。</li></ul><p id="8445" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">Redux用于将元素从拖动源转移到拖放目标，并且拖放目标通常不会在元素被拖放后改变状态，这意味着拖放目标不会在元素被拖放后重新呈现。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="c8d7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">理解建筑</h1><p id="ec38" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我画了一个图像，让你理解DnD遵循的架构反应，并在编写代码时执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/8dad9105689f64bb76d3cf63a7c461f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1DHvHxxtuYaddsTtM3C5Q.jpeg"/></div></div></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="6ad4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">编写代码</h1><p id="1a8b" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们将创建一个简单而基本的例子，从元素列表中拖动一个元素，并将它们放到拖放目标中。</p><p id="77c2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在modules文件夹中，我们将定义一张卡作为我们的可拖动卡，这意味着我们可以拖动这张卡。为了使这张卡可以拖动，我们将使用一个挂钩。</p><p id="a848" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们简单的卡代码看起来像这样-</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="cd16" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我们已经使用了ItemTypes来定义useDrag API中的卡类型。所以ItemTypes是标识被拖动的项的方法。反应DnD不玩浏览器节点或元素，它只是记录元素作为一个对象。一旦在拖动源中设置了项目类型，我们就可以在接受它之前收集并确保拖放目标中的项目类型。当你有2张卡和2个放卡的地方时，这个功能更有用，特别是在棋盘的情况下。在拖放之前，我们总是检查拖放目标中拖动的项目类型。</p><p id="2967" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">一旦使用项目类型拖动并定义了项目，我们就可以仅使用项目类型在拖放目标中收集项目及其属性。将此项目类型视为区分对象的单个id。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="5163" class="nt ld iq np b gy nu nv l nw nx">export const ItemTypes = {<br/>  CARD: 'card',<br/>};</span></pre><p id="62bd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">所以我们的项目已经准备好拖动，我们现在可以简单地拖动项目。</p><p id="063b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">对于拖放目标，我创建了一个组件来收集元素及其属性，比如名称和id。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="7827" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在我们的项目中，我们有5个拖放目标，每个拖放目标接受并呈现拖放的项目。为了收集拖放目标中的拖动项，我们将使用useDrop钩子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b75b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在useDrop hook中，我们首先使用我们在可拖动卡中使用的相同项目类型来定义接受的项目类型。然后，我们简单地使用useDrop的hover方法，一旦用户将项目悬停在拖放目标上，hover方法就会被调用，我只是简单地更改相应拖放目标的背景颜色。</p><p id="721d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在我们需要在应用程序中使用这些拖放目标和可拖动的卡片。</p><p id="07ae" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我创建了一个侧边栏和一个主体组件。侧边栏有所有需要拖动的可拖动组件，主体有拖放目标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1b079d700f7408dc1f46b6076d0a93c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cn3LgVw4PPtVqljR-XLU4A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Current page with sidebar and body</figcaption></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><p id="a9fe" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在正文中，我们有5个拖放目标，所以每个拖放目标必须被映射，并且创建了5个不同的拖放目标。每个拖放目标都有定义的悬停属性，一旦项目被拖放，每个拖放目标都会呈现项目名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/05e049ac2ba79604730c655f52b55724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*T3v-oOuPN4WzrKrC-bYl1w.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Final product gif</figcaption></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="25fd" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">摘要</h1><ul class=""><li id="c6ca" class="ny nz iq lw b lx ly ma mb md oq mh or ml os mp od oe of og bi translated">我们首先创建一张卡片，并使用useDrag hook将其设置为可拖动</li><li id="5793" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated">在useDrag hook中，我们定义了单卡的类型，并设置了它的属性，如name。</li><li id="fa63" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated">然后，我们创建一个单一的拖放目标元素，它将通过使用useDrag API检查相应的条目类型来接受被拖放的元素</li><li id="8912" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated">然后，所有拖放目标在body组件中映射在一起</li><li id="5054" class="ny nz iq lw b lx oh ma oi md oj mh ok ml ol mp od oe of og bi translated">一旦项目被悬停在拖放目标上，相应的拖放目标背景颜色将会改变。</li></ul><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="fb6c" class="nt ld iq np b gy nu nv l nw nx">Code repository =&gt; <a class="ae mv" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/WorkingWithReactDnD" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/WorkingWithReactDnD</a></span></pre><p id="ecd6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">下次再见，祝大家愉快。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt mz"><a href="https://shreyvijayvargiya26.medium.com/make-a-habit-not-goals-430cef847c5d" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">养成习惯而不是目标</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我已经开始养成习惯，一个每天都在延续的习惯，而不是目标。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">shreyvijayvargiya26.medium.com</p></div></div><div class="ni l"><div class="ot l nk nl nm ni nn kp mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://medium.com/nerd-for-tech/3-minute-roadmap-to-master-the-next-js-in-2021-e022fee244b0" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">掌握2021年下一个JS的3分钟路线图</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">2021年掌握下一个JS的完整指南</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="ou l nk nl nm ni nn kp mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://shreyvijayvargiya26.medium.com/there-are-high-chances-that-redux-will-be-replaced-98f1c469bcce" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">redux很有可能被取代</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">看看redux的竞争对手，redux很有可能在未来被取代。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">shreyvijayvargiya26.medium.com</p></div></div><div class="ni l"><div class="ov l nk nl nm ni nn kp mz"/></div></div></a></div><p id="ea9e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><em class="ow">更多内容看</em><a class="ae mv" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lw ir"><em class="ow">plain English . io</em></strong></a></p></div></div>    
</body>
</html>