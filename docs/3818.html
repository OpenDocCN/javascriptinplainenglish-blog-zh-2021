<html>
<head>
<title>Updating My Portfolio Site with Netlify Functions &amp; the DEV API — A Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Netlify函数和DEV API更新我的投资组合站点—演练</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-walkthrough-of-updating-my-portfolio-site-with-netlify-functions-and-the-dev-api-ef8312d0f743?source=collection_archive---------11-----------------------#2021-07-31">https://javascript.plainenglish.io/a-walkthrough-of-updating-my-portfolio-site-with-netlify-functions-and-the-dev-api-ef8312d0f743?source=collection_archive---------11-----------------------#2021-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8f1b5d03e80f06fba51e219d42f72e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSeP1m4H3zzCrsvVbN_0rQ.png"/></div></div></figure><p id="9c61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我意识到，在与新开发人员的交谈中，我的大部分博客帖子的格式暗示我在构建项目时从头到尾都遵循线性路径。当你刚开始的时候，感觉高级开发人员已经知道他们开始时的最终结果是什么。而你，另一方面，甚至不知道从哪里开始。带着这个想法，我一点一点地写了这篇文章。结果是一个曲折的旅程，从我如何选择这个项目开始，到部署、我想重温的事情和演示日结束。在这两者之间是代码示例以及它们背后的弯路和动机。</p><p id="3aa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终，我在五天的空闲时间里写了这篇作品集网站更新，目的是在<a class="ae kt" href="https://virtualcoffee.io" rel="noopener ugc nofollow" target="_blank">虚拟咖啡</a> <a class="ae kt" href="https://virtualcoffee.io)'s" rel="noopener ugc nofollow" target="_blank">的</a>演示日展示它。</p><h1 id="9a7c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">目录</h1><p id="2ac3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">1.<a class="ae kt" href="#b59f" rel="noopener ugc nofollow">怎么挑什么建？</a> <br/> 2。我如何构建它？ <br/> 3。<a class="ae kt" href="#3915" rel="noopener ugc nofollow">设置我的lambda服务器</a> <br/> 4。<a class="ae kt" href="#6f3a" rel="noopener ugc nofollow">在状态</a> <br/> 5下存储数据。<a class="ae kt" href="#113a" rel="noopener ugc nofollow">转换数据</a> <br/> 6。<a class="ae kt" href="#57c7" rel="noopener ugc nofollow">为Blog和SingleBlog组件再做一次</a> <br/> 7。<a class="ae kt" href="#2d19" rel="noopener ugc nofollow">部署</a>8<br/>。<a class="ae kt" href="#f9d2" rel="noopener ugc nofollow">演示日</a> <br/> 9。<a class="ae kt" href="#e723" rel="noopener ugc nofollow">结论</a></p><h1 id="b59f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何挑选要构建的内容？</h1><p id="1080" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，你必须找到一个要解决的问题。它不一定是一个原创的问题或者是一个以前没有人解决过的问题。只是一个你想解决的问题。</p><p id="9220" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我一直在为我的博客文章的投资组合站点手写静态JSX文件。当我将其中的10个导入我的React组件时，我知道这不是最终的解决方案，但当我试图在截止日期前部署我的投资组合时，这是最快的解决方案。</p><p id="2552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我发现DEV有一个API可以发送你每个博客的HTML时，我在我的<a class="ae kt" href="https://github.com/abbeyperini/Portfolio2.0" rel="noopener ugc nofollow" target="_blank"> portfolio site repo </a>中创建了一个分支，重写了我的FullBlog组件，并尝试从已建立的Blog React组件中调用API。没有骰子。CORS误差。现在我知道我需要一台服务器，这样我就可以使用CORS软件包或其他解决方案。此时，我还注意到我必须调用DEV API /articles/me端点来获取我的每个博客的id，然后用id调用/articles/{id}端点来获取HTML版本或找到markdown版本的解决方案。</p><p id="b99f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大概一个月的时间，我试图想出一个我想使用的免费服务器托管解决方案。我觉得Heroku太慢了。我考虑过使用gcloud，因为有一些免费的选项，但是我不想再去解析gcloud文档了。</p><p id="c000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想到采纳我自己的建议，使用我的项目中已经使用的工具。我有一个无服务器的Netlify表单，人们喜欢Netlify的无服务器AWS lambda函数，所以我决定从那里开始。得出这个结论后，离#demoInPublic月度挑战宣布还有几个星期，我承诺为演示日做这个。</p><p id="b89c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果Netlify没有提供一个优秀的解决方案，我会开始向朋友寻求技术建议，或者选择一项我一直想使用的技术，并开始围绕它进行构建。</p><h1 id="a480" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我该如何构建它？</h1><p id="b116" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有疑问的时候，就开始写吧。<br/>——用伪代码写出来。<br/>——写最简单/最小的部分。</p><p id="52f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我第一次开始时，我接受了每个项目提示，并在一个函数或类中用伪代码注释写出了需求，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1250" class="mg kv in mc b gy mh mi l mj mk">function getBlogs(requiredData) {<br/> // http request to API<br/> // with required headers and data<br/> // send back response<br/> // handle errors<br/>}</span></pre><p id="2040" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我会挑选最小的部分，试着用代码写出来。当我陷入困境或者需要用伪代码来表达想法时，我仍然会使用伪代码。大多数时候，我可以从写代码开始，但无论哪种方式，我仍然选择最小的部分，只专注于让它工作。我必须使用这种方法来设置我的lambda服务器，并且几乎每天都在工作中使用。通常最可怕的事情是获取文件中的前几个字符。</p><h2 id="ed8c" class="mg kv in bd kw ml mm dn la mn mo dp le kg mp mq li kk mr ms lm ko mt mu lq mv bi translated">把它分解成最小的部分</h2><p id="487c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我已经有造型和其余的组件建成，所以对于这个项目，我知道我需要:<br/> 1。从DEV API <br/> 2请求我所有博客的数据。在我的FullBlog组件<br/> 3中存储状态数据。转换数据并显示出来<br/> 4。对我的博客和SingleBlog组件再做一次</p><p id="31a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我肯定可以进一步分解这些，所以我将从最小部分的最小部分开始——编写一个<a class="ae kt" href="https://www.netlify.com/products/functions/" rel="noopener ugc nofollow" target="_blank"> Netlify函数</a>。</p><h1 id="3915" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置我的lambda服务器</h1><p id="92ab" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，我仔细阅读了Netlify提供的文档和教程，发现了几个很好的资源来帮助我入门:<a class="ae kt" href="https://github.com/mattburrell/wishyouwerehere" rel="noopener ugc nofollow" target="_blank"> Matt Burrell的Wish You are Here repo</a>用于从API调用向组件传递数据，以及<a class="ae kt" href="https://kentcdodds.com/blog/super-simple-start-to-netlify-functions" rel="noopener ugc nofollow" target="_blank"> Kent C. Dodd的教程</a>用于netlify-lambda包技巧。</p><p id="613d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在花了一个半小时阅读文档并通过反复试验建立了Netlify函数之后，我的修改如下:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="108f" class="mg kv in mc b gy mh mi l mj mk">npm install netlify-lambda axios</span></pre><p id="aa99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的项目repo的根目录中的一个<code class="fe mw mx my mc b">netlify.toml</code>文件，它告诉<code class="fe mw mx my mc b">netlify-lambda</code>在构建期间将函数放在哪里:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fde3" class="mg kv in mc b gy mh mi l mj mk">[build]<br/> functions = “build/functions”</span></pre><p id="7dea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的repo的根目录下有一个名为functions的文件夹，其中有一个名为<code class="fe mw mx my mc b">blogPosts.js</code>的文件，看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2160" class="mg kv in mc b gy mh mi l mj mk">const axios = require(‘axios’)</span><span id="b55c" class="mg kv in mc b gy mz mi l mj mk">exports.handler = function () {<br/> <br/> axios.get(‘<a class="ae kt" href="https://dev.to/api/articles/me'" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/me'</a>, {<br/>   headers: {<br/>   “Api-Key”: “{{MY_API_KEY}}”,<br/>   “Content-Type”: ‘application/json’<br/>   }<br/> })<br/> .then((response) =&gt; { return console.log(response.data) })<br/> .catch((error) =&gt; { return console.log(error) })<br/>}</span></pre><p id="892c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要从DEV获取API密钥，您必须登录您的帐户，访问<a class="ae kt" href="https://dev.to/settings/account" rel="noopener ugc nofollow" target="_blank">https://dev.to/settings/account</a>，键入项目名称，然后单击“生成API密钥”</p><p id="5455" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我只是在<code class="fe mw mx my mc b">return</code> ing <code class="fe mw mx my mc b">console.log</code> s，因为我想验证API调用正在工作，没有CORS错误的机会。在这之后，我花了相当多的时间让我的<code class="fe mw mx my mc b">netlify-lambda build</code>和<code class="fe mw mx my mc b">serve</code>命令工作，这样我的lambda服务器就可以运行了。我必须向我的<code class="fe mw mx my mc b">package.json</code>添加2个脚本:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7e96" class="mg kv in mc b gy mh mi l mj mk">“start:lambda”: “netlify-lambda serve functions”,<br/>“build:lambda”: “netlify-lambda build functions”</span></pre><p id="8b30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“函数”是我的网络函数的源文件夹，这些函数将被构建到<code class="fe mw mx my mc b">netlify.toml</code>中引用的“构建/函数”文件夹中。在我最终在脚本和<code class="fe mw mx my mc b">netlify.toml</code>中拥有正确的文件夹之前，我得到了很多错误。</p><p id="9150" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在，我可以在终端中运行<code class="fe mw mx my mc b">npm run start:lambda</code>并导航到<a class="ae kt" href="http://localhost:9000/.netlify/functions/blogPosts" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000/。在浏览器中输入netlify/functions/blog posts</a>并从https://dev.to/api/articles/me<a class="ae kt" href="https://dev.to/api/articles/me" rel="noopener ugc nofollow" target="_blank">那里得到一个<code class="fe mw mx my mc b">console.log</code>的响应。</a></p><p id="0555" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我想测试从我的组件调用lambda函数。我将这个函数添加到我的<code class="fe mw mx my mc b">FullBlog</code>组件中:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bec7" class="mg kv in mc b gy mh mi l mj mk">async function fetchBlogs() {<br/> const res = await axios.get(‘<a class="ae kt" href="https://abbeyperini.dev/.netlify/functions/blogPosts'" rel="noopener ugc nofollow" target="_blank">https://abbeyperini.dev/.netlify/functions/blogPosts'</a>)<br/> .then((response) =&gt; { return console.log(response) })<br/> .catch((error) =&gt; { return error })<br/> <br/> return await res<br/> }</span></pre><p id="e794" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我得到了一个CORS错误。我碰巧在和一些高级开发人员通话，所以我给他们看了。他们指出，链接到我的投资组合领域，而不是本地主机！感谢<a class="ae kt" href="https://twitter.com/ray_deck" rel="noopener ugc nofollow" target="_blank"> Ray Deck </a>和<a class="ae kt" href="https://twitter.com/davidalpert" rel="noopener ugc nofollow" target="_blank"> David Alpert </a>对CORS的建议和指出。从那时起，我停止了当天的编码工作。</p><p id="436f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">醒来后，我短暂地考虑过对我的博客id进行硬编码，以避免一次API调用。当我不试图思考代码时，思考代码似乎是我过程的一部分。</p><p id="80e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在这一点上，我没有得到CORS错误或组件中的数据。玩了大约一个小时后，我意识到即使我的lambda服务器收到了GET请求，也没有任何东西被发送回来。我试图实现一个回调a la Matt Burrell，然后做了一些进一步的挖掘。结果是，Netlify函数的操作更像是一个服务器路由，而不是一个JavaScript函数，所以一旦我将<code class="fe mw mx my mc b">blogPosts.js</code>更新成这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="eb31" class="mg kv in mc b gy mh mi l mj mk">exports.handler = async function (event, context) {<br/> let response;<br/> try {<br/>   response = axios.get(‘<a class="ae kt" href="https://dev.to/api/articles/me'" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/me'</a>, {<br/>     headers: {<br/>     “Api-Key”: “{{MY_API_KEY}}”,<br/>     “Content-Type”: ‘application/json’,<br/>     “mode”: ‘cors’<br/>     }<br/>   })<br/> } catch (err) {<br/>   return {<br/>     statusCode:err.statusCode || 500,<br/>     body: err.message <br/>   }<br/> }</span><span id="df87" class="mg kv in mc b gy mz mi l mj mk">  return {<br/>   statusCode: 200,<br/>   body: JSON.stringify({<br/>   data: response<br/>   })<br/>  }</span><span id="121e" class="mg kv in mc b gy mz mi l mj mk">}</span></pre><p id="3eca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我又开始从我的React组件得到一个CORS错误，还有来自Lambda服务器的控制台日志，比如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="af41" class="mg kv in mc b gy mh mi l mj mk">Request from ::1: GET /.netlify/functions/blogPosts<br/>Response with status 200 in 3 ms.</span></pre><p id="7965" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而以前，我只能获得GET请求日志。</p><p id="ff22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还简化了我的组件。我第一次尝试使用<code class="fe mw mx my mc b">useReducer()</code>,但是在我可以在组件中获得数据之前，我想减少可能的错误数量。这与我目前在请求中硬编码实际的API键值的原因是一样的——我想知道我的所有值都被实例化、导入，并且对于调试都是正确的。现在我的整个组件看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d67b" class="mg kv in mc b gy mh mi l mj mk">function FullBlog() {</span><span id="1ba1" class="mg kv in mc b gy mz mi l mj mk"> const [data, setData] = useState(“not replaced”)</span><span id="8db8" class="mg kv in mc b gy mz mi l mj mk"> async function get() {<br/>  let res = await axios.get(‘<a class="ae kt" href="http://localhost:9000/.netlify/functions/blogPosts'" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/.netlify/functions/blogPosts'</a>)<br/>  return res<br/> }</span><span id="2b75" class="mg kv in mc b gy mz mi l mj mk"> useEffect(() =&gt; {<br/>   setData(get())<br/> }, [])</span><span id="fd9e" class="mg kv in mc b gy mz mi l mj mk"> return (<br/>   &lt;section className=”full-blog”&gt;<br/>   &lt;p&gt;Data here:{data}&lt;/p&gt;<br/>   &lt;/section&gt;<br/> )<br/>}</span></pre><p id="cb4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:因为我只是在一个<code class="fe mw mx my mc b">&lt;p&gt;</code>标签中添加了响应，所以我也得到一个“对象作为一个反应子对象无效(发现:[对象承诺])”在我的浏览器控制台，但这至少告诉我，我得到了一些东西回来。</p><h2 id="7c89" class="mg kv in bd kw ml mm dn la mn mo dp le kg mp mq li kk mr ms lm ko mt mu lq mv bi translated">解决CORS误差</h2><p id="74f8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在这一点上，我有三个选择，在我看来，从最大时间承诺/复杂性到最小:<br/> 1。只需编写一个node express服务器并托管它<br/> 2。写个代理<br/> 3。看看响应/请求头是否可以修复它</p><p id="6bb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我调出了雷发给我的标题选项。在大约25分钟的谷歌搜索、测试和随意添加头之后——包括对API的请求——我找到了Ben Borger的例子。经过一点点的反复试验，我已经让标题工作了，但是我意识到我还需要一个<code class="fe mw mx my mc b">await</code>。之前我只是发出了一个未兑现的承诺。我的组件现在正在接收数据，我的lambda函数如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e352" class="mg kv in mc b gy mh mi l mj mk">exports.handler = async function (event, context) {<br/> let response;<br/> try {<br/>   response = await axios.get(‘<a class="ae kt" href="https://dev.to/api/articles/me'" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/me'</a>, {<br/>     headers: {<br/>       “Api-Key”: “{{MY_API_KEY}}”,<br/>       “Content-Type”: ‘application/json’<br/>     }<br/>   })<br/> } catch (err) {<br/>   return {<br/>     statusCode:err.statusCode || 500,<br/>     body: err.message,<br/>     headers: {<br/>       “Access-Control-Allow-Origin”: “<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>”,<br/>       “Access-Control-Allow-Methods": “GET”<br/>     }<br/>   }<br/> }</span><span id="1338" class="mg kv in mc b gy mz mi l mj mk"> return {<br/>   statusCode: 200,<br/>   body: JSON.stringify({<br/>   data: response<br/>   }),<br/>   headers: {<br/>     “Access-Control-Allow-Origin”: “<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>”,<br/>     “Access-Control-Allow-Methods”: “GET”<br/>   }<br/> }</span><span id="fe45" class="mg kv in mc b gy mz mi l mj mk">}</span></pre><p id="ef2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了浏览器的安全，我使用了特定的方法和来源，而不仅仅是<code class="fe mw mx my mc b">*</code>。</p><h1 id="6f3a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在状态中存储数据</h1><p id="6e20" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以现在我要回去让我的<code class="fe mw mx my mc b">useReducer()</code>工作了。一旦我将数据存储在state中，就很容易操作和显示它。</p><p id="1d93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了简洁起见，我不会从头开始编写reducer或React组件，但是如果这是您感兴趣的另一个博客，请留下评论。我在和Kirk谈论DEV API和T2 vs Redux的时候写了整个组件。他有一个很棒的pokemon示例，旨在展示typescript的好处，该示例基于由Dan Ott编写的组件。在修复了几个拼写错误后，我的FullBlog组件看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="61c6" class="mg kv in mc b gy mh mi l mj mk">function FullBlog() {</span><span id="7fb3" class="mg kv in mc b gy mz mi l mj mk">  const initialState = {<br/>    isLoading: false,<br/>    blogs: null<br/>  }</span><span id="2e06" class="mg kv in mc b gy mz mi l mj mk">  async function fetchBlogs() {<br/>    const res = await axios.get(‘<a class="ae kt" href="http://localhost:9000/.netlify/functions/blogPosts'" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/.netlify/functions/blogPosts'</a>)<br/>   dispatch({<br/>     type: “blogFetched”,<br/>     payload: res.data<br/>   })<br/> }</span><span id="4506" class="mg kv in mc b gy mz mi l mj mk">  const reducer = (state, action) =&gt; {<br/>     switch (action.type) {<br/>     case “blogLoading”:<br/>       return {<br/>         …state,<br/>         isLoading: true<br/>       };<br/>     case “blogFetched”:<br/>       return {<br/>         …state,<br/>         isLoading: false,<br/>         blogs: action.payload<br/>       };<br/>     case “blogFetchFail”:<br/>       return {<br/>         …state,<br/>         isLoading: false,<br/>         error: action.payload<br/>       };<br/>     default:<br/>       return {<br/>         …state,<br/>         isLoading: false,<br/>         error: “unknown error”<br/>       };<br/>     }<br/>  }</span><span id="239f" class="mg kv in mc b gy mz mi l mj mk">  const [state, dispatch] = useReducer(reducer, initialState);</span><span id="2289" class="mg kv in mc b gy mz mi l mj mk">  useEffect(() =&gt; {<br/>   async function load() {</span><span id="dfbb" class="mg kv in mc b gy mz mi l mj mk">     dispatch({<br/>       type: “blogLoading”<br/>     })<br/> <br/>     fetchBlogs()<br/>   }</span><span id="6e31" class="mg kv in mc b gy mz mi l mj mk">   load()<br/> }, [])</span><span id="8ec4" class="mg kv in mc b gy mz mi l mj mk">  return (<br/>    &lt;section className=”full-blog”&gt;<br/>    &lt;p&gt;Data here&lt;/p&gt;<br/>    &lt;/section&gt;<br/>  )<br/>}</span></pre><p id="5d8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我第一次没有将所有的动作类型都设置为变量，我被告知要这样做，因为很容易拼错。当然，我确实拼错了一个动作类型，但是多亏了我的减速器中的<code class="fe mw mx my mc b">default</code>块，我几乎立刻就发现了它。</p><p id="2e40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还没有显示任何东西，但是由于有了<a class="ae kt" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React开发工具Chrome扩展</a>，我可以看到我的组件的状态，如下所示:</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/39696583e7df499c3823214b4380831c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*QKaN3y3vtH1342fWen7Zqw.png"/></div></figure><p id="aba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个视图还帮助我意识到，在今天的某个时候，我已经将状态中的变量名改为了data，而不是blogs。把它换回来修复了一个不稳定的国家结构。</p><h1 id="113a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">转换数据</h1><p id="cefb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果说我在bootcamp中学到了什么，那就是在页面上显示从API返回的内容列表的第一步是将数据映射到带有一个键(通常是从API返回的id)和一个要显示的字段(通常是标题字段)的<code class="fe mw mx my mc b">&lt;li&gt;</code>标签。首先，我用这个替换了我原来的<code class="fe mw mx my mc b">return</code>块:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d9b1" class="mg kv in mc b gy mh mi l mj mk">if (!state.isLoading &amp;&amp; state.blogs !== null) {<br/>  let blogList = state.blogs.data.map((blog) =&gt; {<br/>    return (<br/>      &lt;li key={blog.id}&gt;<br/>        &lt;p&gt;{blog.title}&lt;/p&gt;<br/>      &lt;/li&gt;<br/>    )<br/>  })</span><span id="2f14" class="mg kv in mc b gy mz mi l mj mk">  return (<br/>    &lt;section className=”full-blog”&gt;<br/>      &lt;ul&gt;<br/>        {blogList}<br/>      &lt;/ul&gt;<br/>    &lt;/section&gt;<br/>  )<br/>} else {<br/>  return (<br/>   &lt;p&gt;Blogs loading!&lt;/p&gt;<br/>  )<br/>}</span></pre><p id="514a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我已经有了一个标题显示列表，我将研究如何显示它。DEV API从/articles/me端点返回一个带有<code class="fe mw mx my mc b">body_markdown</code>字段的博客数组。首先，我将研究显示降价。</p><p id="7629" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Google向我展示了一些包，比如markdown-to-jsx和react-markdown，但是带有反勾的代码片段可能会导致问题。你可能已经注意到阅读这篇文章，我的博客经常涉及许多代码块。因为我有点赶时间，所以我决定在这一点上使用来自/articles/{id}端点的带有<code class="fe mw mx my mc b">body_html</code>字段的响应。</p><p id="4e76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我需要决定是维护一个博客id的静态列表，还是编辑我的lambda函数来从/articles/me中获取所有id，为每个id调用/articles/{id},并返回一个博客数组。我喜欢后者的想法，主要是因为它不涉及维护硬编码数据。</p><p id="a4eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">经过一些尝试和错误之后，我的lambda服务器现在返回一个带有<code class="fe mw mx my mc b">body_html</code>字段的博客数组，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bfca" class="mg kv in mc b gy mh mi l mj mk">async function getAllBlogsByID(blogIDs) {<br/>  let blogArray = []</span><span id="59b4" class="mg kv in mc b gy mz mi l mj mk">  for (let i = 0; i &lt; blogIDs.length; i++) {<br/>    let blog = await getBlogByID(blogIDs[i])<br/>    blogArray.push(blog)<br/>  }</span><span id="9c95" class="mg kv in mc b gy mz mi l mj mk">  return blogArray<br/>}</span><span id="c7da" class="mg kv in mc b gy mz mi l mj mk">async function getBlogByID(id) {<br/>  let blog = await axios.get(`<a class="ae kt" href="https://dev.to/api/articles/${id}`" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/${id}`</a>, {<br/>    headers: {<br/>      “Api-Key”: “{{MY_API_KEY}}”,<br/>      “Content-Type”: ‘application/json’<br/>    }<br/>  })<br/>  return blog.data<br/>}</span><span id="f697" class="mg kv in mc b gy mz mi l mj mk">exports.handler = async function (event, context) {<br/>  let articlesByUser<br/>  let blogIDs = []<br/>  try {<br/>    articlesByUser = await axios.get(‘<a class="ae kt" href="https://dev.to/api/articles/me'" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/me'</a>, {<br/>      headers: {<br/>        “Api-Key”: “{{MY_API_KEY}}”,<br/>        “Content-Type”: ‘application/json’<br/>      }<br/>    })<br/>  } catch (err) {<br/>    return {<br/>      statusCode:err.statusCode || 500,<br/>      body: err.message,<br/>      headers: {<br/>        “Access-Control-Allow-Origin”: “<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>”,<br/>        “Access-Control-Allow-Methods": “GET”<br/>      }<br/>    }<br/>  }</span><span id="65b3" class="mg kv in mc b gy mz mi l mj mk">  articlesByUser.data.forEach(blog =&gt; blogIDs.push(blog.id))<br/>  let allBlogs = await getAllBlogsByID(blogIDs)</span><span id="1f59" class="mg kv in mc b gy mz mi l mj mk">  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify({<br/>      data: allBlogs<br/>    }),<br/>    headers: {<br/>      “Access-Control-Allow-Origin”: “<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>”,<br/>      “Access-Control-Allow-Methods”: “GET”<br/>    }<br/>  }</span><span id="306a" class="mg kv in mc b gy mz mi l mj mk">}</span></pre><p id="9fc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，当我将<code class="fe mw mx my mc b">body_html</code>字段插入到我的JSX地图中时，它只是显示一个带有一堆html标签的字符串。一个快速的谷歌展示给我<code class="fe mw mx my mc b">html-react-parser</code>，在最简单的安装和应用之后，我的博客上加载了漂亮的图片和链接。我所要添加的只是导入(<code class="fe mw mx my mc b">import parse from ‘html-react-parser’;</code>)和我的博客地图上的几行文字:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3ba1" class="mg kv in mc b gy mh mi l mj mk">let blogList = state.blogs.data.map((blog) =&gt; {<br/>  let blogBody = parse(blog.body_html)<br/>  return (<br/>    &lt;li key={blog.id}&gt;<br/>      &lt;h1&gt;{blog.title}&lt;/h1&gt;<br/>      {blogBody}<br/>    &lt;/li&gt;<br/> )<br/>})</span></pre><p id="5fea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在变量/url清理和部署之前剩下的就是样式和Blog和SingleBlog组件，所以今天我就讲到这里。</p><p id="4b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我编写组件时，假设我可以随心所欲地应用<code class="fe mw mx my mc b">classNames</code>，所以我的样式需要稍微调整一下。我还注意到DEV在代码块下添加了一些我不想要的图标。我遵循了一个BEM命名方案，并用注释组织了我的CSS，我很高兴它能如此容易地应用到新格式中。</p><p id="0e64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将把<code class="fe mw mx my mc b">className=”full-blog</code>留在组件的<code class="fe mw mx my mc b">&lt;section&gt;</code>标签中，将<code class="fe mw mx my mc b">className=”blog”</code>添加到地图中的<code class="fe mw mx my mc b">&lt;li&gt;</code>中，注释掉本节中的所有其他规则，并删除两条带有id的规则。我们的情况已经很好了。我的博客有浅色的背景，一些间距，文本居中，有适当的边距。</p><p id="724a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我逐个取消对规则的注释，并开始将带有我不能使用的类名的选择器改为<code class="fe mw mx my mc b">.blog {element}</code>选择器。更改我的图像规则提醒我也要更改媒体查询规则。现在，我的图像和它们的标题看起来是正确的。另外，你也应该感谢DEV回了我所有的短信。</p><p id="b274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来看代码块，我注意到一些事情。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/56e34ed43ae448f5f50287dd888b41a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*da0bCZYucOCjbZWIXy5NAw.png"/></div></figure><p id="e690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类名中的空格意味着我只能使用空格之前的部分名称作为有效的CSS选择器。幸运的是，这足以隐藏代码块图标。然而，这导致容器<code class="fe mw mx my mc b">&lt;div&gt;</code>及其子容器<code class="fe mw mx my mc b">&lt;pre&gt;</code>具有相同的类——“高亮”。在我第一次尝试改变选择器之后，除了一个边界被两次应用到<code class="fe mw mx my mc b">&lt;div&gt;</code>和<code class="fe mw mx my mc b">&lt;pre&gt;.</code>之外，一切都运行良好。谢天谢地，<code class="fe mw mx my mc b">{{element}}.{{class}}</code>选择器很容易就解决了这个问题。</p><p id="0da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，标题有点不靠谱。标题是一个<code class="fe mw mx my mc b">&lt;h2&gt;</code>，但最大的身体标题是一个<code class="fe mw mx my mc b">&lt;h1&gt;</code>。我必须为标题编写一个<code class="fe mw mx my mc b">:first-of-type</code>选择器，然后为文章主体中的标题编写选择器。我还删除了我为不必要的长副标题制定的<code class="fe mw mx my mc b">.blog_published-heading</code>规则(我喜欢这些)。选择器似乎在很大程度上捕捉到了它们。在某种程度上，我可能想标准化我在DEV中设置标题的方式，但不是今天。</p><p id="b975" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，通过滚动，我发现了一些我想修复的东西:<br/> -代码块和正文标题周围的边距<br/> -一些图像左对齐而不是居中<br/> -我的代码块居中，而不是我想要的左对齐</p><p id="0355" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">添加边距很简单。这些图像都包含在一个带有类<code class="fe mw mx my mc b">article-body-image-wrapper</code>的<code class="fe mw mx my mc b">&lt;a&gt;</code>中，所以为了解决这个问题，我将添加另一个规则，用<code class="fe mw mx my mc b">justify-content: center</code>将anchor标签转换成一个flex容器。</p><p id="e88f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决代码块对齐问题也提醒了我，我有媒体对此的疑问。更新这些得到了合适的宽度，但是我的通用选择器<code class="fe mw mx my mc b">text-align: center</code>规则比我进一步添加的任何<code class="fe mw mx my mc b">text-align</code>规则都更加具体。经过一点试验和错误之后，看起来将<code class="fe mw mx my mc b">text-align: left</code>添加到<code class="fe mw mx my mc b">pre.highlight </code>规则中可以解决这个问题。我可以尝试做一些挑剔的事情，但是让我们把摆弄代码块样式添加到我希望在将来重新讨论的事情列表中。</p><p id="e72d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我的FullBlog组件的CSS如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="acc8" class="mg kv in mc b gy mh mi l mj mk">/* full blog */</span><span id="1a65" class="mg kv in mc b gy mz mi l mj mk">.blog img {<br/>  max-width: 200px;<br/>  margin: 10px;<br/>}</span><span id="8590" class="mg kv in mc b gy mz mi l mj mk">.article-body-image-wrapper {<br/>  display: flex;<br/>  justify-content: center;<br/>}</span><span id="020c" class="mg kv in mc b gy mz mi l mj mk">.blog h2:first-of-type {<br/>  font-size: 2em;<br/>}</span><span id="23a1" class="mg kv in mc b gy mz mi l mj mk">.blog h1 {<br/>  font-size: 1.5em;<br/>  margin: 10px;<br/>}</span><span id="47e1" class="mg kv in mc b gy mz mi l mj mk">.blog h2 {<br/>  font-size: 1em;<br/>  margin: 10px;<br/>}</span><span id="efef" class="mg kv in mc b gy mz mi l mj mk">.blog em {<br/>  font-style: italic;<br/>  font-size: 1em;<br/>  max-width: 250px;<br/>  overflow-wrap: break-word;<br/>}</span><span id="404f" class="mg kv in mc b gy mz mi l mj mk">.full-blog {<br/>  background: var( — light-background);<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>  justify-content: center;<br/>}</span><span id="634b" class="mg kv in mc b gy mz mi l mj mk">.blog {<br/>  margin: 10px 0px 10px 0px;<br/>  padding: 20px;<br/>  border-radius: 10px;<br/>  background: var( — accent);<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>  justify-content: center;<br/>}</span><span id="570c" class="mg kv in mc b gy mz mi l mj mk">.blog ul {<br/>  flex-direction: column;<br/>  justify-content: center;<br/>  flex-wrap: wrap;<br/>  width: 50%;<br/>}</span><span id="72b1" class="mg kv in mc b gy mz mi l mj mk">.blog li {<br/>  list-style-type: disc;<br/>  margin: 10px;<br/>  text-align: left;<br/>}</span><span id="1c72" class="mg kv in mc b gy mz mi l mj mk">.highlight__panel {<br/>  display: none;<br/>}</span><span id="31d8" class="mg kv in mc b gy mz mi l mj mk">div.highlight {<br/>  background-color: #eee;<br/>  border: 1px solid black;<br/>  padding: 10px;<br/>  border-radius: 10px;<br/>  margin: 10px;<br/>}</span><span id="0b8a" class="mg kv in mc b gy mz mi l mj mk">pre.highlight {<br/>  white-space: pre-wrap;<br/>  max-width: 250px;<br/>  overflow-x: auto;<br/>  text-align: left;<br/>}</span><span id="c1c8" class="mg kv in mc b gy mz mi l mj mk">code {<br/>  padding: 1px 5px 1px 5px;<br/>}</span><span id="e73b" class="mg kv in mc b gy mz mi l mj mk">.blog p, .blog blockquote {<br/>  padding: 0px;<br/>  margin: 5px;<br/>  text-align: left;<br/>  width: 50%;<br/>}</span></pre><p id="ba9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这些相关的媒体询问:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5710" class="mg kv in mc b gy mh mi l mj mk">/* media queries */</span><span id="211e" class="mg kv in mc b gy mz mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> screen and (min-width: 350px) {</span><span id="555f" class="mg kv in mc b gy mz mi l mj mk">  pre.highlight {<br/>    max-width: 300px;<br/>  }<br/>}</span><span id="34c4" class="mg kv in mc b gy mz mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> screen and (min-width: 525px) {</span><span id="dff2" class="mg kv in mc b gy mz mi l mj mk">  .blog img {<br/>    max-width: 250px;<br/>  }</span><span id="36ae" class="mg kv in mc b gy mz mi l mj mk">  pre.highlight {<br/>    max-width: 500px;<br/>  }<br/>}</span><span id="098d" class="mg kv in mc b gy mz mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> screen and (min-width: 700px) {</span><span id="4521" class="mg kv in mc b gy mz mi l mj mk">  .subAbout, .subContact, .blog {<br/>    margin: 20px;<br/>  }</span><span id="998d" class="mg kv in mc b gy mz mi l mj mk">  .blog img {<br/>    max-width: 300px;<br/>  }</span><span id="812f" class="mg kv in mc b gy mz mi l mj mk">  pre.highlight {<br/>    max-width: 650px;<br/>  }<br/>}</span><span id="f9f9" class="mg kv in mc b gy mz mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> screen and (min-width: 900px) {</span><span id="8ac7" class="mg kv in mc b gy mz mi l mj mk">  .blog img {<br/>    max-width: 500px;<br/>  }</span><span id="dc56" class="mg kv in mc b gy mz mi l mj mk">  pre.highlight {<br/>    max-width: 100%;<br/>  }<br/>}</span><span id="7e4d" class="mg kv in mc b gy mz mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> screen and (min-width: 1200px) {</span><span id="7fe8" class="mg kv in mc b gy mz mi l mj mk">  .blog em {<br/>    max-width: 500px;<br/>  }<br/>}</span></pre><h1 id="57c7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">对Blog和SingleBlog组件重复上述操作</h1><p id="8b0f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">博客组件位于我的作品集的主页上，显示我所有博客的预览，带有标题和封面图片。我希望我的Blog组件能够获取与FullBlog相同的信息，但只显示其中的一小部分。当您在blog组件中单击一篇博文的标题时，它应该只加载该博文的SingleBlog组件。</p><p id="32d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我需要考虑我的状态架构，尽量不要重复代码。我试着将我的reducer、state和<code class="fe mw mx my mc b">fetchBlogs()</code>移动到它们共同的父组件中，但是这真的打乱了我的状态。在这一点上，我将复制一些代码，并考虑我是否甚至需要Fullblog组件，或者我是否可以从我的字体页面重构Blog组件，以便在将来的某个时候处理预览、单个Blog和完整Blog。</p><p id="3729" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的博客组件已经有了一个从父组件传递下来的回调函数，用于选择要呈现的单个博客。我将重写它以使用博客id并触发一个lambda函数，但首先让我们让这个组件加载博客预览。稍微摆弄了一下，我的预览正在加载。不幸的是，DEV没有封面图片的替代文本，所以我的替代文本是非描述性的。Blog和FullBlog的主要区别是我的地图:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fcbe" class="mg kv in mc b gy mh mi l mj mk">let blogPreviewList = state.blogs.data.map((blog) =&gt; {<br/>  let altText = `cover image for ${blog.title}`<br/>  let blogImage = ‘’;</span><span id="7e00" class="mg kv in mc b gy mz mi l mj mk">if (blog.cover_image) {<br/>  blogImage = blog.cover_image<br/>} else if (blog.social_image) {<br/>  blogImage = blog.social_image<br/>}</span><span id="656d" class="mg kv in mc b gy mz mi l mj mk">return (<br/>  &lt;li key={blog.id} className=”blog”&gt;<br/>    &lt;h2 onClick={() =&gt; chooseComponent({id: blog.id})}&gt;{blog.title}&lt;/h2&gt;<br/>    &lt;img alt={altText} src={blogImage}&gt;&lt;/img&gt;<br/>  &lt;/li&gt;<br/> )<br/>})</span></pre><p id="497d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我花几分钟看我的回调函数，试图记住它是如何工作的。我的<code class="fe mw mx my mc b">app.js</code>文件中的主要组件App具有显示哪些组件的状态，以及一个使用<code class="fe mw mx my mc b">setState()</code>并被传递给博客组件的<code class="fe mw mx my mc b">chooseComponent()</code>函数。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="49dd" class="mg kv in mc b gy mh mi l mj mk">function App() {<br/> const [hidden, setHidden] = useState(false);<br/> const [single, setSingle] = useState(false);<br/> const [singleShow, setSingleShow] = useState(‘’);</span><span id="a811" class="mg kv in mc b gy mz mi l mj mk">const chooseComponent = (component) =&gt; {<br/>  setSingle(true);<br/>  setSingleShow(component);<br/>}</span><span id="c66b" class="mg kv in mc b gy mz mi l mj mk">&lt;MainFull condition={hidden &amp;&amp; !single} component={&lt;Blog chooseComponent={chooseComponent} /&gt;} /&gt;</span></pre><p id="bc3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主要的组件和条件分别是渲染组件的CSS转换和状态。下面是我的博客组件中的passing <code class="fe mw mx my mc b">chooseComponent()</code>的样子:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0906" class="mg kv in mc b gy mh mi l mj mk">function Blog(props) {</span><span id="a7e2" class="mg kv in mc b gy mz mi l mj mk">  const chooseComponent = (component) =&gt; {<br/>    props.chooseComponent(component);<br/>  }</span></pre><p id="510d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe mw mx my mc b">app.js</code>中，我为让<code class="fe mw mx my mc b">chooseComponent()</code>使用博客id所做的更改如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0ffb" class="mg kv in mc b gy mh mi l mj mk">const [singleBlogID, setSingleBlogID] = useState(0);</span><span id="34b5" class="mg kv in mc b gy mz mi l mj mk">const chooseComponent = (component) =&gt; {<br/>  if (component.id) {<br/>    setSingle(true)<br/>    setSingleBlogID(component.id)<br/>    setSingleShow(“SingleBlog”)<br/>  } else {<br/>    setSingle(true);<br/>    setSingleShow(component);<br/>  } <br/>}</span><span id="ede3" class="mg kv in mc b gy mz mi l mj mk">&lt;Single condition={hidden &amp;&amp; single &amp;&amp; singleShow === “SingleBlog”} component={&lt;SingleBlog id={singleBlogID} /&gt;}/&gt;</span></pre><p id="aea5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我创建了我的SingleBlog组件。我将从props中的博客预览中传递id，将其添加到state中，并创建一个对lambda函数的新请求。现在我只需要找到一种方法将id传递给lambda函数。这是一天休息的好地方。</p><p id="3f78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在使用lambda函数一段时间后，我发现在url中传递id是可行的，而在主体中带有id的POST请求却不行。我的<code class="fe mw mx my mc b">SingleBlog.js</code>文件现在看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d580" class="mg kv in mc b gy mh mi l mj mk">const axios = require(‘axios’)</span><span id="c7ec" class="mg kv in mc b gy mz mi l mj mk">exports.handler = async function (event, context) {</span><span id="e850" class="mg kv in mc b gy mz mi l mj mk">let id = event.queryStringParameters.id<br/>  try {<br/>    let blog = await axios.get(`<a class="ae kt" href="https://dev.to/api/articles/${id}`" rel="noopener ugc nofollow" target="_blank">https://dev.to/api/articles/${id}`</a>, {<br/>      headers: {<br/>        “Api-Key”: “{{MY_API_KEY}}”,<br/>        “Content-Type”: ‘application/json’<br/>      }<br/>    })</span><span id="52f3" class="mg kv in mc b gy mz mi l mj mk">return {<br/>      statusCode: 200,<br/>      body: JSON.stringify({<br/>        data: blog.data<br/>      }),<br/>      headers: {<br/>        "Access-Control-Allow-Origin": "<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>"<br/>        "Access-Control-Allow-Methods": "GET"<br/>      }<br/>    }</span><span id="c442" class="mg kv in mc b gy mz mi l mj mk">  } catch (err) {<br/>    console.log(err)<br/>    return {<br/>      statusCode:err.statusCode || 500,<br/>      body: err.message,<br/>      headers: {<br/>        "Access-Control-Allow-Origin": "<a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>"<br/>        "Access-Control-Allow-Methods": "GET"<br/>      }<br/>    }<br/>  }</span><span id="1fd4" class="mg kv in mc b gy mz mi l mj mk">}</span></pre><p id="bcea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不得不稍微调整一下我的<code class="fe mw mx my mc b">SingleBlog</code>组件，但是CSS一旦加载数据就可以完美地应用。我将id带出状态，并在Blog中的<code class="fe mw mx my mc b">onClick()</code>中传递它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ccb4" class="mg kv in mc b gy mh mi l mj mk">&lt;h2 className=”preview_button” onClick={() =&gt; chooseComponent({id: blog.id})}&gt;{blog.title}&lt;/h2&gt;</span></pre><p id="e00f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的SingleBlog <code class="fe mw mx my mc b">fetchSingleBlog()</code>和<code class="fe mw mx my mc b">useEffect()</code>函数现在看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5a75" class="mg kv in mc b gy mh mi l mj mk">async function fetchSingleBlog(id) {<br/>  const res = await axios.get(`<a class="ae kt" href="http://localhost:9000/.netlify/functions/singleBlog?id=${id}`" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/.netlify/functions/singleBlog?id=${id}`</a>)</span><span id="d8e5" class="mg kv in mc b gy mz mi l mj mk">  dispatch({<br/>    type: “blogFetched”,<br/>    payload: res.data.data<br/>  })<br/>}</span><span id="3d78" class="mg kv in mc b gy mz mi l mj mk">useEffect(() =&gt; {</span><span id="827a" class="mg kv in mc b gy mz mi l mj mk">  async function load() {</span><span id="8160" class="mg kv in mc b gy mz mi l mj mk">    dispatch({<br/>      type: “blogLoading”<br/>    })<br/> <br/>    fetchSingleBlog(props.id)<br/>  }</span><span id="c2d6" class="mg kv in mc b gy mz mi l mj mk">  load()<br/> }, [])</span><span id="fba6" class="mg kv in mc b gy mz mi l mj mk">if (!state.isLoading &amp;&amp; state.blog !== null) {</span><span id="c96c" class="mg kv in mc b gy mz mi l mj mk">  let blogBody = parse(state.blog.body_html)</span><span id="62eb" class="mg kv in mc b gy mz mi l mj mk">  return (<br/>    &lt;section className=”full-blog”&gt;<br/>      &lt;ul&gt;<br/>        &lt;li key={state.blog.id} className=”blog”&gt;<br/>          &lt;h2&gt;{state.blog.title}&lt;/h2&gt;<br/>          {blogBody}<br/>         &lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/section&gt;<br/>  )<br/>} else {<br/>  return (<br/>    &lt;p&gt;Blogs loading!&lt;/p&gt;<br/>  )<br/>}</span></pre><p id="61f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的博客预览CSS样式应用起来也相当轻松。我唯一调整的是<code class="fe mw mx my mc b">.preview</code>和<code class="fe mw mx my mc b">.preview_image</code>的宽度和高度规则，因为DEV返回的封面图片的横向格式与我使用的不同。然而，它更加标准化，这很好。</p><h2 id="2a1e" class="mg kv in bd kw ml mm dn la mn mo dp le kg mp mq li kk mr ms lm ko mt mu lq mv bi translated">组件中的错误处理</h2><p id="449d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">部署前的最后一件事——我有一个错误动作类型，但是目前没有向reducer发送任何错误！</p><p id="08a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我像这样更新我的axios请求:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8977" class="mg kv in mc b gy mh mi l mj mk">async function fetchBlogs() {<br/>  axios.get(‘<a class="ae kt" href="http://localhost:9000/.netlify/functions/blogPosts'" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/.netlify/functions/blogPosts'</a>)<br/>  .then((res) =&gt; {<br/>    dispatch({<br/>      type: “blogFetched”,<br/>      payload: res.data<br/>    })<br/>  }).catch((error) =&gt; {<br/>    dispatch({<br/>      type: “blogFetchFail”,<br/>      payload: error<br/>    })<br/>  })<br/>}</span></pre><p id="1937" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我将一个<code class="fe mw mx my mc b">else if</code>语句添加到我的返回结果中，位于我的组件的底部:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3a47" class="mg kv in mc b gy mh mi l mj mk">else if (!state.isLoading &amp;&amp; state.error) {<br/>  return (<br/>    &lt;p&gt;There was an error! Try again later.&lt;/p&gt;<br/>  )<br/>} </span></pre><h1 id="2d19" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">部署</h1><p id="cf4d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当我试图入睡时，我意识到我把钥匙交给了一家公共回购公司。幸运的是，我可以从我的手机上撤销它。早上我生成了一把新钥匙。然后是清理我的钥匙和路线的时候了。</p><p id="0379" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我曾经在某个地方读到过，如果您在环境变量的开头添加<code class="fe mw mx my mc b">REACT_APP_</code>，那么<code class="fe mw mx my mc b">.env</code>文件将与React一起工作，在我的例子中，这立即被证明是错误的。然而，我的错误处理工作得很好！</p><p id="5d34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">常规的dotenv包不是为前端设计的，所以接下来我将尝试dotenv-webpack。在安装并添加了一个带有导入的<code class="fe mw mx my mc b">webpack.config.js</code>文件后，我重命名了我的<code class="fe mw mx my mc b">API_KEY</code>变量，添加了一个<code class="fe mw mx my mc b">BASE_URL</code>变量和一个<code class="fe mw mx my mc b">ORIGIN_URL</code>变量，但它仍然不工作。</p><p id="faf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我所有的阅读都向我保证lambda函数将能够访问我在Netlify的UI中设置的环境变量，并且有一种方法可以使用netlify-dev包在本地为它们设置环境变量。此时，我的演示还不到48小时，所以我将对URL进行硬编码，看看部署是否可行，并使本地环境变量成为以后的问题。值得注意的是，我的React组件和lambda函数在部署后都将位于https://abbeyperini.dev 中，所以我可能只需要为本地开发解决那些CORS问题。</p><p id="aab5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一次部署之后，我必须将<code class="fe mw mx my mc b">props.id</code>添加到我的SingleBlog组件的依赖数组中，因为如果出现警告，Netlify构建就会失败。第二次部署导致了一次成功的构建，但是函数没有显示出来。Netlify会在构建日志中告诉你它是否在部署函数，并且有一个函数选项卡可以在函数运行时查看日志。在多次尝试和阅读大量文档和论坛帖子后，我最终将我的<code class="fe mw mx my mc b">netlify.toml</code>改为Matt Burrell使用的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9864" class="mg kv in mc b gy mh mi l mj mk">[build]<br/>  Command = “npm run build &amp;&amp; npm run build:lambda”<br/>  Functions = “netlify”<br/>  Publish = “build”</span></pre><p id="ff46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我认为它解决了我的函数不能构建的问题，因为它告诉Netlify运行build命令。将它们移动到Netlify期望的默认文件夹中可能也没有坏处。嵌套文件夹可能有问题。</p><p id="58f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在deploy attempt 9中，我将<code class="fe mw mx my mc b">console.log(error)</code>添加到我的blogPosts函数中，并意识到我在昨晚撤销API键后还没有旋转它。然而，一切都正常，包括Netlify UI中设置的<code class="fe mw mx my mc b">API_KEY </code>环境变量！环境变量似乎是在构建时被拉进来的，所以如果你编辑了一个，你必须触发一个新的构建才能看到它。我的站点通常由主分支的<code class="fe mw mx my mc b">git push</code>来触发构建，但是在部署选项卡中有一个按钮来触发部署。最后，一切都是生活和工作！</p><p id="ed5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上，我仍然有一个我想重温的事情列表:<br/> -找到一个markdown解析解决方案来避免我偶尔从许多API调用中得到的429错误— <a class="ae kt" href="https://abbeyperini.medium.com/blog-page-accessibility-deep-dive-92ffb5f5ee8d" rel="noopener">完成！</a><br/>——代码块样式——<a class="ae kt" href="https://abbeyperini.medium.com/blog-page-accessibility-deep-dive-92ffb5f5ee8d" rel="noopener">完成！</a> <br/> -可爱的错误和加载图形— <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/adding-shiba-inu-loading-and-error-svgs-to-my-react-site-48f59806362c">完成！</a> <br/> -可能将我的3个博客组件重构为1个或2个，以减少重复代码— <a class="ae kt" href="https://abbeyperini.medium.com/blog-page-accessibility-deep-dive-92ffb5f5ee8d" rel="noopener">完成！</a></p><h1 id="f9d2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">演示日</h1><p id="a250" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">从历史上看，演示日不是我的强项。最初，我很难描述我为什么要构建我所构建的东西，也没有深入任何关于我的代码的细节。在这一点上，我仍然会非常紧张，并开始说得非常快。</p><p id="534d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虚拟咖啡演示日对我来说比过去好得多。尽管我是最后一名，但我在开始时还是以正常速度起步，只是稍微加快了一点。为了做好准备，我制作了一个我想展示的功能的快速视频，以防它在演示前/演示过程中被破坏。我写下了我想涵盖的内容，包括我想展示的代码片段，并在演示前的几个小时里练习了几次。</p><p id="6c3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">演示结束后，<a class="ae kt" href="https://twitter.com/JustinNoelDev" rel="noopener ugc nofollow" target="_blank">贾斯汀·诺尔</a>伸出手来告诉我，我可以通过添加<code class="fe mw mx my mc b">prefers-reduced-motion</code> <code class="fe mw mx my mc b">@media</code>查询使我的网站的登陆页面更容易访问。我为这个博客添加的最后一段代码如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ab44" class="mg kv in mc b gy mh mi l mj mk"><a class="ae kt" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> (prefers-reduced-motion) {<br/>  .bg, .bg2, .bg3 {<br/>    animation-name: dissolve;<br/>  }<br/>}</span></pre><p id="ba69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion" rel="noopener ugc nofollow" target="_blank"> MDN参考文档</a>中了解有关该查询和触发该规则的用户设置的更多信息。我很感谢我没有使用任何非常激烈的动画，我在登陆这个之前尝试过，这正是我想要的反馈类型，每当我分享我的代码。</p><h1 id="e723" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="22df" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我写这篇博客的目的是想让大家明白，建造东西很少是一个线性的过程。我也希望它能让我了解如何分解、处理和解决大大小小的问题。你可以查看我的<a class="ae kt" href="https://github.com/abbeyperini/Portfolio2.0" rel="noopener ugc nofollow" target="_blank">投资组合回购</a>中的所有代码，并观看我的<a class="ae kt" href="https://drive.google.com/file/d/1DXMEfr5-AQn6vk9ntCK5VPKv4C6Ogidc/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">演示日记录</a>。</p><p id="da96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也许你也注意到了我不是一个人这么做的。我使用了从未谋面的开发人员编写的文档、教程和代码片段。(大声喊出来，DEV API的文档中有响应结构示例——非常有用！)当我遇到一个CORS问题时，我曾短暂地与资深开发人员配对。这个特定项目的动力来自其他高级开发人员，他们在视频电话中告诉我一些我不知道的事情。更不用说，如果没有来自<a class="ae kt" href="https://virtualcoffee.io" rel="noopener ugc nofollow" target="_blank">虚拟咖啡</a>的演示日，我就不会得到可访问性提示或找到完成它的动力。</p><h2 id="94e9" class="mg kv in bd kw ml mm dn la mn mo dp le kg mp mq li kk mr ms lm ko mt mu lq mv bi translated">附言</h2><p id="3ec7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我提到过想要重新标准化我在DEV博客文章中写标题的方式。当交叉发布到Medium时，我注意到是我把我的标题写为<code class="fe mw mx my mc b">&lt;h2&gt;</code> s。我已经把我的JSX和CSS更新为<code class="fe mw mx my mc b">&lt;h1&gt;</code> s，所以现在我页面上的所有标题都是降序排列的。为了便于访问，我还是想回去把我在DEV上的所有标题降级，让<code class="fe mw mx my mc b">&lt;h2&gt;</code>和<code class="fe mw mx my mc b">&lt;h3&gt;</code>出现在我的文章正文中。</p><p id="e5ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nc">更多内容尽在</em><a class="ae kt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="nc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>