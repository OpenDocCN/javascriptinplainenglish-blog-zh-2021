<html>
<head>
<title>JavaScript Missing Piece — Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript缺失部分—异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-missing-piece-async-await-f86bdac500bc?source=collection_archive---------8-----------------------#2021-12-10">https://javascript.plainenglish.io/javascript-missing-piece-async-await-f86bdac500bc?source=collection_archive---------8-----------------------#2021-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="806b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> JavaScript </strong>是一种<strong class="jp ir">单线程</strong>编程语言。所有任务按队列和顺序运行，并且任务通常一个接一个地同步执行。这促使我们作为开发人员去学习异步的web编程方式，这样我们就可以在处理其他任务的同时执行“非阻塞”代码。幸运的是，在JavaScript中，我们有<strong class="jp ir"> async/await </strong>，这是一个“不太常见”的难题，可以增强我们的网站在处理其他任务时执行非阻塞代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bf766fc10b9054260e75fd2865e8a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Agh2kkmbJe366h7mqmD8VQ.png"/></div></div></figure><p id="6e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们讨论<strong class="jp ir"> async/await </strong>之前，我们需要理解事件循环、回调和承诺。</p><p id="889b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想让你看看这个文档，它清楚地解释了JavaScript中的事件循环、回调和承诺。</p><div class="kx ky gp gr kz la"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#event_loop" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">并发模型和事件循环- JavaScript | MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">JavaScript有一个基于事件循环的并发模型，它负责执行代码，收集和…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo kv la"/></div></div></a></div><div class="kx ky gp gr kz la"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">回调函数- MDN Web文档词汇表:Web相关术语的定义| MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">回调函数是作为参数传递给另一个函数的函数，然后在外部函数中调用它</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo kv la"/></div></div></a></div><div class="kx ky gp gr kz la"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">Promise - JavaScript | MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">Promise对象表示异步操作的最终完成(或失败)及其结果…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lq l ll lm ln lj lo kv la"/></div></div></a></div><p id="b48b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你看完解释之后，我来问你关于这一大块<code class="fe lr ls lt lu b">console.log</code>的问题。请问这4个<code class="fe lr ls lt lu b">console.log</code> (s)的输出顺序是什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/62ebbd865477ccb87eb2495a4018d965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*0rVVcDBelWlB3ZpdnqzEUg.png"/></div></figure><p id="a9ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在向下滚动寻找答案之前，花些时间思考一下。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/822afbed2b1f7565b4dae1431fe1b1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*SKVoQK3Ggf67_RxBVn5aMQ.png"/></div></figure><p id="3186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你做对了吗？事件的顺序如下。<strong class="jp ir">同步</strong> <code class="fe lr ls lt lu b">console.log</code>将首先运行，<strong class="jp ir"> setTimeout函数</strong>即使有0ms的超时，它也将在下一个/未来的<strong class="jp ir">事件循环</strong>中运行。<strong class="jp ir"> Promise </strong>块正在微任务队列中排队，将在下一个<strong class="jp ir">事件循环</strong>开始之前执行，因此在<strong class="jp ir"> setTimeout </strong>代码之前执行。</p><div class="kx ky gp gr kz la"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">通过queueMicrotask()在JavaScript中使用微任务-Web API | MDN</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">微任务是一个短函数，在创建它的函数或程序退出后执行，并且只有当…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">developer.mozilla.org</p></div></div><div class="lj l"><div class="lx l ll lm ln lj lo kv la"/></div></div></a></div><p id="0df2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你对事件循环、回调和承诺有了更清楚的了解，我们可以更仔细地看看<strong class="jp ir">基于承诺的HTTP调用</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/7a4207a3090c7eb9cf50135895be4eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*33u-EQH_0cwKevZZOWAWlg.png"/></div></figure><p id="e718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行这个基于承诺的HTTP调用，<code class="fe lr ls lt lu b">console.log</code>将在显示“API调用成功”输出之前首先显示同步代码输出。正如我们前面提到的，基于承诺的调用正在微任务队列中排队。基于承诺的HTTP调用的美妙之处在于，它在执行API调用时处理数据检索和错误处理。如果抛出一个错误，它将绕过所有的<strong class="jp ir">然后是</strong>回调，直接进入<strong class="jp ir"> catch </strong>块。</p><p id="97a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是JavaScript中阻塞代码的一个经典例子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lz"><img src="../Images/3758095f52f7524c1086c8f4def3c3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2x6DV2uxS0M2RlruTcJIA.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/9535bc81ba8ea014caba0669f08a9000.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*ZjAQ1aYFmI_Pv_vTh7SSSQ.png"/></div></figure><p id="c7b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅当<strong class="jp ir"> 540ms </strong>后阻塞代码完成时，第二个同步代码输出才输出。</p><p id="bc8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您可能认为可以将while循环包装在一个承诺中，让它在同步代码之后运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/94848dc0688f037a90814d636ab9ac53.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*rFM9KIImC383bkL52ypNKg.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/5e110a8a4a714ddcc4aa5091b8a60c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*3oRxjcGKBp-7eKMl-eo6Wg.png"/></div></figure><p id="b5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在某种程度上是正确的，但是在while循环完成之前，第二个同步代码仍然被阻塞。不过你能做的就是把阻塞代码包装在<strong class="jp ir"> Promise.resolve() </strong>里面，这样你就可以确定阻塞代码只会在所有同步代码执行完之后才会执行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi md"><img src="../Images/f23293c3b0607d0f770eed991346670c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*kq5SOTlSekesqN5XG92-Rw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi me"><img src="../Images/fd70fb9f85d9811f1ca63f3408180082.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*QxKT3Rp_tuMAd0UZnGqIKA.png"/></div></figure><p id="93ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您已经了解了<strong class="jp ir">异步</strong>代码如何在基于承诺的调用中工作，我们可以进入<strong class="jp ir">异步/等待</strong>并看看它如何帮助我们作为开发人员编写更干净、更可读的代码。</p><p id="d613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你写一个不返回任何东西的正则函数时，它只是返回void。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/1b19f3b2f06da13d459b72fcd397ab39.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*mvb53J5u0FnEvUxlUT0-Pg.png"/></div></figure><p id="2bd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是当你在函数参数括号前添加<strong class="jp ir"> async </strong>关键字时，它会返回一个<strong class="jp ir"> promise &lt; void &gt; </strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d54fd5215dc4148c1ec5afb486f05c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*-8Zl3UIUE7bkhi7vrlQYiQ.png"/></div></figure><p id="f566" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了使用<strong class="jp ir"> async </strong>关键字之外，从技术上讲，你可以返回一个<strong class="jp ir"> Promise </strong>，它会将函数调用转换成相同的返回类型。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/d466ac4894ae4832f9df17102d7b8eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*_2TIXq1LE6hBEb3uh_natg.png"/></div></figure><p id="e95c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个函数都返回基于承诺的结果。然而，当你结合使用<strong class="jp ir"> async </strong>关键字和<strong class="jp ir"> await </strong>时，威力就来了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/daf0941868897f8067b3e45276bee916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*YCNvH5c88Y_ncjivPcV6lw.png"/></div></figure><p id="094a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们认识到makeDinner()和makeLunch()都会得到我们想要的输出，也就是‘鸡肉’，‘三文鱼’。但是不同之处在于makeDinner()使用了<strong class="jp ir"> await </strong>关键字，使得代码可读性更好。</p><p id="1f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果第二个函数调用独立于第一个函数调用的结果，我们技术上不需要以这种方式写<strong class="jp ir"> await </strong>。因为这将导致事件循环在执行第二功能之前等待第一功能完成。</p><p id="b2b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在getIngredient()函数中写一个<strong class="jp ir"> 1000ms </strong>的延迟。我们可以看到，执行getDinner()的总时间是<strong class="jp ir"> 2002ms </strong>，每个函数大约需要<strong class="jp ir"> 1000ms </strong>的延迟。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/d553385dbde7f6e5eb670867ca16c7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*6XuNTOJ7rGLenpwYvMLE3A.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a2d9e8eb138636930cf30cad676f6708.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*gPD9pWmgPj1mj8bFlBOJGA.png"/></div></figure><p id="f26e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果结果<strong class="jp ir">相互独立</strong>，我们可以通过使用<strong class="jp ir"> Promise.all </strong>和<strong class="jp ir">wait</strong>来编写<strong class="jp ir">非阻塞代码</strong>在<strong class="jp ir">并行</strong>中执行这两个函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/81db55af623799639a73df0bb7f59f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*kTqfFFOvdclb1t2nMBnsKw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/09fda311b0e1107a9d180896e273ee5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*nGtzZ15FQKM8vHaEyFx0mQ.png"/></div></figure><p id="76bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所花费的时间就是getIngredients()函数<strong class="jp ir">发生一次</strong>的延迟。</p><h1 id="f8d5" class="mn mo iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">使用Async/Await处理错误</h1><p id="94a8" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">通过在函数中使用<strong class="jp ir"> try/catch </strong>块代码，可以轻松处理<strong class="jp ir"> async/await </strong>的错误。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6b4bbf89cde5c6de3dfabe1fae2b3141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*8xYDk4JJPb4Fwzdmkucwaw.png"/></div></figure><p id="2acf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以完全控制如何返回数据。如果在你的<strong class="jp ir"> try </strong>块中，你遇到一个错误，这个错误将在<strong class="jp ir"> catch </strong>块中被捕获。如果您处理它并返回错误，您将在您的<strong class="jp ir"> makeDinner() </strong>的<strong class="jp ir">然后</strong>块中看到错误消息。如果您选择抛出错误，您将能够在您的<strong class="jp ir"> makeDinner() </strong>的<strong class="jp ir"> catch </strong>块中看到错误消息。</p><h1 id="85a3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">最后但并不是最不重要的</h1><p id="d2bd" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">当心在[]中使用<strong class="jp ir">异步/等待</strong>。<strong class="jp ir">映射</strong>或[]。<strong class="jp ir"> forEach </strong>循环。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/125d6c6686879ac72f69cb12de33d66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*-cT4QssPFtI_wzczUDujSA.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f25e2dc9848cd45716c1a1ab881ac074.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*2R5P1ca_42nyvVShVHj7BA.png"/></div></figure><p id="6326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能认为它会一个接一个地运行，但实际上它是在<strong class="jp ir"> promise.all </strong>被解决之后才被执行的。如果您仍然希望您的循环同步运行<strong class="jp ir">和</strong>，您可以使用传统的for循环来代替。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/16cb5035194b4985a3a0d3de923af359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*8cGkEng38xuPkK3VsdGVJw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1eea40138c899d1bce344e91616d587e.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*dS0-smMPFohksg16EDXxHQ.png"/></div></figure><p id="db7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是由于您使用的是<strong class="jp ir"> async/await </strong>，我假设您希望在没有任何阻塞代码的情况下同时运行所有内容，所以在这种情况下，您可以在for循环中使用这个语法来同时解决所有内容。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/95a03e5014661489ba46c1e60f52e057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*yCU71pmdudCYvey3ElP30Q.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0f02a93ab2b0d8e0bb47c9a97e1fe286.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*uGqPObhdsJoVj2G6jNuIPA.png"/></div></figure><h1 id="1b47" class="mn mo iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">奖金</h1><p id="d93c" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">你也可以在你的<strong class="jp ir"> if/else </strong>案例中有条件地使用<strong class="jp ir"> async/await </strong> <em class="nx">。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ace6994fe7539ac892a016906c79e4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Qfme17D6UWxvUGCF9matcA.png"/></div></figure><h1 id="d438" class="mn mo iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">摘要</h1><p id="1ce1" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">希望这篇文章能帮助你更好地理解<strong class="jp ir"> async/await </strong>如何工作以及<strong class="jp ir"> JavaScript </strong>如何处理它们。如果你有其他的<a class="ae nz" href="https://medium.com/@devjo/membership" rel="noopener">异步/等待</a>技巧想与他人分享，请在下面留下你的评论。祝你愉快。</p><div class="kx ky gp gr kz la"><a href="https://medium.com/@devjo/membership" rel="noopener follow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">用我的推荐链接- DevJo加入媒体</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">medium.com</p></div></div><div class="lj l"><div class="oa l ll lm ln lj lo kv la"/></div></div></a></div><p id="7294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nx">更多内容看</em> <a class="ae nz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nx">说白了。报名参加我们的</em> </a><a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="nx">免费每周简讯</em> </a> <em class="nx">。在我们的</em> <a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="nx">社区</em> </a> <em class="nx">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>