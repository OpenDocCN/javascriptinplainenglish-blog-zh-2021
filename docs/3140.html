<html>
<head>
<title>Recursion 101: What is a Recursive Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归101:什么是递归函数？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursion-101-what-is-a-recursive-function-dfeb856488e6?source=collection_archive---------13-----------------------#2021-06-25">https://javascript.plainenglish.io/recursion-101-what-is-a-recursive-function-dfeb856488e6?source=collection_archive---------13-----------------------#2021-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fb1f329aba16369680844cc69f240c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Msljwfct9wL0RSxZnWaMzg.png"/></div></div></figure><p id="f0e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，递归函数是一个在自身内部调用自身直到满足某个条件的函数。在大多数情况下，当使用JavaScript时，最好使用迭代而不是递归，因为JavaScript不是针对递归优化的。也就是说，当你需要用不同的参数重复调用同一个函数时，递归函数是一个有用的工具……这也是技术面试中可能出现的问题。</p><p id="5826" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于递归对于一些人来说是一个很难理解的概念，我想我们将从一个经典的递归例子开始，并把它分解成容易理解的部分。在每个“块”中，我们将仔细看看正在发生的事情和原因。</p><p id="088e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们将看到一个递归函数，它求解n！或者n阶乘。如果你不熟悉，阶乘的定义是一个整数和它下面所有整数的乘积。比如4的阶乘，或者说4！，就是4×3×2×1，等于24。所以4！= 24.</p><p id="4d9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们了解了问题，让我们来看看解决方案。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/d7725651cdc0c2fa288ed168b154e21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*_o-FIHdfZaNtHOgDjZbaZw.png"/></div></figure><p id="8ba5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这只是看起来像胡言乱语，那完全没关系！我们来分解一下。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/a9c2a3a3a54f1ab516da78e5281f6fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*-ZTTel-qOIcbdYjfrqNdxQ.gif"/></div></figure><p id="5e36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一行我们定义了函数。如您所见，我们将函数命名为“factorial ”,并告诉它接受一个参数“num”。好吧，到目前为止还算简单。让我们暂时跳过第二行，看看这个函数的返回值。哇，这是怎么回事？让我们插上一个数字，仔细看看是怎么回事。</p><p id="2ee1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们用4替换“num ”,第三行看起来像这样。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/d44fba7770a0c2efc51137a6f7e676aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*Wm7q0mvAhSwJm27MlCMehQ.png"/></div></figure><p id="9e50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们取4，然后乘以<code class="fe la lb lc ld b">factorial(4-1)</code>。什么是<code class="fe la lb lc ld b">factorial(4-1)</code>？嗯，是<code class="fe la lb lc ld b">factorial(4-1)</code>或者<code class="fe la lb lc ld b">factorial(3)</code>的返回值。而<code class="fe la lb lc ld b">factorial(3)</code>的返回值是<code class="fe la lb lc ld b">3 * factorial(3-1)... factorial(2)</code>是<code class="fe la lb lc ld b">2 * factorial(2-1)... factorial(1) </code>是<code class="fe la lb lc ld b">1 * factorial(1-1)</code>还是<code class="fe la lb lc ld b">factorial(0).</code>现在让我们看看代码的第二行。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/6fcffd4ca259300aa774b594f26d07bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*FnyO1GI1SaRziHrl3WJKxQ.png"/></div></figure><p id="c884" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这被称为基本情况。这是阻止函数无限循环的条件。如果没有这一行，我们将一直超过0，直到浏览器崩溃，或者到达-无穷大。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/2587c76641ac3b919f79f3d20764e8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dt4LqmdPD9HJDn_dxk6V2g.gif"/></div></figure><p id="52b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们有一个基本情况，当调用<code class="fe la lb lc ld b">factorial(0) </code>并且num确实等于0时，我们返回1。现在我们有了一个坚实的价值。一个数字而不是另一个函数调用。由于<code class="fe la lb lc ld b">factorial(0) </code>返回1，那么<code class="fe la lb lc ld b">factorial(1) </code>将返回<code class="fe la lb lc ld b">1 * 1 </code>的结果或者仅仅是1，由于<code class="fe la lb lc ld b">factorial(1) </code>现在有一个值(1)，<code class="fe la lb lc ld b">factorial(2) </code>返回<code class="fe la lb lc ld b">2 * 1 </code>或者2… <code class="fe la lb lc ld b">factorial(3) </code>返回<code class="fe la lb lc ld b">3 * 2 </code>或者6…最后，回到我们开始的地方，<code class="fe la lb lc ld b">factorial(4) </code>返回<code class="fe la lb lc ld b">4 * 6</code>或者24。</p><p id="e67c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来这里发生了很多事情，确实如此，但是现在我们已经知道当我们调用<code class="fe la lb lc ld b">factorial(4) </code>时会发生什么，我们可以从不同的角度来看待它，巩固我们的理解。让我们来看看JavaScript本身，看看调用栈。</p><p id="5f28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript使用调用堆栈来管理执行上下文。调用堆栈基于后进先出(LIFO)原则工作。如果这是没有意义的，不要担心，它会很快。想象一下桌子上的一叠文件。当您添加到堆栈中时，您会添加到堆栈的顶部。当您从纸堆中取出纸张时，也会从纸堆顶部取出纸张。简而言之，这就是JavaScripts调用堆栈的工作方式。现在，当我们调用<code class="fe la lb lc ld b">factorial(4).</code>时，让我们来看看它的运行情况</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="ddd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">啊，所以当我们调用<code class="fe la lb lc ld b">factorial(4) </code>时，它调用<code class="fe la lb lc ld b">factorial(3), factorial(3) </code>调用<code class="fe la lb lc ld b">factorial(2), factorial(2) </code>调用<code class="fe la lb lc ld b">factorial(1), </code>而<code class="fe la lb lc ld b"> factorial(1) </code>调用<code class="fe la lb lc ld b">factorial(0)</code>，我们最终得到一个调用堆栈，看起来像这样:</p><pre class="ku kv kw kx gt li ld lj lk aw ll bi"><span id="b4b6" class="lm ln in ld b gy lo lp l lq lr">factorial(0) //returns 1<br/>factorial(1) //waiting on factorial(0)<br/>factorial(2) //waiting on factorial(1)<br/>factorial(3) //waiting on factorial(2)<br/>factorial(4) //waiting on factorial(3)</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/970dc760da79735ab088c79bc6d1b595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*7Rlvwo10RRyOyR_XG4UGPw.gif"/></div></figure><p id="a2c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记得那堆文件吗？我们在调用时将每个函数添加到堆栈的顶部。一旦我们遇到了基本情况(第二行的if语句),并且有了返回值，我们就从栈顶移除这个函数，并使用它的返回值来求解下面的函数。冲洗并重复，直到堆叠空了。相当聪明！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/90f026e9e7f7e60091ae89a8ecba5933.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*U-vE7l4hUz2loD1Ul9zpEA.gif"/></div></figure><h2 id="c8ec" class="lm ln in bd lu lv lw dn lx ly lz dp ma kg mb mc md kk me mf mg ko mh mi mj mk bi translated">结论</h2><p id="48eb" class="pw-post-body-paragraph jv jw in jx b jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks ig bi translated">递归可能是一个难以理解的概念，递归函数可能会变得非常复杂。这个递归函数非常简单，但是如果不是非常清楚，也不用太担心。只要坚持练习，最终会成功的。开心快乐编码！</p><p id="cecc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mq">更多内容看</em> <a class="ae mr" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="mq">说白了</em></strong></a></p></div></div>    
</body>
</html>