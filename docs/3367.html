<html>
<head>
<title>Code Review: Use A Good Key When Rendering Lists In Your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码审查:在React应用程序中呈现列表时使用好的键</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-review-use-a-good-key-when-rendering-lists-in-your-react-b28d01319eed?source=collection_archive---------17-----------------------#2021-07-08">https://javascript.plainenglish.io/code-review-use-a-good-key-when-rendering-lists-in-your-react-b28d01319eed?source=collection_archive---------17-----------------------#2021-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f518" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么时候可以使用索引作为键，什么时候应该为它生成另一个值？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24c9c7b2c9ac22176dbba9e8f50dcfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toS8KPYvqzqAFdvxtyNajw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@bradyn" rel="noopener ugc nofollow" target="_blank">Bradyn Trollip</a> on <a class="ae ky" href="https://unsplash.com/s/photos/sequence" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="63ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如今，呈现项目列表是大多数UI的常见场景。在官方文件中，React声明<code class="fe kz la lb lc b">key</code>是你的列表的一个基本属性。在这篇文章中，我将总结一些关于它的用法的注意事项。</p><h1 id="3acf" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在某些情况下，索引已经足够好了</h1><h1 id="338d" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">静态列表</h1><p id="7091" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">假设您只显示项目，而没有机会对列表进行重新排序，比如删除一个对象、过滤或移动东西。在那种情况下，<code class="fe kz la lb lc b">index</code>对<code class="fe kz la lb lc b">key</code>来说是一条安全又容易的路。</p><h1 id="4eca" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">无状态组件列表</h1><p id="a0b4" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">如果你的项目是无状态的组件，使用<code class="fe kz la lb lc b">index</code>作为<code class="fe kz la lb lc b">key</code>也是可以的，即使你必须改变它们的顺序。</p><p id="5f04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管这种方法没有针对渲染性能进行优化，但它不会直接影响用户体验。如果您的列表很小，并且子组件没有那么复杂，您可以将<code class="fe kz la lb lc b">index</code>用作<code class="fe kz la lb lc b">key</code>。(你可以在React的<a class="ae ky" href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读更多关于React如何使用<code class="fe kz la lb lc b">key</code>来优化渲染过程的信息)。</p><p id="3e87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的示例中，我有一个带有不同标签和颜色的项目列表。我将该信息存储为列表的一个状态，并使用无状态组件来呈现其子元素。当我删除一些项目时，标签和颜色仍然匹配良好。这意味着在这种情况下<code class="fe kz la lb lc b">index</code>作为<code class="fe kz la lb lc b">key</code>工作良好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/8420f1676d7580596e0bea540353c2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/0*aLUYrx0cPFy0qIsH.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Index can work if the list only contains stateless components</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="b8cf" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">何时避免使用索引</h1><p id="d913" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">如果你的项目是有状态的组件，并且用户可以改变他们的顺序，使用<code class="fe kz la lb lc b">index</code>作为<code class="fe kz la lb lc b">key</code>将会弄乱项目的状态。</p><p id="d8ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的示例与上面的示例具有相同的功能。不同的是，我将颜色代码移到了子组件的<code class="fe kz la lb lc b">state</code>中。这意味着我现在使用有状态组件而不是无状态组件。当我删除一些项目时，颜色都乱了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/bae5b7af856e2cc7720b2408c5ddbde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/0*YeXdEoEyhDPpf9DS.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">It’s problematic if keys weren’t set correctly</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="18fd" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">怎么处理呢</h1><p id="0706" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">当您呈现有状态组件的列表并想要对它们重新排序时，您的数据必须有一个惟一的值用作<code class="fe kz la lb lc b">index</code>。如果没有，您应该生成一个。</p><p id="746b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的例子中，我的列表是一个没有任何唯一属性的字符串数组。我必须用新生成的ID将每一项转换成一个对象，对于我的有状态子组件，这个ID变成了<code class="fe kz la lb lc b">key</code>。当我重新排序列表时，这个ID确保了正确的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/24624b1dd18423bce4f1746725211b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/0*op5uqGcn4JQAG_tX.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Correct key solves the problem with Stateful Items</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="3b38" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">不要在渲染中生成ID</h1><p id="5a96" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">不要在渲染中生成ID。这种行为是一种不好的做法，原因有很多:</p><ul class=""><li id="4283" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">这些键会改变每一次渲染。它强制将项目视为新添加的，并总是重新呈现。</li><li id="9f4c" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">对于呈现动作来说，生成ID可能是一项开销很大任务。</li></ul><p id="fa9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ID应该是列表的永久值。它应该在调用者处生成(如果你使用props的话)或者随你的状态一起生成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="1271" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><ul class=""><li id="37d5" class="mk ml in jm b jn mb jr mc jv my jz mz kd na kh mp mq mr ms bi translated">如果您的数据有唯一的属性，请使用它。</li><li id="4252" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">如果你不需要重新排列你的列表，使用<code class="fe kz la lb lc b">index</code>就足够了。</li><li id="cb95" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">如果你需要对你的列表重新排序，并且你的子组件是无状态的，那么使用<code class="fe kz la lb lc b">index</code>是可以的，尽管它没有针对渲染性能进行优化。</li><li id="96d3" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">在其他情况下，您必须首先为列表数据生成一个唯一的值。这个值应该是永久的，不应该在渲染中改变。</li></ul></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="853f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章是我关于代码评审的系列文章的一部分，它讲述了我在评审代码时的笔记。对某些人来说，它们中的每一个都可能很小或者没什么特别的。但是因为一个小小的错误会让开发人员付出很大的代价，所以其他人留意所有的可能性可能会有所帮助。</p><p id="11f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经把上面的样本放在了<a class="ae ky" href="https://github.com/huynvk/react-small-demos/tree/main/react-key" rel="noopener ugc nofollow" target="_blank"> Github库</a>中，以防有人想试用它们。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="aef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">原发布于</em><a class="ae ky" href="https://huynvk.dev/blog/code-review-use-a-good-key-when-rendering-lists-in-your-react" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://huynvk . dev</em></a><em class="ni">。</em></p><p id="39f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>