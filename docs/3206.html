<html>
<head>
<title>The “this” Keyword in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的“this”关键字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-this-keyword-in-javascript-93090abf261b?source=collection_archive---------4-----------------------#2021-06-30">https://javascript.plainenglish.io/the-this-keyword-in-javascript-93090abf261b?source=collection_archive---------4-----------------------#2021-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b6af92db870b48d2931b17f404d438ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgajcYcYuM18-3CWDVt2dw.jpeg"/></div></div></figure><p id="7b7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript中最被误解的特性在其他语言中被视为基础知识。即使花了一整天阅读关于其内部工作的书籍和教程，关键字仍然是一个令人困惑的话题。</p><p id="b1d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不是不知道那是什么，我们知道。但是当我们需要将知识付诸实践的时候，我们总是会错过一些东西。</p><blockquote class="kx ky kz"><p id="ac7e" class="jv jw la jx b jy jz ka kb kc kd ke kf lb kh ki kj lc kl km kn ld kp kq kr ks ig bi translated">“这个”以前是这个，但“这个”现在是那个</p></blockquote><p id="5c79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">混乱和误解是这四条规则的原因。虔诚地追随他们，你就永远不会成为“这个”的疯狂的牺牲品。规则如下:</p><ol class=""><li id="950d" class="le lf in jx b jy jz kc kd kg lg kk lh ko li ks lj lk ll lm bi translated">默认(全局)绑定规则。</li><li id="6365" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">隐式绑定规则。</li><li id="4566" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">显式绑定规则</li><li id="824d" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">用<code class="fe kt ku kv kw b">new</code>调用构造函数</li></ol><p id="a521" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的建议是:把这些规则写在便利贴上，放在你的桌子旁边。</p><p id="0e75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始探索之前，让我们稍微解释一下为什么“这”是错误的。</p><h1 id="a51c" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">困惑</h1><p id="50b1" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">当你写一段代码时，你的心理模型总是以<strong class="jx io">创建时间</strong>为中心。创建时间是创建/编写这段代码的时期。JavaScript还有另一个叫做<strong class="jx io">执行时间</strong>的周期，它解释你写的东西。</p><p id="22e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">绑定、引用和内存分配都是在执行时完成的。这是意料之中的——在大多数编程语言中，这是一种相互行为。</p><p id="44c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript的问题在于，在运行时(执行)，它根据上下文绑定值。这意味着一个逻辑不一定按照它被(用户)写或读的方式来解释，而是基于所谓的它的<strong class="jx io">执行上下文</strong>。</p><h1 id="5310" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">执行上下文</h1><p id="04a8" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">让我给你一个执行上下文的例子。</p><p id="7d37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有三个保安机器人每天晚上在你的社区巡逻。说机器人A、B、C，晚上9点到11点，机器人A、B在值班，C在充电。晚上11点，C充满电，代替a，现在我们有B和C值班。这种转换以2小时的间隔持续进行。</p><p id="c1e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设在执勤(执行)时，两人需要互相交流对方的位置和检查区域。在第一轮，A和B在交流。当A被C取代时，A不会继续与B通信；相反，它应该与c。</p><p id="a55e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">执行上下文已更改，环境不再相同。在切换之后，A不能与B交谈，但是c理解A不应该再与B交谈，这是我们对“this”关键字感到困惑的地方。</p><p id="283c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">this</code>可以看作是我们的机器人发现自己所处的现状。</p><p id="6153" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你知道为什么它总是让你困惑，让我们来看看避免困惑的四条规则。</p><h1 id="289e" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">规则1:默认(全局)绑定</h1><p id="cb51" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">首先，仔细查看以下示例，并猜测可以记录到控制台的内容。请随意误解:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="1791" class="nd lt in kw b gy ne nf l ng nh">// 1A<br/>function printName() {<br/>  console.log(this.name);<br/>}</span><span id="9aa5" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="cdfd" class="nd lt in kw b gy ni nf l ng nh">printName();</span></pre><p id="235c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记住答案，然后试着猜一猜这个:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="ccd9" class="nd lt in kw b gy ne nf l ng nh">// 1B<br/>function printName() {<br/>  'use strict';<br/>  console.log(this.name);<br/>}</span><span id="8e85" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="c3ca" class="nd lt in kw b gy ni nf l ng nh">printName();</span></pre><p id="370b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们分析一下:</p><p id="1c8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当不在严格模式下时，这是指全局范围。在严格模式下，其绑定是未定义的。</p><p id="681d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Ex 1A </strong>将在控制台上打印“Scotch”，因为“this”指的是全局默认绑定。</p><p id="3268" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> Ex 1B </strong>中，“this”也可以指全局对象，但是因为“use strict”，它默认为<code class="fe kt ku kv kw b">undefined</code>。<code class="fe kt ku kv kw b">use strict</code>确保<code class="fe kt ku kv kw b">this</code>的范围是功能范围，不是全局范围。</p><h1 id="ac79" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">规则2:隐式绑定</h1><p id="4cf3" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">如果函数没有暴露给全局上下文，该怎么办？您对以下几点有什么看法？</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="e753" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Google',<br/>  printName: function printName() {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="a054" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="d927" class="nd lt in kw b gy ni nf l ng nh">company.printName();</span></pre><p id="363f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一次，这是保留对封装其包装功能的对象的引用。因此，规则规定-“这”是指包含在对象中的调用点。</p><p id="fb05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标记“呼叫中心”字样。这条规则没有说“写站点”，而是说“呼叫站点”。上面的示例将打印“Google”，但是不要指望下面的示例打印相同的内容:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="5737" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Google',<br/>  printName: function printName() {<br/>    console.log(this.name);<br/>  }<br/>}</span><span id="550e" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="a78e" class="nd lt in kw b gy ni nf l ng nh">company.printName();  // Google</span><span id="0713" class="nd lt in kw b gy ni nf l ng nh">// print name call site<br/>// won't be the object<br/>// but global<br/>var printNameAgain = company.printName;</span><span id="a986" class="nd lt in kw b gy ni nf l ng nh">printNameAgain(); // Scotch</span></pre><p id="1652" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本示例打印“Scotch”而不是“Google”，因为呼叫站点不是对象，而是全局对象。记住我们的安全机器人插图；执行环境才是最重要的。</p><h1 id="0f5b" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">规则3:显式绑定</h1><p id="cf89" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">如果我们希望<code class="fe kt ku kv kw b">printNameAgain</code>引用<code class="fe kt ku kv kw b">company</code>对象，即使调用上下文不是<code class="fe kt ku kv kw b">company</code>对象而是<code class="fe kt ku kv kw b">global</code>对象？</p><p id="eb1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显式绑定规则:</p><p id="1d88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用<code class="fe kt ku kv kw b">call</code>、<code class="fe kt ku kv kw b">apply</code>或<code class="fe kt ku kv kw b">bind</code>显式操作呼叫中心。</p><p id="7568" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以手工使<code class="fe kt ku kv kw b">printNameAgain</code>引用<code class="fe kt ku kv kw b">company</code>对象作为它的调用点:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="294f" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Google',<br/>  printName: function printName() {<br/>    console.log(this.name);<br/>  }<br/>}</span><span id="558e" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="6e32" class="nd lt in kw b gy ni nf l ng nh">var printNameAgain = company.printName;</span><span id="6b8b" class="nd lt in kw b gy ni nf l ng nh">printNameAgain.call(company);</span></pre><p id="dac3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，当我们调用<code class="fe kt ku kv kw b">printNameAgain</code>时，它引用了全局对象，但是我们现在使用<code class="fe kt ku kv kw b">call</code>方法来硬绑定<code class="fe kt ku kv kw b">company</code>作为它的执行上下文。</p><h1 id="0a5d" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参数呢？</h1><p id="9648" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">当函数有参数时，您可以在上下文之后传入:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="5863" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Google',<br/>  printName: function printName(prefix, suffix) {<br/>    console.log(prefix + this.name + suffix);<br/>  }<br/>}</span><span id="9b74" class="nd lt in kw b gy ni nf l ng nh">var name = 'Scotch';</span><span id="439a" class="nd lt in kw b gy ni nf l ng nh">var printNameAgain = company.printName;</span><span id="14f3" class="nd lt in kw b gy ni nf l ng nh">// hard bind company to printNameAgain<br/>printNameAgain.call(company, 'Hi ', '!!');</span></pre><p id="7ffb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">printName函数需要一个<code class="fe kt ku kv kw b">prefix</code>和<code class="fe kt ku kv kw b">suffix</code>参数。当用<code class="fe kt ku kv kw b">call</code>调用传递的函数(<code class="fe kt ku kv kw b">printNameAgain</code>)时，我们在<code class="fe kt ku kv kw b">company</code>对象绑定后传入参数。</p><p id="cacf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">apply</code>方法允许您以数组的形式传递参数:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="a6d5" class="nd lt in kw b gy ne nf l ng nh">printNameAgain.call(company, ['Hi ', '!!']);</span></pre><p id="0ce4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个是<code class="fe kt ku kv kw b">bind</code>。它的作用与<code class="fe kt ku kv kw b">call</code>和<code class="fe kt ku kv kw b">apply</code>略有不同。<code class="fe kt ku kv kw b">call</code>和<code class="fe kt ku kv kw b">apply</code>执行功能，而<code class="fe kt ku kv kw b">bind</code>不像它们那样。<code class="fe kt ku kv kw b">bind</code>所做的是<em class="la">绑定</em>正确的上下文并返回带有调整后的上下文的函数:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="615e" class="nd lt in kw b gy ne nf l ng nh">var printFunc = printNameAgain.bind(company);</span></pre><p id="0e71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，您可以在需要时调用返回的函数:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="8cc3" class="nd lt in kw b gy ne nf l ng nh">var printFunc('Hi ', '!!');</span></pre><h1 id="a7ed" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">规则4:用新的</h1><p id="7242" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">每当看到用<code class="fe kt ku kv kw b">new</code>关键字调用的函数时，最后一条规则就会浮现出来:</p><p id="d70f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关键字<code class="fe kt ku kv kw b">new</code>在一个链接到原型对象的函数中创建一个虚拟对象。如果这个虚构的对象中没有现有的return语句，它将由函数隐式返回。</p><p id="61a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以尽可能简单的方式来分解它。</p><p id="cc17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我有以下功能:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="a7a1" class="nd lt in kw b gy ne nf l ng nh">function Company() {<br/>  this.name = 'Scotch'<br/>}</span></pre><p id="9bbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后尝试用new调用该函数:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="1781" class="nd lt in kw b gy ne nf l ng nh">new Company();</span></pre><p id="a194" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下评论理想地展示了内部发生的情况:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="1a83" class="nd lt in kw b gy ne nf l ng nh">function Company() {<br/>  // var this = {};<br/>  this.name = 'Scotch'<br/>  // return this;<br/>}</span></pre><p id="4dd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个名为<code class="fe kt ku kv kw b">this</code>的虚拟对象，如果函数没有返回任何内容，则返回<code class="fe kt ku kv kw b">this</code>。因此，您可以将函数调用用作对象:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="4360" class="nd lt in kw b gy ne nf l ng nh">var companyInstance = new Company();</span><span id="995f" class="nd lt in kw b gy ni nf l ng nh">console.log(companyInstance.name) // prints Scotch</span></pre><p id="3492" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该规则还规定该对象链接到原型对象。原型链接超出了本文的范围，但是如果我们看到一个这样的链接的例子，也不会有什么坏处:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="297e" class="nd lt in kw b gy ne nf l ng nh">function Company() {<br/>  this.name = 'Scotch'<br/>}</span><span id="62f6" class="nd lt in kw b gy ni nf l ng nh">Company.prototype.getName = function() {<br/>  return this.name;<br/>}</span><span id="f7c1" class="nd lt in kw b gy ni nf l ng nh">var companyInstance = new Company();<br/>console.log(companyInstance.getName()); // Scotch</span></pre><p id="d0f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只是给公司的原型对象附加了一个方法<code class="fe kt ku kv kw b">getName</code>。该方法可以访问在<code class="fe kt ku kv kw b">Company</code>中创建的同一个<code class="fe kt ku kv kw b">this</code>对象。</p><p id="e01a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">提示</strong>:用<code class="fe kt ku kv kw b">new</code>关键字调用的函数称为<strong class="jx io">构造函数</strong>，通常用大写字母书写，而用<code class="fe kt ku kv kw b">new</code>关键字调用的函数称为<strong class="jx io">构造函数调用</strong>。</p><h1 id="d016" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">优先顺序</h1><p id="1c31" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">重要的是要注意这些规则是按照优先顺序应用的。这意味着如果在同一个场景中发现两个或更多的规则，它们的应用是有顺序的。内容如下:</p><ol class=""><li id="92ea" class="le lf in jx b jy jz kc kd kg lg kk lh ko li ks lj lk ll lm bi translated">构造函数调用(规则4)</li><li id="5361" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">显式绑定(规则3)</li><li id="d2ff" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">隐式绑定(规则2)</li><li id="c6a4" class="le lf in jx b jy ln kc lo kg lp kk lq ko lr ks lj lk ll lm bi translated">默认绑定(规则1)</li></ol><p id="94ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，仅仅颠倒规则就显示了它们的优先顺序。</p><h1 id="47c8" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">常见陷阱:异步处理</h1><p id="79d5" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated"><code class="fe kt ku kv kw b">this</code>绑定有一些已知的缺陷。它们在接收回调作为处理程序的异步逻辑中最受关注。这些处理程序有时被绑定到不同的上下文，使得<code class="fe kt ku kv kw b">this</code>的行为出乎意料。</p><p id="ba68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事件处理就是这样一种情况。事件处理程序是传递给事件注册的回调函数。当事件被触发时，这些回调函数在运行时执行。下面是一个基本的例子:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="2cc0" class="nd lt in kw b gy ne nf l ng nh">button.addEventListener('click', function() {<br/>  console.log('clicked')<br/>});</span></pre><p id="3494" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览器需要给出一些关于事件的上下文信息。它通过绑定到函数中的<code class="fe kt ku kv kw b">this</code>来做到这一点。因此，您可以从关键字:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="8050" class="nd lt in kw b gy ne nf l ng nh">button.addEventListener('click', function() {<br/>  console.log(this)<br/>});</span></pre><p id="b464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是预期的行为，直到您需要从外部上下文访问<code class="fe kt ku kv kw b">this</code>。参见:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="697c" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Scotch',<br/>  getName: function() {<br/>    console.log(this.name)<br/>  }<br/>}</span><span id="5551" class="nd lt in kw b gy ni nf l ng nh">// This event's handler will throw an error<br/>button.addEventListener('click', company.getName)</span></pre><p id="f960" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击事件处理程序是<code class="fe kt ku kv kw b">company</code>对象中的一个方法。正如我们已经提到的，事件处理程序有自己的<code class="fe kt ku kv kw b">this</code>绑定，但是我们需要通过<code class="fe kt ku kv kw b">this</code>访问<code class="fe kt ku kv kw b">company</code>。运行上面的示例将抛出一个错误，告诉您无法读取<code class="fe kt ku kv kw b">name</code>属性。更糟糕的是，<code class="fe kt ku kv kw b">name</code>属性存在于事件的<code class="fe kt ku kv kw b">this</code>属性上，从而产生奇怪的结果，甚至不会抛出错误。</p><p id="b414" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决这个问题，我们需要手动绑定上下文:</p><pre class="mv mw mx my gt mz kw na nb aw nc bi"><span id="0610" class="nd lt in kw b gy ne nf l ng nh">var company = {<br/>  name: 'Scotch',<br/>  getName: function() {<br/>    console.log(this.name)<br/>  }<br/>}</span><span id="cf94" class="nd lt in kw b gy ni nf l ng nh">// bind getName's context as 'company'<br/>button.addEventListener('click', company.getName.bind(company))</span></pre><h1 id="e38c" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="3afa" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">对，就是这样。这就是<code class="fe kt ku kv kw b">this</code>的作用，仅此而已。下次您遇到代码示例时，不要坐立不安，因为它保存着关于正在运行的(不是编写的)代码的上下文信息。</p><p id="90c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要对此进行调试，请避免从代码编辑器中对其进行推理。打开浏览器，在遇到断点的地方添加断点。这样，您将确切地了解到一个<code class="fe kt ku kv kw b">this</code>绑定正在存储什么，以及这些值可能来自哪里。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="edb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你喜欢。</p><p id="4a84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="la">更多内容请看</em><a class="ae nq" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="la">plain English . io</em></strong></a></p></div></div>    
</body>
</html>