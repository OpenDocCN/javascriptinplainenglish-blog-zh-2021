<html>
<head>
<title>Hoisting in JavaScript Explained: A Beginner-Friendly Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提升解释:初学者友好指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hoisting-in-javascript-40413882dde7?source=collection_archive---------19-----------------------#2021-12-21">https://javascript.plainenglish.io/hoisting-in-javascript-40413882dde7?source=collection_archive---------19-----------------------#2021-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1fc0b1a8ae322bc27b202fea376cde87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6C65_anBezHu2JogPqtcQ.png"/></div></div></figure><blockquote class="jv jw jx"><p id="f761" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">提升是一种JavaScript机制，在代码执行之前，变量和函数声明被移动到它们作用域的顶部。</p></blockquote><p id="ea65" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这意味着无论我们在哪里声明我们的变量，函数，甚至类，它都会被移动到它们作用域的顶部，无论是全局作用域还是局部作用域。请注意，JavaScript引擎并没有在物理上移动我们的代码，我们的代码停留在我们输入它的地方。让我们用例子来探讨提升:</p><ul class=""><li id="32e7" class="la lb in kb b kc kd kg kh kx lc ky ld kz le kw lf lg lh li bi translated"><strong class="kb io">可变吊装</strong></li></ul><p id="e11b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">JavaScript引擎将变量声明移动到作用域的顶部。考虑下面的例子:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="b623" class="ls lt in lo b gy lu lv l lw lx">console.log(product); // undefined<br/>var product = “coffee”;</span></pre><p id="01a6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在这里，我们甚至在声明变量<code class="fe ly lz ma lo b">product</code>之前就访问了它，我们得到了<code class="fe ly lz ma lo b">undefined</code>，这是因为<strong class="kb io">执行上下文</strong>在JavaScript中的工作方式。当我们运行一个程序时，JavaScript引擎浏览代码，甚至在代码执行之前就用<code class="fe ly lz ma lo b">undefied</code>初始化变量(用<code class="fe ly lz ma lo b">var</code>声明)。你可以在我的另一篇博客<a class="ae mb" href="https://theprakashkumar.medium.com/javascript-execution-context-8c62cf88c32a" rel="noopener"> JavaScript执行上下文</a>中读到更多关于执行上下文的内容。</p><p id="e09a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">回到例子，由于变量已经用<code class="fe ly lz ma lo b">undefined</code>初始化，我们的代码就像解释器一样:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="6e52" class="ls lt in lo b gy lu lv l lw lx">var product;<br/>console.log(product); // undefined<br/>product = "coffee";</span></pre><p id="38b3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><strong class="kb io">字母关键词</strong></p><p id="213b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">考虑以下用<code class="fe ly lz ma lo b">let</code>关键字声明变量的代码:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="bf2a" class="ls lt in lo b gy lu lv l lw lx">console.log(product); <br/>let product = "coffee";</span></pre><p id="5e95" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">上面的代码会给出以下错误:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="38ce" class="ls lt in lo b gy lu lv l lw lx">ReferenceError: Cannot access 'product' before initialization</span></pre><p id="ddbf" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">错误信息说明<code class="fe ly lz ma lo b">product</code>变量已经在内存中。JavaScript引擎提升使用<code class="fe ly lz ma lo b">let</code>关键字的变量声明，但是它不像在<code class="fe ly lz ma lo b">var</code>的情况下那样用<code class="fe ly lz ma lo b">undefined</code>初始化这些变量。注意，如果您访问一个不存在的变量，JavaScript将抛出一个不同的错误:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="147f" class="ls lt in lo b gy lu lv l lw lx">console.log(price); // ReferenceError: price is not defined<br/>let product = "coffee";</span></pre><p id="4d2e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">请注意，由于时间死区(TDZ)，当我们试图在初始化之前获取值时，我们只会得到一个引用错误，如果变量已经初始化，我们仍然会得到<code class="fe ly lz ma lo b">undefined</code>，因为如果JavaScript引擎仍然无法在声明它们的行中找到<code class="fe ly lz ma lo b">let</code>或<code class="fe ly lz ma lo b">const</code>变量的值，它将为它们分配值<code class="fe ly lz ma lo b">undefined</code>或返回一个错误(对于<code class="fe ly lz ma lo b">const</code>，见下文):</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="82b4" class="ls lt in lo b gy lu lv l lw lx">let product;<br/>console.log(product); // undefined<br/>product = "coffee";</span></pre><p id="8ac5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><strong class="kb io">常量关键字</strong></p><p id="d5ca" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><code class="fe ly lz ma lo b">const</code>的行为很像<code class="fe ly lz ma lo b">let</code>而不是输出<code class="fe ly lz ma lo b">undefined</code>，它会通过参考误差:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="a73a" class="ls lt in lo b gy lu lv l lw lx">console.log(product); // ReferenceError: Cannot access 'product' before initialization<br/>const product = coffee;</span></pre><p id="7eb5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">如上所述，如果JavaScript引擎没有获得用<code class="fe ly lz ma lo b">const</code>声明的变量的值，它将给出一个错误:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="925a" class="ls lt in lo b gy lu lv l lw lx">const product;// SyntaxError: Missing initializer in const declaration<br/>const product = "coffee";</span></pre><ul class=""><li id="3bfc" class="la lb in kb b kc kd kg kh kx lc ky ld kz le kw lf lg lh li bi translated"><strong class="kb io">功能提升</strong></li></ul><p id="0755" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">正如我们之前讨论的那样，在变量JavaScript引擎使用<code class="fe ly lz ma lo b">undefined</code>初始化的情况下，但是在函数声明的情况下，执行上下文在代码执行之前存储整个函数。</p><p id="27fd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><strong class="kb io">功能声明</strong></p><p id="ac3a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">函数声明被提升到顶部。考虑下面的例子:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="e609" class="ls lt in lo b gy lu lv l lw lx">getCaffeinated(); // Latte<br/>functin getCaffeinated () {<br/>    console.log("Latte");<br/>};</span></pre><p id="82c1" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在这里，我们能够在声明之前调用函数，因为执行上下文在代码执行之前存储了整个函数。</p><p id="2b0a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><strong class="kb io">函数表达式</strong></p><p id="3df4" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">函数表达式不被提升:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="1f25" class="ls lt in lo b gy lu lv l lw lx">getCaffeinated(); // TypeError: getCaffeinated is not a function<br/>var getCaffeinated = function () {<br/>    console.log("Latte");<br/>}</span></pre><p id="3a14" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在这种情况下，我们无法调用该函数，因为在全局执行上下文的创建阶段，JavaScript引擎会在内存中创建<code class="fe ly lz ma lo b">getCaffeinated</code>变量，并使用<code class="fe ly lz ma lo b">undefined</code>对其进行初始化，因此当我们运行上述程序时，调用的<code class="fe ly lz ma lo b">getCaffeinated</code>不是函数，因此会出现类型错误。</p><p id="8455" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">请注意，在箭头函数的情况下，JavaScript引擎也会抛出与函数表达式相同的错误，因为箭头函数只是定义函数表达式的语法糖。</p><p id="243c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这是用JavaScript写的。非常感谢你花时间阅读这篇博客。👊🏻再见！</p><p id="2458" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><em class="ka">更多内容请看</em><strong class="kb io"><em class="ka"/></strong><a class="ae mb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ka">说白了。</em> </strong> <em class="ka">报名参加我们的</em><strong class="kb io"><em class="ka"/></strong></a><a class="ae mb" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="ka">免费每周简讯这里</em> </strong> </a> <strong class="kb io"> <em class="ka">。</em>T45】</strong></p></div></div>    
</body>
</html>