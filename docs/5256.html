<html>
<head>
<title>Use Headless Chrome and Docker to run GPU Computations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Headless Chrome和Docker运行GPU计算</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/visit-websites-without-opening-the-browser-9ee3cf18abdd?source=collection_archive---------5-----------------------#2021-10-26">https://javascript.plainenglish.io/visit-websites-without-opening-the-browser-9ee3cf18abdd?source=collection_archive---------5-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb7e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用headless Chrome、简单JavaScript和Docker容器与网站交互。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9aa080344af676d38a062229d2e3ef17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B0SswuDMCh7ObeV-"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kevnbhagat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Bhagat</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="11a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能需要以编程方式访问某个网站。出于不同的原因，它可能会有所帮助。这里有几个例子:</p><ol class=""><li id="4576" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">快速准确地测试网站的行为，无需手动刷新或检查。您可以自动化与网站的交互，如按钮点击、表单提交、UI测试等。</li><li id="ea31" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">收集服务器端渲染图。</li><li id="d4f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">生成网站截图。</li><li id="9974" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">测试chrome扩展。</li><li id="5f37" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将这个过程集成到您的测试管道中。使用Selenium和Cypress之类的测试框架可能不会有问题。</li><li id="925e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">以编程方式对浏览器进行更精细的控制；例如，强制GPU用于图形计算，启用不同的渲染器，绘制扩展等。</li><li id="64a7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">根据网站UI内容制作工具。</li></ol><p id="16b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个设置有三个主要部分:puppeteer，一个非强制的docker容器，以及您想要访问的网站。</p><p id="00b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用Nvidia Tesla GPU在Ubuntu 20.04上测试了以下代码。</p><h1 id="3ea9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">操纵木偶的人</h1><blockquote class="my mz na"><p id="fd64" class="kw kx nb ky b kz la jr lb lc ld ju le nc lg lh li nd lk ll lm ne lo lp lq lr ij bi translated"><em class="iq">puppet er是一个节点库，它提供了一个高级API来控制Chrome或通过</em> <a class="ae kv" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> DevTools协议</em> </a> <em class="iq">的Chrome。木偶师默认运行</em> <a class="ae kv" href="https://developers.google.com/web/updates/2017/04/headless-chrome" rel="noopener ugc nofollow" target="_blank"> <em class="iq">无头</em> </a> <em class="iq">，但可以配置为运行全(无头)铬或铬。</em></p></blockquote><p id="67e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是包含木偶师并定义所需的参数。</p><p id="829b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保使用无头选项。请注意，目前在Mac上，即使在headless模式下，它也会启动一个实例，然后很快隐藏它，因此在该平台上的性能是有问题的。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="5573" class="nk mh iq ng b gy nl nm l nn no">--headless</span></pre><p id="982b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择GPU进程应该使用哪个GL也很重要。选项包括:</p><ul class=""><li id="3517" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><strong class="ky ir">桌面</strong>:用户已经安装的任何桌面OpenGL(Linux和Mac默认)。</li><li id="5be5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir"> egl </strong>:用户安装的任何EGL/gles 2(Windows默认——实际角度)。</li><li id="1126" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">swift shader</strong>:swift shader软件渲染程序。</li></ul><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="d8d9" class="nk mh iq ng b gy nl nm l nn no">--use-gl=egl</span></pre><p id="efe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是对所有可能选项的精彩描述:<a class="ae kv" href="https://peter.sh/experiments/chromium-command-line-switches/" rel="noopener ugc nofollow" target="_blank">https://Peter . sh/experiments/chromium-command-line-switches/</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/90e53d717d28b14b0527a324beaa338c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5iGSMnHI1-PzEKcg.png"/></div></figure><p id="ff3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建设置时，一个有用的步骤是将控制台日志从web应用程序重定向到puppeteer标准输出。如下图所示，page对象可以通过挂钩控制台、页面错误流等进行重定向。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/813b0e618da3ed5a06b3f4bd2caa7f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fBn5ts9C91yPns0C.png"/></div></figure><p id="a4a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，您可以使用下面的函数访问一组默认参数。确保检查它们，如果某些内容对您的设置无效，请覆盖它们。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="4833" class="nk mh iq ng b gy nl nm l nn no">puppeteer.defaultArgs()</span></pre><p id="0b1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后您可以使用<em class="nb"> launch </em>函数启动puppeteer并传递参数。返回的对象是浏览器的句柄。</p><p id="b2be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用浏览器句柄，您可以开始与网站进行交互。几个常见的步骤是在浏览器中打开一个新页面，使用<em class="nb"> newpage </em>函数获得一个新的页面对象。页面对象具有用于访问网站的<em class="nb"> goto </em>功能。</p><p id="e60c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用页面句柄上的函数进行异步交互，例如<em class="nb"> waitforNavigation </em>，它会一直等到页面刷新。</p><p id="6fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，别忘了使用<em class="nb"> browser.close() </em>关闭浏览器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/110a55ff16e159419ceda5dda4a7bbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OnUgCW3W_MEQ_QfE.png"/></div></figure><h1 id="ef48" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">码头工人</h1><p id="1e5e" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">一个重要的任务是将Nvidia驱动程序暴露给Docker容器。我发现最简单的方法是将您的容器基于Nvidia open GL映像，例如:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="eabe" class="nk mh iq ng b gy nl nm l nn no">nvidia/opengl:1.2-glvnd-devel-ubuntu20.04</span></pre><p id="3aac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码如下。确保安装所有的chrome依赖项。你不需要在系统范围内单独安装Chrome，因为木偶师包下载了一个兼容的Chrome二进制文件。但我认为安装Chrome更容易获得所有的依赖项。此外，您需要安装可能与下面不同的任何附加依赖项。我安装了基本的Unix工具、字体、节点、npm等。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="4489" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">前端服务器</h1><p id="8497" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">一旦你设置好木偶和码头，你可以访问任何网站。一个例子是你的网站呈现一些用户界面。您可以访问该网站，并从您的JavaScript脚本舒适的截图:)</p><p id="0656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的HTML创建了一个简单的三JS场景并渲染了一些着色器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本地主机服务器上提供服务后访问网站的代码非常简单:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="d5c9" class="nk mh iq ng b gy nl nm l nn no">const page = await browser.newPage(); <br/>await page.goto(pagePath); <br/>await page.screenshot({path: outputName + '.png'}); <br/>await page.pdf({path: outputName + '.pdf'})</span></pre><p id="37a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在GPU上同时运行64个木偶师实例并捕获网站内容，取得了相当好的性能。docker和puppeteer选项可能会进一步优化以加快渲染速度，但可能会过于特定于内容。</p><p id="c699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nb">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>