<html>
<head>
<title>React Native Navigational Child Component Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本机导航子组件更新</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-navigational-child-component-updates-767ab3199238?source=collection_archive---------14-----------------------#2021-01-18">https://javascript.plainenglish.io/react-native-navigational-child-component-updates-767ab3199238?source=collection_archive---------14-----------------------#2021-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3fe9697f9e58f54ffcfb05ac348675d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8PwcXv1b1ma5XLFn"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c64e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">“犯错是人之常情，真正把事情搞砸需要电脑”</h1><p id="ae74" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">哦，千真万确。虽然React在概念上看起来很简单，但它处理的是一个状态模型，需要我们在头脑中拥有多个状态机。把状态放在不同的地方并把它搞砸实在是太容易了——然后你会发现为什么。</p><p id="dd4e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在为我的孩子创建一个故事应用程序时，我遇到了一个有趣的问题。</p><p id="7af5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">它在整个故事中运行得很好——但是我无法通过父组件重置故事。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/f755e79ac72fd2a5a09987557ea52b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/1*R-wVxXwRXlj2N246dVrI3w.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Looks great — but the last screen…. is the end of another book.</figcaption></figure><h2 id="62d9" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">我有3个组件</h2><ul class=""><li id="2d1f" class="ms mt in la b lb lc lf lg lj mu ln mv lr mw lv mx my mz na bi translated">故事屏幕—以卡片形式保存故事列表。</li><li id="a62a" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">位置屏幕—这表示处理位置容器的滚动视图。</li><li id="7fc5" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">位置—显示该特定位置的选项、文本和其他信息的实际组件。</li></ul><p id="f7b9" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">流程如下所示:</p><ol class=""><li id="7db1" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv nj my mz na bi translated">位置屏幕:位置ID: 0 +故事ID: 0</li><li id="ef87" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv nj my mz na bi translated">位置:LocationID: 0 + StoryID: 0</li></ol><p id="2a99" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">到目前为止，一切都很好！</p><p id="ce06" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这些是作为道具传入的。</p><p id="1c85" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是，单击其中一个按钮，会显示以下内容:位置:位置ID: 0 +故事ID: 0</p><p id="31da" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是因为我们使用state来触发LocationsID的刷新—我不想构建导航链或历史。</p><p id="52cd" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">到目前为止，一切顺利。位置组件会不断更新自己，直到我们用尽故事，没有地方可去。</p><p id="3744" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">点击不同的故事，显示如下:</p><ol class=""><li id="9c59" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv nj my mz na bi translated">位置屏幕:位置ID: 0 +故事ID: 1</li><li id="1448" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv nj my mz na bi translated">位置:LocationID: 0 + StoryID: 1</li></ol><p id="bf5d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这…看起来是正确的—新故事的位置0(1，而不是旧的0)。</p><p id="1cb8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">但是，我们显示的不是位置0，而是位置2，也就是我们结束上一个故事的位置。</p><p id="e608" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在是时候看看代码了——原因应该很明显:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b098" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个功能组件的中间有两个React挂钩。第一个存储locationID，第二个存储storyID。</p><p id="1cf4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">第4行——Location id——被设置为传递到组件位置的默认值。</p><p id="b7b4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">根据状态挂钩，以下是正确的:</p><ul class=""><li id="7ca2" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv mx my mz na bi translated">当一个组件被安装时，钩子对象(curLocation)被初始化为一个值。</li><li id="905d" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">如果该值已经初始化，则不会重新初始化。</li></ul><p id="e67f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">稍微改变一下我们的图案，我们可以看到:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="31fa" class="mg kb in nn b gy nr ns l nt nu">Location: LocationID: 0 + StoryID: 1 + curLocation: 1</span></pre><p id="c7bb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是我们上一本书的curLocation值。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="ea63" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">本质上，这意味着我们需要解决一个用例——用户需要能够改变到一个新的故事。想一想，我认为我们应该只在用户从我们的故事屏幕上点击“阅读”时重新开始一本书，这是一个不同的故事。如果他们在同一个故事上点击阅读，我们应该从他们停止的地方继续他们正在阅读的故事，就像他们使用了“当前故事”导航项目一样。</p><p id="e27c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我意识到这意味着用户需要在开始一个新的故事之前完成故事中的一条路径，但就目前而言，我认为这是最简单的方法。也许以后我会改变主意。:)</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="5ce5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">因此，这意味着我们需要触发一个父组件(故事屏幕)来告诉较低级别的组件(位置屏幕)更改默认位置。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="9a4d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我的第一次尝试是将这段代码插入位置屏幕:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="8ac5" class="mg kb in nn b gy nr ns l nt nu">if (curStory !== storyID) {<br/>   setLocation(locationID);<br/>   setStory(storyID);<br/>    console.log(‘Resetting Story ID to ‘ + storyID);<br/>}</span></pre><p id="7d72" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这一次运行代码时，我们可以看到以下输出:</p><ul class=""><li id="60ce" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv mx my mz na bi translated">将文章ID重置为1</li></ul><p id="d472" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">好——这正是我们想要看到的。</p><p id="eb33" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">代码工作正常——任何时候我们使用同一本书，我们都使用我们在书中最后知道的位置。每当我们加载不同的书，我们使用一个新的位置1。</p><p id="ac96" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我不喜欢这个解决方案，但它确实有效。我不喜欢它，因为它迫使我们在Locations组件中添加代码来跟踪状态。我更喜欢:</p><ol class=""><li id="e0d8" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv nj my mz na bi translated">从顶层组件设置故事和位置</li><li id="c45e" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv nj my mz na bi translated">或者在我有新的故事要处理时卸载位置组件。</li></ol></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="c854" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们继续努力，看看我们能做些什么不同的事情…</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="7bf3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">首先，让我们添加一点代码来告诉我们组件是否被挂载。这将使用React Native的“useEffect”挂钩。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0b61" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这会打印出以下消息:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="4512" class="mg kb in nn b gy nr ns l nt nu">Location:IN MOUNT: LocationID: 0 + StoryID: 1 + curLocation: 0</span></pre><p id="d918" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们有了，让我们用另一种方法来研究。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="a712" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">React中的组件使用一个键来确定更改、添加或删除了什么项目。它们看起来像道具，但不会传递给组件——而是作为一种提示方式，提示对以后的组件更改做出反应。</p><p id="c2e5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">使用数组索引并不被认为是好的做法——但是我们这里有storyID。将来，我可能会考虑使用“nanoID()”直接与故事进行深度链接。不过，我们将在另一篇文章中讨论这个问题。</p><p id="6ddc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">首先，让我们修改我们的use effect——只在组件的初始安装或卸载时打印。这模仿了componentDidMount和componentWillUnmount的React类方法。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="db75" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">这里发生了两件事</h2><ol class=""><li id="ca9b" class="ms mt in la b lb lc lf lg lj mu ln mv lr mw lv nj my mz na bi translated">我们在这段代码中添加了一个新的返回——该函数将在组件清理之前运行。</li><li id="0c04" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv nj my mz na bi translated">我们将空数组[]添加到依赖项列表中。这意味着这种效果不依赖于任何变量的改变，因此我们应该只在挂载和卸载时运行，而不是在每次渲染后运行</li></ol><p id="653a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在运行它，结果如下:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="aecc" class="mg kb in nn b gy nr ns l nt nu">LocationScreen: LocationID: 0 + StoryID: 0<br/>Location: LocationID: 0 + StoryID: 0 + curLocation: 0<br/>Location:IN MOUNT: LocationID: 0 + StoryID: 0 + curLocation: 0<br/>Location: LocationID: 0 + StoryID: 0 + curLocation: 2<br/>LocationScreen: LocationID: 0 + StoryID: 1<br/>Location: LocationID: 0 + StoryID: 1 + curLocation: 2</span></pre><p id="4e90" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">注意StoryID是如何改变的，但是curLocation没有被重置？此外，以前的位置组件没有被拆除。那就是b\c React不知道这个位置和其他任何位置都不一样。</p><p id="462c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们继续将关键字添加到位置:</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="378e" class="mg kb in nn b gy nr ns l nt nu">&lt;Location<br/>    jsondata={route.params.story.locations}<br/>    locationID={route.params.locationID}<br/>    storyID={route.params.storyID}<br/>    key={route.params.storyID}<br/>/&gt;</span></pre><p id="4ea0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这样，我们可以看到curLocation，我们的状态值，在组件被安装时被保存，在我们改变故事后被重置。</p><pre class="mc md me mf gt nm nn no np aw nq bi"><span id="d491" class="mg kb in nn b gy nr ns l nt nu">Location: LocationID: 0 + StoryID: 0 + curLocation: 1<br/>LocationScreen: LocationID: 0 + StoryID: 1<br/>Location: CleaningUP<br/>Location:IN MOUNT:        LocationID: 0 + StoryID: 1 + curLocation: 0</span></pre><p id="170c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这是一个简单得多的解决方案。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="2971" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们也可以选择用另一个使用效果来做这件事:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="40a4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当“storyID”更新时，该事件被触发，并被传递到函数中。</p><p id="d9d4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当storyID更改时，这个新效果会触发，并重置位置状态。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h2 id="6c17" class="mg kb in bd kc mh mi dn kg mj mk dp kk lj ml mm ko ln mn mo ks lr mp mq kw mr bi translated">实现该功能的另外两种方法</h2><ol class=""><li id="f6a2" class="ms mt in la b lb lc lf lg lj mu ln mv lr mw lv nj my mz na bi translated">使用“useRef”钩子——这将允许我进入位置组件，并调用resetLocation，或者任何我想要的特定函数。这本来可以很好地工作，除了感觉完全没有必要——为什么我的父组件需要调用子组件的函数？</li><li id="95a2" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv nj my mz na bi translated">将位置和故事放在上下文提供者中。现在对我来说，这感觉有点过了，但是这并不是不可能的——以后当我想支持状态保存和恢复、深度链接等时，我可能会需要它。</li></ol><p id="6008" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里可以看到更多的方法:<a class="ae jz" href="https://itnext.io/changing-children-state-from-another-component-with-react-hooks-5c982c042e8" rel="noopener ugc nofollow" target="_blank">https://it next . io/changing-children-state-from-other-component-with-react-hooks-5c 982 c 042 e 8</a></p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="93ff" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">目前，我选择了“key”方法——这是最简单、最直接的方法。它让React负责设置和管理组件初始化，并确保我的用例正确工作。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="c0d7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">参考文献:</strong></p><ul class=""><li id="4083" class="ms mt in la b lb lw lf lx lj ng ln nh lr ni lv mx my mz na bi translated">React Hook eslint插件——你会想要的！【https://www.npmjs.com/package/eslint-plugin-react-hooks T4】</li><li id="4401" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-effect.html</a></li><li id="8a16" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/hooks-FAQ . html # how-do-life cycle-methods-comment-to-hooks</a></li><li id="8c7c" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://medium.com/@albertogasparin/forcing-state-reset-on-a-react-component-by-using-the-key-prop-14b36cd7448e" rel="noopener">https://medium . com/@ albertogasparin/forcing-state-reset-on-a-react-component-by-using-the-key-prop-14b 36 CD 7448 e</a></li><li id="b64b" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://stackoverflow.com/questions/39556753/how-to-reset-child-elements-state" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/39556753/how-to-reset-child-elements-state</a></li><li id="f875" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-state.html</a></li><li id="66aa" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">https://robinpokorny . medium . com/index-as-a-key-is-an-anti-pattern-e 0349 aece 318</a></li><li id="b93d" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://kentcdodds.com/blog/understanding-reacts-key-prop" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog/understanding-reacts-key-prop</a></li><li id="237a" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/re conciliation . html # recursing-on-children</a></li><li id="8956" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><a class="ae jz" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/forwarding-refs.html</a></li><li id="3a1d" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">https://reactjs.org/docs/hooks-reference.html<a class="ae jz" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="ba2a" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">【https://reactjs.org/docs/lists-and-keys.html T4】</li></ul></div></div>    
</body>
</html>