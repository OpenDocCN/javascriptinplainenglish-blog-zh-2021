<html>
<head>
<title>Angular Unit Testing Series - Episode #2: Introduction to Angular Unit Testing w/ Jasmine &amp; ts-mocking-bird</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度单元测试系列——第2集:Jasmine &amp; ts-mocking-bird角度单元测试介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-angular-unit-testing-w-jasmine-ts-mocking-bird-3475a1d906e7?source=collection_archive---------7-----------------------#2021-10-13">https://javascript.plainenglish.io/introduction-to-angular-unit-testing-w-jasmine-ts-mocking-bird-3475a1d906e7?source=collection_archive---------7-----------------------#2021-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6a67" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">测试角度服务</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ddf64924c290005c8926206838260eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PE-tBuQcwObvgrJIsxuj2Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">serviceable mock wing</figcaption></figure><p id="d594" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本系列的前一集中，我们使用Angular CLI创建了一个样本Angular项目。但是，需要对其进行验证和确认，以确保代码按预期运行。随着应用程序的规模和复杂性的增长，这是一种扩展应用程序的好方法。</p><p id="01ec" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这篇文章旨在提供一个角度单元测试的介绍，并带你一步一步地为我们的<a class="ae lo" href="https://github.com/pkErbynn/demystify/tree/9368cc50d5d0acb5389b2f862726b7ccf1c78d91" rel="noopener ugc nofollow" target="_blank"> <em class="lp">非角度应用程序</em> </a> <em class="lp">编写单元测试。</em></p><p id="21e6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="lp">我们所期待的:</em> </strong></p><p id="c9a7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lp">使用Jasmine和ts-mocking-bird对用户服务文件的每一行进行测试，在下面的浏览中报告或显示。</em></p><p id="2d7c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lp">项目代码库状态:</em> <a class="ae lo" href="https://github.com/pkErbynn/demystify/tree/abc2114e514cefeba548d22d4e3b95efe47583da" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> GitHub链接</em> </a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/66fe0e055ee7244d7ad3622f5163f282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6elR_MSFiBPe0R0dbYH5Pg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">user service test results (using ts-mocking-bird &amp; Jasmine)</figcaption></figure><p id="7d9e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在本文结束时，您应该能够；</p><ul class=""><li id="14e0" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln lw lx ly lz bi translated">理解什么是单元测试以及它为什么重要</li><li id="8ab8" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">介绍可用的角度测试工具(Jasmine、Karma、ts-mocking-bird)</li><li id="49ca" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">设置、配置和运行角度单位测试</li><li id="185e" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">了解如何构建测试规范文件</li><li id="b4fd" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">使用模拟和间谍测试服务返回的可观察性</li><li id="33c3" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">使用Jasmine和ts-mocking-bird库发送HTTP请求的测试服务</li></ul><p id="7df3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们摇滚吧…</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="4990" class="mm mn in bd mo mp mq mr ms mt mu mv mw jt mx ju my jw mz jx na jz nb ka nc nd bi translated">概观</h1><h2 id="17ac" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated">什么是单元测试？</h2><p id="7670" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">单元测试已经成为现代软件开发过程中不可或缺的一部分，它确保了一个质量至上的可靠的工程环境。</p><blockquote class="nv nw nx"><p id="fb1e" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated">单元测试是一个软件开发过程，在这个过程中，一个应用程序的最小的可测试部分，称为<strong class="ku io">单元</strong>，被单独和独立地仔细检查以确保正确的操作。来源:<a class="ae lo" href="https://searchsoftwarequality.techtarget.com/definition/unit-testing" rel="noopener ugc nofollow" target="_blank">https://searchsoftwarequality.techtarget.com</a></p></blockquote><p id="3a49" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">强烈建议在实现过程的早期编写单元测试，因为它有助于检测代码中的早期缺陷，而这些缺陷在测试过程的后期可能更难检测。单元测试可以手动完成，但通常是自动化的。</p><h2 id="8ca1" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated">为什么要进行单元测试？</h2><p id="5d57" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">单元测试…</p><ul class=""><li id="ba49" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln lw lx ly lz bi translated">改进实现的设计。</li><li id="925b" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">允许信任重构(对代码更改无罪)。</li><li id="d904" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">在不破坏任何东西的情况下推广新功能。</li><li id="4993" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">有助于在发布软件之前发现缺陷/错误。</li><li id="7915" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated">通过确保所有代码在部署前符合质量标准，节省时间和金钱。</li></ul><h1 id="90f8" class="mm mn in bd mo mp ob mr ms mt oc mv mw jt od ju my jw oe jx na jz of ka nc nd bi translated">角度测试工具</h1><p id="3e0b" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">Angular应用程序可以用几种兼容的测试工具进行测试，包括Karma、Jasmine、Mocha、ts-mocking-bird、Siesta等等。在我们的例子中，我们将关注Karma、Jasmine和ts-mock-bird工具。</p><p id="8b5a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">想知道茉莉、因果报应和ts-mock-bird之间的区别吗？在使用这些框架之前，让我们对它们如何工作和相互联系有一个高层次的概述。</p><h2 id="c8f3" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated"><strong class="ak">茉莉</strong>Vs<strong class="ak">ts-嘲鸟Vs因果</strong></h2><p id="b959" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated"><a class="ae lo" href="https://jasmine.github.io/pages/docs_home.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> <em class="lp">茉莉</em> </strong> </a>是一个<strong class="ku io">框架</strong>编写的测试。它支持测试DOM相关的代码。其他种类的Javascript测试框架包括QUnit、Mocha等。</p><blockquote class="nv nw nx"><p id="373e" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated">Jasmine是一个行为驱动的开发框架，用于测试JavaScript代码。它不依赖于任何其他JavaScript框架。— <a class="ae lo" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank">茉莉doc </a></p></blockquote><p id="f17b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://morganstanley.github.io/ts-mocking-bird/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lp">ts-mock-bird</em></strong></a><strong class="ku io"><em class="lp"/></strong>是一个与Jasmine一起工作的<strong class="ku io"> <em class="lp"> </em> </strong>全类型安全嘲讽库。尽管Jasmine有一个内置的<em class="lp"> spyOn() </em>库，可以模仿或删除任何确定的代码片段，但ts-mocking-bird可以用于替换或并列使用。但是，ts-mocking-bird不支持DOM相关的测试。</p><p id="4d83" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://karma-runner.github.io/latest/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lp">Karma</em></strong></a>是一个命令行工具，运行测试并在命令行和浏览器中显示报告。它从浏览器加载测试文件、运行并向命令行报告测试结果。Karma观察开发文件的变化并自动重新运行测试。它开箱后带有棱角。</p><p id="21fa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">与Jasmine和ts-mock-bird不同，Karma不是一个测试框架，而是一个<strong class="ku io">测试运行器</strong>(它依赖于<em class="lp"> node.js) </em>来运行我们用Jasmine或ts-mock-bird编写的测试。大多数情况下，Jasmine和Karma一起使用来执行Angular中的测试。</p><h1 id="e4ba" class="mm mn in bd mo mp ob mr ms mt oc mv mw jt od ju my jw oe jx na jz of ka nc nd bi translated">安装<code class="fe og oh oi oj b">morgan-stanley/ts-mocking-bird library</code></h1><p id="78c4" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">现在我们已经理解了一些核心概念，让我们继续安装我们的工具。</p><p id="8f0d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Angular CLI与<a class="ae lo" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>捆绑在一起，用于测试Angular应用程序，而ts-mock-bird是一个外部库，需要使用以下命令安装；</p><pre class="kd ke kf kg gt ok oj ol om aw on bi"><span id="33c5" class="ne mn in oj b gy oo op l oq or">$ npm install @morgan-stanley/ts-mocking-bird</span></pre><p id="89e1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一旦安装完成，你的<code class="fe og oh oi oj b">package.json</code><em class="lp"/>就应该将库添加到<em class="lp"> </em> <code class="fe og oh oi oj b">dependencies</code> <em class="lp"> </em>块中，就像这样；</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/5a91ffd838ca51f0bd6becc9c03a51c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXrLGZCme14F9yf2uXW8bw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">package.json after installation</figcaption></figure><h1 id="51a4" class="mm mn in bd mo mp ob mr ms mt oc mv mw jt od ju my jw oe jx na jz of ka nc nd bi translated">开始运行服务测试</h1><p id="01c0" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">当您使用<a class="ae lo" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>创建组件、服务等时，默认情况下，除了创建主代码文件，它还会创建一个简单的Jasmine spec文件，以<code class="fe og oh oi oj b">.spec.ts</code>结尾。</p><p id="e94f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我们的用户服务中，这将创建两个文件:</p><ul class=""><li id="3ad6" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln lw lx ly lz bi translated"><code class="fe og oh oi oj b">user.service.ts</code> —这是主代码文件，我们将服务的代码实现放在这里。</li><li id="be5d" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><code class="fe og oh oi oj b">user.service<strong class="ku io">.spec.ts</strong></code> —这是服务的Jasmine测试套件。</li></ul><p id="a66c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lo" href="https://github.com/pkErbynn/demystify/blob/master/src/app/services/user.service.spec.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lp"> spec </em> </a>文件会有一些已经引导的代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4ec45fe529482a4269540c9b4b496885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*1aHeHsf0QgG_BQaaOLgfhg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">user-service.spec.ts</figcaption></figure><h2 id="e1bc" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated">运行我们的初始用户服务单元测试</h2><p id="644f" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">在项目目录的根目录下运行以下命令。这构建了我们的应用程序，然后运行Karma，它是我们的测试运行程序，显示测试报告(在CLI和浏览器中)。</p><pre class="kd ke kf kg gt ok oj ol om aw on bi"><span id="9375" class="ne mn in oj b gy oo op l oq or">$ ng test</span></pre><blockquote class="nv nw nx"><p id="9c24" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated"><strong class="ku io">注意:</strong>为了只运行我们的userService测试套件，让我们像这样在前面加上一个‘f’来集中注意力<code class="fe og oh oi oj b"><strong class="ku io">f</strong>describe(‘UserService’...</code>。如果花色或规格是重点，只有那些将被执行。</p><p id="6fdf" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated">顺便说一下，一个suit和spec可以通过在前面加上一个“x”来临时禁用(报告为待定和未执行)，分别是:<code class="fe og oh oi oj b"> <strong class="ku io">x</strong>describe(‘UserService’, ...) </code>和<code class="fe og oh oi oj b"> <strong class="ku io">xit</strong>(‘should be created’, ...) </code>。</p></blockquote><p id="e635" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">显然，您将从命令行和浏览器收到一个失败的测试结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/e6b1b33f5b2f781d5d04910e6f330990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzVE0POIf6IDe9SUbz0v4Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Failed test result from the command line</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/93f86b9751ff5b391caa2dd4260ffb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*derNH-9MEwbZTZNsy1F9aQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Failed test result from the browser</figcaption></figure><h1 id="3f40" class="mm mn in bd mo mp ob mr ms mt oc mv mw jt od ju my jw oe jx na jz of ka nc nd bi translated">重写我们的用户服务测试</h1><p id="8b1f" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">让我们重新编写我们的单元测试来修复Jasmine和ms-mocking-bird这两个测试框架中失败的服务测试。</p><p id="3444" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的用户服务实现包含at <code class="fe og oh oi oj b">getUsers()</code>方法来获取所有用户，并有一个<code class="fe og oh oi oj b">catchError</code>块来处理请求过程中可能出现的错误。</p><p id="1e05" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了测试<code class="fe og oh oi oj b">UserService</code>类，也就是我们正在测试的系统(SUT)，让我们考虑以下三个测试用例场景:</p><ol class=""><li id="fc99" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln ow lx ly lz bi translated">应该创建一个用户服务</li><li id="0145" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln ow lx ly lz bi translated">应该在成功时获取所有用户</li><li id="8c2a" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln ow lx ly lz bi translated">如果获取用户失败，应该抛出错误消息</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/83920538d38a4fd21ea49a04ad5b7a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uU8qRcVN9jwQFpUEJbzxjA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">user.service.ts (i.e. system under test)</figcaption></figure><h2 id="b2e8" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated"><strong class="ak">用户服务测试(使用Jasmine框架)</strong></h2><p id="a648" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">现在让我们利用Jasmine框架来测试我们的<code class="fe og oh oi oj b">UserService</code>类。用以下内容更新<code class="fe og oh oi oj b">user.service.spec.ts</code>文件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/88d9ac61c485697c5b769db001c035ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zx43LP5uujTnR2mop_bzzQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><code class="fe og oh oi oj b">user.service.spec.ts</code></figcaption></figure><p id="e2b7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们明白这是怎么回事…</p><ul class=""><li id="6923" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln lw lx ly lz bi translated"><strong class="ku io">第9行</strong> <code class="fe og oh oi oj b">describe('UserService', ...</code>:描述了一组相关的单独测试，因此称为<em class="lp">测试套件，</em>，包含三个测试规格。</li><li id="aabf" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io">行#13— #21 </strong> <code class="fe og oh oi oj b">beforeEach(()...</code>:它不仅在每个测试规格(<code class="fe og oh oi oj b">it(...</code>)的 <em class="lp">之前运行<em class="lp">，而且包含正确的配置(使用<code class="fe og oh oi oj b">TestBed</code>类)和所有必要的实例(#19 — #20)。它还提供了初始化服务所需的依赖关系。配置过程与普通<em class="lp">模块</em>相似。这称为<em class="lp">设置。</em>其他设置和拆卸方法包括<em class="lp"> </em> <code class="fe og oh oi oj b">beforeAll(), afterEach(), afterAll()</code>。</em></em></li><li id="5eea" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io">第23行</strong> <code class="fe og oh oi oj b">it('should ...</code>:定义一个单独的<em class="lp">测试规范。服务通过验证。</em>类似地<em class="lp">，</em>第27行和第40行分别描述了成功和失败的测试用例场景。</li><li id="de3b" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io"> line #32 </strong> <code class="fe og oh oi oj b">spyOn(httpClient ...</code>:用预期结果模拟http <code class="fe og oh oi oj b">get</code>依赖关系。</li><li id="f36c" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io"> line #34 </strong> <code class="fe og oh oi oj b">userService.getUsers().subscribe...</code>:订阅<code class="fe og oh oi oj b">getUsers</code>返回的可观察对象，所以发送(假)HTTP请求。调查响应<code class="fe og oh oi oj b">users</code>，以匹配预期响应。</li><li id="ecec" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io"> line #42 </strong> <code class="fe og oh oi oj b">spyOn(httpClient ...</code>:模拟调用http <code class="fe og oh oi oj b">get</code>时抛出的错误消息。</li></ul><p id="d202" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，保存并重新运行测试，您应该有一个成功的浏览器测试报告，如下所示。耶！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/d7ac08840a9952143e2f145304d46117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53_5eqGItcWyGOMxfmObUA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">browser success test report for User service</figcaption></figure><h2 id="e496" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated">用户服务测试(使用ms-ts-mocking-bird库)</h2><p id="32e4" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">或者，我们也可以使用ts-mocking-bird库测试我们的用户服务。让我们创建另一个名为<code class="fe og oh oi oj b">user.service.mocking-bird.spec.ts</code>的规范文件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/4f34cbda67af92ad5de131ec94f6a979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yL-ubpjkSXPeQF-jBOjBtQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">user.service.mocking-bird.spec.ts</figcaption></figure><p id="ff38" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们强调一下这里发生的关键事情…</p><ul class=""><li id="6e79" class="lr ls in ku b kv kw ky kz lb lt lf lu lj lv ln lw lx ly lz bi translated"><strong class="ku io">第8行</strong> <code class="fe og oh oi oj b">describe...</code>:将测试服描述为<code class="fe og oh oi oj b">UserService: MockingBird</code></li><li id="5d27" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io">行#20 — #22 </strong> <code class="fe og oh oi oj b">mockHttp = Mock.create&lt;HttpClient&gt;...</code>:模仿<code class="fe og oh oi oj b">HttpClient</code>依赖关系(用<code class="fe og oh oi oj b">get()</code>方法)并初始化声明的<code class="fe og oh oi oj b">mockHttp</code>。</li><li id="7b14" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io"> line #24 </strong> <code class="fe og oh oi oj b">userService = new ...</code>:创建一个<code class="fe og oh oi oj b">UserService </code>的实例，将所需的模拟依赖项作为参数传递给它。</li><li id="a6ff" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io">行#27 — #29 </strong> <code class="fe og oh oi oj b">it(‘should ...’)</code> : <strong class="ku io"> </strong>验证用户服务及其依赖项创建成功。</li><li id="b5be" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io"> line #34 </strong> <code class="fe og oh oi oj b">expect(mockHttp.withFuntion ...</code>:验证<code class="fe og oh oi oj b">get()</code>方法只使用正确的url调用一次。</li><li id="9223" class="lr ls in ku b kv ma ky mb lb mc lf md lj me ln lw lx ly lz bi translated"><strong class="ku io">第45行— #47 </strong> <code class="fe og oh oi oj b">mockHttp = mockHttp.setup...</code>:用模拟错误响应覆盖http <code class="fe og oh oi oj b">get()</code>方法。</li></ul><blockquote class="nv nw nx"><p id="6f0c" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated"><strong class="ku io">注意:</strong>当Jasmine使用<code class="fe og oh oi oj b">spy()</code>库模仿类方法时，ts-mock-bird除了使用<code class="fe og oh oi oj b">Mock</code>库之外还使用了<code class="fe og oh oi oj b">setupFunction</code>。</p></blockquote><p id="d66c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果一切顺利，您会看到这样一个成功的结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/66fe0e055ee7244d7ad3622f5163f282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6elR_MSFiBPe0R0dbYH5Pg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">all user service tests result</figcaption></figure><h2 id="60c0" class="ne mn in bd mo nf ng dn ms nh ni dp mw lb nj nk my lf nl nm na lj nn no nc np bi translated">结论</h2><p id="9b0d" class="pw-post-body-paragraph ks kt in ku b kv nq jo kx ky nr jr la lb ns ld le lf nt lh li lj nu ll lm ln ig bi translated">这篇文章展示了Jasmine和mock-bird，它们是在Angular web应用程序中执行服务单元测试的强大工具。在我看来，与Jasmine相比，ts-mock-bird提供了一个类型安全且干净的模仿系统。</p><p id="d048" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我希望这篇文章对你有用。请随时<em class="lp">鼓掌</em>，<em class="lp">关注</em>或发送评论、反馈和问题:)</p><p id="f7f2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">项目代码库状态:<a class="ae lo" href="https://github.com/pkErbynn/demystify/tree/abc2114e514cefeba548d22d4e3b95efe47583da" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a></p><p id="b643" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">“T”表示感谢！</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><blockquote class="nv nw nx"><p id="4e1e" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated">下一篇文章:</p><p id="78d3" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated"><a class="ae lo" href="https://medium.com/nerd-for-tech/angular-unit-testing-series-episode-3-component-testing-w-jasmine-2ed25082558f?source=friends_link&amp;sk=344737eebdffa73b8aa2ceb569839919" rel="noopener"> <strong class="ku io">角度单元测试系列-第3集:测试带Jasmine的角度组件</strong> </a></p><p id="61da" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated">前一篇文章:</p><p id="c93e" class="ks kt lp ku b kv kw jo kx ky kz jr la ny lc ld le nz lg lh li oa lk ll lm ln ig bi translated"><a class="ae lo" href="https://pkerbynn.medium.com/angular-unit-testing-series-episode-1-getting-started-5ec86d645525" rel="noopener"> <strong class="ku io">【角度单元测试系列-第一集:入门(设置样本角度项目)</strong> </a></p></blockquote></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="8206" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lp">更多内容请看</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ku io"><em class="lp">plain English . io</em></strong></a></p></div></div>    
</body>
</html>