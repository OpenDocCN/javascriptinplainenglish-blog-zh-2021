<html>
<head>
<title>Mocking JavaScript Modules in a Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在浏览器中嘲笑JavaScript模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-and-mocking-javascript-modules-in-browser-ae9fc333ee5d?source=collection_archive---------15-----------------------#2021-06-17">https://javascript.plainenglish.io/testing-and-mocking-javascript-modules-in-browser-ae9fc333ee5d?source=collection_archive---------15-----------------------#2021-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e518" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在浏览器中测试简化了web应用程序的开发。但是如何在浏览器中模拟模块依赖呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/169ba9a92d76512304f4ef5cfb1b9e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77QKU2FJgk7H5siOVWwr4g.png"/></div></div></figure><p id="7eb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在浏览器中测试可以节省时间，尤其是在原型开发期间。对于不复杂的模块，例如与用户界面相关的模块，可以完成代码，然后编写测试。</p><p id="fb50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是想象一个执行复杂计算的模块。例如，一个模块，它将一些复杂的统计数据转换并聚合成可以绘制在图表中的简单数据。在开发复杂的计算过程中，你无法在头脑中完成，大量的调试是不可避免的，因此频繁的测试是必不可少的。</p><p id="fe81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">碰巧的是，必须对模块进行模拟，以便于甚至可能对导入它们的模块进行测试。嘲笑的典型目标是从REST资源中获取数据的模块。他们返回的数据可能因每个请求而异。此外，根据应用程序的不同，提取的数据可能会很大，需要花费大量时间进行加载和处理。</p><p id="22cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果被测试的代码与任何可能需要时间并引入随机性的外部资源分离，那么解释和调试测试就更容易了。在模拟模块中<code class="fe ln lo lp lq b">fetch</code>调用被一些恒定的数据代替，以确保在测试期间父模块总是接收到相同的输入，该输入应该导致相同的输出。</p><h1 id="87f5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">用提取调用模拟模块</h1><p id="2710" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">想象一个模块，它对庞大且难以辨认的输入数据进行难以想象的复杂计算，并产生简单的输出，最终显示给用户。在本文中，我将使用一个很小的示例模块<em class="mo"> userView.js. </em>来模拟这样一个模块。假设它将用户配置文件数据转换为仪表板的一个组件:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="39f1" class="mt ls iq lq b gy mu mv l mw mx">// userView.js<br/>import { getUser } from "shared/dataSource.js";</span><span id="c281" class="mt ls iq lq b gy my mv l mw mx">export default async function getHomeView() {<br/>    const user = await getUser();<br/>    return `Hello ${user.name}`;<br/>}</span></pre><p id="8cc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了简单起见，对用户特定数据的所有想象中的复杂计算都用原始模板字符串<code class="fe ln lo lp lq b">`Hello ${user.name}`</code>代替，而庞大的用户档案数据则用微小的JSON <code class="fe ln lo lp lq b">{"name": "John"}</code>代替。模块<em class="mo"> userView.js </em>接收来自导入功能<code class="fe ln lo lp lq b">getUser()</code>的数据。<strong class="kt ir"> </strong>该功能从REST资源中获取数据:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="16a4" class="mt ls iq lq b gy mu mv l mw mx">// dataSource.js<br/>export function getUser() {<br/>    return fetch('api/user.json').then(response =&gt; response.json());<br/>}</span></pre><p id="78ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设从REST资源接收到的用户特定数据随每个请求而变化，如何测试<em class="mo"> userView.js </em>的输出？让我们从对<em class="mo"> userView.js </em>的一个简单测试开始:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="82ed" class="mt ls iq lq b gy mu mv l mw mx">// userViewTest.js<br/>import getHomeView from './userView.js';<br/> <br/>describe("homeView", function () {<br/>    it("returns some content, but irreproducible depending on REST resource", async function () {<br/>        const view=await getHomeView();<br/>       <strong class="lq ir"> expect(view).toBeDefined();</strong><br/>    });<br/>});</span></pre><p id="feb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于REST资源的响应内容不同，因此<code class="fe ln lo lp lq b">getHomeView()</code>返回的输出也不同，我只能检查模块是否产生了什么东西<code class="fe ln lo lp lq b">expect(view).toBeDefined()</code>。但是我不知道到底是什么产生的。</p><p id="5d1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完美的测试应该进行全面彻底的检查:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="7fab" class="mt ls iq lq b gy mu mv l mw mx">// userViewWithMockTest.js<br/>import getHomeView from './userView.js';<br/> <br/>describe("homeView", function () {<br/>    it("expected output of complex calculations", async function() {<br/>        const view=await getHomeView();<br/>        <strong class="lq ir">expect(view).toBe('Hello Mock');</strong><br/>    });<br/>});</span></pre><p id="06ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使上面的完美测试可用，导入的函数<code class="fe ln lo lp lq b">getUser()</code> <strong class="kt ir"> </strong>必须返回常量数据<code class="fe ln lo lp lq b">{"name": "Mock"}</code>。为此，我编写了一个模拟模块<em class="mo"> dataSourceMock.js </em>，它将在测试期间替代模块<em class="mo"> dataSource.js </em>。被模仿的模块不会<code class="fe ln lo lp lq b">fetch</code>，相反，它会返回一个解析为常量值的<code class="fe ln lo lp lq b">Promise</code>。</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="7b2c" class="mt ls iq lq b gy mu mv l mw mx">// dataSourceMock.js<br/>export function getUser() {<br/>    return Promise.resolve({"name":"Mock"});<br/>}</span></pre><p id="f913" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在测试期间用它的mock替换原来的模块，我添加了一个导入映射到Jasmine的<em class="mo">SpecRunner.html</em>中:</p><pre class="kg kh ki kj gt mp lq mq mr aw ms bi"><span id="19ee" class="mt ls iq lq b gy mu mv l mw mx">&lt;script type="importmap"&gt;<br/>    {<br/>        "imports": {<br/>            "shared/dataSource.js":"./js/shared/dataSourceMock.js"<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="e9fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">导入映射指示浏览器如何将测试模块<em class="mo"> userView.js </em>的语句<code class="fe ln lo lp lq b">import { getUser } from "shared/dataSource.js";</code>中包含的模块名解析为实际的URL。现在，当浏览器遇到名称<code class="fe ln lo lp lq b">shared/dataSource.js</code>时，它导入<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/live-bindings-difference-between-export-default-and-export-as-default-4541c354cdaa">被模仿模块<code class="fe ln lo lp lq b">dataSourceMock.js</code>的绑定</a>。</p><p id="4ab9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管没有其他方法来模拟浏览器中的模块，但是测试并不是导入映射的主要用例。<a class="ae mz" href="https://marian-caikovski.medium.com/remapping-javascript-module-names-with-import-maps-bd2bad121c1d" rel="noopener">导入地图是支持JavaScript模块的特性。</a>没有导入映射，JavaScript模块很难在浏览器中使用，因为它们的<code class="fe ln lo lp lq b">import</code>相对URL可能很长，并且充满了双点。至少与非原生模块系统AMD相比，原生模块看起来很有缺陷。</p><p id="3410" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章的完整源代码可以从<a class="ae mz" href="https://github.com/marianc000/ModuleMocks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载，并在浏览器中执行。</p><p id="44d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mo">更多内容请看</em><a class="ae mz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mo">plain English . io</em></a></p></div></div>    
</body>
</html>