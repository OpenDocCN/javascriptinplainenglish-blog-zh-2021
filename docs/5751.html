<html>
<head>
<title>I built a no-code alternative to Workbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我构建了一个替代Workbox的无代码版本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-built-a-no-code-alternative-to-workbox-27a0a484635?source=collection_archive---------4-----------------------#2021-12-06">https://javascript.plainenglish.io/i-built-a-no-code-alternative-to-workbox-27a0a484635?source=collection_archive---------4-----------------------#2021-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5557" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这个缓存策略生成器是我开发过的最难的产品</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fa21d92321ce802c5aaa5f168f595508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NylIdGY7cylTCffxU3QezQ.png"/></div></div></figure><p id="3189" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">几天前，我们终于发布了一个令人兴奋的新<a class="ae lk" href="https://progressier.com" rel="noopener ugc nofollow" target="_blank"> Progressier </a>功能，自从我们发布测试版以来，我们的客户一直在不懈地要求这个功能。</p><p id="62dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了我们的<a class="ae lk" href="https://progressier.com/dashboard/caching-strategies" rel="noopener ugc nofollow" target="_blank">缓存策略生成器</a>，任何拥有web应用的人都可以轻松配置缓存策略——通过切换和下拉，而不是复杂的<a class="ae lk" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank"> regex </a>和硬编码的<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">服务工人</a>。</p><h1 id="7209" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">为什么我应该关心缓存策略？</h1><p id="0748" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">默认情况下，浏览器倾向于通过<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP缓存</a>机制缓存不可预测的资源。您几乎无法控制如何缓存和更新资源。</p><p id="950d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">取而代之的是服务工作者中可用的<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存接口</a>，您可以非常精确地定义如何获取、缓存和刷新每种类型的资源。</p><p id="fa46" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">借助正确的策略，您可以:</p><ol class=""><li id="2bb3" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">使您的应用程序脱机工作</li><li id="17c8" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">缩短加载时间</li><li id="e84c" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">保持关键资源新鲜，而不必使用<a class="ae lk" href="https://css-tricks.com/strategies-for-cache-busting-css/#query-strings" rel="noopener ugc nofollow" target="_blank">版本控制技巧</a></li><li id="f7ab" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">降低您的服务器成本</li></ol><p id="c6fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">理论上很酷。在实践中？没那么容易。今年早些时候，谷歌几乎给每个网络应用开发者下了最后通牒:要么让你的应用离线工作，要么失去安装功能。当他们放弃这个计划时，我假设让一个网站离线工作比大多数人想象的要困难。</p><p id="ab74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2021年，大多数开发人员使用<a class="ae lk" href="https://developers.google.com/web/tools/workbox" rel="noopener ugc nofollow" target="_blank">工具箱</a>——一个JavaScript库，它抽象了<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>和<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存API </a>。工具箱简化了事情…但是对我来说还不够简单。测试策略是一件麻烦的事。在服务人员中对URL列表进行硬编码并不能完全适应未来。规则的顺序可能会导致意想不到的行为。并且编写Regex是一个众所周知的令人头疼的事情。</p><h1 id="b02c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">缓存是一个雷区</h1><p id="c5f5" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>、<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request" rel="noopener ugc nofollow" target="_blank">预检请求</a>、<a class="ae lk" href="https://intercom.help/progressier/en/articles/5740926-how-to-deal-with-opaque-responses-in-service-workers" rel="noopener ugc nofollow" target="_blank">不透明响应</a>、<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank">缓存控制头</a> …这些是一些让缓存难以掌握的概念。它们是抽象的和有见解的——事实上大多数开发人员并不真正了解它们。</p><p id="c152" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以挑战是双重的。首先，如何构建一个通用的服务工作器来处理任何域和资源？第二——如何构建一个没有学习曲线的用户界面来适应这个<em class="mw">内在复杂的</em>过程？</p><p id="12c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">关键是每个人处理缓存的方式都是一样的——从<a class="ae lk" href="https://developers.google.com/web/tools/workbox" rel="noopener ugc nofollow" target="_blank">工具箱网站</a>或<a class="ae lk" href="https://developers.google.com/web/fundamentals/primers/service-workers" rel="noopener ugc nofollow" target="_blank">谷歌开发网站</a>复制粘贴代码片段，然后用自己的变量交换样本值。<a class="ae lk" href="https://progressier.com/" rel="noopener ugc nofollow" target="_blank"> Progressier </a>让您用切换和下拉来定义这些变量，而不是在您的服务人员中硬编码它们。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/1b4dbf8a25f250709a5a0cb3eea1b28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxu-m2RB6juLUQWqlWWz_w.jpeg"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Specify rules, choose a strategy, see matching resources, precache URLs, auto-retry them — all in one interface with inputs and toggles instead of code</figcaption></figure><p id="5252" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有一些看起来不一样的东西，在我们这个时代已经不再需要了。Progressier 简化这一过程的方法之一是自动屏蔽你。缓存到期日期就是一个很好的例子。</p><h1 id="ed57" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">缓存的现代观点</h1><p id="e2ee" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">你再也不用担心保质期了。因为不再需要缓存到期日期。这是一种使缓存资源无效的过时方法——让人回想起处理缓存的唯一方法是不可预测的<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank"> HTTP Cache </a>接口。</p><p id="f002" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了服务人员可用的<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存接口</a>，完全没有必要在任何地方设置过期日期。你现在对事情有了更好的控制:</p><ul class=""><li id="e891" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj nc mo mp mq bi translated">您可以通过完全不使用缓存(仅网络)来保持资源的系统性更新</li><li id="ba75" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">您可以保持资源的新鲜，但是当网络不可用时(网络优先)，您可以使用缓存的版本</li><li id="609b" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">您可以首先从缓存中获取资源以减少加载时间，但是每次都要系统地重新验证它们(Stale-while-Revalidate)</li><li id="485e" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">您可以从缓存中获取资源，并且永远不会重新验证它们，以降低服务器成本(缓存优先)</li></ul><h1 id="4a9d" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">简明英语中的缓存策略</h1><p id="3328" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">使用<a class="ae lk" href="https://progressier.com/" rel="noopener ugc nofollow" target="_blank"> Progressier </a>，您只需选择上面的一个策略，并选择将它应用于哪些资源。规则示例:</p><ul class=""><li id="9597" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj nc mo mp mq bi translated">"<em class="mw">将网络优先应用于来自cdn.whatever.com的所有资源"</em></li><li id="2b9e" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated"><em class="mw">“首先将缓存应用于所有字体文件”</em></li><li id="969e" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated"><em class="mw">“仅将网络应用于api.mydomain.com/very-important-data.json"</em></li><li id="0385" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated"><em class="mw">“对托管在我的域上的所有图像应用失效时重新验证”</em></li></ul><p id="f6d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为<a class="ae lk" href="https://progressier.com/" rel="noopener ugc nofollow" target="_blank"> Progressier </a>是一个无代码工具，你用简单的英语来指定这些规则——就像我上面做的那样。这可能看起来很无聊。但是如果两年后你必须修改它们，你会很高兴不用去破译一堆正则表达式。</p><p id="bdcb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你也可以想象每个策略如何拦截你的资源——因为规则可能会重叠。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/ef2be47930a34b4ff2b81a799b1e94d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0ptH67Z5lJKaizP7RgvUw.jpeg"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">A visual indicator tells you how many actual resources from your app match each of these strategies.</figcaption></figure><h1 id="b749" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">以及所有其他缓存功能</h1><p id="3e4a" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">缓存策略是让web应用离线工作的关键。要获得完整的离线体验，还必须了解一些其他机制。</p><p id="6780" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下是一些你可以在<a class="ae lk" href="https://progressier.com/" rel="noopener ugc nofollow" target="_blank"> Progressier </a>中点击几下就可以配置你的网络应用程序自动完成的事情:</p><ul class=""><li id="1c7c" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj nc mo mp mq bi translated"><a class="ae lk" href="https://intercom.help/progressier/en/articles/5746972-how-to-precache-resources-to-make-them-available-offline" rel="noopener ugc nofollow" target="_blank">离线时启动应用程序所需的预缓存资源</a></li><li id="43ba" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated"><a class="ae lk" href="https://intercom.help/progressier/en/articles/5741155-how-to-retry-a-post-request-later-when-offline" rel="noopener ugc nofollow" target="_blank">当网络连接丢失时，稍后重试失败的请求</a></li><li id="dc79" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">通过<a class="ae lk" href="https://intercom.help/progressier/en/articles/5732949-how-to-set-a-fallback-url-in-progressier" rel="noopener ugc nofollow" target="_blank">为重要资源提供后备URL</a>来建立冗余</li><li id="0832" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">覆盖阻止缓存的头(对于像<a class="ae lk" href="https://bubble.io/" rel="noopener ugc nofollow" target="_blank"> Bubble </a>这样的无代码构建器特别有用)。</li><li id="2665" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nc mo mp mq bi translated">显示一个<a class="ae lk" href="https://intercom.help/progressier/en/articles/5750252-how-to-display-an-offline-alert" rel="noopener ugc nofollow" target="_blank">离线提醒</a>来警告用户他们已经失去了网络连接</li></ul><h1 id="c448" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">简单很难</h1><p id="d261" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">史蒂夫·乔布斯说过“<em class="mw">简单可能比复杂更难:你必须努力让你的思维变得清晰，才能变得简单。但最终还是值得的，因为一旦你到了那里，你就可以移山倒海了。</em></p><p id="cf2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构建缓存策略生成器的用户界面可能是我曾经做过的最难最简单的事情。虽然Progressier肯定不会移山，但它确实让任何开发人员都可以实现缓存——无论他们是编写代码还是使用无代码构建器。如果这听起来很有趣，你可以在这里免费试用<a class="ae lk" href="https://progressier.com" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="860a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mw">更多内容请看</em> <a class="ae lk" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">说白了就是</em> </strong> </a> <strong class="kq io"> <em class="mw">。</em> </strong> <em class="mw">报名参加我们的</em> <a class="ae lk" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mw">免费每周简讯这里</em> </strong> </a> <strong class="kq io"> <em class="mw">。</em> </strong></p></div></div>    
</body>
</html>