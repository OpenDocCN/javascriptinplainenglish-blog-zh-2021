<html>
<head>
<title>Intro to React Component Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件测试简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-react-component-testing-cd42853c06d3?source=collection_archive---------7-----------------------#2021-03-19">https://javascript.plainenglish.io/intro-to-react-component-testing-cd42853c06d3?source=collection_archive---------7-----------------------#2021-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ffdd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">工具、标准和最佳实践</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4497771cc2dc2d15940290554da6428b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU89TcfRAR5mmclMX9x57w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae ks" href="/s/photos/checklist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="f9a8" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">拥抱测试的力量</h2><p id="9ff7" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">测试驱动开发是一种流行的实践，这是有原因的。在开始编写更多代码之前，通过为单个函数添加和运行测试，从一开始就将测试作为优先事项有助于避免将来引入难以发现的错误。</p><p id="3853" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">测试的标准流程很容易记住…安排、行动和断言。首先，安排代码(包括所需的道具或其他参数)，调用一个动作(单击一个按钮，给出虚假的用户输入等)。)，并做出断言(注入你的假设)。请记住，我们的目标是模拟该应用程序在生产中的使用方式。</p><h2 id="62cb" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">从哪里开始</h2><p id="e5bc" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在开始之前，请记住，我们不一定需要测试所有内容。这里有一些我们在构建测试文件时做的和不想关注的事情。</p><p id="f49a" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">务必为您已经创建的方法、隔离单元、条件输入和预期呈现编写测试。</p><p id="86ec" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">不要关注第三方库，复杂的连接比如React props是否传递给孩子，或者不影响最终用户功能的东西比如全局变量。</p><p id="9a86" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">总是用标准的约定命名你的测试文件:file_name_here.test.js。否则，当你运行你的应用程序的测试脚本时，它将不知道测试文件在哪里。</p><p id="39fb" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">当您想要运行一个单独的测试时(假设您已经安装了必要的库)，只需键入yarn或npm test，后跟文件名。</p><h2 id="d042" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">单元、集成和电子对电子</h2><p id="153f" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">有3种通用类型的测试:单元测试、集成测试和端到端测试。</p><p id="f1bc" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">编写单元测试是为了验证小块代码的预期功能。这些用于单一方法。</p><p id="e432" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">集成测试旨在检查应用程序的不同部分(或组件)是否如预期的那样协同工作。</p><p id="fa18" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">端到端测试将较小的单元测试和集成测试封装成一个在模拟浏览器中进行的大型测试。例如，您可以使用E-to-E测试，从收集用户查询数据库或API的输入开始，查看用户是否得到了正确的身份验证。</p><h2 id="90ed" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">测试React组件的常用工具</h2><p id="522a" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">React自带测试库，方便地称为React-Testing-Library。它因一些有用的内置方法而受到称赞，如afterEach(cleanup ),该方法在测试和查询getByText等方法后卸载组件。另一个主要卖点是，我们可以使用像useReducer这样的挂钩，它在使用actions和Reducer时测试组件的行为，并使用Context测试子组件是否可以更新其父组件的上下文状态。</p><p id="f7fc" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">另一个广泛使用的测试程序是Jest。如果您使用create-react-app，它可能已经在您的package.json文件中了。然而，Jest不仅仅局限于反应。这是一个JavaScript测试框架，可用于Babel、Angular、Vue等。</p><p id="cfc6" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">我们还需要一些测试实用程序，让我们能够将组件安装到一个假DOM上，并对它们进行遍历。最流行的工具是酶。它基于React的DOM渲染器来测试模拟DOM中的各个组件。它还允许我们包装对象并将它们打印到控制台，以便更深入地了解我们的功能中正在发生的事情。</p><h2 id="bcf3" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">快照测试</h2><p id="6662" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我们可以用酶做的事情之一是实现快照测试。这些测试允许我们看到一个组件自从我们上次测试以来是如何变化的。第一次运行它时，会自动生成一个snapshots_folder和test.js文件，其中包含被测试函数的快照，以便将来进行比较。</p><p id="8276" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">如果有问题的代码完全没有变化，我们只能通过测试。失败时，结果将包含“差异”以显示哪些代码行发生了更改。如果由于某种已知的原因，被测试的代码发生了更改，您可以从命令行键入-u标志来更新快照。</p><p id="608c" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">一些人认为这种类型的测试应该谨慎对待，因为如果函数调用中有拼写错误或者CSS类被重新命名，它可能会对功能完整的应用程序产生假阴性。所以要注意这些情况。</p><h2 id="1e9c" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">浅与安装</h2><p id="83a0" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在单元测试中，很容易看到关键字shallow。这就是我们如何明确声明我们只想测试有问题的组件，而忽略它的任何子组件。这有助于利用隔离测试的原则。</p><p id="b06d" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">Mount通常用于集成测试，有点像shallow的反义词。在这种情况下，我们会仔细检查组件的子组件，并希望在模拟浏览器中执行被测试的代码。但是，不会有真实的渲染。</p><p id="0521" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">请记住，使用挂载的测试确实运行得较慢，因为您运行的是一个几乎完全没有UI的实时应用程序。在这种情况下，您需要在运行这个测试之后包含一个卸载或清理的方法。</p><h2 id="00b5" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">嘲弄的</h2><p id="4930" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">当我们谈到模拟一个真实的应用程序时，是时候引入模拟测试，也就是“间谍”了。这些是测试API请求的好方法。</p><p id="3647" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">测试这个功能可能是至关重要的，但是发出一个真正的API请求会降低我们的测试速度，并且可能会导致我们的数据库被意外操纵。使用模拟函数，我们可以在测试环境中调用API，而无需实现函数的实际逻辑。</p><h2 id="acff" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">工装连体服</h2><p id="ad08" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">在部署之前，一般目标是测试80–100%的代码。在进行了一些测试之后，您可能想知道在被覆盖的代码量中是否还有缺口。这就是工作服派上用场的地方。</p><p id="a2f7" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">Coveralls生成一个报告，显示当前正在测试的应用程序的百分比。超级好用。你只需注册，将它同步到你的GitHub账户，然后在“添加回购”标签中搜索你的回购名称就可以打开它。</p><p id="64eb" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">通过将cypress和coverage标志添加到package.json文件中的脚本，将repo配置为使用连体工作服:</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="6505" class="kt ku in mo b gy ms mt l mu mv">"cypress": "node_modules/.bin/cypress open,<br/>"test": "react-scripts test --coverage"</span></pre><h2 id="52e5" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">新找到的自信</h2><p id="14ba" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">测试增强了您对应用程序的信心，并通过发现错误显示了改进的机会，从而防止了进一步的复杂化。它们提供了对正在运行的进程的更透明的观察。刚开始可能会有点吓人，但是在确认你的假设后，你会对你的工作质量感觉好很多。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h2 id="6805" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">深潜</h2><p id="e854" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我强烈建议阅读上面提到的库和工具的文档。以下是一些有助于入门的资源…<br/><a class="ae ks" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank">https://github.com/testing-library/react-testing-library</a><br/><a class="ae ks" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/</a><br/><a class="ae ks" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">https://enzymejs.github.io/enzyme/</a><br/><a class="ae ks" href="https://www.npmjs.com/package/@wojtekmaj/enzyme-adapter-react-17" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ wojtekmaj/enzyme-adapter-react-17</a><br/><a class="ae ks" href="https://kentcdodds.com/blog?q=testing" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog?q=testing</a><br/><a class="ae ks" href="https://www.freecodecamp.org/news/testing-react-hooks/" rel="noopener ugc nofollow" target="_blank">https://www.freecodecamp.org/news/testing-react-hooks/</a><br/><a class="ae ks" href="https://medium.com/@wyattsweet/testing-react-components-using-the-new-context-api-a1c553edc2fa" rel="noopener">https://medium . com/@ wyattsweet/testing-react-components-using-the-the</a></p></div></div>    
</body>
</html>