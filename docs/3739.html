<html>
<head>
<title>Start Using Optional Chaining and Nullish Coalescing in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中开始使用可选的链接和无效合并</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/start-using-optional-chaining-and-nullish-coalescing-in-react-322bdf24b78c?source=collection_archive---------4-----------------------#2021-07-27">https://javascript.plainenglish.io/start-using-optional-chaining-and-nullish-coalescing-in-react-322bdf24b78c?source=collection_archive---------4-----------------------#2021-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f86" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在React中使用nullish合并和可选链接并使您的代码库更上一层楼所需要知道的一切。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c84569711dd5c85036f236d0b701cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fnfzVKmQBbHlpXUX"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自从我开始在React中开发以来，我注意到大多数在线代码片段和教程是如何避免可选的链接操作符以及nullish合并操作符的。虽然它们是相当新的创新，但已经有一年多的历史了。</p><p id="bd61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我认为这背后的原因是缺乏关于它们是什么，如何开始使用它们，如何使用，为什么使用以及何时使用的教育。让我们试着解决所有这些问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9127" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">它们是什么</h1><p id="6798" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们根据<a class="ae kv" href="https://en.wikipedia.org/wiki/MDN_Web_Docs" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>来看看可选的链接操作符和nullish合并操作符的定义。</p><h2 id="16da" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a></h2><blockquote class="ni nj nk"><p id="28fc" class="kw kx nl ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated">可选的链接操作符(<code class="fe np nq nr ns b"><strong class="ky ir">?.</strong></code>)使您能够读取一个位于连接对象链深处的属性值，而不必检查链中的每个引用是否有效。</p><p id="b138" class="kw kx nl ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated"><code class="fe np nq nr ns b">?.</code>操作符类似于<code class="fe np nq nr ns b">.</code>链接操作符，除了当引用为<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish" rel="noopener ugc nofollow" target="_blank"> nullish </a> ( <code class="fe np nq nr ns b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>或<code class="fe np nq nr ns b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a></code>)时，表达式不会导致错误，而是用返回值<code class="fe np nq nr ns b">undefined</code>短路。当用于函数调用时，如果给定的函数不存在，则返回<code class="fe np nq nr ns b">undefined</code>。— <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><h2 id="139f" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank">无效合并</a></h2><blockquote class="ni nj nk"><p id="2bbe" class="kw kx nl ky b kz la jr lb lc ld ju le nm lg lh li nn lk ll lm no lo lp lq lr ij bi translated"><strong class="ky ir">无效合并运算符(</strong> <code class="fe np nq nr ns b"><strong class="ky ir">??</strong></code> <strong class="ky ir"> ) </strong>是一个逻辑运算符，当其左侧操作数为<code class="fe np nq nr ns b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>或<code class="fe np nq nr ns b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a></code>时，返回其右侧操作数，否则返回其左侧操作数。— <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9e79" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何启用它们</h1><p id="d9d8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这两个操作符都正式发布了<a class="ae kv" href="https://262.ecma-international.org/11.0/" rel="noopener ugc nofollow" target="_blank"> ECMA-262第11版</a> JavaScript语言规范。因为这些都是相当新的特性，所以只有React的某些版本支持它们。</p><p id="2ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用它们，必须满足以下要求:</p><ul class=""><li id="46a4" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><a class="ae kv" href="https://babeljs.io/blog/2020/01/11/7.8.0" rel="noopener ugc nofollow" target="_blank">巴别塔≥ 7.8.0 </a></li><li id="de03" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><a class="ae kv" href="https://github.com/facebook/create-react-app/blob/main/CHANGELOG-3.x.md#330-2019-12-04" rel="noopener ugc nofollow" target="_blank">创建React App ≥ 3.3.0 </a></li></ul><p id="b0f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，TypeScript开发者要求<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank"> TypeScript ≥ 3.7 </a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6a05" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何使用它们</h1><p id="7c98" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们看看使用这两个操作符所需的语法。</p><h2 id="47dd" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">可选链接</h2><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="b6b2" class="mw ma iq ns b gy ol om l on oo">obj.val?.prop // default use<br/>obj.val?.[expr] // <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining#optional_chaining_with_expressions" rel="noopener ugc nofollow" target="_blank">optional chaining with expressions</a><br/>obj.arr?.[index] // <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining#array_item_access_with_optional_chaining" rel="noopener ugc nofollow" target="_blank">array item access with optional chaining</a><br/>obj.func?.(args) // <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining#optional_chaining_with_function_calls" rel="noopener ugc nofollow" target="_blank">optional chaining with function calls</a></span></pre><h2 id="c945" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">无效合并</h2><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="a160" class="mw ma iq ns b gy ol om l on oo">leftExpr ?? rightExpr // default use</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0401" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么以及何时使用它们</h1><p id="56ce" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们看看为什么JavaScript引入了这两个操作符，以及何时应该使用它们来利用它们的优势。</p><h2 id="13ed" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">可选链接</h2><p id="4530" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在用JavaScript开发时，您经常需要从树状结构中访问深度嵌套的属性。常见的解决方案是编写一个长长的属性访问链。问题是，如果链中的任何中间引用是<code class="fe np nq nr ns b">null</code>或<code class="fe np nq nr ns b">undefined</code>，JavaScript将抛出一个<code class="fe np nq nr ns b"><em class="nl">TypeError: Cannot read property ‘name’ of undefined</em></code>错误。</p><p id="7d57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您可能最终会编写自定义逻辑来避免这种情况发生。这段代码不仅难看，还会降低代码库的可读性。这就是引入可选链接操作符的原因。</p><p id="1190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在可选链接之前，您必须编写如下代码:</p><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="36e9" class="mw ma iq ns b gy ol om l on oo">if (obj &amp;&amp; object.property1 &amp;&amp; object.property1.property2)<br/>   object.property1.property2.toLowerCase();</span></pre><p id="1058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过可选的链接，您可以用一行更简洁、可读性更好的代码实现相同的结果:</p><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="5f89" class="mw ma iq ns b gy ol om l on oo">obj.property1?.property2.toLowerCase()</span></pre><p id="0413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个简单的例子，但是你可以在这里找到更深入的指南。</p><p id="82ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，记住可选的链接操作符只对声明的变量有效。如果没有<code class="fe np nq nr ns b">obj</code>变量，那么就会抛出一个<code class="fe np nq nr ns b">ReferenceError</code>错误。</p><p id="93c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您应该只对可选属性和变量使用<code class="fe np nq nr ns b">?.</code>。这意味着如果根据你的编码逻辑<code class="fe np nq nr ns b">obj</code>变量必须存在，但是<code class="fe np nq nr ns b">property1</code>属性是可选的，你应该写<code class="fe np nq nr ns b">obj.property1?.property2</code>。</p><h2 id="b979" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">无效合并</h2><p id="926b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当您需要一个变量有一个默认值时，您可以考虑使用OR运算符(<code class="fe np nq nr ns b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR" rel="noopener ugc nofollow" target="_blank">||</a></code>)，如下所示:</p><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="d9a0" class="mw ma iq ns b gy ol om l on oo">let value;<br/>let defaultValue = value || 'Hello World!';</span></pre><p id="e53f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会变成一个很难发现的错误。实际上，<code class="fe np nq nr ns b">||</code>是一个布尔逻辑运算符。因此，在求值期间，左边的操作数会自动转换为布尔值。这意味着，如果左侧操作数是任何JavaScript <em class="nl"> falsy </em>值(<code class="fe np nq nr ns b">0</code>、<code class="fe np nq nr ns b">''</code>、<code class="fe np nq nr ns b">NaN</code>、<code class="fe np nq nr ns b">null</code>、<code class="fe np nq nr ns b">undefined</code>)，则不会返回默认值。</p><p id="a4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引入nullish合并运算符是为了解决这个问题。事实上，它通过仅在第一个操作数计算为<code class="fe np nq nr ns b">null</code>或<code class="fe np nq nr ns b">undefined</code>时返回第二个操作数(但没有其他<em class="nl"> falsy </em>值)来避免这个缺陷:</p><pre class="kg kh ki kj gt oh ns oi oj aw ok bi"><span id="36ea" class="mw ma iq ns b gy ol om l on oo">const nullValue = null;<br/>const emptyText = ""; // falsy<br/>const aNumber = 42;<br/><br/>const val1 = nullValue ?? "Default Value 1";<br/>const val2 = emptyText ?? "Default Value 2";<br/>const val3 = aNumber ?? 0;<br/><br/>console.log(val1); // "Default Value 1"<br/>console.log(val2); // "" (as the empty string is not null or undefined)<br/>console.log(val3); // 42</span></pre><p id="9139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个简单的例子，但是你可以在这里找到更深入的指南<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator#examples" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6f88" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">奖金</h1><p id="b972" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可能还对以下内容感兴趣:</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/avoid-the-fear-of-refactoring-with-absolute-imports-in-react-804bce61dc31"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">避免对React中绝对导入的重构的恐惧</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在React中使用绝对路径别名使导入易于重构</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://betterprogramming.pub/how-to-avoid-bottlenecks-in-node-js-applications-8085d86b6b2e" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">如何避免Node.js应用程序中的瓶颈</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">配置Sequelize和Mongoose来处理并发的数据密集型请求</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kp os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://codeburst.io/avoiding-code-duplication-by-adding-an-api-requests-definition-layer-in-javascript-6e5d7b409896" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">通过在JavaScript中添加API层来避免代码重复</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">使用基于Promise的HTTP客户端构建API层</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">codeburst.io</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg kp os"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bd81" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="2c53" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">今天我们看了什么是可选的链接和无效合并操作符，如何使用它们，为什么和在哪里使用。尽管它们在一年前就在JavaScript中引入了，但许多开发人员仍然没有尝试过它们。这是因为它们仍然是一个相当新奇的事物，需要通过教育来了解开始采用它们所需的一切，而这正是本文的目的。</p><p id="ba4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望这篇文章对你有所帮助。请随意留下任何问题、评论或建议。</p><p id="bb87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nl">更多内容看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="nl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>