<html>
<head>
<title>React 18 Alpha Release: 6 Must-Know New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18 Alpha版本:6个必须知道的新功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-18-alpha-release-6-must-know-new-features-8c0a33dea6ae?source=collection_archive---------5-----------------------#2021-06-29">https://javascript.plainenglish.io/react-18-alpha-release-6-must-know-new-features-8c0a33dea6ae?source=collection_archive---------5-----------------------#2021-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">React</figcaption></figure><p id="9145" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">React核心团队最近发布了React 18的alpha版本。这个版本更关注用户体验和内部架构的变化，包括对并发特性的适应。</em></p><p id="a9a8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以使用以下工具立即安装React 18:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c363" class="lh li in ld b gy lj lk l ll lm">npm install react@alpha</span></pre><p id="a315" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">和ReactDOM，</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e0d7" class="lh li in ld b gy lj lk l ll lm">npm install react-dom@alpha</span></pre><p id="5bcd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">有什么新消息？</strong></p><h1 id="b156" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1.新的根API</h1><p id="1946" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">我们通常会创建一个这样的根级DOM，并附加React应用程序。这现在已经被废弃，现在被称为“遗留根API”。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b8d3" class="lh li in ld b gy lj lk l ll lm">import React from 'react';<br/>import ReactDOM from 'react-dom';</span><span id="db50" class="lh li in ld b gy mp lk l ll lm">const container = document.getElementById('root') </span><span id="890e" class="lh li in ld b gy mp lk l ll lm">ReactDOM.render(&lt;App /&gt;, container);</span></pre><p id="584f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">相反，React18中引入了一个新的<code class="fe mq mr ms ld b">Root API</code>,如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7ba7" class="lh li in ld b gy lj lk l ll lm">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from 'App'</span><span id="edf8" class="lh li in ld b gy mp lk l ll lm">const container = document.getEleementById('root')</span><span id="221b" class="lh li in ld b gy mp lk l ll lm">const root = ReactDOM.createRoot(container)</span><span id="f456" class="lh li in ld b gy mp lk l ll lm">root.render(&lt;App /&gt;)</span></pre><p id="344e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">React 18将同时搭载<code class="fe mq mr ms ld b">Legacy Root API</code>和<code class="fe mq mr ms ld b">New Root API</code>，以保持应用从React 17(或更老版本)到React 18的平稳过渡。</p><p id="dd2d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">在传统根API上使用新的根API </strong></p><p id="33b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">新的Root API有很多改进:</p><p id="d326" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">答:易于使用的水合物函数，因为我们可以将可选的布尔值直接传递给根。</strong></p><p id="3260" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">传统根API: </strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9309" class="lh li in ld b gy lj lk l ll lm">import ReactDOM from 'react-dom'<br/>import App from 'App'</span><span id="87e1" class="lh li in ld b gy mp lk l ll lm">const container = document.getElementById('app');</span><span id="deba" class="lh li in ld b gy mp lk l ll lm">ReactDOM.hydrate(&lt;App /&gt;, container)</span></pre><p id="d5d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">新的根API: </strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8e7a" class="lh li in ld b gy lj lk l ll lm">import ReactDOM from ‘react-dom’;<br/>import App from 'App';</span><span id="31e5" class="lh li in ld b gy mp lk l ll lm">const container = document.getElementById('root');</span><span id="28ab" class="lh li in ld b gy mp lk l ll lm">const root = ReactDOM.createRoot(container, { hydrate: true });</span><span id="f49a" class="lh li in ld b gy mp lk l ll lm">root.render(&lt;App /&gt;);</span></pre><p id="f2be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击阅读更多关于水合作用<a class="ae mt" href="https://stackoverflow.com/questions/46516395/whats-the-difference-between-hydrate-and-render-in-react-16" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="9e78" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> b .渲染回调的改进:</strong></p><p id="a103" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在遗留的根API中，我们可以传递一个渲染回调函数。这是一个匿名函数，在挂载根组件后呈现/运行。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0149" class="lh li in ld b gy lj lk l ll lm">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from 'App'</span><span id="f4c8" class="lh li in ld b gy mp lk l ll lm">const container = document.getElementById('root')</span><span id="3c76" class="lh li in ld b gy mp lk l ll lm">ReactDOM.render(&lt;App /&gt;, container, function(){<br/>    console.log('render only after initial component rendering')<br/>})</span><span id="4cac" class="lh li in ld b gy mp lk l ll lm">console.log('render at very last')</span></pre><p id="cfa1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种方法在新的根API中有所改变。React团队建议不要使用回调，而是使用<code class="fe mq mr ms ld b">requestIdleCallback</code>甚至本地<code class="fe mq mr ms ld b">setTimeout</code>。</p><h1 id="6eb2" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">2.startTransition API</h1><p id="9e14" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">这是这个版本中引入的一个新API，它有助于保持当前网页的响应性，同时能够进行大量的非阻塞UI更新。</p><p id="d755" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mq mr ms ld b">startTransition</code>的一个重要用例可能是当用户开始在搜索框中键入时。输入值必须立即更新，而搜索结果可能会等待几毫秒(如用户所预期的)。</p><p id="7fb9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个API提供了区分快速更新和延迟更新的方法。</p><p id="f279" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">延迟的更新(即，从一个UI视图到另一个的转换)被称为<strong class="kb io">转换更新</strong>。</p><p id="80d8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于像打字、悬停、点击这样的紧急更新，我们称之为道具/功能，通常是这样的:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8e62" class="lh li in ld b gy lj lk l ll lm">setText(input)</span></pre><p id="3f82" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于非紧急或繁重的UI更新，我们可以将其包装在一个<code class="fe mq mr ms ld b">startTransition</code> API中，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="65f8" class="lh li in ld b gy lj lk l ll lm">startTransition(() =&gt; {</span><span id="009f" class="lh li in ld b gy mp lk l ll lm">  setText(input);</span><span id="0ba2" class="lh li in ld b gy mp lk l ll lm">});</span></pre><h1 id="92ca" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">3.严格效果进入严格模式</h1><p id="112a" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">React18现在将和<code class="fe mq mr ms ld b">Strict Effects</code>模式一起发售<code class="fe mq mr ms ld b">&lt;StrictMode /&gt;</code>。就像严格模式一样，这将用于开发构建和改进的DX。</p><p id="24b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当组件被包装在<code class="fe mq mr ms ld b">Strict Effects</code>中时，React将确保“有意”运行副作用两次，以检测异常行为/模式，这通常是使用<code class="fe mq mr ms ld b">useEffect</code>安装和清理功能时的一个痛点。</p><p id="81e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">运行两次效果有点像:<em class="kx">mount-&gt;unmount-&gt;mount</em></p><h1 id="9bcf" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">4.SSR改进</h1><p id="488e" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">服务器端渲染(SSR)在这个版本中得到了架构上的革新，包括首次加载屏幕时间的改进。</p><p id="2f97" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在以前的版本(直到React 17)中，SSR必须先加载整个页面，然后才能开始对页面进行水合处理。</p><p id="e16e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这在反应堆18中发生了变化。现在我们可以使用<code class="fe mq mr ms ld b">&lt;Suspense /&gt;</code>将React组件分成更小的块。</p><p id="6f29" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个现在叫做<code class="fe mq mr ms ld b">selective hydration</code>。</p><p id="208b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设我们在屏幕上有4 - 5个不同的组件。现在封装一个组件将会在代码加载后开始合并这个特定的组件，并且不会阻塞页面的其余部分。</p><p id="c536" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过这种策略，页面中更重要的部分/组件可以首先变得交互(在极慢的连接下)，而其他组件将继续保持良好的用户体验。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="30ed" class="lh li in ld b gy lj lk l ll lm">&lt;Layout&gt;<br/>  &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;<br/>    &lt;DelayedComponent /&gt;<br/>  &lt;Suspense /&gt;<br/>&lt;Layout /&gt;</span></pre><p id="79c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这里，<code class="fe mq mr ms ld b">&lt;Delayed /&gt;</code>组件将不会被解析，直到数据被获取。到那时，组件将回落到<code class="fe mq mr ms ld b">&lt;LoadingSpinner /&gt;</code>。</p><p id="7dc7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以使用<code class="fe mq mr ms ld b">&lt;Suspense /&gt;</code>让几个组件在不同时间获取数据，保持重要组件的交互。</p><h1 id="ad32" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">5.悬念列表</h1><p id="e748" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">React 18的另一个并发特性，它“编排”了大量数据提取组件在屏幕上出现的顺序。</p><p id="bcdf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一个<code class="fe mq mr ms ld b">&lt;SuspenseList /&gt;</code>用值forward、backward或together接受<code class="fe mq mr ms ld b">revealOrder</code> prop。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="49da" class="lh li in ld b gy lj lk l ll lm">&lt;SuspenseList revealOrder="forwards"&gt;<br/>  &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;<br/>    &lt;CardComponent id={1} /&gt;<br/>  &lt;/Suspense&gt;<br/>  &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;<br/>    &lt;CardComponent id={2} /&gt;<br/>  &lt;/Suspense&gt;<br/> &lt;/SuspenseList&gt;</span></pre><p id="6b4b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里，卡组件将向前显示(直到获取数据，将退回到LoadingSpinner组件)。类似地，<code class="fe mq mr ms ld b">backwards</code>会以相反的顺序显示卡片，而together道具会“一起”渲染所有东西</p><h1 id="eb26" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">6.useDeferredValue</h1><p id="cc63" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated"><code class="fe mq mr ms ld b">useDeferredValue</code>接受一个状态值，一个以毫秒为单位的超时，并返回该值的“延迟版本”。该值滞后于提供的超时秒数。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="edf5" class="lh li in ld b gy lj lk l ll lm">const deferredValue = useDeferredValue(value, { timeoutMs: 3000 });</span></pre><p id="4512" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这可能是文本输入字段的一个用例。文本输入会立即呈现在屏幕上。然而，<code class="fe mq mr ms ld b">&lt;CardLists /&gt;</code>文本属性接收一个<code class="fe mq mr ms ld b">useDeferredValue</code>并返回一个滞后3秒的<code class="fe mq mr ms ld b">defferedText</code>。</p><p id="d470" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这导致延迟了卡片列表组件，同时仍然允许用户让文本字段感觉很快。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="15cf" class="lh li in ld b gy lj lk l ll lm">function App() {<br/>  const [text, setText] = useState("");<br/>  const deferredText = useDeferredValue(text, { timeoutMs: 2000 }); </span><span id="9703" class="lh li in ld b gy mp lk l ll lm">  return (<br/>    &lt;div className="App"&gt;<br/>    &lt;input value={text} onChange={handleChange} /&gt;</span><span id="f7f8" class="lh li in ld b gy mp lk l ll lm">      &lt;CardLists text={deferredText} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/> }</span></pre><h1 id="7ad3" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">包扎</h1><p id="143a" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">React 18主要是关于并发特性，而不是一个成熟的并发模式(从React 16开始，这个模式已经被大肆宣传了)。这样做的原因是应用程序和库的作者可以有一个平稳的过渡，而不是任何突破性的变化。</p><p id="6187" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">React 18目前是alpha版本，不适合量产。因此，API可能会不断发展，直到它在今年年底(预计)达到稳定版本。</p><p id="aa84" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们关于React 18的帖子到此结束。</p><h2 id="efcc" class="lh li in bd lo mu mv dn ls mw mx dp lw kk my mz ma ko na nb me ks nc nd mi ne bi translated">我长期以来收集的一些重要资源:</h2><ol class=""><li id="1cba" class="nf ng in kb b kc mk kg ml kk nh ko ni ks nj kw nk nl nm nn bi translated"><a class="ae mt" href="https://chan.dev/posts/concurrent-mode-is-dead/" rel="noopener ugc nofollow" target="_blank">https://chan.dev/posts/concurrent-mode-is-dead/</a></li><li id="7c87" class="nf ng in kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">https://dev.to/cassidoo/react-18-alpha-is-out-now-what-2apj<a class="ae mt" href="https://dev.to/cassidoo/react-18-alpha-is-out-now-what-2apj" rel="noopener ugc nofollow" target="_blank"/></li><li id="adfe" class="nf ng in kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated">【https://github.com/reactwg/react-18/discussions/4 T4】</li><li id="05b8" class="nf ng in kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated"><a class="ae mt" href="https://github.com/reactwg/react-18/discussions/37" rel="noopener ugc nofollow" target="_blank">https://github.com/reactwg/react-18/discussions/37</a></li><li id="0dcd" class="nf ng in kb b kc no kg np kk nq ko nr ks ns kw nk nl nm nn bi translated"><a class="ae mt" href="https://javascript.works-hub.com/learn/react-18-is-here-whats-new-9b46a?utm_source=dev_to&amp;utm_medium=blog_xpost" rel="noopener ugc nofollow" target="_blank">https://JavaScript . works-hub . com/learn/react-18-is-here-what-new-9b46a？UTM _ source = dev _ to&amp;UTM _ medium = blog _ xpost</a></li></ol></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="6b03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">希望你喜欢这篇文章！</p><p id="beae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">更多内容请看</em><a class="ae mt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>