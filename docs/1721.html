<html>
<head>
<title>The Ultimate Guide to JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的终极指南承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-ultimate-guide-to-javascript-promises-76f2df318ce8?source=collection_archive---------11-----------------------#2021-04-12">https://javascript.plainenglish.io/the-ultimate-guide-to-javascript-promises-76f2df318ce8?source=collection_archive---------11-----------------------#2021-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e1f5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">promise.all()、promise.any()、promise.race()和promise.allsettled()的区别</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9ed780e1cc12dd2c6267219b91c395c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjd1rBktK0a_dUHBFMGafw.jpeg"/></div></div></figure><p id="de9d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本教程中，我们将讨论所有的JavaScript承诺，它们的区别和它们的用例。</p><h1 id="1432" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">介绍</h1><p id="72bf" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">承诺是在JavaScript(ES6)中实现<code class="fe mh mi mj mk b">async</code>编程的一种方式。承诺将成为未来价值的容器。通俗地说，你在亚马逊上下单订购一件商品。下订单后，您会在邮箱中收到一张注明交付日期的收据。在这种情况下，收据代表您的订单将交付给您的承诺。收据就像容器或你订购物品的证明(未来价值)。</p><p id="4b3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于异步编程，JavaScript使用回调，但是使用回调有一个问题，那就是<code class="fe mh mi mj mk b"><strong class="kq io">callback hell</strong></code>。</p><p id="5865" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回调对于小的应用程序来说似乎是可以的。但是当涉及到有很多回调的复杂应用程序时，你开始有很多深度嵌套的回调函数，这些函数可能变得很难阅读、理解或管理。</p><p id="c9d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">回调地狱的一个例子</strong></p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="a028" class="mp ll in mk b gy mq mr l ms mt"><br/>func1(function(a){ <br/> func2(a, function(b){ <br/> func3(b, function(c){ <br/> … <br/> }); <br/> }); <br/>});<br/></span></pre><h2 id="8ff2" class="mp ll in bd lm mu mv dn lq mw mx dp lu kx my mz lw lb na nb ly lf nc nd ma ne bi translated">对救援的承诺</h2><p id="6694" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">当我们不确定分配的任务是否会完成时，承诺就产生了。Promise对象表示异步操作的最终完成(或失败)及其结果值。顾名思义，一个承诺要么遵守，要么打破。<br/>承诺总是处于以下状态之一:<br/> *履行:与承诺相关的动作成功。<br/> *拒绝:与承诺相关的行动失败。<br/> *待定:承诺仍处于待定状态，即尚未履行或拒绝。<br/> *已结算:承诺已履行或拒绝</p><p id="798e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">句法</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="54f9" class="mp ll in mk b gy mq mr l ms mt"><br/>const promise = new Promise((resolve,reject) =&gt; {….});<br/></span></pre><p id="a4ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例子</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="2b52" class="mp ll in mk b gy mq mr l ms mt"><br/>const myPromise = new Promise((resolve, reject) =&gt; { <br/> if (Math.random() &gt; 0) { <br/> resolve(‘Hello, I am positive number!’); <br/> } <br/> reject(new Error(‘I failed some times’)); <br/>})</span></pre><p id="ee10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我发表了一篇关于dev.to的文章</p><div class="nf ng gp gr nh ni"><a href="https://dev.to/faithfulojebiyi/new-features-in-ecmascript-2021-with-code-examples-302h" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">ECMAScript 2021中的新特性(带代码示例)</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在本教程中，我们将了解最新版本的ECMAScript 2021中可以使用的新功能…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">开发到</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw km ni"/></div></div></a></div><p id="247d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在那里我谈到了<code class="fe mh mi mj mk b">promise.any()</code>。有人问我JavaScript承诺之间的区别。所以我在这里用另一篇文章来澄清你可能对JavaScript承诺的各种实现的任何困惑。</p><h2 id="7cf4" class="mp ll in bd lm mu mv dn lq mw mx dp lu kx my mz lw lb na nb ly lf nc nd ma ne bi translated">保证。全部()</h2><p id="39ca" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><code class="fe mh mi mj mk b">Promise.all()</code>方法将一个可迭代的承诺作为输入，并返回一个承诺，该承诺解析为输入承诺的结果数组。当输入的所有承诺都已解析时，或者如果输入iterable不包含承诺，则返回的承诺将被解析。如果任何一个承诺被拒绝，<code class="fe mh mi mj mk b">promise.all()</code>会抛出第一个被拒绝的承诺的错误。</p><p id="0fbb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面举个例子。我们创建3个承诺，在随机时间解决。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="fbce" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“first promise resolved”)<br/> // reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“second promise resolved”)<br/> // reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“third promise resolved”)<br/> // reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="f679" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> try {<br/> const result = await Promise.all([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err)<br/> }<br/> <br/>})();<br/></span></pre><p id="f1c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们在控制台中查看我们的结果，我们可以看到所有三个承诺都解决了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/ee8a90d6062991ce3b6700d856145f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-bm0w1I1py511NgiIBaxA.png"/></div></div></figure><p id="2c73" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们的一个承诺被拒绝了呢？我们已经在try catch块中轻松处理了这个错误。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="c259" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“first promise resolved”)<br/> // reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“second promise resolved”)<br/> reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“third promise resolved”)<br/> // reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});(async function() {<br/> try {<br/> const result = await Promise.all([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err)<br/> }<br/> <br/>})();<br/><br/></span></pre><p id="6623" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">查看控制台，我们可以看到控制台中记录的被拒绝的承诺。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/aaa79237c412dc414e0c9548fbfc8cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4rPB3J79o6Zdo1hSKTE5Q.png"/></div></div></figure><h2 id="dae0" class="mp ll in bd lm mu mv dn lq mw mx dp lu kx my mz lw lb na nb ly lf nc nd ma ne bi translated">承诺.竞赛()</h2><p id="32ad" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">一旦iterable中的一个承诺履行或拒绝，方法就返回一个履行或拒绝的承诺，并带有该承诺的值或原因。</p><p id="e909" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例子</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="8eac" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“first promise resolved”)<br/> // reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“second promise resolved”)<br/> // reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“third promise resolved”)<br/> // reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="f134" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> try {<br/> const result = await Promise.race([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err)<br/> }<br/> <br/>})();<br/></span></pre><p id="3b25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们只检查控制台，会返回一个承诺，这是最先解决的承诺，无论是解决还是拒绝。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/5a0f8672c3f5d6b0fe28f8d74901235b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuGebFLLvxpgw3GmZNfsrQ.png"/></div></div></figure><h2 id="7da9" class="mp ll in bd lm mu mv dn lq mw mx dp lu kx my mz lw lb na nb ly lf nc nd ma ne bi translated">Promise.any()</h2><p id="458f" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><code class="fe mh mi mj mk b">Promise.any()</code>就像是<code class="fe mh mi mj mk b">Promise.all()</code>的反义词。<code class="fe mh mi mj mk b"><strong class="kq io">Promise.any()</strong></code>如果解决了任何供应承诺，则解决。不像<code class="fe mh mi mj mk b"> promise.all()</code>，要等所有承诺都解决了才解决。让我们看看下面的例子。 <br/>基本上，我们有3个承诺会随机兑现。我们使用了<code class="fe mh mi mj mk b">setTimeout()</code>功能来设置每个承诺的解决时间。我们使用<code class="fe mh mi mj mk b"> Math.floor(Math.random)</code>给<code class="fe mh mi mj mk b">setTimeout()</code>函数一个随机时间，所以我们真的不知道哪个承诺先解决。这是真实生活中发生的真实事件。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4eca" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(<br/> () =&gt; resolve(“this is the first promise”),<br/> Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(<br/> () =&gt; resolve(“this is the second promise”),<br/> Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(<br/> () =&gt; resolve(“this is the third promise”),<br/> Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="f998" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> const result = await Promise.any([prom1, prom2, prom3]);<br/> console.log(result); // Prints “A”, “B” or “C”<br/>})();<br/></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/4ee6220fad4f52de840654647e0f09f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZjzjoxWWSZjdwNWa4Tz3g.png"/></div></div></figure><p id="012f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mh mi mj mk b">promise.any()</code>的好处是，即使其中一个承诺被拒绝，它也会继续解决另一个承诺。如果所有承诺都被拒绝，它只会抛出一个聚合错误。</p><p id="eb14" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在第一个例子中，只有一个承诺被拒绝，但它继续解决。在第二个例子中，所有的承诺都被拒绝，因此，我们得到一个总的错误</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="ebd3" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“first promise resolved”)<br/> reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“second promise resolved”)<br/> // reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“third promise resolved”)<br/> reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="6ef7" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> try {<br/> const result = await Promise.any([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err, ‘all promises rejected’)<br/> }<br/> <br/>})();<br/></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a581eda4de3d7ac36ab15b7580635bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*UZY-gHXYCM_g7k9LH4T0NQ.png"/></div></figure><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="5696" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“first promise resolved”)<br/> reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“second promise resolved”)<br/> reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“third promise resolved”)<br/> reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="976c" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> try {<br/> const result = await Promise.any([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err, ‘all promises rejected’)<br/> }<br/> <br/>})();</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/32138553a8572e039c31aa38fb8115f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osCmOO0Xst4yjVe8YRMu2g.png"/></div></div></figure><h2 id="cb47" class="mp ll in bd lm mu mv dn lq mw mx dp lu kx my mz lw lb na nb ly lf nc nd ma ne bi translated">Promise.allSettled()</h2><p id="1822" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><code class="fe mh mi mj mk b">Promise.allSettled()</code>方法返回一个承诺，该承诺在所有给定的承诺都被履行或拒绝后解析，并带有一个对象数组，每个对象描述每个承诺的结果。<br/>在下面的示例中，其中一个承诺被拒绝，但<code class="fe mh mi mj mk b">promise.allSettled()</code>仍返回所有已结算的承诺。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="e237" class="mp ll in mk b gy mq mr l ms mt"><br/>const prom1 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“first promise resolved”)<br/> // reject(“first promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom2 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> resolve(“second promise resolved”)<br/> // reject(“second promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});<br/>const prom3 = new Promise((resolve, reject) =&gt; {<br/> setTimeout(() =&gt; {<br/> // resolve(“third promise resolved”)<br/> reject(“third promise rejected”)<br/> }, Math.floor(Math.random() * 100)<br/> );<br/>});</span><span id="ce1d" class="mp ll in mk b gy nx mr l ms mt">(async function() {<br/> try {<br/> const result = await Promise.allSettled([prom1, prom2, prom3]);<br/> console.log(result);<br/> } catch (err) {<br/> console.log(err)<br/> }<br/> <br/>})();<br/></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/191e3e1c2f7d2cc9a90a19ab03e81ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0iocKD3sn6AN7_jUh4hcg.png"/></div></div></figure><h1 id="a948" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="2716" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">在本教程中，我们已经能够指出JavaScript承诺及其不同用例之间的区别。</p><p id="f99e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您有任何补充或保留，请在下面的评论区告诉我。</p><p id="bd09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="oe">更多内容请看</em><a class="ae of" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="oe">plain English . io</em></strong></a></p></div></div>    
</body>
</html>