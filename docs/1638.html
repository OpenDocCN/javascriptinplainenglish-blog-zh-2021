<html>
<head>
<title>JavaScript: Pass-by-Value vs. Pass-by-Reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:按值传递与按引用传递</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-paas-by-value-vs-reference-b1667016e4a3?source=collection_archive---------5-----------------------#2021-04-08">https://javascript.plainenglish.io/javascript-paas-by-value-vs-reference-b1667016e4a3?source=collection_archive---------5-----------------------#2021-04-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0a7e1883f1283dd55a4aee2fa3b08e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ym68fMoYs_zR9H-7OBmsww.png"/></div></div></figure><p id="dd97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我来自C++背景，当我第一次遇到JavaScript中的传值和引用时，我一直对JavaScript中的引用是如何工作的感到困惑。在C++中，如果我们想把一个数传递给一个函数，我们可以把它作为<code class="fe kt ku kv kw b">int &amp;num</code>传递，它会更新它的值。但是如果我们像通过<code class="fe kt ku kv kw b">x</code>一样通过它，<code class="fe kt ku kv kw b">num</code>将是对<code class="fe kt ku kv kw b">x</code>的引用。但是在JavaScript中，引用的工作方式有点不同。</p><p id="227e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些困惑都可以在两条规则的帮助下得到解决。但是为了理解这两条规则，我们需要知道什么是简单值(基元)和复合值。</p><p id="4abe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript中，有九种内置类型:Null、Undefined、String、Number、BigInt、Boolean、Symbol、Object、Function。除了对象和函数之外的所有值都称为原始值。因此，为了便于理解，我们可以将这些值分为两部分，即:</p><ol class=""><li id="3f67" class="kx ky in jx b jy jz kc kd kg kz kk la ko lb ks lc ld le lf bi translated"><strong class="jx io">简单值:</strong>原语</li><li id="6577" class="kx ky in jx b jy lg kc lh kg li kk lj ko lk ks lc ld le lf bi translated"><strong class="jx io">复合值:</strong>对象(由数组和所有装箱的对象包装器组成)和函数。</li></ol><figure class="ll lm ln lo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0d591584e3acb5c475a0e59aabdb820d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu7m3sbDR5805uXlds5z4w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Figure 1: Type of values</figcaption></figure><p id="6821" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们跳到参考文献。如前所述，我们只需学习两条规则，就可以知道一个值是通过引用传递还是通过值传递。</p><p id="2453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">规则1: </strong>简单值(又名原语)总是按值传递。</p><p id="f2ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">规则二:</strong>复合值(对象、函数、数组等。)是通过引用传递的。</p><p id="4db7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们举几个例子来清楚地理解这些概念。</p><h1 id="678f" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">例子:</strong></h1><p id="6137" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated"><strong class="jx io"> 1。按值传递</strong></p><pre class="ll lm ln lo gt mw kw mx my aw mz bi"><span id="7487" class="na lu in kw b gy nb nc l nd ne">let var1 = 10;<br/>let var2 = "Hi";<br/>let var3 = var1;<br/>var3 = var3 + 1;<br/>console.log(var3); // 11<br/>console.log(var1); // 10</span></pre><p id="73ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们声明了三个变量<code class="fe kt ku kv kw b">var1, var2, and var3</code>。在第3行，我们给<code class="fe kt ku kv kw b">var3 = var1.</code>赋值，因为<code class="fe kt ku kv kw b">var1</code>是一个数字(它是一个原始值)，所以根据我们的规则，这属于第一个规则，即它将作为一个值传递，这意味着<code class="fe kt ku kv kw b">var1</code>的值的副本被赋值给与第一个值没有关系的<code class="fe kt ku kv kw b">var3</code>(两者有不同的内存地址)。现在在第四行中，当我们执行<code class="fe kt ku kv kw b">var3 + 1</code>时，只有<code class="fe kt ku kv kw b">var3</code>的值在内存中得到更新。</p><figure class="ll lm ln lo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ae654015063196777b6a8ced927a8144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL-R97S98749U3B4aRT75A.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Figure 2: Pass by value</figcaption></figure><p id="8a63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。参考通过</strong></p><pre class="ll lm ln lo gt mw kw mx my aw mz bi"><span id="1bfa" class="na lu in kw b gy nb nc l nd ne">let var1 = 10;<br/>let var2 = "Hi";<br/>let var3 = [1,2];<br/>let var4 = var3;<br/>var4.push(3); <br/>console.log(var3); // [1,2,3]<br/>console.log(var4); // [1,2,3]</span></pre><p id="cb20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们有四个变量:<code class="fe kt ku kv kw b"> var1</code>、<code class="fe kt ku kv kw b">var2, var3, and var4</code>。前两行的执行与上面的例子相同。在第三行中，这里有<code class="fe kt ku kv kw b">var3 = [1,2].</code>，传递的值是一个数组(对象类型),这意味着它将作为对其值的引用(根据我们的第二个规则)被传递。</p><p id="c5ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，假设这个引用的内存地址&lt;0x01&gt;指向值[1，2]。这一步之后，在第四行，我们有，<code class="fe kt ku kv kw b">var4 = var3</code>。这里<code class="fe kt ku kv kw b">var4</code>被赋予<code class="fe kt ku kv kw b">var3</code>的值，该值是被赋予值[1，2]的存储器地址&lt; 0x01 &gt;。这里有一个关键的区别，在上面的例子中，两个值彼此没有关系，但是这里<code class="fe kt ku kv kw b">var3</code>和<code class="fe kt ku kv kw b">var4</code>的值都是对同一个值的引用，所以如果我们更新这个值，那么<code class="fe kt ku kv kw b">var3</code>和<code class="fe kt ku kv kw b">var4</code>也会发生变化。这就是为什么在下一步中，当我们将“3”推入var4时，<code class="fe kt ku kv kw b">var4</code>的值(值[1，2]的内存地址)会更新为[1，2，3]，即引用的值会更新。这意味着当我们在控制台中记录<code class="fe kt ku kv kw b">var3 </code>和<code class="fe kt ku kv kw b">var4</code>时，我们会得到相同的结果【1，2，3】。</p><figure class="ll lm ln lo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fe82ab2fefd71ac1fda1a3fdc38faebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtvAgnWXXGcwZZUiHK3SEQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Figure 2: Pass by reference</figcaption></figure><h2 id="5668" class="na lu in bd lv nf ng dn lz nh ni dp md kg nj nk mh kk nl nm ml ko nn no mp np bi translated">结论</h2><p id="2ddf" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">所有对象都通过引用它们的值来传递。因此，每当我们在设置为等于另一个变量或传递给一个函数后更新它们时，它们都指向同一个值，这有时会导致错误。所以，当你在处理对象类型的时候，记住上面的两条规则，剩下的将会被排序。</p><p id="22b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nq">更多内容请看</em><a class="ae nr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nq">plain English . io</em></a></p></div></div>    
</body>
</html>