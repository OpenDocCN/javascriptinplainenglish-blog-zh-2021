<html>
<head>
<title>The only JavaScript loop benchmark that matters for the most of us</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对我们大多数人来说唯一重要的JavaScript循环基准</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-only-javascript-loop-benchmark-that-matters-for-the-most-of-us-77ec819eb23e?source=collection_archive---------1-----------------------#2021-03-13">https://javascript.plainenglish.io/the-only-javascript-loop-benchmark-that-matters-for-the-most-of-us-77ec819eb23e?source=collection_archive---------1-----------------------#2021-03-13</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="e205" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如果你正在处理数组，你应该如何遍历它们以获得最快的结果？有关系吗？</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/0a750652181f498c922151c005cec6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mG-48ao-ADh803nw"/></div></div></figure><p id="a6c4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以你在JavaScript中有一个数组。假设它有1000个条目。问题是，你应该如何循环遍历它们，才能得到最快的结果？</p><p id="03c0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我研究了几种不同的循环方法，并比较了它们之间的速度差异。</p><p id="f10b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是在向您展示我的代码和我取得的结果(在NodeJS上)之前，我想提一下:</p><p id="32b1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">速度差别不大，但最慢的结果仍然足够快，你真的不应该太在意。因为最慢的时间仍然非常快，你不得不怀疑可读性是否比节省几毫秒更重要。</p><p id="5ea6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，这里取得的任何结果都是快照，而不是平均值。如果你再次运行相同的代码，总会有变化。这也是本文的重点。</p><h1 id="baa9" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">循环类型</h1><p id="853e" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">我想比较JavaScript中几种类型的循环，并对它们进行一些测试。我要看的循环类型:</p><ul class=""><li id="43c8" class="ml mm ir ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated"><code class="fe mu mv mw mx b">for</code></li><li id="0fa1" class="ml mm ir ku b kv my ky mz lb na lf nb lj nc ln mq mr ms mt bi translated"><code class="fe mu mv mw mx b">while</code></li><li id="6c9d" class="ml mm ir ku b kv my ky mz lb na lf nb lj nc ln mq mr ms mt bi translated"><code class="fe mu mv mw mx b">for-of</code></li><li id="7d48" class="ml mm ir ku b kv my ky mz lb na lf nb lj nc ln mq mr ms mt bi translated"><code class="fe mu mv mw mx b">forEach</code></li></ul><h1 id="7fbd" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">简单数据集</h1><p id="ca3c" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">因此，当查看循环基准时，您总是看到人们循环一百万个项目，但是您多久处理一次如此巨大的数据集呢？因此，我们将着眼于一个更加现实的数据集。1000个项目。</p><p id="71fc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我当然知道，计算机是强大的机器，所以用一百万个项目进行测试可以更好地展示不同循环之间的速度差异，但我个人对用循环来做稍微复杂一些的事情会发生什么，以及相比之下很小的循环的性能感兴趣。您将要处理的大多数数据集将会是</p><p id="2327" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们来定义我们的数据，这是一个由1000个条目组成的数组，它们的键在值中。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><h2 id="af48" class="nf lp ir bd lq ng nh dn lu ni nj dp ly lb nk nl ma lf nm nn mc lj no np me nq bi translated">简单循环</h2><p id="8f9b" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">我们要执行的第一个循环，就是用<code class="fe mu mv mw mx b">Math.pow()</code>将这个数和它自身相乘。在性能上已经有了明显的差异。我们先来看代码。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="32d0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我使用<code class="fe mu mv mw mx b">console.time</code>来记录每个部分的持续时间，然后我们的输出显示如下:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="a3fd" class="nf lp ir mx b gz nv nw l nx ny">for: 0.080ms<br/>while: 0.061ms<br/>forOf: 0.083ms<br/>forEach: 0.090ms</span></pre><p id="018d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如您所见，差异非常小，您不必考虑它们中任何一个的性能，您只需选择您认为最合适的即可。</p><p id="5dbb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当我将项目从1000更改为10000时，我们会得到这些结果</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="79d9" class="nf lp ir mx b gz nv nw l nx ny">for: 0.650ms<br/>while: 0.595ms<br/>forOf: 0.714ms<br/>forEach: 0.607ms</span></pre><p id="48bc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">尽管如此，对于10k行，我们仍然比1毫秒快。同样，它足够低，您不需要担心性能差异。</p><p id="4941" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你对微秒级的性能改进如此着迷，你可能也应该重新考虑你安装的1000个npm包。我现阶段的建议？选择代码中最容易理解的循环，或者你最熟悉的循环。</p><h1 id="1857" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">现实的数据集</h1><p id="4062" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">好了，我们已经在一个数组中建立了超过1000或10k个元素的循环，其中只有一个数字，对它们进行简单的计算，实际上根本不需要时间。但是您可能要处理的潜在数据集呢？</p><p id="efe3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们将保持所有代码不变，但数据生成会有所不同。这次我们将这样生成数据:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="095e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如你所见，我们使用了一个为我们生成随机数据的包，在这个例子中是博客文章。让我们看看它生成的一个输出。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="944a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以我们在一个数组中有了标题、内容、创建日期和一些关键字。看起来很现实，对吗？也许仍然有点小，但它会做我们的工作，比较这是如何表现的。</p><p id="36a2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因此，让我们再次运行我们的示例代码，看看它现在的表现如何。这是我们的结果:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="6e62" class="nf lp ir mx b gz nv nw l nx ny">for: 0.228ms<br/>while: 0.189ms<br/>forOf: 0.226ms<br/>forEach: 0.269ms</span></pre><p id="4c35" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">总的来说，看起来我们的代码变得慢了3倍，尽管我们没有做任何改变。让我们来计算实际的差异</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/2685aa8a777be3052b16d23d977b27d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*ehYKAnPv60WYW8L1xrQ0Ig.png"/></div></figure><p id="6ccd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以快速计算显示所有的循环增加了大约3倍的时间。时间增加最少的是for-of，最多的是while。但是，这段代码只运行了一次，这仅仅是一个快照。也许我的机器在不同的基准测试之间做得更少(或更多)。有一点是肯定的，每次运行代码，我都会得到稍微不同的结果。考虑到它们的密集度都接近3倍，我认为可以肯定地说，这没多大关系。最后，这一切只花了不到1/3毫秒。</p><p id="1dca" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了好玩，我曾经用100k博客帖子运行我的代码，得到了下面的结果。</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="c9dc" class="nf lp ir mx b gz nv nw l nx ny">for: 15.271ms<br/>while: 12.549ms<br/>forOf: 18.343ms<br/>forEach: 14.043ms</span></pre><p id="b4a2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">即使那样，时间也很接近。太接近了，以至于不在乎差异。老实说，我们中有多少人会同时在内存中处理10万篇博客文章？</p><h2 id="3cd5" class="nf lp ir bd lq ng nh dn lu ni nj dp ly lb nk nl ma lf nm nn mc lj no np me nq bi translated">添加一些进一步的计算</h2><p id="57fa" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">所以让我们在数据上添加一些进一步的、真实的计算。我们将计算内容有多少个字符，我们将计算标题和内容的长度之比，我们将从标题中创建一个url，然后我们还将使用<code class="fe mu mv mw mx b">MomentJS</code>使时间戳可读。</p><p id="f606" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为此，我将创建一个函数，每个循环都将调用同一个函数。这是我的计算函数的样子:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="daaa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">基于一些测试，我得出结论，这个函数最差的部分是<code class="fe mu mv mw mx b">MomentJS</code>。是的，我知道它不是处理日期最好/最快的库，但它是一个常用的库，这也是我使用它的原因。</p><p id="4b84" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">经过一些测试后，我还得出结论，第一个循环的表现总是比第二个循环差，所以我将分别测试它们，而不是在同一个文件中。</p><h2 id="a4d0" class="nf lp ir bd lq ng nh dn lu ni nj dp ly lb nk nl ma lf nm nn mc lj no np me nq bi translated">测试1:没有力矩</h2><p id="cdaf" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">首先，我将禁用<code class="fe mu mv mw mx b">MomentJS</code>行，只用我自己的代码进行测试。结果是这样的:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="210a" class="nf lp ir mx b gz nv nw l nx ny">for: 1.260ms<br/>while: 0.999ms<br/>forOf: 1.156ms<br/>forEach: 0.764ms</span></pre><p id="df45" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我想重复我自己，这些测试不是确凿的事实，而只是在我自己的机器上的即时测试。结果有时会因<code class="fe mu mv mw mx b">nodejs</code>或我的Mac的感觉而异，而不是实际可测量的结果。这也正是我写这篇文章的原因，不是为了证明一个比另一个快，而是为了向您展示它们是如此接近，以至于您使用什么都不重要。</p><h2 id="3943" class="nf lp ir bd lq ng nh dn lu ni nj dp ly lb nk nl ma lf nm nn mc lj no np me nq bi translated">测试2:带力矩</h2><p id="f8ba" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">现在我将再次运行相同的测试，但是这次启用了<code class="fe mu mv mw mx b">MomentJS</code>。结果如下:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="58b0" class="nf lp ir mx b gz nv nw l nx ny">for: 52.884ms<br/>while: 51.455ms<br/>forOf: 50.531ms<br/>forEach: 52.349ms</span></pre><p id="7835" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这是他们所有人的第一个结果，但这里有一个问题:</p><p id="3e7a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我多次运行每个测试，所有循环都显示了49-55毫秒的结果。这正是我写这篇文章的原因，对于一个合理的数据集，循环之间的差异在生产机器上是不可测量的。</p><p id="794d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是，如果您同时按顺序运行所有循环，您会得到以下结果:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="e1f0" class="nf lp ir mx b gz nv nw l nx ny">for: 50.346ms<br/>while: 22.444ms<br/>forOf: 16.450ms<br/>forEach: 15.701ms</span></pre><p id="e03c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因此，在这个过程中的某个地方，JavaScript会看到重复的计算，它会执行得更好。因此，如果你有复杂的代码，不断地做各种各样的事情，你的结果会有更大的不同。</p><p id="0273" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么，当所有4个循环都启用了100k blogposts时，这段代码会有什么表现呢？幸运的是，我做了测试，结果如下:</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="ff85" class="nf lp ir mx b gz nv nw l nx ny">for: 978.380ms<br/>while: 884.993ms<br/>forOf: 882.864ms<br/>forEach: 957.400ms</span></pre><p id="8fe0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以100倍的数据，20倍的时间。因此，JavaScript似乎在处理更大的数据集时变得更有效率。我在之前的1k循环中看到的“第一循环最慢”效应似乎也适用于此。</p><p id="4927" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">而且，实际上，我的代码中大多数性能受到影响的是<code class="fe mu mv mw mx b">MomentJS</code>。这是没有<code class="fe mu mv mw mx b">MomentJS</code>的100k博客帖子的结果</p><pre class="kh ki kj kk gu nr mx ns nt aw nu bi"><span id="e53c" class="nf lp ir mx b gz nv nw l nx ny">for: 69.448ms<br/>while: 67.378ms<br/>forOf: 68.693ms<br/>forEach: 65.682ms</span></pre><h1 id="076d" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">最后</h1><p id="e527" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">所以我的结论很简单，你选择什么样的循环并不重要，它们的性能相当，你应该关心代码的可读性，而不是循环的性能。</p><p id="d6e9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以下次有同事评论你的公关，说你应该因为绩效原因改变你的循环，你可以把他们链接到这篇文章。我会对你的同事说:</p><blockquote class="oa"><p id="5d85" class="ob oc ir bd od oe of og oh oi oj ln dk translated">是的，我肯定一个循环的性能不同于另一个，但我们没有处理足够的数据来证明这一点。因此，除非您希望每次都运行成千上万行，否则差异非常小，我们不应该因为性能原因而讨论循环类型。我们来谈谈可读性吧。</p></blockquote><p id="79b4" class="pw-post-body-paragraph ks kt ir ku b kv ok js kx ky ol jv la lb om ld le lf on lh li lj oo ll lm ln ik bi translated">你能从我的文章中得到的唯一真实的结论？<code class="fe mu mv mw mx b">MomentJS</code>有糟糕的表现，但即使如此，它也足够快，你不会真的注意到它。</p><p id="ec4e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">想看看我最终的测试代码，这样你就可以自己运行了？你可以在<a class="ae op" href="https://gist.github.com/Topener/4d816028fb61954e617ef82ed275dc76#file-final_code-js" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到</p></div></div>    
</body>
</html>