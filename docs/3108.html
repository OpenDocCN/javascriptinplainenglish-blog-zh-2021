<html>
<head>
<title>Generating Cryptographically Secure, Safe, and Truly Random Numbers in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中生成加密安全的真正随机数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generating-a-secure-safe-and-truly-random-number-in-node-js-e943224cbe30?source=collection_archive---------6-----------------------#2021-06-24">https://javascript.plainenglish.io/generating-a-secure-safe-and-truly-random-number-in-node-js-e943224cbe30?source=collection_archive---------6-----------------------#2021-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9a98b54ddf9d736ddf46b92c021e5acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hmIiqtJJ3JP8mNw_"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@rihok?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Riho Kroll</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">这篇文章有Node.js的例子，但适用于大多数编程语言。</em></p><p id="13fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在寻找随机性时，您可能会找到的第一个函数是<code class="fe kz la lb lc b"><em class="ky">Math.random()</em> </code>，它生成一个范围在[0，1) <em class="ky">(包括0，但不包括1) </em>内的伪随机数。不幸的是，它不提供密码安全的随机数。因此，你不应该使用它，除非一旦你读了这篇文章，你决定这是一个可行的选择。</p><p id="21b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开始我们的旅程，我们可能遇到的第一件事是随机的类型:</p><ul class=""><li id="473f" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated">真正随机的:没有模式或算法可以创造它们，因此它们是不可能预测的。关于这些是否存在存在争议。</li><li id="f315" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><strong class="kc io">不可预测</strong>:不是真正的随机，而是不可能预测。这通常是你正在寻找的安全选择。因为只要无法预测，它是如何产生的并不重要。</li><li id="445d" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><strong class="kc io">不规则</strong>:这是大多数人对随机的误解。这只是一些你无法在简单的视图中识别出模式的数据。这不是真正的随机，甚至是不可预测的。</li></ul><p id="583a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不规则数据生成速度最快。当需要可再现的和统计上高质量的伪随机数时，应该使用它。例如在科学研究中，能够复制结果是很重要的。或者在运行测试时，某个种子值可能会导致bug。</p><p id="741e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">但是，如果攻击者能够预测即将到来的值，那么就不应该使用不规则数据。</strong></p><p id="a772" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不可预测的生成速度较慢，这可能是大多数解决方案所需要的。不可预测的数据由<em class="ky"> CSPRNG </em>产生。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="01e7" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">RNG的类型(随机数生成器)</h1><ul class=""><li id="b7b7" class="ld le in kc b kd mw kh mx kl my kp mz kt na kx li lj lk ll bi translated"><strong class="kc io"> CSPRNG </strong> : <em class="ky">密码安全伪随机数发生器。</em>是一个伪随机数发生器，它产生不可预测的值，使得<strong class="kc io">对所有用例</strong>都是安全的。</li><li id="ed7c" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><strong class="kc io">PRNG</strong>T25】伪随机数发生器。这是一个超类，包含了不规则值的生成器。</li><li id="be81" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated"><strong class="kc io"> RNG </strong> : <em class="ky">随机数发生器</em>。包含<em class="ky"> PRNG </em> s和<em class="ky">的超类是真正的随机</em>生成器吗？</li></ul><p id="9d41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此你应该使用CSPRNG来产生各种代币、秘密、抽奖、彩票和种子。只有当你知道你在做什么的时候才使用剩下的。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="9163" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">偏见</h1><p id="307e" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated">Node.js中最广为人知的<em class="ky"> CSPRNG </em>是生成所需字节数的<code class="fe kz la lb lc b"><em class="ky">crypto.randomBytes</em></code> <em class="ky"> </em>。<em class="ky"> </em>因此我们才得到了一种生成安全随机数的方法。结局？号码</p><p id="6e11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直接使用<code class="fe kz la lb lc b"><em class="ky">crypto.randomBytes</em></code>会导致你的价值观产生偏差。这方面的一个例子是使用模运算符从生成的字节中获取一个较小的数字。</p><blockquote class="ne"><p id="c626" class="nf ng in bd nh ni nj nk nl nm nn kx dk translated">设randomNumber = randomByte % 50</p></blockquote><p id="eb45" class="pw-post-body-paragraph ka kb in kc b kd no kf kg kh np kj kk kl nq kn ko kp nr kr ks kt ns kv kw kx ig bi translated">因为一个字节有256个不同的值，所以使用模运算符会增加选取较低值的机会。</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a08a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码是一个错误生成随机数的完美例子，代表了这种常见的错误。在此示例中，您将生成以下范围:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f025" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着在6和49 之间的<strong class="kc io">数在此范围内有<strong class="kc io"> 5个对应值</strong>，而在0和5 </strong>之间的<strong class="kc io">数有<strong class="kc io"> 6个对应值</strong>。因此，虽然介于6和49之间的数字有1.95%的几率被选中，但介于0和5之间的数字有2.34%的几率被选中。</strong></p><p id="4b43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是让你的随机值再次变得不安全的方法之一。</p><figure class="nt nu nv nw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/4c02da5b970a2dd5798ff791d997146b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tdBGN6HMkS8gzlrj"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="d293" class="ly lz in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">铆钉铆合</h1><p id="09ed" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated">那么，如何生成安全的随机数呢？也许你现在最好的选择是使用一个解决这个问题的库。在Node.js中，我们有:</p><ul class=""><li id="b9d0" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated">用于在 : <a class="ae jz" href="https://www.npmjs.com/package/random-number-csprng" rel="noopener ugc nofollow" target="_blank">随机数-csprng </a>范围内生成随机数<strong class="kc io"/></li><li id="f77f" class="ld le in kc b kd lm kh ln kl lo kp lp kt lq kx li lj lk ll bi translated">对于API密钥或令牌来说，你最好的选择可能是uuid，如果是这样，你可能会寻找T2函数。</li></ul><p id="9bb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是考虑到你不应该在任何情况下修改结果，因为你可能会再次落入陷阱。</p><p id="4e59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于此主题的更多信息:</p><ul class=""><li id="1ac6" class="ld le in kc b kd ke kh ki kl lf kp lg kt lh kx li lj lk ll bi translated"><a class="ae jz" href="https://www.youtube.com/watch?v=LDPMpc-ENqY" rel="noopener ugc nofollow" target="_blank">Stephan t . lava vej关于C++中的<em class="ky"> rand() </em>和生成随机数的精彩演讲。</a></li></ul><p id="a965" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>