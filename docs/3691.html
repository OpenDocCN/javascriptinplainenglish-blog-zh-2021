<html>
<head>
<title>Replace null with ES6 Symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ES6符号替换null</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replace-null-with-es6-symbols-c0e77d74542e?source=collection_archive---------1-----------------------#2021-07-24">https://javascript.plainenglish.io/replace-null-with-es6-symbols-c0e77d74542e?source=collection_archive---------1-----------------------#2021-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9c465f6eb23ae6592224e22116dc5550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cF5KQi37G9SnB99KyYLADQ.jpeg"/></div></div></figure><div class=""/><p id="76d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我在开发我的小型项目库时，我需要表示一个缺失的值。过去，当我想要更多的控制时，我在简单的设置和选项中使用可空的方法。</p><p id="2707" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，两者都不正确，所以我想出了一个不同的方法来展示。</p><h1 id="32b2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么可空是不够的</h1><p id="0ad7" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">可空意味着当有一个值时，它是一个字符串、一个数字或一个对象。当没有值时，我们使用<code class="fe lz ma mb mc b">null</code>或<code class="fe lz ma mb mc b">undefined</code>。</p><p id="f09b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">提示:</em>如果您在TypeScript中使用可空类型，请确保您打开了<code class="fe lz ma mb mc b"><a class="ae me" href="https://www.typescriptlang.org/tsconfig#strictNullChecks" rel="noopener ugc nofollow" target="_blank">strictNullChecks</a></code></p><p id="70df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这通常是好的。</p><p id="8fb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，有两种情况不是这样:</p><ol class=""><li id="efc7" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">值<em class="md">可以是<code class="fe lz ma mb mc b">null</code>或<code class="fe lz ma mb mc b">undefined</code>。最后，这些都是有效的JavaScript原语，人们可以以多种方式使用它们。</em></li><li id="33be" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">你想增加一些高级逻辑。到处写<code class="fe lz ma mb mc b">x == null</code>变得繁琐。</li></ol><p id="3a17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我处理的是一个承诺的输出，它可以返回任何东西。而且我可以预见，这两个‘失踪’最终都会被归还。</p><p id="2232" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，问题1和2有相同的解决方案:使用实现选项类型的库。</p><h1 id="0100" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么选择太多</h1><p id="b49b" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Option(有时称为Maybe)类型有两种可能:要么没有值(<code class="fe lz ma mb mc b">None</code>在<code class="fe lz ma mb mc b">Nothing</code>上)，要么有值(<code class="fe lz ma mb mc b">Some</code>或<code class="fe lz ma mb mc b">Just</code>)。</p><p id="5936" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript/TypeScript中，这意味着引入一个包装值的新结构。最常见的是一个具有属性<code class="fe lz ma mb mc b">tag</code>的对象，该属性定义了它的可能性。</p><p id="6dad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是如何在TypeScript中快速实现选项:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7813" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，你会使用一个定义类型的库和一些有用的工具。<a class="ae me" href="https://dev.to/ryanleecode/practical-guide-to-fp-ts-option-map-flatten-chain-6d5" rel="noopener ugc nofollow" target="_blank">这里是我最喜欢的fp-ts库中选项的介绍</a>。</p><p id="ea7e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我构建的库很小，没有依赖性，并且不需要使用任何选项工具。因此，引入一个选项库将是大材小用。</p><div class="ip iq gp gr ir mz"><a href="https://github.com/robinpokorny/promise-throttle-all" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jc gy z fp ne fr fs nf fu fw ja bi translated">github-robinpokorny/promise-throttle-all:🤏promise . all有限并发</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Promise.all用有限的并发限制正在进行的异步操作，比如一次只运行几个API请求…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ix mz"/></div></div></a></div><p id="e17f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一段时间，我在考虑内联这个选项，也就是从头开始编码。对于我的用例来说，这只有几行。但是，这会使库的逻辑有点复杂。</p><p id="8274" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我有了一个更好的主意！</p><h1 id="5169" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">符号作为新的空值</h1><p id="40a5" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">回到Nullable，无法解决的问题是<code class="fe lz ma mb mc b">null</code>(或<code class="fe lz ma mb mc b">undefined</code>)是全局的。它是一个等于自身的值。对每个人来说都一样。</p><p id="3aa0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你返回<code class="fe lz ma mb mc b">null</code>，我返回<code class="fe lz ma mb mc b">null</code>，以后，就不可能知道<code class="fe lz ma mb mc b">null</code>从哪里来了。</p><p id="8747" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，永远只有一个实例。为了解决这个问题，我们需要有一个新的<code class="fe lz ma mb mc b">null</code>实例。</p><p id="918b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们可以使用空对象。在JavaScript中，每个对象都是一个新的实例，它不同于任何其他对象。</p><p id="0a9f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，嘿，在ES6中我们有了一个新的原语来做这件事:符号。(阅读一些<a class="ae me" href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/" rel="noopener ugc nofollow" target="_blank">符号介绍</a></p><p id="7c2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我做的是一个新的常数，代表一个缺失值，这是一个符号:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="91f6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看好处:</p><ul class=""><li id="31b4" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv no ml mm mn bi translated">这是一个简单的值，不需要包装</li><li id="a900" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv no ml mm mn bi translated">其他任何内容都被视为数据</li><li id="7805" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv no ml mm mn bi translated">这是一个私有的None，该符号不能在其他地方重新创建</li><li id="3763" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv no ml mm mn bi translated">它在我们的代码之外没有任何意义</li><li id="0aca" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv no ml mm mn bi translated">标签使调试更容易</li></ul><p id="3eec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了！特别是第一点允许用None作为<code class="fe lz ma mb mc b">null</code>。查看一些使用示例:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="3dc2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">符号几乎是空的</h1><p id="3a29" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">也有一些缺点。</p><p id="a9a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，这在IMO中很少见，环境必须支持ES6符号。也就是说Node.js &gt; =0.12(不要和v12混淆)。</p><p id="588b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，电子监管化(去电子监管化)存在问题。有趣的是，符号的行为和<code class="fe lz ma mb mc b">undefined</code>一模一样。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d807" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，关于实例的信息当然会丢失。然而，由于它的行为类似于<code class="fe lz ma mb mc b">undefined</code>——本机“缺失值”)——这使得它非常适合表示自定义的“缺失值”。</p><p id="22b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，选项基于结构而不是实例。任何属性<code class="fe lz ma mb mc b">tag</code>设置为<code class="fe lz ma mb mc b">none</code>的对象都被视为无。这使得序列化和解序列化更加容易。</p><h1 id="fc60" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="a252" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我对这种式样相当满意。在不需要对财产进行高级操作的地方，这似乎是比<code class="fe lz ma mb mc b">null</code>更安全的选择。</p><p id="b1a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许，如果这个自定义符号泄漏到模块或库之外，我会避免它。</p><p id="eb92" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我特别喜欢使用变量名和符号标签，我可以传达缺失值的域含义。在我的小图书馆里，它代表着承诺没有实现:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c73c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不同的域含义可能会有多个缺失值。</p><blockquote class="np nq nr"><p id="3ed2" class="jy jz md ka b kb kc kd ke kf kg kh ki ns kk kl km nt ko kp kq nu ks kt ku kv ij bi translated"><em class="jb">让我知道你对这个用法的看法？是不是很好的替代</em> <code class="fe lz ma mb mc b"><em class="jb">null</em></code> <em class="jb">？每个人都应该使用期权吗？</em></p></blockquote><p id="efd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:符号并不总是容易使用，看我的演讲<em class="md">符号让一切变得复杂</em>。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nv my l"/></div></figure></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="5432" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">原载于</em><a class="ae me" href="https://robinpokorny.com/blog/replace-null-with-es6-symbols/" rel="noopener ugc nofollow" target="_blank">robinpokorny.com/</a><em class="md">。</em></p></div></div>    
</body>
</html>