<html>
<head>
<title>Finding Simple Cycles in an Undirected Graph — A JavaScript Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在无向图中寻找简单循环——一种JavaScript方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/finding-simple-cycles-in-an-undirected-graph-a-javascript-approach-1fa84d2f3218?source=collection_archive---------2-----------------------#2021-08-08">https://javascript.plainenglish.io/finding-simple-cycles-in-an-undirected-graph-a-javascript-approach-1fa84d2f3218?source=collection_archive---------2-----------------------#2021-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/094b7f4ba6c3451b3c945497b9d8290f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRPJpxI3jsNMgX2S_XSUsA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Cycles in a Graph</figcaption></figure><p id="41e0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章是为从<a class="ae kx" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>开始的初学者准备的。以下图形概念的基本知识是理解该算法的先决条件。</p><ul class=""><li id="320d" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">简单圈:</strong>简单圈是指图中没有重复顶点(除了开始和结束顶点)的圈</li><li id="1d52" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb io">深度优先搜索:</strong>DFS算法从<a class="ae kx" href="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology" rel="noopener ugc nofollow" target="_blank">根节点</a>开始(在有图的情况下选择任意一个节点作为根节点)，在回溯之前尽可能地沿着每个分支进行探索。</li><li id="8f35" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><strong class="kb io">生成树:</strong>无向图<a class="ae kx" href="https://en.wikipedia.org/wiki/Undirected_graph" rel="noopener ugc nofollow" target="_blank">G的生成树T是一个子图，它是一棵包含G的所有</a><a class="ae kx" href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)" rel="noopener ugc nofollow" target="_blank">顶点</a>的<a class="ae kx" href="https://en.wikipedia.org/wiki/Tree_(graph_theory)" rel="noopener ugc nofollow" target="_blank">树</a></li></ul><p id="379e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该算法旨在找出图中重叠最少的所有圈。如果我们有一个图<code class="fe lm ln lo lp b"><strong class="kb io">[ABCD]</strong></code>，算法返回的循环将是<code class="fe lm ln lo lp b"><strong class="kb io">[ABD]</strong></code>和<code class="fe lm ln lo lp b"><strong class="kb io">[BCD]</strong></code>。循环<code class="fe lm ln lo lp b"><strong class="kb io">[ABCD]</strong></code>将不会返回。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/886c21d545753bbbd44645ca7a174e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjoQYrEuVYc37lYSnujtXw.png"/></div></div></figure><h1 id="f65b" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">算法设计</strong></h1></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="69ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该算法可以大致分为三个步骤。</p><ol class=""><li id="2fe2" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw na le lf lg bi translated">根据度数的降序对顶点进行排序。(这样做是为了实现边之间的最小重叠，如果不需要最小重叠的循环，则可以忽略此步骤)</li><li id="8151" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw na le lf lg bi translated">形成图的生成树，并获得移除边的列表。</li><li id="27f8" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw na le lf lg bi translated">寻找连接被删除边的端点的环。</li></ol><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/943423ed26ea90ad04739be61c1d5645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51PRDZsuzgvSA5p9iapCTA.png"/></div></div></figure><h1 id="22ec" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">代表图形</strong></h1><p id="20bb" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">该算法涉及两个图。第一个是输入图，第二个是生成树。这两个图都使用邻接表表示。</p><p id="de89" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入图被建模为顶点对象的列表。每个顶点对象包含一个<code class="fe lm ln lo lp b"><strong class="kb io">vertex</strong></code>和一个<code class="fe lm ln lo lp b"><strong class="kb io">adjacencyList</strong></code>。这个图也可以实现为顶点对象的散列图，但是这里选择列表方法是为了便于排序。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/cc9e894b47988adeaefe8d9cac96b5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C52aT6WE8MX8XqDERgvw5Q.png"/></div></div></figure><p id="0086" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">生成树被建模为顶点对象的散列图。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/e75b36377b422971bbd38483ebdb8a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gESXW8f4wYjVLIQtYG2n1Q.png"/></div></div></figure><h1 id="33b7" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">详细步骤</strong></h1><p id="8b96" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">FindCircuits(graph)</strong></code> <strong class="kb io"> </strong>方法是接受输入图并返回路径列表的算法的起点。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/5aab7fe453f3ccf09bf5d57a018eaa65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cn4D5W6z8k4NAQ2BvQRfXA.png"/></div></div></figure><p id="3cfd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它由三个主要步骤组成，包括顶点排序、生成树和寻找环。</p><h2 id="4d23" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak"> 1。G </strong> etSortedVertices <strong class="ak">(图形)</strong></h2><p id="de7e" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">顶点的排序是使用JavaScript <code class="fe lm ln lo lp b"><strong class="kb io">Array.Sort()</strong></code>方法完成的。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/ca52747a990e02f144d170daa1d52a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCzIRBc01DehfBpy5oz7cg.png"/></div></div></figure><h2 id="b562" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak"> 2。GetSpanningTree(图形)</strong></h2><p id="c785" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">接下来是<code class="fe lm ln lo lp b"><strong class="kb io">GetSpanningTree(graph)</strong></code> <strong class="kb io"> </strong>方法，该方法将排序后的图作为输入，并返回生成树。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/6fea4842dda7ee85a67ec6ce0549b1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO3GRrUQVxu1AU_TdEXvGg.png"/></div></div></figure><p id="7e11" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">映射数据结构用于存储生成树。输入图的所有顶点都被添加到生成树中。维护一个<code class="fe lm ln lo lp b"><strong class="kb io">visitedVertices</strong></code>集合，以便在创建生成树时跟踪访问过的边。</p><p id="1672" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">生成树是通过循环遍历排序的图并在树中添加相邻的顶点(边)来构建的，如果它还没有被访问的话。(不在<code class="fe lm ln lo lp b"><strong class="kb io">visitedVertices</strong></code>)</p><h2 id="0cb1" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak"> 3。GetAllCycles(图形，生成树)</strong></h2><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/35b2612778d10ad84b7f2c37b8bcdb15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9n5YSqX703LbfLiKN-oqMw.png"/></div></div></figure><p id="3395" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以通过在生成树上执行<strong class="kb io"> DFS </strong>遍历来获得输入图中存在的圈。</p><p id="3ee1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从图中删除的每条边都是某个循环的一部分。输入图中存在一条简单的路径，将已移除边的一端连接到另一端。因为生成树没有任何圈，所以可以从任何顶点到任何其他顶点追踪一条简单的路径。如果我们取被删除边的两端，在生成树中追踪两端之间的简单路径，我们得到一个圈。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/98af5d0efe786183ad77d5ae1ca45da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UwqtHN1_uZa7J6I0q7-5g.png"/></div></div></figure><p id="89f4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">边的<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>和<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>是通过用连字符<code class="fe lm ln lo lp b"><strong class="kb io">"-"</strong></code>分割<code class="fe lm ln lo lp b"><strong class="kb io">edgeKey</strong></code>得到的。</p><p id="e3e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">FindCycle(start, end, spanning)</strong></code> <strong class="kb io"> </strong>方法在生成树上执行DFS遍历，并返回从<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>顶点开始到<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>顶点结束的循环。如果在开始和结束之间没有循环，则该方法返回null。</p><h2 id="f6ec" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak">3 . a . getrejectedges(graph，spanningTree) </strong></h2><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/dff95b150c34b855fcbfd2e3660b7034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sV4M1cEigjvxqR7jOnESLQ.png"/></div></div></figure><p id="b3a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">rejectedEdges</strong></code>是一组边，其中每个边由一个<code class="fe lm ln lo lp b"><strong class="kb io">edgeKey</strong></code>表示。<code class="fe lm ln lo lp b"><strong class="kb io">edgeKey</strong></code>是由连字符分隔的两个<code class="fe lm ln lo lp b"><strong class="kb io">vertexKeys</strong></code>连接而成的字符串。</p><p id="22a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">比如从<code class="fe lm ln lo lp b">'<strong class="kb io">A'</strong></code>到<code class="fe lm ln lo lp b">'<strong class="kb io">B'</strong></code>有一条边，那么它的<code class="fe lm ln lo lp b"><strong class="kb io">edgeKey</strong></code>应该是<code class="fe lm ln lo lp b">'<strong class="kb io">A-B'</strong></code>。</p><p id="c29c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果边不在生成树中，则通过遍历图并添加<code class="fe lm ln lo lp b"><strong class="kb io">edgesKeys</strong></code>来填充<code class="fe lm ln lo lp b"><strong class="kb io">rejectedEdges</strong></code>集。</p><h2 id="69da" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak"> 3.b. FindCycle(start，end，spannigTree，parents，visited，current_node，parent_node) </strong></h2><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/cc7b9479f50f2861626a603c02a8a4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMwzwyRVVf8d3d9_SPNm3g.png"/></div></div></figure><p id="1e2b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一种递归方法，它采用移除边的起点和终点，从起点开始递归地在生成树上执行<strong class="kb io"> DFS </strong>遍历，直到找到终点。</p><p id="b3e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">parents</strong></code>映射在遍历树时存储节点的直接父节点。这被初始化为一个空映射。</p><p id="4ddb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">visited</strong></code>集合保存在遍历树时访问过的顶点的集合，以便找到一个循环。这在默认参数中被初始化为空映射。</p><p id="512a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">current_node</strong></code>变量保存递归中当前顶点的名称。这被初始化为<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>。</p><p id="4650" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe lm ln lo lp b"><strong class="kb io">parent_node</strong></code>变量保存递归中当前顶点的名称。这被初始化为<code class="fe lm ln lo lp b"><strong class="kb io">" "</strong></code>。</p><p id="71af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些变量被初始化为默认参数，并在以后的递归调用中被更改。</p><p id="3d0b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于从当前顶点离开的每个未访问的边，<code class="fe lm ln lo lp b"><strong class="kb io">FindCycle()</strong></code>被递归调用，其中<code class="fe lm ln lo lp b"><strong class="kb io">current_node</strong></code>作为边目的地，<code class="fe lm ln lo lp b"><strong class="kb io">parent_node</strong></code>作为当前节点。</p><p id="f679" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当到达<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>顶点或访问完所有顶点时，递归结束。</p><p id="f0a8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">每当到达一个<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>顶点时，到达该顶点的路径将是循环的。<strong class="kb io"> </strong> <code class="fe lm ln lo lp b"><strong class="kb io">GetCyclePath(start, end, parent_node, parents)</strong></code>方法用于从<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>回溯到<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>。此方法返回循环路径。</p><h2 id="43e5" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated"><strong class="ak"> 3.b.i. GetCyclePath(start，end，parent_node，parents) </strong></h2><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/b5b9e91fe69a17c595a6a62fd9628758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGO8CG5jcf-qgF5izSgt5A.png"/></div></div></figure><p id="c09b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该方法通过回溯从<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code> <strong class="kb io"> </strong>顶点到<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>顶点的生成树来捕捉<code class="fe lm ln lo lp b"><strong class="kb io">start</strong></code>和<code class="fe lm ln lo lp b"><strong class="kb io">end</strong></code>顶点之间的循环路径。<code class="fe lm ln lo lp b"><strong class="kb io">parents</strong></code>图用于获取专利顶点的参考。</p><h2 id="a685" class="ni lw in bd lx nj nk dn mb nl nm dp mf kk nn no mj ko np nq mn ks nr ns mr nt bi translated">测试</h2><p id="df9b" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">可以通过将下面的输入图传递给<code class="fe lm ln lo lp b"><strong class="kb io">FindCircuits(graph)</strong></code>方法来测试该算法</p><p id="67d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">输入:</strong></p><pre class="lr ls lt lu gt nv lp nw nx aw ny bi"><span id="6398" class="ni lw in lp b gy nz oa l ob oc"><strong class="lp io">let vertices = [<br/>    {<br/>        vertex: "A",<br/>        adjList: ["B", "D"]<br/>    },<br/>    {<br/>        vertex: "B",<br/>        adjList: ["A", "C", "D"]<br/>    },<br/>    {<br/>        vertex: "C",<br/>        adjList: ["B", "D"]<br/>    },<br/>    {<br/>        vertex: "D",<br/>        adjList: ["A", "B", "C"]<br/>    }<br/>];</strong></span><span id="0325" class="ni lw in lp b gy od oa l ob oc"><strong class="lp io">let graph = {<br/>    vertices: vertices,<br/>};</strong></span></pre><p id="9059" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">输出:</strong></p><p id="92d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该算法返回一个循环路径列表。对于给定的输入图，输出如下。</p><pre class="lr ls lt lu gt nv lp nw nx aw ny bi"><span id="ec7d" class="ni lw in lp b gy nz oa l ob oc"><strong class="lp io">[ [ 'A', 'B', 'D' ], [ 'C', 'B', 'D' ] ]</strong></span></pre><p id="3f48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该算法的完整代码可在<a class="ae kx" href="https://gist.github.com/savinuvijay/06de64299e23bbdea7e38d825e3ad774" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="134c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="og">更多内容请看</em><a class="ae kx" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="og">plain English . io</em></strong></a></p></div></div>    
</body>
</html>