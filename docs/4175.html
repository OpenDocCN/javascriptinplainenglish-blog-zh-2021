<html>
<head>
<title>How to Add a Widget to Zoom In &amp; Out on a Web Page When We Spin the Mouse Wheel Like on Google Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当我们像在谷歌地图上一样旋转鼠标滚轮时，如何添加一个小部件来放大和缩小网页</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-a-widget-that-we-can-zoom-in-and-out-on-a-web-page-when-we-spin-the-mouse-wheel-like-on-f1b83d6b82df?source=collection_archive---------8-----------------------#2021-08-19">https://javascript.plainenglish.io/how-to-add-a-widget-that-we-can-zoom-in-and-out-on-a-web-page-when-we-spin-the-mouse-wheel-like-on-f1b83d6b82df?source=collection_archive---------8-----------------------#2021-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d098fa2d6fbf1cc68e0cc16364e3ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7SA9mIi6eQK7Mr8B"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glen Carrie</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a73e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们想在网页上创建一个小部件，在那里我们可以像在谷歌地图上一样放大和缩小某些东西。</p><p id="59e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看如何创建一个小部件，我们可以用鼠标滚轮放大和缩小，就像我们在谷歌地图上做的那样。</p><h1 id="a7e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">画出我们可以在画布上放大和缩小的图像</h1><p id="1985" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在画布上绘制我们想要放大和缩小的图像。</p><p id="6a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以监听<code class="fe me mf mg mh b">wheel</code>事件，并在移动鼠标滚轮来放大和缩小图像时转换画布图像。</p><p id="0c8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d5d6" class="mq lc iq mh b gy mr ms l mt mu">&lt;canvas id="canvas" width="600" height="200"&gt;&lt;/canvas&gt;</span></pre><p id="a519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以编写以下JavaScript代码，在画布上绘制图像，并在移动鼠标滚轮时放大和缩小图像:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3d85" class="mq lc iq mh b gy mr ms l mt mu">const zoomIntensity = 0.2;</span><span id="265b" class="mq lc iq mh b gy mv ms l mt mu">const canvas = document.getElementById("canvas");<br/>let context = canvas.getContext("2d");<br/>const width = 600;<br/>const height = 200;</span><span id="fa01" class="mq lc iq mh b gy mv ms l mt mu">let scale = 1;<br/>let originx = 0;<br/>let originy = 0;<br/>let visibleWidth = width;<br/>let visibleHeight = height;</span><span id="4c84" class="mq lc iq mh b gy mv ms l mt mu">const draw = () =&gt; {<br/>  context.fillStyle = "white";<br/>  context.fillRect(originx, originy, width / scale, height / scale);<br/>  context.fillStyle = "black";<br/>  context.fillRect(50, 50, 100, 100);<br/>  window.requestAnimationFrame(draw);<br/>}<br/>draw();</span><span id="927e" class="mq lc iq mh b gy mv ms l mt mu">canvas.onwheel = (event) =&gt; {<br/>  event.preventDefault();<br/>  const mousex = event.clientX - canvas.offsetLeft;<br/>  const mousey = event.clientY - canvas.offsetTop;<br/>  const wheel = event.deltaY &lt; 0 ? 1 : -1;<br/>  const zoom = Math.exp(wheel * zoomIntensity);<br/>  context.translate(originx, originy);<br/>  originx -= mousex / (scale * zoom) - mousex / scale;<br/>  originy -= mousey / (scale * zoom) - mousey / scale;<br/>  context.scale(zoom, zoom);<br/>  context.translate(-originx, -originy);<br/>  scale *= zoom;<br/>  visibleWidth = width / scale;<br/>  visibleHeight = height / scale;<br/>}</span></pre><p id="6c0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">draw</code>功能，用第一行和第二行将屏幕清空为白色。</p><p id="2cc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">fillStyle</code>和<code class="fe me mf mg mh b">fillRect</code>画一个黑色方块。</p><p id="bca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">window.requestAnimationFrame</code>来重画画布。</p><p id="fc56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们定义了<code class="fe me mf mg mh b">draw</code>函数，我们就调用它来开始初始绘制。</p><p id="3649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将<code class="fe me mf mg mh b">canvas.onwheel</code>属性设置为当我们移动鼠标滚轮时放大和缩小图像的函数。</p><p id="9dcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数中，我们首先调用<code class="fe me mf mg mh b">event.preventDefault()</code>来停止鼠标滚轮移动时的默认行为。</p><p id="5416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用以下公式得到鼠标偏移量:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9fbe" class="mq lc iq mh b gy mr ms l mt mu">const mousex = event.clientX - canvas.offsetLeft;<br/>const mousey = event.clientY - canvas.offsetTop;</span></pre><p id="bbb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们编写以下代码来规范鼠标移动，以避免不正常的跳跃:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be9e" class="mq lc iq mh b gy mr ms l mt mu">const wheel = event.deltaY &lt; 0 ? 1 : -1;</span></pre><p id="d6ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到缩放系数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce48" class="mq lc iq mh b gy mr ms l mt mu">const zoom = Math.exp(wheel * zoomIntensity);</span></pre><p id="a971" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们平移可见原点，使其位于上下文的原点:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8ac4" class="mq lc iq mh b gy mr ms l mt mu">context.translate(originx, originy);</span></pre><p id="28e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们计算缩放完成后的新原点:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ec74" class="mq lc iq mh b gy mr ms l mt mu">originx -= mousex/(scale*zoom) - mousex/scale;<br/>originy -= mousey/(scale*zoom) - mousey/scale;</span></pre><p id="2fa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用<code class="fe me mf mg mh b">context.scale(zoom, zoom)</code>来围绕原点缩放图像。</p><p id="b92a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们平移图像以偏移可见原点，使其在缩放后处于正确的位置:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac3f" class="mq lc iq mh b gy mr ms l mt mu">context.translate(-originx, -originy);</span></pre><p id="6e2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们使用以下内容更新缩放后的尺寸:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b4ff" class="mq lc iq mh b gy mr ms l mt mu">scale *= zoom;<br/>visibleWidth = width / scale;<br/>visibleHeight = height / scale;</span></pre><p id="b22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们移动鼠标滚轮时，黑色方块应该会放大和缩小。</p><h1 id="8b70" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="af70" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加一个带有图像的小部件，我们可以通过在画布上绘制图像并在移动鼠标滚轮时平移和缩放图像来放大和缩小图像。</p><p id="0270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>