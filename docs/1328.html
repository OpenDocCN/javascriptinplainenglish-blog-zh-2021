<html>
<head>
<title>How Generators work in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中生成器的工作方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-generators-work-in-javascript-133264ce0161?source=collection_archive---------9-----------------------#2021-03-20">https://javascript.plainenglish.io/how-generators-work-in-javascript-133264ce0161?source=collection_archive---------9-----------------------#2021-03-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2ae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一个函数的可能性，它可以在任何点停止，并且可以返回多个值，这些值是来自外部环境的有价值的输入。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/05b09995e2f9118389c042011016a637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8zM_Dc0vW3o1wE7nGPqNQ.png"/></div></div></figure><p id="b088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成器函数是可以生成多个值的特殊函数，对于为<strong class="jm io"> iterables </strong>创建数据流特别有用。</p><p id="f8fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常情况下，<code class="fe kv kw kx ky b">return</code>语句会停止正常函数的执行并返回一个值，但是在生成器函数中，我们可以使用<code class="fe kv kw kx ky b">yield</code>关键字来暂停函数的执行以返回一个特定的值，并且可以在以后需要时继续执行，从而返回尽可能多的值。</p><p id="424f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们检查一下语法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="c234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成器函数语法在<code class="fe kv kw kx ky b">function</code>后面有一个<code class="fe kv kw kx ky b"><strong class="jm io">*</strong></code> <strong class="jm io"> </strong> <em class="ki">(星号)</em>符号，并且只能使用<code class="fe kv kw kx ky b">function</code>关键字创建，所以没有箭头函数。我们也可以使用匿名函数语法。</p><p id="f078" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说到执行这个函数，流程中的一个问题是我们只能调用这个函数一次，但是我们如何恢复并对同一个函数进行后续调用呢？</p><p id="195c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案是生成器对象。每当我们调用该函数时，它并不执行该函数，而是返回一个带有方法<code class="fe kv kw kx ky b">next()</code>的生成器对象，调用该方法可以部分执行生成器函数(如果不是全部的话):</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="14c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，返回的每个值都包装在另一个对象中，其中的<code class="fe kv kw kx ky b">value</code>属性包含返回的数据。</p><p id="e429" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">done</code>属性表示功能是暂停还是完成。换句话说，对于每个<code class="fe kv kw kx ky b">yield</code>，<code class="fe kv kw kx ky b">done</code>属性返回<code class="fe kv kw kx ky b">true</code>，一旦所有<code class="fe kv kw kx ky b">yields</code>结束，最后一个调用返回<code class="fe kv kw kx ky b">false</code>，或者带有<code class="fe kv kw kx ky b">return</code>值，或者带有<code class="fe kv kw kx ky b">undefined</code>。</p><p id="363c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显式<code class="fe kv kw kx ky b">return</code>语句之后的所有后续<code class="fe kv kw kx ky b">next()</code>调用都将返回<code class="fe kv kw kx ky b">{value:undefined, done:true}</code>。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="73bb" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">谢谢，下一位()</h1><p id="5929" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated"><code class="fe kv kw kx ky b">next()</code>的一个神奇之处在于，它是一个与生成器功能通信的秘密网关。自己看:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="aafe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来解码一下上面的代码执行。第一个值得注意的是作为参数传递的<code class="fe kv kw kx ky b">sum</code>变量，只要函数没有被生成器对象完全执行，它就保持活动状态。</p><blockquote class="ml mm mn"><p id="7aeb" class="jk jl ki jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">发生器函数的<code class="fe kv kw kx ky b">arguments</code>与普通函数的工作方式相同。</p></blockquote><p id="5407" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们得到了生成器对象，我们调用第一个没有任何<code class="fe kv kw kx ky b">argument</code>的<code class="fe kv kw kx ky b">next()</code>方法。当传递给<code class="fe kv kw kx ky b">next()</code>方法的<code class="fe kv kw kx ky b">argument</code>是从最后一条<code class="fe kv kw kx ky b">yield</code>语句中收集的时，情况总是如此。</p><p id="03c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这有点令人困惑，但请耐心等待。<code class="fe kv kw kx ky b">next()</code>方法执行生成器函数的某个部分，可以传递一些值，但是我们如何收集它们呢？</p><p id="d84e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个集合正是前面的<code class="fe kv kw kx ky b">yield</code>语句派上用场的地方，它充当接收在<code class="fe kv kw kx ky b">next()</code>方法中传递的值的媒介。这也限制了我们向<code class="fe kv kw kx ky b">next()</code>调用传递多个<code class="fe kv kw kx ky b">arguments</code>，因为只有第一个<code class="fe kv kw kx ky b">argument</code>会被收集。</p><p id="722a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于第一个<code class="fe kv kw kx ky b">next()</code>调用执行了没有先前<code class="fe kv kw kx ky b">yield</code>语句的生成器函数部分，传递的值无法通过当前设计收集。</p><p id="2623" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个<code class="fe kv kw kx ky b">next()</code>调用被传递40，由第一个<code class="fe kv kw kx ky b">yield</code>语句收集并添加到<code class="fe kv kw kx ky b">sum</code>。</p><p id="c2cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三个<code class="fe kv kw kx ky b">next()</code>被传递20，该值由第二个<code class="fe kv kw kx ky b">yield</code>语句收集并再次添加到<code class="fe kv kw kx ky b">sum</code>中，最终值由生成器函数返回。</p><p id="3059" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，<code class="fe kv kw kx ky b">next()</code>方法在使功能灵活和建立与外部环境的双向通信方面非常有用。</p><h1 id="fc4a" class="li lj in bd lk ll mr ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb mv md me mf bi translated">产量多吗？</h1><p id="bbbe" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated"><code class="fe kv kw kx ky b">yield</code>是生成器函数中的一个灵活部分，以至于下面的生成器函数完全没问题:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="a3d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">yields</code>是嵌套的，使得代码从最右边的<code class="fe kv kw kx ky b">yield</code>开始运行，它的返回被馈送给它前面的一个，以此类推，直到你点击最后一个<code class="fe kv kw kx ky b">yield</code>。</p><p id="530b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，您可以使用<code class="fe kv kw kx ky b">yield*</code>调用另一个生成器函数的yields:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="8be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">yield*</code>基本上是将传递的生成器函数的<code class="fe kv kw kx ky b">yields</code>扩展到当前的生成器函数，作为自己的函数来执行。此外，最后传递的生成器函数的<code class="fe kv kw kx ky b">return</code>值由<code class="fe kv kw kx ky b">yield*</code>收集，允许我们在需要时使用内部生成器函数的<code class="fe kv kw kx ky b">return</code>值。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="cc50" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">如何让发电机发电？</h1><h2 id="a18e" class="mw lj in bd lk mx my dn lo mz na dp ls jv nb nc lw jz nd ne ma kd nf ng me nh bi translated">可重复的</h2><p id="9187" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">生成器满足<em class="ki">迭代器协议</em>，从而使其有资格在任何对象中用作<code class="fe kv kw kx ky b">[Symbol.iterator]</code>，使其成为<strong class="jm io">可迭代</strong>。</p><p id="205b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">[Symbol.iterator]</code>是我们使用扩展操作符或<code class="fe kv kw kx ky b">for...of</code>循环时内部调用的方法。是的，数组和字符串有内置的<code class="fe kv kw kx ky b">[Symbol.iterator]</code>方法。</p><p id="8e4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我们在一个对象上使用一个spread操作符时，它的<code class="fe kv kw kx ky b">[Symbol.iterator]</code>被调用一次，这将返回一个对象，在该对象上调用<code class="fe kv kw kx ky b">next()</code>方法，直到<code class="fe kv kw kx ky b">done</code>解析为<code class="fe kv kw kx ky b">true</code>值，此时迭代结束，我们得到最终结果。</p><p id="6abe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以从理论上讲，下面的对象是可迭代的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="55cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，<code class="fe kv kw kx ky b">next()</code>方法返回的值只有在<code class="fe kv kw kx ky b">{done:false}</code>时才被接受。</p><p id="288e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成器派上了用场，使我们编写<code class="fe kv kw kx ky b">[Symbol.iterator]</code>方法变得极其容易，因为它遵循相同的协议。上述对象也可以写成:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><h2 id="31fd" class="mw lj in bd lk mx my dn lo mz na dp ls jv nb nc lw jz nd ne ma kd nf ng me nh bi translated">自定义序列</h2><p id="67ef" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">生成器对象的原型链中也有<code class="fe kv kw kx ky b">[Symbol.iterator]</code>，它返回自己的实例进行迭代，因此对于创建定制序列非常有用:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><h2 id="2b8e" class="mw lj in bd lk mx my dn lo mz na dp ls jv nb nc lw jz nd ne ma kd nf ng me nh bi translated">异步包装器</h2><p id="2edf" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">生成器函数可用于管理异步任务，因为该函数可以暂停以等待异步任务完成，然后可以继续执行其他任务。</p><p id="29a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以像异步await函数一样编写它，但它可以比异步await函数更强大，因为恢复控制的函数完全在我们手中。</p><p id="148c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这有助于避免相同获取调用的重复副作用，因为我们可以通过调用<code class="fe kv kw kx ky b">return()</code>方法而不是<code class="fe kv kw kx ky b">next()</code>方法来终止重复的生成器对象，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="5d93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里控制权交给了<code class="fe kv kw kx ky b">doasync()</code>函数，它根据传递的文本中是否包含'<em class="ki"> get' </em>'文本来决定是完成<code class="fe kv kw kx ky b">asyncgen()</code>执行还是中断它。</p><blockquote class="ml mm mn"><p id="df59" class="jk jl ki jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">C <!-- -->在生成器对象上调用<code class="fe kv kw kx ky b">return()</code>方法取消了生成器函数的所有进一步的产出，并且只执行<code class="fe kv kw kx ky b">finally{}</code>块(如果存在的话)来进行任何清理过程，并且退出函数，生成器对象状态为关闭。</p></blockquote><p id="99cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个小的<strong class="jm io"> React </strong>例子，展示了我们如何像异步await一样使用生成器函数，但是对副作用有更多的控制。您可以在<code class="fe kv kw kx ky b">App.js</code>中比较功能<code class="fe kv kw kx ky b">getData()</code>和<code class="fe kv kw kx ky b">processData()</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni la l"/></div></figure><p id="7ffd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，生成器包装器考虑了最后一次fetch调用来实现副作用，并终止了其他函数调用。然而，我们也可以将其更改为在获取过程已经处于活动状态时不处理进一步的调用。</p><p id="f88d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，可以实现生成器函数，作为获取调用和响应后要实现的任务之间的网关，从而给我们提供了按照我们想要的方式定制它的能力。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="25da" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="73e9" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">正常情况下，我们不需要函数在中间暂停，但是在某些情况下，生成器真的可以派上用场。生成器函数与生成器对象建立的通信是非常独特的，可以在某些流中使用。它在定制对象的迭代行为方面也非常有用，并且是对javascript特性的一个很好的补充。</p><p id="e1d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><p id="3184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">延伸阅读</strong></p><div class="nj nk gp gr nl nm"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd io gy z fp nr fr fs ns fu fw im bi translated">发电机</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">生成器对象由生成器函数返回，它符合可迭代协议和迭代器…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">developer.mozilla.org</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kt nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://javascript.info/generators" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd io gy z fp nr fr fs ns fu fw im bi translated">发电机</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">常规函数只返回一个值(或者不返回任何值)。生成器可以返回(“产生”)多个值，一个…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">javascript.info</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa kt nm"/></div></div></a></div></div></div>    
</body>
</html>