<html>
<head>
<title>How to Create a Tic-Tac-Toe Game Using React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React创建井字游戏？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-tic-tac-toe-game-using-react-js-2c560fe9e282?source=collection_archive---------5-----------------------#2021-06-07">https://javascript.plainenglish.io/how-to-create-a-tic-tac-toe-game-using-react-js-2c560fe9e282?source=collection_archive---------5-----------------------#2021-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5bc80d776d846e6a594fc6ea2099fac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMExIHEWq6Uj-tGGeF-oVg.png"/></div></div></figure><p id="9f2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到本文结束时，你将拥有一个和上面一样的井字游戏。</p><p id="e1ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从将问题陈述分成子集开始，然后我们将一个接一个地挑选。</p><p id="7f36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要创造一个井字游戏。这个游戏有哪些不同的方面？</p><ol class=""><li id="684b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">它有一块3 x 3的板。</li><li id="c893" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">有两个玩家。</li><li id="a449" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">游戏从一个空棋盘开始。</li><li id="15ee" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">每个玩家只能走一步，然后跟着下一个玩家走。</li><li id="6429" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">水平、垂直或对角覆盖三个后续方块的玩家获胜。</li></ol><p id="618c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上是一款井字游戏必须满足的基本要求。</p><p id="e2da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们着手解决每个问题子集。</p><h1 id="32cc" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak"> 1。一块3 x 3的木板— </strong></h1><p id="b201" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">如果您曾经遇到过类似棋盘的结构，那么创建它最简单的方法就是使用一个<code class="fe mk ml mm mn b"><strong class="jx io">display:grid</strong></code> <strong class="jx io"> </strong>属性作为这些条目的父div。对于给定的，我们想要实现一个3 x 3的板，它可以被创建如下(容器是父div的类):</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1a70" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">.container{<br/>    display: grid;<br/>    grid-template-columns: 200px 200px 200px;<br/>    grid-template-rows : 150px 150px 150px;<br/>   }</em></strong></span></pre><p id="6bb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在到了你必须选择如何渲染你的棋盘的时候了。如果你做对了，程序的其余部分会找到自己的路。</p><p id="98a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">网格中的每个div最初都是空的，然后用玩家的值(1或0)替换div中的空内容。现在是时候使用React的力量了。React允许你将一个状态附加到一个元素上，并且当你改变附加到元素上的状态时，它会重新渲染这个元素！</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f476" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">class TictacBoard extends Component {<br/>    initialState = {<br/>        value : {<br/>            '00' : '',<br/>            '01' : '',<br/>            '02' : '',<br/>            '10' : '',<br/>            '11' : '',<br/>            '12' : '',<br/>            '20' : '',<br/>            '21' : '',<br/>            '22' : ''<br/>        }<br/>    };<br/>    state = this.initialState;<br/>    boardItems = [];<br/>    createBoardDivs() {<br/>        this.boardItems  = [];<br/>        for (let i = 0; i &lt; 3; i++) {<br/>            for (let j = 0; j &lt; 3; j++) {<br/>                let key = i.toString() + j.toString();<br/>                this.boardItems.push(&lt;div xaxis={i} yaxis={j} key=    {i.toString() + j.toString()} onClick={this.showValue}&gt;{this.state.value[key]}&lt;/div&gt;);<br/>            }<br/>        }<br/>        return this.boardItems;<br/>    }</em></strong></span><span id="596c" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">render() {<br/>    return (<br/>        &lt;React.Fragment&gt;<br/>            &lt;div className={styles.container}&gt;<br/>                {this.createBoardDivs()}<br/>            &lt;/div&gt;<br/>        &lt;/React.Fragment&gt;<br/><br/>    );<br/>   }</em></strong></span><span id="186b" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">}</em></strong></span></pre><p id="0923" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里创建了棋盘组件，棋盘看起来像一个大小为3 x 3的矩阵。每个div都有一个x轴和一个y轴属性，这将使我们更容易跟踪div上的值。</p><h1 id="614d" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak"> 2。有两个玩家— </strong></h1><p id="4876" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">为了跟踪玩家，我们在组件的状态中创建了一个键，我们可以在每次移动时切换这个键。currentPlayer对象最初被设置为“0 ”,以后当用户单击任何div时将被切换。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c24d" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">class TictacBoard extends Component {<br/>    initialState = {<br/>        currentPlayer : 0,<br/>        value : {<br/>            '00' : '',<br/>            '01' : '',<br/>            '02' : '',<br/>            '10' : '',<br/>            '11' : '',<br/>            '12' : '',<br/>            '20' : '',<br/>            '21' : '',<br/>            '22' : ''<br/>        }<br/>      };<br/>    state = this.initialState;<br/>}</em></strong></span></pre><h1 id="75c0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.游戏从一个空棋盘开始—</h1><p id="ab57" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">要在所有div中以空内容开始游戏，我们可以创建一个对象来跟踪每个div的状态，并用一个空值初始化所有键，以便在第一次加载页面时启动一个空网格。</p><p id="5a39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经在组件的状态中创建了一个值对象。为了保持每个div的唯一性，value对象中的每个键都是每个div的x轴值和y轴值的组合，作为一个字符串，我们已经用空值初始化了这个字符串，以启动一个空网格。现在，当您想要更改div上的值时，您所需要做的就是更改组件状态的value对象中相应键的值</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="acb0" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">class TictacBoard extends Component {<br/>    initialState = {<br/>        value : {<br/>            '00' : '',<br/>            '01' : '',<br/>            '02' : '',<br/>            '10' : '',<br/>            '11' : '',<br/>            '12' : '',<br/>            '20' : '',<br/>            '21' : '',<br/>            '22' : ''<br/>        }<br/>    };<br/>    state = this.initialState;<br/>    boardItems = [];<br/>    createBoardDivs() {<br/>        this.boardItems  = [];<br/>        for (let i = 0; i &lt; 3; i++) {<br/>            for (let j = 0; j &lt; 3; j++) {<br/>                let key = i.toString() + j.toString();<br/>                this.boardItems.push(&lt;div xaxis={i} yaxis={j} key=    {i.toString() + j.toString()} onClick={this.showValue}&gt;{this.state.value[key]}&lt;/div&gt;);<br/>            }<br/>        }<br/>        return this.boardItems;<br/>    }</em></strong></span><span id="691f" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">render() {<br/>    return (<br/>        &lt;React.Fragment&gt;<br/>            &lt;div className={styles.container}&gt;<br/>                {this.createBoardDivs()}<br/>            &lt;/div&gt;<br/>        &lt;/React.Fragment&gt;<br/><br/>    );<br/>   }</em></strong></span><span id="ce3b" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">}</em></strong></span></pre><h1 id="b672" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak"> 4。每个玩家只能走一步，然后跟着下一个玩家走。</strong></h1><p id="be9e" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">为了确保这一点，我们现在深入研究处理每个div上的点击的函数。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7501" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">showValue = (event) =&gt; {<br/>    let xAxis = event.target.getAttribute("xaxis");<br/>    let yAxis = event.target.getAttribute("yaxis");<br/>    let keyToChange = xAxis + yAxis;<br/><br/>   const newValue = {...this.state.value};<br/>      newValue[keyToChange] = this.state.currentPlayer ? '0' : '1';<br/>   this.setState((prevState) =&gt; {<br/>      return {<br/>        currentPlayer: prevState.currentPlayer ? 0 : 1,<br/>        value: newValue<br/>    }<br/>  });<br/>  this.checkWinner(xAxis, yAxis, newValue[keyToChange], newValue);<br/>}</em></strong></span></pre><p id="c8b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当玩家点击一个div时，我们首先通过从div中获取<code class="fe mk ml mm mn b"><strong class="jx io">xaxis</strong> </code>和<code class="fe mk ml mm mn b"><strong class="jx io">yaxis </strong></code>属性来找出哪个div被点击了。现在，我们在值对象中生成想要更改的键，并用新的值对象在组件上设置新的状态。此外，每当我们单击一个div时，div上呈现的值就会在0和1之间切换。</p><h1 id="3d61" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">5.找到赢家—</h1><p id="4596" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">让我们创建一个函数来查找获胜者。这个函数必须在每个div被点击后被调用。你也可以通过在第5步之后开始调用来减少调用这个函数的次数，因为在至少6步之前，任何一个玩家都不能赢。</p><p id="7a4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在有4个玩家可以获胜的条件:</p><p id="ba4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从玩家的当前位置/当前点击的div跟踪以下内容:</p><p id="733a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设单击的div是(1，2) — 1是div的x轴，2是y轴。</p><ol class=""><li id="db43" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">跟踪所有水平div到这个div — ( 1，0)，(1，1)</li><li id="339d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">跟踪到这个div的所有垂直div — (0，2)，(2，2)</li></ol><p id="a620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你能看到上面两个案例中的模式吗？对于第一种情况，x轴与被单击的div的x轴保持不变，y轴从0变为2。类似地，对于第二种情况，y轴与被单击的div的y轴保持不变，而x轴从0变为2。</p><p id="6912" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.跟踪从棋盘左上角开始到棋盘右下角的所有对角线div(仅当所单击的当前div的x轴和y轴相等时)。</p><p id="a6f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为下面是这条对角线上的divs，0)，(1，1)，(2，2)。</p><p id="8419" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.跟踪从棋盘右上角到左下角的所有对角线div(仅当所单击的当前div的x轴和y轴之和等于2时)。</p><p id="e96d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为下面是这条对角线上的divs，2)，(1，1)，(2，0)。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="6132" class="mw li in mn b gy mx my l mz na"><strong class="mn io"><em class="nb">checkWinner(xAxis, yAxis, currentValue, values) {<br/>    let allValues = {...values};<br/>    let won = true;<br/>    let x = 0, y = 0;<br/>   <br/>    //case 1 : check horizontally</em></strong></span><span id="ca60" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">    while(x &gt;= 0 &amp;&amp; x &lt; 3) {<br/>        if(allValues[x.toString() + yAxis.toString()] !== currentValue) {<br/>            won = false;<br/>            break;<br/>        }<br/>        x++;<br/>    }</em></strong></span><span id="375e" class="mw li in mn b gy nc my l mz na"> <strong class="mn io"><em class="nb">  //case 2 : check vertically</em></strong></span><span id="c697" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">    if(!won) {<br/>        won = true;<br/>        while(y &gt;= 0 &amp;&amp; y &lt; 3) {<br/>            if(allValues[xAxis.toString() + y.toString()] !== currentValue) {<br/>                won = false;<br/>                break;<br/>            }<br/>            y++<br/>        }<br/>    }</em></strong></span><span id="520c" class="mw li in mn b gy nc my l mz na">  <strong class="mn io"><em class="nb"> //case 3 : check top-left to bottom-right diagonal</em></strong></span><span id="a7e5" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">   if(!won &amp;&amp; xAxis === yAxis) {<br/>        won = true;<br/>        x = 0;<br/>        y = 0;<br/>        while(x &lt; 3 &amp;&amp; y &lt; 3) {<br/>            if(allValues[x.toString() + y.toString()] !== currentValue) {<br/>                won = false;<br/>                break;<br/>            }<br/>            x++;<br/>            y++;<br/>        }<br/>    }</em></strong></span><span id="7220" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb">  //case 4: check top-right to bottom-left diagonal</em></strong></span><span id="28e9" class="mw li in mn b gy nc my l mz na"><strong class="mn io"><em class="nb"><br/>    if(!won &amp;&amp; (Number.parseInt(xAxis) + Number.parseInt(yAxis) === 2)) {<br/>        won = true;<br/>      for(let i = 0; i &lt; 3; i++) {<br/>          for(let j = 0; j &lt; 3; j++) {<br/>              if(i + j === 2) {<br/>                  if(allValues[i.toString() + j.toString()] !== currentValue) {<br/>                      won = false;<br/>                      break;<br/>                  }<br/>              }<br/>          }<br/>      }<br/>    }<br/>    if(won) {<br/>        this.setState({winner : `The winner of this game is ${currentValue}`});<br/>     }<br/><br/><br/>}</em></strong></span></pre><p id="1bbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且你还有自己的井字游戏可以玩！</p><p id="171c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以对该代码添加其他一些修改，例如:一旦发现获胜者，禁用网格，为游戏添加计时器，添加“谁先走”选项，添加SVG标签以显示穿过获胜者div的线。</p><p id="5a4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如需完整代码，请访问GitHub链接:</p><div class="nd ne gp gr nf ng"><a href="https://github.com/SaloniMishra/Tic-tac-toe-" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">SaloniMishra/井字游戏-</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">React.js中的一个基本井字游戏。通过在…上创建一个帐户来促进SaloniMishra/井字游戏的发展</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jt ng"/></div></div></a></div><p id="411d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nb">更多内容尽在</em><a class="ae nv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>