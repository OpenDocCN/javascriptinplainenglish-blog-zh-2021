<html>
<head>
<title>Solving LeetCode’s ‘Maximum Number of Vowels in a Substring of Given Length’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解LeetCode的“给定长度的子串中元音的最大数量”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-leetcodes-maximum-number-of-vowels-in-a-substring-of-given-length-8ac89b663fe?source=collection_archive---------12-----------------------#2021-05-03">https://javascript.plainenglish.io/solving-leetcodes-maximum-number-of-vowels-in-a-substring-of-given-length-8ac89b663fe?source=collection_archive---------12-----------------------#2021-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7290bfdaedeab6e5373a7980ea9b8a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QVre71iK5XD-vSO8"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@amadorloureiroblanco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Amador Loureiro</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e988" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将在JavaScript中求解LeetCode在给定长度的子串中的最大元音数。这个问题使用了滑动窗口技术。有两种类型的滑动窗口。这个问题使用的技术是一个固定的窗口长度k。我们移动窗口来寻找窗口中的特定内容，例如窗口中的最大数量。另一种技术涉及2个指针(通常是字符串/数组的索引),表示窗口边上的2条边。起始索引在左边缘，结束索引在右边缘。在起始和结束索引范围内捕获的数组元素将用于计算结果。我们可以根据需要扩大或缩小数组的大小。在每种技术中，窗口从数组的开头开始，滑动到末尾，扫描所有元素。因此得名，推拉窗。</p><h1 id="682c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题</h1><p id="39d3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">给定字符串s和整数k。</p><p id="18dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回长度为k的s的任意子串中元音字母的最大数量。</p><p id="c5de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">英语中的元音字母是(a，e，I，o，u)。</p><h1 id="0eec" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">例子</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8461" class="mk kz in mg b gy ml mm l mn mo"><strong class="mg io">Input:</strong> s = "abciiidef", k = 3</span><span id="dd9a" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">Output:</strong> 3</span><span id="dc84" class="mk kz in mg b gy mp mm l mn mo"><strong class="mg io">Explanation:</strong> The substring "iii" contains 3 vowel letters.</span></pre><h1 id="227a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决办法</h1><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="4503" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">说明</h1><p id="b57d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们第一次通过我们的for循环(<code class="fe ms mt mu mg b">s[i]</code> = <code class="fe ms mt mu mg b">“a”</code>)，我们的第二个if语句为真:<code class="fe ms mt mu mg b">“a”</code>包含在我们的<code class="fe ms mt mu mg b">vowels</code>字符串中。我们的<code class="fe ms mt mu mg b">count</code>变量增加，我们的<code class="fe ms mt mu mg b">result</code>变量被重新分配给<code class="fe ms mt mu mg b">count</code>。<code class="fe ms mt mu mg b">“b”</code>和<code class="fe ms mt mu mg b">“c”</code>不是元音并且<code class="fe ms mt mu mg b">i</code>仍然小于<code class="fe ms mt mu mg b">k</code>，所以什么都不会发生。我们的下一个循环(<code class="fe ms mt mu mg b">s[i]</code> = <code class="fe ms mt mu mg b">“i”</code>)的索引为3，等于<code class="fe ms mt mu mg b">k</code> ( <code class="fe ms mt mu mg b">k</code> = 3)。我们的if语句为真(<code class="fe ms mt mu mg b">i &gt;= k</code>)，其内部if语句<code class="fe ms mt mu mg b">vowels.includes(s[i — k])</code>为真(<code class="fe ms mt mu mg b">s[i — k]</code> = <code class="fe ms mt mu mg b">“a”</code>)。我们正在右移窗口，所以<code class="fe ms mt mu mg b">“a”</code>不再在窗口中，我们减少了<code class="fe ms mt mu mg b">count</code>。我们下一个if语句为真，<code class="fe ms mt mu mg b">“i”</code>是元音。我们将它添加到我们的<code class="fe ms mt mu mg b">count</code>中，我们的<code class="fe ms mt mu mg b">result</code>保持不变。</p><p id="b292" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个循环是另一个索引为4的<code class="fe ms mt mu mg b">“i”</code>，所以我们进入第一个if语句。这次，<code class="fe ms mt mu mg b">s[i — k]</code>等于不是元音的<code class="fe ms mt mu mg b">“b”</code>，所以我们不减<code class="fe ms mt mu mg b">count</code>。<code class="fe ms mt mu mg b">“i”</code>是一个元音，所以我们把它加到<code class="fe ms mt mu mg b">count</code>上，而<code class="fe ms mt mu mg b">result</code>被重新分配为2。对于我们的下一个<code class="fe ms mt mu mg b">“i”</code>(索引为5)，我们再次遵循相同的模式，我们的<code class="fe ms mt mu mg b">count</code>和<code class="fe ms mt mu mg b">result</code>现在等于3。我们现在可以返回我们的结果，而不需要完成我们的for循环，因为3是我们窗口中可能的最大元音数(<code class="fe ms mt mu mg b">k</code> = 3)。</p><h2 id="6ef4" class="mk kz in bd la mv mw dn le mx my dp li kl mz na lm kp nb nc lq kt nd ne lu nf bi translated">资源</h2><p id="b0c6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">LeetCode问题:<a class="ae jz" href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/maximum-number-of-a-substring-of-given-length/</a></p><div class="ng nh gp gr ni nj"><a href="https://zengruiwang.medium.com/sliding-window-technique-360d840d5740" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">滑动窗口技术</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">滑动窗口技术对于解决数组或字符串中的问题是有用的，特别是它被认为是一种</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">zengruiwang.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jt nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://medium.com/swlh/sliding-window-a-common-technique-for-solving-algorithmic-problems-involving-string-array-44adf35e2d5d" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">滑动窗口——解决涉及字符串/数组的算法问题的常用技术</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">我最近在尝试解决一些涉及数组的算法问题时，偶然发现了滑动窗口技术…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jt nj"/></div></div></a></div><p id="8ed2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nz">更多内容请看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>