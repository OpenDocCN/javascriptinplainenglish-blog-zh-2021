<html>
<head>
<title>JavaScript: Closure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:闭包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-closure-2cfdf06d2b08?source=collection_archive---------0-----------------------#2021-12-09">https://javascript.plainenglish.io/javascript-closure-2cfdf06d2b08?source=collection_archive---------0-----------------------#2021-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/526f90199580740b33ce1cbc53a9c172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GdS68PRvpRWXwRIG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohammad Rahmani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中最有趣但令人难以置信的概念之一是闭包。不管喜欢与否，许多人偶然发现这个概念，并发现它很难，尤其是在面试中。大多数时候，关于闭包的理论很容易理解。然而，当你得到一个现成的问题陈述时，你很可能会出错。为什么？你可能还没有理解闭包的真正含义和意义。</p><p id="948c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我想分享一下我对什么是闭包以及为什么使用闭包的理解。</p><h2 id="a60e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">长话短说</h2><p id="3a75" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，我坚信闭包只不过是一个函数。</p><p id="e285" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个函数与它在外部作用域(别名词法环境)中的引用成对出现时，它就变成了一个闭包。</p><p id="d87c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">什么是词汇环境？它只是一个执行上下文，看起来像一个堆栈框架。在词法环境中，所有局部变量名和值都被映射。</p><p id="99be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript一直在利用词汇环境。每个函数在词法环境中都有一个引用。当一个函数被调用时，该函数的引用被用来构建实际的执行上下文。因此，函数内部的所有代码行将能够看到外部变量的实际值。无论何时何地调用该函数，都可以看到实际值。</p><p id="b0b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个函数调用另一个函数，而另一个函数又调用另一个函数时，就产生了一个链。对于那些不知道的人来说，这只不过是一个范围链。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="36a7" class="lb lc iq me b gy mi mj l mk ml">function <strong class="me ir">foo</strong>() {<br/>  const <strong class="me ir">secret</strong> = "777";<br/>  return function inner() {<br/>    console.log(`The secret number is ${secret}.`)<br/>  }<br/>}<br/>const f = <strong class="me ir">foo</strong>()<br/>f()</span></pre><p id="23ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一下上面的代码片段。你可能想知道存储在<strong class="kf ir"> foo </strong>中的<strong class="kf ir">秘密</strong>号是什么。嗯，知道<strong class="kf ir">秘密</strong>数字的唯一方法，就是调用<strong class="kf ir"> f </strong>。创建foo时，函数inner在构建执行上下文时用foo的词法环境创建一个闭包。这意味着，调用<strong class="kf ir"> f </strong>将让你访问<strong class="kf ir">秘密</strong>号。</p><h2 id="f25d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">为什么需要闭包？</h2><p id="6041" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们假设JavaScript中从来没有闭包。现在，在上面的例子中，你如何访问<strong class="kf ir">秘密</strong>？如果没有闭包，您将在函数之间显式地传递参数<strong class="kf ir">。这将使你的代码变得非常长，并且非常嘈杂。代码能够投入生产吗？这是一个你需要回答的问题。</strong></p><p id="ef0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让变量和函数成为函数的私有部分是很棒的。使用闭包，您可以很容易地实现这一点。当你决定你需要一个私有国家的时候，你将需要闭包。</p><p id="c00d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到今天，JavaScript还不支持私有字段。</p><p id="1524" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到2015年，JavaScript都没有任何一种创建类的语法。</p><p id="4684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么？您可以使用闭包来实现以上目标。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ba11" class="lb lc iq me b gy mi mj l mk ml"><strong class="me ir">//Example of creating a Private Instance</strong></span><span id="809c" class="lb lc iq me b gy mm mj l mk ml">function Festival(name, month, date, color) {<br/>  return {<br/>    toString() {<br/>      return `${name} ${month} (${date}, ${color})`<br/>    }<br/>  }<br/>}<br/>const feast = new Festival('Christmas Eve','December','24','Gold, Red and Silver')<br/>console.log(feast.toString())</span><span id="f7aa" class="lb lc iq me b gy mm mj l mk ml"><strong class="me ir">//Example of building event oriented code</strong></span><span id="ca7c" class="lb lc iq me b gy mm mj l mk ml">const $ = document.querySelector.bind(document)<br/>const COLOR = 'rgba(20,20,20,1)'<br/><br/>function onClick() {<br/>  $('body').style.background = COLOR<br/>}<br/><br/>$('button').addEventListener('click', onClick)</span><span id="6026" class="lb lc iq me b gy mm mj l mk ml"><strong class="me ir">//Example of building class based structures</strong></span><span id="7672" class="lb lc iq me b gy mm mj l mk ml">function createObject() {<br/>  let x = 42;<br/>  return {<br/>    log() { console.log(x) },<br/>    increment() { x++ },<br/>    update(value) { x = value }<br/>  }<br/>}<br/><br/>const o = createObject()<br/>o.increment()<br/>o.log() // 43<br/>o.update(5)<br/>o.log() // 5<br/>const p = createObject()<br/>p.log() // 42</span></pre><h2 id="57ae" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">使用正确的声明</h2><p id="4f10" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有几种方法可以声明变量。可以选择<strong class="kf ir">让</strong>、<strong class="kf ir"> var </strong>或者<strong class="kf ir"> const </strong>。这些声明的行为在闭包中有很大的不同。</p><p id="0014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果你选择<strong class="kf ir"> var </strong>来声明一个变量，你必须小心你计划关闭的变量。</p><p id="1714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<strong class="kf ir"> var </strong>声明的变量将被提升。我们用一个简单的例子来理解这一点。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3e5c" class="lb lc iq me b gy mi mj l mk ml">function <strong class="me ir">foo</strong>() {<br/>  var result = []<br/>  for (var i = 0; i &lt; 3; i++) {<br/>    result.push(function inner() { console.log(i) } )<br/>  }<br/>  return result<br/>}<br/><br/>const result = <strong class="me ir">foo</strong>()<br/>for (var i = 0; i &lt; 3; i++) {<br/>  result[i]() <br/>}</span></pre><p id="0c13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，上面这段代码会打印出什么呢？上面的代码将打印三次“3”。另一方面，预期结果将是“1、2和3”。</p><p id="e6df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且，上述由<strong class="kf ir"> var </strong>引起的问题可以用<strong class="kf ir"> let </strong>解决。</p><h2 id="95a4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">常见的误解</h2><p id="4734" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">很多时候，开发人员读到了闭包，并且认为闭包只有在内部函数被返回时才被创建。构建闭包不需要返回函数或变量。将一个内部函数赋给一个变量，或者将一个参数传递给一个可以调用它的函数就足够了。闭包是在封闭函数被调用时创建的。</p><p id="b68e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包不引用作用域中的旧值。变量成为闭包不可分割的一部分。当您访问一个变量时，您将能够看到最近的值。这使得用循环构建内部函数的过程非常困难和棘手。</p><p id="f7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包可能会消耗大量内存。然而，您永远不会面临任何类型的内存泄漏。为什么？JavaScript倾向于清理所有没有被引用的循环结构。</p><h2 id="324e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">摘要</h2><p id="b932" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">闭包代表一个代码块，它满足三个标准:</p><ol class=""><li id="ee81" class="mn mo iq kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">你可以把它作为一个值来传递</li><li id="4cc5" class="mn mo iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">它可以按需执行。任何拥有该值的人都可以执行它。</li><li id="672b" class="mn mo iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">可以引用用于创建闭包的上下文中的变量。</li></ol><p id="7a80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nb">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nb">说白了就是</em> </strong> </a> <strong class="kf ir"> <em class="nb">。</em> </strong> <em class="nb">报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nb">免费每周简讯这里</em> </strong> </a> <strong class="kf ir"> <em class="nb">。</em> </strong></p></div></div>    
</body>
</html>