<html>
<head>
<title>Let’s build our own Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建立自己的Redux</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-our-own-redux-9384b283529c?source=collection_archive---------5-----------------------#2021-11-05">https://javascript.plainenglish.io/lets-build-our-own-redux-9384b283529c?source=collection_archive---------5-----------------------#2021-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/630a93caa240d4d281c485699b7a4413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8d2YnHhgwEBNr8a6Krvkg.png"/></div></div></figure><p id="9695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在大学生活的大部分时间里都用Java/Kotlin编写代码，因此，大部分项目都遵循MVC模式。具有讽刺意味的是，我大学毕业后的第一份工作是ReactJS开发人员。现在，我不得不将我的范式从这种方法转移到建模数据的函数方法Redux上，这对我来说并不容易，我也经历了一些艰难的时刻。</p><p id="400f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，这几乎就像魔术一样。这个问题困扰了我很久，直到有一天我决定不再这样做。我体内的极客，就像你的一样，开始更多地了解它。好吧，你在正确的地方，不再怀疑，今天当你离开的时候，你将有足够的知识来建立你自己的<strong class="jx io"> redux </strong>。</p><p id="33c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redux至少可以分解为两个部分——减速器和通量。</p><h1 id="2cc7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是通量？</h1><p id="7a46" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Flux是一种模式或架构，而不是一个库或框架，用于管理我们应用程序中的数据流。由脸书(现为Meta)创建，其USP是数据单向流动。见下图。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/bb712c09522fd8add45e33418ba5d992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgxTL69KXTYjupzGO015Ew.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Image source: <a class="ae mf" href="https://github.com/facebook/flux/tree/main/examples/flux-concepts" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/flux/tree/main/examples/flux-concepts</a></figcaption></figure><p id="da87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据的任何变化，即<strong class="jx io">存储</strong>，都必须经过<strong class="jx io">调度程序。</strong>防止多个动作同时改变<strong class="jx io">存储器</strong>中的相同数据<strong class="jx io">。</strong>视图从商店中读取任何所需的信息，并将其显示在UI部件上。让我们在应用程序中使用一个简单的添加到购物车功能来快速理解这些。</p><h2 id="9d63" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">分配器</h2><p id="1a84" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">商店进货的唯一来源是通过调度员。调度程序通过动作接收信息，并将其传递给商店。<strong class="jx io">每家店都会收到每一个动作</strong>。此外，flux模式规定每个应用程序都应该有一个单独的调度程序。</p><p id="8d50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只要用户按下add-to-cart按钮，我们的视图就会捕获事件并调度一个包含产品id的<code class="fe ms mt mu mv b">add-to-cart</code>动作。</p><h2 id="6ad9" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">商店</h2><p id="e500" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">商店是我们应用程序的小型数据库。它拥有持久存储所需的所有数据，仅此而已。它向调度程序注册以接收动作。存储中的数据只能通过响应一个动作来改变。</p><p id="cf7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">收到<code class="fe ms mt mu mv b">add-to-cart</code>动作后，我们的商店更新购物车，并在应用程序中发出一个change事件。</p><h2 id="3fbb" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">行动</h2><p id="fcca" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">动作是简单的JavaScript对象，具有需要调度的动作类型和有效负载，或者特定动作所需的数据。按照惯例，动作应该是语义性的，而不是描述动作的实现。</p><p id="5222" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中<code class="fe ms mt mu mv b">add-to-cart</code>是看起来更像下面的动作。</p><pre class="lx ly lz ma gt mw mv mx my aw mz bi"><span id="4800" class="mg ku in mv b gy na nb l nc nd">{<br/>   type: 'add-to-cart',<br/>   payload: { <br/>     product: '1' <br/>   }<br/>}</span></pre><h2 id="ec5d" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">视图</h2><p id="749c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这些只是显示商店数据的UI组件。它们监听来自存储的变化事件，并根据上下文重新呈现。通常在用户触发的事件回调时从UI调度操作。</p><p id="02e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户按下add-to-cart按钮时，我们在<code class="fe ms mt mu mv b">onclick</code>回调上调度<code class="fe ms mt mu mv b">add-to-cart</code>动作。</p><p id="5c8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们知道了flux框架，让我们从构建自己的redux开始。另外，如果你对JavaScript的<code class="fe ms mt mu mv b">reduce</code>方法了解不多，请快速阅读这篇<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/lets-deduce-the-reduce-method-in-javascript-bdc828f368a2">文章</a>,然后回到这里。如果你已经知道，让我们从一个简单的使用reduce的sum函数开始。</p><h2 id="79f4" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">将数组简化为总和</h2><p id="cc1a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Reduce方法可以用来计算数组的和。下面是一个简单的实现。</p><pre class="lx ly lz ma gt mw mv mx my aw mz bi"><span id="3e83" class="mg ku in mv b gy na nb l nc nd">const sum = (nums) =&gt; {<br/>   return nums.reduce((state, next) =&gt; state + next);<br/>};<br/>sum([1,2,3,4]); // <strong class="mv io">10</strong></span></pre><p id="b98b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们把这个写得复杂一点。</p><pre class="lx ly lz ma gt mw mv mx my aw mz bi"><span id="31d4" class="mg ku in mv b gy na nb l nc nd">const sum = (nums) =&gt; {<br/>   const iterator = (state, next) =&gt; state + next;<br/>   const [initialState, rest] = nums;<br/>   return rest.reduce(iterator, initialState);<br/>};<br/>sum([1,2,3,4]); // <strong class="mv io">10</strong></span></pre><p id="f2c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我只是析构了数组，并单独创建了迭代器函数。到目前为止看起来不错。现在让我们试着将这个概念应用到更真实的世界。</p><h2 id="21d1" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">越来越具体</h2><p id="f6c5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">假设我们有一个购物车，它根据UI上的用户交互接收关于产品数量的更新。下面是上述代码的更新版本，以匹配这个用例。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="995b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ms mt mu mv b">update</code>方法与我们之前看到的sum函数相同，只是用作购物车中产品数量的更新方法。传递给update方法的数组中的所有值本质上都是传递给reducer的动作。让我们通过给我们的行为命名来使它更清楚。参见下面的代码。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="86d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看我们所有的动作现在都有一个类型字段和有效载荷，在我们的例子中是qty。此外，将现有存储作为初始状态传递给<code class="fe ms mt mu mv b">reduce()</code>，然后用结果覆盖它，我们可以开始跨多个调用转换数据以减少。</p><p id="e172" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法使我们的代码更容易阅读和维护。此外，我们的存储只涉及数据建模和逻辑，这使得存储和归约器非常容易移植。ReactJS上的web应用程序和React Native上的移动应用程序可以使用同一套reducers和stores，考虑到如今我们将想法发布到产品上的时间越来越少，这是非常酷的。</p><p id="e70a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你今天学到了新东西。一定要尝试做一个类似redux的应用来解决离你更近的应用挑战。此外，让我知道哪些JavaScript主题仍然困扰着你，我们会努力理解它们。</p><p id="bb5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ng">让你内心的极客赢！</em> </strong></p><p id="179c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ng">更多内容请看</em><a class="ae mf" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ng">plain English . io</em></strong></a></p></div></div>    
</body>
</html>