<html>
<head>
<title>The Basics of Linked Lists with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现链表的基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/linked-list-the-basics-with-javascript-pt-1-60404df9ed?source=collection_archive---------16-----------------------#2021-07-06">https://javascript.plainenglish.io/linked-list-the-basics-with-javascript-pt-1-60404df9ed?source=collection_archive---------16-----------------------#2021-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e01" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1cd49161e18a64960723f696611ec553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FIcvwHY4cOnPW7Tu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0a7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">想象一个暴徒袭击。想象一下，一个颤抖的小家伙向教父寻求帮助。想象一下，教父向军师下命令，他向他的助手下达指令。助手走向他的伙伴，递给他一把枪，伙伴找到了那个人，并把他变成了零。那是一个链表。每个节点都有两个属性:数据和对下一个节点的引用。</p><p id="becc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在链表中搜索需要花费很长时间，因为您必须遍历整个列表才能找到一个节点，如果您要查找的节点是第一个节点，这可能很好，但是想象一下查找1，000，000，000个节点。</p><p id="f431" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">插入和删除列表相对容易，因为您需要做的只是改变它的参考点，但是读取一个节点需要的时间和该节点的编号从0开始一样多。这与数组是一致的，因为从数组中获取数据非常简单。您提到了索引和boom，您就说到点子上了，但是插入和删除对计算机来说需要“永远”的时间，因为您必须将新的更短/更大的数组移动到新的内存位置。</p><p id="8804" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript中的链表实际上只是以键值对的形式存在于彼此内部的对象，这并不理想，但是我现在已经习惯了JavaScript，所以我把它们放在一起。当我对Java更熟悉时，我也会为它编写一篇文章。</p><p id="0f5d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我可以继续谈论这个理论，但这是我喜欢学习的方式。我继续在黑客银行或类似的网站上解决一些简单的问题。像那样的学习对我来说通常会更深入。</p><p id="46ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于链表的任何理论，访问<a class="ae ks" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">维基百科页面</a>。</p><p id="faad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不会每次都重写这段代码，所以节点和链接列表类就在这里。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="39f5" class="lu lv in lq b gy lw lx l ly lz">class Node {<br/>   constructor(data, next) {<br/>      this.data = data;<br/>      this.next = null;<br/>    }<br/> };<br/> <br/> class SinglyLinkedList {<br/>    constructor() {<br/>       this.head = null;<br/>       this.tail = null;<br/>    }<br/> };</span></pre><p id="828b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将把链表作为函数参数的头。</p><p id="95ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以首先，让我们从基础开始，让我们尝试<strong class="kv io">在链表</strong>的开始插入一个节点。</p><p id="651e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">逻辑是这样的:</p><p id="9181" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.创建新节点</p><p id="d8b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果链表中没有节点，那么我们想要的节点就成为头</p><p id="2916" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.否则，我们初始化的节点引用头部，实际上成为链表的头部</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="7f87" class="lu lv in lq b gy lw lx l ly lz">const insertNodeAtHead =&gt; (head, data) = {</span><span id="43b2" class="lu lv in lq b gy ma lx l ly lz">   let newNode = new Node(data);</span><span id="4053" class="lu lv in lq b gy ma lx l ly lz">   if (head == null) {</span><span id="2517" class="lu lv in lq b gy ma lx l ly lz">   return newNode;</span><span id="ce85" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="46c3" class="lu lv in lq b gy ma lx l ly lz">   newNode.next = head;</span><span id="3a82" class="lu lv in lq b gy ma lx l ly lz">   return newNode;</span><span id="5181" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="6d11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了。既然我们已经知道了如何添加链表，让我们看看如何<strong class="kv io">打印链表</strong>，然后再尝试更多的操作。</p><p id="fd1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.打印节点的数据</p><p id="e2e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.移动到下一个节点</p><p id="0bad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.这样做，直到头部为空(这将带我们从列表的开始到结束)</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9eb2" class="lu lv in lq b gy lw lx l ly lz">const printLinkedList = (head) =&gt; {</span><span id="e349" class="lu lv in lq b gy ma lx l ly lz">   while (head != null) {</span><span id="c978" class="lu lv in lq b gy ma lx l ly lz">   console.log(head.data);</span><span id="4502" class="lu lv in lq b gy ma lx l ly lz">   head = head.next;</span><span id="af4b" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="e5ae" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="185e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好的，接下来，让我们尝试<strong class="kv io">在链表的尾部插入一个节点</strong>。</p><p id="3e90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.创建新节点</p><p id="6e35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果没有头节点，则分配新节点作为头并返回</p><p id="7540" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.接下来，让我们指定一个临时变量“current”作为头</p><p id="c0e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.继续将下一个节点分配给当前节点，直到当前节点的下一个为空(这将把我们带到链表的末尾)</p><p id="8b58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.现在我们在最后一个节点，分配新节点作为当前的下一个节点</p><p id="ac99" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">6.返回链表</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6e76" class="lu lv in lq b gy lw lx l ly lz">const insertNodeAtTail = (head, data) =&gt; {</span><span id="dc32" class="lu lv in lq b gy ma lx l ly lz">   let newNode = new Node(data);</span><span id="40d0" class="lu lv in lq b gy ma lx l ly lz">   if (!head) {</span><span id="a1fb" class="lu lv in lq b gy ma lx l ly lz">      head = newNode;</span><span id="1e52" class="lu lv in lq b gy ma lx l ly lz">      return head;</span><span id="a97f" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="1df4" class="lu lv in lq b gy ma lx l ly lz">   let current = head;</span><span id="1565" class="lu lv in lq b gy ma lx l ly lz">   while (current.next) {</span><span id="fd00" class="lu lv in lq b gy ma lx l ly lz">      current = current.next;</span><span id="8332" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="e1f2" class="lu lv in lq b gy ma lx l ly lz">   current.next = newNode;</span><span id="70fc" class="lu lv in lq b gy ma lx l ly lz">   return head;</span><span id="d53e" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="295d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们继续删除一些节点之前，让我们再做一次插入。让<strong class="kv io">插入到一个特定的位置</strong>。该函数有链表头、要输入的数据和节点要插入的位置等参数。</p><p id="e283" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.声明一个新节点</p><p id="5814" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.声明一个变量currentPosition = 1</p><p id="debd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.将压头分配给临时可变电流</p><p id="d6d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.如果位置在0，那么新节点的下一个引用将在头部，我们从新节点返回链表</p><p id="ddb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.否则，我们使用position作为固定点，curentPosition作为移动点，将链表移动到位置之前的节点</p><p id="0c19" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">6.在那里，我们添加新节点的下一个引用到位置</p><p id="9edd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">7.我们将当前位置节点的下一个引用更改为新节点</p><p id="3784" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">8.返回链表</p><p id="ba04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我画的一张图，为了在脑子里解决这个问题…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mb"><img src="../Images/b3fae937a498fbcaddc28320c691ab91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyCj7ujn6hbFw2NEtdKoXw.jpeg"/></div></div></figure><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a246" class="lu lv in lq b gy lw lx l ly lz"><br/>const insertNodeAtPosition = (head, data, position) =&gt; {</span><span id="7a8b" class="lu lv in lq b gy ma lx l ly lz">   let newNode = new Node(data);</span><span id="91ec" class="lu lv in lq b gy ma lx l ly lz">   let current = head;</span><span id="4b3b" class="lu lv in lq b gy ma lx l ly lz">   let currentPosition = 1;</span><span id="cc97" class="lu lv in lq b gy ma lx l ly lz">   if (position == 0) {</span><span id="e493" class="lu lv in lq b gy ma lx l ly lz">      newNode.next = head;</span><span id="b3b0" class="lu lv in lq b gy ma lx l ly lz">      return newNode;</span><span id="a683" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="b01d" class="lu lv in lq b gy ma lx l ly lz">   while (currentPosition &lt; position) {</span><span id="b90d" class="lu lv in lq b gy ma lx l ly lz">      current = current.next;</span><span id="c033" class="lu lv in lq b gy ma lx l ly lz">      currentPosition++;</span><span id="fc86" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="1037" class="lu lv in lq b gy ma lx l ly lz">   newNode.next = current.next;</span><span id="abd6" class="lu lv in lq b gy ma lx l ly lz">   current.next = newNode;</span><span id="9d43" class="lu lv in lq b gy ma lx l ly lz">   return head;</span><span id="8e34" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="74c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">酷毙了。最后，让我们试着<strong class="kv io">从链表</strong>中删除一个节点。</p><p id="15a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript有一个垃圾清除系统，就像大多数城市一样。你把它排除在外，不知何故它就消失了。所以我们真正需要做的就是删除对一个节点的下一个引用，它就会消失。</p><p id="f1c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1.将head赋给一个名为node的变量</p><p id="2f30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.如果位置是0，那么我们要删除第一个并返回其余的</p><p id="f849" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.让我们创建一个变量currentPosition，并将其初始化为1(以反映列表的第一个位置)</p><p id="bd1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.为了到达我们想要删除的节点之前的节点，我们将把下一个节点分配给当前节点，并增加currentPosition，直到它比位置小1</p><p id="b7aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5.现在我们在需要删除的节点之前，我们把它分配到下一个节点之后。就像我们跳过想要删除的节点，并移除对它的引用。</p><p id="f68c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">6.返回链表</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="0733" class="lu lv in lq b gy lw lx l ly lz">const deleteNode(head, position) {</span><span id="c31f" class="lu lv in lq b gy ma lx l ly lz">   let node = head;</span><span id="cbb8" class="lu lv in lq b gy ma lx l ly lz">   let currentPosition = 1;</span><span id="c102" class="lu lv in lq b gy ma lx l ly lz">   if (position == 0) {</span><span id="a096" class="lu lv in lq b gy ma lx l ly lz">      return node.next;</span><span id="3eb3" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="b5e2" class="lu lv in lq b gy ma lx l ly lz">   while (currentPosition &lt; position) {</span><span id="3c2b" class="lu lv in lq b gy ma lx l ly lz">      node = node.next;</span><span id="ebd6" class="lu lv in lq b gy ma lx l ly lz">      currentPosition++;</span><span id="a4d9" class="lu lv in lq b gy ma lx l ly lz">   }</span><span id="a8fb" class="lu lv in lq b gy ma lx l ly lz">   node.next = node.next.next;</span><span id="4aff" class="lu lv in lq b gy ma lx l ly lz">   return head;</span><span id="933d" class="lu lv in lq b gy ma lx l ly lz">}</span></pre><p id="5934" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有几个问题我想解决，但我会把它分成两个帖子，这样更具可读性。所以，去喝杯水，看看第二部分。</p><p id="e9c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mc">更多内容尽在</em><a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>