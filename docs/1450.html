<html>
<head>
<title>React App Performance Optimization: The Definitive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用性能优化:权威指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-app-performance-optimization-the-definitive-guide-9b658be3b6e4?source=collection_archive---------1-----------------------#2021-03-28">https://javascript.plainenglish.io/react-app-performance-optimization-the-definitive-guide-9b658be3b6e4?source=collection_archive---------1-----------------------#2021-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0c62" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">提高React应用速度的技巧</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3ecc9203d0e38929306c63d70a6e0d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQyZx8fb-rur6NO7U33MXA.png"/></div></div></figure><h1 id="2df5" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">React中的UI是如何渲染的？</h1><p id="a935" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React中，您的UI是通过更新一个叫做DOM(文档对象模型)的东西来呈现的。用基本的外行话来说，DOM类似于对象和节点的树状结构。</p><p id="7551" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然而，在React中，HTML不是DOM的根节点。事实上，它只是Javascript原型链中的一个节点，因此它可以获得计算样式、属性或操作单个节点的函数。</p><p id="7daa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">简单来说，React中的DOM是一个标准，它定义了如何获取、更新或操作HTML元素。</p><p id="4d8f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React DOM知道如何呈现页面，但是跟踪每个正在更新的节点和组件就不那么智能了。</p><p id="1c80" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，假设您的SPA(单页应用程序)上有一个10项的列表，当您的用户与UI交互时，您必须更新其中的一项。使用DOM，您将最终更新所有组件，因为整个列表将被重新呈现。</p><p id="8bfe" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这就是虚拟DOM概念发挥作用的地方。虚拟DOM是HTML DOM的本地副本。</p><p id="7faa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">让我们回到我们的列表示例，看看虚拟DOM将如何让React呈现UI。</p><p id="b057" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当用户与UI交互时，React将以虚拟DOM的形式创建一个副本，并在将真实DOM与虚拟DOM进行比较后更新UI。这样，需要更新的项目将在不影响其他项目的情况下进行更新。</p><h1 id="b4f9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">虚拟DOM有什么不好？</h1><p id="4767" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在上一节中，您已经了解了虚拟DOM的优点。</p><p id="c045" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，让我们熟悉一下虚拟DOM的缺点，它是React中许多性能问题的罪魁祸首。</p><p id="4b8a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React利用了一个<strong class="li io"> diff算法</strong>来最小化节点上的操作。然而，算法本身并不完美。</p><p id="5a33" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">例如，让我们看看下面给出的GIF，它类似于一个react DOM树。假设黄色节点的值已经改变，需要更新。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mh"><img src="../Images/c5320777b2467f4437d495ab4f31bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UClTRkJX6jUfanss.gif"/></div></div></figure><p id="a2ea" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">正如您在上面看到的，React继续渲染整个子树，而不是渲染相关的组件。当这些不必要的渲染在React应用程序中闲置时，它们会耗尽不必要的CPU和内存资源，这对React应用程序来说是致命的。这就是为什么他们被称为<strong class="li io">浪费渲染</strong>。</p><p id="f7d5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">谈到虚拟世界，Reactjs中大约一半的性能相关问题源于:</p><ul class=""><li id="6ae0" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated"><strong class="li io">不更新DOM的组件</strong>中的冗余处理</li><li id="0fc7" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><strong class="li io"> Diff算法</strong> <strong class="li io">不断更新不需要更新的叶节点</strong></li><li id="98b9" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><strong class="li io">由于Diff算法更新组件，CPU计算量很大</strong></li></ul></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="9e8b" class="ko kp in bd kq kr nd kt ku kv ne kx ky jt nf ju la jw ng jx lc jz nh ka le lf bi translated">加快反应速度的工具</h1><h2 id="4d03" class="ni kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">1.你为什么更新</h2><p id="a602" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><code class="fe nu nv nw nx b"><a class="ae ny" href="https://github.com/maicki/why-did-you-update" rel="noopener ugc nofollow" target="_blank">why-did-you-update</a></code>函数<strong class="li io">检测不必要的组件渲染</strong>。具体来说，它指出了组件的render方法被调用的情况，即使没有发生任何变化。您可以通过简单的npm安装来设置它:</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="a31b" class="ni kp in nx b gy od oe l of og">npm install --save why-did-you-update</span></pre><p id="759f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">接下来，在您的应用程序代码中包含以下代码片段:</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="747c" class="ni kp in nx b gy od oe l of og">import React from 'react'</span><span id="7520" class="ni kp in nx b gy oh oe l of og">if (process.env.NODE_ENV !== 'production') {<br/>    const {whyDidYouUpdate} = require('why-did-you-update')<br/>    whyDidYouUpdate(React)<br/>}</span></pre><p id="771b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">确保在您的最终版本中禁用这个特性，这样它就不会降低用户端的速度。</p><h2 id="e368" class="ni kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">2.React开发人员工具</h2><p id="f46c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Chrome的<a class="ae ny" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React开发者工具</a>扩展可以突出显示组件更新，进一步帮助你<strong class="li io">识别不必要的渲染周期</strong>。安装完扩展后，通过选择Chrome DevTools中的React选项卡打开它，然后选中“高亮显示更新”框。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/2526ff98308a551cdc88a6d1f414e961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zR0vHIKAXGngIK6dPLxpw.png"/></div></div></figure><p id="40eb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当您处理项目时，重新渲染组件现在应该以蓝色、绿色、黄色或红色高亮显示。较冷的颜色表示更新最不频繁的组件，而色谱中较暖的一侧表示更新更频繁。</p><p id="2174" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，你应该会看到很多黄色和红色的UI元素，比如滑块。但是，如果单击一个按钮会让您看到红色，那么您可能正在进行一些不必要的渲染。</p><h2 id="d04c" class="ni kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">3.Chrome DevTools性能时间表</h2><p id="345d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果您使用的是<strong class="li io"> React 15.4.0或更高版本</strong>，那么可以利用Chrome的性能时间线来精确定位组件的安装、更新和卸载时间。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/ac9ca70d8cb44ff22c3e9e1c303ea611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sB3xaOL2B9w-igdond1GIA.jpeg"/></div></div></figure><p id="53cb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">此外，您可以可视化组件的生命周期，并将它们相互比较。由于该功能依赖于用户定时API，因此只能在Chrome、Edge和Internet Explorer中使用。</p><p id="4780" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在我们知道了react中的工具和故障性能的根本原因，让我们了解如何优化React应用程序的性能。</p><h1 id="97f9" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">1.实现shouldComponentUpdate以防止不必要的呈现</h1><p id="ffee" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">移动应用程序中大多数与性能相关的问题往往通过实现较小的更改来解决，但这些更改足以使您的应用程序更快。</p><p id="75b7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">其中一个看起来很小但是能够为你的React应用提供足够可测量和可感知的性能提升的变化是<strong class="li io"> shouldComponentUpdate方法</strong>。</p><p id="6dd9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">顾名思义，shouldComponentUpdate是一个react生命周期挂钩，使用它您可以指示React to <strong class="li io">避免重新呈现一个给定的组件，如果它的状态没有改变</strong>。</p><p id="a8bc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React开发者工具扩展有一个“高亮更新”选项，我们用它来发现导致渲染浪费的组件。</p><p id="3329" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">假设您有一个由许多具有复杂嵌套结构的组件组成的列表，并且列表中的一项发生了变化。你的应用程序从列表中呈现不必要的组件是对资源的浪费。通过实现shouldComponentUpdate，您基本上可以告诉React忽略除了发生变化的组件之外的所有组件。</p><h1 id="29a3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">2.由于使用PureComponent进行不必要的渲染，提高了性能</h1><p id="5cfa" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果使用shouldComponentUpdate没有获得任何性能提升，那么您也可以尝试使用<strong class="li io">纯组件</strong>，它是React组件类的更高性能版本。纯组件的使用大大提高了性能，因为它<strong class="li io">减少了应用程序中渲染操作的数量</strong>。</p><p id="790a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">Pure component与React中的component类完全相似，除了它<strong class="li io">自动为您处理shouldComponentUpdate方法</strong>之外。</p><h1 id="f9d7" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">3.通过代码分割进一步优化应用加载时间</h1><p id="3544" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果你想让你的用户更快地加载网页，那么你只加载用户需要的代码是很有意义的。</p><p id="8926" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">尤其是在单页应用程序(SPA)的情况下，当您希望您的用户查看登录页面时，没有什么特别的理由要加载组成管理面板的代码。有道理，对吧？？</p><p id="224a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这就是代码分割发挥作用的地方。<strong class="li io">对你的应用进行代码拆分可以帮助你“延迟加载”用户当前需要的东西，这可以极大地提高你的应用的性能。</strong></p><p id="ab8a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">通过利用代码分割技术，将Javascript包分成三个不同的类别，Pinterest将它们的包大小从650KB降低到150KB。在Pinterest的案例中，代码拆分不仅减少了包的大小，还将应用程序的加载时间从23秒缩短到了6.5秒。</p><blockquote class="ok"><p id="6967" class="ol om in bd on oo op oq or os ot mb dk translated">如果你正在使用webpack，你可以通过使用<a class="ae ny" href="https://webpack.js.org/plugins/commons-chunk-plugin/" rel="noopener ugc nofollow" target="_blank"><strong class="ak">CommonsChunkPlugin</strong></a>将你的代码分割成多个文件。</p><p id="350b" class="ol om in bd on oo op oq or os ot mb dk translated">如果您不喜欢使用web-pack，那么您可以使用<a class="ae ny" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank"><strong class="ak">react loadable</strong></a>库来拆分您的捆绑代码，以便延迟加载。</p></blockquote><h1 id="6b3d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt ou ju la jw ov jx lc jz ow ka le lf bi translated">4.用SSR反应性能</h1><p id="bd83" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React是构建单页面应用程序(SPA)的一个不可思议的框架。然而，由于它是一个客户端框架，我们在构建应用程序时可能会遇到以下性能问题:</p><ul class=""><li id="93a7" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated">糟糕的搜索引擎优化:由于Javascript相关的内容是在客户端呈现的，雅虎、百度和必应等搜索引擎将无法对它们进行索引，因为它们只能看到与负面搜索引擎优化相关的空白页面。</li><li id="893e" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><strong class="li io">应用加载时间慢:</strong>应用初始加载时，浏览器中没有JavaScript的缓存。如果应用程序很大，最初加载应用程序所花费的时间也会很长。</li></ul><p id="b97b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">[ <strong class="li io">注意:</strong> <a class="ae ny" href="https://webmasters.googleblog.com/2017/12/rendering-ajax-crawling-pages.html" rel="noopener ugc nofollow" target="_blank">谷歌机器人现在能够在某些情况下渲染Javascript </a>。也就是说，如果你不担心雅虎、必应、百度、duckduckgo等其他搜索引擎的SEO。，您的水疗中心不需要优化任何东西，也不会有问题]</p><p id="bafd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然而，如果你真的关心谷歌以外的搜索引擎的搜索引擎优化，那么使用服务器端渲染并构建一个同构的React应用程序是很有意义的。</p><p id="4076" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在服务器端呈现中，JavaScript相关内容最初是从服务器呈现的。在初始渲染发生后，客户端脚本接管，它像普通SPA一样工作。</p><p id="2c4d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">但是在React中实现SSR会带来很多代码复杂性，考虑到Node.js等优秀服务器的需求，设置它的成本是巨大的。</p><p id="ddbb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然而，如果你真的想提高你的应用程序的加载速度，那么你可以用Next.js 实现<strong class="li io"> SSR，这将节省你为SSR设置服务器的大量时间。</strong></p><h1 id="fa69" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">5.通过延迟加载图像来缩短应用程序的加载时间</h1><p id="3254" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在前面的章节中，我谈到了只加载必要的代码，这大大提高了应用程序的加载速度。但是，图像呢？</p><p id="21cb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">图像是最重要的资源，你的用户可能永远不会看到，直到一个网页完全加载。由于以下原因，它们可能会降低React应用程序的性能:</p><ul class=""><li id="735b" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated"><strong class="li io">数据浪费:</strong>加载图像不一定会导致数据的大量使用，考虑到你的用户不能正确地看到它们，这完全是一种浪费。</li><li id="cb2e" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><strong class="li io">设备资源和电池的不必要消耗:</strong>从服务器下载图像后，浏览器必须对其进行解码，并将内容呈现到UI，这需要大量消耗设备资源和电池。</li></ul><p id="bc00" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">为了缩短应用程序加载时间，一个经验法则是在需要的时候加载图片，而不是在应用程序页面加载的时候加载。这被称为<strong class="li io">图像的延迟加载</strong>。</p><p id="6c43" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">Pinterest在其渐进式网络应用程序中使用渐进式延迟加载技术来加载图像。</p><p id="f26c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">Pinterest最初在页面加载时使用了占位符。图像在初始加载时看起来很模糊，但一旦页面完全加载，图像就会完全加载。</p><blockquote class="ok"><p id="4c15" class="ol om in bd on oo op oq or os ot mb dk translated">React app中图片的延迟加载可以通过使用<a class="ae ny" href="https://github.com/jasonslyvia/react-lazyload" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> React Lazyload库来实现。</strong> </a></p></blockquote><h1 id="4d49" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt ou ju la jw ov jx lc jz ow ka le lf bi translated">6.使用React虚拟化列表优化列表呈现</h1><p id="5408" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">列表和网格视图是React应用程序中显示数据的常见模式。当React中有一个很大的列表(比如1000多个条目)时，应该在滚动时呈现元素，在快速向下滚动到1000个条目后，您的UI可能会有一点滞后。</p><p id="b20a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，<strong class="li io">虚拟渲染</strong>开始发挥作用。它让你只渲染30个组件，而不是渲染所有的组件。或者40岁或者10岁。无论数量多少，在一天结束时，您将呈现组件的一个小的子集。这给了你一个很大的性能提升。</p><blockquote class="ok"><p id="4dbd" class="ol om in bd on oo op oq or os ot mb dk translated"><a class="ae ny" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> React虚拟化列表</strong> </a>是一个考虑了虚拟渲染技术的库。每当你觉得你的UI由于大量的数据列表而滞后时，你可以使用React虚拟化列表来提高它的性能。</p></blockquote><h1 id="d58a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt ou ju la jw ov jx lc jz ow ka le lf bi translated">7.通过为组件使用正确的键来优化反应列表性能</h1><p id="7747" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">React使用<strong class="li io">键属性</strong>来决定哪些元素可以在下一个渲染阶段重用。这些键对于更新动态列表中的元素非常重要。</p><p id="6b3b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">React通过比较新元素的键和前一个元素的键来进行更新。在这个过程中，它还可能呈现具有新键的组件，并取消呈现具有不再使用的键的组件。</p><p id="8743" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我发现大多数开发人员在呈现列表时错误地将项目的索引假定为键，这就是他们遇到性能问题的原因，例如:</p><ul class=""><li id="57f6" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated">列表中不必要的重新呈现</li><li id="ed4f" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">不必要的错误，可能会使用户界面在滚动时没有反应</li></ul><p id="0365" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">使用列表中的关键属性有助于保持列表的一致性。顺便提一下，一定要记住您的键值<strong class="li io">对于列表</strong>中的每个组件都应该是唯一的。</p><p id="5016" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">从今以后，在React中实现list时要明智地使用key={ }。</p><h1 id="9559" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">8.为基于React的PWA识别有问题的包</h1><p id="bf63" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">优化React应用包大小的第一步是识别生产构建中有问题的代码块。</p><p id="d28f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果您在React中使用webpack进行简单的捆绑，那么您可以使用<a class="ae ny" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> Webpack捆绑包分析器插件</a>来分析您的构建依赖关系。</p><p id="cd2d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在Webpack bundle analyzer插件的帮助下，Pinterest能够识别出他们构建中的大量重复代码。他们将重复的代码从异步程序块转移到主程序块，这将所有延迟加载程序块的大小减少了90 %。</p><p id="77d8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">下面提到了一些更优秀的Webpack插件，它们可能有助于您评估构建中有问题的代码块:</p><ul class=""><li id="27fc" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated"><a class="ae ny" href="https://github.com/webpack/compression-webpack-plugin" rel="noopener ugc nofollow" target="_blank">压缩-网络包-插件</a></li><li id="873e" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae ny" href="https://www.npmjs.com/package/uglifyjs-webpack-plugin" rel="noopener ugc nofollow" target="_blank">丑陋的js插件</a></li><li id="25fa" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated"><a class="ae ny" href="https://webpack.js.org/plugins/ignore-plugin/" rel="noopener ugc nofollow" target="_blank">忽略插件</a></li></ul><p id="565f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">[ <strong class="li io">注意:</strong>在使用上述插件之前，请确保对它们进行评估，以便您可以提前了解使用情况]</p><h1 id="b0f2" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">9.更好的摇树</h1><p id="0470" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">树抖动是<strong class="li io">从包</strong>中移除未使用的或死代码的过程。当使用像Lodash这样的实用程序库时，这一点尤其重要，因为您不需要导入库的所有特性。</p><p id="6e80" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">术语“树摇动”来自于你的应用程序的心理模型和它作为树状结构的依赖关系。树中的每个节点代表一个为应用程序提供不同功能的依赖项。在现代应用中，这些依赖关系是通过<a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">静态</a> <code class="fe nu nv nw nx b"><a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">import</a></code> <a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">语句</a>引入的，如下所示:</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="0bdb" class="ni kp in nx b gy od oe l of og">// Import all the array utilities!<br/>import arrayUtils from "array-utils";</span></pre><p id="0913" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">通过利用我们如何使用静态<code class="fe nu nv nw nx b">import</code>语句来拉入ES6模块的特定部分，树抖动解决了大量<a class="ae ny" href="https://developers.google.com/web/updates/2018/05/lighthouse#unused_javascript" rel="noopener ugc nofollow" target="_blank">未使用的JavaScript </a>:</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="0c28" class="ni kp in nx b gy od oe l of og">// Import only some of the utilities!<br/>import { unique, implode, explode } from "array-utils";</span></pre><p id="7723" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个<code class="fe nu nv nw nx b">import</code>例子和前一个例子的不同之处在于，它不是从<code class="fe nu nv nw nx b">"array-utils"</code>模块导入<em class="ox">所有的东西</em>(这可能是很多东西！)，这个例子只导入它的特定部分。在开发版本中，这并不会真正改变什么，因为整个模块都会被导入。然而，在生产版本中，我们可以配置webpack从没有明确导入的ES6模块中“摆脱”<code class="fe nu nv nw nx b"><a class="ae ny" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank">export</a></code> <a class="ae ny" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank"> s </a>，使得生产版本更小。</p><h1 id="3fbd" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">10.预加载和预取<strong class="ak">资源</strong></h1><p id="be2c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io">预加载您有高置信度的资源将在当前页面上使用。预取可能用于跨多个导航边界的未来导航的资源。</strong></p><p id="a166" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">预加载是对浏览器的早期获取指令，以请求页面所需的资源<em class="ox"/>(关键脚本、网络字体、英雄图像)。指定<code class="fe nu nv nw nx b">as</code>属性很重要——它有助于浏览器合理安排下载的优先级和时间。</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="f287" class="ni kp in nx b gy od oe l of og">&lt;link rel="preload" href="comic-sans.woff2" as="font" /&gt;</span></pre><p id="553d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe nu nv nw nx b">as</code>可以是你可以在浏览器中下载的任何东西:<code class="fe nu nv nw nx b">style</code>用于样式表，<code class="fe nu nv nw nx b">script</code>用于脚本，<code class="fe nu nv nw nx b">font</code>用于字体，<code class="fe nu nv nw nx b">fetch</code>用于通过<code class="fe nu nv nw nx b">fetch()</code>或<code class="fe nu nv nw nx b">XMLHttpRequest.</code>下载的资源</p><p id="7c84" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">预取服务于一个稍微不同的用例——用户的未来导航(例如在视图或页面之间),其中获取的资源和请求需要跨导航保持。预取是一种通知浏览器可能被请求的资源并在需要之前获取它们的方式。</p><p id="a896" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">一旦加载了当前页面所需的资源，并且当浏览器处于空闲状态时，就会执行此操作。对于服务器端渲染的应用，Node.js中支持HTTP/2 Push API。</p><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="36f7" class="ni kp in nx b gy od oe l of og">&lt;link rel="prefetch" href="/style.css" as="style" /&gt;</span></pre><p id="4e28" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">指定<code class="fe nu nv nw nx b">as</code>属性很重要——它有助于浏览器正确地安排下载的优先级和时间。如果页面A发起对页面B所需的关键资源的预取请求，则关键资源和导航请求可以并行完成。如果我们在这个用例中使用preload，它会在页面A的unload中被立即取消。</p><p id="973b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在预加载和预取之间，我们得到为当前导航或未来导航加载关键资源的解决方案。</p><h1 id="1346" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">11.使用记忆</h1><p id="f663" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">记忆化是一个允许我们缓存递归/昂贵的函数调用的值的过程，以便下次用相同的参数调用函数时，返回缓存的值，而不必重新计算函数。</p><p id="4e89" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这确保了我们的应用程序运行得更快，因为我们通过返回一个已经存储在内存中的值来避免重新执行函数所花费的时间。</p><h2 id="fa76" class="ni kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">为什么在React中使用记忆？</h2><p id="bc9a" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在React功能组件中，当组件中的道具改变时，默认情况下整个组件会重新渲染。换句话说，如果组件中的任何值更新，整个组件将重新呈现，包括其值/属性没有改变的函数/组件。<br/>在React中记忆的方法:</p><ul class=""><li id="fa4c" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated">是一个高阶组件，我们可以用它来包装那些我们不想重新渲染的组件，除非其中的道具发生了变化</li></ul><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="c275" class="ni kp in nx b gy od oe l of og">const MyComponent = React.memo(function MyComponent(props) {<br/>  /* render using props */<br/>});</span><span id="e89d" class="ni kp in nx b gy oh oe l of og"><br/>export function Movie({ title, releaseDate }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;Movie title: {title}&lt;/div&gt;<br/>      &lt;div&gt;Release date: {releaseDate}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export const MemoizedMovie = React.memo(Movie);</span></pre><ul class=""><li id="1c34" class="mi mj in li b lj mc lm md lp mk lt ml lx mm mb mn mo mp mq bi translated"><code class="fe nu nv nw nx b">useMemo()</code>是一个React钩子，我们可以用它来包装组件中的函数。我们可以利用这一点来确保只有当其中一个依赖项发生变化时，才重新计算该函数中的值</li></ul><pre class="kd ke kf kg gt nz nx oa ob aw oc bi"><span id="b280" class="ni kp in nx b gy od oe l of og">const memoizedValue = React.useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="fbef" class="ko kp in bd kq kr nd kt ku kv ne kx ky jt nf ju la jw ng jx lc jz nh ka le lf bi translated">结论</h1><p id="b8b4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">微调React应用程序的关键可能在于确保组件只在绝对需要时更新。不言而喻，但是一定要把性能优化作为一个常规的优先事项，尤其是当你对你的应用程序进行重大修改的时候。不要忘记在做出改变之前和之后运行基准来跟踪你的进展。</p><p id="e2d6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们已经介绍了大多数加速和优化React应用程序性能的技术。我希望你已经发现这是有用的。</p><p id="f671" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">感谢您的阅读:)</p><h2 id="480f" class="ni kp in bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">进一步阅读</h2><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/5-tools-practices-to-help-you-develop-faster-in-react-b884c1b20fc2"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd io gy z fp pg fr fs ph fu fw im bi translated">帮助您在React中更快开发的5种工具和实践</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">React工具、技巧和最佳实践将帮助您更快地构建应用</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp km pb"/></div></div></a></div><p id="21e3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><em class="ox">更多内容请看</em><a class="ae ny" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="ox">plain English . io</em></strong></a><em class="ox">。报名参加我们的</em> <a class="ae ny" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> <em class="ox">免费周报</em> </strong> </a> <em class="ox">。关注我们关于</em><a class="ae ny" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="ox">Twitter</em></strong></a><a class="ae ny" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="ox">LinkedIn</em></strong></a><em class="ox"/><a class="ae ny" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="ox">YouTube</em></strong></a><em class="ox"/><a class="ae ny" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="li io"><em class="ox">不和</em> </strong> </a> <em class="ox">。</em></p></div></div>    
</body>
</html>