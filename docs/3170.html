<html>
<head>
<title>Don’t Make These Mistakes While Converting Your Node.js App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在转换Node.js应用程序时不要犯这些错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ecmascript-modules-are-the-new-default-code-reuse-standard-dont-make-these-mistakes-converting-9315f02cf44b?source=collection_archive---------11-----------------------#2021-06-27">https://javascript.plainenglish.io/ecmascript-modules-are-the-new-default-code-reuse-standard-dont-make-these-mistakes-converting-9315f02cf44b?source=collection_archive---------11-----------------------#2021-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="69af" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">ECMAScript模块是新的默认代码重用标准</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0e3bc02373962e781b9b8065aa8b2fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-cKoCQu0kJU2Ffz"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sigmund</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="38d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">ECMAScript模块是封装JavaScript代码以供将来重用的官方标准格式。Es6模块现在在Node.js 12和更高版本中得到完全支持，所以是时候开始使用它们了。</p><p id="22e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，JavaScript开发人员和节点库通常将commonjs用于模块。如果您在过去几年中使用过typescript，您将会熟悉应用程序中的模块导入语法。大多数typescript应用程序不使用commonjs <code class="fe lp lq lr ls b">require(“module”)</code>，而是使用某种变体的<code class="fe lp lq lr ls b">import module from “module”</code>。</p><p id="2025" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，Typescript会将这个导入语法转换成commonjs require语句。这一步在现代Node.js应用程序中是不必要的。你可以在你的编译代码中直接使用<code class="fe lp lq lr ls b">import module from “module”</code>。</p><p id="e2c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你使用typescript，你可以修改你的<strong class="kv io"> tsconfig </strong>设置来输出ECMAScript (ES6)模块，这样就可以了。如果你不使用typescript，如果你想更新你的应用程序，你可能需要做一些重写。</p><p id="ffa1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我升级Node.js应用程序以使用ECMAScript模块(如配置typescript、设置jest、正确配置package.json等)时，我花了一些时间和调查来找出这些问题的解决方案。</p><h1 id="472f" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">对ECMAScript 6 (ES6)模块的Node.js支持</h1><p id="0c72" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">从Node.js 14开始，对ECMAScript模块的支持是稳定的。因此，使用该功能没有任何问题。</p><p id="3872" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你还在生产中使用Node.js 12(这个我是有罪的！)，那么ECMAScript模块特性将被标记为“实验性的”,因此您应该谨慎使用。但是支持是完全存在的。请注意，Node.js 12即将停止使用，需要来自<em class="mq"> 2022/04/30 </em>的支持。因此，您应该考虑升级到Node.js 14。</p><p id="0e12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，如果您提供了一个其他应用程序依赖的库，那么留意您的客户支持的Node.js版本是值得的。</p><p id="038e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一般来说，截至2021年，大多数积极开发的Node.js应用程序都应该原生支持ECMAScript模块。</p><h1 id="3b23" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">package.json类型属性</h1><p id="7a97" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在Node.js中使用ECMAScript模块有两种主要方式。您可以在文件中使用<code class="fe lp lq lr ls b">.mjs</code>后缀，或者在package.json中设置<code class="fe lp lq lr ls b">type: "module"</code>属性。在使用TypeScript时，<code class="fe lp lq lr ls b">.mjs</code>后缀实际上并不相关或不实用，因此在package.json文件中设置type属性更容易。</p><p id="aa8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑下面的示例package.json文件类型，注意我已经显式地将<code class="fe lp lq lr ls b">type</code>设置为module。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="1dc7" class="mv lu in ls b gy mw mx l my mz">"name": "shared-api-client",<br/>  "version": "1.0.0",<br/>  "description": "OpenAPI client for shared-api-client",<br/>  "author": "OpenAPI-Generator",<br/>  "main": "./dist/index.js",<br/>  "typings": "./dist/index.d.ts",<br/>  "type": "module",</span></pre><p id="5f1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这<strong class="kv io">非常重要</strong>，因为它告诉你的包的消费者从你的代码中加载模块作为ECMAScript模块，而不是CommonJS模块。</p><p id="2dc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您发现您发布的模块有一个问题，某个工具不能正确地从其中导入模块，那么您可能没有设置type属性，其他Node.js工具会认为您希望通过CommonJS加载模块。它们会断裂。</p><p id="6275" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果您已经配置了实验模块，您可以让Jest本机使用ES6模块。</p><p id="89a5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果你的包使用导入/导出，而你没有告诉Jest这个包使用的是ES6模块，那么它会尝试把它作为CommonJS加载，Jest就会崩溃。您将得到一个错误:<em class="mq"> Jest "SyntaxError:意外的令牌导出。"</em></p><p id="77c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您要发布一个包含ECMAScript ES6模块的包，请记住设置<code class="fe lp lq lr ls b">type: "module"</code>。</p><h1 id="d684" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">使用顶级await(在TypeScript中)</h1><p id="e531" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">await通常在异步函数中调用。没有办法在函数之外拥有一个。这里有一个例子:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="cc28" class="mv lu in ls b gy mw mx l my mz">import fs from 'fs/promises'<br/>// this is ok because it's in an async function<br/>const myFunc = async () =&gt; {<br/>  await fs.readFile('path')<br/>}<br/><br/>// this fails to compile in tsc because it is at the top level of a module<br/>await fs.readFile('path')<br/><br/>// just to make this a module<br/>export {}</span></pre><p id="f341" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是函数中没有等待的真实用例。</p><p id="4ae2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">特别是，如果您正在为Jest测试设置资源，您可能有一个Jest在开始运行测试之前运行的设置文件。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="5fd1" class="mv lu in ls b gy mw mx l my mz">import dotenv from 'dotenv'<br/><br/>import { AuthenticatedRequests } from './commonDataModels/AuthenticatedRequests'<br/>dotenv.config()<br/><br/>// async function that gets a valid auth token from a third party service so we can build requests<br/>await AuthenticatedRequests.setToken()<br/><br/>export {}</span></pre><p id="827b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以通过在<code class="fe lp lq lr ls b">setToken()</code>方法中使用<code class="fe lp lq lr ls b">.then()</code> promise语法来避免使用<code class="fe lp lq lr ls b">await</code>，并使其成为一个同步方法。但是我更喜欢尽可能使用async/await。</p><p id="0c26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你正在用一个顶层的<code class="fe lp lq lr ls b">.mjs</code>文件编写一个本地节点模块，await应该很适合你。</p><p id="87d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您是在TypeScript中编写的，那么您必须将<strong class="kv io"> tsconfig </strong>中的模块选项设置为“<strong class="kv io"> esnext </strong>”(在编写本文时)。我将在另一节描述如何配置TypeScript。</p><h1 id="fb0a" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">将CommonJS模块导入ES6模块</h1><p id="5ea6" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">现在你的目标是ES6或更高版本，你不能再在自己的模块中使用任何CommonJS模块。您必须使用<code class="fe lp lq lr ls b">import</code>语法导入它们。</p><p id="58ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">TypeScript和Node.js都为此提供了互操作性。我来描述一下打字稿的那个。</p><p id="8383" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大多数导入CommonJS模块的TypeScript应用程序应该在它们的<strong class="kv io"> tsconfig </strong>文件中打开<code class="fe lp lq lr ls b">esModuleInterop</code>。那你就用一个【正常】<code class="fe lp lq lr ls b">import</code>就可以了。</p><p id="fb20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">旧的TypeScript CommonJS互操作以违反ES6标准的方式处理CommonJS导入。EsModuleInterop对TypeScript编译器进行了一些更改，以更好地处理这些问题。这些问题在TypeScript文档<a class="ae ks" href="https://www.typescriptlang.org/tsconfig#esModuleInterop" rel="noopener ugc nofollow" target="_blank">中有所描述。</a></p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="5bf1" class="mv lu in ls b gy mw mx l my mz">// this imports the default export from a commonjs module.<br/>import dotenv from 'dotenv'<br/><br/>// this imports default and any named exports on module.exports<br/>import * as dotenv from 'dotenv'<br/>// you could access dotenv.default here<br/>// or const postConfig = dotenv() (dotenv module doesn't export a function on exports but this is just an example)</span></pre><h1 id="a413" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">变量__filename和__dirname在ECMAScript ES6模块中不可用</h1><p id="4be5" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">当您尝试使用这些特殊变量中的一个时，如果您使用ECMAScript模块，您将得到错误<em class="mq">“reference error:_ _ filename is not defined”</em>。</p><p id="2e0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为当Node.js在ECMAScript ES6模块模式下运行时，它们根本不可用。在<code class="fe lp lq lr ls b">import.meta.</code>中，有一种替代方法可以让您获得当前的工作目录。以下是使用方法。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="2308" class="mv lu in ls b gy mw mx l my mz">console.log(import.meta.url)<br/>// returns where the module (usually the file) is located e.g. file:///Users/me/personal-projects/blog/e2e-backend/src/preRun.ts<br/><br/>// and how to get a string file path<br/>console.log(new URL('./new-file-path.json', import.meta.url).pathname)<br/>// returns e.g. /Users/me/personal-projects/blog/e2e-backend/src/new-file-path.json</span></pre><p id="431d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Node.js文档建议您可以直接为<code class="fe lp lq lr ls b">fs</code>方法提供一个<code class="fe lp lq lr ls b">URL</code>实例，但是我在应用程序中使用的类型需要传递一个字符串。所以，这就是我将URL的<code class="fe lp lq lr ls b">.pathname</code>属性传递给<code class="fe lp lq lr ls b">fs</code>方法的原因。</p><p id="b820" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我怀疑这个打字问题将在Node.js类型的新版本中得到解决，因此您可能能够在应用程序中传递URL而无需读取路径名。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="ed9e" class="mv lu in ls b gy mw mx l my mz">// this works on my application with installed Node.js types<br/>const contents = fs.readFileSync(<br/>  new URL('./new-file-path.json', import.meta.url).pathname<br/>)<br/><br/>// this is how the Node.js docs suggest using URL with fs methods but this did not<br/>// pass with my typescript Node.js types<br/>const contents = fs.readFileSync(<br/>  new URL('./new-file-path.json', import.meta.url)<br/>)</span></pre><h1 id="dbf1" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">为ECMAScript ES6模块配置TypeScript</h1><p id="25d3" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">您需要设置您的TypeScript配置来支持ES6模块特性。我将假设您使用的是TypeScript 4或更高版本。</p><p id="fcc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您使用的是Node 14和更高版本，您可以访问ES2020上的所有可用功能，没问题。您可以使用这些库，也可以将它们作为输出目标。</p><p id="b436" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你只想使用ECMAScript ES6模块，并且不需要使用顶级await，那么你可以使用<code class="fe lp lq lr ls b">es2020</code>模块。这可以通过以下方式完成:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="8a10" class="mv lu in ls b gy mw mx l my mz">{<br/>  "compilerOptions": {<br/>    "lib": ["es2020"],<br/>    "module": "es2020",<br/>    "target": "es2020",<br/>    "strict": true,<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "forceConsistentCasingInFileNames": true<br/>  }<br/>}</span></pre><p id="a5c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您还想使用顶级await，那么在撰写本文时，您需要像这样将模块选项设置为<code class="fe lp lq lr ls b">esnext</code>。</p><p id="0b84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">esnext</code>旨在包含实验特性，因此您可能不想在生产中使用它。</p><p id="76fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">顶级等待很可能在将来被添加到一个永久的模块配置中。因此，如果你来自未来，并且正在阅读这篇文章，请查看TypeScript文档以获得对顶级await的支持！</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="6c7d" class="mv lu in ls b gy mw mx l my mz">{<br/>  "compilerOptions": {<br/>    "lib": ["es2020"],<br/>    "module": "esnext",<br/>    "target": "es2020",<br/>    "strict": true,<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "forceConsistentCasingInFileNames": true<br/>  }<br/>}</span></pre><p id="5c07" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我个人的观点是，在目前的写作阶段，拥有顶级等待是很好的，但是在生产运行时环境中通常有需要它们的方法。不过，我确实在每天运行的开发工具中使用它们。</p><p id="e8c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您使用的是Node.js 12，这是您应该使用的TypeScript配置:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="aac7" class="mv lu in ls b gy mw mx l my mz">{<br/>  "compilerOptions": {<br/>    "lib": ["es2019", "es2020.promise", "es2020.bigint", "es2020.string"],<br/>    "module": "esnext",<br/>    "target": "es2019",<br/>    "strict": true,<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "forceConsistentCasingInFileNames": true<br/>  }<br/>}</span></pre><p id="f4a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">重要的是要注意，你需要替换的<code class="fe lp lq lr ls b">__filename</code>的<code class="fe lp lq lr ls b">import.meta</code>属性只在ES2020模块或更高版本中可用(<strong class="kv io"> esnext </strong>也会有)。</p><h1 id="8812" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">为ECMAScript ES6模块配置Jest和TypeScript</h1><p id="5264" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">如果你想用TypeScript在Jest中使用ES6模块，我推荐使用<strong class="kv io"> ts-jest </strong>预置，并打开<strong class="kv io"> useEsm </strong>。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="f5aa" class="mv lu in ls b gy mw mx l my mz">npm i --save-dev ts-jest<br/>// or<br/>// yarn add -D ts-jest<br/><br/>{<br/>  "preset": "ts-jest",<br/>  "roots": ["&lt;rootDir&gt;/src"],<br/>  "extensionsToTreatAsEsm": [".ts"],<br/>  "testRegex": ".e2e-spec.ts$",<br/>  "setupFiles": ["&lt;rootDir&gt;/src/preRun.ts"],<br/>  "globals": {<br/>    "ts-jest": {<br/>      "useESM": true<br/>    }<br/>  }<br/>}</span></pre><p id="f235" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当你调用Jest时，告诉它使用ES6模块。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="fc32" class="mv lu in ls b gy mw mx l my mz">"test" : "NODE_OPTIONS=--experimental-vm-modules npx jest"</span></pre><h1 id="7bca" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">在TypeScript中使用node: schema</h1><p id="4d01" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">Node.js模块实现支持模式。导入的“from”部分实际上是一个URL！并且节点缓存也这样对待它。一个非常有趣的模式是<code class="fe lp lq lr ls b">node:</code>模式，因此您可以清楚地知道这个导入是一个节点模块，而不是一个定制的应用程序模块。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="668e" class="mv lu in ls b gy mw mx l my mz">import fs from 'node:fs'</span></pre><p id="7c77" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">目前(2021年6月)这个模式有一个问题，Node.js类型的维护者试图添加这个模式，但它导致了CommonJS导入的问题。所以，他们恢复了加法。</p><p id="c015" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，您不能将节点模式与TypeScript和Node.js类型一起使用。</p><p id="07fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我相信这个问题将来会得到解决，但是为了让你不要浪费时间去解决它，我想我应该分享一下调查结果！</p><h1 id="3d12" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><p id="0e80" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">ECMAScript模块就在这里，随时可以使用！</p><p id="0240" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出于向后兼容性的考虑，在您的浏览器web应用程序中使用它们还需要一段时间，但是在Node.js中，我们控制运行时，所以现在就开始使用它们。</p><p id="098b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过对TypeScript进行一些配置更改，您可以停止将ES6模块移植到CommonJS中，如果需要的话，您将获得一些新的有用特性。</p><p id="23d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您有任何问题，可以通过Twitter 联系我<a class="ae ks" href="https://twitter.com/darraghor" rel="noopener ugc nofollow" target="_blank">！</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/467d203c246f32851b7b8ae0da31744f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lV2NeNyCxqKP-adu.png"/></div></div></figure></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="b2d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mq">原载于</em><a class="ae ks" href="https://www.darraghoriordan.com/2021/06/26/publishing-package-using-esm-esmodules/" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://www.darraghoriordan.com</em></a><em class="mq">。</em></p><p id="88cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mq">更多内容看</em> <a class="ae ks" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> <em class="mq">说白了</em></strong></a></p></div></div>    
</body>
</html>