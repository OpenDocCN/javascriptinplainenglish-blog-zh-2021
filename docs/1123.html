<html>
<head>
<title>The JavaScript Execution Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript执行模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-javascript-execution-model-part-2-467c7b9b42fa?source=collection_archive---------6-----------------------#2021-03-09">https://javascript.plainenglish.io/the-javascript-execution-model-part-2-467c7b9b42fa?source=collection_archive---------6-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="400b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">第2部分:承诺如何与JavaScript的调用堆栈和事件循环交互</em></h2></div><p id="c77f" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="kz">这篇文章中的动画可视化是用</em><a class="ae la" href="https://jsv9000.app/." rel="noopener ugc nofollow" target="_blank"><em class="kz">https://jsv 9000 . app</em></a><em class="kz">创建的——一个旨在帮助你可视化和了解事件循环的工具。</em></p><p id="5c32" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在上一篇文章中，我们了解了JavaScript的调用堆栈和事件循环。我们完成了一个使用<code class="fe lb lc ld le b">setTimeout()</code>将一个长时间运行的同步功能分解成一系列短任务的例子。但是我们为什么选择了<code class="fe lb lc ld le b">setTimeout()</code>？我们可以用<code class="fe lb lc ld le b">Promise.resolve()</code>来代替吗？毕竟，承诺应该是异步的，所有异步JavaScript都是通过在事件循环中将任务排队来工作的。</p><p id="4a1e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们试试吧！</p><h1 id="d3f1" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">setTimeout()与Promise.resolve()</h1><p id="ccd2" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">我们将使用在第1部分中创建的网页来测试我们的理论。</p><p id="dc78" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这是我们的<code class="fe lb lc ld le b">computePrimes()</code>函数的最终版本:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="cce2" class="mk lg in le b gy ml mm l mn mo"><strong class="le io">function</strong> computePrimes(onPrime, startAt = 2) {<br/>  <strong class="le io">let</strong> currNum = startAt;<br/>  <strong class="le io">while</strong> (<strong class="le io">true</strong>) {<br/>    <strong class="le io">if</strong> (isPrime(currNum)) onPrime(currNum);<br/>    currNum += 1;<br/>    <strong class="le io">if</strong> (currNum % 500 === 0) <strong class="le io">break</strong>;<br/>  }<br/>  setTimeout(() =&gt; computePrimes(onPrime, currNum), 0); <em class="kz">// Magic‽</em><br/>}</span></pre><p id="da90" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们改写一下，用<code class="fe lb lc ld le b">Promise.resolve()</code>代替<code class="fe lb lc ld le b">setTimeout()</code>:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="1f03" class="mk lg in le b gy ml mm l mn mo"><strong class="le io">function</strong> computePrimes(onPrime, startAt = 2) {<br/>  <strong class="le io">let</strong> currNum = startAt;<br/>  <strong class="le io">while</strong> (<strong class="le io">true</strong>) {<br/>    <strong class="le io">if</strong> (isPrime(currNum)) onPrime(currNum);<br/>    currNum += 1;<br/>    <strong class="le io">if</strong> (currNum % 500 === 0) <strong class="le io">break</strong>;<br/>  }<br/>  <em class="kz">// Let's try Promise.resolve() instead of setTimeout()</em><br/>  Promise.resolve().then(() =&gt; computePrimes(onPrime, currNum));<br/>}</span></pre><p id="119e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">现在，在浏览器中打开网页，点击“开始计算素数”按钮。</p><figure class="mc md me mf gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/a494786d92290f464f27359c0a49c63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gf1jKWGE458QK5n23B29gg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><em class="kc">Webpage after running for a short time using Promise.resolve()</em></figcaption></figure><p id="5e44" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">没用！也许<code class="fe lb lc ld le b">Promise.resolve()</code>终究不是真正的异步？让我们来看看:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="7eaf" class="mk lg in le b gy ml mm l mn mo"><strong class="le io">function</strong> logA() { console.log('A'); }<br/><strong class="le io">function</strong> logB() { console.log('B'); }<br/><strong class="le io">function</strong> logC() { console.log('C'); }<br/><br/>logA();<br/>Promise.resolve().then(logB);<br/>logC();<br/><br/><em class="kz">// =&gt; A C B</em></span></pre><p id="c9e0" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">试着自己运行这个。你会发现B总是<strong class="kf io">最后一个被记录。这与我们在第1部分的<code class="fe lb lc ld le b">setTimeout()</code>中看到的行为相同。因此，我们已经确认<code class="fe lb lc ld le b">Promise.resolve()</code>实际上是异步的。它像<code class="fe lb lc ld le b">setTimeout()</code>一样将任务排队。</strong></p><p id="405c" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">但是当我们试图用<code class="fe lb lc ld le b">Promise.resolve()</code>而不是<code class="fe lb lc ld le b">setTimeout()</code>来分解我们的<code class="fe lb lc ld le b">computePrimes()</code>函数时，它不起作用！Why‽</p><p id="056e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">显然，<code class="fe lb lc ld le b">setTimeout()</code>和<code class="fe lb lc ld le b">C</code>是相似的，但是在一些基本的方式上也是不同的。让我们尝试调整我们之前的脚本，以便更好地处理它们各自的行为方式:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="6471" class="mk lg in le b gy ml mm l mn mo"><strong class="le io">function</strong> logA() { console.log('A') }<br/><strong class="le io">function</strong> logB() { console.log('B') }<br/><strong class="le io">function</strong> logC() { console.log('C') }<br/><strong class="le io">function</strong> logD() { console.log('D') }<br/><br/>logA();<br/>setTimeout(logB, 0);<br/>Promise.resolve().then(logC);<br/>logD();<br/><br/><em class="kz">// =&gt; A D C B</em></span></pre><p id="d09a" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如预期的那样，首先执行两个同步调用(<code class="fe lb lc ld le b">logA()</code>和<code class="fe lb lc ld le b">logD()</code>)。但是我们用<code class="fe lb lc ld le b">setTimeout()</code> ( <code class="fe lb lc ld le b">logB()</code>)和<code class="fe lb lc ld le b">Promise.resolve()</code> ( <code class="fe lb lc ld le b">logC()</code>)进行的两个异步调用被无序记录。由<code class="fe lb lc ld le b">Promise.resolve()</code>排队的任务总是在由<code class="fe lb lc ld le b">setTimeout()</code>排队的任务之前执行。</p><p id="bdb1" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这没有意义，因为事件循环是按照FIFO顺序处理任务队列中的任务的。由于<code class="fe lb lc ld le b">setTimeout()</code>在我们的脚本中首先运行，我们希望它的任务首先被执行。但显然不是。</p><p id="2cd8" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们在第1部分中获得的关于调用堆栈和事件循环的理解不能解释这里发生了什么。为了理解为什么<code class="fe lb lc ld le b">setTimeout()</code>和<code class="fe lb lc ld le b">Promise.resolve()</code>表现不同，我们必须谈谈<strong class="kf io">微任务</strong>。但是在这之前，我们需要充实一下我们对<strong class="kf io">任务</strong>和<strong class="kf io">任务队列</strong>的理解。</p><h1 id="a81b" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">任务</h1><p id="f255" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">在第1部分中，我们将任务队列作为事件循环的一部分进行了介绍。它被表示为一个FIFO任务队列。然而，这幅图并不完整。事实上，事件循环包含<em class="kz">几个</em>任务队列。</p><p id="22ff" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">JavaScript语言规范允许JS引擎拥有任意多的队列。但是有<a class="ae la" href="https://www.ecma-international.org/ecma-262/9.0/index.html#table-26" rel="noopener ugc nofollow" target="_blank"> 2个必需的队列</a>:</p><ul class=""><li id="30b5" class="nb nc in kf b kg kh kj kk km nd kq ne ku nf ky ng nh ni nj bi translated"><strong class="kf io">脚本任务队列</strong> —该队列包含验证和评估JavaScript源代码的任务。我们不会在这篇文章中进一步讨论这个队列。</li><li id="34f3" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><strong class="kf io">承诺任务队列</strong> —该队列包含在<code class="fe lb lc ld le b">Promise</code>被解决或拒绝后排队的任务。例如，您可以使用<code class="fe lb lc ld le b">Promise.resolve().then(taskFn)</code>将任务放入这个队列中。</li></ul><p id="a933" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">JS引擎通常也有额外的队列。例如，浏览器可能有第三个队列用于DOM事件，第四个队列用于计时器回调。</p><p id="ca62" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">JavaScript规范没有规定这些队列被服务的顺序。这由JavaScript引擎的设计者来决定。一个引擎可能会选择首先处理它的计时器队列中的所有事件，只有当计时器队列为空时才移动到DOM事件队列。或者，引擎可能会交叉两个队列中的事件。</p><p id="5327" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">当所有事件队列都为空时，引擎设计者也要决定发生什么。一个引擎可能选择退出(像NodeJS)或者继续运行并等待某个外部源将一个新事件加入队列(像web浏览器)。</p><p id="0f55" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们用JS代码对事件循环的更新版本进行建模:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="1926" class="mk lg in le b gy ml mm l mn mo"><strong class="le io">while</strong> (EventLoop.waitForTask()) {<br/>  <strong class="le io">const</strong> taskQueue = EventLoop.selectTaskQueue();<br/>  <strong class="le io">if</strong> (taskQueue.hasNextTask()) {<br/>    taskQueue.processNextTask();<br/>  }<br/><br/>  rerender();<br/>}</span></pre><p id="9ae2" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们更新第1部分中的事件循环图，以包括额外的任务队列:</p><figure class="mc md me mf gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi np"><img src="../Images/ac5e0ea2dc483813fad0d2313e79477c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvQUjZ54pnuljDA1qyea-Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><em class="kc">The JavaScript Event Loop with Multiple Task Queues</em></figcaption></figure><h1 id="6b25" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">有些东西闻起来有鱼腥味🐟</h1><p id="499c" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">HTML规范概述了浏览器中事件循环的9步<a class="ae la" href="https://www.w3.org/TR/html52/webappapis.html#event-loops-processing-model" rel="noopener ugc nofollow" target="_blank">处理模型:</a></p><blockquote class="nq nr ns"><p id="77e5" class="kd ke kz kf b kg kh jo ki kj kk jr kl nt kn ko kp nu kr ks kt nv kv kw kx ky ig bi translated">只要事件循环存在，它就必须持续运行以下步骤:</p><p id="7eae" class="kd ke kz kf b kg kh jo ki kj kk jr kl nt kn ko kp nu kr ks kt nv kv kw kx ky ig bi translated">1.<strong class="kf io">在事件循环的任务队列中选择最早的任务。</strong> <br/> 2。将事件循环的当前运行任务设置为上一步中选择的任务。<br/> 3 .<strong class="kf io">运行所选任务。</strong> <br/> 4。将事件循环当前运行的任务设置回null。<br/> 5。从任务队列中删除在步骤3中运行的任务。<br/> 6。执行微量询问检查点。<br/> 7。<strong class="kf io">更新渲染。</strong> <br/> 8。<em class="in">…省略(此步骤仅适用于网络工作人员)… </em> <br/> 9。<strong class="kf io">返回事件循环的第一步。</strong></p></blockquote><p id="5994" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这很重要，因为根据这个模型，浏览器应该在处理任务之间重新渲染。</p><p id="f349" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这里有些不对劲。如果<code class="fe lb lc ld le b">Promise.resolve()</code>和<code class="fe lb lc ld le b">setTimeout()</code>都将任务排队，那么就我们的<code class="fe lb lc ld le b">computePrimes()</code>函数而言，它们应该是等价的:<code class="fe lb lc ld le b">computePrimes()</code>应该能够将其主要计算分解成承诺或定时器任务队列中的一系列任务。在运行这些任务之间，事件循环应该允许浏览器重新渲染(步骤7)。但是我们已经表明，这仅适用于计时器任务队列。基于我们之前的实验，浏览器不会<strong class="kf io">重新渲染承诺任务队列中的中间处理任务。</strong></p><p id="d4d0" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">那么是什么呢？</p><h1 id="c553" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">故意违反</h1><p id="b951" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">这种差异是由HTML规范所称的<strong class="kf io">微任务</strong>造成的。但是在JavaScript规范中没有提到微任务。那么，他们来自哪里呢？HTML规范有一个<a class="ae la" href="https://www.w3.org/TR/html52/webappapis.html#integration-with-the-javascript-job-queue" rel="noopener ugc nofollow" target="_blank">部分</a>谈到了这一点(请注意，这个摘录中的术语“工作”就是我们一直所说的“任务”):</p><blockquote class="nq nr ns"><p id="e9ff" class="kd ke kz kf b kg kh jo ki kj kk jr kl nt kn ko kp nu kr ks kt nv kv kw kx ky ig bi translated">JavaScript规范定义了JavaScript作业和作业队列抽象，以便指定承诺操作如何以干净的JavaScript执行上下文堆栈和特定顺序执行的特定不变量。然而，在撰写本文时，该规范中对EnqueueJob的定义[原文如此]不够灵活，无法与HTML集成为一个宿主环境。</p><p id="b646" class="kd ke kz kf b kg kh jo ki kj kk jr kl nt kn ko kp nu kr ks kt nv kv kw kx ky ig bi translated"><strong class="kf io"> <em class="in">注</em> </strong> <em class="in"> : </em>严格来说这不是真的。事实上，通过充分利用算法中许多“实现定义”的部分，有可能按照我们的目的扭曲它。然而，最终的结果是大量混乱的间接和变通方法，它们基本上完全绕过了作业队列基础设施，尽管这种方式在技术上是在实现定义的行为范围内得到认可的。我们不走这条路，而是引入以下故意违反。</p><p id="b222" class="kd ke kz kf b kg kh jo ki kj kk jr kl nt kn ko kp nu kr ks kt nv kv kw kx ky ig bi translated">因此，用户代理必须使用下面的定义来代替JavaScript规范中的定义。这些确保了由JavaScript规范排队的promise作业被正确地集成到用户代理的事件循环中。</p></blockquote><p id="589e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">说了很多话。HTML规范基本上是说JS规范的一个特定部分使得HTML规范很难完成它的工作。因此，HTML规范没有试图绕过这一部分，而是提出了自己的版本。</p><p id="5d56" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">有意思！HTML规范故意违反了JavaScript规范。这种违反就是微任务的来源。</p><p id="9f87" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">由于这种违反，我们在本文前面形成的关于Promise任务队列的图片并不真正正确。没有一个主流的JS引擎有Promise任务队列。相反，他们有一个微任务队列。本应进入承诺任务队列的任务转到这里，被称为<strong class="kf io">微任务</strong>。</p><h1 id="cf87" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">微任务</h1><p id="9053" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated"><strong class="kf io">微任务</strong>很像<strong class="kf io">任务</strong>。它们是同步的代码块(把它们想象成<code class="fe lb lc ld le b">Function</code>对象),在运行时可以独占访问调用堆栈。就像任务一样，微任务能够将额外的微任务或接下来要运行的任务排队。</p><p id="44b0" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">微任务和任务之间的唯一区别是它们被存储在哪里，以及何时被处理。</p><ul class=""><li id="0b81" class="nb nc in kf b kg kh kj kk km nd kq ne ku nf ky ng nh ni nj bi translated">众所周知，任务存储在任务队列中。但是微任务存储在微任务队列中(这里只有一个)。</li><li id="5624" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated">任务在循环中处理，渲染在任务之间执行。但是在任务完成之后，在重新渲染发生之前，微任务队列被清空。</li></ul><p id="e707" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们将微任务队列循环添加到事件循环模型中:</p><pre class="mc md me mf gt mg le mh mi aw mj bi"><span id="efad" class="mk lg in le b gy ml mm l mn mo">while (EventLoop.waitForTask()) {<br/>  <strong class="le io">const</strong> taskQueue = EventLoop.selectTaskQueue();<br/>  <strong class="le io">if</strong> (taskQueue.hasNextTask()) {<br/>    taskQueue.processNextTask();<br/>  }<br/><br/>  <strong class="le io">const</strong> microtaskQueue = EventLoop.microTaskQueue;<br/>  <strong class="le io">while</strong> (microtaskQueue.hasNextMicrotask()) {<br/>    microtaskQueue.processNextMicrotask();<br/>  }<br/><br/>  rerender();<br/>}</span></pre><p id="dfaa" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们还将更新我们的图表:</p><figure class="mc md me mf gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi np"><img src="../Images/65e1ff9afbd48a9f966d8f43eac9c584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAafrFTxySvVgYN6Bb_XnQ.png"/></div></div></figure><h1 id="72e6" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">为什么Promise.resolve()冻结了我们的网页</h1><p id="5a38" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">让我们回到我们的例子。如果我们使用<code class="fe lb lc ld le b">setTimeout()</code>分解质数计算，效果会很好。但是如果我们尝试用<code class="fe lb lc ld le b">Promise.resolve()</code>来代替，网页又会死机。</p><p id="bb8f" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">发生这种情况是因为<code class="fe lb lc ld le b">Promise.resolve()</code>没有将任务入队——它将一个<em class="kz">微任务</em>入队。正如我们在上面看到的，直到微任务队列为空，事件循环才重新呈现。因此，如果微任务队列从不为空，浏览器将永远不会重新呈现。</p><p id="6167" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这正是导致我们的示例网页冻结的原因！就在<code class="fe lb lc ld le b">computePrimes()</code>函数返回之前，它将另一个微任务排入队列，以计算下一批素数。这防止微任务队列被事件循环完全清空。</p><p id="517e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe lb lc ld le b">setTimeout()</code>运行良好的原因是因为它将任务排队，而不是微任务。如上所述，浏览器能够在处理任务之间重新呈现(但不能在微任务之间)。</p><p id="98f4" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">让我们想象一下这一切。</p><figure class="mc md me mf gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nw"><img src="../Images/194f4c0178ccf542a3765e0445a6795e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-66xwHubxFQZpBdlJlj3Xg.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><em class="kc">Visualization of the Microtask Queue. Created with </em><a class="ae la" href="https://jsv9000.app/" rel="noopener ugc nofollow" target="_blank"><em class="kc">https://jsv9000.app/</em></a></figcaption></figure><p id="2730" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">注意事件循环是如何在运行所有微任务步骤中停滞的。无论脚本运行多长时间，它都不会进入rerender步骤。</p><h1 id="7686" class="lf lg in bd lh li lj lk ll lm ln lo lp jt lq ju lr jw ls jx lt jz lu ka lv lw bi translated">结论</h1><p id="c667" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">在ES6之前，JavaScript的事件循环模型相对简单，与HTML规范配合得很好。但是ES6带来了承诺，随之而来的是JavaScript事件循环的额外复杂性。JS规范只是用另一个任务队列来处理承诺。但是HTML规范违反了JS规范，用一种新的结构处理承诺:微任务队列。这就是今天所有主流JavaScript引擎处理承诺的方式。</p><p id="c972" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在JavaScript中启动异步操作的两种显而易见的方法是<code class="fe lb lc ld le b">setTimeout(taskFn, 0)</code>和<code class="fe lb lc ld le b">Promise.resolve().then(microtaskFn)</code>。如果您对JavaScript及其事件循环只有基本的了解，这些方法可能看起来是等效的。但实际上，由于微任务，它们在一些重要方面的操作是不同的。</p><p id="2aa9" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我希望这篇文章能帮助你更好地理解承诺是如何与JavaScript的执行模型交互的。感谢阅读！</p></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><p id="c8be" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">【2019年2月写了这篇文章。原来这里贴的是<a class="ae la" href="https://qdivision.io/javascript-settimeout-an-in-depth-look-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="kz"/></a><em class="kz">。</em></p><p id="9d1e" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io"> <em class="kz">这篇文章建立在</em> </strong> <a class="ae la" href="https://andrewjdillon.medium.com/the-javascript-execution-model-part-1-448e62628f23" rel="noopener"> <strong class="kf io"> <em class="kz">第一部分</em> </strong> </a> <strong class="kf io"> <em class="kz">的基础上，讨论了承诺如何与JavaScript的调用堆栈和事件循环交互。</em> </strong></p><h2 id="7eb0" class="mk lg in bd lh oe of dn ll og oh dp lp km oi oj lr kq ok ol lt ku om on lv oo bi translated">脚注</h2><p id="79a9" class="pw-post-body-paragraph kd ke in kf b kg lx jo ki kj ly jr kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">[1]:如果我们只关心JavaScript规范要说什么，那么<em class="kz">就是</em>正确的。但是所有主要的JavaScript引擎都是为浏览器开发的(包括NodeJS使用的V8引擎)。因此，这些JS引擎必须符合JS和HTML规范。因此，实际上，您编写的任何JS代码都将在使用微任务的环境中运行。</p><h2 id="bb4e" class="mk lg in bd lh oe of dn ll og oh dp lp km oi oj lr kq ok ol lt ku om on lv oo bi translated">额外阅读和观看</h2><ul class=""><li id="c6cf" class="nb nc in kf b kg lx kj ly km op kq oq ku or ky ng nh ni nj bi translated">https://www.youtube.com/watch?v=8aGhZQkoFbQ<a class="ae la" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank"/></li><li id="441b" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/" rel="noopener ugc nofollow" target="_blank">https://blog . rising stack . com/writing-a-JavaScript-framework-execution-timing-beyond-settimeout/</a></li><li id="3015" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener ugc nofollow" target="_blank">https://jakearchibald . com/2015/tasks-micro tasks-queues-and-schedules/</a></li><li id="fbbe" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/event loop</a></li><li id="715e" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/microtask-and-macro task-a-hands-on-approach-5d 77050 e 2168</a></li><li id="6db1" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://developer.mozilla.org/en-US/docs/Tools/Performance/Scenarios/Intensive_JavaScript" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Tools/Performance/Scenarios/Intensive _ JavaScript</a></li></ul><h2 id="fc3b" class="mk lg in bd lh oe of dn ll og oh dp lp km oi oj lr kq ok ol lt ku om on lv oo bi translated">主要来源</h2><ul class=""><li id="4418" class="nb nc in kf b kg lx kj ly km op kq oq ku or ky ng nh ni nj bi translated"><a class="ae la" href="https://www.ecma-international.org/ecma-262/9.0/index.html" rel="noopener ugc nofollow" target="_blank"> JavaScript语言规范</a></li><li id="eb56" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://www.w3.org/TR/html52/webappapis.html" rel="noopener ugc nofollow" target="_blank"> HTML脚本规范</a></li></ul><h2 id="f8ca" class="mk lg in bd lh oe of dn ll og oh dp lp km oi oj lr kq ok ol lt ku om on lv oo bi translated">二手来源</h2><ul class=""><li id="5368" class="nb nc in kf b kg lx kj ly km op kq oq ku or ky ng nh ni nj bi translated"><a class="ae la" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/event-loop-timers-and-next tick/</a></li><li id="0ce5" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://www.quora.com/Does-JavaScript-in-the-browser-have-the-equivalent-of-process-nextTick-or-setImmediate-in-node-js-or-do-we-just-have-setTimeout" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/Does-JavaScript-in-the-browser-have-the-equivalent-of-process-next tick-or-set immediate-in-node-js-or-do-we-just-have-setTimeout</a></li><li id="6347" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/questions/26615966/how-to-make-non-blocking-javascript-code" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/26615966/how-to-make-non-blocking-JavaScript-code</a></li><li id="bc26" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="http://latentflip.com/loupe/" rel="noopener ugc nofollow" target="_blank">http://latentflip.com/loupe/</a></li><li id="0b1e" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/questions/38752620/promise-vs-settimeout" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/38752620/promise-vs-settimeout</a></li><li id="2ca3" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/questions/24117267/nodejs-settimeoutfn-0-vs-setimmediatefn" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/24117267/nodejs-settimeoutfn-0-vs-setimmediate fn</a></li><li id="121a" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/779379/why-is-settimeoutfn-0-有时有用</a></li><li id="7c3c" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16" rel="noopener ugc nofollow" target="_blank">https://es discuse . org/topic/the-initial ization-steps-for-web-browsers # content-16</a></li><li id="b289" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="noopener ugc nofollow" target="_blank">https://blog . session stack . com/how-JavaScript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f 077 c 4438 b 5</a></li><li id="11fe" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a" rel="noopener ugc nofollow" target="_blank">https://blog . session stack . com/how-JavaScript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c 0757 f6a</a></li><li id="9770" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2734025/is-JavaScript-guaranteed-to-be-single-threaded/2734311 # 2734311</a></li><li id="2bea" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://en.m.wikipedia.org/wiki/Reentrancy_(computing)" rel="noopener ugc nofollow" target="_blank">https://en . m . Wikipedia . org/wiki/Reentrancy _(计算)</a></li><li id="519a" class="nb nc in kf b kg nk kj nl km nm kq nn ku no ky ng nh ni nj bi translated"><a class="ae la" href="https://stackoverflow.com/a/19699970" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/19699970</a></li></ul></div></div>    
</body>
</html>