<html>
<head>
<title>Never write TypeScript types for GraphQL schema by hand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">永远不要手工为GraphQL模式编写类型脚本类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/never-write-typescript-types-for-graphql-schema-by-hand-4c35fe302845?source=collection_archive---------7-----------------------#2021-01-05">https://javascript.plainenglish.io/never-write-typescript-types-for-graphql-schema-by-hand-4c35fe302845?source=collection_archive---------7-----------------------#2021-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/254ba15da3fe4f7b8a1316f51260c97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGD3d5i9cTKGIMhLPvMXrA.png"/></div></div></figure><h1 id="f43b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么我们要使用TypeScript？</h1><p id="16b0" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现代软件开发最佳实践要求程序员编写大量代码:</p><ul class=""><li id="7bb2" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">业务逻辑</li><li id="d8f4" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">测试。单位/综合/E2E和<em class="mh">偶数类型</em>。<strong class="kv io">类型是测试</strong>，甚至在你运行程序之前就可以大量运行</li></ul><p id="a452" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">没有测试，您的系统将注定面临众所周知的问题:</p><ul class=""><li id="73eb" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">团队把大部分时间花在修复bug上，而不是增加新功能</li><li id="22b3" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">每一个新添加的特性都会使下一个特性更难实现</li></ul><p id="9499" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated"><strong class="kv io">你需要写大量的代码来掌控你的游戏。</strong> <strong class="kv io">不要让自己的生活更艰难。永远不要再手工为GraphQL模式编写类型脚本类型</strong>。</p><p id="2519" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">TypeScript验证您的程序是否支持当前的GraphQL模式。这为前端和后端增加了一层令人敬畏的质量测试:</p><ul class=""><li id="4a57" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">您的CI/CD可以对您的repo运行TypeScript验证和单元测试，并检测任何模式裂缝。</li></ul><p id="404e" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">但是手工编写打字稿是一项乏味的任务，结果很脆弱。</p><h1 id="776c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么我们要从GraphQL模式自动生成TypeScript？</h1><p id="5d83" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">GraphQL允许从模式文件自动生成TypeScript类型。该功能将:</p><p id="2a48" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated"><strong class="kv io">节省时间</strong>。应该手动验证每个模式更新并检查错误。即使是一个小的模式也可以是1000行的TypeScript定义。别忘了在React前端你需要写<a class="ae ml" href="https://www.apollographql.com/docs/react/api/react/hooks/" rel="noopener ugc nofollow" target="_blank"> Apollo React钩子</a>。</p><p id="a3e5" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated"><strong class="kv io">保护您免受人为错误</strong>。GraphQL规范非常复杂，有很多细节。您很可能知道以下两者之间的区别:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5c96" class="mv jw in mr b gy mw mx l my mz">offers(input: OffersInput): [ProductOffer]!</span></pre><p id="3338" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">和</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="120e" class="mv jw in mr b gy mw mx l my mz">offers(input: OffersInput): [ProductOffer!]!</span></pre><p id="603d" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">但是，您能在每次模式更新时可靠地验证每个这样的(以及许多更小的)差异吗？</p><p id="3dff" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated"><strong class="kv io">保护您免受GraphQL规范或模式更新的影响。</strong> GraphQL语言规范随时间演进:<a class="ae ml" href="https://spec.graphql.org/" rel="noopener ugc nofollow" target="_blank">https://spec.graphql.org/</a></p><p id="62c2" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">你的代码库将始终与最新的GraphQL 模式<strong class="kv io">保持同步。通过这种方式，您可以避免重大变更意外部署到生产环境中。多酷啊。通过自动生成类型脚本，您的GraphQL模式成为整个分布式系统的唯一事实来源。</strong></p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="237a" class="jv jw in bd jx jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks bi translated">如何从GraphQL模式设置自动类型脚本生成</h1><blockquote class="nm nn no"><p id="5d52" class="kt ku mh kv b kw lt ky kz la lu lc ld np mi lg lh nq mj lk ll nr mk lo lp lq ig bi translated"><em class="in">在这篇文章中我使用了一个</em> <a class="ae ml" href="https://medium.com/@adamhjk/monorepo-please-do-3657e08a4b70" rel="noopener"> <em class="in"> Monorepo </em> </a> <em class="in">项目设置，例如，我所有的包和项目都存储在一个单独的repo中。这样，客户端应用程序和后端可以访问GraphQL模式的一个物理副本。但是您可以将您的项目存储在您想要的任何地方，只需找到一种方法为您的后端和前端提供相同的GraphQL模式文件。</em></p><p id="1f1c" class="kt ku mh kv b kw lt ky kz la lu lc ld np mi lg lh nq mj lk ll nr mk lo lp lq ig bi translated"><strong class="kv io"> <em class="in">如果您正在使用第三方API </em> </strong> <em class="in">您可以直接从端点使用当前的GraphQL模式。我将在后面描述这个过程。</em></p></blockquote><p id="8c67" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">我强烈推荐使用<a class="ae ml" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>包。</p><ul class=""><li id="30d4" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><strong class="kv io">将“devDependencies”安装到你的软件包</strong>(你可以使用不同的软件包版本和插件)</li></ul><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">“@graphql-codegen/cli” — is the main package, “@graphql-codegen/*” — are plugins</figcaption></figure><ul class=""><li id="8aa9" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><strong class="kv io">将“graphql-codegen”命令添加到您的“package.json”脚本部分。</strong></li></ul><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Good points will be “build” or “postinstall” (will be automatically called on the package installation)</figcaption></figure><ul class=""><li id="ce2d" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">在你的包根目录下创建一个“codegen.yml”。这个文件将为你的“graphql-codegen”命令提供配置。检查codegen.yml文档</li></ul><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="681f" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">“模式”——程序应该在哪里搜索GraphQL模式文件。在这种情况下，我们的客户机“order-list-app”在附近的monorepo包“order-list-backend”中搜索服务器GraphQL模式。然而，<strong class="kv io">如果你使用的是第三方API </strong>，那么你应该在这里放上你的URL端点。</p><p id="c788" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">“文档”——这些文件看起来像graphql模式，但是描述了客户端的操作。GraphQL客户端使用“文档”来形成graphql请求，在后端可能会被省略。</p><p id="566a" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">" graph QL _ API _ build/types _ and _ hooks . tsx "-放置结果的位置</p><p id="17dc" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">“插件”——应该生成什么代码。在这个例子中，我想要TypeScript types+<a class="ae ml" href="https://www.apollographql.com/docs/react/api/react/hooks/" rel="noopener ugc nofollow" target="_blank">Apollo React Hooks</a>。后端没有挂钩，所以后端可以省略“typescript-react-apollo”插件。</p><ul class=""><li id="e844" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated"><strong class="kv io">就这样！免费使用和享受大量的类型。他们会从上到下测试你的系统。</strong></li></ul></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="7f93" class="jv jw in bd jx jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks bi translated">您不应该将生成的TypeScript文件提交给git</h1><p id="f59c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在“yarn install”或“npm install”之后，文件将直接从graphql模式编译，没有必要提交它们。这样，你的GraphQL模式将成为一个<strong class="kv io">真实的单一来源</strong>。</p><h1 id="0c06" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">您应该在每次架构更新时重新编译TypeScript类型</h1><p id="d7e2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果已经更新了模式，应该调用“graphql-codegen”脚本来重新编译类型。不要担心忘记它。编译后的文件不会提交给repo，CI/CD会从头开始重新编译它们并捕捉错误。这种不一致的状态是不能断产的。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="7f18" class="jv jw in bd jx jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks bi translated">结论</h1><p id="61ed" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">TypeScript代码生成易于自动化和使用。<a class="ae ml" href="https://github.com/dotansimha/graphql-code-generator" rel="noopener ugc nofollow" target="_blank"> graphql-code-generator </a>在github上有6k颗星。这个软件包是抛光的方式以上，你可以真实地手写。</p><p id="f4cc" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">使用编译类型，您将获得:</p><ul class=""><li id="23a4" class="lr ls in kv b kw lt la lu le lv li lw lm lx lq ly lz ma mb bi translated">更少的错误</li><li id="7fb3" class="lr ls in kv b kw mc la md le me li mf lm mg lq ly lz ma mb bi translated">更快的发展</li></ul><p id="fe32" class="pw-post-body-paragraph kt ku in kv b kw lt ky kz la lu lc ld le mi lg lh li mj lk ll lm mk lo lp lq ig bi translated">GraphQL不仅仅是“用更少的网络流量休息”。这是一项更加深奥的技术。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h2 id="1b58" class="mv jw in bd jx ny nz dn kb oa ob dp kf le oc od kj li oe of kn lm og oh kr oi bi translated">感谢您的阅读，</h2><p id="9323" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">非常感谢您在评论中的反馈。</p></div></div>    
</body>
</html>