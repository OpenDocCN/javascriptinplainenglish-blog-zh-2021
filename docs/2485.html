<html>
<head>
<title>Use TailwindCSS via Directive in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Angular中的指令使用TailwindCSS</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-tailwindcss-via-directive-in-angular-6e4ec63e1c48?source=collection_archive---------6-----------------------#2021-05-22">https://javascript.plainenglish.io/use-tailwindcss-via-directive-in-angular-6e4ec63e1c48?source=collection_archive---------6-----------------------#2021-05-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="afc3" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">从角度模板中整理顺风类，并在应用程序中重用样式。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/0092bd9848e46ad983ea20d0fd9fe4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJUU9C6RVvXqQCf-"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@zhpix?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pascal Meier</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>. <strong class="bd kx">Fun fact: Tailwind is a term heavily used in </strong><a class="ae kw" href="https://en.wikipedia.org/wiki/Headwind_and_tailwind" rel="noopener ugc nofollow" target="_blank"><strong class="bd kx">Aviation</strong></a><strong class="bd kx">.</strong></figcaption></figure><p id="013d" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">从v11.2开始，Angular对TailwindCSS提供了一流的支持。当在angular模板中使用tailwind时，您可能希望对一些类进行分组以便重用。例如，对于卡片样式，您可能有<code class="fe lu lv lw lx b">bg-gray-100 rounded-md p-4 shadow hover:shadow-lg hover:bg-gray-50</code>。当然，你有tailwind的<a class="ae kw" href="https://tailwindcss.com/docs/functions-and-directives#apply" rel="noopener ugc nofollow" target="_blank"> @apply指令</a>来创建你自己的定制类，由tailwind类组成。但是我将向你展示一种非常规的分组方式，并在angular模板中使用它们。</p><h1 id="02f3" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">样式映射</h1><p id="9631" class="pw-post-body-paragraph ky kz ir la b lb mr js ld le ms jv lg lh mt lj lk ll mu ln lo lp mv lr ls lt ik bi translated">让我们首先创建一个风格词典。键名将用于匹配和提取tailwind类，并将它们应用于HTML元素。下面给出一个例子:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Styles Map</figcaption></figure><h1 id="2517" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">该指令</h1><p id="6869" class="pw-post-body-paragraph ky kz ir la b lb mr js ld le ms jv lg lh mt lj lk ll mu ln lo lp mv lr ls lt ik bi translated">创建一个名为<code class="fe lu lv lw lx b">tailwind</code>的指令，并使其全局可用，例如，通过在您的<code class="fe lu lv lw lx b">AppModule</code>中声明，或者如果您有一个<code class="fe lu lv lw lx b">CoreModule</code>作为单例/可重用内容的全局容器模块。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Tailwind directive</figcaption></figure><p id="1d22" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">发生了什么事？我们将接收一个字符串作为指令的输入。注意我们使用了选择器名称和输入两者<code class="fe lu lv lw lx b">tailwind</code>。相同的选择器和输入名称允许您用一个声明附加和获取输入。</p><p id="9f83" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">我们需要对输入进行一些处理。我们没有使用<code class="fe lu lv lw lx b">OnChanges</code>生命周期挂钩，而是使用了另一种带有getter &amp; setter的模式。与实现内部的<code class="fe lu lv lw lx b">ngOnChanges</code>方法相比，这更干净，并且只在输入改变时运行。</p><p id="09fa" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">指令可以访问主机，即指令应用的位置。我们使用<code class="fe lu lv lw lx b">@HostBinding(’class’)</code> decorator将类属性附加到主机上。</p><p id="7cf7" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">在setter中，我们获取输入字符串并-</p><ol class=""><li id="8331" class="my mz ir la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">用空格分割字符串。然后我们有一个字符串元素的数组。</li><li id="62d8" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">对于每个字符串元素，查看我们是否在<strong class="la is">样式映射</strong>中有匹配。如果是，那么返回映射的更大的字符串(tailwind类)。否则，返回字符串本身。因此，如果字符串元素是<code class="fe lu lv lw lx b">layoutCenter</code>，那么我们得到<code class="fe lu lv lw lx b">flex items-center justify-center</code>，如果是<code class="fe lu lv lw lx b">bla</code>，那么我们得到<code class="fe lu lv lw lx b">bla</code>。</li><li id="7bd3" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">我们将所有解析后的字符串再次用空格分隔连接起来。</li></ol><h1 id="5c83" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">使用</h1><p id="e9b3" class="pw-post-body-paragraph ky kz ir la b lb mr js ld le ms jv lg lh mt lj lk ll mu ln lo lp mv lr ls lt ik bi translated">我们的诡计得逞了！是时候在模板中使用它了。你像这样使用它:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Usage of Tailwind Directive</figcaption></figure><p id="885f" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">现在你甚至可以通过<code class="fe lu lv lw lx b">tailwind="someclass"</code>指令直接应用tailwind类，而不是HTML类属性(<code class="fe lu lv lw lx b">class="someclass"</code>)；我不是警察！可能性无穷:)</p><h1 id="236a" class="lz ma ir bd mb mc md me mf mg mh mi mj jx mk jy ml ka mm kb mn kd mo ke mp mq bi translated">利弊</h1><ol class=""><li id="c9c4" class="my mz ir la b lb mr le ms lh nm ll nn lp no lt nd ne nf ng bi translated">对顺风类进行分组并在应用范围内使用要容易得多。你不需要为每个元素做单独的指令/包装组件，比如<code class="fe lu lv lw lx b">button</code>、<code class="fe lu lv lw lx b">card</code>，只是为了在你的应用中应用一些样式类。</li><li id="f84d" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">如果有许多样式，应用程序必须将一个大的typescript对象加载到内存中。没什么大不了的，但还是要记在心里。</li><li id="0887" class="my mz ir la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">定制类的顺序很重要。最右边的自定义类包含的顺风类将覆盖左边的自定义类。这就是为什么<code class="fe lu lv lw lx b">button buttonSecondary</code>会按预期工作，而<code class="fe lu lv lw lx b">buttonSecondary button</code>不会。</li></ol><p id="c535" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated">分享你的想法和/或建议作为回应。感谢阅读！</p><p id="6886" class="pw-post-body-paragraph ky kz ir la b lb lc js ld le lf jv lg lh li lj lk ll lm ln lo lp lq lr ls lt ik bi translated"><em class="ly">更多内容请看</em><a class="ae kw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="la is"><em class="ly">plain English . io</em></strong></a></p></div></div>    
</body>
</html>