<html>
<head>
<title>How to Properly Implement Authorization in a Microservice Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在微服务应用程序中正确实现授权</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-properly-implement-authorization-in-a-microservice-application-8fdb0d4dab1e?source=collection_archive---------5-----------------------#2021-10-05">https://javascript.plainenglish.io/how-to-properly-implement-authorization-in-a-microservice-application-8fdb0d4dab1e?source=collection_archive---------5-----------------------#2021-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a1d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何将安全认证和授权正确集成到您的微服务应用中的3种不同策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a65e6d19dc58019b4f06cf9ebc856a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9D8YfARa4VCTuXX6Na7_Xw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://pixabay.com/de/users/buffik-17824401/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5475655" rel="noopener ugc nofollow" target="_blank">Buffik </a>on <a class="ae kv" href="https://pixabay.com/de/illustrations/business-technology-stadt-line-5475655/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="79d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微服务已经成为软件开发中最流行的架构模式之一，这是有充分理由的！它们提供更快的开发周期，允许独立部署，提高可伸缩性，并允许您为特定任务使用最好的工具。然而，各种传统方法在微服务架构中不再有效。其中一个领域就是处理授权。</p><h2 id="e0cf" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">单片应用中的认证和授权</h2><p id="63d0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在传统的单片应用中，它通常是这样工作的:</p><ol class=""><li id="a582" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">当未经认证的用户试图访问受保护的资源时，该用户被重定向到登录页面，在该页面中他认证自己(例如，通过使用密码)。</li><li id="91e9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">应用程序在数据库中创建一个用户会话，将用户信息存储在其中，并将会话id作为cookie发送给用户。</li><li id="c436" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">浏览器随每个请求发送这个会话cookie，允许应用程序从数据库加载用户会话，并检查是否允许该用户执行请求。</li></ol><h2 id="81a1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">微服务呢？</h2><p id="9813" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这很容易实现，并且适用于单片应用程序。然而，在微服务架构中，我们不希望用户单独登录每个服务。因此，需要某种分布式会话。</p><p id="4bce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这个问题已经解决了很多次。到目前为止，在我见过的大多数情况下，使用了以下三种方法之一:反向代理上的会话、每个后端或OAuth2中的OIDC和用户会话，以及前端中的访问令牌。让我们看看这三个，并检查他们的利弊。</p><h2 id="5e4c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">反向代理中的用户会话</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/31f02459f570182697ec10455b9db99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ql_uWuPeryklJ4b81NhcqA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Storing the user session including a JWT in a reverse proxy</figcaption></figure><p id="a865" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反向代理是客户端和微服务之间的系统，它将请求分发到各种服务。在基本上所有的微服务应用中，都使用某种反向代理功能。然而，它通常被集成到负载平衡器或Web应用防火墙(WAF)中，或者由Kubernetes这样的基础设施提供。</p><p id="e8a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">身份验证成功后，反向代理除了通常的任务之外，还可以在用户会话中存储用户信息，并将会话id作为cookie发送给用户，就像一个整体应用程序一样。然后，浏览器在每个请求中发送这个cookie，反向代理加载会话并将信息发送给微服务，通常是作为JSON Web令牌(JWT)。</p><p id="8e37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简单的解决方案易于实现，并且有许多现成的解决方案已经提供了这个特性(例如，开源反向代理NGIX的<a class="ae kv" href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html" rel="noopener ugc nofollow" target="_blank"> auth_request </a>模块)。使用这种经过验证的实现为您提供了额外的安全优势，因为恶意请求甚至不会到达您的服务。此外，大多数云提供商已经提供这种服务(例如，<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/Azure AD Application Proxy"> Azure广告应用代理</a>)。然而，有几个缺点:</p><ul class=""><li id="fcf6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nf mw mx my bi translated">反向代理变成了单点故障，您被牢牢地捆绑在某个代理产品上。你通常想避免的事情。</li><li id="4622" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">反向代理必须处理一个状态，因此，如果您需要它的多个实例，您必须使用一些会话感知负载平衡或分布式会话缓存，这两者都会带来问题。</li><li id="3817" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">所有微服务必须在一个公共域下可访问，否则，会话cookie将不会被发送。</li></ul><p id="4a1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这种模式非常适合中小型应用程序，但是对于大型和高度分布式的应用程序，它很快就会变得混乱。</p><h2 id="5145" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">开放授权(OAuth) 2和开放ID连接(OIDC)</h2><p id="4b4f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">OAuth2是访问授权的开放标准。它允许用户(称为“资源所有者”)使用可信的第三方(“授权服务器”)授予应用程序(“客户端”)对“资源服务器”上的资源的访问权。另一方面，OpenID是一种身份联合协议，允许用户为多个网站(“依赖方”)使用一个可信方(称为“身份提供商”)的登录。第三代OpenID基于OAuth2，名为“OpenID Connect”(OIDC)。因此，OAuth2和OpenID-Connect这两个术语经常互换使用，但是它们使用的语义略有不同。</p><p id="f3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的微服务架构中使用OAuth2/OIDC时，单个服务负责用户认证(通常称为“授权服务器”或“身份提供者”)。这种服务的各种实现已经存在，例如开源的<a class="ae kv" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>，还有像微软的<a class="ae kv" href="https://docs.microsoft.com/en-us/windows-server/identity/active-directory-federation-services" rel="noopener ugc nofollow" target="_blank">活动目录联合服务</a>这样的商业产品。然而，有两种不同的方法可以将它集成到您的架构中。</p><h2 id="c812" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">后端的OIDC</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/9415b5ce483d43b23d700ab7837e48d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkG14yLrR-d_NQTiCKv18w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Storing the user session in the backend</figcaption></figure><p id="7dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它集成到您的应用程序中的最简单的方法是将您的微服务设置为OIDC依赖方。当用户第一次访问微服务时，它会将用户重定向到身份提供者，身份提供者在成功认证后会将用户重定向回应用程序。作为重定向的一部分，一个代码被发送到微服务，然后微服务可以使用这个代码从身份提供者那里获得一个包含所有需要的用户信息的id-token。与单一应用程序一样，后端将这些信息存储到用户会话中，并向客户端发送一个会话cookie。</p><p id="3e13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个微服务都必须执行这样的OIDC登录。但是，在第一次登录后，身份提供者已经知道用户，因此他可以直接向微服务返回一个代码，而无需额外的用户交互。</p><p id="bc58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于基本上所有的技术堆栈都有库，因此这种解决方案也很容易实现，并且不太依赖于单点故障(与反向代理不同，身份提供者仅在第一次请求中使用),但它本身也有一些缺点:</p><ul class=""><li id="b26a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nf mw mx my bi translated">您无法从反向代理的额外安全性中获益。如果你在后台搞砸了验证码，将会有严重的后果。</li><li id="4103" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">现在在每个后端都有一个用户会话，每个都有不同的超时时间，等等。如果一个前端接受多个后端服务，事情会变得非常复杂并且容易出错。</li></ul><p id="3c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式非常适合较小的应用程序，尤其是当它们实现了<a class="ae kv" href="https://samnewman.io/patterns/architectural/bff/" rel="noopener ugc nofollow" target="_blank">后端-4-前端</a>方法的时候。对于任何其他应用程序，我都不推荐这种模式。甚至对于后端-前端应用程序，使用代理服务器可能更好。</p><h2 id="394f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">前端的OAuth2</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/f653f6fdda217ca76600c193fa54e416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kN-0sSkDjxt2VhrLTMpORA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Storing a JWT in the frontend, no backend sessions needed</figcaption></figure><p id="daf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在使用富前端(例如，单页面应用程序)，您也可以将用户信息存储在前端，而不是存储在后端会话中。在前端访问第一个受保护的微服务之前，它将用户重定向到授权服务器，授权服务器在成功认证之后将用户重定向回应用。现在，前端使用来自重定向的代码从认证服务器获取访问令牌。然后，这个访问令牌存储在前端，并在需要时作为授权头发送到后端。</p><p id="0d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不容易实现，因为前端需要(安全地)存储访问令牌，并自行处理超时和状态变化。虽然可行，但这需要相当多的工作。我计划写一个专注于如何做到这一点的故事。</p><p id="1a09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有了这个解决方案，您就有了最大的灵活性。您可以连接多个无状态后端，支持单个SPA中的公共和私有部分，并处理非活动超时等。优雅地站在你面前。您甚至可以在将请求发送到后端之前使用反向代理或web应用程序防火墙来验证访问令牌，并从额外的安全性中获益，而不会失去服务的无状态性。因此，对于大型或高度分布式的应用程序，我推荐这种方法。</p><h2 id="e1dc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">其他方法</h2><p id="acdc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">还有几种其他解决方案策略，例如，使用包含访问令牌的共享cookie，或者对所有微服务使用共享会话存储。但是当涉及到认证时，我只能建议您不要重新发明轮子，而要坚持久经考验的计划。错过某些东西并引入严重的安全缺陷实在是太容易了。如果你不知道自己在做什么，那就不值得。</p><h1 id="67e8" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">摘要</h1><p id="d2ed" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">微服务应用中的身份验证不是一个简单的话题，根据您的具体需求，应该使用不同的策略。对于中小型应用程序，使用提供身份验证的反向代理是保护资产的一种简单而安全的方法。但是当构建复杂的、高度分布式的应用程序时，这种策略会有太多的缩减，所以在这种情况下，我建议您在前端实现OAuth2。</p><p id="5221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有不同的经历，我很想听听！给我写封回信，或者在<a class="ae kv" href="https://www.linkedin.com/in/matthias-graf-81b458183/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae kv" href="https://twitter.com/graf_matthias" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系我。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="856e" class="ni lt iq bd lu nj oa nl lx nm ob no ma jw oc jx md jz od ka mg kc oe kd mj ns bi translated">资源</h1><div class="of og gp gr oh oi"><a href="https://openid.net/connect/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">OpenID连接| OpenID</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">OpenID Connect 1.0是OAuth 2.0协议之上的一个简单的身份层。它允许客户验证…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">openid.net</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://datatracker.ietf.org/doc/html/rfc6749" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">RFC 6749:oauth 2授权框架</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">互联网工程任务组。征求意见:6749微软过时:5849 2012年10月…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">datatracker.ietf.org</p></div></div></div></a></div><div class="of og gp gr oh oi"><a href="https://www.keycloak.org" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">钥匙锁</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">轻松地为应用程序和安全服务添加身份验证。不需要处理存储用户或…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.keycloak.org</p></div></div></div></a></div><p id="95fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="or">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="or">plain English . io</em></strong></a></p></div></div>    
</body>
</html>