<html>
<head>
<title>Create an Editable, Resizable Text Label in Konva with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React在Konva中创建一个可编辑、可调整大小的文本标签</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-an-editable-resizable-text-label-in-konva-with-react-8ab3a6b11dfb?source=collection_archive---------4-----------------------#2021-09-11">https://javascript.plainenglish.io/creating-an-editable-resizable-text-label-in-konva-with-react-8ab3a6b11dfb?source=collection_archive---------4-----------------------#2021-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e4a3a3989a9154cca91237e7a76fd057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*BLBgj9aQFiB22s92vrhxig.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">An example of sticky notes and connection labels in Reciprocal.dev using the techniques to create editable and resizable text in Konva</figcaption></figure><p id="cbea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发<a class="ae kw" href="https://reciprocal.dev" rel="noopener ugc nofollow" target="_blank"> Reciprocal.dev </a>的过程中，很明显，对于大多数用户来说，用户旅程地图的构建模块不是一个屏幕模型，而是一个简单的便笺。</p><p id="7d83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种便笺允许用户快速记下用户旅程中的一个步骤，并将其移动到多个上下文区域，直到它适合正确的位置。一个模型需要更多的努力，有时必须做出重大改变，以适应着陆区域的其余步骤。</p><p id="b1ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向应用程序添加一个便笺组件非常简单，它只是一个带有一些文本的矩形，但棘手的部分是如何使用户能够快速编辑文本，而不必填写表单来查看文本的更改。</p><p id="3942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">允许编辑便笺的解决方案还需要扩展到其他组件，如连接标签，以便为编辑画布上的文本组件提供一致的UX。</p><p id="edf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是<a class="ae kw" href="https://konvajs.org/docs/sandbox/Editable_Text.html" rel="noopener ugc nofollow" target="_blank"> Konva文档中有一个演示，演示了如何创建可编辑和可调整大小的文本</a>，所以我不得不修改这些以在react-konva中工作，并将这两种方法合并到一个组件中。</p><h2 id="1d4b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">使文本可编辑</h2><p id="6745" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">制作可编辑文本的技巧是使用放置在画布文本上的HTML输入，然后从输入中删除样式，这样当用户键入时，就好像他们在直接更新画布文本一样。</p><p id="e285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">react-konva-utils</code>库有一个<code class="fe lv lw lx ly b">Html</code>组件，允许在Konva画布上呈现HTML，如果你在画布上提供它需要呈现的X和Y坐标。</p><p id="4076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在HTML中，我们可以呈现一个类似于Konva docs中的可编辑文本演示的<code class="fe lv lw lx ly b">textarea</code>，但是为了让它看起来好像<code class="fe lv lw lx ly b">textarea</code>实际上是画布上的文本，我们需要应用样式来隐藏默认的UI元素，这些元素泄露了它是一个<code class="fe lv lw lx ly b">textarea</code>的事实。</p><p id="9aff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一种方法，允许用户退出编辑模式，回到画布上查看编辑文本。我的实现以两种方式做到了这一点；第一个是按照konva示例监听return和escape键，但是我还在舞台上设置了一个onClick事件，以便在文本区域之外单击会重置状态以显示不可编辑的文本。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The isEditing flag controls if the user sees the canvas Text or the textarea HTML input. When the stage is clicked the isEditing flag is set to false allowing the user to end editing by clicking outside the sticky note</figcaption></figure><h2 id="22a5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">调整文本大小</h2><p id="45b2" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">要实现的第二个行为是能够在文本没有被编辑时调整其大小。如果文本很长，这将允许用户改变文本的宽度，以便使其适合较小的空间。</p><p id="5f39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是通过使用一个<code class="fe lv lw lx ly b">Transformer</code>组件实现的，该组件被配置为转换<code class="fe lv lw lx ly b">Text</code>组件，但是被锁定为只允许在X轴上调整大小。</p><p id="69f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，转换器的回调在更高的组件级别更新文本的宽度和高度，以便画布文本、文本输入和可调整大小的文本获得新的尺寸。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The transformer is only applied when the text transform has been activated. This state is set at the higher component level and will become useful later</figcaption></figure><h1 id="8f7e" class="mf ky iq bd kz mg mh mi lc mj mk ml lf mm mn mo li mp mq mr ll ms mt mu lo mv bi translated">将两个动作合并成一个组件</h1><p id="5810" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我希望可编辑文本组件的UX是，单击可以调整文本的大小，双击可以编辑文本。</p><p id="6e90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我创建了一个组件，它包装了上面详述的<em class="mw"> EditableTextInput </em>和<em class="mw"> ResizableText </em>组件，并根据用户执行的操作，使用状态来显示适当的组件。</p><p id="3b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非活动状态将显示作为<em class="mw"> ResizableText </em>组件的一部分呈现的画布文本，因此单击只是切换该组件上的转换器。双击会将<em class="mw"> ResizableText </em>组件换成<em class="mw"> EditableTextInpu </em> t组件。</p><p id="ddee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使包装器组件可重用，状态将不会在包装器内被跟踪，而是在父组件外部被跟踪，这样当状态改变时，它就可以控制如何呈现自己。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">The wrapper component. It takes two flags; isEditing and isTransforming which are used to show the text input and transformer. These flags are tracked and updated in the parent component</figcaption></figure><p id="bcde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用EditableText包装器组件的组件需要跟踪编辑和转换状态，但也需要在点击阶段时更新这些状态，因此需要添加一个<code class="fe lv lw lx ly b">useEffect</code>挂钩，以便在发生这种情况时更新这些标志。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">An implementation of the EditableText within a component. The useEffect hook listens for changes to the selected flag and resets the editing/transforming state when the flag is set to false by a click on the stage</figcaption></figure><h1 id="ea7a" class="mf ky iq bd kz mg mh mi lc mj mk ml lf mm mn mo li mp mq mr ll ms mt mu lo mv bi translated">演示</h1><p id="7015" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">您可以在我创建的允许编辑便笺的演示应用程序中找到可编辑&amp;可调整大小文本的<a class="ae kw" href="https://codesandbox.io/s/react-konva-editable-resizable-text-55kyv?file=/src/StickyNote.jsx" rel="noopener ugc nofollow" target="_blank">示例实现。</a></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mx me l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">A demo of an editable and resizable text block. Illustrated using a sticky note-like component</figcaption></figure><h1 id="6ae6" class="mf ky iq bd kz mg mh mi lc mj mk ml lf mm mn mo li mp mq mr ll ms mt mu lo mv bi translated">结论</h1><p id="6461" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">通过让用户在画布中编辑文本和调整文本大小，你可以给他们更多的交互体验，并且更好地控制他们正在编辑的文本元素如何适应他们正在工作的整个画布。</p><p id="0b32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法可以进一步发展，将用于可编辑文本的基本<code class="fe lv lw lx ly b">textinput</code>替换为功能更丰富的编辑小部件，因为编辑功能是在画布上呈现的HTML块中呈现的。</p><p id="eb4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mw">更多内容请看</em><a class="ae kw" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>