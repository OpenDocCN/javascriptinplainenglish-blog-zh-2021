<html>
<head>
<title>TypeScript Typeguard Transparency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript Typeguard透明度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typeguard-transparency-fe33061c1744?source=collection_archive---------15-----------------------#2021-02-28">https://javascript.plainenglish.io/typeguard-transparency-fe33061c1744?source=collection_archive---------15-----------------------#2021-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8025" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些熟悉TypeScript的人来说，您可能已经知道了typeguards以及它们有多有用。如果你不熟悉typeguards，我建议你去看看。关于这一主题有大量的指南和资源:</p><ul class=""><li id="ccae" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><a class="ae kr" href="https://basarat.gitbook.io/typescript/type-system/typeguard" rel="noopener ugc nofollow" target="_blank">https://basarat.gitbook.io/typescript/type-system/typeguard</a></li><li id="e495" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" href="https://rangle.io/blog/how-to-use-typescript-type-guards/" rel="noopener ugc nofollow" target="_blank">https://rangle.io/blog/how-to-use-typescript-type-guards/</a></li><li id="7ad8" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" href="https://2ality.com/2020/06/type-guards-assertion-functions-typescript.html" rel="noopener ugc nofollow" target="_blank">https://2 ality . com/2020/06/type-guards-assertion-functions-typescript . html</a></li></ul><p id="4b5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然已经有许多很好的资源可用，但是给出的大多数例子都处理非常小的数据结构，或者只处理一个字段的有效性。</p><p id="be38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我目前工作的地方，我们大量使用typeguards来验证API响应是我们期望的，并且在将对象保存到我们的数据库之前，对象具有正确的形状和有效的数据。</p><p id="c527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在这种规模下，typeguards对我来说变得太不透明了……尤其是在处理更大的数据模型和嵌套结构时。</p><p id="ceb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个类型<code class="fe kx ky kz la b">Car</code>及其子类型<code class="fe kx ky kz la b">Engine</code>和<code class="fe kx ky kz la b">Wheel</code>的例子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/c6ef76ba43f8f2e85fb9334f4db331f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJsiV4L95dwpPmVHe-MvAw.png"/></div></div></figure><p id="708e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们正在检查的obj在wheel对象中嵌套了不正确的类型，该怎么办呢？或者引擎对象的<code class="fe kx ky kz la b">fuelType</code>是<code class="fe kx ky kz la b">deisel</code>，而不是<code class="fe kx ky kz la b">diesel</code>，这是因为代码库中某处的一些小错误。虽然typeguard会完成它的工作，声明对象不是Car类型，但是试图调试这种情况很快就会变成一场噩梦。如果您对失败的类型检查抛出错误，您可能会看到类似“Object x与Car的模式不匹配”的内容。在这一点上，你可能会对自己说:“嗯……是的，这是怎么回事?”？?"</p><p id="e397" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里真正的陷阱是，如果一个字段无效，整个检查就会失败，而且没有任何原因。这将不可避免地迫使您注销整个对象，这样您就可以尝试查看无效字段在哪里……这可不好玩。</p><p id="5333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在我们的系统中遇到了许多这样的错误之后，我对我们的类型守卫在失败的类型检查背后的推理中所给予的透明度如此之少感到非常沮丧。以下是我想到的解决方案。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ln"><img src="../Images/811c1452e16ad4e65bf9761860ba1707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djCeKZQl5OtVUc5U1zPM4Q.png"/></div></div></figure><p id="485e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们有两个通用助手，RuleSet和isType。</p><p id="2b18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RuleSet是一个通用接口，它定义了一个键和一个用于检查该键是否有效的函数。规则集中的密钥应该与接口中的密钥完全匹配。</p><p id="bd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">isType是一个通用类型检查函数，它接受要检查的对象和要检查的规则集。这里的好处是isType将记录任何未通过检查的键和值。</p><p id="afdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定我们的<code class="fe kx ky kz la b">Car</code>类型示例，我们可以将所有的typeguard函数(<code class="fe kx ky kz la b">isCar</code>、<code class="fe kx ky kz la b">isEngine</code>、<code class="fe kx ky kz la b">isWheel</code>)更改为规则集。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ln"><img src="../Images/4e5422fc84298fca615fa4426fa1b272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07iNpXT2HgmUshzUq-ahsg.png"/></div></div></figure><p id="07cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，我们的规则集看起来几乎和我们的typeguard函数一模一样，实际上更容易阅读和定义(至少在我看来是这样)。</p><p id="7e03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们有一个小的输入错误，比如我们的引擎模型将<code class="fe kx ky kz la b">fuelType</code>作为<code class="fe kx ky kz la b">deisel</code>而不是<code class="fe kx ky kz la b">diesel</code>，我们会得到一条消息，指出对象无效的确切原因:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lo"><img src="../Images/3083cb08bbd033d7f2333d96640bad92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SrBD0DLQEr27lHAmV2OyXQ.png"/></div></div></figure><h2 id="99b9" class="lp lq in bd lr ls lt dn lu lv lw dp lx jv ly lz ma jz mb mc md kd me mf mg mh bi translated">结论</h2><p id="78bb" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">我希望你觉得这篇文章很有价值，并希望它能节省你将来调试的时间！</p><p id="eda0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">源代码和测试可以在这里找到:<a class="ae kr" href="https://gist.github.com/armueller/ac31bfe290f256eda830ea495d3426dd" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/armueller/AC 31 bfe 290 f 256 EDA 830 ea 495d 3426 DD</a></p></div></div>    
</body>
</html>