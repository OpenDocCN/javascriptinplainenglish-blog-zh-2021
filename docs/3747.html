<html>
<head>
<title>What’s Exported Fragment in Web Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web开发中输出的片段是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-exported-fragment-in-web-development-bd0ae16a0429?source=collection_archive---------12-----------------------#2021-07-27">https://javascript.plainenglish.io/whats-exported-fragment-in-web-development-bd0ae16a0429?source=collection_archive---------12-----------------------#2021-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/78dd77b71f1e6eddb2ec10cff88465df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9qBMe9Wql3Vx0f3tpcPOA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@danny-meneses-340146?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Danny Meneses</a> from <a class="ae jz" href="https://www.pexels.com/photo/photo-of-turned-on-laptop-computer-943096/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="a275" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TLDR:导出的片段是组件模板的一部分，可以由父组件导出和控制，它可以帮助制作更简单的具有性能和大小优势的web应用。</p><p id="7b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">许多UI框架有包装器组件，如<code class="fe ky kz la lb b">Content</code>、<code class="fe ky kz la lb b">Actions</code>，它们执行包装器的角色，其中一些没有任何逻辑/代码。所以把它作为一个独立的组件看起来开销很大。</p><p id="accf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SMUI和Smelte是Svelte最流行的一些UI框架。我们在这里回顾一个问题。</p><h2 id="b228" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">1.顽固</h2><p id="8b66" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">我们来看组件<code class="fe ky kz la lb b">Card</code>(冶炼厂):</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/737c1381e3975dc493d38d62eb1e5baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osIh3EwmvcOqXa92IfbhbA.png"/></div></div></figure><p id="f7eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你看可以加槽<code class="fe ky kz la lb b"><strong class="kc io">title</strong></code>和槽<code class="fe ky kz la lb b"><strong class="kc io">media</strong></code>，很好，但是槽不让你换位置/顺序。如果我在<code class="fe ky kz la lb b"><strong class="kc io">media</strong></code>之后需要槽位<code class="fe ky kz la lb b"><strong class="kc io">title</strong></code>怎么办？老虎机就是不让你这么做。</p><p id="18aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以插槽不太适合这种情况，最好使用子组件，你可以把它放在你需要的地方。</p><h2 id="0071" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">2.开销</h2><p id="9a90" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">让我们看看来自框架SMUI的<code class="fe ky kz la lb b">Card</code></p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/0370fb86ae1d1c8056e322ff428dcbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-5yfwxC_o5u-kZ6ddbmWA.png"/></div></div></figure><p id="649a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有插槽，它使用组件(上例中的<code class="fe ky kz la lb b">Content</code>、<code class="fe ky kz la lb b">Actions</code>)，因此更灵活，但请注意它们的作用:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/91c073d94fe39082fb587926d60bf999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpq6jXolGp-KZhla4jS9rA.png"/></div></div></figure><p id="35ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">他们只是用类插入一个<code class="fe ky kz la lb b">div</code>。仅仅为了插入一个div元素而创建一个包含状态和上下文的完整组件值得吗？与只插入一个元素相比，它会产生开销(内存、性能和包大小)。</p><h2 id="0228" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">3.逻辑从属关系</h2><p id="d7e8" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">另一点是，像<code class="fe ky kz la lb b"><strong class="kc io">Card.Title</strong></code>、<code class="fe ky kz la lb b"><strong class="kc io">Card.Actions</strong></code>这样的“内部”组件——它们被期望作为组件<code class="fe ky kz la lb b"><strong class="kc io">Card</strong></code>的一部分使用，所以从概念上来说，它们不是像现在这样的独立组件。虽然这不是什么大问题。</p><h2 id="5116" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">如何改善？</h2><p id="1062" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">这三个子句都可以通过<code class="fe ky kz la lb b"><strong class="kc io">exported fragment</strong></code>来修复(你可以定义一部分模板，可以从组件中导出，<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/how-fragments-can-help-in-your-web-development-5efc4d10f9da">了解更多关于片段的信息</a>)。</p><p id="10c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">exported fragment</code>的优点:<br/> 1。灵活性——你可以把它放在你想放的地方(作为一个组件)<br/> 2。轻量级的，只是一个片段(不是一个完整的组件)<br/> 3。它在一个主组件内部(它是一个依赖代码)<br/> 4。它与一个组件共享一个范围(见下文)</p><p id="8e84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">导出的片段与主组件共享相同的作用域(相同的变量和函数)，因此它可以让您制定更简单的解决方案，例如，如果您需要主组件和片段之间的一些通信。</p><p id="1444" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的例子包含了一个组件<code class="fe ky kz la lb b"><strong class="kc io">Chip</strong></code>，它可以让你在任意位置放置项目<code class="fe ky kz la lb b"><strong class="kc io">ChipItem</strong></code>:<a class="ae jz" href="https://svelte.dev/repl/97b000a81b9f464fa2ce0ee7d071525b?version=3.38.3" rel="noopener ugc nofollow" target="_blank">版本，子组件在Svelte </a>上，<a class="ae jz" href="https://malinajs.github.io/repl/#/share/f9TOEVm9wgx?version=0.6.39" rel="noopener ugc nofollow" target="_blank">版本，导出片段在Malina.js上</a></p><p id="8a48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们比较一下这两种方式:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/e1d0498e893fdc5784f5906ce6456dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C_7z0dNkmvkXBublQEy8A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Svelte on the left, Malina.js on the right</figcaption></figure><p id="ee33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里没有大的区别，我们只是调用组件<code class="fe ky kz la lb b"><strong class="kc io">Chip</strong></code>并在里面插入项目。<br/>接下来是带项目的元件芯片:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/ea43d68bc6e3b6a9c52e6ddb54410f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMPEUaDcojU7QRuSL3Rw-g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Svelte on the left, Malina.js on the right (with exported fragment)</figcaption></figure><p id="27da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个片段给出了相同的结果，第一个看起来更复杂，因为它必须进行一些通信(上下文+存储)来共享“值”和“索引”。</p><p id="2fa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第二个例子中，变量“value”和“index”可用于组件和片段“item”——相同的作用域，因此不需要任何通信，组件本身变得更加简单。</p><p id="e53f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顺便说一下，导出的片段更紧凑——与创建整个组件相比，包增长更少，内存/CPU使用更少。<br/>我检查了导出片段的包增长速度——我又添加了一个片段/组件，并检查了包的大小:</p><h2 id="e03b" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated"><strong class="ak">基本示例，以字节为单位的包大小:</strong></h2><p id="7c9f" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated"><strong class="kc io">苗条</strong>:9170(3214 brot Li)<br/><strong class="kc io">malina . js</strong>:4289(1820 brot Li)<br/><strong class="kc io">malina . js(片段)</strong> : 4110 (1783 brotli)</p><h2 id="b775" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated"><strong class="ak">额外组件+ 2的示例调用:</strong></h2><p id="a238" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated"><strong class="kc io">苗条</strong>:10616(3494 brot Li)<br/><strong class="kc io">malina . js</strong>:4769(1961 brot Li)<br/><strong class="kc io">malina . js(片段)</strong> : 4485 (1885 brotli)</p><h2 id="a810" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated"><strong class="ak">束生长(brotli): </strong></h2><p id="cbaf" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated"><strong class="kc io"/>:+280字节<br/> <strong class="kc io"> Malina.js </strong> : +141字节<br/> <strong class="kc io"> Malina.js(片段)</strong> : +102字节</p><p id="690b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，bundle更小，使用导出的片段时增长更慢。一个简单的测试显示我有+8%的性能。</p><h2 id="4592" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">结论</h2><p id="2da4" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">导出片段提供了一种更灵活的方法来控制子组件，以及移动和复制子组件的片段。当您的组件(片段)只是一个包装器或者与一个主组件有很深的连接时，您可以使用它。</p><p id="ca1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，它可以提供更简单、更紧凑、更快速的解决方案。</p><p id="a069" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它不是组件的替代品，只是在某些情况下多了一个功能。</p><p id="69e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果不想错过benchmark“Vue vs Svelte vs malina . js”就在twitter上关注<a class="ae jz" href="https://twitter.com/malinajs" rel="noopener ugc nofollow" target="_blank">malina . js</a>；)</p><h2 id="54de" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">链接</h2><ul class=""><li id="689a" class="mj mk in kc b kd lv kh lw kl ml kp mm kt mn kx mo mp mq mr bi translated"><a class="ae jz" href="https://github.com/malinajs/fragment_comparison" rel="noopener ugc nofollow" target="_blank">源代码示例</a></li><li id="4bdf" class="mj mk in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated"><a class="ae jz" href="https://malinajs.github.io/repl/" rel="noopener ugc nofollow" target="_blank">在线编辑(REPL) </a></li><li id="c079" class="mj mk in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated"><a class="ae jz" href="https://github.com/malinajs/malinajs" rel="noopener ugc nofollow" target="_blank">GitHub</a>上的Malina.js，Twitter<a class="ae jz" href="https://twitter.com/malinajs" rel="noopener ugc nofollow" target="_blank">上的</a></li><li id="a160" class="mj mk in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">文章:<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/how-fragments-can-help-in-your-web-development-5efc4d10f9da">片段如何帮助你的网站开发</a></li></ul><p id="d8c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mx">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="mx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>