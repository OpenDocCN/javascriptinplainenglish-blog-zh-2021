<html>
<head>
<title>Introduction to the Proxy and Reflect APIs in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的代理和反射API简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/proxy-reflect-api-in-javascript-7d6a1e4e5811?source=collection_archive---------8-----------------------#2021-08-28">https://javascript.plainenglish.io/proxy-reflect-api-in-javascript-7d6a1e4e5811?source=collection_archive---------8-----------------------#2021-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6fcb1922d1e393d2a2d64463bae1348d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_K1Qa0fP6kf38JV0PuCGJw.jpeg"/></div></div></figure><div class=""/><p id="5d5b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代理和反射API出现在ES6中，两者配合得非常好！</p><p id="0d99" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，</p><h2 id="e6cf" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">代理人</h2><p id="4160" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">一个<strong class="jx iz">代理</strong>是外来物体，它没有属性！它包装了对象的行为。它需要两个参数。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="afc4" class="kt ku iy lw b gy ma mb l mc md">const toto = new Proxy(target, handler)</span></pre><p id="1b39" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">目标</strong>:代理将要代理/包装的对象。</p><p id="0367" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> handler: </strong>是代理的配置，它会拦截目标上的操作(get、set等。)，你会看到一个例子！</p><p id="b298" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多亏了<strong class="jx iz">代理</strong>，你可以像这样创建<code class="fe me mf mg lw b">traps</code>:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="436c" class="kt ku iy lw b gy ma mb l mc md">const toto = { a: 55, b:66 }<br/>const handler = {<br/>   get(target, prop, receiver) {<br/>      if (!!target[prop]) {<br/>         return target[prop]<br/>      }<br/>      return `This ${prop} prop don’t exist on this object !`<br/>   }<br/>}</span><span id="d04f" class="kt ku iy lw b gy mh mb l mc md">const totoProxy = new Proxy (toto, handler)</span><span id="9807" class="kt ku iy lw b gy mh mb l mc md">totoProxy.a // 55<br/>totoProxy.c // This c prop don’t exist on this object !</span></pre><p id="d69a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个内部对象<code class="fe me mf mg lw b">method</code>都有自己的<em class="mi">目标函数。</em></p><p id="f9c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是等同于Target的对象方法列表</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="78d6" class="kt ku iy lw b gy ma mb l mc md">| object method | target |<br/>| — — — | — — |<br/>| object[prop] | get |<br/>| object[prop] = 55 | set |<br/>| new Object() | construct |<br/>| Object.keys | ownKeys |</span></pre><p id="8ffd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是完整的清单🔗<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy*" rel="noopener ugc nofollow" target="_blank"><em class="mi">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Proxy/Proxy</em></a></p><p id="4a4c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目标函数的参数可以根据函数而改变。</p><p id="d40c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比如对于<strong class="jx iz"> get </strong>函数，取<em class="mi">(目标，道具，接收者(代理本身))</em>但是对于<strong class="jx iz"> set </strong>函数，取<em class="mi">(目标，道具，值(要设置)，接收者)。</em></p><h2 id="4e8f" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">用法示例</h2><p id="92f7" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们可以创造一个🔓秘密财产！</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2248" class="kt ku iy lw b gy ma mb l mc md"><br/>const toto = {<br/>   name: ‘toto’,<br/>   age: 25,<br/>   _secret: ‘***’<br/>}</span><span id="a6de" class="kt ku iy lw b gy mh mb l mc md">const handler = {<br/>   get(target, prop) {<br/>      if (prop.startsWith(‘_’)) {<br/>         throw new Error(‘Access denied’)<br/>      }<br/>      return target[prop]<br/>   },<br/>   set(target, prop, value) {<br/>      if (prop.startsWith(‘_’)) {<br/>         throw new Error(‘Access denied’)<br/>      }<br/>      target[prop] = value<br/>      // set methods return boolean,<br/>      // in order to let us know if the value has been correctly set !<br/>      return true<br/>   },<br/>   ownKeys(target, prop) {<br/>      return Object.keys(target).filter(key =&gt; !key.startsWith(‘_’))<br/>   },<br/>}</span><span id="c07a" class="kt ku iy lw b gy mh mb l mc md">const totoProxy = new Proxy (toto, handler)<br/>for (const key of Object.keys(proxy1)) {<br/>   console.log(key) // ‘name’, ‘age’<br/>}<br/></span></pre><h2 id="2c72" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">显示</h2><p id="3ebd" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">反射是一个静态类，它简化了代理的创建。</p><p id="ab72" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个内部对象方法都有自己反射方法:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="977c" class="kt ku iy lw b gy ma mb l mc md">| object method | Reflect|<br/>| — — — | — — |<br/>| object[prop] | Reflect.get|<br/>| object[prop] = 55 | Reflect.set|<br/>| new Object() | Reflect.construct|<br/>| Object.keys | Reflect.ownKeys |</span></pre><p id="02d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是完整的清单🔗<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect*" rel="noopener ugc nofollow" target="_blank"><em class="mi">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Reflect</em></a></p><p id="59b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">❓为什么要用它？因为它与代理配合得非常好！它接受与代理的处理程序相同的参数！</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="329b" class="kt ku iy lw b gy ma mb l mc md">const toto = { a: 55, b:66 }</span><span id="c23c" class="kt ku iy lw b gy mh mb l mc md">const handler = {<br/>   get(target, prop, receiver) {<br/>   // Equal to target[prop]<br/>   const value = Reflect.get(target, prop, receiver)<br/>   if (!!value) {<br/>      return value <br/>   }<br/>   return `This ${prop} prop don’t exist on this object !` <br/>   },<br/>   set(target, prop, value, receiver) {<br/>   // Equal to target[prop] = value<br/>   // Reflect.set return boolean, it’s perfect<br/>   // since set handler need to return boolean<br/>   return Reflect.set(target, prop, receiver)<br/>   },<br/>}</span><span id="2566" class="kt ku iy lw b gy mh mb l mc md">const totoProxy = new Proxy (toto, handler)</span></pre><p id="a10c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如您所见，代理和反射API是有用的，但您不会每天都使用它们。使用它们来制作陷阱或隐藏一些对象属性可能会很好。另一个解决方案是，比如符号。</p><p id="9fb0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你使用的是Vue.js框架，试着修改一个组件的props对象，它会触发一个来自Vue的警告日志，这个功能是使用代理完成的。:)</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="e030" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你喜欢这篇读物！</p><p id="fcd9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🎁你可以免费获得我的新书《javascript中被低估的技能》,如果你在推特上关注我的话😁</p><p id="b86a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者在这里得到它<a class="ae mj" href="https://codeoz.gumroad.com/l/RXLYp" rel="noopener ugc nofollow" target="_blank"/></p><p id="012d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🎁<a class="ae mj" href="https://www.getrevue.co/profile/code__oz" rel="noopener ugc nofollow" target="_blank">我的简讯</a></p><p id="e764" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">☕️你可以<a class="ae mj" href="https://www.buymeacoffee.com/CodeoZ" rel="noopener ugc nofollow" target="_blank">支持我的作品</a>🙏</p><p id="f563" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🏃‍♂️，你可以跟着我👇</p><p id="6e07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🕊 <a class="ae mj" href="https://twitter.com/code__oz" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="aaed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">👨‍💻<a class="ae mj" href="https://github.com/Code-Oz" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="f766" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以标记🔖这篇文章！</p><p id="4fed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mi">更多内容请看</em><a class="ae mj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="mi">plain English . io</em></strong></a></p></div></div>    
</body>
</html>