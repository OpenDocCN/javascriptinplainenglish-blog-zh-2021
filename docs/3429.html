<html>
<head>
<title>Understanding Memoization &amp; the useMemo React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解记忆化&amp;使用记忆反应钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/memoization-the-usememo-react-hook-9aeddc96d6fd?source=collection_archive---------11-----------------------#2021-07-11">https://javascript.plainenglish.io/memoization-the-usememo-react-hook-9aeddc96d6fd?source=collection_archive---------11-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/c1eb275809632f33c4fce2f84fe24b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*RsewJ8y0OsDw2m_edutPag.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Let’s Memoize!</figcaption></figure><p id="2194" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React的组件生命周期中，当进行更新时，组件被重新呈现。如果检测到React的虚拟DOM和浏览器内DOM之间存在差异(即difs ),就会出现这种情况，在这种情况下，包含difs的组件(以及这些组件的任何子组件)会在浏览器内重新呈现。如果你对这个概念不熟悉，或者你想重温一下React的虚拟DOM的功能，可以看看我在下面链接的关于这个主题的帖子(<em class="kt">插件</em>)。</p><div class="ku kv gp gr kw kx"><a href="https://denalibalser.medium.com/react-the-virtual-dom-d450b72df918" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">React &amp;虚拟DOM</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">首先，域对象模型(DOM)是由浏览器解析的表示，由文档的…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">denalibalser.medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jp kx"/></div></div></a></div><p id="adfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这一功能是React如此强大的部分原因，但如果您的组件包含由于与另一个组件连接而需要重新呈现的昂贵函数，它很容易降低应用程序的性能。此外，当React查找组件中的变化时，可能会检测到JavaScript处理浅层比较和等式的方式导致的意外difs导致冗余的重新呈现。</p><p id="4a6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您的组件包含昂贵的操作(例如长循环函数或从API获取大量数据)，这些不必要/意外的重新渲染会显著影响性能并导致较差的用户体验。React引入了<code class="fe lm ln lo lp b">memo</code>概念来解决这个问题。</p><h2 id="8edb" class="lq lr in bd ls lt lu dn lv lw lx dp ly kg lz ma mb kk mc md me ko mf mg mh mi bi translated">记忆入门</h2><p id="2360" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated"><em class="kt">记忆化</em>是一种优化技术，通过将昂贵的函数调用结果存储在缓存中(以便有效地“记住”)并在再次提供相同参数时返回这些结果，来提高程序的速度。当这种技术应用于一个函数时，该函数被<em class="kt">记忆</em>。</p><p id="dc60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个简单的例子，假设我们有一个函数，它接受一个整数作为参数，并返回该输入乘以<strong class="jx io"> 2 </strong>。我们提供<strong class="jx io"> 2 </strong>作为函数调用的参数，并返回<strong class="jx io">4</strong>——如果该函数在每次将<strong class="jx io"> 2 </strong>作为参数提供给函数调用时使用记忆，结果将被记忆并返回，而无需执行函数中的表达式。</p><p id="abda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然上面的例子非常简单，但是您可以想象在重新呈现组件的上下文中，对于一个更复杂、更昂贵的函数，记忆化将会带来多大的好处。</p><h2 id="eb5f" class="lq lr in bd ls lt lu dn lv lw lx dp ly kg lz ma mb kk mc md me ko mf mg mh mi bi translated">使用useMemo提高性能</h2><p id="34d9" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated"><code class="fe lm ln lo lp b">useMemo</code>是一个React钩子，它可以通过记忆来帮助提高应用程序性能——或者存储昂贵函数的结果，并在组件重新呈现时显示存储的结果，而不必重新运行函数，除非提供给函数的输入发生变化(在这种情况下，函数将重新运行)。</p><p id="dccb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，<code class="fe lm ln lo lp b">useMemo</code>长什么样？参考<a class="ae mo" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> React文档</a>，<code class="fe lm ln lo lp b">useMemo</code>表示如下:</p><pre class="mp mq mr ms gt mt lp mu mv aw mw bi"><span id="550c" class="lq lr in lp b gy mx my l mz na">const memoizedValue = React.useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span></pre><p id="d46e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上所示，<code class="fe lm ln lo lp b">useMemo</code>接受一个函数和一组依赖项。这些依赖项的作用类似于函数中的参数。依赖列表中的元素是<code class="fe lm ln lo lp b">useMemo</code>寻找的——如果在重新渲染之前和期间依赖之间没有差异，那么函数结果将保持不变。如果存在依赖性差异，则该函数将在重新渲染期间重新运行。可以想象，这可以显著降低重新呈现组件的开销，因为整个组件都可以重新呈现，而不必重新运行函数(如果依赖关系保持不变)，相反，存储的结果将在组件重新呈现中返回。</p><p id="ac5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lm ln lo lp b">useMemo</code>的主要用例是包装大而昂贵的函数，如果在每次重新渲染时重新运行，会降低应用程序的性能。</p><p id="2174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个将<code class="fe lm ln lo lp b">useMemo</code>应用于一个项目数组的例子，该数组使用了两个昂贵的函数:</p><pre class="mp mq mr ms gt mt lp mu mv aw mw bi"><span id="fcd9" class="lq lr in lp b gy mx my l mz na">const Cats = React.useMemo(() =&gt;<br/>  allTheCats.map(cat =&gt; ({<br/>    ...cat,<br/>    catProp1: firstExpensiveFunction(props.first),<br/>    catProp2: secondExpensiveFunction(props.second)<br/>  })), [allTheCats]<br/>)</span></pre><p id="380a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<code class="fe lm ln lo lp b">useMemo</code>函数将在第一次渲染时运行(因为依赖项是新的)，线程将被阻塞，直到两个昂贵的函数完成。在下面的组件重新渲染中，如果<code class="fe lm ln lo lp b">allTheCats</code>没有改变，这些昂贵的函数不需要重新运行。初始函数调用的结果将存储在<code class="fe lm ln lo lp b">Cats</code>变量中并从该变量中访问，并且保持不变，直到依赖关系发生变化。</p><p id="488b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由此产生的用户体验就好像这些昂贵的功能被即时呈现，使得<code class="fe lm ln lo lp b">useMemo</code>的应用程序更适合组件中昂贵的同步功能。</p><h2 id="16af" class="lq lr in bd ls lt lu dn lv lw lx dp ly kg lz ma mb kk mc md me ko mf mg mh mi bi translated">要记住的事情</h2><p id="d00a" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">在编写代码时，最好先写出函数，然后再看是否可以重构来优化性能。在应用程序中过多使用<code class="fe lm ln lo lp b">useMemo</code>会对性能产生负面影响。</p><p id="3b18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了确定您是否应该合并<code class="fe lm ln lo lp b">useMemo</code>，您可以利用分析工具来定位可以通过使用<code class="fe lm ln lo lp b">useMemo</code>来改进的性能问题。何时记忆的一个例子是在一个函数中定义了大量的变量(占用大量内存)。</p><p id="e492" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，<code class="fe lm ln lo lp b">useMemo</code>钩子有可能提高应用程序的性能——但是如果过度使用也会降低应用程序的速度，因为它用得越多，应用程序需要分配的内存就越多。</p><p id="c4d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容尽在</em><a class="ae mo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>