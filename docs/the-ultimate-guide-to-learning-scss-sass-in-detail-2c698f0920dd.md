# 学习萨斯/SCSS 的终极指南

> 原文：<https://javascript.plainenglish.io/the-ultimate-guide-to-learning-scss-sass-in-detail-2c698f0920dd?source=collection_archive---------4----------------------->

## 变量、嵌套、部分、模块、混合、继承、运算符等等

![](img/51272c89c275cfc48cfca45b419949fc.png)

Photo by [Paweł Czerwiński](https://unsplash.com/@pawel_czerwinski?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](/backgrounds/colors/gradient?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

Sass 是使用最广泛的预处理程序之一。预处理器是一种语言或程序，它从使用预处理器本身提供的独特语法和功能编写的代码中生成 CSS。由于浏览器不理解萨斯/SCSS 代码，所有代码都编译回标准 CSS。

## 萨斯对 SCSS

萨斯和 SCSS 基本上指的是同一种萨斯语言。它们之间唯一的主要区别是我们书写它们的方式。用`.scss`扩展名编写的文件遵循传统的用`{ }`编写规则的类块结构。而扩展名为`.sass`的文件遵循基于缩进的结构，没有分号(如 python 中使用的)来编写规则。

*   Sass(语法上令人敬畏的样式表)
*   SCSS(时髦的层叠样式表)

下面的例子显示了 Sass 和 SCSS 之间的语法差异。

> ***注:*** 我已经尽量完整了。但我肯定可能少了一些东西。如果你有任何反馈，请留下评论，我会更新文章。

## 新语法

SCSS 没有给 CSS 语言本身增加任何新的特性。只是一些新的语法和特性，缩短了编写 CSS 规则的时间。这使得将所有相关的选择器组织在一个地方变得更加容易，从而使得代码维护更加容易。

我们将在整篇文章中使用 SCSS 结构，因为大多数用户已经熟悉它了。

我们开始吧！

# 变量

如果用户希望在样式表中多次使用某个值，他们可以使用变量。为了创建变量，可以给一个以`$`开头的名称赋值，并且可以在整个样式表中使用相同的名称，而不是实际值。

看起来像`<variable-name> : <expression/value>`

当 Sass 被处理成 CSS 时，实际值将替换变量。

变量对于保持颜色、字体样式、布局样式以及其他需要在站点中保持一致的规则非常有用。如果有必要，用户可以在声明时修改它，而不是在样式表中每次出现时修改。

## **默认值**

通常，当您为变量赋值后又为其赋值时，原始值会被覆盖。

为了克服这一点，Sass 为您提供了一个`!default`标志，当使用该标志时，仅当变量尚未定义或者其值为`null`时，才将值赋给变量。

**配置模块**

如果您正在创建一个 Sass 库，您可能希望允许用户在他们的 SCSS 中使用它之前配置变量。

使用`!default`标志定义的变量可由用户在使用`@use`规则加载模块时进行配置。

您可以像这样配置模块:

```
@use <path/url> with (
    <variable-one> : <value-one>,
    <variable-two> : <value-two>
)
```

配置的值现在会覆盖库中分配的默认值。

## 范围

在顶部声明的变量是*全局变量*，可以在该文件的任何地方访问。但并不是每个变量都是这样，在一个块中分配的变量(即花括号)是局部的，只能在这个块中访问。

**遮蔽**

可以将值赋给与全局变量同名的局部变量。但它们在全局和局部范围内是两个不同的变量。它允许用户创建局部变量，而不会意外覆盖全局变量的值。

如果想在局部范围内给全局变量赋值，可以使用`!global`标志。`!global`标志确保值总是分配给全局范围变量。

**流量控制范围**

在流控制规则中声明的变量不会隐藏在与流控制规则相同的级别上声明的变量。相反，它们直接将值赋给它们，允许用户有条件地将值赋给变量。

# 插入文字

您几乎可以在 Sass 的任何地方使用插值来将表达式嵌入到一组 CSS 规则中。你只需要将表达式放在`#{}`中，如下例所示。

# 嵌套

Sass 允许用户将 CSS 选择器嵌套在与 HTML 相似的视觉层次中。您可以在另一个中编写一组样式规则，而不是重复相同的选择器。

嵌套是一种很好的组织样式的方式，因为与选择器相关的每一组规则都在一个地方。但是请注意不要将规则嵌套在深层，因为这将使维护变得更加困难，并且被认为是一种不好的做法。

## 选择器列表

嵌套规则在处理选择器列表(即逗号分隔的选择器列表)方面很聪明。每个选择器都单独嵌套，然后组合成一个选择器列表。

## 选择器组合子

你也可以将选择器和组合子嵌套在一起。您可以将组合子放在外部选择器的末尾，内部选择器的开头，或者它自己的不同级别。

## 高级嵌套

**父选择器**

父选择器(`&`)是 Sass 中的一个特殊字符，在嵌套选择器中用来引用其外部父选择器。您可以以不同的方式使用父选择器，比如添加*伪类*、*伪元素*，或者在父选择器之前添加一个选择器。

**添加后缀**

您还可以使用`&`为外部选择器添加后缀。

# 分音

您可以在 Sass 中编写部分文件，其中包含可以在其他 Sass 文件中使用的 CSS 小片段。分部规则是模块化 CSS 规则并使其更易于维护的好方法。

通过在实际名称前添加一个前导下划线，可以在 Sass 中创建部分文件。下划线让 Sass 知道该文件只是一个部分文件，不需要对其进行任何处理。

您可以使用`@use`规则在另一个文件中使用部分文件，并且您会注意到在使用它时不需要提供扩展名和前导下划线。

请记住，CSS 是从上到下解析的。因此，如果您想使用部分文件中的任何内容，请在实际的 Sass 中使用这些规则之前包含它。

# 模块

你不必把所有的脏话都写在一个文件里。借助于`@use`规则，您可以以任何方式分割它，并在您的主 Sass 文件中将它作为一个模块使用。这个规则允许用户使用基于文件名的名称空间来引用该模块中可用的变量、函数和混合。您可以使用文件名或给它一个别名来直接引用它们，如示例所示。

# 混合蛋白

用复杂的声明和各种现有的供应商前缀编写一些规则有点棘手。mixin 允许用户创建一组 CSS 声明，您可以在整个 Sass 中重用这些声明。

你可以使用`@mixin`指令并给它一个名字来创建一个 mixin。您可以通过在 mixin 名称后添加`@include`来将其用作声明。

## 争论

当您使用供应商前缀时，Mixins 非常有用。您甚至可以传递参数，使其更加动态和灵活。您可以通过在声明时在 mixin 名称后添加带参数的括号来实现这一点。并在圆括号内传递参数，同时将它与`@include`一起用作实际声明。你可以在下面的例子中看到它的用法。

**可选参数**

通常，mixin 中定义的每个参数都需要在使用时传递。但是可选参数允许用户做的是给参数赋予默认值，而不必在调用时提供它们。

**关键字参数**

除了根据参数在参数列表中的位置传递参数之外，还可以按名称传递参数。当涉及到许多可选参数时，这个特性非常有用。如果我们处理的是布尔值，除非给定一个名字，否则不会那么明显。

**采用任意参数**

如果 mixin 能够接受任意数量的参数，有时会很有帮助。如果 mixin 中定义的最后一个参数以“…”结尾，那么传递给它的所有剩余参数都作为一个列表分配给该参数。

## 内容块

mixin 也可以接受整个声明块，称为内容块。您可以通过在 mixin 主体中使用`@content`规则来声明 mixin 可以获取内容块。

您可以在 mixin 名称后使用花括号传递内容块，这个块是由 Sass 本身代替`@content`规则注入的。

# 扩展/继承

扩展/继承是 Sass 中最有用的特性之一。您可以使用`@extend`规则在不同的选择器之间共享一组 CSS 属性。

我们还将看到占位符类与`@extend`一起出现。占位符类是一种包含一组规则的类，这些规则只有在您扩展它们时才会生成。您可以通过添加前导`%`来表示一个类是共享的。

在上面的例子中，`shared`占位符在所有三个块中都被扩展，所以所有这些块共享相同的规则。这有助于避免在 HTML 元素中添加许多类。

注意，CSS 中没有生成`another-shared`占位符，因为您没有扩展它。

您也可以扩展选择器。但是建议使用占位符，因为它可以确保您没有使用嵌套在样式中其他位置的选择器，这可能会导致向 CSS 中添加一些意外的规则集。

# 经营者

在你的 CSS 中做数学运算会很有帮助。Sass 允许您使用标准的数学运算符，如`+`、`-`、`*`、`/`和`%`。

Sass 还允许使用许多其他操作符，如下所示。

*   `==`和`!=`用于检查是否相等。
*   `<`、`<=`、`>`和`>=`用于检查两个数是否大于或小于对方。
*   `and`、`or`和`not`的行为类似于通常的布尔运算符。除了`false`和`null`之外，Sass 将每个值都视为`true`。
*   `+`、`-`和`/`用于连接字符串。

## 优先顺序

Sass 的操作顺序如下所示:

1.  一元运算符`not`、`+`、`-`和`/`。
2.  `*`、`/`和`%`操作员。
3.  `+`和`-`操作符。
4.  `>`、`>=`、`<`和`<=`操作员。
5.  `==`和`!=`操作员。
6.  `and`操作员。
7.  `or`操作员。
8.  `=`操作员。

**括号**

您可以使用括号更改优先顺序。用括号括起来的操作具有最高的优先级，在所有其他操作符之前进行计算。

## 单一平等

Sass 还支持只允许作为函数参数的`=`操作符，它创建一个两边都有两个操作数的无引号字符串。该运算符的存在只是为了向后兼容旧的 IE 特定语法。

```
**.transparent-blue** {
  **background**: **chroma**(color**=**#0000ff);
}
```

**注意:**为了查看不同操作符的输出，我们将使用`@debug`规则。您可以使用`@debug`规则来查看变量或表达式的值。您可以将它用作`@debug <expression/variable>`，它打印表达式的结果以及文件名和行号。

## 不同运算符的详细信息

## 平等

相等运算符检查给定的两个值是否相同。写为`<expression> == <expression>`检查是否相等，`<expression> != <expression>`检查是否*不*相等。

如果两个表达式/值具有相同的类型和值，则认为它们相等。该规则在不同的数据类型之间略有不同。你可以从下面的例子中得到更好的想法。

## 有关系的

关系运算符检查给定的数字是大于还是小于彼此。不同的关系运算符是`>`、`>=`、`<`和`<=`。如果可能，它们会自动将操作数转换为兼容的单位。

没有单位的数可以和其他有单位的数比较。它们会自动转换为该单位。

```
**@debug** 50 > 50px; // false
**@debug** 5px < 7; // true
```

不能用不兼容的单位来比较数字。

```
**@debug** 100px **>** 10s;
Error: 10px and 10s have incompatible units.
```

## 数字的

Sass 支持标准的数学运算符，如`+`、`-`、`*`、`/`和模运算符(`%`)。数学运算符会自动在兼容单位之间转换。

无单位的数字可以和有单位的数字一起使用。

```
**@debug** 100px **+** 20; *// 120px* **@debug** 5s ***** 10; *// 50s*
```

具有不兼容单位的数字不能与`+`、`-`或`%`运算符一起使用。

```
**@debug** 10px + 10s;
Error: 10px and 10s have incompatible units.
```

**一元运算符**

也可以使用`+`和`—`作为一元运算符。

`+`操作符返回表达式的不变值，`—`操作符返回它的负版本。

```
**@debug** **+**(5s **+** 10s); *// 15s* **@debug** **-**(5s **+** 3s); *// -8s* **@debug** **-**(10px **-** 15px); *// 5px*
```

**斜线分隔值**

一些 CSS 属性将`/`作为分隔值的一种方式，这意味着在作为分隔值的`/`和作为除法运算符的`/`之间存在歧义。

仅当满足任何给定标准时，由`/`分隔的两个数字将被打印为斜线分隔，而不是除法:

*   两个操作数都不是文字数字。
*   计算结果保存在变量中或作为函数调用的结果返回。
*   运算在括号内。
*   包含`/`的求值部分是另一个表达式的一部分。

如果你想强制使用`/`作为分隔符，你可以这样写:

`#{<expression>} / #{<expression>}`。

**单位**

Sass 擅长单位计算。

当任意两个数相乘时，它们的单位也会相乘。当两个数相除时，结果是从第一个数得到分子单位，从第二个数得到分母单位。

一个数的分子和/或分母可以有多个单位。

Sass 会自动将操作数转换为兼容的单位，尽管结果得到的单位取决于您正在使用的 Sass 的实现。

```
// In CSS one inch is considered as 96 pixels.
**@debug** 1in + 4px; // 100px or 1.0416666667in**@debug** 1in + 1s;
// Error: 1in and 1s have incompatible units.
```

## 线

Sass 支持一些字符串操作符。

*   `+`生成包含两个表达式值的字符串。如果任一表达式的值是带引号的字符串，则结果将带有引号，否则，它将是不带引号的字符串。
*   `/`生成一个不带引号的字符串，它包含两个表达式的值，用一个`/`隔开。
*   `-`生成一个不带引号的字符串，它包含两个表达式的值，由`-`分隔。因为这是一个传统的操作符，您应该使用插值来代替它。

您还可以将它们与任何可以写入 CSS 的值一起使用，只有少数例外，如数字和颜色不能用作左边的值，因为它们有自己的运算符。

```
**@debug** "ETA: " + 10s; // "ETA: 10s";
**@debug** true + " is a boolean value"; // "true is a boolean value";
```

## 布尔代数学体系的

Sass 使用单词而不是字符作为布尔运算符。

*   `not`运算符给出相反版本的表达式。
*   `and`只有当两个操作数都是`true`时，运算符才返回`true`。
*   `or`只有当给定的两个操作数中的任何一个为`true`时，运算符才返回`true`。

# At 规则

Sass 语言的额外特性以不同 at-rules 的形式添加到 CSS 之上。

您已经在前面的章节中看到了`@use`、`@mixin`、`@include`、`@extend`和`@debug`规则。在这里，您将看到 Sass 提供的其他 at 规则。

**@前进**

`@forward`规则允许用户加载样式表，并且当您使用`@use`规则加载样式表时，可以使用样式表中的所有内容。

`@forward`规则允许用户组织位于许多文件中的不同库，并帮助用户从一个入口点加载它们。

规则可以写成`@forward "<url>”`。就像`@use`规则一样，它从给定 URL 处的模块中加载所有内容，并使用户可以使用该模块的公共成员，就像它们是直接在`@forward`规则的位置编写的一样。

但是那些规则对用户来说还不可用，为了使它们可用，你必须编写一个`@use`规则。不要担心模块将只加载一次。

如果您想在同一个文件中为相同的值编写`@forward`和`@use`规则，可以考虑先编写`@forward`。通过这样做，如果用户想要从转发的模块中配置任何东西，那么在您使用`@use`加载它之前，这些更改将应用于该模块。

**添加前缀**

您可以为转发的模块添加一个前缀，如`@forward “<url>” as <prefix>-*`,这将为转发的模块中的每个 mixin、变量和函数添加前缀。

**控制能见度**

在某些情况下，您不希望转发模块中的每个可用成员。您可能需要将一些成员设为私有，将一些设为公共。您可以通过将每个成员写成`@forward “<url>” hide <members…>`或`@forward “<url>” show <members…>`来控制它们的可用性。

`hide`表示列出的成员应该保持私密，不应该被转发，但其他的都应该。`show`意味着*只有*给定的成员应该被转发。在这两种情况下，您都应该列出混合、函数和变量的名称。

**配置模块**

用户也可以使用`@forward`规则配置模块。它的工作原理与`@use`规则相同。一个新的增加是，您可以在配置模块时添加`!default`标志。这个新增功能允许用户在配置级别更改默认值，同时还允许用户在将它们加载到样式表时覆盖它们。

**@导入**

Sass 通过允许用户导入 Sass 和 CSS 样式表来扩展 CSS `@import`的功能，为用户提供对混合、函数和变量的访问，以及组合多个样式表规则的能力。CSS `@import`需要浏览器在呈现页面时发出多个 HTTP 请求，但另一方面，Sass 导入完全是在编译期间处理的。

Sass 导入遵循与 CSS 导入相同的语法。它还允许编写多个用逗号分隔的 URL/路径，而不是每个 URL/路径都有单独的`@import`。

当您导入一个文件时，该文件会被评估，就好像它的全部内容被直接放置在`@import`规则的位置，包括所有的混合、函数和变量。
导入文件时，您不必写出文件的扩展名。如果你写`@import “variables”`，这将自动加载`variables.scss`、`variables.sass`或`variables.css`。

**嵌套**

通常，您会将导入放在样式表的顶部，但这并不是必须的。您也可以将它们嵌套在其他规则或选择器中。导入的规则嵌套在该上下文中，这使得它们在将一组 CSS 规则用于特定元素或媒体查询时非常有用。但是嵌套导入中定义的所有顶级混合、函数和变量都是全局可用的。

**导入 CSS**

除了导入`.sass`和`.scss`文件，Sass 还可以导入普通的`.css`文件。记住`@import` *不能有*扩展名，因为那会使它成为一个普通的 CSS `@import`。

**@功能**

您可以使用函数来定义对某些值的复杂操作，您可以在整个 Sass 文件中重用这些操作。它们使常见的计算或行为很容易分开。

使用`@function`规则定义函数，记为`@function <name>(<arguments…>) { … }`。该函数应该只包含通用语句，如变量声明、流控制规则、`@debug`、`@error`、`@warn`和一个`@return`规则。`@return`表示用作该函数调用结果的值。

您可以使用常规 CSS 函数语法调用函数，如下例所示。

`@function`规则还支持可选参数、关键字参数和任意参数。您已经在 mixin 部分看到了这些参数的细节。如果需要，您可以再次推荐他们。

**@错误**

当你编写一个 mixin 或者一个带参数的函数时，你会希望确保这些参数匹配你的 mixin/函数所期望的类型和格式。如果它们不匹配，那么需要通知用户，并且需要停止执行。

您可以使用写为`@error <expression>`的`@error`规则来做到这一点。它将打印该表达式的值，以及显示当前 mixin/function 如何被调用的堆栈跟踪。一旦打印出错误，Sass 就停止编译并告诉用户发生了错误。

错误和堆栈跟踪的确切格式因实现而异，也可能取决于您的构建系统。上面的例子显示了它在 Dart Sass 中的样子。

**@warn**

当您编写 mixin 或函数时，可能会希望用户将一些预定义的值集作为参数传递。您希望阻止它们传递不支持的参数，这可能会导致 mixin/function 以非预期的方式运行。

您可以使用`@warn`规则来打印这类警告。它被写成`@warn <expression>`，它打印该表达式的值，以及显示当前 mixin 或函数如何被调用的堆栈跟踪。与`@error`规则不同的是，`@warn`不会阻止 Sass 处理下面的表达式。您可以在下面的示例中看到 Dart Sass 实施中如何出现警告。

**@根**

`@at-root`规则写成`@at-root <selector> { … }`。

`@at-root`块的规则应用于元素的根，而不是普通的嵌套。它主要在使用父选择器进行高级嵌套时使用。

在 HTML 中编写一个匹配外部选择器和元素选择器的选择器非常方便。您可以使用它，这样除了写在`@at-root`块中的规则之外，外部块中的其他规则不会应用于它。

## 流量控制规则

Sass 也有一组流量控制 at-rules。这些规则允许用户根据条件控制评估流程，以决定应用哪些样式。并且在生成稍微不同的规则的情况下，重复操作一定次数。

Sass 支持这四种流量控制规则:

*   `@if`和`@else`允许您根据给定的条件控制执行哪个块。
*   `@each`为给定列表中的每个元素或给定映射中的每个对执行给定块。
*   `@for`规则根据给定的范围执行程序块一定的次数。
*   `@while`重复执行一个程序块，直到满足给定条件。

**@if 和@else**

您可以将`@if`规则写成`@if <expression/value> { … }`，它控制花括号内的块是否基于表达式/值进行计算。如果表达式返回`true`，则块执行，否则不执行。

一个`@if`规则可以选择性地跟随着一个`@else`，写成`@else { … }`。该块评估`@if`表达式是否返回`false`。

您也可以使用写成`@else if <expression> { … }`的`@else if`来检查`@if`之后的条件。该块仅在前面的`@if`表达式返回`false`且`@else if`表达式返回 true 时进行评估。

在`@if`之后，你可以根据需要链接任意多的`@else if`。无论哪个表达式在该链中返回`true`，该表达式后面的块都会被求值。可以在末尾添加一个普通的`@else`,以便在前面的所有条件检查都失败时执行。

> ***注:*** 允许直接使用控制流规则中的值`true`和`false`。萨斯将`false`和`null`值视为虚假值。所有其他值都被认为是真实的。

**@每个**

`@each`规则允许用户为给定列表中的每个元素或给定地图中的每个元素对应用样式或执行代码块。它非常适合动态生成重复的规则，这些规则之间只有一些细微的变化。

它被写成`@each <variable> in <expression> { … }`，其中表达式的计算结果是一个列表。列表中的每个元素都被赋给了变量，并且该块被赋值。

通过将`@each`写成`@each <variable>, <variable> in <expression> { … }`，还可以使用它来迭代映射中的每个键/值对。对于每次迭代，键被分配给第一个变量，元素被分配给第二个变量。

***解构***

您还可以对列表中的列表使用`@each`规则。将内部列表中的每个值写入给定的变量，将其写成`@each <variable…> in <expression> { … }`。它被称为*析构*，因为变量匹配内部列表的结构。

每个变量名在列表中相应的位置被赋值。如果列表没有足够的值，变量被赋予一个`null`。

**@为**

写为`@for <variable> from <expression> to <expression> { … }`或`@for <variable> from <expression> through <expression> { … }`的`@for`规则将计数从一个数字(第一个表达式的结果)递增或递减到另一个数字(第二个表达式的结果)，并对该范围内的每个数字评估给定的块。每次迭代的数字被分配给给定的变量。

如果使用`to`，范围内的最后一个数字将被排除。而且是包含在`through`的情况下。

**@而**

如果给定的块的表达式返回`true`，那么`@while`规则(写为`@while <expression> { ... }`)将对其求值。该块的求值继续进行，直到表达式最终返回`false`。

## 结论

我希望您对不同的特性有了更好的理解，比如变量、嵌套、部分文件、模块、混合、函数、继承、操作符以及 SCSS/SASS 提供的不同 at 规则。

我希望您在当前或即将到来的项目中享受使用这些 Sass 特性的乐趣。希望你喜欢这篇文章，感谢阅读！

## 参考

*   sass-lang.com 的萨斯基础知识。
*   关于 sass-lang.com 的详细文件。