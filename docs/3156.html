<html>
<head>
<title>JavaScript ES2021 (ES12) Approved Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES2021 (ES12)认可的功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es2021-es12-approved-features-24451e9591f8?source=collection_archive---------8-----------------------#2021-06-26">https://javascript.plainenglish.io/javascript-es2021-es12-approved-features-24451e9591f8?source=collection_archive---------8-----------------------#2021-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c46b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Ecma大会批准的JavaScript ES2021 (ES12)中的新特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec7add47faced0ffef173ba3ccd23c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gcfDibESzdPjwOt0.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">JavaScript 2021 (ES12) picture</figcaption></figure><p id="2961" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大约一年前，我写了一篇关于JavaScript将在其ES2021规范中包含的新特性的文章。</p><p id="8dfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，2021年6月，这些功能以及其他功能都已获得批准。在这篇文章中，我详细阐述了我一年多前写的东西，但是添加了已经被批准的最终特性。</p><h1 id="d497" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">索引</h1><ul class=""><li id="a3dc" class="mj mk iq kx b ky ml lb mm le mn li mo lm mp lq mq mr ms mt bi translated">String.prototype.replaceAll()</li><li id="f736" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">Promise.any()和AggregateError</li><li id="820c" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">WeakRefs和终结注册表</li><li id="3dda" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">逻辑赋值运算符</li><li id="3dd2" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">数字分隔符</li></ul><h1 id="821d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">String.prototype.replaceAll()</h1><p id="8a8d" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated"><code class="fe nc nd ne nf b">String.prototype.replaceAll()</code>用另一个字符串值替换字符串中某个子字符串的所有实例，而不使用全局regexp。</p><p id="1e5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，最常见的方法是使用全局regexp。</p><p id="5c9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下面的代码，其中我们使用正则表达式将“+”字符替换为空字符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="be58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法的缺点是需要使用特殊字符的正则表达式来实现这一点。但是正则表达式的使用并不容易，而且容易出错，是常见的错误来源。</p><p id="cd71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现这一点的更直接的解决方法是将String#split与Array#join结合起来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="eb55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个过程避免了正则表达式，但代价是将字符串分割成一组部分，然后再将它们粘在一起。</p><p id="8d8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Mathias bynens的提议解决了这些问题，并给出了一种执行全局子串替换的简单方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e8d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌注意，为了与语言中预先存在的API保持一致，<code class="fe nc nd ne nf b">String.prototype.replaceAll(searchvalue, newvalue)</code>的行为类似于<code class="fe nc nd ne nf b">String.prototype.replace(searchvalue, newvalue)</code>,但有两个主要例外:</p><ul class=""><li id="2320" class="mj mk iq kx b ky kz lb lc le nj li nk lm nl lq mq mr ms mt bi translated">如果<code class="fe nc nd ne nf b">searchvalue</code>是一个字符串，那么字符串#replaceAll替换所有出现的子串，而字符串#replace只替换子串的第一个出现的子串。</li><li id="569b" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">如果<code class="fe nc nd ne nf b">searchValue</code>是非全局正则表达式，<code class="fe nc nd ne nf b">String.prototype.replace</code>只替换单个匹配。另一方面，<code class="fe nc nd ne nf b">String.prototype.replaceAll</code>在这种情况下抛出一个异常，以避免在缺少全局标志(这意味着“不要全部替换”)和被调用方法的名称(这意味着“全部替换”)之间产生混淆。</li></ul><h1 id="f4e1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Promise.any()和一个<strong class="ak">聚合错误</strong></h1><p id="d1bd" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">任何承诺一兑现就解决，否则就全部拒绝。在这种情况下，用<code class="fe nc nd ne nf b">AggregateError</code>拒绝。</p><p id="ad92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6e1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果以<code class="fe nc nd ne nf b">Promise.any()</code>首先解析的结果为准。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4ef5b40bfe17f4cb9106125af44cc214.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*7zZ2Hv7sf7EmxHE-.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Example in Google Chrome dev tools.</figcaption></figure><p id="d8f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有一个承诺被解决，<code class="fe nc nd ne nf b">Promise.any()</code>抛出一个<code class="fe nc nd ne nf b">AggregateError</code>异常。</p><p id="3512" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌请记住与<code class="fe nc nd ne nf b">Promise.race()</code>的不同之处，在这里，只要任何一个承诺被解决，承诺就被解决，不管它们是被实现还是被拒绝。</p><h2 id="7569" class="nn ls iq bd lt no np dn lx nq nr dp mb le ns nt md li nu nv mf lm nw nx mh ny bi translated">聚合错误</h2><p id="5e85" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">当各种错误需要包装在单个错误中时，<code class="fe nc nd ne nf b">AggregateError</code>对象表示一个错误。如果传递给它的所有承诺都被拒绝，与<code class="fe nc nd ne nf b">Promise.any()</code>一起使用很有帮助。</p><p id="0c14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用<code class="fe nc nd ne nf b">AggregateError()</code>构造函数来创建一个新的<code class="fe nc nd ne nf b">AggregateError</code>对象。</p><p id="6e64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">属性:</p><ul class=""><li id="f276" class="mj mk iq kx b ky kz lb lc le nj li nk lm nl lq mq mr ms mt bi translated"><code class="fe nc nd ne nf b">message</code>:我们使用这个属性来显示错误消息。默认值为”。</li><li id="7d8b" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><code class="fe nc nd ne nf b">name</code>:我们使用这个属性来显示错误的名称。默认值为AggregateError。</li></ul><p id="d8cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">捕获聚合错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8b53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如何创建聚合错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="b708" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">WeakRefs和<strong class="ak">终结注册表</strong></h1><p id="fc5e" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">武器在很多情况下都很有用。例如，我们可以使用一个Map对象来实现一个包含许多键值的缓存，这些键值需要大量的内存。在这种情况下，对我们来说方便的是尽快释放键值对占用的内存，WeakRefs允许我们这样做。</p><p id="ba08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakRef对象包含对对象的弱引用。对对象的弱引用是一种阻止对象被垃圾收集器恢复的引用。另一方面，标准引用将对象保存在内存中。</p><p id="5e52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript中对对象的引用被保存。也就是说，只要你有一个对象的引用，它就不会被垃圾收集。</p><p id="2d3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4f20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，我们有WeakMap()和WeakSet()使用WeakRefs:</p><p id="8cbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakMap对象是键-值对的集合，其中的键被弱引用。</p><p id="93b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="16ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用前一个对象的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f4ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想记录某个特定对象调用该方法的次数，并在超过1000次时进行报告:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6d4c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个解决方案是可行的，但是它存在内存泄漏，因为传递给函数的每个对象都永远保留在映射上，并且没有被垃圾收集。解决方案是使用WeakMap:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8453" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌因为引用是弱的，所以WeakMap键是不可枚举的。</p><p id="a782" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌WeakSet类似于WeakMap，但是就像集合一样，WeakSet中的每个对象只能出现一次。WeakSet集合中的所有对象都是唯一的。</p><h2 id="599e" class="nn ls iq bd lt no np dn lx nq nr dp mb le ns nt md li nu nv mf lm nw nx mh ny bi translated">终结注册表</h2><p id="20b0" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">对对象进行垃圾回收后，可以使用FinalizationRegistry类运行用户定义的终结器。无论如何，最好避免使用终结器，因为如果使用不当，它们会导致意外的结果。</p><h1 id="10a4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">逻辑赋值运算符</h1><p id="464d" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">逻辑赋值操作符(由Justin Ridgewell和Hemanth HM提出)结合了逻辑操作符(&amp;&amp;，||，？？)和赋值表达式:</p><p id="d353" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，JavaScript有以下赋值操作符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d23d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个建议，我们可以将逻辑运算符和赋值表达式结合起来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="df6a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数字分隔符</h1><p id="06f7" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">数字分隔符(Christophe Porteneuve)扩展了现有的<a class="ae ni" href="https://tc39.github.io/ecma262/#prod-NumericLiteral" rel="noopener ugc nofollow" target="_blank"> <em class="nz"> NumericLiteral </em> </a>以允许数字之间的分隔符。</p><p id="9c2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">得益于这一特性，通过在数字之间创建一个可视的分隔符，可以很容易地使数字更具可读性。</p><p id="2f4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4919" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的数字文字很难阅读，但是我们可以使用下划线作为分隔符使其更容易阅读:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9755" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，现在更容易理解“钱”这个变量了。</p><p id="0332" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数字分隔符可以用在不同的位置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9289" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，数字分隔符在八进制整数文本中也是可用的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="42da" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="fb70" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我在很多年前开始使用JavaScript，当时这种语言几乎还是个玩具，只是用来在浏览器中做些傻事。今天，它已经成为全球使用最多的语言，几乎被用来做任何事情。</p><p id="96e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，我们不能忘记，它是一种不断更新的活语言。</p><p id="51ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nz">更多内容尽在</em><a class="ae ni" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>