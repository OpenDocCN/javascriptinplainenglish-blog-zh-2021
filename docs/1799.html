<html>
<head>
<title>A New Alternative to Redux for React — For Faster &amp; Lighter Web Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的Redux的新替代方案——用于更快、更轻的Web开发</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/new-alternative-of-redux-for-react-de0b420c0c60?source=collection_archive---------3-----------------------#2021-04-16">https://javascript.plainenglish.io/new-alternative-of-redux-for-react-de0b420c0c60?source=collection_archive---------3-----------------------#2021-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3cff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我提醒您注意React，Preact的状态管理<a class="ae ki" href="https://github.com/rubender/redoor" rel="noopener ugc nofollow" target="_blank">库</a>(仅重4.8 Kb)。该库仍在开发中，但您已经可以尝试一下了。</p><p id="5601" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先说一个大家最喜欢的TODO组织者的例子。<a class="ae ki" href="https://github.com/rubender/redoor_todo_example" rel="noopener ugc nofollow" target="_blank"> Github </a>上的源代码。首先，让我们创建主要组件main.js。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/99d4936c7d51eaa2669d1877b1aa184b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PB-X8rtEcARiJnNh3HT-Bw.png"/></div></div></figure><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="3bbf" class="la lb in kw b gy lc ld l le lf">// main.js<br/>import React, { createElement, Component, createContext } from 'react';<br/>import ReactDOM from 'react-dom';<br/>import {Connect, Provider} from './store'<br/>import Input from './InputComp'<br/>import TodoList from './TodoList'<br/>import LoadingComp from './LoadingComp'<br/><br/>const Main = () =&gt; (<br/>  &lt;Provider&gt;<br/>    &lt;h1&gt;Todo:&lt;/h1&gt;<br/>    &lt;LoadingComp&gt;<br/>      &lt;TodoList/&gt;<br/>    &lt;/LoadingComp&gt;<br/>    &lt;hr/&gt;<br/>    &lt;Input/&gt;<br/>  &lt;/Provider&gt;<br/>)<br/><br/>ReactDOM.render(&lt;Main /&gt;, document.getElementById("app"));</span></pre><p id="2e1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，存储。我们需要存储来初始化库，并且在这里我们指定了所有必需的文件和动作。在我们的示例中，这是actions.js和actionsSetup。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="d4a3" class="la lb in kw b gy lc ld l le lf">// store.js<br/><br/>import React, { createElement, Component, createContext } from 'react';<br/>import createStoreFactory from 'redoor';<br/><br/>// <!-- -->Exporting all functions <!-- -->from actions.js и actionsSetup.js<br/>import * as actions from './actions'<br/>import * as actionsSetup from './actionsSetup'<br/><br/>// <!-- -->here we specify the necessary functions of the React library<br/>const createStore = createStoreFactory({<br/>  Component, <br/>  createContext, <br/>  createElement<br/>});<br/><br/>// creating a store as a parameter, you must specify an array of objects<br/>// of all used action functions<br/>const { Provider, Connect } = createStore([<br/>  actions,<br/>  actionsSetup<br/>]);<br/><br/>export { Provider, Connect };</span></pre><p id="de9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提交我们的行动和项目状态</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="5476" class="la lb in kw b gy lc ld l le lf">// actions.js<br/><br/>// each local state can contain its own set of variables<br/>// redoor will automatically add them to the global store<br/>// initState is a reserved variable it can be either an object,<br/>// or a function that returns an object with a state<br/>export const initState = {<br/>    todos:[],<br/>    value:'',<br/>}<br/></span><span id="2973" class="la lb in kw b gy lg ld l le lf">// adding a new task to the array<br/>// the state variable contains the global state<br/>// the args variable depends on the values passed from the component<br/>// the function returns new state variables<br/>export const a_enter = ({state,args}) =&gt; {<br/>  let {value,todos} = state;<br/>  todos.push({<br/>    id:(Math.random()+"").substr(2),<br/>    value:value,<br/>    done:false<br/>  });<br/>  return {<br/>    value:'',<br/>    todos<br/>  }<br/>}<br/><br/>export const a_done = ({state,args}) =&gt; {<br/>  let {todos} = state;<br/>  let id = args.id;<br/>  todos = todos.map(it=&gt;(it.id === id ? (it.done = !it.done, it) : it))<br/>  return {<br/>    todos<br/>  }<br/>}<br/><br/>export const a_delete = ({state,args}) =&gt; {<br/>  let {todos} = state;<br/>  let id = args.id;<br/>  todos = todos.filter(it=&gt;it.id !== id)<br/>  return {<br/>    todos<br/>  }<br/>}</span></pre><p id="b583" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">视图的组件</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="854c" class="la lb in kw b gy lc ld l le lf">// InputComp.js<br/>import React from 'react';<br/>import {Connect} from './store'<br/><br/>// redoor adds the cxRun function and all variables to the props<br/>// globally store<br/>const Input = ({cxRun, value})=&gt;&lt;label className="input"&gt;<br/>  Todo:<br/>  <br/>// here we can change the store directly from the component<br/>  &lt;input onChange={e=&gt;cxRun({value:e.target.value})} <br/>					value={value} <br/>					type="text" <br/>  /&gt;<br/>  <br/>// by clicking, we call the action a_enter from actions.js<br/>  &lt;button onClick={e=&gt;cxRun('a_enter')} disabled={!value.length}&gt;<br/>		ok<br/>	&lt;/button&gt;<br/>&lt;/label&gt;<br/><br/>// соеденяем с redoor наш компонент и экспортируем <br/>export default Connect(Input);</span></pre><p id="5613" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">cxRun可以在两种模式下运行。第一种方法是直接更改存储的内容，例如使用字符串参数或从actions.js文件中调用操作。</p><p id="6d70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及输出待办事项列表本身的最后一个组件。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="e35b" class="la lb in kw b gy lc ld l le lf">// TodoList.js<br/>import React from 'react';<br/>import {Connect} from './store'<br/><br/>const Item = ({cxRun, it, v})=&gt;&lt;div className="item"&gt;<br/>  <!-- -->// we call the a_done action, where we specify as a parameter<br/>  // array element in the asense this variable will be called args<br/>  &lt;div className="item_txt" onClick={e=&gt;cxRun('a_done',it)}&gt;<br/>    {v+1}) {it.done ? &lt;s&gt;{it.value}&lt;/s&gt; : &lt;b&gt;{it.value}&lt;/b&gt;}<br/>  &lt;/div&gt;<br/>  &lt;div className="item_del" onClick={e=&gt;cxRun('a_delete',it)}&gt;<br/>    &amp;times;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/><br/>const TodoList = ({cxRun, todos})=&gt;&lt;div className="todos"&gt;<br/>  {<br/>    todos.map((it,v)=&gt;&lt;Item key={v} cxRun={cxRun} it={it} v={v}/&gt;)<br/>  }<br/>&lt;/div&gt;<br/><br/>export default Connect(TodoList);</span></pre><p id="0d79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的项目中，全局存储中只有两个变量，value和todos。它们由actions.js文件中的initState初始化。initState可以是一个对象，也可以是一个函数，它应该返回一个带有状态的对象。这里，理解动作文件中的所有状态都放在一个对象中是很重要的，每个动作都可以访问任何状态变量。</p><p id="b6c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">动作是必须以前缀“a_”或“action”开头的函数。调用cxRun时，操作函数的名称将被指定为第一个参数。输入参数将是一个带有state和args变量的对象。</p><p id="0c53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态——这是项目的整体状态</p><p id="027a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">args是cxRun函数调用的第二个参数。在我们的项目中，当你点击delete时，我们调用cxRun('a_delete '，it)，其中第一个参数是动作函数的名称，第二个是元素本身，这是我们在args中得到的。</p><p id="33bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该操作应该返回状态的新状态，这将自动重新绘制连接到存储的组件。</p><p id="5d9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">动作异步工作怎么办？为此，我们需要使用bindStateMethods函数将setState方法连接到actions file.js的局部变量。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="bd61" class="la lb in kw b gy lc ld l le lf">//actions.js<br/>let __setState;<br/>let __getState;<br/><br/>// <!-- -->connecting the methods of working with the state<br/>export const bindStateMethods = (getState, setState) =&gt; {<br/>  __getState = getState;<br/>  __setState = setState;<br/>};<br/><br/>export const a_setup = async ({state,args}) =&gt; {<br/>  __setState({loading:true});<br/>  let data = await loading();<br/>  __setState({<br/>    loading:false,<br/>    todos:data<br/>  })<br/>}</span></pre><p id="fd2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在调用“a_load”动作时，下载开始前会出现下载图标，数据加载后，数据数组会更新，下载图标会被禁用。如果需要获取异步函数内部的全局状态，可以调用__getState，它返回该状态的当前状态。</p><h1 id="511f" class="lh lb in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">调试器</h1><p id="8f0c" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">对于调试，有一个redoor-devtool工具。调试器是一种服务器，它侦听来自redoor库的数据，并将其传递给localhost:8333中的单个页面。</p><p id="038b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，调试器不仅可以位于另一个浏览器中，也可以位于另一台机器上。这在为移动设备开发时尤其有用。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mj"><img src="../Images/755331544c83ddb0ab3e7198fc10ab07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*74UW893sVaOHxk92.png"/></div></div></figure><p id="36dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装重做程序-devtool:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="d324" class="la lb in kw b gy lc ld l le lf">yarn add redoor-devtool</span></pre><p id="2dad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在单独的控制台中，运行控制台调试服务器</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="0206" class="la lb in kw b gy lc ld l le lf">npx redoor-devtool -o</span></pre><p id="4eea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“-o”键将在调试器所在的<a class="ae ki" href="http://localhost:8333" rel="noopener ugc nofollow" target="_blank"> http://localhost:8333 </a>处打开chrome。</p><h2 id="1416" class="la lb in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated">结论</h2><p id="3f93" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">就我自己而言，我可以分享我已经使用这个库完成了几个项目。使用套接字处理项目非常方便。</p><p id="2b70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然有使用功能。例如，您需要记住，所有动作在所有模块中都是“可见的”。如果您有一个清晰的命名动作结构，这就不会成为问题。在我的项目中，我使用这个命名“a_moduleName_actionName”。</p><p id="4ac0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在就这些了。如果你感兴趣，我会试着写一篇更详细的评论。</p><p id="111a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mv">更内容于</em> <a class="ae ki" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mv">通俗地说就是</em> </strong> </a></p></div></div>    
</body>
</html>