<html>
<head>
<title>Secret Ways of Using For Loops That You Don’t Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道的使用For循环的秘密方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-secrets-surrounding-for-loops-in-javascript-3db58541caa9?source=collection_archive---------4-----------------------#2021-01-08">https://javascript.plainenglish.io/the-secrets-surrounding-for-loops-in-javascript-3db58541caa9?source=collection_archive---------4-----------------------#2021-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d21" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">揭开对大多数开发者隐藏的秘密</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0e7bf9e33f25b2cb8dabfae722e449b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-fsf7mhcrKo4cpN2"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@dmey503?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Meyers</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您偶尔会希望一组语句被多次执行。我们使用循环来完成这项任务。在大多数编程语言中，大部分代码执行时间都花在循环中。</p><p id="bc2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对一系列值进行循环是编程中最常用的模式之一，因此也是必须集中精力提高性能的领域之一。</p><p id="32d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解JavaScript中循环的性能影响尤其重要，因为无限或长时间运行的循环会严重影响整体用户体验。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4f2a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">你认识的那种——你不认识的那种。</h1><p id="e32f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">JavaScript提供了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration" rel="noopener ugc nofollow" target="_blank">四种</a>循环类型。在本文中，我们将重点介绍<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>循环。但是无论我们在这里学到什么，也可以应用于其他类型的循环。</p><p id="a70b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code> <strong class="ky ir"> </strong>循环非常适合您希望执行一组语句特定次数的情况。数组的本质要求我们能够遍历或迭代数组的值。</p><p id="ac42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="na"> for </em> </strong>语句简化了遵循通用模式的循环。大多数循环都有某种<code class="fe mw mx my mz b">counter</code> <strong class="ky ir"> <em class="na">变量</em> </strong>。该变量在循环开始前被<strong class="ky ir"> <em class="na">初始化</em> </strong>，并在循环的每次迭代前被测试。</p><p id="3b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，变量<code class="fe mw mx my mz b">counter</code>在循环体 结束时<strong class="ky ir"> <em class="na">递增或更新，就在变量再次被测试之前。在这种循环中，<strong class="ky ir">初始化</strong>、<strong class="ky ir">测试</strong>和<strong class="ky ir">更新</strong>是循环变量的三个关键操作。</em></strong></p><p id="b37c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>语句将这三种操作编码为一个表达式，并使这些表达式成为循环语法的显式部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/0c6918718d3a78c1b4b71806fcb926f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFhz-hrr-Hq6gBIKUF6ByA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">for loop syntax in JavaScript</figcaption></figure><p id="fe85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">括号内定义的代码至关重要，它们控制着<code class="fe mw mx my mz b"><strong class="ky ir"><em class="na">for</em></strong></code>循环的开始和结束。总之，我们将三个语句放在括号中，并用两个分号分隔它们。</p><ul class=""><li id="5955" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><strong class="ky ir">第一个语句称为初始表达式。<br/> </strong>我们用它来初始化一个或多个循环计数器。该语句在<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>循环开始时执行，并且只执行一次！</li><li id="16c3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">第二条语句控制</strong> <code class="fe mw mx my mz b"><strong class="ky ir"><em class="na">for</em></strong></code> <strong class="ky ir">循环何时停止。<br/> </strong>它会在每次循环之前执行。当第二条语句返回一个falsie值时,<code class="fe mw mx my mz b"><strong class="ky ir"><em class="na">for</em></strong></code>循环将停止。第二条语句必须正确设置，否则可能会出现无限循环。</li><li id="18e5" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">最后一条语句是我们用来更新每个循环的语句。<br/> </strong>在每次循环结束时执行。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/9b5b2f40c17146f2c08353ff4bdeaf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLA_9bKXaQ2p0KGb_3r0ew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Codes defined inside the curly brackets will be repeatedly executed.</figcaption></figure><p id="31a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们对大多数地方的<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>循环的了解。虽然在大多数地方，他们从来没有超越这一点，但在本文中，我们将探索<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>循环中不为人知的一面。这不仅会让你对<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code> <strong class="ky ir"> <em class="na"> </em> </strong>循环有更深的理解，还会让你成为更好的开发者。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a56f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">有时候我们需要的只是一个全新的开始。</h1><p id="7071" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">第一条语句可以在<code class="fe mw mx my mz b">for</code>循环之外定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e002334cbb7722a5e9bcf1d70cbd64b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNLN-E2FPnGBMlCb5M8h9g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">initialization defined outside the for loop</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e08db317f090ab01b4d32c217fbed20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*FeE1wBfqVxU5L0cJSTI4pQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The output of the above code</figcaption></figure><p id="a00c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一句话也可以移到花括号里</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/99773af287ce4f4fd5f419648206f7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_n-ACaogdbBmAZ4iLUXZw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">post-loop-expression or increment gets defined into the curly brackets</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e08db317f090ab01b4d32c217fbed20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*FeE1wBfqVxU5L0cJSTI4pQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The output of the above code</figcaption></figure><p id="1f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使for循环能够正常工作。只需确保第二条语句设置正确，并且两个分号<em class="na">被封顶。嗯，没有那么强烈的对比！是吗？但是如果我说我们可以合并第二个<strong class="ky ir"><em class="na"/></strong><strong class="ky ir"><em class="na">第三个</em> </strong>语句呢。🙀那么，我们该怎么做呢？</em></p><p id="cd3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们声明一个<code class="fe mw mx my mz b">counter</code>并将它的初始值设置为负1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9b94791652b046c14d36cd75b9f61b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*jHOsDDLtxNKHgPMeizDZ3g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pay attention here it is negative 1, not 0</figcaption></figure><p id="57b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个语句中，我们将最后一个元素索引与<code class="fe mw mx my mz b"><strong class="ky ir">counter++ </strong></code>进行比较，我们可以通过从数组长度中减去1来获得最后一个元素索引。不需要设置后循环表达式或增量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/abfc887cf918dd6c812dc9a2735d9bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V04dXnHZgLMnUNqG_ZkUMw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pay attention to the conditional test here.</figcaption></figure><p id="1b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道这个程序到底是如何工作的？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/3d7fc68733f4c454b06e3708a53b9629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKhXhw1tjTrxawB2MIK10g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The second statement can be tested to either true or false</figcaption></figure><p id="2435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，第二条语句将在每个循环之前被测试和执行。所以每当一个新的循环开始时,<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>变量的值就会增加1。这就是为什么我们把<code class="fe mw mx my mz b">counters</code>的初始值设为负1。<br/>在第一次循环中，花括号中的<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>值将变为1。<br/>最终，<code class="fe mw mx my mz b">counter</code>值将大于最后一个元素的索引。比较将返回false并关闭for循环。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/41ea0a62f67314f8716dfb53baa34666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZmH9lme1DUOrvzh_CCdcA.png"/></div></div></figure><p id="25ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用body语句来测试一下</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/2f60b7dcc8f02d6591a2a6c5e26b9024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDXLoHe7mmLWvM3Ll5vlTw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e08db317f090ab01b4d32c217fbed20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*FeE1wBfqVxU5L0cJSTI4pQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We can see the result is the same as before.</figcaption></figure><p id="6fc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一种方法可以合并第二个和第三个语句。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a7f19498f45e69f36e795c0b71b5c85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*xnRhgDe-P-OoF6jOt3Wxiw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">First, we declare a counter and set its value to zero.</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/543df93b494370eb459fde8866ec51f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*T20V9A383BT_ftHYg-3yZw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Then we declare another variable and name it item.</figcaption></figure><p id="9259" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe mw mx my mz b"><strong class="ky ir">item</strong></code>变量在第二条语句中存储一个数组元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/2e17ec3df6de3115cba66465aec69cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLzHu9mKeJs-nvXx_lUK4g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We set the value for the item variable.</figcaption></figure><p id="8255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mw mx my mz b"><strong class="ky ir">counter++</strong></code>作为索引来检索元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/463c9c2d6b35af0aaa0129b52400549c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWcUFmg1DAXL1c_uBvOocg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">There is no need to set the third statement.</figcaption></figure><p id="b618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，这个程序是如何工作的呢？</p><blockquote class="od"><p id="13f3" class="oe of iq bd og oh oi oj ok ol om lr dk translated">第二条语句在每次循环之前执行。</p></blockquote><p id="8fcb" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">代码将首先使用<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>作为索引检索一个数组元素，并将检索到的元素赋给变量<code class="fe mw mx my mz b"><strong class="ky ir">item</strong></code>，然后<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>的值将增加1。</p><p id="f00c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意这里<code class="fe mw mx my mz b"><strong class="ky ir">counter </strong></code>的值不会改变，直到数组元素被检索和赋值。这是因为增量运算符位于<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>之后，而不是之前。这意味着首先使用变量的原始值，然后给它加1。所以当前行的<code class="fe mw mx my mz b"><strong class="ky ir">counter’s</strong></code>值不会改变。这也是为什么我们将<code class="fe mw mx my mz b"><strong class="ky ir">counter’s</strong></code>初始值设置为<strong class="ky ir">零</strong>而不是<strong class="ky ir">负一，</strong>在第一个循环中<code class="fe mw mx my mz b"><strong class="ky ir">counter's</strong></code>值仍然为零。</p><p id="6f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它不会变成<strong class="ky ir"> 1 </strong>直到第二个循环<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>值将增加1，每个循环最终它的值将大于最后一个元素的索引。如果我们使用数组中不存在的索引来检索一个元素，我们将得到<code class="fe mw mx my mz b">undefined</code>，<strong class="ky ir"> undefined </strong>是一个假值，因此，<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>语句将在花括号内停止。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/c999d76948d603977298cb5d927e0b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UhHff-3bnvuFqD3bA9wBQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Visualisation of the above code</figcaption></figure><p id="d19e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以直接输出item变量，我们可以看到每个元素都被输出了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/74addae5ab72d8b7fd629ce25f275af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*x1hCBv6lnEPxStcCBoLM6Q.png"/></div></figure><p id="3b52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个程序有一个问题。所有元素值必须真实。如果有一个<code class="fe mw mx my mz b"><strong class="ky ir">false</strong></code>值，<code class="fe mw mx my mz b">for</code>循环将根据您的程序设计立即结束。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/fc384eef1deb7f8841fc18e20b61a4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4xVuP_dfcEmC4NKjRqntQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We added null as a second element in the array</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/3ebbbb8b2dddade5d97181f446fb2063.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*TQIZyE7VQlF3Bgt7c_fIKg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The loop ends immediately after it found a null value in the array.</figcaption></figure><p id="e809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个功能可以给你带来麻烦，也可以给你带来麻烦。</p><p id="0530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你累了吗？我们也要回去吗？我保证你会学到一些关于在代码中使用循环的深刻的东西，这是你在其他任何地方都不会发现的！请耐心等待，我们正在揭开循环的秘密。</p><p id="0b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个变量，命名为<code class="fe mw mx my mz b">counter</code>，并将其值设置为数组长度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/eb16c1622c4db49aafc5739961f95434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9p6npeuFF5Nl1qjkz85vA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">There is no need to subtract one from the array length.</figcaption></figure><p id="e901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们创建一个for循环。第一个语句已经设置好了，但是您仍然需要保留分号。</p><p id="d976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道如何设置第二个语句吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/55086acf5b96c6f55958f0ecc221278e.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*4qhFAtzKK_kB5oPyZdMbqQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">what should we replace ?? with?</figcaption></figure><p id="c9f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mw mx my mz b">counter</code>连接到<code class="fe mw mx my mz b">decrement operator</code>，并将其与零进行比较。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/e699ef06de9c9bb47cb5a4d91f9d23a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*3jYJ8WKoJIlL7Yz-Rb776w.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We require the counter to be bigger than zero</figcaption></figure><p id="e8f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在花括号内，我们使用counter作为索引值来检索数组元素</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a8c43a52033eb09c6faf7b1a68cd4150.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*BJq7oLcocrOCFvveRF1PoA.png"/></div></figure><p id="7e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把所有的碎片拼在一起。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/f4fc7c694aa86e60abece9240cbcb4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEp0IlALZtMb9ujRsh1scg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/61a23d442574c90e1222576844ca10b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*igiBh0AHScVD90PuvGC3Bg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We can see all elements have been retrieved</figcaption></figure><p id="3ddc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，每当一个新的循环开始时，数组就被向后迭代。</p><p id="be1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">counter</code>值将与零进行比较，然后每循环一次减1。<code class="fe mw mx my mz b">counter </code>的值将下降1。最终结果是<code class="fe mw mx my mz b">counter</code>值将下降到零。比较表达式将返回一个关闭<code class="fe mw mx my mz b"><strong class="ky ir">for</strong></code>循环的falsie值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/acb285ae0b5ca43911032a451b480266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*ejQZ4SIoZ0r8l9rIsMZUVg.png"/></div></div></figure><p id="bf0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">又想知道上面的代码究竟是如何工作的？</p><p id="e16c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的程序中，关键是减量运算符！<br/>它被放在变量<code class="fe mw mx my mz b">counter</code>后面，如果圆括号中的<code class="fe mw mx my mz b">counter</code>值为1，那么在花括号中，它的值将减少1，变成0。这就是为什么我们把<code class="fe mw mx my mz b">counters</code>的初始值设为数组长度，而不是数组长度减1。</p><p id="8e6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试试第二种方法。</p><p id="1022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们声明两个变量。第一个名为<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>，我们将其值设为数组长度-1</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/46a643411812aabc962c5b1c082be11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*dk2xOiNR3CbG6QkFjhY-Tg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We name the second variable item.</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/1f0ef2303aa4566a1a4ca42968232c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2osU8J_h_AvjtSTAithtcg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">we retrieve the array element using <code class="fe mw mx my mz b"><strong class="bd pf">counter</strong>- -</code> and assign it to item</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/d82c9efce24385c82d91099df55f72b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wAG2rx2PRraK3kmm9mc9Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">in the curly brackets, we output variable item</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/61a23d442574c90e1222576844ca10b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*igiBh0AHScVD90PuvGC3Bg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">we can see the program works</figcaption></figure><p id="d2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组中输出的每个元素都被向后迭代。<br/><code class="fe mw mx my mz b">counter</code>的初始值是最后一个元素的索引。第二条语句将使用当前的<code class="fe mw mx my mz b">counter</code>检索元素，并将元素值赋给变量<code class="fe mw mx my mz b"><strong class="ky ir">item</strong></code>，然后<code class="fe mw mx my mz b"><strong class="ky ir">counter</strong></code>的值将减1。</p><p id="1328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键部分还是放在<code class="fe mw mx my mz b">counter</code>后面的减量运算符。在下一个循环中，<code class="fe mw mx my mz b">counter</code>的值将减少1。最终，<code class="fe mw mx my mz b">counter</code>值会变成<code class="fe mw mx my mz b"><strong class="ky ir">negative 1</strong></code>，这是一个非法的索引值。使用非法的索引值会给我们一个未定义的值，这是一个假值，结果，<code class="fe mw mx my mz b">for</code>循环会停止。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/cc33fb0d49e7b6ac0e3bc3566cd83fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzThoqWEQSbs_WIpgmOkqQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">For better Visualisation</figcaption></figure><p id="5b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个程序的关键是，如果你在一个<strong class="ky ir">变量</strong>后面加上递增或递减运算符，变量值直到下一行才会改变。在当前行中，变量值保持不变。</p><p id="1189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唷！那是相当长的时间，不是吗？</p><p id="7556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经仔细阅读了所有的例子，那么到现在为止，你的大脑一定已经成长了一点，你一定会以不同的方式看待这些循环。</p><p id="774d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还在这里，我有东西给你！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="be84" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">环路性能🔥</h1><p id="3bda" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用哪个循环一直是争论的焦点。在JavaScript提供的四种循环类型中，只有一种明显比其他循环慢:即<code class="fe mw mx my mz b"><strong class="ky ir">for-in</strong></code>循环。</p><p id="df44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于循环中的每次迭代都会导致在实例或原型上进行属性查找，因此<code class="fe mw mx my mz b">for-in</code>循环每次迭代的开销要大得多，因此比其他循环要慢。</p><p id="8e29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe mw mx my mz b"><strong class="ky ir">for-in</strong></code>循环之外，所有其他类型的循环都具有相同的性能特征，因此试图确定哪种循环最快是没有用的。</p><p id="b9ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环类型的选择应该基于您的需求，而不是性能考虑。如果循环类型对循环性能没有影响，那么什么有影响呢？</p><h2 id="bf3a" class="pi ma iq bd mb pj pk dn mf pl pm dp mj lf pn po ml lj pp pq mn ln pr ps mp pt bi translated">只有两个因素:</h2><ul class=""><li id="5486" class="nc nd iq ky b kz mr lc ms lf pu lj pv ln pw lr nh ni nj nk bi translated"><strong class="ky ir">每次迭代完成的工作</strong></li><li id="ed23" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">迭代次数</strong></li></ul><p id="9f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过减少其中一个或两个，您可以积极地影响循环的整体性能。</p><h2 id="472f" class="pi ma iq bd mb pj pk dn mf pl pm dp mj lf pn po ml lj pp pq mn ln pr ps mp pt bi translated">减少每次迭代的工作量</h2><p id="8764" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">显而易见，如果一次循环需要很长时间来执行，那么多次循环将需要更长时间。</p><p id="9187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">限制循环体中执行的高开销操作的数量是加速整个循环的好方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/4a8410e7e5f9c545e6e07117aa0ec96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*BmvJKbjtF9VpE8L5iIlwLA.png"/></div></figure><p id="d8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子在每次循环中对<code class="fe mw mx my mz b">arr.length</code>进行属性查找。这样做是浪费的，因为这个值在循环执行期间不会改变，因此是不必要的性能损失。</p><p id="21e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过执行一次属性查找，将值存储在局部变量中，然后在控制条件中使用该变量，可以很容易地提高循环性能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/8c4142aa4d92c3f9651e6fcb3d866b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*NkUdPY0jKnip1CaQJyyEPQ.png"/></div></figure><p id="51eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以通过颠倒循环顺序来提高循环的性能。通常，数组项的处理顺序与任务无关，因此从最后一个项开始，向第一个项进行处理是一种可接受的替代方法。</p><p id="77ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反转循环顺序是编程语言中一种常见的性能优化，但通常并没有得到很好的理解。</p><p id="1eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在最初的例子中改变编写<code class="fe mw mx my mz b">for</code>循环的通常方式时，两者都被牢记在心。所以，如果你关注了这些例子，那么恭喜你！现在，您可以编写性能循环了。</p><h2 id="1ac4" class="pi ma iq bd mb pj pk dn mf pl pm dp mj lf pn po ml lj pp pq mn ln pr ps mp pt bi translated"><strong class="ak">减少迭代次数</strong></h2><p id="2dc8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当迭代数千次时，即使是循环体中最快的代码也会累加起来。此外，执行循环体会产生少量的性能开销，这只会增加总的执行时间。</p><p id="75d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以通过减少循环中的迭代次数来提高性能。限制循环迭代最广为人知的方法是一种叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Duff%27s_device" rel="noopener ugc nofollow" target="_blank"> Duff's Device的模式。</a></p><p id="5651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由程序员汤姆·达夫于1983年在卢卡斯影业有限公司工作时发明。Duff的设备是一种展开循环体的技术，以便每次迭代完成多次迭代的工作。</p><p id="5a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该感谢Jeff Greenberg，因为他是第一个在2001年用JavaScript发布Duff的设备代码的人(<em class="na">最初的实现是用C语言</em>)。</p><p id="c6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript实现如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/7454ed24e33f250903abee86e76cdf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Au0uNRb46Z_diW6yibumAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here doSomething() is an operation that you want to execute more than once</figcaption></figure><p id="0c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Duff的设备实现背后的基本思想是每次循环最多允许八次调用<code class="fe mw mx my mz b">doSomething()</code>。</p><p id="4b27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将项目总数除以8来确定循环的迭代次数。</p><p id="cd14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于算法和流量控制的原因，并非所有的数字都能被8整除，<code class="fe mw mx my mz b">startAt</code>变量保存余数，并指示在第一次循环中对<code class="fe mw mx my mz b">doSomething()</code>的调用次数。</p><p id="b115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有12项，那么第一次循环调用process() 4次，然后第二次调用<code class="fe mw mx my mz b">process()</code> 8次，总共两次循环，而不是12次。</p><p id="42ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是否值得使用Duff的设备，很大程度上取决于你已经在做的迭代次数。在循环迭代少于1，000次的情况下，与使用常规循环结构相比，您可能只会看到微不足道的性能提升。</p><p id="7ce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，随着迭代次数增加到1000次以上，达夫设备的功效显著增加。例如，在500，000次迭代时，执行时间比常规循环少70%。</p><h1 id="3d58" class="lz ma iq bd mb mc qa me mf mg qb mi mj jw qc jx ml jz qd ka mn kc qe kd mp mq bi translated">我们所学内容的总结</h1><ul class=""><li id="fd44" class="nc nd iq ky b kz mr lc ms lf pu lj pv ln pw lr nh ni nj nk bi translated">JavaScript提供了四种循环类型。</li><li id="3570" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">第一条语句(initialize)可以在for循环之外定义。</li><li id="7c26" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">最后一个语句(增量)也可以移到花括号中</li><li id="6e0e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们可以合并第<strong class="ky ir"> <em class="na">第二</em> </strong>和第<strong class="ky ir"> <em class="na">第三</em> </strong>语句</li><li id="64b9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果测试中有一个<code class="fe mw mx my mz b"><strong class="ky ir">false</strong></code>值，即<code class="fe mw mx my mz b">for</code>循环，它将立即结束。</li><li id="59f1" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mw mx my mz b">for-in </code>由于属性查找，循环是最慢的。</li><li id="1896" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">每次迭代完成的工作</strong>和<strong class="ky ir">迭代次数</strong>决定了任何循环的性能。</li><li id="9d6d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Duff%27s_device" rel="noopener ugc nofollow" target="_blank">达夫的设备</a>历史及其在JavaScript中的实际实现。</li><li id="ebc3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">在较大的迭代中使用Duff的设备，执行时间比常规循环少70%</li></ul><h2 id="0774" class="pi ma iq bd mb pj pk dn mf pl pm dp mj lf pn po ml lj pp pq mn ln pr ps mp pt bi translated">我们还没完呢！</h2><p id="9800" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你想巩固你在这里学到的东西，那么打开<a class="ae kv" href="https://repl.it/" rel="noopener ugc nofollow" target="_blank"> repl.it </a>，试试文章中显示的代码。<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="noopener ugc nofollow" target="_blank">测量性能</a>，并在评论中告诉我你认为哪个性能最好。</p><h1 id="90bc" class="lz ma iq bd mb mc qa me mf mg qb mi mj jw qc jx ml jz qd ka mn kc qe kd mp mq bi translated">感谢信</h1><p id="4729" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我想利用这最后的机会说声谢谢。</p><p id="954b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的光临！如果没有像你这样的<em class="na"> </em>人跟随并带着那种信念阅读我的帖子，我将无法做我所做的事情。</p><p id="0fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你能<a class="ae kv" href="https://polymathsomnath.medium.com/subscribe" rel="noopener"> <strong class="ky ir">加入我的<a class="ae kv" href="https://polymathsomnath.medium.com/subscribe" rel="noopener"> <strong class="ky ir">我的未来博客</strong> </a>中的</strong> </a>并留下来，因为我认为我们这里有一些很棒的东西。我希望在未来的许多年里，我能在你的职业生涯中帮助你！</p><p id="32e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见。再见！</p></div></div>    
</body>
</html>