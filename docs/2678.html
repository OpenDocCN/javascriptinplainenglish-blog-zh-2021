<html>
<head>
<title>Separation of Concerns in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中关注点的分离</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/separation-of-concerns-in-react-45a8cfcd3143?source=collection_archive---------8-----------------------#2021-06-02">https://javascript.plainenglish.io/separation-of-concerns-in-react-45a8cfcd3143?source=collection_archive---------8-----------------------#2021-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/795802e166038322a85a907d32fbd3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R97poLiYP2YZnuOw"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@willfrancis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Will Francis</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="838a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇博文中，我将演示如何构建一个React应用程序，该应用程序与我之前<a class="ae jz" href="https://aws.plainenglish.io/process-dynamodb-streams-with-lambda-5d870455f524" rel="noopener ugc nofollow" target="_blank">构建的【WebSocket API进行通信。如果你没有阅读之前的文章，不要担心，希望这篇文章仍然有意义。</a></p><p id="c117" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个过程中，我将探索如何在React中正确地分离关注点，特别是如何使用服务定位器和依赖注入模式，以及如何分离表示组件和容器组件。我们开始吧！</p><h1 id="9775" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">建立WebSocket连接</h1><p id="2acd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我将使用没有任何花哨包装的WebSocket API，尽管在现实生活中，我会认真考虑使用它来处理像重新连接这样的事情。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8315" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果套接字不处于打开状态，向其发送消息将导致错误。为了防止它，我还引入了一个简单的包装器</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f761" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回的对象只公开了一个<code class="fe mh mi mj mk b">send</code>方法，它是原始<code class="fe mh mi mj mk b">send</code>的包装器。如果套接字没有打开，它将向队列中添加一条消息。在<code class="fe mh mi mj mk b">open</code>事件中，队列中的所有消息都将按正确的顺序发送。如果连接是打开的，它只会转发消息。有可能一些边缘情况没有包含在这段代码中，这是考虑某种包装WebSocket API的库的另一个理由。</p><h1 id="f965" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提出一个抽象概念</h1><p id="c70b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">至此，我已经设置好了WebSocket连接。理论上，我可以只使用<code class="fe mh mi mj mk b">getSocket</code>，直接从React组件或定制钩子开始与它交互。但是，我不打算这样做，原因有两个:</p><ol class=""><li id="2837" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">引入WebSocket API依赖将使我的React代码难以测试。我只是不知道模仿WebSocket API的好方法。</li><li id="ac18" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">React组件并不真正关心WebSocket API surface的大部分内容。直接从React组件使用WebSocket会破坏接口分离原则。</li><li id="c023" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">依赖倒置原则告诉我们，我们应该依赖一个抽象，而不是一个具体的实现。</li></ol><p id="cf60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的例子中，我实现了一个实时待办事项列表。从WebSocket连接中，我将接收对我的TODO项的更新流。这就是为什么我决定用Observables抽象WebSocket API。RxJS是最流行的实现，但是我决定选择一个更简单、更轻便的<a class="ae jz" href="https://github.com/zenparsing/zen-observable" rel="noopener ugc nofollow" target="_blank">Zen-observable</a>库。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a6c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是用Observables包装我的WebSocket API的一种非常简单的方法。我假设从WebSocket接收到action设置为<code class="fe mh mi mj mk b">stream</code>和<code class="fe mh mi mj mk b">payload</code>的消息，其中包含一组已更改的TODOs。</p><h1 id="6ae6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">连接它做出反应</h1><p id="ffa0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">到目前为止，我们还没有对React做任何事情。这很好，并不是所有事情都是关于反应的。然而，现在到了实际显示待办事项的时候了。</p><h2 id="c2fa" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">倾听变化</h2><p id="22d9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">第一件事是订阅observable，并将所有TODOs放入应用程序本地状态。我想让API变得非常简单。<code class="fe mh mi mj mk b">useTodosSync()</code>将是完美的。但是，我其实对<code class="fe mh mi mj mk b">socket</code>和<code class="fe mh mi mj mk b">todoStream</code>有依赖。嗯，我可能会选<code class="fe mh mi mj mk b">useTodosSync({socket, todoStream})</code>，但是我真的不喜欢它。原因如下:</p><ol class=""><li id="7984" class="ml mm in kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">我只有一个<code class="fe mh mi mj mk b">todoStream</code>，它是包装WebSocket连接的可观察对象。传来传去令人困惑。</li><li id="41d8" class="ml mm in kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">不想在道具上被迫过<code class="fe mh mi mj mk b">socket</code>和<code class="fe mh mi mj mk b">todoStream</code>。</li></ol><p id="aa64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么我想出了一个我称之为<em class="nl">钩子工厂</em>的东西。<code class="fe mh mi mj mk b">makeUseTodoSync</code>是一个返回钩子的函数。我猜这种模式在React社区中不是很流行，但是因为钩子只是函数，所以在我看来这很有意义。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e2b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们分析一下上面的代码。在<code class="fe mh mi mj mk b">useEffect</code>我订阅了<code class="fe mh mi mj mk b">todoStream</code>。对于发出的每一个TODO，我都调度<code class="fe mh mi mj mk b">UPSERT_TODO</code>动作，该动作在本地状态下创建或更新TODO。如果你想知道如何建立这样一个商店，我在我的<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/replace-redux-with-usereducer-100406773332">上一篇文章</a>中描述了它。</p><p id="7349" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还向WebSocket API发送<code class="fe mh mi mj mk b">syncTodos</code>消息，这是为了告诉<em class="nl">嘿，我刚连接上，把所有现有的待办事项</em>发送给我。当然，我也可以用REST API调用来完成。</p><p id="12ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请不要说我引入了<code class="fe mh mi mj mk b">Sandable</code>接口，因为我真的不在乎它是一个<code class="fe mh mi mj mk b">WebSocket</code>接口，我不想依赖这个事实。</p><h2 id="8a4c" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">添加和切换</h2><p id="1d59" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在查询已经完成，让我们实现突变。出于与上述相同的原因，我将使用<em class="nl">钩子工厂</em>模式。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c567" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望代码通俗易懂。我向WS API发送一条消息来通知这一变化，并乐观地更新本地存储。由于操作的异步性质，这里有一些竞争条件，但我决定不在本文中解决它们。</p><h2 id="278e" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">服务定位器</h2><p id="4f51" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">好了，我们有了<em class="nl">钩子工厂</em>。但是在React组件中，我们需要实际的钩子。我们如何到达那里？我最近读了马丁·福勒的一篇名为<a class="ae jz" href="https://martinfowler.com/articles/refactoring-dependencies.html" rel="noopener ugc nofollow" target="_blank">重构模块依赖</a>的优秀文章，这篇文章激励我创造了下面的解决方案。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="caf6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想法很简单，我想为<code class="fe mh mi mj mk b">useTodos</code>和<code class="fe mh mi mj mk b">useTodosSync</code>钩子的用户提供一个简单的接口。我希望他们提供包括电池(在这种情况下，电池是<code class="fe mh mi mj mk b">socket</code>和<code class="fe mh mi mj mk b">todosStream</code>)。这是一个依赖注入模式，我注入电池，所以客户端不需要担心它们。</p><h2 id="9e9a" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">演示组件</h2><p id="1ae0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我是分离表示组件和容器组件的爱好者，这个想法是我在这篇文章中第一次学到的。通过分离表示层，你可以使用像storybook这样的工具独立地开发UI组件，没有任何嘲笑，我认为这本身就很酷。</p><p id="a0f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个表示组件的例子</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d180" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它没有依赖关系。很无聊，但我喜欢。如果你能提取一个无聊的部分，就去做，不要把复杂的部分和无聊的部分混在一起。理想情况下，表示组件只依赖于其他表示组件。</p><h2 id="86c0" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">容器组件</h2><p id="246d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当然我们也需要容器组件。容器组件调用定制挂钩并呈现表示性组件，但是它们不应该关心标记或CSS。当然，React并不强制这样做，但是根据我的经验，它使代码更容易推理。</p><p id="1a3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个容器组件的例子。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="71ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，<code class="fe mh mi mj mk b">useTodo</code>钩子是从我前面介绍的服务定位器导入的。</p><h2 id="336e" class="mz kz in bd la na nb dn le nc nd dp li kl ne nf lm kp ng nh lq kt ni nj lu nk bi translated">缝隙模式</h2><p id="2519" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">所以之前我说过<em class="nl">理想情况下，表示组件只依赖于其他表示组件。</em>这并不意味着容器组件不能在不违反这个规则的情况下呈现在表示性组件中。让我们看一个例子。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6630" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mh mi mj mk b">Layout</code>组件是一个表示性组件，它接受两个容器组件作为插槽。我的实现很简单，只是为了演示一下思路。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8faf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用插槽模式也可以带来一些性能上的好处。</p><h1 id="d333" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="9751" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我知道这篇文章代码很多，但是我希望它介绍了一些你不知道或者还没有在React中使用的模式。现在你可以试着告诉我你是否喜欢它！</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/fb03277587b35d4f707356a9deeaaa99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LcoxVujUzKdGLTMkuGnGFw.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">In action</figcaption></figure><p id="52fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢<a class="ae jz" href="https://dorians.medium.com/" rel="noopener"> Dorian </a>提出了将可观察到的变化标准化并在React中使用可观察到的变化的想法。</p><p id="22ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="nl">plain English . io</em></strong></a></p></div></div>    
</body>
</html>