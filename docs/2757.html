<html>
<head>
<title>React Native Cookie Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对本机Cookie身份验证做出反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-cookie-authentication-83ef6e84ba70?source=collection_archive---------1-----------------------#2021-06-06">https://javascript.plainenglish.io/react-native-cookie-authentication-83ef6e84ba70?source=collection_archive---------1-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ccb4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何解决React Native应用程序中基于cookies的身份验证问题。</h2></div><p id="683f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们开始之前，需要大喊@<a class="ae ky" href="https://locastic.medium.com/?source=post_page-----80ee18f4c71b--------------------------------" rel="noopener">loca tical</a>。本文主要基于<a class="ae ky" href="https://medium.com/locastic/react-native-cookie-based-authentication-80ee18f4c71b" rel="noopener"> <strong class="ke io"> <em class="kz">【反应原生基于cookie的认证】</em> </strong> </a>，但包含更详细的代码示例。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi la"><img src="../Images/36542e670d15016129782d90d9da9a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*VB-3vUjlH9DK-jCQXccsgA.png"/></div></figure><h1 id="9afd" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">介绍</h1><p id="6d0e" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在构建现代网络或移动应用程序时，对用户进行身份验证是最需要的功能。它允许验证用户、用户会话，最重要的是，它为实现用户授权(角色和权限)提供了基础。</p><p id="de49" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，这是用来做什么的呢？作为前端开发人员，我们通常只需开发一个登录表单并向服务器发送一个请求。如果服务器的响应是肯定的，用户就登录了。听起来很容易，对吧？到目前为止，一切都很好。</p><p id="12bd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是服务器返回了另外一件事:您需要传递的某种用户标识，以及访问某些端点的以下请求。此外，当用户关闭应用程序而不注销时，由于这一点，我们可以让他保持登录，并在用户每次打开应用程序时跳过登录步骤。</p><p id="7ea2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是基于令牌的身份验证或基于会话的身份验证。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/ee617bc55b007677029ab66c57db7bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wccGR2fmBvWBws-xQoeLhA.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Cookie Based Authentication</figcaption></figure><p id="c2a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在基于cookie的身份验证中，成功登录后，服务器会创建会话，并将会话id值作为Cookie返回。随后的请求包含会话id为的cookie，该cookie将根据服务器上的会话id进行验证，以确定该会话是否有效。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/747158c1c3de2a374db8777c68f23957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxcuj8S36lruurB1zG1neA.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">JWT Based Authentication</figcaption></figure><p id="1c63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，我们有基于令牌的认证。成功登录后，服务器返回签名的令牌。然后，该令牌通常存储在本地存储器中。以下请求与保存的令牌一起发送到授权头。服务器解码令牌，如果令牌有效，则处理请求。</p><h1 id="657f" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">哪一个更好用？</h1><p id="d26b" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">如果你有能力选择，使用JWT。在大多数现代web应用程序中，JWTs被广泛使用，因为它比基于会话cookie的扩展得更好，因为令牌存储在客户端，而会话使用服务器内存来存储用户数据，当大量用户同时访问应用程序时，这可能是一个问题。然而，一些公司仍然宁愿使用cookie流，因为他们依赖遗留代码。所以，如果你像我一样，在某个时候，你不能选择并且必须使用组织中现有的安全认证系统，这篇文章是给你的。</p><p id="c11c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将介绍React Native中基于cookie的身份验证，这里有一个问题——它并不像您想象的那么简单。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/5fa511850c4a7c537b14b01ddbc45aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*De3uRIOfruS4Cz7c2_FxiQ.gif"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">The Cookie Monster</figcaption></figure><h1 id="9d56" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">问题</h1><p id="1c40" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">React Native依赖于用Java和Objective-C编写的原生(Android和iOS)API。您可能认为cookie的使用和在浏览器中使用一样简单，但不幸的是，事实并非如此。</p><p id="5ed3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，本地网络API<strong class="ke io">正在保存</strong>g<strong class="ke io">cookie</strong>，开始时可能看起来完全没问题，但一段时间后&amp;很少发出请求，请求可能变得不一致，导致服务器拒绝访问。因为我们发送的cookies是无效的，即使它们在调试时没有任何问题——当它们最初被传递给请求时。相信我，当我说，你可以花几个小时发现认证系统是你得到那些讨厌的401的原因。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mp"><img src="../Images/0ef23e17bf367a41c9e67b3cf86e1044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6gQPNw-hZBAt8ERl6ZjFg.png"/></div></div></figure><p id="a8de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">控制Android上的cookies非常复杂，React本地团队在官方<a class="ae ky" href="https://reactnative.dev/docs/0.61/network#known-issues-with-fetch-and-cookie-based-authentication" rel="noopener ugc nofollow" target="_blank">文档</a>上发布了一个关于它的章节！这是一个已知的问题，无论你决定在前端使用哪个提取库，本地端都会为你处理cookies。</p><div class="mq mr gp gr ms mt"><a href="https://github.com/facebook/react-native/issues/23185" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">基于Cookie的身份验证问题聚合问题#23185 facebook/react-native</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">kelset更改了标题基于Cookie的身份验证问题聚合+问题未解决就关闭了。饼干…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lg mt"/></div></div></a></div><p id="fa12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这与Java使用基于键的值的方式有关，因此当您收到一个cookie键时，它会覆盖前一个。</p><h1 id="3bcc" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">走向解决方案</h1><p id="81eb" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">当你试图勇敢面对它时，你总是以下面的方式绕过它。你对自己说，“嗯，我有一个本地存储，我可以在那里设置cookie，对于每个API调用，只需将它取出并追加它。”</p><p id="bcdd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在成功登录后，服务器用状态和cookies进行响应。现在，您尝试将cookies保存在设备上(异步存储、本地存储或者甚至使用像Redux这样的状态管理)。然后，每个后续的请求报头都被来自设备存储器的cookie填充。</p><p id="7ec5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们来分析一下到底是怎么回事，好吗？</p><p id="354e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React Native有自己的cookie管理，这意味着当服务器返回header Set-cookie时，下一个API调用在默认情况下已经在它的头上设置了Cookie，因此在这里提供Cookie必须生效。</p><p id="4794" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们实现了自己的处理程序，但它们实际上没有本机意义，因为我们使用一个fetch库(如Axios)来构建处理请求和响应的API回调，而本机设备才是实际发送请求的设备。用我们自己的覆盖cookie会导致同样的问题出现，在我的例子中，它只发生在Android上——想想看。🤷‍♂️</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f41ed65264f02bf023bb1bcc6275ddcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*lGOupxR0r1u5jYm0xAp47Q.gif"/></div></figure><p id="0f24" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">经过一些研究，我遇到了<a class="ae ky" href="https://github.com/react-native-cookies/cookies" rel="noopener ugc nofollow" target="_blank"> react-native-cookies </a>。这是React Native的一个cookie管理库，可以让你本地管理cookie<strong class="ke io"/>。现在实际上有了一种操纵本机cookie管理的方法，可以进一步改进在设备上存储cookie的方法。</p><p id="da66" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们完全删除本机cookiess，只使用存储在设备上的cookie。最简单的方法是清理本地存储的cookies。</p><h1 id="d1da" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">解决方案</h1><p id="4929" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">幸运的是，我在我的项目中有一个分离的关注点。网络管理器(在我的例子中是<em class="kz"> Axios </em>，但也可以是任何其他的……)只创建一次。每次我想进行API调用时，我都会导入‘fetcher’并发出网络请求。</p><p id="dd7d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我如何在代码中使用它</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="de7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">网络管理器的基本实现如下所示:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Simple network manager</figcaption></figure><p id="0523" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，使用cookie-manager，我们可以更新网络管理器文件，删除所有cookie，然后在get请求上重新分配(作为一个例子)。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Updated network manager with Cookie Manager integrated</figcaption></figure><p id="ed87" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，任何使用网络管理器(`<em class="kz"> fetcher()的人。get() </em>`)将获得现成的cookie管理，甚至他们都不知道这个令人头痛的cookie😎</p><p id="4bac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，我们不需要使用<code class="fe nl nm nn no b">fetcher</code>实例来改变组件的任何用法。</p><p id="35ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于在每次请求之前会清理本机存储的cookie，因此可以肯定的是，只有那些手动存储在设备上的cookie才会随请求一起传递。</p><h1 id="affa" class="li lj in bd lk ll lm ln lo lp lq lr ls jt lt ju lu jw lv jx lw jz lx ka ly lz bi translated">结论</h1><p id="adbb" class="pw-post-body-paragraph kc kd in ke b kf ma jo kh ki mb jr kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">使用更新的网络管理器确保我们没有更多的cookies相互干扰，同时在使用应用程序时保持一致的会话！</p><p id="0a0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望我说得更清楚一点——你是如何解决React Native上的cookie管理问题的？如果您有任何问题，请随时在Twitter <a class="ae ky" href="https://twitter.com/MatanKastel" rel="noopener ugc nofollow" target="_blank"> @matan.kastel </a>上联系我。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/04f1c2609829ac191b5e30ef90bed8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*gIjjlFaj-8iR9zaDwxHI1w.gif"/></div></figure><p id="5803" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，你可以看看我的其他文章，如<a class="ae ky" href="https://zmtmaster.medium.com/my-react-native-style-building-blocks-f144a22cbcad" rel="noopener"> <strong class="ke io"> <em class="kz">我的React原生风格构建模块</em> </strong> </a>，或<a class="ae ky" href="https://medium.com/swlh/custom-tab-navigator-using-react-navigation-svg-b659b395a7c4" rel="noopener"> <strong class="ke io"> <em class="kz">自定义标签导航器使用React导航&amp;</em></strong></a><strong class="ke io"><em class="kz">。</em> </strong></p><p id="6339" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下次再见，保重！😷</p><p id="7105" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="kz">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kz">plain English . io</em></a></p></div></div>    
</body>
</html>