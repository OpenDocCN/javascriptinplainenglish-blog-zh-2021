<html>
<head>
<title>How to use React.useCallback()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React.useCallback()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/path-to-react-usecallback-c7f20e4a27a0?source=collection_archive---------9-----------------------#2021-06-09">https://javascript.plainenglish.io/path-to-react-usecallback-c7f20e4a27a0?source=collection_archive---------9-----------------------#2021-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/906117a04287616a61b4bf14bb76780f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*hxsySVkRQLRJl1pPYaqqFQ.jpeg"/></div></figure><p id="ca28" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你一定经常听到这样的话:我们应该使用<strong class="jt io"> useCallback() </strong>到<strong class="jt io"> </strong>来记忆回调函数，以防止无用的组件重渲染。</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi kp"><img src="../Images/6d7c0a0daa5cfc3eac145084c7f70601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xC0NZ_nUvsxZPrSHfyFinQ.png"/></div></div></figure><p id="51a4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是<strong class="jt io"> useCallback()到底是什么呢🤔</strong>。你想过吗？</p><p id="2f32" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我来帮助你理解它是什么以及在哪里正确使用它。</p><h1 id="8849" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">让我们先了解函数相等检查</strong></h1><p id="5447" class="pw-post-body-paragraph jr js in jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko ig bi translated">在看到我们如何使用它之前，让我们看看它解决了什么问题。让我们编写一个返回函数的简单函数:</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/46100e601a56220ca62141ea8972baed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*eK51vnd60iihTS_QTd7n4g.png"/></div></figure><p id="4844" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe mc md me mf b"><em class="mg">mul1</em></code>和<code class="fe mc md me mf b"><em class="mg">mul2</em></code>是两个数相乘的函数。它们是由<em class="mg">乘</em>函数创建的。</p><p id="1103" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">JavaScript中的函数是常规对象。函数<code class="fe mc md me mf b"><em class="mg">mul1</em></code>和<code class="fe mc md me mf b"><em class="mg">mul2</em></code>共享相同的代码，但它们是不同的函数对象。比较它们评估为<em class="mg">假</em>。</p><p id="45ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是JavaScript对象的工作方式。一个对象(包括一个函数对象)只等于它自己。</p><h1 id="cf0d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">现在说明useCallback()的目的和正确用法</h1><p id="767f" class="pw-post-body-paragraph jr js in jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko ig bi translated"><strong class="jt io"> React.useCallback() </strong>基本上解决了我们上面看到的函数相等性检查。共享相同代码的不同函数对象通常在React组件内部创建:</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mh"><img src="../Images/0134957ae63283b9cdaa4cee5569e8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmqmD3h6VMPPd02GH7zmLw.png"/></div></div></figure><p id="b443" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mg"> handleClick </em>(内嵌函数)在<em class="mg"> CustomComponent </em>的每次渲染上都是不同的函数对象。</p><blockquote class="mi mj mk"><p id="b3fd" class="jr js mg jt b ju jv jw jx jy jz ka kb ml kd ke kf mm kh ki kj mn kl km kn ko ig bi translated">让函数与React组件内联声明也没有坏处。它不会对性能产生有害影响。</p></blockquote><p id="5418" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是在某些情况下，您需要在渲染之间维护单个函数实例:</p><ol class=""><li id="5203" class="mo mp in jt b ju jv jy jz kc mq kg mr kk ms ko mt mu mv mw bi translated">比如当函数具有某种内部状态时，例如当函数被去抖/节流时</li></ol><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/482dcb6d4d0a9c4a1dc7425c2d7dc706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfjOwnlNbWsnwYHAtc369g.png"/></div></div></figure><p id="3ad5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上面的例子中，如你所见，去抖函数被包装在<strong class="jt io"> useCallback() </strong>下，如果我们不这样做，那么每次组件被重新评估时，局部变量被再次初始化，并且每次按键500毫秒后<em class="mg">去抖查询</em>被调用。</p><p id="4400" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.包装在<code class="fe mc md me mf b"><em class="mg">React.memo()</em></code>内部的一个功能组件接受一个功能对象prop。</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/8021ca60378b92ac526d7339879cc78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpFEiYkUSyMI4cs1n0mlJw.png"/></div></div></figure><p id="c5cd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果接受回调的子组件依赖于引用等式检查(例如:<em class="mg"> React.memo() </em>或<em class="mg">shouldComponentUpdate()</em>)来防止当其属性改变时不必要的重新呈现，那么任何回调属性在呈现之间不改变是很重要的。</p><p id="77a2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，在父组件中，我们可以将回调属性包装在<em class="mg"> useCallback() </em>中，并保证它将相同的函数对象向下传递到优化的子组件中。</p><p id="e6ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.当函数对象依赖于其他钩子时，例如<code class="fe mc md me mf b"><em class="mg">useEffect(..., [callback])</em></code></p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/0f143795c6f8aa0af002433bab9e4268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8H4fJQ8NsJ0QgAMrvnRHHw.png"/></div></div></figure><p id="c04f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上面的例子中，如果<em class="mg"> myFunction </em>做了一些导致<em class="mg"> MyComponent </em>重新构建的事情(例如，如果它做了一些改变道具或状态的事情),就会导致你进入一个无限循环状态。</p><p id="7f27" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了防止这种情况，我们将<strong class="jt io"> useCallback() </strong>包装在一个函数周围，并定义它的依赖关系，以确保该函数只有在其依赖关系改变时才会被重新创建。因此，该函数不再在每个渲染周期重新声明</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="4414" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以上面的用例是当，<strong class="jt io"> useCallback </strong> hook是有帮助的:给定相同的依赖值，钩子在渲染之间返回相同的函数实例并提高性能。</p><p id="4b31" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望它能帮助你理解在哪里实际使用<strong class="jt io"> useCallback() </strong>。</p><p id="f288" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">参考:</strong>T13】https://dmitripavlutin.com/dont-overuse-react-usecallback/</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="5ba8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">感谢您阅读这篇文章。如果你喜欢它，请在评论中告诉我们。</p><p id="aaf8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="mg">更多内容看</em> <a class="ae nh" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> <em class="mg">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>