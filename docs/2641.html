<html>
<head>
<title>An Introduction to Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intro-to-docker-823dc07fcd7c?source=collection_archive---------10-----------------------#2021-05-31">https://javascript.plainenglish.io/intro-to-docker-823dc07fcd7c?source=collection_archive---------10-----------------------#2021-05-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="061b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker是一个流行的开源项目，用go编写，由点云(一家PaaS公司)开发。它基本上是一个容器引擎，使用Linux内核特性(如名称空间和控制组)在操作系统上创建容器。在今天的帖子中，我将向您介绍docker，以及一些基本的命令和常见问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/980049124827c0eb18eeaf925887fa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wq1qEQ4ELhksep5-.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Docker Basics</figcaption></figure><h2 id="9190" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">虚拟化:</h2><p id="ceb4" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">虚拟化允许您将一个系统分成多个不同的部分，这些部分就像独立的、不同的单独系统一样。这有助于开发人员在一台物理服务器的硬件上运行和托管多个操作系统。<strong class="jm io">虚拟机管理程序</strong>为客户操作系统提供整体虚拟机。这些虚拟机形成了系统硬件 <strong class="jm io">层</strong>的<strong class="jm io">抽象，这意味着主机上的每个虚拟机都充当物理机。</strong></p><h2 id="8c56" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">集装箱化:</h2><p id="53b1" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">这有助于开发人员在单个虚拟机或服务器上使用相同的操作系统部署多个<strong class="jm io">应用</strong>。容器为运行应用程序提供了一个隔离的环境。整个用户空间明确地专用于应用程序。容器构成了应用层<strong class="jm io"/>的<strong class="jm io">抽象，这意味着每个容器构成了一个不同的应用。容器内的任何更改都不会反映在主机上，甚至不会反映在同一主机上运行的其他容器上。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/e0c7336a116b315491cb02dc8bfcc7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZ-v24HlN1Tn73Du3lp7nw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Virtualization vs Containerization</figcaption></figure><p id="e3cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所见，与虚拟化相比，容器化的开销要低得多。容器要轻量得多，可以比VM更快地启动和关闭。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="81f1" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">码头工人:</h2><p id="3946" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Docker是一个容器化平台，它以容器的形式将应用程序及其依赖项打包在一起。这确保了您的应用程序可以在任何环境中无缝工作，无论是开发、测试还是生产环境。Docker容器，将一个软件包装在一个完整的文件系统中，该文件系统包含运行所需的一切:代码、运行时、系统工具、系统库等。它基本上包装了任何可以安装在服务器上的东西。这保证了软件将总是相同地运行，而不管其环境如何。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="7dd3" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">码头集装箱:</h2><p id="05c8" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">最简单地说，docker容器由应用程序及其所有依赖项组成。它与其他容器共享内核，在主机操作系统的用户空间中作为独立的进程运行。docker容器的主要目的是在部署和运行应用程序时摆脱对基础设施的依赖。这意味着任何容器化的应用程序都可以在任何平台上运行，而不考虑底层使用的基础设施。从技术上讲，它们只是docker映像的运行时实例。</p><p id="c815" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">docker容器从开始创建到结束的不同阶段称为docker容器生命周期。<br/>最重要的阶段是:</p><ul class=""><li id="a9ea" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated"><strong class="jm io"> Created: </strong>这是容器刚刚被新建但还没有开始的状态。</li><li id="21ab" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><strong class="jm io">正在运行:</strong>在这种状态下，容器将与所有相关的进程一起运行。</li><li id="dd66" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><strong class="jm io">暂停:</strong>此状态下，正在运行的容器暂停。</li><li id="5544" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><strong class="jm io">停止:</strong>当正在运行的容器已经停止时，会出现这种状态。</li><li id="85d4" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><strong class="jm io">删除:</strong>在此，容器处于死状态。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/a1c796c5956ec59e4ed602c38786c112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdkHS8UNky0pN7-81_qqzQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Docker Container Lifecycle</figcaption></figure></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="4b63" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">Docker图像:</h2><p id="dca4" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Docker镜像是Docker容器的蓝图，包含应用程序代码和依赖项、软件包等。换句话说，Docker图像用于创建容器。当用户运行Docker映像时，会创建一个容器实例。Docker映像可以部署到任何docker环境中，容器可以在那里运行应用程序。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="9c00" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">码头中心:</h2><p id="276c" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Docker图像创建docker容器。这些码头工人的形象必须有一个栖身之所。默认位置是Docker Hub。用户可以从Docker Hub获取图像，并使用它们来创建定制的图像和容器。Docker提供了一个基于云的注册表，用于存储容器的公共图像，并提供查找和共享这些图像的功能，称为Docker Hub。</p><h2 id="8b7b" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">Docker架构:</h2><p id="2b46" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Docker架构由Docker引擎组成，Docker引擎是一个客户端-服务器应用程序，有三个主要组件:</p><ol class=""><li id="964c" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mt mk ml mm bi translated">服务器是一种长期运行的程序，称为守护进程(docker命令)。</li><li id="db41" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mt mk ml mm bi translated">REST API指定了一些接口，程序可以使用这些接口与守护进程对话，并指示它做什么。</li><li id="5584" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mt mk ml mm bi translated">命令行界面(CLI)客户端(docker命令)。</li><li id="112b" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mt mk ml mm bi translated">CLI使用Docker REST API通过脚本或直接CLI命令来控制Docker守护进程或与之交互。许多其他Docker应用程序使用底层API和CLI。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c41a43864cc4e0c04b04b02633a18dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43Iom9HfVUvxPedVFc3Upw.png"/></div></div></figure></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="ba62" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">Docker文件:</h2><p id="803e" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">Docker可以通过从一个名为Dockerfile的文件中读取指令来自动构建映像。它是一个文本文档，包含用户可以在命令行上调用的所有命令来组合一个图像。使用docker build，用户可以创建一个连续执行几个命令行指令的自动化构建。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/85b6daa35c9ceebc70eaebb0b3a6c962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsZIYNRYrO5Kj2b_W257zg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Steps to create a docker container</figcaption></figure></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="0dd2" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">基本命令:</h2><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="90ab" class="ky kz in mx b gy nb nc l nd ne">$ docker version // To check the docker version<br/>$ docker info // to get info about no of containers running, paused &amp; stopped<br/>$ docker login // to login to docker repository<br/>docker run -it -d &lt;image_name&gt; // to create and run docker container from image with detached mode</span><span id="4b05" class="ky kz in mx b gy nf nc l nd ne">$ docker ps // list only running container<br/>$ docker rm &lt;container_id&gt; // to remove stopped container<br/>$ docker rmi &lt;image_id&gt; // to remove the image<br/>$ docker build &lt;path_to_docker_file&gt; //to build the docker file<br/>$ docker push &lt;username/image_name&gt; // to push image to hub or repository</span><span id="af37" class="ky kz in mx b gy nf nc l nd ne">$ docker pull &lt;image_name&gt; // To pull docker image<br/>$ docker start &lt;container_id&gt; // To start container<br/>$ docker kill &lt;container_id&gt; // To kill docker container<br/>$ docker stop &lt;container_id&gt; // To stop docker container</span></pre></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="39b3" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">常见问题:</h2><p id="d043" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><strong class="jm io">问:</strong>Docker容器的规模有多大？一样有什么要求吗？<br/> <strong class="jm io">答:</strong>容器可以扩展到成千上万个并行运行。容器总是需要内存&amp;操作系统。以及缩放时有效使用该内存的方法。</p><p id="838d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问:</strong>当docket容器存在时，您会丢失数据吗？<br/> <strong class="jm io">答:</strong>不会，你不会丢失数据的。它保留在磁盘上，直到docker容器被显式删除。</p><p id="605d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问:</strong>为什么要使用docker系统prune？<br/> <strong class="jm io">答:</strong>移除所有停止的容器，不使用的N/W，悬空图像&amp;建立缓存。</p><p id="25d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问:</strong>能否从docker中移除暂停的容器？<br/> <strong class="jm io">答:</strong>不可以，不能去掉。</p><p id="7fb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问:</strong>容器可以自己重启吗？<br/> <strong class="jm io">答:</strong>不能，不能自己重启。虽然您可以设置flag-restart[restart-policy-value]来自动重启容器。</p><p id="c1da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问:</strong>每台主机可以运行多少个容器？<br/> <strong class="jm io">答:</strong>这完全取决于主机，因为容器需要存储空间，硬件需要支持的CPU &amp;内存。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="a43a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的文章中，我们将通过一个Node.js项目部署的例子来了解AWS ECS &amp; ECR。</p><p id="54be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ng">感谢阅读。最初发表于2021年5月30日https://noob2geek.in/</em></strong><strong class="jm io"><em class="ng"><a class="ae nh" href="https://noob2geek.in/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ng">。</em> </strong></a></em></strong></p><p id="7416" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ng">更多内容请看</em><a class="ae nh" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ng">plain English . io</em></a></p></div></div>    
</body>
</html>