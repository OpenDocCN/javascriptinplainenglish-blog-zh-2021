<html>
<head>
<title>How to Compare Old Values and New Values with the React useEffect Hook?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React useEffect钩子比较旧值和新值？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-compare-old-values-and-new-values-with-the-react-useeffect-hook-5a3385e5fc8b?source=collection_archive---------12-----------------------#2021-06-23">https://javascript.plainenglish.io/how-to-compare-old-values-and-new-values-with-the-react-useeffect-hook-5a3385e5fc8b?source=collection_archive---------12-----------------------#2021-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1921c5ca61d5ad9dcd5c3435b3a73f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dW7hihDf2Ojz2yIC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@efekurnaz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Efe Kurnaz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a4cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们可能想要比较用React钩子创建的React组件中状态的新旧值。</p><p id="e18a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何比较用React钩子创建的组件的新旧状态值。</p><h1 id="e4ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Ref中存储旧值</h1><p id="a6f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将旧值存储在ref中，因为给它们赋值不会触发组件的重新渲染，但该值会在每次渲染循环后保持不变。</p><p id="ee3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f28f" class="mn lc iq mj b gy mo mp l mq mr">import React, { useEffect, useRef, useState } from "react";</span><span id="8d57" class="mn lc iq mj b gy ms mp l mq mr">const usePrevious = (value) =&gt; {<br/>  const ref = useRef();<br/>  useEffect(() =&gt; {<br/>    ref.current = value;<br/>  });<br/>  return ref.current;<br/>};</span><span id="f449" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  const [count, setCount] = useState(0);<br/>  const prevCount = usePrevious(count);<br/>  useEffect(() =&gt; {<br/>    console.log("prevCount: ", prevCount, "count: ", count);<br/>  }, [prevCount, count]);</span><span id="4048" class="mn lc iq mj b gy ms mp l mq mr">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;increment&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="d0e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建<code class="fe mt mu mv mj b">usePrevious</code>钩子来存储状态的前一个值。</p><p id="d656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">钩子接受带有我们想要存储的状态或属性值的<code class="fe mt mu mv mj b">value</code>参数。</p><p id="7c2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个回调函数调用<code class="fe mt mu mv mj b">useEffect</code>来设置<code class="fe mt mu mv mj b">ref</code>的<code class="fe mt mu mv mj b">current</code>属性，以在其中存储<code class="fe mt mu mv mj b">value</code>。</p><p id="2536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有传入第二个参数，所以<code class="fe mt mu mv mj b">useEffect</code>回调将在每个渲染周期运行。</p><p id="5131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回<code class="fe mt mu mv mj b">ref.current</code>的值，这样我们可以将它赋给组件中的一个值并使用它。</p><p id="7ec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">App</code>中，我们用<code class="fe mt mu mv mj b">useState</code>钩子创建了<code class="fe mt mu mv mj b">count</code>状态。</p><p id="28ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">count</code>调用<code class="fe mt mu mv mj b">usePrevious</code>钩子将<code class="fe mt mu mv mj b">count</code>的前一个值存储在<code class="fe mt mu mv mj b">ref</code>中，</p><p id="2c02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们通过将<code class="fe mt mu mv mj b">prevCount</code>和<code class="fe mt mu mv mj b">count</code>作为第二个参数传入一个数组，用<code class="fe mt mu mv mj b">useEffect</code>钩子观察<code class="fe mt mu mv mj b">prevCount</code>和<code class="fe mt mu mv mj b">count</code>的值。</p><p id="9d96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在那下面，我们有一个按钮，当我们点击它来更新<code class="fe mt mu mv mj b">count</code>时，它会调用<code class="fe mt mu mv mj b">setCount</code>。</p><p id="dd6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们展示了<code class="fe mt mu mv mj b">count</code>。</p><p id="7e1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在控制台日志中，我们应该看到<code class="fe mt mu mv mj b">prevCount</code>应该具有<code class="fe mt mu mv mj b">count</code>的先前值。</p><h1 id="5df8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9479" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将值存储在ref中来存储状态或属性的旧值，这样我们就可以在组件中使用它。</p><p id="17e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>