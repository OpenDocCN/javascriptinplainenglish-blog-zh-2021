<html>
<head>
<title>Generator Function: The Powerful JavaScript Tool Nobody is Talking About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成器函数:无人问津的强大JavaScript工具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generator-function-the-powerful-javascript-tool-nobody-is-talking-about-cd0fc17312c4?source=collection_archive---------12-----------------------#2021-04-13">https://javascript.plainenglish.io/generator-function-the-powerful-javascript-tool-nobody-is-talking-about-cd0fc17312c4?source=collection_archive---------12-----------------------#2021-04-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1e61ae1c710a26b0ad16fb818431a034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOyzJ7yr3TAVc-vbB-4L6w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@kevin-ku-92347?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> from <a class="ae jz" href="https://www.pexels.com/photo/black-farmed-eyeglasses-in-front-of-laptop-computer-577585/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="9d18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何面试过web开发人员职位的人都知道，他们可能会发现挑剔的考官会询问与Javascript相关的详细理论问题。</p><p id="9884" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，在那些时刻我会对自己说:<em class="ky">“但是我真的需要记住一个我在JavaScript中永远不会用到的函数的准确名称来准备这次面试吗？”</em></p><p id="6ea0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，今天我们既没有谈论理论，也没有谈论任何隐藏在MDN web文档中的东西。</p><p id="b79e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我们将讨论<em class="ky">生成器函数</em>，它是迭代器的强大替代品，提供了一组工具来使我们的代码执行得更好，并使它更有效、更易读。</p><h2 id="b4d1" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">什么是发电机功能？</strong></h2><p id="3567" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><em class="ky">生成器函数</em>是一种特殊类型的函数，由ES6引入，作为迭代器的“工厂”运行。</p><p id="6d59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，它们是可以退出以便以后进入的函数，为函数随后被调用时保持函数的上下文。</p><p id="ae12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">快速举例<br/> </strong>举个快速的例子，想想当你决定下午下班休息，在PlayStation上玩个游戏。</p><p id="e47f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">休息(不幸的是)不会持续很久，所以你不得不保存你的游戏并在晚上下班后继续。</p><p id="b2c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，就像一个<em class="ky">生成器函数</em>一样，我们在游戏中执行动作，保存我们游戏的状态，退出函数，然后在那天晚上返回函数，从我们离开的地方继续。</p><h2 id="996e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">如何使用生成器功能？</strong></h2><p id="0213" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">要声明一个<em class="ky">生成器函数</em>，需要使用下面的保留关键字<code class="fe lx ly lz ma b"><strong class="kc io">function*</strong></code>，它返回一个<em class="ky">生成器</em>类型的对象。</p><p id="b3ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，我们有一个不立即运行的函数生成器。事实上，该函数返回一个迭代器对象，并且只从第一个被调用的<code class="fe lx ly lz ma b">next()</code>开始，生成器主体将一直执行到第一个<code class="fe lx ly lz ma b">yield</code>表达式。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a948" class="kz la in ma b gy mj mk l ml mm">function* increment(i) {<br/>  yield i;<br/>  console.log("hello");<br/>  yield i + 10;<br/>  console.log("world!");<br/>  yield i;<br/>}</span><span id="c6b5" class="kz la in ma b gy mn mk l ml mm">const generator = increment(5);</span><span id="08f2" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: 5</em></span><span id="afe5" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value);<br/>// <em class="ky">output: hello 15</em></span><span id="cb95" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); <br/>// <em class="ky">output: world! 5</em></span><span id="47c4" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); <br/>// <em class="ky">output: undefined</em></span></pre><p id="1ff6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，一些读者肯定已经注意到只有3个<em class="ky"> yield </em>关键字，而生成器函数被调用了4次。</p><p id="00b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，一旦所有的值都被“消耗”完，要再次生成这些值，就必须创建一个新的生成器对象。</p><p id="a527" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数返回的<em class="ky">生成器对象</em>符合iterable协议和iterator协议。</p><p id="6c1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，对象生成器的方法有:</p><ul class=""><li id="7537" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><code class="fe lx ly lz ma b">Generator.prototype.next()</code>:返回一个由<code class="fe lx ly lz ma b">yield</code>表达式产生的值。<br/>每次调用<code class="fe lx ly lz ma b">next()</code>都会返回一个具有两个属性的对象:</li></ul><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ddf4" class="kz la in ma b gy mj mk l ml mm">{<br/>   value: any,<br/>   done: boolean<br/>}</span></pre><p id="9dc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky"> value </em>属性当然包含值，相反,<em class="ky"> done </em>属性指示生成器是否已经结束执行并且不再生成任何值。</p><p id="89ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">记住:<br/> </strong>如果你想停止一个生成器的执行，你也可以<em class="ky">返回</em>并且<em class="ky"> done </em>属性将变成<code class="fe lx ly lz ma b">true</code>，阻止任何更多的值生成。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e38e" class="kz la in ma b gy mj mk l ml mm">function* increment(i) {<br/>  yield i;<br/>  yield i + 10;<br/>  return 'stop'; // <em class="ky">Generator ends here</em><br/>  yield i; // <em class="ky">Will never be executed</em><br/>}</span><span id="27eb" class="kz la in ma b gy mn mk l ml mm">const generator = increment(5);</span><span id="4f3e" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: 5</em></span><span id="19a8" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: 15</em></span><span id="35d9" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: stop</em></span><span id="656a" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: undefined</em></span></pre><ul class=""><li id="3378" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><code class="fe lx ly lz ma b">Generator.prototype.return()</code>:返回给定值，完成生成器。</li></ul><p id="e22f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在前面的例子中看到的，通过调用<em class="ky">生成器对象的<code class="fe lx ly lz ma b">return()</code>函数，</em>我们将<em class="ky"> done </em>属性设置为<code class="fe lx ly lz ma b">true</code>。</p><ul class=""><li id="1116" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><code class="fe lx ly lz ma b">Generator.prototype.throw()</code>:抛出一个错误给生成器，stoppen done ovviamente l ' esecuzione。</li></ul><h2 id="3926" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">为什么用生成器而不用迭代器？</h2><p id="53bc" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在解释原因之前，这里有一个关于迭代器的理论思考:</p><blockquote class="mx my mz"><p id="843d" class="ka kb ky kc b kd ke kf kg kh ki kj kk na km kn ko nb kq kr ks nc ku kv kw kx ig bi translated">当一个对象知道如何一次访问一个集合的元素时，它就是一个<strong class="kc io">迭代器</strong>,保存着关于它在序列中当前位置的信息。</p></blockquote><p id="b6c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ES6引入生成器的原因总是一样的:试图简化开发人员的工作，删除繁琐的预防措施和代码行，否则开发人员每次都必须编写代码。</p><p id="a718" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，尽管实现迭代器很有用，但是需要特别注意迭代器内部状态的管理，很明显，生成器的内部状态由函数接管。</p><h2 id="f3bc" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">使用示例</h2><p id="2d7f" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">例如，不禁止在另一个生成器函数中调用一个生成器函数，同时仍然保留状态并遵守我们上面已经提到的规则。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="40cc" class="kz la in ma b gy mj mk l ml mm">function* double(i) {<br/>  yield i * 2;<br/>}</span><span id="400c" class="kz la in ma b gy mn mk l ml mm">function* increment(i) {<br/>  yield i;<br/>  yield* double(i);<br/>  yield i + 10;<br/>}</span><span id="48f5" class="kz la in ma b gy mn mk l ml mm">const generator = increment(5);</span><span id="41ce" class="kz la in ma b gy mn mk l ml mm">console.log(generator.next().value); // <em class="ky">output: 5<br/></em>console.log(generator.next().value); // <em class="ky">output: 10<br/></em>console.log(generator.next().value); // <em class="ky">output: 15<br/></em>console.log(generator.next().value); // <em class="ky">output: undefined</em></span></pre><p id="48c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种可以使用的方法是将参数传递给函数生成器。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="b707" class="kz la in ma b gy mj mk l ml mm">function* logGenerator() {<br/>  console.log(yield);<br/>  console.log("hello");<br/>  console.log(yield);<br/>}</span><span id="a079" class="kz la in ma b gy mn mk l ml mm">const generator = logGenerator();</span><span id="45c8" class="kz la in ma b gy mn mk l ml mm">generator.next('Kristine'); // <em class="ky">output: Kristine</em><br/>generator.next('Paul'); // <em class="ky">output: hello Paul</em><br/>generator.next('The end'); // <em class="ky">output: undefined</em></span></pre><p id="6954" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">斐波那契数列</strong></p><p id="0896" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几乎我们所有人都知道<em class="ky">斐波纳契数列，</em>其中每个数字都是前面两个数字的和，从0和1开始。</p><p id="5a92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是通过<em class="ky">生成器函数</em>实现的算法。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="6f82" class="kz la in ma b gy mj mk l ml mm">function* fibonacci() {<br/>  let fn1 = 0;<br/>  let fn2 = 1;<br/>  while (true) {<br/>    let current = fn1;<br/>    fn1 = fn2;<br/>    fn2 = current + fn1;<br/>    const reset = yield current;<br/>    if (reset) {<br/>        fn1 = 0;<br/>        fn2 = 1;<br/>    }<br/>  }<br/>}</span><span id="45b0" class="kz la in ma b gy mn mk l ml mm">const sequence = fibonacci();</span><span id="6491" class="kz la in ma b gy mn mk l ml mm">console.log(sequence.next().value); // <em class="ky">output: 0<br/></em>console.log(sequence.next().value); // <em class="ky">output: 1<br/></em>console.log(sequence.next().value); // <em class="ky">output: 1<br/></em>console.log(sequence.next().value); // <em class="ky">output: 2<br/></em>console.log(sequence.next().value); // <em class="ky">output: 3<br/></em>console.log(sequence.next().value); // <em class="ky">output: 5<br/>...<br/></em>console.log(sequence.next(true).value); // <em class="ky">output: 0<br/></em>console.log(sequence.next().value); // <em class="ky">output: 0<br/></em>console.log(sequence.next().value); // <em class="ky">output: 1<br/></em>console.log(sequence.next().value); // <em class="ky">output: 1<br/></em>console.log(sequence.next().value); // <em class="ky">output: 2</em></span></pre><h2 id="b262" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">发电机的优势</h2><p id="2810" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在最明显的优势中，当然有数据的<strong class="kc io"> <em class="ky">懒惰评估</em> </strong>。</p><p id="e64a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，通过生成器函数，我们可以在必要的时候请求计算，请求服务器等等。</p><p id="c692" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们想象一个应该返回5的倍数的函数。</p><p id="2648" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它们将是无限的，函数将返回一个<em class="ky"> Javascript堆内存不足错误</em>。</p><p id="58c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，通过利用生成器函数，只有在真正必要时才可以请求我们感兴趣的数的倍数，节省了存储效率，只有在我们需要时才推迟计算。</p><h2 id="793a" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">要记住的事情</h2><p id="e4c8" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io">仅一次性访问</strong></p><p id="073e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦您用完了所有的值，如果您想再次生成值，您必须创建一个新的生成器对象。</p><p id="06fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">桌面支持</strong></p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/74caa5dc114ac464f0ac878224cc366c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*7QcRUiX3qWeI9oiJKR4zRg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://caniuse.com/es6-generators" rel="noopener ugc nofollow" target="_blank">caniuse.com</a></figcaption></figure><p id="d553" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">移动支持</strong></p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/aeb39f30c6d9bf8ffdd41a167fe73659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fE12aso3aedlPG4fqn0tZg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://caniuse.com/es6-generators" rel="noopener ugc nofollow" target="_blank">caniuse.com</a></figcaption></figure></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="7c31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请按👏按钮，这将鼓励我写其他文章。</p><p id="906f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有任何问题，请随意提问。非常感谢你的阅读！</p><p id="67eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">plain English . io</em></strong></a></p></div></div>    
</body>
</html>