<html>
<head>
<title>How to Check if an Object has a Specific Property in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中检查一个对象是否有特定的属性？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-check-if-an-object-has-a-specific-property-in-javascript-245b950acf31?source=collection_archive---------5-----------------------#2021-10-23">https://javascript.plainenglish.io/how-to-check-if-an-object-has-a-specific-property-in-javascript-245b950acf31?source=collection_archive---------5-----------------------#2021-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce41fab90389fe866a60ea9dedc141ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9473XeM00QhmXMg_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gusruballo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gus Ruballo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f5c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript对象是动态创建的。</p><p id="ca0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可能不知道JavaScript对象中有什么内容。</p><p id="39cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们必须找到检查一个对象是否包含特定属性的方法。</p><p id="ecb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在JavaScript中检查一个对象是否有特定的属性。</p><h1 id="a9cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">The hasOwnProperty Method</code></h1><p id="e904" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">hasOwnProperty</code>是从<code class="fe lz ma mb mc b">Object.prototype</code>继承的一个方法。</p><p id="6fc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数对象从它们继承，除非我们指定它们不从它继承。</p><p id="8002" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以这样写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2525" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}</span><span id="d806" class="mq lc iq mc b gy mv ms l mt mu">console.log(obj.hasOwnProperty('a'))<br/>console.log(obj.hasOwnProperty('d'))</span></pre><p id="a260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用属性名字符串调用<code class="fe lz ma mb mc b">hasOwnProperty</code>。</p><p id="ef87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个控制台日志应该记录<code class="fe lz ma mb mc b">true</code>，因为<code class="fe lz ma mb mc b">a</code>在<code class="fe lz ma mb mc b">obj</code>中。</p><p id="f6e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个控制台日志应该记录<code class="fe lz ma mb mc b">false</code>，因为<code class="fe lz ma mb mc b">d</code>不在<code class="fe lz ma mb mc b">obj</code>中。</p><p id="f80a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">hasOwnProperty</code>方法是从<code class="fe lz ma mb mc b">Object.prototype</code>继承的，所以它很容易被其他代码覆盖。</p><p id="674a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这个问题，我们可以通过编写以下代码用<code class="fe lz ma mb mc b">call</code>调用<code class="fe lz ma mb mc b">hasOwnProperty</code>:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4638" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}</span><span id="ebe5" class="mq lc iq mc b gy mv ms l mt mu">console.log(Object.prototype.hasOwnProperty.call(obj, 'a'))<br/>console.log(Object.prototype.hasOwnProperty.call(obj, 'd'))</span></pre><p id="0bc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lz ma mb mc b">Object.prototype.hasOwnProperty.call</code>调用<code class="fe lz ma mb mc b">hasOwnProperty</code>，它不能像用<code class="fe lz ma mb mc b">hasOwnProperty</code>方法那样被覆盖。</p><p id="22f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是<code class="fe lz ma mb mc b">this</code>的值，它应该被设置为我们正在检查属性的对象。</p><p id="5713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而第二个参数是属性名字符串本身，也就是我们调用第一种方式时的<code class="fe lz ma mb mc b">hasOwnProperty</code>的第一个参数。</p><p id="b90b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该得到和以前一样的结果。</p><h1 id="efbf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">in运算符</h1><p id="80d2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">in</code>操作符让我们检查非继承的和继承的属性。</p><p id="c09c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果存在具有给定属性名的继承或非继承属性，它将返回<code class="fe lz ma mb mc b">true</code>。</p><p id="7561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e645" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}</span><span id="40f2" class="mq lc iq mc b gy mv ms l mt mu">console.log('a' in obj)<br/>console.log('hasOwnProperty' in obj)</span></pre><p id="43a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe lz ma mb mc b">a</code>本身就在<code class="fe lz ma mb mc b">obj</code>中，所以它们都记录了<code class="fe lz ma mb mc b">true</code>。</p><p id="4b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lz ma mb mc b">hasOwnProperty</code>是继承自<code class="fe lz ma mb mc b">Object.prototype</code>。</p><h1 id="ed6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Lodash有方法</h1><p id="7747" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们也可以使用Lodash <code class="fe lz ma mb mc b">has</code>方法来检查一个属性是否是一个对象的非继承属性。</p><p id="b868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4718" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}</span><span id="6f00" class="mq lc iq mc b gy mv ms l mt mu">console.log(_.has(obj, 'a'))<br/>console.log(_.has(obj, 'hasOwnProperty'))</span></pre><p id="62a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后第一个控制台日志记录<code class="fe lz ma mb mc b">true</code>。</p><p id="0968" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二控制台日志记录<code class="fe lz ma mb mc b">false</code>。</p><h1 id="7531" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="474d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有很多方法可以检查一个属性是否在一个对象中。</p><p id="9a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将它们区分为继承属性和非继承属性。</p><p id="0cbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容看</em><a class="ae kc" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>