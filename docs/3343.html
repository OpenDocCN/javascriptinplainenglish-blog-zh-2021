<html>
<head>
<title>Triggering file uploads/downloads without a back end in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中触发文件上传/下载而无需后端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/july-7-triggering-file-uploads-downloads-without-a-back-end-in-react-6438cb77859?source=collection_archive---------10-----------------------#2021-07-07">https://javascript.plainenglish.io/july-7-triggering-file-uploads-downloads-without-a-back-end-in-react-6438cb77859?source=collection_archive---------10-----------------------#2021-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/873c4eb49c183d5286ce34d52197c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/1*-MzRiX--ym8ueJBrXwPmWQ.gif"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Photo credit: NBC Universal</figcaption></figure><p id="946a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“宽恕我吧，神父，因为我犯了罪…”</p><p id="1666" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我们将尝试一些有点淘气的事情:<strong class="jx io">完全从前端触发浏览器下载。在React(我经常在博客上谈论的一个主题)中，有几个流行的包可以做到这一点，但是今天，我将分享一种简单、实用的前端下载方法，它不需要任何包。这个概念足够通用，可以适应任何框架，但是在React-land中，我们只需要<code class="fe ku kv kw kx b">FileReader()</code>，React的<code class="fe ku kv kw kx b">useRef()</code>钩子和一点黑魔法...</strong></p><h1 id="943e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">背景</strong></h1><p id="4015" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">以前从前端触发下载是不被允许的，原因有几个:</p><ul class=""><li id="a85c" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io">不可靠:</strong>在某些浏览器中，文件可能会在新的标签页/窗口中打开，或者根本无法打开</li><li id="4da6" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">存在安全风险:</strong>强制下载可能会导致恶意软件的入侵</li><li id="d774" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">有味道:</strong>严格来说，这是应该由后端处理的事情</li></ul><p id="2091" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如今单页应用程序比以往任何时候都更加普遍和丰富，浏览器也赶上来了，所以安全风险不那么严重。在一些有限的情况下，当后端仍在构建中时，它可能有助于启动并运行概念验证。</p><h1 id="0423" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用<code class="fe ku kv kw kx b">useRef()</code>和<code class="fe ku kv kw kx b">hidden</code>在DOM上实现</h1><p id="e8bf" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我已经做了一段时间的矢量图形应用。我最终希望将它与连接到处理保存和下载文件的SQL数据库的后端集成在一起，但在此之前，我希望测试我正在生成的SVG文件，以确保它们确实可以工作。所以我设置了一个组件，看起来像这样:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/055fbe94a53f99be52159aaca5c1fe39.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*hHwJOcu0lQsoAR4jRWphXA.png"/></div></figure><p id="b7bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以亲眼看到点击“加载”按钮会出现一个文件上传窗口，每点击一次“保存”按钮，就会出现一次疯狂下载。让我们看看从<a class="ae mp" href="https://github.com/josh-frank/gieves-edit/blob/master/src/components/menus/FilePanel.js" rel="noopener ugc nofollow" target="_blank">中得到的<code class="fe ku kv kw kx b">return</code>是什么，以及它的源代码</a>中的相关组件，看看它是如何完成的:</p><pre class="mr ms mt mu gt mv kx mw mx aw my bi"><span id="9215" class="mz kz in kx b gy na nb l nc nd">export default function FilePanel() {</span><span id="80d0" class="mz kz in kx b gy ne nb l nc nd">...</span><span id="f27b" class="mz kz in kx b gy ne nb l nc nd">  return &lt;div className="menu-panel"&gt;<br/>  &lt;div className="menu-header"&gt;File&lt;/div&gt;<br/><strong class="kx io">    &lt;input<br/>      type="file"<br/>      hidden<br/>    /&gt;</strong><br/>    &lt;button onClick={ () =&gt; {<br/>      alert( "This will erase your artboard!" );<br/>    } }&gt;<br/>      🗂 &lt;b&gt;Load from SVG&lt;/b&gt;<br/>    &lt;/button&gt;<br/>    &lt;button&gt;<br/>      〈／〉 &lt;b&gt;Download as SVG&lt;/b&gt;<br/>    &lt;/button&gt;<br/>&lt;/div&gt;;</span><span id="0067" class="mz kz in kx b gy ne nb l nc nd">}</span></pre><p id="d853" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们这两个按钮的目的很明显——但是<code class="fe ku kv kw kx b">&lt;input type="file"&gt;</code>有什么用呢？这是一个非常熟悉的普通标签，通常显示如下，这并不理想…</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/eef7c5b869277088f6cdc2f7d9ee7c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*CBvW40Oz0Nu0Sic4qSzvLw.png"/></div></figure><p id="246f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">…所以我添加了<code class="fe ku kv kw kx b">hidden</code>属性，这当然隐藏了它，但是这样做使得<code class="fe ku kv kw kx b">input</code>在没有进一步魔法的情况下不可用。<strong class="jx io">进入</strong> <code class="fe ku kv kw kx b"><strong class="jx io">useRef</strong></code> <strong class="jx io">阶段左:</strong></p><pre class="mr ms mt mu gt mv kx mw mx aw my bi"><span id="b5d3" class="mz kz in kx b gy na nb l nc nd"><strong class="kx io">import { useRef } from "react";</strong></span><span id="fb17" class="mz kz in kx b gy ne nb l nc nd">export default function FilePanel() {</span><span id="3a7c" class="mz kz in kx b gy ne nb l nc nd"><strong class="kx io">   const uploadRef = useRef( null );</strong></span><span id="43c9" class="mz kz in kx b gy ne nb l nc nd">   return &lt;div className="menu-panel"&gt;<br/>     &lt;div className="menu-header"&gt;File&lt;/div&gt;<br/>       &lt;input<br/>         type="file"<br/><strong class="kx io">         ref={ uploadRef }<br/></strong>         hidden<br/>       /&gt;<br/>       &lt;button onClick={ () =&gt; {<br/>         alert( "This will erase your artboard!" );<br/><strong class="kx io">         uploadRef.current.click();</strong><br/>       } }&gt;<br/>         🗂 &lt;b&gt;Load from SVG&lt;/b&gt;<br/>       &lt;/button&gt;<br/>       &lt;button&gt;<br/>         〈／〉 &lt;b&gt;Download as SVG&lt;/b&gt;<br/>       &lt;/button&gt;<br/>   &lt;/div&gt;;</span><span id="d14c" class="mz kz in kx b gy ne nb l nc nd">}</span></pre><p id="390e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b"><strong class="jx io">useRef()</strong></code> <strong class="jx io">是一个非常有用的小技巧，每个React开发人员都应该保持警惕。它基本上是一个整洁的小存储盒，保存一个DOM元素作为它的引用；工程师(你)可以使用它的属性<code class="fe ku kv kw kx b">.current</code>调用引用<code class="fe ku kv kw kx b">current</code> ly指向的任何东西。在这种情况下，我们用它来模拟被引用元素上的一个<code class="fe ku kv kw kx b">click()</code>，即使它是<code class="fe ku kv kw kx b">hidden</code>。引用以<code class="fe ku kv kw kx b">null</code>开始，但是由于React的<code class="fe ku kv kw kx b">ref={}</code>属性，一旦DOM被渲染，引用就被设置为我们的文件输入。</strong></p><h1 id="adee" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用<code class="fe ku kv kw kx b">FileReader()</code>响应上传</h1><p id="4b1d" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">现在我们的文件输入如预期的那样工作了，由一个按钮点击触发，而不是由那个丑陋的“选择文件”按钮触发。但是一旦我们的用户上传了本地文件，我们实际上如何使用本地文件呢？让我们写一个方法给<code class="fe ku kv kw kx b">handleUpload()</code>:</p><pre class="mr ms mt mu gt mv kx mw mx aw my bi"><span id="2637" class="mz kz in kx b gy na nb l nc nd">import { useRef } from "react";</span><span id="4972" class="mz kz in kx b gy ne nb l nc nd">export default function FilePanel() {</span><span id="3707" class="mz kz in kx b gy ne nb l nc nd"><strong class="kx io">   const handleUpload = uploadEvent =&gt; {<br/>      const uploadedFile = uploadEvent.target.files[ 0 ];<br/>      if ( uploadedFile &amp;&amp; uploadedFile.type === "image/svg+xml" ) {<br/>         const fileReader = new FileReader();<br/>         fileReader.onload = async loadEvent =&gt; {<br/>            &lt;do stuff with loadEvent here&gt;;<br/>         }<br/>         fileReader.readAsText( uploadedFile );<br/>      }<br/>   };</strong></span><span id="fe07" class="mz kz in kx b gy ne nb l nc nd">   const uploadRef = useRef( null );</span><span id="8145" class="mz kz in kx b gy ne nb l nc nd">return &lt;div className="menu-panel"&gt;<br/>     &lt;div className="menu-header"&gt;File&lt;/div&gt;<br/>        &lt;input<br/>          type="file"<br/>          ref={ uploadRef }<br/><strong class="kx io">          onChange={ handleUpload }<br/></strong>          hidden<br/>        /&gt;<br/>        &lt;button onClick={ () =&gt; {<br/>          alert( "This will erase your artboard!" );<br/>          uploadRef.current.click();<br/>        } }&gt;<br/>          🗂 &lt;b&gt;Load from SVG&lt;/b&gt;<br/>        &lt;/button&gt;<br/>        &lt;button&gt;<br/>          〈／〉 &lt;b&gt;Download as SVG&lt;/b&gt;<br/>        &lt;/button&gt;<br/>   &lt;/div&gt;;</span><span id="4a8f" class="mz kz in kx b gy ne nb l nc nd">}</span></pre><p id="4339" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于一个<code class="fe ku kv kw kx b">&lt;input type="file"&gt;</code>标签，一个<code class="fe ku kv kw kx b">onChange</code>事件将包括一个特殊的属性<code class="fe ku kv kw kx b">files</code>，一个JavaScript <code class="fe ku kv kw kx b">File</code>对象数组，可以通过一个名为<code class="fe ku kv kw kx b">FileReader()</code>的底层库读取。<code class="fe ku kv kw kx b">File</code>和<code class="fe ku kv kw kx b">FileReader()</code>现在基本上是每个广泛使用的浏览器API的一部分。</p><p id="065e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在检查了上传的<code class="fe ku kv kw kx b">file</code>的<code class="fe ku kv kw kx b">type</code>是正确的之后(我们在这里编辑SVG)，我们创建了一个<code class="fe ku kv kw kx b">FileReader()</code>的新实例，并为它提供了一个特殊的回调函数<code class="fe ku kv kw kx b">onload</code>，来定义一旦我们读取了数据，我们将对它做什么:设置状态、更新DOM、更新Redux存储…任何事情！<strong class="jx io">注意</strong> <code class="fe ku kv kw kx b"><strong class="jx io">onload</strong></code> <strong class="jx io">是一个</strong> <code class="fe ku kv kw kx b"><strong class="jx io">async</strong></code> <strong class="jx io">函数，因为它必须等待用户上传文件——</strong>这可能很棘手，所以要小心！</p><h1 id="de8d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用<code class="fe ku kv kw kx b">href</code>和<code class="fe ku kv kw kx b">document.createElement</code>强制下载</h1><p id="d5ec" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我将在这里强调最后一个小技巧，用于下载在一个应用程序中创建/生成的数据，我将它放在一个不同的文件中，我称之为<code class="fe ku kv kw kx b">fileUtilities.js</code>:</p><pre class="mr ms mt mu gt mv kx mw mx aw my bi"><span id="8fd8" class="mz kz in kx b gy na nb l nc nd">export const downloadArtboardAsSvg = ( paths, dimensions ) =&gt; {<br/>  const element = document.createElement( "a" );<br/>  element.setAttribute( "href", "data:image/svg+xml;utf8," + encodeURIComponent( [<br/>    `&lt;?xml version="1.0" encoding="utf-8"?&gt;`,<br/>    `&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;`,<br/>    `&lt;svg version="1.1" id="Layer_1"  xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="${ dimensions[ 0 ] }px" height="${ dimensions[ 1 ] }px" viewBox="0 0 ${ dimensions[ 0 ] } ${ dimensions[ 1 ] }" enable-background="new 0 0 ${ dimensions[ 0 ] } ${ dimensions[ 1 ] }" xml:space="preserve"&gt;`,<br/>    ...paths.map( path =&gt; `&lt;path d="${ path }" stroke="black" stroke-width="1" fill="white" /&gt;` ),<br/>    `&lt;/svg&gt;`<br/>  ].join( "" ) ) );<br/>  element.setAttribute( "download", `GievesEdit-${ Date.now() }` );<br/>  element.style.display = "none";<br/>  document.body.appendChild( element );<br/>  element.click();<br/>  document.body.removeChild( element );<br/>}</span></pre><p id="950c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是怎么回事？为了在点击下载按钮时触发浏览器下载一个SVG文件，我实际上是<strong class="jx io">进入浏览器并创建一个带有<code class="fe ku kv kw kx b">document.createElement</code>的</strong> <code class="fe ku kv kw kx b"><strong class="jx io">&lt;a&gt;</strong></code> <strong class="jx io">标签</strong>。这里有一个细目分类:</p><ul class=""><li id="21fb" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">首先，我用一个名为<code class="fe ku kv kw kx b">encodeURIComponent()</code>的方法设置锚的<code class="fe ku kv kw kx b">href</code>属性，该方法将您希望下载的文件主体包含的任何内容(在本例中，是一个表示SVG文档的字符串)作为参数。</li><li id="51d3" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">然后我设置了主播的<code class="fe ku kv kw kx b">download</code>属性。这做了两件事:它告诉我们的DOM这是一个文件下载的链接(不是URL)，它还设置下载文件的文件名。在这种情况下，我使用带有<code class="fe ku kv kw kx b">Date.now()</code>时间戳的应用程序名称。</li><li id="52ac" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">我通过用<code class="fe ku kv kw kx b">display = "none"</code>隐藏它来确保锚不会在我们的DOM上造成混乱。</li><li id="37a2" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">最后，我用<code class="fe ku kv kw kx b">appendChild()</code>将我们的临时文件锚附加到DOM，模拟一个<code class="fe ku kv kw kx b">click()</code>来触发下载，并通过将其从DOM中移除来进行清理。</li></ul><p id="99ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们所要做的就是将<code class="fe ku kv kw kx b">onClick</code>添加到我们之前使用的React组件中的下载按钮:</p><pre class="mr ms mt mu gt mv kx mw mx aw my bi"><span id="ecac" class="mz kz in kx b gy na nb l nc nd">export default function FilePanel() {</span><span id="b0a4" class="mz kz in kx b gy ne nb l nc nd"><strong class="kx io">const handleDownload = () =&gt; {<br/>   downloadArtboardAsSvg( &lt;...an array of SVG paths held in state&gt; );<br/>};</strong></span><span id="e404" class="mz kz in kx b gy ne nb l nc nd">return &lt;div className="menu-panel"&gt;<br/>     &lt;div className="menu-header"&gt;File&lt;/div&gt;<br/>        &lt;input<br/>          type="file"<br/>          ref={ uploadRef }<br/>          onChange={ handleUpload }<strong class="kx io"><br/></strong>          hidden<br/>        /&gt;<br/>        &lt;button onClick={ () =&gt; {<br/>          alert( "This will erase your artboard!" );<br/>          uploadRef.current.click();<br/>        } }&gt;<br/>          🗂 &lt;b&gt;Load from SVG&lt;/b&gt;<br/>        &lt;/button&gt;<br/>        &lt;button <strong class="kx io">onClick={ handleDownload }</strong>&gt;<br/>          〈／〉 &lt;b&gt;Download as SVG&lt;/b&gt;<br/>        &lt;/button&gt;<br/>   &lt;/div&gt;;</span><span id="8e3c" class="mz kz in kx b gy ne nb l nc nd">}</span></pre><h1 id="0d44" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">结论</strong></h1><p id="2837" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">正如我上面提到的，以及之前在这个博客上提到的，<strong class="jx io">像这样深入</strong> <code class="fe ku kv kw kx b"><strong class="jx io">document</strong></code> <strong class="jx io">并不是什么了不起的反应，但它完成了任务。一场关于以这种方式触发下载是否可接受的激烈辩论仍在继续。许多人坚持认为创建一个端点总是更好；标签不应该以这种方式使用，即使它不会带来安全风险；这种方法既不可靠又笨重。您的里程可能会有所不同。</strong></p><p id="56c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不管怎样，我想我们都同意<code class="fe ku kv kw kx b">useRef()</code>被犯罪性地利用和邪恶的强大。对于React应用程序来说，这是利用熟悉、可靠的普通HTML标签的最佳方式——同时对用户隐藏它们，以支持更灵活、更现代的方式。</p><p id="0e00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容看</em><a class="ae mp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="kt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>