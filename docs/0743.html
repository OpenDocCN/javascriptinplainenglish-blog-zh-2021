<html>
<head>
<title>Secure React SPA using Azure Endpoints with Authorization code flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure端点和授权代码流保护React SPA</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/secure-react-spa-using-azure-endpoints-with-authorization-code-flow-847f47f972d?source=collection_archive---------4-----------------------#2021-02-15">https://javascript.plainenglish.io/secure-react-spa-using-azure-endpoints-with-authorization-code-flow-847f47f972d?source=collection_archive---------4-----------------------#2021-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0b6bdc8cfb70cbb40e736312f3e048a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_lqN_Yp1pusWAugjSWaFQ.jpeg"/></div></div></figure><p id="7d21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于浏览器的认证一直是优化的范围。对运行在浏览器中的公共客户端保密是一种安全威胁，它不能保密，也不能正确地向认证服务器认证。为了处理这样的问题，Oauth 2.0提出了这个概念，叫做<strong class="jx io"> P </strong>屋顶<strong class="jx io"> K </strong> ey代表<strong class="jx io">C</strong>ode<strong class="jx io">E</strong>xchange(<strong class="jx io">PKCE</strong>)。</p><h1 id="eef7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak"> 1。简介</strong></h1><p id="63f0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">根据布洛克·艾伦的</strong> <a class="ae lw" href="https://brockallen.com/2019/01/03/the-state-of-the-implicit-flow-in-oauth2/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">帖子</strong> </a> <strong class="jx io">，</strong></p><p id="d3fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">PKCE使用的缓解措施是在每次客户端需要连接到授权端点时创建一个新的动态秘密。然后，动态秘密将在令牌端点上使用，令牌服务器将帮助保证只有合法的客户端可以使用该代码来获得相应的访问令牌。</em></p><h2 id="c27e" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">从微软文档中，</h2><p id="dfd1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io"> <em class="lx">“如今许多浏览器都在屏蔽第三方cookies——对与浏览器栏中显示的域名不同的域名请求的cookies。这打破了隐式流程，需要新的身份验证模式来成功登录用户。在Microsoft identity platform中，当第三方cookies被阻止时，我们通过PKCE和刷新令牌使用授权流来保持用户登录。”</em>T25】</strong></p><h1 id="91e6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak"> 2。工作演示</strong></h1><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/dbeab975beb94ff95a1d93d63a6a0ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*U1mUv5292DGO-lPWF0vIzg.gif"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Fig 1.0: Microsoft Authentication Code flow with PKCE for React SPA</figcaption></figure><h1 id="5ab1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.Azure端App注册</h1><p id="bc09" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在Azure portal上，您可以获取设置环境所需的所有细节，</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/63ca512b8faeca026f106f504b461059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVQXkYs3OfvJI6AC4Qfmcg.png"/></div></div></figure><p id="132f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要获得正确的应用程序注册指南，您可以关注微软的这篇文章，</p><div class="mu mv gp gr mw mx"><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">快速入门:在Microsoft身份平台中注册应用程序</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">在此快速入门中，您将在Azure门户中注册一个应用程序，以便Microsoft身份平台可以提供…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">docs.microsoft.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jt mx"/></div></div></a></div><p id="4bdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保在<a class="ae lw" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow" rel="noopener ugc nofollow" target="_blank"> SPA </a>下正确注册您的重定向URI，以便为CORS启用它。</p><h1 id="021e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.源代码及其配置</h1><p id="3f00" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我有一个代码样本为这个工作演示准备好了，如上图所示。克隆存储库并安装节点模块</p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="0130" class="ly ku in nn b gy nr ns l nt nu">git clone <a class="ae lw" href="https://github.com/surya5954/LoginAs.git" rel="noopener ugc nofollow" target="_blank">https://github.com/surya5954/LoginAs.git</a><br/>cd LoginAs<br/>npm install</span></pre><p id="3478" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开。env文件，并更新下面提到的字段，</p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="02b0" class="ly ku in nn b gy nr ns l nt nu">REACT_APP_AZURE_ID=&lt;Client ID from Azure App registration portal&gt;<br/>REACT_APP_AZURE_TENANT_ID=&lt;Tenant ID from same portal&gt;</span></pre><p id="39a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在回到我们的应用程序，让我们开始理解这个魔术背后的逻辑，</p><h2 id="0727" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">PKCE相关配置，</h2><p id="bce8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io"> CODE_VERIFIER : </strong>根据<a class="ae lw" href="https://tools.ietf.org/html/rfc7636#section-4.1" rel="noopener ugc nofollow" target="_blank"> PKCE RFC </a>，这需要是最小43位长的URL安全随机字符串，使用无保留字符[A-Z]/[A-Z]/[0–9]/"-" "/ "_" / "~".</p><p id="84cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> CODE_CHALLENGE_METHOD : </strong>根据<a class="ae lw" href="https://tools.ietf.org/html/rfc7636#section-4.2" rel="noopener ugc nofollow" target="_blank"> PKEC RFC </a>这应该是‘sha 256’，如果客户端能够使用它，否则这也可以是‘plain’。</p><p id="525e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> CODE_CHALLENGE : </strong>在“sha256”的情况下，它应该是代码验证器的Base64 URL编码的SHA-256哈希。</p><p id="f8ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> &lt;回购路径&gt;/loginas/src/config/pckeconfigs . js中，</strong></p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="2f25" class="ly ku in nn b gy nr ns l nt nu">import crypto from 'crypto';</span><span id="e3e1" class="ly ku in nn b gy nv ns l nt nu">// Some random 64 bit long string<br/>export const CODE_VERIFIER = 'AdleUo9ZVcn0J7HkXOdzeqN6pWrW36K3JgVRwMW8BBQazEPV3kFnHyWIZi2jt9gA';</span><span id="db35" class="ly ku in nn b gy nv ns l nt nu">export const CODE_CHALLENGE_METHOD = 'S256';<br/>const base64URLEncode = (str) =&gt; {<br/>    return str.toString('base64')<br/>        .replace(/\+/g, '-')<br/>        .replace(/\//g, '_')<br/>        .replace(/=/g, '');<br/>}<br/>const getCodeChallange = (verifier) =&gt; {<br/>    return base64URLEncode(crypto.createHash('sha256')<br/>            .update(verifier).digest());<br/>}<br/>export const CODE_CHALLENGE = getCodeChallange(CODE_VERIFIER);</span></pre><p id="b3b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码生成了我们正在讨论的动态秘密，并帮助您的客户端应用程序成为Microsoft身份验证服务器眼中的合法客户端，以获取access_token。</p><h2 id="f2ff" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">授权端点配置，</h2><p id="fa06" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在，我们来看看如何用PKCE构建您的授权端点调用以获得响应代码，</p><p id="0aed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> &lt;回购路径&gt;/loginas/src/container/AuthEndpointSetup/azure . js中，</strong></p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="2736" class="ly ku in nn b gy nr ns l nt nu">const Azure = () =&gt; {<br/>    return queryString.stringifyUrl({<br/>        url: `<a class="ae lw" href="https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/authorize`" rel="noopener ugc nofollow" target="_blank">https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/authorize`</a>,<br/>        query: {<br/>            client_id: AZURE_ID,<br/>            redirect_uri: REDIRECT_URI,<br/>            response_type: 'code',<br/>            response_mode: 'query',<br/>            scope: [<br/>                'openid',<br/>                'offline_access',<br/>                'email',<br/>                'profile',<br/>                'user.read',<br/>            ].join(" "),<br/>            state: JSON.stringify({ provider: 'Microsoft' }),<br/>            code_challenge: CODE_CHALLENGE,<br/>            code_challenge_method: CODE_CHALLENGE_METHOD<br/>        }<br/>    });<br/>}</span></pre><h2 id="c618" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">从URL获取代码，</h2><p id="b5e1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">接下来，我们需要从URL获取代码细节来构造对令牌端点的调用，</p><p id="f1ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> &lt;回购路径&gt;/loginas/src/container/Layout/Layout . js</strong>中，</p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="2325" class="ly ku in nn b gy nr ns l nt nu">componentDidMount() {<br/>        const [code_param] = /((\?|\&amp;)code\=)[^\&amp;]+/.exec(this.props.location.search) || [];<br/>        const [state_param] = /((\?|\&amp;)state\=)[^\&amp;]+/.exec(this.props.location.search) || [];<br/>        if (code_param != null) <br/>            let code = decodeURIComponent(code_param.replace(/(\?|\&amp;)?code\=/, ''));<br/>            let state = decodeURIComponent(state_param.replace(/(\?|\&amp;)?state\=/, ''));<br/>            const provider = JSON.parse(state).provider;<br/>            console.log(provider + "===&gt; " + code);<br/>            this.setState({ enableProgressBar: true })<br/>            const token = window.localStorage.getItem('token');<br/>            console.log(token);<br/>            if (token == null) {<br/>                this.getAccessTokenFromCode(provider, code);<br/>            } else {<br/>                this.props.history.push('/welcome/user');<br/>            }</span><span id="3044" class="ly ku in nn b gy nv ns l nt nu">        }<br/>}</span></pre><h2 id="147d" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">令牌端点配置，</h2><p id="7d23" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">既然我们已经从URL获得了代码，现在需要构造令牌端点URL，这是一个post调用，</p><p id="e2ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> &lt;回购路径&gt;/loginas/src/container/TokenEndpointSetup/azuretoken . js中，</strong></p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="5626" class="ly ku in nn b gy nr ns l nt nu">const AzureToken = async (code) =&gt; {<br/>    console.log("Getting token for Azure provider ===&gt;");<br/>    let params = {<br/>        client_id: AZURE_ID,<br/>        code: code,<br/>        grant_type: ['authorization_code'],<br/>        redirect_uri: REDIRECT_URI,<br/>        code_verifier: CODE_VERIFIER,<br/>        state: JSON.stringify({ provider: 'Microsoft' }),<br/>    }</span><span id="d6ac" class="ly ku in nn b gy nv ns l nt nu">const post_data = queryString.stringify(params);<br/>    let parsedUrl = URL.parse(`<a class="ae lw" href="https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/token`" rel="noopener ugc nofollow" target="_blank">https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/token`</a>, true);</span><span id="ee37" class="ly ku in nn b gy nv ns l nt nu">let realHeaders = {};<br/>    realHeaders['Host'] = parsedUrl.host;<br/>    realHeaders["Content-Length"] = post_data.length;<br/>    realHeaders["Content-Type"] = 'application/x-www-form-urlencoded';</span><span id="e305" class="ly ku in nn b gy nv ns l nt nu">const options = {<br/>        host: parsedUrl.hostname,<br/>        port: parsedUrl.port,<br/>        path: parsedUrl.pathname,<br/>        method: "POST",<br/>        headers: realHeaders<br/>    };</span><span id="d9e9" class="ly ku in nn b gy nv ns l nt nu">const payload = Object.assign({<br/>        body: post_data<br/>    }, options);</span><span id="dd19" class="ly ku in nn b gy nv ns l nt nu">let response = await fetch(`<a class="ae lw" href="https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/token`" rel="noopener ugc nofollow" target="_blank">https://login.microsoftonline.com/${AZURE_TENANT_ID}/oauth2/v2.0/token`</a>, payload)</span><span id="c71d" class="ly ku in nn b gy nv ns l nt nu">let token_object = await response.json();</span><span id="5b53" class="ly ku in nn b gy nv ns l nt nu">return token_object.access_token;</span><span id="cba1" class="ly ku in nn b gy nv ns l nt nu">}</span></pre><p id="02ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在这个post调用中，我们将那个64位长的随机字符串作为<strong class="jx io"><em class="lx">code _ verifier</em></strong>连同我们从URL获取的代码一起传递。</p><p id="6462" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦你有了access_token，你也会像，</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/381497448d94812057e0916489d28503.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*xp-hMnpbMODxNEPqwLaygg.gif"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Yay !! I have got the token</figcaption></figure><h2 id="9b60" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">获取用户详细信息，</h2><p id="7cca" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在你需要做的就是像老板一样坐下来询问用户的详细信息，下面是我用来获取用户姓名和电子邮件详细信息的代码片段。虽然本例中的access_token是一个JWT令牌，因此您也可以从该令牌中获得一些关于用户的有限细节，但是我已经调用了一个Microsoft Graph Api来获得一些用户细节，</p><p id="b469" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> &lt;回购路径&gt;/loginas/src/container/user details/azureuser . js中，</strong></p><pre class="ml mm mn mo gt nm nn no np aw nq bi"><span id="181f" class="ly ku in nn b gy nr ns l nt nu">const AzureUser = async (token) =&gt; {<br/>    let userProvider;<br/>    const res = await fetch(`<a class="ae lw" href="https://graph.microsoft.com/v1.0/me`" rel="noopener ugc nofollow" target="_blank">https://graph.microsoft.com/v1.0/me`</a>, {<br/>        method: 'get',<br/>        headers: {<br/>            Authorization: `Bearer ${token}`,<br/>        }<br/>    })<br/>    const me = await res.json();<br/>if (me.id) {<br/>        userProvider = {<br/>            name: me.displayName,<br/>            email: me.mail,<br/>        }<br/>    }<br/>    return userProvider;<br/>}</span></pre><h2 id="1930" class="ly ku in bd kv lz ma dn kz mb mc dp ld kg md me lh kk mf mg ll ko mh mi lp mj bi translated">结论</h2><p id="e8ef" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这就是直接从浏览器使用Microsoft endpoint进行成功身份验证所需的全部内容，不涉及后端。我希望这对您有所帮助。感谢您的阅读。</p><p id="3537" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">黑客快乐！</p></div></div>    
</body>
</html>