<html>
<head>
<title>Compound Component Pattern in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应中的复合组分模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/compound-component-pattern-in-react-13ee74b819f8?source=collection_archive---------5-----------------------#2021-03-17">https://javascript.plainenglish.io/compound-component-pattern-in-react-13ee74b819f8?source=collection_archive---------5-----------------------#2021-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7f75" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React中的组件模式指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9e2ed23e18cfa69b162a9d41625ac5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qhU6oHMnqWQIyV11oSvPw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae ks" href="https://unsplash.com/s/photos/reactjs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3735" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">注意:很好地理解</em><a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"><em class="lp">React Context API</em></a><em class="lp">以便能够理解这一部分是很有用的。</em></p><p id="3816" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看下面这段来自react UI库<a class="ae ks" href="https://ant.design/" rel="noopener ugc nofollow" target="_blank"> Ant Design </a>的代码片段。<a class="ae ks" href="https://ant.design/components/menu/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">菜单</em> </a>组件具有看似特殊的属性，称为<em class="lp">项目</em>和<em class="lp">子菜单</em>。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="54cc" class="lv lw in lr b gy lx ly l lz ma">&lt;Menu&gt;<br/>  &lt;Menu.Item&gt;Menu&lt;/Menu.Item&gt;<br/>  &lt;Menu.SubMenu title="SubMenu"&gt;<br/>    &lt;Menu.Item&gt;SubMenuItem&lt;/Menu.Item&gt;<br/>  &lt;/Menu.SubMenu&gt;<br/>&lt;/Menu&gt;</span></pre><p id="5291" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种创建组件的方式被称为复合组件模式。这个想法本质上是，这个例子中的组件<em class="lp">菜单</em>具有一些逻辑，这些逻辑在这个例子中的属性<em class="lp">项目</em>和<em class="lp">子菜单</em>之间共享。想想HTML中的select和option标签。他们打算一起工作。</p><p id="0054" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了便于解释，让我们举一个简单的例子，看看Ant design如何在<em class="lp">菜单</em>组件中使用复合组件模式来为<em class="lp">菜单</em>提供主题。Ant Design使用的默认主题是light，如下图所示。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="1460" class="lv lw in lr b gy lx ly l lz ma"><strong class="lr io">Default Props provided to the <em class="lp">Menu</em> component </strong>(<a class="ae ks" href="https://github.com/ant-design/ant-design/blob/756a1dffea3b8f00876e61fd13f7ceb9ddc561b1/components/menu/index.tsx#L26" rel="noopener ugc nofollow" target="_blank">Source</a>)<strong class="lr io">.</strong></span><span id="4d38" class="lv lw in lr b gy mb ly l lz ma">static defaultProps: Partial&lt;MenuProps&gt; = {<br/>    className: '',<br/>    <strong class="lr io"><em class="lp">theme: 'light', // or dark</em></strong><br/>    focusable: false,<br/>  };</span></pre><p id="cc3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实现复合组件模式的方法是使用上下文API。<em class="lp">菜单</em>组件使用上下文提供程序，并提供必须与<em class="lp">项目</em>和<em class="lp">子菜单</em>组件内部共享的值。此外，<em class="lp">项目</em>和<em class="lp">子菜单</em>组件消耗上下文，这导致状态在组件之间共享。</p><p id="0310" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看<em class="lp">菜单的</em>组件是如何使用上述方法创建复合组件的。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="ef3c" class="lv lw in lr b gy lx ly l lz ma"><strong class="lr io">Creating the context in <em class="lp">Menu</em> component</strong> (<a class="ae ks" href="https://github.com/ant-design/ant-design/blob/756a1dffea3b8f00876e61fd13f7ceb9ddc561b1/components/menu/index.tsx#L74" rel="noopener ugc nofollow" target="_blank">Source</a>)</span><span id="27fb" class="lv lw in lr b gy mb ly l lz ma">&lt;MenuContext.Provider<br/>  value={{<br/>    inlineCollapsed: this.getInlineCollapsed() || false,<br/>    <strong class="lr io"><em class="lp">antdMenuTheme: theme,</em></strong><br/>    direction,<br/>  }}<br/>&gt;</span><span id="ae0c" class="lv lw in lr b gy mb ly l lz ma"><strong class="lr io">Consuming the context in <em class="lp">SubMenu</em> Component</strong> (<a class="ae ks" href="https://github.com/ant-design/ant-design/blob/d5eda4f87e4c1bb605d08a2acea76c8eb7163a4d/components/menu/SubMenu.tsx#L57" rel="noopener ugc nofollow" target="_blank">Source</a>)</span><span id="a9c5" class="lv lw in lr b gy mb ly l lz ma">&lt;MenuContext.Consumer&gt;<br/>  {({ inlineCollapsed, <strong class="lr io"><em class="lp">antdMenuTheme</em></strong> }: MenuContextProps) =&gt; (<br/>    &lt;RcSubMenu<br/>      {...omit(this.props, ['icon'])}<br/>      title={this.renderTitle(inlineCollapsed)}<br/>      popupClassName={classNames(<br/>        rootPrefixCls,<br/>        <strong class="lr io"><em class="lp">`${rootPrefixCls}-${antdMenuTheme}`,</em></strong><br/>        popupClassName,<br/>      )}<br/>    /&gt;<br/>  )}<br/>&lt;/MenuContext.Consumer&gt;</span></pre><p id="6d9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意<em class="lp">菜单</em>组件创建了一个上下文并提供了<em class="lp">主题的值。</em>该值随后在<em class="lp">子菜单</em>组件中被消耗。因此，复合组件模式是使用上下文API创建的。</p><p id="c9d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里是<a class="ae ks" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> React Bootstrap </a>使用的复合组件模式的另一个例子。这个例子使用了带有<a class="ae ks" href="https://react-bootstrap.github.io/components/modal/" rel="noopener ugc nofollow" target="_blank">模态</a>的模式。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="1204" class="lv lw in lr b gy lx ly l lz ma"><strong class="lr io">Compound component in React Bootstrap</strong> (<a class="ae ks" href="https://react-bootstrap.github.io/components/modal/" rel="noopener ugc nofollow" target="_blank">Source</a>)</span><span id="d7ea" class="lv lw in lr b gy mb ly l lz ma">&lt;Modal.Dialog&gt;<br/>  &lt;Modal.Header closeButton&gt;<br/>    &lt;Modal.Title&gt;Modal title&lt;/Modal.Title&gt;<br/>  &lt;/Modal.Header&gt;<br/>  &lt;Modal.Body&gt;<br/>    &lt;p&gt;Modal body text goes here.&lt;/p&gt;<br/>  &lt;/Modal.Body&gt;<br/>  &lt;Modal.Footer&gt;<br/>    &lt;Button variant="secondary"&gt;Close&lt;/Button&gt;<br/>    &lt;Button variant="primary"&gt;Save changes&lt;/Button&gt;<br/>  &lt;/Modal.Footer&gt;<br/>&lt;/Modal.Dialog&gt;</span></pre><p id="de2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React bootstrap还利用上下文API来实现该模式。</p><h1 id="53da" class="mc lw in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">为什么要复合成分？</h1><p id="8cb3" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">我确信这种模式一定引起了你的兴趣，但是你可能仍然想知道这种模式的必要性。</p><ul class=""><li id="2ac3" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">让我们假设React Bootstrap为Modal提供了一个类似这样的API</li></ul><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="5b29" class="lv lw in lr b gy lx ly l lz ma"><strong class="lr io">Alternative internal implementation of the Modal Component</strong></span><span id="4486" class="lv lw in lr b gy mb ly l lz ma">const Modal = ({title, body}) =&gt; {<br/>  return(<br/>    &lt;div className="modal"&gt;<br/>      &lt;div className="modal-title"&gt;{title}&lt;/div&gt;<br/>      &lt;div className="modal-body"&gt;{body}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="157c" class="lv lw in lr b gy mb ly l lz ma"><strong class="lr io">Consuming the Modal component</strong></span><span id="ba54" class="lv lw in lr b gy mb ly l lz ma">&lt;Modal title={...} body={...}/&gt;</span></pre><p id="41e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当用户传递所需的道具时，它肯定会工作。然而，当显示模式时，API有一个非常严格的方法。使用复合组件方法，用户可以灵活选择是否显示<em class="lp">模态。标题</em>。用户还可以灵活选择显示顺序。不管出于什么原因，仍然可以显示<em class="lp">模态。正文</em>在<em class="lp">情态之前。标题</em>。</p><ul class=""><li id="cd41" class="my mz in kv b kw kx kz la lc na lg nb lk nc lo nd ne nf ng bi translated">让我们再举一个例子，其中的用例是在点击按钮时切换内容。这个想法是利用组件之间隐式共享的状态。</li></ul><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="0693" class="lv lw in lr b gy lx ly l lz ma"><strong class="lr io">Creating the Compound Component Pattern</strong></span><span id="bcfb" class="lv lw in lr b gy mb ly l lz ma">import React, { useContext, useState } from "react";</span><span id="1055" class="lv lw in lr b gy mb ly l lz ma"><em class="lp">// creating the context</em><br/>const TogglerContext = React.createContext();</span><span id="90b4" class="lv lw in lr b gy mb ly l lz ma">const Toggler = ({ children }) =&gt; {<br/>  // this state will be shared<br/>  const [value, setValue] = useState(false);</span><span id="3c30" class="lv lw in lr b gy mb ly l lz ma">  const toggle = () =&gt; {<br/>    setValue((prevValue) =&gt; !prevValue);<br/>  };</span><span id="39fd" class="lv lw in lr b gy mb ly l lz ma">  return (<br/>    <em class="lp">// using context to share the state between the components<br/>    </em>&lt;TogglerContext.Provider value={{ value }}&gt;<br/>      &lt;div&gt;<br/>        &lt;div role="button" onClick={toggle}&gt;<br/>          Toggle Description<br/>        &lt;/div&gt;<br/>        {children}<br/>      &lt;/div&gt;<br/>    &lt;/TogglerContext.Provider&gt;<br/>  );<br/>};</span><span id="7c17" class="lv lw in lr b gy mb ly l lz ma">const Data = ({ children }) =&gt; {<br/>  <em class="lp">// Consuming the context</em><br/>  const TogglerContextConsumer = useContext(TogglerContext);<br/>  return TogglerContextConsumer.value &amp;&amp; &lt;&gt;{children}&lt;/&gt;;<br/>};</span><span id="3711" class="lv lw in lr b gy mb ly l lz ma"><strong class="lr io">Using the Compound Component Pattern</strong></span><span id="f909" class="lv lw in lr b gy mb ly l lz ma">&lt;Toggler&gt;<br/>  &lt;Data&gt;<br/>    &lt;p&gt;I will get toggled when you click the button.&lt;/p&gt;<br/>  &lt;/Data&gt;<br/>&lt;/Toggler&gt;</span></pre><p id="f639" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意<em class="lp">数据</em>组件如何利用<em class="lp"> Toggler </em>组件中定义的状态变量来<a class="ae ks" href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener ugc nofollow" target="_blank">有条件地呈现</a>的子组件。本质上，这两个组件之间存在内部状态共享，这为最终用户提供了一个灵活的API。上面的代码片段是一个非常基本的例子来说明这个想法。</p><p id="7b2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您一定已经注意到，与复合组件模式相关联的组件通常被声明为<em class="lp">模态</em>、<em class="lp">模态。标题</em>，<em class="lp">模态。标题</em>，等等。这种符号有助于在相关组件之间建立心理联系。让我们快速地将我们的例子从<em class="lp">托格勒</em>修改为<em class="lp">托格勒.数据.</em></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="da8b" class="lv lw in lr b gy lx ly l lz ma">// Add the following line just after the Data component.<br/>Toogler.Data = Data;</span><span id="106a" class="lv lw in lr b gy mb ly l lz ma"><strong class="lr io">Using the Modified Compound Component Pattern</strong></span><span id="5e91" class="lv lw in lr b gy mb ly l lz ma">&lt;Toggler&gt;<br/>  &lt;Toggler.Data&gt;<br/>    &lt;p&gt;I will get toggled when you click the button.&lt;/p&gt;<br/>  &lt;/Toggler.Data&gt;<br/>&lt;/Toggler&gt;</span></pre><h1 id="0d4d" class="mc lw in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">结论</h1><p id="d127" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">复合组件模式允许我们表达组件之间的关系。组件共享状态，这意味着状态被所涉及的组件内部使用和操纵。该模式提供了一个更简洁的API，并使用react上下文实现。</p><p id="c544" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">既然你已经理解了这个模式，让我们开始使用它吧！</p></div></div>    
</body>
</html>