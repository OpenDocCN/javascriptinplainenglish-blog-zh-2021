<html>
<head>
<title>How To Create And Use Hash Tables in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中创建和使用哈希表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hash-tables-in-javascript-cb2b804cd1c8?source=collection_archive---------5-----------------------#2021-02-01">https://javascript.plainenglish.io/hash-tables-in-javascript-cb2b804cd1c8?source=collection_archive---------5-----------------------#2021-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2137a1fa3ed963ae238682e388542322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oL8AwW4LKEpMTREm"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pisitheng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pisit Heng</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a16e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哈希表是由键和值对组成的数据结构。一个很好的类比是把它想象成一本字典(书)，关键字是单词，值是定义。如果你觉得这听起来很熟悉，那你就对了，JavaScript对象就是哈希表的一个例子。也就是说，使用JavaScript的内置对象或映射，会比我在这里实现的更快更好。这篇博客更多的是关于理解哈希表背后的概念。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="1ef1" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">散列表的利与弊</h1><h2 id="189f" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">赞成的意见</h2><ul class=""><li id="6cb8" class="mq mr in kc b kd ms kh mt kl mu kp mv kt mw kx mx my mz na bi translated">快速查找</li><li id="894d" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">快速插入</li><li id="8eca" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">快速删除</li></ul><h2 id="e6ed" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">骗局</h2><ul class=""><li id="f6e4" class="mq mr in kc b kd ms kh mt kl mu kp mv kt mw kx mx my mz na bi translated">哈希冲突(特别是当有很多哈希冲突时)</li><li id="3c77" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">对少量数据效率不高</li><li id="1897" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">对于在不知道键的情况下搜索值来说不是很有效(在哈希表中迭代)</li><li id="0ffe" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">不适合排序</li></ul><h1 id="d758" class="lg lh in bd li lj ng ll lm ln nh lp lq lr ni lt lu lv nj lx ly lz nk mb mc md bi translated">履行</h1><h2 id="4869" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">从数组开始</h2><p id="4ffa" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">为了实现哈希表，我们将利用数组的快速查找和插入时间。为此，我们将初始化一个数组，其大小大致相当于我们要存储的键和值对的数量(我们将创建一个动态大小的哈希表，所以如果我们不知道数量，也没关系)。在这里，我们将创建一个散列函数。</p><h2 id="9e37" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">散列法</h2><p id="25a2" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">散列的目的是给定一个键，它将生成一个在数组边界内的索引。给定相同的密钥，哈希算法总是产生相同的索引，这一点很重要。这样我们就可以通过给定的键来查找条目。散列算法相对较快也很重要，因为每个条目和查找都必须运行它。</p><p id="c46c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个完美的实现中，每个给定的键会产生一个唯一的索引，这被称为完美散列函数。但是，您更有可能遇到两个或更多产生相同索引的键。这叫做碰撞。</p><h2 id="7ae4" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">碰撞</h2><p id="1a90" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">由于碰撞几乎是不可避免的，我们需要一种方法来处理它们。一般来说，有两种方法来处理冲突。</p><p id="5aa3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">单独链接</strong></p><p id="7950" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这包括在散列表的每个索引处存储一些其他类型的列表结构。这是我将在这里讨论的方法。有许多不同的方式进行单独的链接，每一种都有自己的优点和缺点。我就不多说了。</p><p id="0a65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">开放寻址</strong></p><p id="5bcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开放式寻址不是在哈希表的每个索引处存储另一个列表，而是在给定索引处已经有一个元素时实现一个探测序列。简而言之，探测序列是关于在哈希表中下一步在哪里查找以尝试找到空槽的指令。</p><p id="3815" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在线性探测中，探测器之间的间隔是固定值。所以如果你的哈希函数给你的索引是0，但是已经有了，你可以加4，如果索引是4，你再加4，那么索引8是空的，所以你可以在那里存储你的键和值对。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="e594" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">密码</h1><p id="ed51" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">我将使用一个JavaScript类来实现一个散列表。这是类和构造函数，从这里开始，所有的代码都将进入这个类。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1b19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“桶”是一个术语，用于表示存储在索引中的一系列键和值对。在独立链接中，一个桶中可以存储不止一个键和值对，而在开放式寻址中，一个桶中只存储一个键和值对。</p><p id="87b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们需要我们的散列函数。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Link to source for hash function: <a class="ae jz" href="https://logicmason.com/2013/how-to-implement-a-hash-table/" rel="noopener ugc nofollow" target="_blank">https://logicmason.com/2013/how-to-implement-a-hash-table/</a></figcaption></figure><p id="8f30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我从上面的链接得到了这个散列函数，功劳归于马克·威尔伯。我不明白为什么它会给我们这么好的分布。我已经在代码的注释中尽可能多地解释了这一点。你将在大多数(如果不是全部)散列函数中看到的最重要的部分是使用模数(%运算符)。这确保了数字在数组索引的范围内。</p><p id="a9ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们的索引是通过散列函数确定的，所以让我们使用一些方法来轻松地将一个键转换成一个索引，并在该索引处抓取桶。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="76fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住，bucket可以包含多个键和值对。因此，虽然我们有办法访问bucket，但是我们还需要做更多的工作来访问正确的键和值对。</p><p id="8d49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们能够检索任何元素之前，我们需要能够插入它们。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="879a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的代码在这里变得有点复杂。首先，我们需要确定存储桶的索引。然后我们看看这个桶是否存在(如果里面什么都没有，那么访问这个索引将返回<code class="fe nu nv nw nx b">undefined</code>)。如果不存在，实例化一个空数组来存储我们的键和值对。</p><p id="bbec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从那里我们可以获取<code class="fe nu nv nw nx b">bucket</code>本身(即使它只是一个空数组)。如果我们已经插入了一个键和值对，我们需要覆盖与之相关的值。如果没有，我们需要将它插入桶中。</p><p id="590f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将键和值对存储为一个元组。元组是包含两个项目的数组。因此，我们知道我们的键总是在索引0，我们的值在索引1。所以我们的桶是充满元组的数组。</p><p id="1844" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们遍历我们的桶，如果有一个键与我们插入的键匹配，我们就覆盖这个值。如果没有，我们就把它推进桶里。如果我们必须把它推进去，我们就增加我们的尺寸。</p><p id="ced4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从那里我们检查哈希表是否需要调整大小(有时称为重散列)。这由装载系数决定，装载系数实质上是装满的铲斗与最大尺寸之间的比率。在时间和空间复杂度之间具有良好折衷的负载因子在. 25和. 75之间。</p><p id="3291" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以这样考虑装载系数，我们的铲斗越少，就越有可能发生碰撞。但是，一堆空桶占用了不必要的空间。</p><p id="af16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看<code class="fe nu nv nw nx b">resize</code>法。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3980" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数获取当前的存储桶，并将它们存储在一个临时变量(<code class="fe nu nv nw nx b">tempBuckets</code>)中。在那里，我们将大小重置为0，并清除当前的存储桶。我们遍历我们的<code class="fe nu nv nw nx b">tempBuckets</code>,将每个键和值对添加回调整后的哈希表中。我们通过我们的<code class="fe nu nv nw nx b">set</code>方法运行它，因为它使用<code class="fe nu nv nw nx b">getIndex</code>来运行我们的散列函数。我们需要再次这样做，因为我们的散列函数的结果取决于散列表的最大大小。因此，我们的旧指数不会与新指数保持一致。</p><p id="4921" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道了如何添加元素，以及调整哈希表的大小时会发生什么。让我们看看<code class="fe nu nv nw nx b">get</code>方法，我们用它来检索给定的键和值对的值。</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4e29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给我们一把钥匙，我们取回水桶。我们遍历该桶中的键和值对，并返回与给定键相关联的值。如果没有bucket，我们就不会将那个键插入哈希表，所以我们返回<code class="fe nu nv nw nx b">undefined</code>。</p><p id="f3fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用<code class="fe nu nv nw nx b">get</code>和<code class="fe nu nv nw nx b">set</code>元素。让我们创建一个<code class="fe nu nv nw nx b">remove</code>方法！</p><figure class="no np nq nr gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f68a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于<code class="fe nu nv nw nx b">remove</code>，这是一个类似于<code class="fe nu nv nw nx b">get</code>的概念。我们找到正确的桶，并遍历桶，直到找到正确的键。我们将<code class="fe nu nv nw nx b">splice</code>存储桶，而不仅仅是返回它，以便从中移除那个键和值对。如果加载因子很低，我们将调整哈希表的大小。然后我们返回我们移除的节点的值。</p><p id="b568" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！我们可以在哈希表中插入、检索和删除元素。</p><h1 id="01d2" class="lg lh in bd li lj ng ll lm ln nh lp lq lr ni lt lu lv nj lx ly lz nk mb mc md bi translated">时间和空间复杂性</h1><h2 id="45c9" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">时间复杂度</h2><p id="c1b8" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">您可能想知道，由于所有的额外复杂性，这怎么比数组快呢？我们正在遍历一个包含列表(桶)的列表，以便找到正确的键和值对！</p><p id="f05f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建哈希表的主要目标是尽可能减少冲突。大多数情况下，一个桶中只有一个键和值对，所以即使我们在搜索，也应该立即找到。</p><p id="9c26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看上述方法的时间复杂性:</p><ul class=""><li id="b500" class="mq mr in kc b kd ke kh ki kl ny kp nz kt oa kx mx my mz na bi translated"><code class="fe nu nv nw nx b">HashFunction</code>、<code class="fe nu nv nw nx b">getIndex</code>、<code class="fe nu nv nw nx b">getBucket</code>都是O(1)。<code class="fe nu nv nw nx b">HashFunction</code>的运行时间是由键的长度决定的，所以和哈希表本身的大小无关。</li><li id="ac3e" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe nu nv nw nx b">get</code>最糟糕的情况是，每个键和值对都存储在同一个桶中，我们要找的那个在最后。这将导致O(n)个时间复杂度。然而，如前所述，这种情况非常罕见。通常<code class="fe nu nv nw nx b">get</code>需要O(1)个时间。</li><li id="07b6" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe nu nv nw nx b">set</code>，假设我们不需要调整哈希表的大小，类似于<code class="fe nu nv nw nx b">get</code>。最坏的情况是，所有对都在同一个桶里，我们需要把它加到最后。但是，大多数时间需要O(1)次。</li><li id="b211" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe nu nv nw nx b">remove</code>，最坏的情况是O(n)。这是因为如果我们需要删除包含所有对的桶中的最后一对。我们将首先遍历所有的对，得到正确的对，然后使用<code class="fe nu nv nw nx b">splice</code>即O(n)。这是O(n + n)，简化为O(n)。但是，在大多数情况下，一个存储桶中只有一对，因此需要O(1)。</li><li id="a4ad" class="mq mr in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe nu nv nw nx b">resize</code>将始终取O(n)。因为我们需要将每一对复制到调整了大小的哈希表中。</li></ul><p id="187e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，对于查找、删除和插入，最坏的时间复杂度是O(n)，但更可能是O(1)。</p><h2 id="c5ce" class="me lh in bd li mf mg dn lm mh mi dp lq kl mj mk lu kp ml mm ly kt mn mo mc mp bi translated">空间复杂性</h2><p id="cf25" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">哈希表的空间复杂度是O(n)。这是因为我们正在动态调整哈希表的大小。哈希表中存储桶的数量应该具有0 . 25到0 . 75的负载系数。这意味着在任何给定的点上，哈希表应该在25%到75%之间，如果不是，我们就调整大小。因此，随着配对数量的增加或减少，我们的桌子也相应地增加和减少。</p><h1 id="0740" class="lg lh in bd li lj ng ll lm ln nh lp lq lr ni lt lu lv nj lx ly lz nk mb mc md bi translated">最后</h1><p id="55f3" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">哈希表是一种有用的数据结构，用于解决许多现实世界中的问题。它们的一些用例包括:编译器使用它们来识别关键字、缓存和数据库索引。当您有大量相关数据时，哈希表是很好的选择，其中顺序并不重要。我想我会坚持JavaScript的内置数据结构，但是观察事物在幕后是如何工作的总是很有趣的。你可以从这个博客的<a class="ae jz" href="https://github.com/ReginaF2012/javascript-hash-table" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中找到代码。</p></div></div>    
</body>
</html>