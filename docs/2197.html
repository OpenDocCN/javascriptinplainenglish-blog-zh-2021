<html>
<head>
<title>How I Setup Database Migration using Sequelize in Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在微服务架构中使用Sequelize设置数据库迁移</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-setup-database-migration-using-sequelize-in-microservice-architecture-629cbc8115b6?source=collection_archive---------8-----------------------#2021-05-08">https://javascript.plainenglish.io/how-i-setup-database-migration-using-sequelize-in-microservice-architecture-629cbc8115b6?source=collection_archive---------8-----------------------#2021-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f06aad168215a0458e4f330e505246cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WUP605eJ6DvQkC-i"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mightyhummingbird?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mariko margetson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="81bd" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="8ae4" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">很久以前，我与Joe就为基于微服务的架构建立迁移脚本存储库进行了一次对话。对话是这样进行的:</p><p id="822c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我:嘿，乔，我们在代码中使用了<a class="ae jz" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank">序列</a>。但是我们的迁移呢？由于我们使用基于微服务的架构，如果我们在每个服务中编写我们的迁移文件，管理起来不会很困难，而且脚本分散在各处。</p><p id="b74f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">乔:嗯……你可能是对的。不如我们建立一个名为<strong class="la io">迁移</strong>的存储库。我们将把所有迁移脚本集中在该存储库中。因此，我们可以在单个存储库中对所有的变更有一个总体的了解。你怎么想呢?</p><p id="6100" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我:听起来是个好主意。让我们开始寻找&amp;解决这个问题。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="6763" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">逐步指南</h1><p id="301c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在我们从头开始浏览分步指南之前，让我们对我们将拥有的东西有一个高层次的概述。</p><ul class=""><li id="a258" class="mn mo in la b lb lw lf lx lj mp ln mq lr mr lv ms mt mu mv bi translated">具有<code class="fe mw mx my mz b">sequelize-cli</code>依赖关系的节点项目</li><li id="7820" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated"><code class="fe mw mx my mz b">models</code>文件夹中包含了所有的模型表。我们将总是在这里拥有最新的模型结构，因此整个团队将在存储库中检查最新的表结构。</li><li id="ac0b" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated"><code class="fe mw mx my mz b">migrations</code>文件夹，包含使用<code class="fe mw mx my mz b">sequelize-cli</code>生成的所有迁移脚本和开发人员编码的数据库更改。</li></ul><p id="785a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">事不宜迟，让我们开始深入细节。</p><h2 id="e233" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">第一步。启动项目</h2><p id="3637" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这里是关于我们如何引导项目的命令，并且<code class="fe mw mx my mz b">sequelize-cli</code>库提供了引导命令，我们可以把它看作是移植库的样板。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5d8c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">上面的命令将创建名为<code class="fe mw mx my mz b">config</code>、<code class="fe mw mx my mz b">migrations,</code>和<code class="fe mw mx my mz b">seeders</code>的文件夹。下面是您的项目的截图:</p><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/91965aa9411c8b9320b1990d217f7f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*rDf6g2A4F3gL_FrD.png"/></div></figure><p id="53ec" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">sequelize <a class="ae jz" href="https://sequelize.org/master/manual/migrations.html" rel="noopener ugc nofollow" target="_blank">文档</a>也为这些文件夹的功能提供了非常直观的解释。下面是每个文件夹的描述截图。</p><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cbfcd1652f91268d53467f7f9808e0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*5ku1EdTsYfySK6bs.png"/></div></figure><p id="338c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我们已经准备好了样板代码。接下来，我们将准备好环境变量，以便我们可以选择在不同的环境中运行迁移脚本。</p><p id="83c5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们进入第二步。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="2a67" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">第二步。使用环境变量的动态配置设置</h2><p id="bf1e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">您可能注意到了，配置是以<code class="fe mw mx my mz b">json</code>格式编写的。使用json格式，我们无法实现动态配置设置，这意味着每次都需要更改数据库名称、凭证，甚至其他配置。您需要进行代码更改&amp;将源代码提交给存储库。</p><p id="0d31" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">因此，我们可以按照以下说明使用动态配置进行设置。</p><ul class=""><li id="5784" class="mn mo in la b lb lw lf lx lj mp ln mq lr mr lv ms mt mu mv bi translated">在<em class="nz">配置</em>文件夹中创建一个名为<code class="fe mw mx my mz b">config.js</code>的文件</li><li id="13e3" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">在根目录下创建一个名为<code class="fe mw mx my mz b">.sequelizerc</code>的文件。该文件的目的是覆盖默认配置位置为<code class="fe mw mx my mz b">config.js</code>。默认的配置文件是<code class="fe mw mx my mz b">config.json</code></li><li id="b8e1" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">创建名为<code class="fe mw mx my mz b">.env</code>的环境文件，因为我们将使用<a class="ae jz" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>库来加载本地测试中的环境配置。(如果您使用pm2等其他工具，此步骤可能是可选的)或etc。</li><li id="e489" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">接下来，我们将安装<a class="ae jz" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>库，并初始化它以将环境变量加载到<code class="fe mw mx my mz b">config.js</code>中</li></ul><p id="a02a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">事不宜迟，让我们详细讨论一下每一个问题。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="08df" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在将以下内容粘贴到<code class="fe mw mx my mz b">config.js</code>中。在下面的例子中，我使用的是MySQL数据库。您可以随意使用自己喜欢的数据库，比如Postgresql或其他关系数据库。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="20b1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来，我们将编辑<code class="fe mw mx my mz b">.sequelizerc</code>的内容，以覆盖默认位置<code class="fe mw mx my mz b">config/config.json</code>到<code class="fe mw mx my mz b">config/config.js</code>的配置文件位置。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d26d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这一步的最后一部分，我们将在您的本地环境中创建<code class="fe mw mx my mz b">.env</code>文件，并定义您的数据库凭证。此外，我们还定义了<code class="fe mw mx my mz b">NODE_ENV</code> env变量，该变量应该与您在<code class="fe mw mx my mz b">config.js</code>中定义的键相匹配。例如，如果您为NODE_ENV定义了<code class="fe mw mx my mz b">test</code>，那么sequelize-cli将使用在<code class="fe mw mx my mz b">test.</code>中定义的配置</p><p id="1ff4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">此外，出于最佳安全实践，您不应该将该文件提交给存储库。因此，您的数据库凭证不会暴露给每个可以访问存储库的人。</p><blockquote class="oa ob oc"><p id="4091" class="ky kz nz la b lb lw ld le lf lx lh li od ly ll lm oe lz lp lq of ma lt lu lv ig bi translated"><em class="in">注意:您可以将</em> <code class="fe mw mx my mz b"><em class="in">.env</em></code> <em class="in">文件添加到您的</em> <code class="fe mw mx my mz b"><em class="in">.gitignore</em></code> <em class="in">中，这样您的Git CLI &amp;客户端就可以忽略该文件，从而不会意外将其提交到您的存储库中。</em></p></blockquote><p id="3b5a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">以下是我的<code class="fe mw mx my mz b">.env</code>文件的示例。我只在示例env文件中定义了测试环境的数据库凭据。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="61a2" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">第三步。验证动态配置设置</h2><p id="9f94" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在此步骤中，我们将尝试通过迁移创建一个简单的表，以验证迁移是否在存储库中成功运行。</p><p id="8b4c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们可以按照以下说明验证设置。</p><ul class=""><li id="b289" class="mn mo in la b lb lw lf lx lj mp ln mq lr mr lv ms mt mu mv bi translated">使用<code class="fe mw mx my mz b">sequelize-cli</code>创建迁移脚本模板</li><li id="fc56" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">通过创建用户表完成上面创建的脚本。创建包含多列的表</li><li id="35db" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">运行迁移命令&amp;确保迁移脚本成功执行。</li></ul><p id="69e4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">不用多说，让我们深入探讨每一个问题。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b347" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">使用上述命令创建迁移脚本后，您将能够看到在<em class="nz">迁移</em>目录中创建了一个<code class="fe mw mx my mz b">.js</code>文件。现在，让我们继续添加迁移命令-创建表和回滚命令-删除表。下面是迁移脚本的示例:</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="244e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来，我们将通过运行下面的命令来运行迁移脚本。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4799" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，让我们验证迁移脚本是否成功执行。您会看到新的<em class="nz">用户</em>表被创建。默认情况下，迁移脚本也存储在<code class="fe mw mx my mz b">SequelizeMeta</code>表中。请参阅下面的截图。</p><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/3fd57ef99b0b4094968deecde6d0fc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RG4hiAGxICQFPbtm.png"/></div></div></figure><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/cfeacd27211523eb6ae8bf4dd4ddcef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I215sfKuPUF7pMQy.png"/></div></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="65f9" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">第四步。可选配置(可选)</h2><p id="9ca2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，我们已经拥有了功能齐全的迁移存储库。但是我们可以有更多的额外配置，例如:</p><ul class=""><li id="adb2" class="mn mo in la b lb lw lf lx lj mp ln mq lr mr lv ms mt mu mv bi translated">更改迁移存储表名称</li><li id="2183" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">更改播种机存储表名称</li></ul><p id="35ff" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在此步骤中，我们将尝试将迁移存储表的名称从默认的<code class="fe mw mx my mz b">SequelizeMeta</code>更改为<code class="fe mw mx my mz b">migrations</code>。让我们深入研究一下。</p><p id="7141" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">默认情况下，sequelize将迁移脚本名称存储在<code class="fe mw mx my mz b">SequelizeMeta</code>表中，以便跟踪哪些迁移已经执行，哪些没有执行。但是，我们可以将默认的迁移存储表名称更改为我们更喜欢的名称，在本例中，我们将它更改为<code class="fe mw mx my mz b">migrations</code>。</p><p id="515a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在更改迁移表名称之前，让我们通过运行下面的命令来回滚我们在步骤3中所做的更改。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0ee0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您将看到下面成功回滚的截图。</p><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a7d696f20567c28ce531c16ecda565c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*jVRAMP5YyZYSK71I.png"/></div></figure><p id="58ab" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">成功回滚后，通过编辑<code class="fe mw mx my mz b">config.js</code>开始。我们将把<code class="fe mw mx my mz b">migrationStorageTableName</code>键添加到测试配置中。下面是编辑后的<code class="fe mw mx my mz b">config.js</code>的例子。</p><figure class="nr ns nt nu gt jo"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="eabc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">编辑后，我们现在可以运行migrate命令，现在您将看到迁移脚本已执行，新的<code class="fe mw mx my mz b">migrations</code>表已创建，我们的迁移脚本名称已记录在表中。参考下面的截图。</p><figure class="nr ns nt nu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/13c42fb13b55abd01c09824e9c0c3175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*42sbSDouKQM-a3xD.png"/></div></div></figure><p id="3713" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我们的迁移脚本存储在迁移表中。</p><h1 id="a957" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="54d1" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在本文中，我们创建了一个用于迁移目的的集中存储库，其中存储了所有的迁移脚本和最新的模型文件。拥有集中式存储库的目的是解决迁移脚本分散在不同微服务中的问题。</p><p id="99d3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">此外，我们还深入探讨了细节:</p><ul class=""><li id="66ac" class="mn mo in la b lb lw lf lx lj mp ln mq lr mr lv ms mt mu mv bi translated">引导迁移存储库</li><li id="4f81" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">通过环境变量为不同的环境使用动态配置设置</li><li id="5911" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">通过创建一个简单的迁移脚本来验证设置是否正确</li><li id="0ed9" class="mn mo in la b lb na lf nb lj nc ln nd lr ne lv ms mt mu mv bi translated">覆盖默认迁移存储表名称</li></ul><p id="6427" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">最后但同样重要的是，您可以在这里获得迁移库<a class="ae jz" href="https://github.com/tlcheah2/sequelize-migration-microservice-example" rel="noopener ugc nofollow" target="_blank">的完整源代码。</a></p><p id="5869" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我希望这篇文章对你有所帮助，并和我分享你是如何在关系数据库中管理迁移的，我希望看到你的回应。</p><p id="b3e8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下篇见，感谢阅读。</p><p id="5e5a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><em class="nz">原创文章发表在我的</em> <a class="ae jz" href="https://tekloon.dev/how-i-setup-database-migration-using-sequelize-in-microservice-architecture" rel="noopener ugc nofollow" target="_blank"> <em class="nz">博客</em> </a> <em class="nz">。</em></p><p id="efca" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">参考</strong>:顺序迁移<a class="ae jz" href="https://sequelize.org/master/manual/migrations.html" rel="noopener ugc nofollow" target="_blank">文档</a></p></div></div>    
</body>
</html>