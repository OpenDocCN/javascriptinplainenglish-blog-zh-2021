<html>
<head>
<title>The Difference Between Object.assign() and Object.create() in JavaScript — JS interview series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript — JS访谈系列中Object.assign()和Object.create()的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/difference-between-object-assign-and-object-create-in-javascript-6f3ee100f99d?source=collection_archive---------1-----------------------#2021-06-05">https://javascript.plainenglish.io/difference-between-object-assign-and-object-create-in-javascript-6f3ee100f99d?source=collection_archive---------1-----------------------#2021-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ca5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">物体之间的区别。create()和Object。assign()是JavaScript面试中被问得最多的问题之一。因此，有必要了解这两种方法之间的区别以及它们实现的本质。</p><p id="9012" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将讨论对象之间的差异。赋值()和对象。详细创建()。所以抓紧了，让我们开始吧。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><h1 id="623e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.Object.assign()和Object.create()之间的基本区别</h1><p id="290a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated"><strong class="jm io">对象。assign(): </strong>对象。assign()用于复制可枚举属性(可迭代的属性或者可枚举属性设置为true的属性<a class="ae ls" href="https://www.geeksforgeeks.org/what-does-enumerable-property-mean-in-javascript/" rel="noopener ugc nofollow" target="_blank">T3】检查这个！！ </a>)从源对象到目标对象。还有，对象。assign()方法返回新形成的目标对象。</p><p id="d875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看以下示例:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/40b15e5707975ba0f21d79b1ff6f5f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWqTCDfMAI6Yps1yHlhnyg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Run in Fiddle: <a class="ae ls" href="https://jsfiddle.net/ShaikWasef/e93cm5xu/5/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/ShaikWasef/e93cm5xu/5/</a></figcaption></figure><p id="e0e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的例子说明了。assign()在复制目标和源的属性值后返回目标对象。returnedTarget和Target是相同的对象，并且拥有对相同键-值对的引用。但是，assign不会通过引用复制属性，因此更改目标属性不会更改源的属性，如下所示。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/d3103482d07725baff8e99f49c5aef6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmfRDbz0LpvWHT3Ou-A26g.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Run in Fiddle: <a class="ae ls" href="https://jsfiddle.net/ShaikWasef/4xsden5w/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/ShaikWasef/4xsden5w/</a></figcaption></figure><p id="010a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，如果在Object执行期间源和目标的键匹配，源的属性将被覆盖。如上面的例子所示。</p><p id="d149" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:为了创建源对象的新副本，请使用以下语法:<em class="lt"> Object.assign({}，source) </em></p><p id="ca1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">object . create()</strong>:object . create()用于以现有对象为原型创建新对象。这意味着返回的对象除了继承源对象本身的属性之外，还继承与源对象链接的所有原型的属性。因此，目标对象不仅仅是源对象的副本。查看下面的例子</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/60d2da6747071dad6e36bc5c485c9c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4RhrDmszZm4zylkgd75qg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Run in Fiddle: <a class="ae ls" href="https://jsfiddle.net/ShaikWasef/kcg08ypn/27/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/ShaikWasef/kcg08ypn/27/</a></figcaption></figure><h1 id="7d79" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.事实真相</h1><p id="d07b" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">考虑以下使用Object的代码片段。assign()创建对象的副本并猜测输出。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mg"><img src="../Images/a9e0bd245262220fa133affd9955b099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNrtD_52Do1-C_nEazcbFg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Run in Fiddle : <a class="ae ls" href="https://jsfiddle.net/ShaikWasef/yz084oje/8/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/ShaikWasef/yz084oje/8/</a></figcaption></figure><p id="711d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经运行了小提琴，你一定已经观察到当targetObj.c.d改变时obj值也改变了。</p><p id="60d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为对象。assign()只创建源对象的浅表副本。如果源值包含对某个对象的引用，则复制对该对象的引用。因此obj。c.d也改成了‘变’。要创建深层副本，您必须编写一个单独的代码，可以在这里找到该代码的引用<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> MDN DOCS </a>。</p><p id="6e38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在考虑下面使用Object的代码片段。create()创建一个具有原型继承的新对象。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/946f2b739088b1633cf00ed522ba1e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUynHqlXsw4WTI6qcYIoNQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Run in Fiddle: <a class="ae ls" href="https://jsfiddle.net/ShaikWasef/6j17cmgp/1/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/ShaikWasef/6j17cmgp/1/</a></figcaption></figure><p id="9d35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码片段产生了与前者相同的输出。</p><p id="5949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因对象。create()这样做是因为原型链接的工作方式。JS原型链接中有两个规则(没有正式定义，但为了更好地理解，已经声明)。</p><p id="0e7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lt">规则1: </em> <strong class="jm io">从子对象中读取属性:<br/> </strong>当你试图从子对象中访问一个属性时，Javascript将搜索整个原型链，直到它设法找到该属性，否则如果没有找到则返回undefined。</p><p id="ea6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lt">规则2: </em> <strong class="jm io">在子对象中写属性:<br/> </strong>它会先尝试定位你的目标属性所属的对象，然后直接在那个对象上设置那个属性。</p><p id="439b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果您更改了targetObj的属性“a ”,那么JS将直接设置targetObj的属性。但是，如果您更改属性“d ”,它将为targetObj和Obj设置值“d ”,因为“d”是键“c”的对象值的属性，因此为targetObj和Obj设置值“d ”,因为属性“c”属于它们两者，并且它<strong class="jm io">是属性“d”的目标对象</strong>。</p><p id="1551" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎评论和分享您的知识，帮助JS社区成长。</p><p id="2ca3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lt">更多内容请看</em><a class="ae ls" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>