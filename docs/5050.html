<html>
<head>
<title>How to Build a Template Engine using Template Literals in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用模板文字构建模板引擎</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-template-engine-using-template-literals-in-javascript-9ace13ae4514?source=collection_archive---------3-----------------------#2021-10-13">https://javascript.plainenglish.io/how-to-build-a-template-engine-using-template-literals-in-javascript-9ace13ae4514?source=collection_archive---------3-----------------------#2021-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/434b5b80f19e9dcb615ac2dcfe21a30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q_OA5-cnsX7s193D"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@joannakosinska?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joanna Kosinska</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="667f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能见过像<a class="ae jd" href="https://mustache.github.io/" rel="noopener ugc nofollow" target="_blank">小胡子</a>、<a class="ae jd" href="https://ejs.co/" rel="noopener ugc nofollow" target="_blank">ejs.co</a>这样的模板引擎。这些库用起来非常酷。然而，对于简单的用例，您可能不想包含这些库。可以增加制作app的代码量。JavaScript ES6或ES2015引入了模板字符串或模板文字的概念。使用模板字符串，您可以构建一个模板引擎。</p><h2 id="f058" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是模板字符串？</h2><p id="1e89" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">模板字符串是指允许创建多行字符串的分隔符。它还可以包括表达式。模板字符串可以使用反斜杠(``)来定义。</p><p id="91ec" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">样本:</strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c8d3" class="lb lc jg me b gy mi mj l mk ml">const userName = "Deepak";<br/>let htmlStr = `&lt;div&gt;<br/>  &lt;h1&gt;This is Template String&lt;/h1&gt;<br/>  &lt;p&gt;My name is ${userName};<br/>&lt;/div&gt;`;</span><span id="be96" class="lb lc jg me b gy mm mj l mk ml">console.log(htmlStr);<br/>/* <br/>&lt;div&gt;<br/>  deepak is list is<br/>  &lt;h1&gt;30&lt;/h1&gt;<br/>  yrs old<br/>&lt;/div&gt;<br/>*/</span></pre><p id="16bf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的示例中，<code class="fe mn mo mp me b"><strong class="kf jh">htmlStr</strong></code>是一个存储使用模板字符串计算的字符串的变量。用户名将被变量<code class="fe mn mo mp me b">userName.</code>的值替换</p><p id="6071" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用占位符<code class="fe mn mo mp me b"><strong class="kf jh">${}</strong></code>，你可以分配任何表达式。模板字符串将尝试计算表达式，并将其分配给占位符位置。</p><p id="f0aa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">样本:</strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e0d4" class="lb lc jg me b gy mi mj l mk ml">const a = 10;<br/>const b = 5;<br/>console.log(`The value of exp (a+b)*10= ${(a + b) * 10} `);</span><span id="34b3" class="lb lc jg me b gy mm mj l mk ml">//The value of exp (a+b)*10= 150</span></pre><h2 id="4169" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">标记模板</h2><p id="1de9" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">模板字符串还提供了标记模板的强大功能。您可以将任何函数用作标记函数。标记函数可以解析模板字符串。第一个参数是经过解析的字符串数组，其余参数是模板字符串中使用的表达式。让我们创建一个标记函数。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4641" class="lb lc jg me b gy mi mj l mk ml">const html = (strings, ...args) =&gt; {<br/>  console.log(strings);<br/>  console.log(args);<br/>};</span><span id="cf23" class="lb lc jg me b gy mm mj l mk ml">// [ '{name:', ', age: ', ',\ngetName:', '}' ]<br/>// [ 'Deepak', 30, [Function: getName] ]</span><span id="2979" class="lb lc jg me b gy mm mj l mk ml">const user = {<br/>  name: "Deepak",<br/>  age: 30,<br/>  getName() {<br/>    return this.name;<br/>  },<br/>};</span><span id="95e4" class="lb lc jg me b gy mm mj l mk ml">const htmlString = html`{name:${user.name}, age: ${user.age}, getName:${user.getName}}`;</span></pre><p id="c2f0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你运行上面的例子，你会看到一个包含<code class="fe mn mo mp me b">[ ‘{name:’, ‘, age: ‘, ‘,getName:’, ‘}’ ] </code>的字符串数组和一个所有传递的表达式<code class="fe mn mo mp me b">[ ‘Deepak’, 30, [Function: getName] ].</code>的数组。正如你注意到的，你也可以传递一个函数作为表达式。</p><p id="d570" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> CSS构建器</strong></p><p id="846e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你曾经做过React，你可能会熟悉<a class="ae jd" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">样式化组件</strong> </a>。S <strong class="kf jh"> tyled-components </strong>提供了许多实用方法来创建React组件。<strong class="kf jh">样式化组件</strong>最大的USP是<strong class="kf jh"> </strong>标记模板函数的使用。<code class="fe mn mo mp me b"><strong class="kf jh">css</strong></code>是效用函数之一。使用这个函数，你可以创建复杂的CSS字符串。让我们试着模仿这种行为。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="53f8" class="lb lc jg me b gy mi mj l mk ml">// Theme token varibale</span><span id="068a" class="lb lc jg me b gy mm mj l mk ml">const theme = {<br/>  color: "#dedede",<br/>  font_size: "20px",<br/>};</span><span id="d0e9" class="lb lc jg me b gy mm mj l mk ml">/**<br/> * css: tagged function, parse the string template <br/> * and exec all functions theme as parameter.<br/> *<br/> * <a class="ae jd" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} strings<br/> * <a class="ae jd" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a>  {...any} fns<br/> * <a class="ae jd" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a><br/> */<br/>const css = (strings, ...fns) =&gt; {<br/>  let str = strings[0];<br/>  for (let i = 0; i &lt; fns.length; i++) {<br/>    if (typeof fns[i] === "function") {<br/>      str += fns[i](theme);<br/>    } else {<br/>      str += fns[i];<br/>    }<br/>    str += strings[i + 1];<br/>  }<br/>  return str;<br/>};</span><span id="e86e" class="lb lc jg me b gy mm mj l mk ml">const cssStr = css`<br/>   {<br/>    color: ${(p) =&gt; p.color};<br/>    font-size: ${(p) =&gt; p.font_size};<br/>  }<br/>`;</span><span id="a077" class="lb lc jg me b gy mm mj l mk ml">console.log(cssStr);</span><span id="0597" class="lb lc jg me b gy mm mj l mk ml">// { color:#dedede; font-size:20px }</span></pre><p id="01ad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">解释</strong>:</p><p id="b3ab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们已经创建了一个<strong class="kf jh">主题</strong>变量。这个主题变量存储所有的主题标记。<strong class="kf jh"> css </strong>函数将解析模板字符串，并将字符串与表达式的值连接起来。它执行所有以主题变量作为参数的函数表达式。</p><p id="7311" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，既然我们对模板字符串和标记函数有了一个很好的想法，让我们试着构建一个复杂的HTML引擎。</p><p id="6045" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">要求</strong>:</p><p id="78ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTML函数的简单要求是获取一个模板字符串并对对象建模，解析它并返回HTML字符串。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7fd4" class="lb lc jg me b gy mi mj l mk ml">function html(string template, object model) <br/> -&gt; (string html)</span><span id="93e8" class="lb lc jg me b gy mm mj l mk ml">html(<br/>  `&lt;div&gt;${"person.name"} is &lt;strong&gt;${(m) =&gt; m.person.age}&lt;/strong&gt;yrs old&lt;/div&gt;`,</span><span id="d024" class="lb lc jg me b gy mm mj l mk ml">  { person: { name: "deepak", age: 30 } }<br/>);</span><span id="bae2" class="lb lc jg me b gy mm mj l mk ml">{/* &lt;div&gt;deepak is &lt;strong&gt;30&lt;/strong&gt;yrs old&lt;/div&gt; */}</span></pre><p id="0315" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了构建这个HTML解析器，我们需要一个简单的util函数<code class="fe mn mo mp me b">safeEval</code>。这个<strong class="kf jh"> safeEval </strong>函数将帮助从基于键的对象中获取嵌套值。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fed9" class="lb lc jg me b gy mi mj l mk ml">const evalReg = /(\.)|(\[(\d)\])/;<br/>const safeEval = (key, obj, def) =&gt; {<br/>  let lastKey;<br/>  let match;<br/>  do {<br/>    if (lastKey) {<br/>      if (match &amp;&amp; match[2]) {<br/>        obj = obj[lastKey][match[3]];<br/>      } else {<br/>        obj = obj[lastKey];<br/>      }<br/>    }<br/>    match = evalReg.exec(key);<br/>    if (!match) {<br/>      lastKey = key;<br/>      break;<br/>    } else {<br/>      lastKey = key.substr(0, match.index);<br/>      key = key.slice(!match[3] ? match.index + 1 : match.index + 3);<br/>    }<br/>  } while (match);<br/>  if (lastKey) {<br/>    obj = obj[lastKey];<br/>  }<br/>  return obj || def;<br/>};</span><span id="d48c" class="lb lc jg me b gy mm mj l mk ml">const model = { person: { name: "deepak", age: 30 } }<br/>console.log(safeEval("person.name", model));<br/>console.log(safeEval("person.age", model));</span><span id="ebe3" class="lb lc jg me b gy mm mj l mk ml">// deepak<br/>// 30</span></pre><p id="c556" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了<code class="fe mn mo mp me b">safeEval</code>函数，剩下的逻辑就非常简单，与<code class="fe mn mo mp me b">css</code>标记函数相同。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3614" class="lb lc jg me b gy mi mj l mk ml">/**<br/> * html: tagged function returns a closure function. The closure function parse the template string and bind with model data<br/> * <br/> * <a class="ae jd" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} strings <br/> * <a class="ae jd" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a>  {...any} fns <br/> * <a class="ae jd" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> <br/> */<br/>function html(strings, ...fns) {<br/>  return (model) =&gt; {<br/>    let str = strings[0];<br/>    for (let i = 0; i &lt; fns.length; i++) {<br/>      const evl = fns[i];<br/>      if (typeof evl === "string") str += safeEval(evl, model);<br/>      else if (typeof evl === "function") str += evl(model);<br/>      else res += evl;<br/>      str += strings[i + 1];<br/>    }<br/>    return str;<br/>  };<br/>}</span><span id="28bb" class="lb lc jg me b gy mm mj l mk ml">let template = html`&lt;div&gt;${"person.name"} is &lt;strong&gt;${(m) =&gt; m.person.age}&lt;/strong&gt;yrs old&lt;/div&gt;`;</span><span id="05db" class="lb lc jg me b gy mm mj l mk ml">console.log(template({ person: { name: "deepak", age: 30 } }));</span><span id="2e0e" class="lb lc jg me b gy mm mj l mk ml">// &lt;div&gt;deepak is &lt;strong&gt;30&lt;/strong&gt;yrs old&lt;/div&gt;</span></pre><p id="30b8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Tada！我们最简单的HTML模板引擎已经可以使用了。您可以根据自己的需要定制和增强行为。</p><p id="161f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">一个复杂的例子:</strong>使用HTML模板引擎构建一个秒表。</p><figure class="lz ma mb mc gt is"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c042" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">参考:</strong><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Template _ literals</a></p><p id="7ea6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ms">更多内容看</em><strong class="kf jh"><em class="ms"/></strong><a class="ae jd" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh"><em class="ms">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>