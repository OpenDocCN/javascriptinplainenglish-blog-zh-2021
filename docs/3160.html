<html>
<head>
<title>Closures in JavaScript — JS Interview Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript — JS访谈系列中的闭包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/closures-in-javascript-js-interview-series-c93af277bfac?source=collection_archive---------1-----------------------#2021-06-27">https://javascript.plainenglish.io/closures-in-javascript-js-interview-series-c93af277bfac?source=collection_archive---------1-----------------------#2021-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a772" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript中的闭包被认为是最受欢迎的概念之一，也是JavaScript访谈中经常出现的话题。在本文中，我们将探讨JavaScript中的闭包以及它们是如何工作的。</p><p id="86ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">按照Kyle Simpson的说法，闭包的定义如下:<em class="ki">“闭包是一种JavaScript机制，因为它使得函数倾向于记住并访问其作用域之外描述的变量，即使函数本身是在不同的作用域中执行的。”</em></p><p id="eef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我稍微理解一下。现在我们将通过一个例子来理解这个定义。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/aae1c327248fc239fa440c9652164a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2mLR03Q1TQGaUK3SFCESw.png"/></div></div></figure><p id="44ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b"><em class="ki">foo()</em></code>函数返回<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>函数。当执行<code class="fe kv kw kx ky b"><em class="ki">foo()</em></code>函数时，它返回存储在<em class="ki">校验</em>变量中的<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>函数。当执行<code class="fe kv kw kx ky b"><em class="ki">check()</em></code>函数时，这又调用了<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>函数，我们看到“javascript”被打印出来。</p><p id="aacb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为函数<em class="ki"> </em> <code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>用变量<em class="ki">名</em>形成了一个闭包，当函数<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>被执行时，JavaScript会试图在<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>函数的作用域内找到在<code class="fe kv kw kx ky b"><em class="ki">console.log(name)</em></code>中定义的变量<em class="ki">名</em>。一旦JavaScript在其作用域内找不到变量<em class="ki">名称</em>，它将尝试在其直接外部作用域内搜索变量<em class="ki">名称</em>，以此类推。</p><p id="8089" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此之后，函数<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code> <em class="ki"> </em>将记住变量<em class="ki">的名称</em>和它的值，即使它是在不同的作用域(上面例子中的全局作用域)中执行的。</p><p id="7e4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们用另一个例子来验证这一点。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kz"><img src="../Images/ed7929cc20e592245a320e221f4f7f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW4jDDTqp6CuX657lQ5rxg.png"/></div></div></figure><p id="9868" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，变量<em class="ki">名称</em>在函数<code class="fe kv kw kx ky b"><em class="ki">foo()</em></code>的作用域中找不到，因此JavaScript从更高的作用域中选择它。</p><p id="1bac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们更进一步。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi la"><img src="../Images/6af0b531fb5d959e6daffb8b9a4eb667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXgs6jFgkk6meTlEsju29w.png"/></div></div></figure><p id="718a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，函数<code class="fe kv kw kx ky b"><em class="ki">foo()</em></code> <em class="ki"> </em>与变量<em class="ki"> count </em>形成一个闭包，并倾向于记住它的值。因此，对于函数<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>的每次调用，我们得到变量<em class="ki">计数</em>的一个增量值。</p><p id="45b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们尝试另一个结合了上述两个概念的例子。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi la"><img src="../Images/66f47da8d441970322f19f7c9524527c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHhq624mSVqAzaMySxEoVQ.png"/></div></div></figure><p id="1f02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显然，函数<code class="fe kv kw kx ky b"><em class="ki">bar()</em></code>与变量<em class="ki">计数</em>形成了一个闭包，并且倾向于记住它。因此，在最后一行，我们看到<code class="fe kv kw kx ky b"><em class="ki">check()</em></code> <em class="ki"> </em>函数打印了<code class="fe kv kw kx ky b">‘7’</code>。</p><h2 id="f6ae" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated"><strong class="ak">闭包的优缺点</strong></h2><p id="e542" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><strong class="jm io">优点</strong></p><ol class=""><li id="392d" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">闭包有助于数据封装，也就是说，使用闭包，您可以将数据存储在一个单独的范围内，并且只在必要的时候共享它。</li><li id="3b8c" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">现代JavaScript库(如React)严重依赖闭包来呈现状态或属性变化时的组件。</li></ol><p id="e42b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">缺点</strong></p><ol class=""><li id="8985" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">闭包会消耗大量内存空间，因为函数需要将变量的值存储在内存中，即使变量的函数本身不会在代码中多次使用。</li></ol><p id="6fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读。欢迎在评论框中留下任何评论和建议。</p><p id="f618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae mn" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>