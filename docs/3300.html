<html>
<head>
<title>Everything You Need to Know About Linked Lists: Data Structure with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于链表你需要知道的一切:JavaScript的数据结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-linked-lists-data-structure-with-javascript-4aee994965b0?source=collection_archive---------17-----------------------#2021-07-05">https://javascript.plainenglish.io/everything-you-need-to-know-about-linked-lists-data-structure-with-javascript-4aee994965b0?source=collection_archive---------17-----------------------#2021-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e56b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是链表，如何用JavaScript实现一个基本的链表？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/03287f8ec227c05bb015c17dbae6d56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8jUSRkWMYvVLmzDF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@tomasjolmes" rel="noopener ugc nofollow" target="_blank">Tomas Anton Escobar</a> at <a class="ae kv" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kw kx ky"><p id="7e38" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">他的帖子最初发表在:<br/><a class="ae kv" href="https://raulmelo.dev/blog/data-structure-with-javascript-linked-list" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">https://raulmelo . dev/blog/data-structure-with-JavaScript-linked-list</strong></a></p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="fb08" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">你好，德夫斯。</p><p id="c3cb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">今天，我想深入一个非常具体的数据结构，来保存一个叫做链表的集合。</p><p id="0e3a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">首先，我将简要解释数组问题以及链表是如何解决这些问题的，然后我们将讨论如何用JavaScript实现它。</p><p id="41eb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">我已经可以说，作为一个JavaScript开发人员，我没有看到大的用例，因为我们有一个相当不错的本地处理集合的方法。然而，作为一名软件工程师，我认为对它有一个基本的了解是非常重要的，以备将来需要。</p><p id="3b53" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">请记住:</p><blockquote class="kw kx ky"><p id="e57c" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">知识就是力量，永远不会无用。</p></blockquote><h1 id="2cb9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">关于列表</h1><p id="4f49" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">数组是存储数据集合最有效的方式之一，比如Instagram上的朋友列表。</p><p id="34df" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">在JavaScript中，当我们想要创建一个列表时，我们所需要的只是一个非常简单的开/闭方括号(<code class="fe nd ne nf ng b">[]</code>)并把你想要的元素推送到里面。</p><p id="6e1b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">然而，在其他一些语言中，尤其是那些关注性能的语言中，方法是不同的。在那里，如果你需要一个列表，你必须指定你的列表的大小，这有时是一个问题，因为我们经常处理动态数据。</p><p id="fffb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">这种方法是有意义的。如果你只有很少的内存，并且需要写一些代码来编译一种非常低级的机器语言(比如二进制)，例如，如果你说你的列表将只有3个元素，编译器可以说:</p><blockquote class="kw kx ky"><p id="2b07" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">嘿，这个列表只能分配几个字节，因为我们事先知道它最多只包含3个元素。</p></blockquote><p id="f1c7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">此外，如果您想在某个特定位置插入或删除元素，您需要完全移动列表，这些操作可能会很繁琐且代价高昂。</p><p id="5f23" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">在JavaScript中，我们对此没有太大的困扰，因为语言就是以这种方式设计的，而且我们也有原生数组方法(我认为是非常优化的)，可以删除或添加元素并重新生成列表，就像方法<code class="fe nd ne nf ng b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">Array.prototype.splice()</a></code>。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4888" class="nl mh iq ng b gy nm nn l no np">const months = ['Jan', 'March', 'April', 'June'];</span><span id="603b" class="nl mh iq ng b gy nq nn l no np">// insert exactly in the index one (1, 0) the string `Feb`<br/>months.splice(1, 0, 'Feb');</span><span id="7d5b" class="nl mh iq ng b gy nq nn l no np">console.log(months); // Array ["Jan", "Feb", "March", "April", "June"]</span><span id="771f" class="nl mh iq ng b gy nq nn l no np">// removes everything from the index 3 til the last el ("April" and "June")<br/>months.splice(3, months.length)</span><span id="746a" class="nl mh iq ng b gy nq nn l no np">console.log(months); // ["Jan", "Feb", "March"]</span></pre><h1 id="23b8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">链表:概念</h1><p id="c6af" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">链表实现试图解决我们可以在一个列表中存储的元素的最大数量，以及如何通过将使用的数据结构从数组改为简单的链接对象(节点)来轻松地浏览列表。</p><p id="5c49" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">每个节点都有两个属性:</p><ul class=""><li id="77fa" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">element</code>:我们希望存储在列表中的数据；</li><li id="4348" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">next</code>:到另一个节点的链接或空值(不存在的下一个节点)。</li></ul><p id="113c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">也许最好的视觉化方法是想象一列火车。</p><p id="9d51" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">在一列火车上，我们总是有一个“头”，从那里它连接到第一辆“货车”，然后第二辆“货车”连接到第一辆，直到火车的尾部。</p><p id="6d9e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">例如，如果我们想要移除一个有缺陷的货车，我们需要做的就是找到这个货车，将前一个货车链接到下一个货车，然后就完成了。</p><p id="0b4e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">当我们想要添加新的“旅行车”时，原理是相同的。我们所需要的是找到我们想要添加它的地方，将前面和后面的货车连接到新的货车上。</p><p id="e330" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">换句话说，链表就是创建和修改节点之间的连接。</p><p id="29ba" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">在下一节中，我们将一步一步地实现所有这些添加和删除，您会发现这是一个相对简单的概念。</p><h1 id="34fd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">链表:实现</h1><p id="2232" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">在任何实现之前，让我们看一下这种列表需要的API:</p><ul class=""><li id="14ce" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.append(element)</code> -用于向列表末尾追加新元素的方法；</li><li id="e8db" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.indexOf(element)</code> -用于知道我们的元素被添加到索引中的什么位置的方法；</li><li id="1624" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.insertAt(position, element)</code> -用于在特定位置添加元素的方法；</li><li id="18b1" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.remove(element)</code> -用于从列表中删除元素的方法；</li><li id="8dd8" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.removeAt(position)</code> -用于移除某个特定位置的元素的方法；</li><li id="e6fd" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">.toString()</code> -用于概览我们的列表的方法。</li></ul><p id="3be4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">再一次，代替使用JS类/原型，我将使用我最喜欢的模式工厂，已经为我们的API准备了一些占位符:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="e3d5" class="nl mh iq ng b gy nm nn l no np">function LinkedListFactory() {<br/>  return {<br/>    append,<br/>    indexOf,<br/>    insertAt,<br/>    remove,<br/>    removeAt,<br/>    toString,<br/>  };</span><span id="69ef" class="nl mh iq ng b gy nq nn l no np">  function append(element) {}</span><span id="e0c8" class="nl mh iq ng b gy nq nn l no np">  function indexOf(element) {}</span><span id="7bdf" class="nl mh iq ng b gy nq nn l no np">  function insertAt(position, element) {}</span><span id="6751" class="nl mh iq ng b gy nq nn l no np">  function remove(element) {}</span><span id="01e9" class="nl mh iq ng b gy nq nn l no np">  function removeAt(position) {}</span><span id="5304" class="nl mh iq ng b gy nq nn l no np">  function toString() {}<br/>}</span></pre><h1 id="4fc0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">“全局”变量</h1><p id="7ddd" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">在实现这些方法之前，我们需要创建两个几乎在所有方法中都要用到的变量:</p><ul class=""><li id="2b0e" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">head</code> -变量保存我们的第一个元素，一切都将从这里开始。它将从值<code class="fe nd ne nf ng b">null</code>开始；</li><li id="3d7d" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><code class="fe nd ne nf ng b">length</code> -一个容易保持列表大小的控制变量。它将以值<code class="fe nd ne nf ng b">0</code>开始。</li></ul><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="7a26" class="nl mh iq ng b gy nm nn l no np">function LinkedListFactory() {<br/>  let head = null;<br/>  let length = 0;</span><span id="835b" class="nl mh iq ng b gy nq nn l no np">  return {<br/>    append,<br/>    indexOf,<br/>    insertAt,<br/>    remove,<br/>    removeAt,<br/>    toString,<br/>  };</span><span id="6a83" class="nl mh iq ng b gy nq nn l no np">  function append(element) {}</span><span id="6508" class="nl mh iq ng b gy nq nn l no np">  function indexOf(element) {}</span><span id="e910" class="nl mh iq ng b gy nq nn l no np">  function insertAt(position, element) {}</span><span id="a87b" class="nl mh iq ng b gy nq nn l no np">  function remove(element) {}</span><span id="0433" class="nl mh iq ng b gy nq nn l no np">  function removeAt(position) {}</span><span id="27b4" class="nl mh iq ng b gy nq nn l no np">  function toString() {}<br/>}</span></pre><h1 id="9335" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。追加(元素)</h1><p id="920a" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">在<code class="fe nd ne nf ng b">append</code>方法中，我们首先需要创建一个我们称之为“节点”的内部基本结构。</p><p id="65f2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">一个节点是一个简单的对象，它将保存我们添加到列表中的元素和下一个元素(链接本身)。</p><p id="026b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">由于append总是将一个元素添加到列表的末尾，<code class="fe nd ne nf ng b">next</code>将总是<code class="fe nd ne nf ng b">null</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="6a55" class="nl mh iq ng b gy nm nn l no np">function append(element) {<br/>  const node = {<br/>    element,<br/>    next: null<br/>  }<br/>}</span></pre><p id="d68f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">第一种情况是当我们的列表为空时，或者当<code class="fe nd ne nf ng b">head</code>为<code class="fe nd ne nf ng b">null</code>时。在这种情况下，我们将把新创建的节点分配给头部:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="7db2" class="nl mh iq ng b gy nm nn l no np">function append(element) {<br/>  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="0f2b" class="nl mh iq ng b gy nq nn l no np">  if (head === null) {<br/>    head = node;<br/>  }<br/>}</span></pre><p id="417d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">现在，我们必须考虑其他情况(如果不是头或倒数第二个节点的情况)。</p><p id="1465" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">因为我们想在列表末尾添加一个元素，所以我们必须遍历所有节点，直到<code class="fe nd ne nf ng b">.next</code>等于<code class="fe nd ne nf ng b">null</code>。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9f1b" class="nl mh iq ng b gy nm nn l no np">function append(element) {<br/>  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="5f27" class="nl mh iq ng b gy nq nn l no np">  if (head === null) {<br/>    head = node;<br/>  } else {<br/>    let currentNode = head;</span><span id="a3a5" class="nl mh iq ng b gy nq nn l no np">    while (currentNode.next !== null) {<br/>      currentNode = currentNode.next;<br/>    }<br/>  }<br/>}</span></pre><p id="1710" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">既然我们遇到了最后一个元素，我们需要做的就是将这个元素的<code class="fe nd ne nf ng b">.next</code>属性链接到我们新创建的节点:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4451" class="nl mh iq ng b gy nm nn l no np">function append(element) {<br/>  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="80c7" class="nl mh iq ng b gy nq nn l no np">  if (head === null) {<br/>    head = node;<br/>  } else {<br/>    let currentNode = head;</span><span id="cceb" class="nl mh iq ng b gy nq nn l no np">    while (currentNode.next !== null) {<br/>      currentNode = currentNode.next;<br/>    }</span><span id="497b" class="nl mh iq ng b gy nq nn l no np">    currentNode.next = node;<br/>  }<br/>}</span></pre><p id="2d15" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">最后，对于这两种情况(有没有头)，我们都需要将列表大小增加1(<code class="fe nd ne nf ng b">length</code>)，所以在条件之外是很重要的</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="cc74" class="nl mh iq ng b gy nm nn l no np">function append(element) {<br/>  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="f024" class="nl mh iq ng b gy nq nn l no np">  if (head === null) {<br/>    head = node;<br/>  } else {<br/>    let currentNode = head;</span><span id="b10d" class="nl mh iq ng b gy nq nn l no np">    while (currentNode.next !== null) {<br/>      currentNode = currentNode.next;<br/>    }</span><span id="8cd1" class="nl mh iq ng b gy nq nn l no np">    currentNode.next = node;<br/>  }</span><span id="f118" class="nl mh iq ng b gy nq nn l no np">  length++;<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/195c4283c908b6c7f88c69134fc672af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wvli4sW1oxOYznpQ.png"/></div></div></figure><h1 id="b96e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。元素索引</h1><p id="795e" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">这个方法的目的是找到给定元素在列表中的位置。</p><p id="9f88" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">首先，我们需要两个控制器变量:<code class="fe nd ne nf ng b">nodeIndex</code>和<code class="fe nd ne nf ng b">currentElement</code>。第一个将被用作返回值，也是为了知道我们在迭代中的位置，第二个用于比较元素是否是我们正在寻找的元素:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9b0b" class="nl mh iq ng b gy nm nn l no np">function indexOf(element) {<br/>  let nodeIndex = 0;<br/>  let currentNode = head;<br/>}</span></pre><p id="ab40" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">还记得我跟你说过<code class="fe nd ne nf ng b">head</code>可能是<code class="fe nd ne nf ng b">null</code>或者最后一个节点的<code class="fe nd ne nf ng b">.next</code>会是<code class="fe nd ne nf ng b">null</code>吗？我们将使用这个条件来遍历所有节点。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="c4a5" class="nl mh iq ng b gy nm nn l no np">function indexOf(element) {<br/>  let nodeIndex = 0;<br/>  let currentNode = head;</span><span id="1949" class="nl mh iq ng b gy nq nn l no np">  while (currentNode) {<br/>    if (element === currentNode.element) {<br/>      return nodeIndex;<br/>    }</span><span id="ae9c" class="nl mh iq ng b gy nq nn l no np">    nodeIndex++;</span><span id="4167" class="nl mh iq ng b gy nq nn l no np">    currentNode = currentNode.next;<br/>  }<br/>}</span></pre><p id="2441" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">现在，直到<code class="fe nd ne nf ng b">currentNode</code>不是<code class="fe nd ne nf ng b">null</code>，我们将首先检查元素是否是我们正在寻找的元素。如果是，我们可以直接返回<code class="fe nd ne nf ng b">nodeIndex</code>的值。</p><p id="3414" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">如果不是，那么我们需要将1增加到<code class="fe nd ne nf ng b">nodeIndex</code>并将<code class="fe nd ne nf ng b">currentNode</code>分配给<code class="fe nd ne nf ng b">currentNode.next</code>，或者换句话说，简单地移动到下一个节点，再次运行比较。</p><p id="78b3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">最后，如果我们找不到用户正在寻找的元素，我们必须给出一个我们找不到的指示。</p><p id="e4de" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">传统上，对于这样的情况，这些方法返回<code class="fe nd ne nf ng b">-1</code>，但是没有什么可以阻止我们返回其他值，例如<code class="fe nd ne nf ng b">null</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4306" class="nl mh iq ng b gy nm nn l no np">function indexOf(element) {<br/>  let nodeIndex = 0;<br/>  let currentNode = head;</span><span id="a94f" class="nl mh iq ng b gy nq nn l no np">  while (currentNode) {<br/>    if (element === currentNode.element) {<br/>      return nodeIndex;<br/>    }</span><span id="1f17" class="nl mh iq ng b gy nq nn l no np">    nodeIndex++;</span><span id="de94" class="nl mh iq ng b gy nq nn l no np">    currentNode = currentNode.next;<br/>  }</span><span id="4459" class="nl mh iq ng b gy nq nn l no np">  return -1<br/>}</span></pre><h1 id="32c3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。insertAt(位置，元素)</h1><p id="9e6d" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">在这个操作中，我们将做一个与<code class="fe nd ne nf ng b">indexOf</code>(控制索引)相似的操作，另外我们必须调整节点连接。</p><p id="ec37" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">想象以下场景:我们的列表中有4个链接的节点，我们想在位置2(第二个位置，因为它是基于0的索引)插入一个新元素。</p><p id="e3b8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">我们基本上需要:</p><ol class=""><li id="b9ec" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv og nx ny nz bi translated">遍历节点；</li><li id="39c8" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">找出谁在位置2；</li><li id="84b5" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">让这个节点<code class="fe nd ne nf ng b">.next</code>指向我们正在插入的元素</li><li id="6d9f" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">让我们的新节点<code class="fe nd ne nf ng b">.next</code>指向我们刚刚找到的元素<code class="fe nd ne nf ng b">.next</code></li></ol><p id="2185" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">这可能看起来有点混乱，但是我将一步一步地引导您实现它。</p><p id="f8da" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">我们需要做的第一个验证是用户请求添加的职位是否存在于我们的列表中。如果我们的列表中只有1个元素，我们需要确保如果我们不在位置4添加元素:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="3776" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return false<br/>  }<br/>}</span></pre><blockquote class="kw kx ky"><p id="1d15" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="iq">提示:保存此逻辑的变量只是描述(英语中)条件的一种语义方式。</em></p></blockquote><p id="0b10" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">像在其他方法中一样，我们将需要迭代我们的列表，看看我们需要在哪里添加这个元素。这意味着我们需要创建一个控制器变量和我们的节点:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="e27a" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return false<br/>  }<br/>  <br/>  // Our brand new node<br/>  const node = {<br/>    element,<br/>    next: null<br/>  }<br/>  <br/>  // Controller to iterate over the list<br/>  let currentNode = head;<br/>}</span></pre><p id="e771" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">我们这里的第一个例子是用户想在第一个位置(head)添加一个元素。我们所要做的就是说新节点<code class="fe nd ne nf ng b">.next</code>将是当前元素，而头部现在将是新节点:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="5876" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="1702" class="nl mh iq ng b gy nq nn l no np">  if (!isPositionInTheRange) {<br/>    return false;<br/>  }</span><span id="2b46" class="nl mh iq ng b gy nq nn l no np">  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="4b40" class="nl mh iq ng b gy nq nn l no np">  let currentNode = head;</span><span id="8f59" class="nl mh iq ng b gy nq nn l no np">  const isHeadPosition = position === 0;</span><span id="d3a8" class="nl mh iq ng b gy nq nn l no np">  if (isHeadPosition) {<br/>    // Assign currentNode (head) to `node.next`<br/>    node.next = currentNode;<br/>    // Replace the current head with this node<br/>    head = node;<br/>  } else {<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/fd5aaf9a4bbd8772559665f1f1393a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3qmE-4gl1ohHcOmi.png"/></div></div></figure><p id="44b6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">现在我们需要处理位置在头部之后的情况。</p><p id="b751" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">首先，我们需要两个控制器变量，<code class="fe nd ne nf ng b">index</code>(基于此进行迭代)和<code class="fe nd ne nf ng b">previousNode</code>(找到位置后重新创建链接):</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="ba43" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="8129" class="nl mh iq ng b gy nq nn l no np">  if (!isPositionInTheRange) {<br/>    return false;<br/>  }</span><span id="fe0f" class="nl mh iq ng b gy nq nn l no np">  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="9313" class="nl mh iq ng b gy nq nn l no np">  let currentNode = head;</span><span id="6c63" class="nl mh iq ng b gy nq nn l no np">  const isHeadPosition = position === 0;</span><span id="b4c7" class="nl mh iq ng b gy nq nn l no np">  if (isHeadPosition) {    <br/>    node.next = currentNode;<br/>    head = node;<br/>  } else {<br/>    let previousNode = null;<br/>    let index = 0;<br/>  }<br/>}</span></pre><p id="07c9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">然后，我们将使用<code class="fe nd ne nf ng b">index</code>进行迭代。当指数小于期望位置时，我们将更新我们的控制器<code class="fe nd ne nf ng b">previousNode</code>和<code class="fe nd ne nf ng b">currentNode</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="359b" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="d59e" class="nl mh iq ng b gy nq nn l no np">  if (!isPositionInTheRange) {<br/>    return false;<br/>  }</span><span id="8053" class="nl mh iq ng b gy nq nn l no np">  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="6da7" class="nl mh iq ng b gy nq nn l no np">  let currentNode = head;</span><span id="4d1c" class="nl mh iq ng b gy nq nn l no np">  const isHeadPosition = position === 0;</span><span id="541b" class="nl mh iq ng b gy nq nn l no np">  if (isHeadPosition) {    <br/>    node.next = currentNode;<br/>    head = node;<br/>  } else {<br/>    let previousNode = null;<br/>    let index = 0;<br/>    <br/>    while (index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next;<br/>    }<br/>  }<br/>}</span></pre><blockquote class="kw kx ky"><p id="4336" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="iq">记住:index++将首先计算数字，然后只加1。</em></p></blockquote><p id="c898" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">这一步只需要遍历我们的列表，直到位置与我们想要更改的位置相匹配。</p><p id="f6d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">当我们达到这一点时，我们需要做的就是重新做好<code class="fe nd ne nf ng b">previousNode</code>&lt;-&gt;-<code class="fe nd ne nf ng b">new node</code>-&gt;-<code class="fe nd ne nf ng b">currentNode</code>之间的联系:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="54cf" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="3c3f" class="nl mh iq ng b gy nq nn l no np">  if (!isPositionInTheRange) {<br/>    return false;<br/>  }</span><span id="6bea" class="nl mh iq ng b gy nq nn l no np">  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="2bea" class="nl mh iq ng b gy nq nn l no np">  let currentNode = head;</span><span id="4165" class="nl mh iq ng b gy nq nn l no np">  const isHeadPosition = position === 0;</span><span id="d03f" class="nl mh iq ng b gy nq nn l no np">  if (isHeadPosition) {    <br/>    node.next = currentNode;<br/>    head = node;<br/>  } else {<br/>    let previousNode = null;<br/>    let index = 0;<br/>    <br/>    while (index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next;<br/>    }<br/>    <br/>    previousNode.next = node;<br/>    node.next = currentNode;<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/20b7a9cb7b45b83977967b459bfd3f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iWN7iuMdBB7OPaSz.png"/></div></div></figure><p id="cdd6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">最后，我们需要将<code class="fe nd ne nf ng b">+1</code>添加到我们的列表长度中，不管它被插入到列表中的什么位置，并返回<code class="fe nd ne nf ng b">true</code>来通知用户操作成功:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="67c0" class="nl mh iq ng b gy nm nn l no np">function insertAt(position, element) {<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="1acf" class="nl mh iq ng b gy nq nn l no np">  if (!isPositionInTheRange) {<br/>    return false;<br/>  }</span><span id="4126" class="nl mh iq ng b gy nq nn l no np">  const node = {<br/>    element,<br/>    next: null,<br/>  };</span><span id="3d95" class="nl mh iq ng b gy nq nn l no np">  let currentNode = head;</span><span id="fa17" class="nl mh iq ng b gy nq nn l no np">  const isHeadPosition = position === 0;</span><span id="71de" class="nl mh iq ng b gy nq nn l no np">  if (isHeadPosition) {    <br/>    node.next = currentNode;<br/>    head = node;<br/>  } else {<br/>    let previousNode = null;<br/>    let index = 0;<br/>    <br/>    while (index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next;<br/>    }<br/>    <br/>    previousNode.next = node;<br/>    node.next = currentNode;<br/>  }<br/>  <br/>  length++;<br/>  return true;<br/>}</span></pre><h1 id="a8e1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。移除(位置)</h1><p id="76b8" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">removeAt方法的实现与我们刚刚在<code class="fe nd ne nf ng b">insertAt</code>中看到的非常相似，我们需要:</p><ol class=""><li id="f190" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv og nx ny nz bi translated">遍历列表；</li><li id="30f1" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">在那个位置找到对应的元素；</li><li id="6040" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">将前一个元素连接到下一个元素；</li><li id="288d" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv og nx ny nz bi translated">减小列表大小</li></ol><p id="2bfb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">再次开始，让我们首先验证请求位置是否包含元素:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="7172" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>}</span></pre><p id="7af6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">然后，我们需要创建控制器变量<code class="fe nd ne nf ng b">currentNode</code>来迭代:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="ca52" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>}</span></pre><p id="934c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">同样，我们会有两种情况:头或不头。如果是head，我们需要做的就是将<code class="fe nd ne nf ng b">head</code>重新分配为当前节点(在本例中是head元素本身)的<code class="fe nd ne nf ng b">.next</code>值:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="af90" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>  <br/>  if(position === 0){<br/>    head = currentNode.next;<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4623a7b6d5f80a3946a7935ad76424ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CXe0kuGL1OD9Iztp.png"/></div></div></figure><blockquote class="kw kx ky"><p id="d61e" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="iq">如果你不知道，只要从这个元素中删除所有引用，</em> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#garbage_collection" rel="noopener ugc nofollow" target="_blank"> <em class="iq">垃圾收集器</em> </a> <em class="iq">就会知道不再需要它，并从内存中删除它。</em></p></blockquote><p id="01aa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">现在，我们需要删除不是头部的元素。为此，让我们创建另外两个控制器变量，<code class="fe nd ne nf ng b">index</code>和<code class="fe nd ne nf ng b">previousNode</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="83d2" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>  <br/>  if(position === 0){<br/>    head = currentNode.next;<br/>  } else {<br/>    let index = 0;<br/>    let previousNode = null;<br/>  }<br/>}</span></pre><p id="0d5d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">再一次，迭代所有的元素，直到我们到达我们想要的位置:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9f13" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>  <br/>  if(position === 0){<br/>    head = currentNode.next;<br/>  } else {<br/>    let index = 0;<br/>    let previousNode = null;<br/>    <br/>    while(index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next<br/>    }<br/>  }<br/>}</span></pre><p id="7e40" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">现在，我们通过将<code class="fe nd ne nf ng b">previousNode.next</code>链接到<code class="fe nd ne nf ng b">currentNode.next</code>来重新创建节点链接:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="bba2" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>  <br/>  if(position === 0){<br/>    head = currentNode.next;<br/>  } else {<br/>    let index = 0;<br/>    let previousNode = null;<br/>    <br/>    while(index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next<br/>    }<br/>    <br/>    previousNode.next = currentNode.next;<br/>    <br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/6ba685b396f8aff0aeb1952a0dfe290e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KfW-KT2Ky_coj3vS.png"/></div></div></figure><p id="1d66" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">最后，我们需要从列表长度中减去1，并返回我们要删除的元素，这样用户就可以对它做一些事情:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="0ebc" class="nl mh iq ng b gy nm nn l no np">function removeAt(position){<br/>  const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;<br/>  <br/>  if(!isPositionInTheRange){<br/>    return null<br/>  }<br/>  <br/>  let currentNode = head;<br/>  <br/>  if(position === 0){<br/>    head = currentNode.next;<br/>  } else {<br/>    let index = 0;<br/>    let previousNode = null;<br/>    <br/>    while(index++ &lt; position){<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next<br/>    }<br/>    <br/>    previousNode.next = currentNode.next;<br/>  }<br/>  <br/>  length--;<br/>  return currentNode.element;<br/>}</span></pre><h1 id="7637" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。移除(元素)</h1><p id="e4b9" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">这个方法实现起来非常简单。这是因为我们已经有了一个从元素中查找索引的方法(<code class="fe nd ne nf ng b">indexOf</code>)和一个从位置中移除元素的方法(<code class="fe nd ne nf ng b">removeAt</code>):</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="82e5" class="nl mh iq ng b gy nm nn l no np">function remove(element){<br/>  const elementIndex = indexOf(element);<br/>  return removeAt(elementIndex);<br/>}</span></pre><h1 id="d3c0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">。toString()</h1><p id="4fae" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">这个方法纯粹是给使用这个链表的人一个列表中所有元素的概念。</p><p id="b686" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">我们需要再次浏览所有节点，并将元素值连接成一个字符串:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="26b5" class="nl mh iq ng b gy nm nn l no np">function toString() {<br/>  let result = "";<br/>  let current = head;</span><span id="121f" class="nl mh iq ng b gy nq nn l no np">  while (current) {<br/>    result += `${current.element}${current.next ? ", " : ""}`;<br/>    current = current.next;<br/>  }</span><span id="4109" class="nl mh iq ng b gy nq nn l no np">  return result;<br/>}</span></pre><blockquote class="kw kx ky"><p id="0882" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="iq"> Obs。:这只适用于原始值。如果要支持的元素有</em><code class="fe nd ne nf ng b"><em class="iq">objects</em></code><em class="iq"/><code class="fe nd ne nf ng b"><em class="iq">functions</em></code><em class="iq">等。您需要增强连接和数据解析。</em></p></blockquote><h1 id="d34c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">决赛成绩</h1><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="cbf9" class="nl mh iq ng b gy nm nn l no np">function LinkedListFactory() {<br/>  let head = null;<br/>  let length = 0;</span><span id="7063" class="nl mh iq ng b gy nq nn l no np">  return {<br/>    append,<br/>    indexOf,<br/>    insertAt,<br/>    remove,<br/>    removeAt,<br/>    toString,<br/>  };</span><span id="fc5c" class="nl mh iq ng b gy nq nn l no np">  function append(element) {<br/>    const node = {<br/>      element,<br/>      next: null,<br/>    };</span><span id="6337" class="nl mh iq ng b gy nq nn l no np">    if (head === null) {<br/>      head = node<br/>    } else {<br/>      let currentNode = head;</span><span id="dd0a" class="nl mh iq ng b gy nq nn l no np">      while (currentNode.next !== null) {<br/>        currentNode = currentNode.next;<br/>      }</span><span id="8621" class="nl mh iq ng b gy nq nn l no np">      currentNode.next = node;<br/>    }</span><span id="f9ec" class="nl mh iq ng b gy nq nn l no np">    length++;<br/>  }</span><span id="a240" class="nl mh iq ng b gy nq nn l no np">  function indexOf(element) {<br/>    let nodeIndex = 0;<br/>    let currentNode = head;</span><span id="b32a" class="nl mh iq ng b gy nq nn l no np">    while (currentNode) {<br/>      if (element === currentNode.element) {<br/>        return nodeIndex;<br/>      }</span><span id="2bf0" class="nl mh iq ng b gy nq nn l no np">      nodeIndex++;</span><span id="3190" class="nl mh iq ng b gy nq nn l no np">      currentNode = currentNode.next;<br/>    }</span><span id="3a3e" class="nl mh iq ng b gy nq nn l no np">    return -1;<br/>  }</span><span id="764a" class="nl mh iq ng b gy nq nn l no np">  function insertAt(position, element) {<br/>    const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt;= length;</span><span id="d12a" class="nl mh iq ng b gy nq nn l no np">    if (!isPositionInTheRange) {<br/>      return false;<br/>    }</span><span id="4096" class="nl mh iq ng b gy nq nn l no np">    const node = {<br/>      element,<br/>      next: null,<br/>    };</span><span id="93bd" class="nl mh iq ng b gy nq nn l no np">    let currentNode = head;</span><span id="461e" class="nl mh iq ng b gy nq nn l no np">    const isHeadPosition = position === 0;</span><span id="4d92" class="nl mh iq ng b gy nq nn l no np">    if (isHeadPosition) {<br/>      node.next = currentNode;<br/>      head = node;<br/>    } else {<br/>      let previousNode = null;<br/>      let index = 0;</span><span id="8a65" class="nl mh iq ng b gy nq nn l no np">      while (index++ &lt; position) {<br/>        previousNode = currentNode;<br/>        currentNode = currentNode.next;<br/>      }</span><span id="6b2a" class="nl mh iq ng b gy nq nn l no np">      previousNode.next = node;<br/>      node.next = currentNode;<br/>    }</span><span id="31b0" class="nl mh iq ng b gy nq nn l no np">    length++;<br/>    return true;<br/>  }</span><span id="a5bf" class="nl mh iq ng b gy nq nn l no np">  function removeAt(position) {<br/>    const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;</span><span id="8c2b" class="nl mh iq ng b gy nq nn l no np">    if (!isPositionInTheRange) {<br/>      return null;<br/>    }</span><span id="1780" class="nl mh iq ng b gy nq nn l no np">    let currentNode = head;</span><span id="cf5a" class="nl mh iq ng b gy nq nn l no np">    if (position === 0) {<br/>      head = currentNode.next;<br/>    } else {<br/>      let index = 0;<br/>      let previousNode = null;</span><span id="0d04" class="nl mh iq ng b gy nq nn l no np">      while (index++ &lt; position) {<br/>        previousNode = currentNode;<br/>        currentNode = currentNode.next;<br/>      }</span><span id="5406" class="nl mh iq ng b gy nq nn l no np">      previousNode.next = currentNode.next;<br/>    }</span><span id="0101" class="nl mh iq ng b gy nq nn l no np">    length--;<br/>    return currentNode;<br/>  }</span><span id="378e" class="nl mh iq ng b gy nq nn l no np">  function removeAt(position) {<br/>    const isPositionInTheRange = position &gt; -1 &amp;&amp; position &lt; length;</span><span id="a436" class="nl mh iq ng b gy nq nn l no np">    if (!isPositionInTheRange) {<br/>      return null;<br/>    }</span><span id="e94b" class="nl mh iq ng b gy nq nn l no np">    let currentNode = head;</span><span id="4ae0" class="nl mh iq ng b gy nq nn l no np">    if (position === 0) {<br/>      head = currentNode.next;<br/>    } else {<br/>      let index = 0;<br/>      let previousNode = null;</span><span id="ae6e" class="nl mh iq ng b gy nq nn l no np">      while (index++ &lt; position) {<br/>        previousNode = currentNode;<br/>        currentNode = currentNode.next;<br/>      }</span><span id="db18" class="nl mh iq ng b gy nq nn l no np">      previousNode.next = currentNode.next;<br/>    }</span><span id="616e" class="nl mh iq ng b gy nq nn l no np">    length--;<br/>    return currentNode.element;<br/>  }</span><span id="f941" class="nl mh iq ng b gy nq nn l no np">  function remove(element) {<br/>    const elementIndex = indexOf(element);<br/>    return removeAt(elementIndex);<br/>  }</span><span id="1e3b" class="nl mh iq ng b gy nq nn l no np">  function toString() {<br/>    let result = "";<br/>    let current = head;</span><span id="7f2b" class="nl mh iq ng b gy nq nn l no np">    while (current) {<br/>      result += `${current.element}${current.next ? ", " : ""}`;<br/>      current = current.next;<br/>    }</span><span id="c64d" class="nl mh iq ng b gy nq nn l no np">    return result;<br/>  }<br/>}</span><span id="0196" class="nl mh iq ng b gy nq nn l no np">const linkedList = LinkedListFactory();</span><span id="3d4c" class="nl mh iq ng b gy nq nn l no np">linkedList.append(1);<br/>linkedList.append(10);<br/>linkedList.append(-1);<br/>linkedList.append(40);<br/>linkedList.append(-123);</span><span id="8ed8" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.toString()); // 1, 10, -1, 40, -123</span><span id="18cd" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.removeAt(3)); // 40</span><span id="70c0" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.toString()); // 1, 10, -1, -123</span><span id="2aba" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.indexOf(1)); // 0</span><span id="c81b" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.remove(1)); // 1</span><span id="9df6" class="nl mh iq ng b gy nq nn l no np">console.log(linkedList.toString()); // 10, -1, -123</span></pre><h1 id="4c7c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="a06b" class="pw-post-body-paragraph kz la iq lc b ld my jr lf lg mz ju li md na ll lm me nb lp lq mf nc lt lu lv ij bi translated">我希望我能向你解释什么是链表，以及如何简单地实现它。</p><p id="7a88" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">它还有两种变体:“双重链接”(下一个和上一个链接)和循环，但我认为在另一篇文章中会更好。</p><p id="1b4f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">同样，因为我们处于JavaScript环境中，我没有看到它的强大用法，但知道它的存在是很重要的，以防我们在其他语言中接触到它。</p><p id="7c89" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">如果你对此有任何意见，请发微博给我，这样我们可以一起积累知识！</p><p id="798f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">干杯。</p><h1 id="3682" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><ul class=""><li id="b34d" class="nr ns iq lc b ld my lg mz md ok me ol mf om lv nw nx ny nz bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Memory _ Management</a></li><li id="4b06" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://www.geeksforgeeks.org/applications-of-linked-list-data-structure" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/applications-of-linked-list-data-structure</a></li><li id="7768" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array</a></li><li id="1de3" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated">https://en.wikipedia.org/wiki/Linked_list<a class="ae kv" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="a70e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">JavaScript数据结构</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><ul class=""><li id="226f" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv nw nx ny nz bi translated"><a class="ae kv" href="https://raulmelo-dev-nn9485d2s-raulfdm.vercel.app/blog/data-structure-in-javascript-stack" rel="noopener ugc nofollow" target="_blank">栈</a></li><li id="2700" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://raulmelo-dev-nn9485d2s-raulfdm.vercel.app/blog/data-structure-with-javascript-queue" rel="noopener ugc nofollow" target="_blank">队列</a></li><li id="0d53" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://raulmelo-dev-nn9485d2s-raulfdm.vercel.app/blog/data-structure-with-javascript-linked-list" rel="noopener ugc nofollow" target="_blank">链表</a></li></ul><p id="1836" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">3部分系列</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="226d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated">标签</p><ul class=""><li id="e5b2" class="nr ns iq lc b ld le lg lh md nt me nu mf nv lv nw nx ny nz bi translated"><a class="ae kv" href="https://raulmelo-dev-nn9485d2s-raulfdm.vercel.app/tag/computer-science" rel="noopener ugc nofollow" target="_blank">#计算机科学</a></li><li id="4a2a" class="nr ns iq lc b ld oa lg ob md oc me od mf oe lv nw nx ny nz bi translated"><a class="ae kv" href="https://raulmelo-dev-nn9485d2s-raulfdm.vercel.app/tag/data-structure" rel="noopener ugc nofollow" target="_blank">#数据结构</a></li></ul><p id="900a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li md lk ll lm me lo lp lq mf ls lt lu lv ij bi translated"><em class="lb">更多内容看</em> <a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="lb">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>