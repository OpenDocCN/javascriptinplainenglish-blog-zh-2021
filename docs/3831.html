<html>
<head>
<title>Create a Product Rating System with MongoDB and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MongoDB和Node.js创建一个产品评级系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-product-rating-system-with-mongodb-and-node-js-ca1b2502885f?source=collection_archive---------1-----------------------#2021-08-02">https://javascript.plainenglish.io/creating-a-product-rating-system-with-mongodb-and-node-js-ca1b2502885f?source=collection_archive---------1-----------------------#2021-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/67a926e6545ebe2f90d682fd18bb5642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*YV-L6_YO7I-SoPLsepJsUw.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Source: Getty</figcaption></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="7985" class="kc kd in bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="e512" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在本教程中，您将学习如何充分利用Mongoose模式混合类型、getters和setters来操作MongoDB数据库中的数据</p><p id="7493" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">大多数产品评级系统，如亚马逊的系统，利用加权平均系统。加权平均值的计算方法与“正常”简单平均值几乎相同，只是总和中的每个单位都有一个乘数，称为权重。例如在五星评级系统中。一颗星的权重为1，两颗星的权重为2，依此类推。</p><h1 id="454c" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">例子</h1><p id="6723" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">假设一个产品有以下星级评价。</p><p id="9d4e" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">一颗星— — 8颗</p><p id="5063" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">两颗星--10颗</p><p id="e3aa" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">三星--7颗</p><p id="6874" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">四颗星--5颗</p><p id="7dec" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">五星— — 3颗</p><p id="2100" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">简单的平均值是</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bc3d" class="mr kd in mn b gy ms mt l mu mv">const SA = (8+10+7+5+3) / 5<br/><strong class="mn io"><em class="mw">console</em></strong>.log(<strong class="mn io"><em class="mw">Math</em></strong>.round(SA)) // 2</span></pre><p id="761e" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">加权平均值为:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0311" class="mr kd in mn b gy ms mt l mu mv">const WA = ((1*8) + (2*10) + (3*7) + (5*3))/(10+8+7+5+3) <br/><strong class="mn io"><em class="mw">console</em></strong>.log(<strong class="mn io"><em class="mw">Math</em></strong>.round(WA)) // 2</span></pre><p id="0181" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">加权平均系统给出了更好的结果，因为它给出了消费者对该产品的看法的良好印象。</p><p id="d909" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">如何实现这一点？</p><p id="8e5e" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">在后台实现这一点意味着你不仅需要一个地方来存储每个产品的评分，还需要一个地方来存储每个start收到的数字。解决这个问题有不同的方法。就个人而言，我更喜欢Mongoose模式混合类型与setters和getters的组合。</p><p id="2b64" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">要求</p><p id="fe77" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">对于这个项目将只需要Mongoose作为我们的MongoDB驱动程序和一个本地Mongo shell，并可选地为良好的可视化指南针。</p><p id="3acf" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">首先，让我们创建一个简单的节点项目并安装Mongoose。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8e3b" class="mr kd in mn b gy ms mt l mu mv">npm install -s mongoose</span></pre><p id="6df6" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">创建一个文件model.js并启动本地Mongo客户端</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="69e2" class="mr kd in mn b gy ms mt l mu mv">const mongoose = <strong class="mn io"><em class="mw">require</em></strong>('mongoose');<br/><br/>const connectDB = async () =&gt; {<br/>     try{<br/>         const conn = await mongoose.connect('mongodb://localhost:27017/myapp', {useNewUrlParser: true, useFindAndModify: false})<br/>         <strong class="mn io"><em class="mw">console</em></strong>.log(`MongoDb connected: ${conn.connection.host}`)<br/>         return conn<br/>     }<br/>     catch (e) {<br/>         <strong class="mn io"><em class="mw">console</em></strong>.error(e);<br/>         <strong class="mn io"><em class="mw">process</em></strong>.exit(1);<br/><br/>     }<br/> };</span></pre><p id="dee3" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">接下来，让我们为产品集合创建一个基本的mongoose模式。它只有两个路径，一个是保存产品名称的字符串路径，一个是存储产品评级的混合路径对象。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2a37" class="mr kd in mn b gy ms mt l mu mv">const ProductSchema = new mongoose.Schema({<br/>    name: <strong class="mn io"><em class="mw">String</em></strong>,<br/>    ratings:{<br/>        type: mongoose.Mixed, <br/> // A mixed type object to handle ratings. Each star level is represented in the ratings object<br/>        1: <strong class="mn io"><em class="mw">Number</em></strong>, //  the key is the weight of that star level<br/>        2: <strong class="mn io"><em class="mw">Number</em></strong>,<br/>        3: <strong class="mn io"><em class="mw">Number</em></strong>,<br/>        4: <strong class="mn io"><em class="mw">Number</em></strong>,<br/>        5: <strong class="mn io"><em class="mw">Number</em></strong>,<br/>    default: {1:1, 2:1, 3:1, 4:1, 5:1}}<br/>    }) </span></pre><p id="cddf" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">因为我们使用getters，所以请确保在schema对象中包含以下选项，以便在获取JSON或JavaScript对象时可以使用getters</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1ca7" class="mr kd in mn b gy ms mt l mu mv">{toObject:{getters: true, }, toJSON:{getters: true}}</span></pre><h1 id="e085" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">Getter函数</h1><p id="f23e" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">接下来，我们将编写一个getter函数，用于从评级路径中获取产品的评级。当我们在路径上调用getter函数时，它接受一个表示路径的参数。在这种情况下，它是一个普通的JavaScript对象，包含我们的明星评论。这简化了getter函数。如下图。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="42f9" class="mr kd in mn b gy ms mt l mu mv">get: function(r){<br/>    // r is the entire ratings object<br/>    let items = <strong class="mn io"><em class="mw">Object</em></strong>.entries(r); // get an array of key/value pairs of the object like this [[1:1], [2:1]...]<br/>    let sum = 0; // sum of weighted ratings<br/>    let total = 0; // total number of ratings<br/>    for(let [key,value] of items){<br/>        total += value;<br/>        sum += value * parseInt(key); // multiply the total number of ratings by it's weight in this case which is the key<br/>    }<br/>    return <strong class="mn io"><em class="mw">Math</em></strong>.round(sum / total)<br/>},</span></pre><h1 id="0509" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">Setter函数</h1><p id="ebfe" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">此函数将处理评级路径的值设置。它将使我们有一个简单的界面来更新产品的评级。假设用户给产品的评分是3，或者我们想用一个新的对象替换整个评分对象。我们希望能够用这样的简单在线更新产品的评级。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1484" class="mr kd in mn b gy ms mt l mu mv">product.ratings = 3<br/>product.ratings = {1:1, 2:1, 3:1, 4:1, 5:1}<br/>Product.findByIdAndUpdate(id, {$inc:{'ratings.3': 1}})<br/>Product.findByIdAndUpdate('61084b72b346c52e8482ed3b', {ratings: {1:3, 2:1, 3:1, 4:1, 5:1}}, {new: true})</span></pre><p id="25ea" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">前两个片段会将三星评级的数量更新1。而另外两个将向评级路径分配新的对象。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="639c" class="mr kd in mn b gy ms mt l mu mv">set: function(r){<br/>    if (!(this instanceof mongoose.Document)){<br/>        // only call setter when updating the whole path with an object<br/>        if(r instanceof <strong class="mn io"><em class="mw">Object</em></strong>) return r<br/>        else{throw new <strong class="mn io"><em class="mw">Error</em></strong>('')}<br/>    }else{<br/>        // get the actual ratings object without using the getter which returns  an integer value<br/>        // r is the ratings which is an integer value that represent the star level from 1 to 5<br/>        if(r instanceof <strong class="mn io"><em class="mw">Object</em></strong>){<br/>            return r    // handle setting default when creating object<br/>        }<br/>        this.get('ratings', null, {getters: false})[r] = 1 + parseInt(this.get('ratings', null, {getters: false})[r])<br/>        return this.get('ratings', null, {getters: false})} // return the updated ratings object<br/>},</span></pre><p id="9a8d" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">setter函数有点复杂，因为我们需要获取该文档的rating对象，而不需要使用getter返回一个整数值。setter函数的参数要么是我们想要更新的星级，要么是一个JavaScript对象，它包含作为键的星级，就像模式中指定的那样。Mongoose setters在运行更新操作和直接分配路径时都会被调用。不同之处在于，当运行更新操作时，函数中的“this”指的是查询对象，而不是我们正在更新的mongoose文档的实例，这使得我们很难对子路径执行自定义更新操作，因为我们正在更新特定的子路径，而不是整个路径。因此，如果有人试图使用任何Mongoose模型更新方法用整数值更新整个路径，我们将抛出一个错误。</p><p id="f3e3" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">setter函数中剩下的逻辑很简单，我们将简单地获取产品评级对象，而不使用getters，然后使用setter函数的参数来更新特定的路径，之后我们将返回更新后的评级对象。</p><h1 id="2244" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">确认</h1><p id="d6e9" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">添加一个验证器来防止一次增加一个以上的子路径值是很好的，但是，当使用增量运算符“$inc”时，Mongoose验证器不会运行，因此，在将数据传递给数据库之前，由我们来验证数据。我们的验证器函数将简单地防止在我们的模式中指定的级别之外添加额外的星级。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4299" class="mr kd in mn b gy ms mt l mu mv">validate:{<br/>    validator: function(i){<br/>        let b = [1, 2, 3, 4, 5] // valid star levels<br/>        let v = <strong class="mn io"><em class="mw">Object</em></strong>.keys(i).sort()<br/>        return b.every((x, j) =&gt; (v.length === b.length) &amp;&amp; x === parseInt(v[j]))<br/>    },<br/>    message: "Invalid Star Level"<br/>},</span></pre><h1 id="a693" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">测试</h1><p id="5c22" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们创建一个产品，并在有和没有getters的情况下对其进行控制台日志记录，看看它是什么样子的。下面是我们的代码。然后我们可以复制产品id来测试我们的更新方法和验证器。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="670a" class="mr kd in mn b gy ms mt l mu mv">const create = async () =&gt; {<br/>    let prod = await product.create({name: "Product One"})<br/>    // display the newly created object with and without getters<br/>    <strong class="mn io"><em class="mw">console</em></strong>.log(prod)<br/>    <strong class="mn io"><em class="mw">console</em></strong>.log(prod.get( 'ratings', null, {getters: false}))<br/>}<br/>create()<br/><br/>// result without the getter<br/>{<br/>    ratings: 3,<br/>        _id: 61069af7547cd8335409a926,<br/>    <strong class="mn io"><em class="mw">name</em></strong>: 'Product One',<br/>    __v: 0,<br/>    id: '61069af7547cd8335409a926'<br/>}<br/><br/>// the ratings object<br/>{ '1': 1, '2': 1, '3': 1, '4': 1, '5': 1 }</span></pre><p id="7ad0" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">看到我们的吸气剂在工作。我们将尝试以几种不同的方式更新我们产品的评级，以测试我们的setters。</p><p id="5b40" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">让我们写一个代码给我们的产品一个五星评级。如您所见，只需将评分对象的值指定为5，我们就可以将五星评价的数量从1更新为2。平均评级仍然是3，因为我们在获得评级时使用了加权平均计算。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7520" class="mr kd in mn b gy ms mt l mu mv">const test1 = async () =&gt; {<br/>    // increment a particular star level.<br/>    // by assigning directly to the ratings object<br/>    let prod = await product.findById('61084b72b346c52e8482ed3b')<br/>    prod.ratings = 5<br/>    prod.markModified('ratings')  // Add markModified because ratings is a mixed object type<br/>    prod.save()<br/>    <strong class="mn io"><em class="mw">console</em></strong>.log(prod.get( 'ratings', null, {getters: false}))<br/>    <strong class="mn io"><em class="mw">console</em></strong>.log(prod)<br/>}</span><span id="bb89" class="mr kd in mn b gy mx mt l mu mv">test1()<br/><br/>{ '1': 1, '2': 1, '3': 1, '4': 1, '5': 2 }<br/><br/>{<br/>    ratings: 3,<br/>        _id: 61084b72b346c52e8482ed3b,<br/>    <strong class="mn io"><em class="mw">name</em></strong>: 'Product One',<br/>    __v: 0,<br/>    id: '61084b72b346c52e8482ed3b'<br/>}</span></pre><h1 id="f99d" class="kc kd in bd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz bi translated">结论</h1><p id="10a7" class="pw-post-body-paragraph la lb in lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">一如既往，在计算机科学中，有许多方法可以解决一个问题，有些方法比其他方法更直观。然而，找到一个适应性强、可维护、包含最少代码的解决方案总是更可取的。</p><p id="1160" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated">完整的代码可以在https://github.com/Ichinga-Samuel/Rating-System.git找到</p><p id="770b" class="pw-post-body-paragraph la lb in lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ig bi translated"><em class="mw">更多内容尽在</em><a class="ae my" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lc io"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>