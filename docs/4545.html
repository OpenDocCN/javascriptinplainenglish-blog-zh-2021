<html>
<head>
<title>How To Build a Website Development Server From Scratch With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js从零开始搭建网站开发服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-development-server-8365a9bf449b?source=collection_archive---------6-----------------------#2021-09-10">https://javascript.plainenglish.io/node-js-development-server-8365a9bf449b?source=collection_archive---------6-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3abb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在每次代码更改时重新加载页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5dbd076eb095377e82084a81f2ee0126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcdByWHVVzRZzxjz6zqUew.png"/></div></div></figure><p id="e545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您肯定知道什么是开发服务器。我们可以在任何地方找到它们——当使用Webpack、create-react-app或使用像Live Server这样的编辑器扩展时。</p><p id="6469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发服务器帮助我们在机器上提供web应用程序，并在我们更改代码时重新加载页面。这使得开发变得容易。</p><p id="367d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这样的服务器实际上是如何工作的呢？让我们通过自己建造一个来找出答案。目标是一个小服务器，当我们对我们的网站进行更改时，它会重新加载浏览器窗口。我们的结果实际上是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/1258a80b6db9ae8040d584efa5f9fe41.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*DkYAX-gsurSuvoWbRzHKZw.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">GIF takes a couple of seconds</figcaption></figure><h1 id="62c4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们的服务器将如何工作</h1><p id="77e6" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">在我们进入代码之前，澄清一些事情是很重要的。那么，开发服务器是如何工作的呢？</p><p id="603e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的核心是我们服务的目录。在这个目录中，我称之为“src ”,我们构建的web应用程序存在——因此，一个index.html、一些JavaScript，当然还有CSS文件都放在那里。</p><p id="ecad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切都围绕着这个目录——每当目录发生变化时，开发服务器都会强制浏览器重新加载页面。事情是这样发生的:</p><ul class=""><li id="57ee" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">使用节点库“chokidar ”,我们观察“src”目录中的文件变化。无论我们编辑index.html还是这个目录中的JavaScript文件，服务器都会注意到，多亏了chokidar。</li><li id="0a13" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">当chokidar启动并运行时，开发服务器建立一个客户机可以连接的web套接字。每当“src”目录中的文件发生变化时，就会向客户端发出一条web套接字消息。但是谁是客户，他如何联系？</li><li id="f035" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">请兴奋:客户端是“src”目录中的index.html——因此，是我们正在构建的web应用程序的入口点。所以，是的，index.html包含连接到服务器的web套接字的JavaScript代码。现在，更大的图景出现了:</li><li id="4958" class="mp mq iq kt b ku my kx mz la na le nb li nc lm mu mv mw mx bi translated">Dev服务器开始监视文件→当一个文件改变时，一个web socket消息被发送到客户端→客户端接收消息并重新加载浏览器窗口，因此改变变得可见。只剩下最后一个问题:我们如何将web套接字代码放入客户端？</li></ul><p id="366e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发服务器的目标是服务于一个页面——我们不想强迫开发者默认提供所需的代码。这就是为什么我们在客户端手动注入web socket代码。让我们看一个例子。</p><p id="3ae3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设用户正在开发一个网站，该网站目前包含一个空的HTML文件:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="91ef" class="ni lt iq ne b gy nj nk l nl nm">&lt;html&gt;<br/>  &lt;head&gt;&lt;/head&gt;<br/>  &lt;body&gt;&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="bb86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的开发服务器读取文件，将其发送到浏览器——但在此之前，他注入了所需的代码。这是怎么回事？通过一个名为JSDOM的库。JSDOM使我们能够像在浏览器中一样操纵HTML使用像<code class="fe nn no np ne b">document.querySelector</code>或<code class="fe nn no np ne b">element.appendChild</code>这样的函数。</p><p id="1e88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们读取用户创建的index.html，并在将其发送到浏览器之前，向其中注入必要的脚本。结果，注入的代码:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5371" class="ni lt iq ne b gy nj nk l nl nm">&lt;script src="https://cdn.socket.io/socket.io-3.0.0.min.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>const socket = io()</span><span id="553b" class="ni lt iq ne b gy nq nk l nl nm">socket.on('message', (data) =&gt; {<br/>  if (data == 'reload') {<br/>    location.reload()<br/>  }<br/>})</span></pre><p id="9a3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，为了连接到服务器的web套接字，使用了SocketIO。当客户端收到信号时，<code class="fe nn no np ne b">location.reload()</code>重新加载页面。</p><h1 id="57fa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们进入代码</h1><p id="cac5" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">嗯，那是一大堆理论。我将指导你一步一步地通过代码，你可以在最后找到整个代码。</p><p id="5a59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是最重要的几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f735" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nn no np ne b">watcher</code>是chokidar提供的主要对象——通过它，我们可以对任何文件更改做出反应——编辑、添加或删除文件。ignore initial选项只是意味着chokidar不应该对现有的文件作出初始反应——只有在某些内容发生变化的情况下。</p><p id="ce75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们通过SocketIO建立一个web套接字。对于“src”目录中的所有文件更改，将向客户端发送一条web套接字消息，其中包含字符串“reload”。</p><p id="60f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，事情变得越来越复杂。我们的中央GET请求处理逻辑如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="11d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当应用程序的开始页面，例如，<code class="fe nn no np ne b">http://localhost/</code>被请求时，我们注入WebSocket客户端代码——这是我剪下并标有“一会儿有更多代码”的代码。每个请求URL else <strong class="kt ir">必须</strong>指向一个文件——因为我们不能也不应该将WebSocket客户端代码注入到JS文件或CSS文件中，我们只是从“src”目录中提供所请求的文件。</p><p id="2f4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在讨论如何注入WebSocket代码(该代码属于我所说的“稍后会有更多代码”的部分):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7bf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，当请求“index.html”时，我们从“src”目录中读取它。“数据”参数包含HTML代码。通过JSDOM，我们基于这个HTML的内容创建了一个DOM。</p><p id="aef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们创建两个HTML元素——都是脚本标记。第一个名为<code class="fe nn no np ne b">scriptSocketLink</code>的文件保存了到CDN上SocketIO库的链接。</p><p id="1f4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个名为<code class="fe nn no np ne b">scriptSocketCode</code>的脚本标签保存了我之前介绍过的客户端web socket代码。</p><p id="9ef3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">两个新的HTML元素都作为子元素附加到文档的头部。最后，我们用<code class="fe nn no np ne b">dom.seralize()</code>将处理好的DOM转换成一个字符串，并发送给客户端。</p><p id="92e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后但同样重要的是，端口和一个很酷的功能:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="de41" class="ni lt iq ne b gy nj nk l nl nm">http.listen(5000)</span><span id="2ba9" class="ni lt iq ne b gy nq nk l nl nm">open('http://localhost:5000/')</span></pre><p id="dca3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择端口由您决定。库“open”中的open函数打开我们机器上的默认浏览器。当现在执行开发服务器时，所需的窗口打开，您可以看到来自“src”目录的页面——及其所有的CSS和JS文件。当您更改这些文件中的任何一个时，窗口会自动重新加载。酷吧？</p><p id="f3e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是完整的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="eb13" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进一步的想法</h1><p id="4a3c" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">我们在Node.js中有一个网站的最小开发服务器。然而，如你所见，它现在还不完美。首先，重新加载页面很慢——大多数开发服务器使用热重新加载，而不是完全重新加载页面。接下来，dev服务器在项目中只支持一个HTML文件，所以是单页app。</p><p id="9869" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个缺点是UX——用Node执行JavaScript文件来启动服务器，需要一个“src”目录，这很不方便。相反，CLI会更好，它可以服务于任何目录。</p><p id="b85e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们用这个基本的例子来保持它。然而，如果你有兴趣阅读第二部分，升级这个服务器，让我知道！我很想拍第二部。</p><p id="5aff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的阅读！</p><p id="9884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nt">更多内容看</em><a class="ae nu" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="nt">plain English . io</em></strong></a></p></div></div>    
</body>
</html>