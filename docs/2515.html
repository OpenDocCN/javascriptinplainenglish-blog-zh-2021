<html>
<head>
<title>Why I think Parsing and Transforming API Response Data in the Front-end is Necessary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我认为在前端解析和转换API响应数据是必要的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-think-parsing-and-transforming-api-response-data-in-the-front-end-is-necessary-7ae9e832f0d?source=collection_archive---------2-----------------------#2021-05-24">https://javascript.plainenglish.io/why-i-think-parsing-and-transforming-api-response-data-in-the-front-end-is-necessary-7ae9e832f0d?source=collection_archive---------2-----------------------#2021-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1ad2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，你有一个API，你想在前端使用它。您如何处理响应数据？我们可以在<code class="fe ki kj kk kl b">fetch</code>之后加上<code class="fe ki kj kk kl b">JSON.parse</code>吗？</p><p id="bb23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我见过许多前端项目只是直接使用API返回的任何内容，而没有进一步处理，我会说这并不理想——在我看来，解析和转换API响应数据是必要的，我将解释为什么。</p><h1 id="d648" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">主要原因:运行时类型安全</h1><p id="7b14" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">让我们从我从别处偷来的一句话开始:</p><blockquote class="lq lr ls"><p id="16f0" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated">“东西会碎”——丹·阿布拉莫夫</p></blockquote><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/a6d0126307ecc9ee509f5759ff46c41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuw5LVMRB8KAldHY-bxbUw.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk"><a class="ae lp" href="https://www.vecteezy.com/vector-art/629015-error-frustrated-man" rel="noopener ugc nofollow" target="_blank">Error &amp; frustrated man Vectors by Vecteezy</a></figcaption></figure><p id="746e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我以前是后端开发者。我学到的最重要的一条规则是“<strong class="jm io">永远不要相信来自前端的输入</strong>”。这很公平，因为我们都知道恶意用户可以绕过客户端验证来发送携带畸形/危险负载的请求，客户端代码也可能会出现导致错误请求负载的问题。</p><p id="690a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反过来，作为前端开发人员，我们应该仅仅相信后端通过API提供给我们的任何东西吗？绝对不会——我们可能会收到潜在的意外API响应数据，并且我们应该尽最大努力使我们的前端对此具有弹性(除非我们想随时解决更多问题)。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="6da7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">直接使用从API返回的数据会出什么问题？以下是一些例子:</p><h2 id="6092" class="mu kn in bd ko mv mw dn ks mx my dp kw jv mz na la jz nb nc le kd nd ne li nf bi translated">我们期望有一个<code class="fe ki kj kk kl b">number</code>，但却收到一个<code class="fe ki kj kk kl b">string</code></h2><pre class="ly lz ma mb gt ng kl nh ni aw nj bi"><span id="f6b3" class="mu kn in kl b gy nk nl l nm nn">{<br/>  "aNumber": "1"<br/>}</span></pre><p id="f243" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下，我们要从<code class="fe ki kj kk kl b">+1</code>到<code class="fe ki kj kk kl b">aNumber</code>，会发生什么？</p><p id="1bb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果是11，不是2！</p><h2 id="ee14" class="mu kn in bd ko mv mw dn ks mx my dp kw jv mz na la jz nb nc le kd nd ne li nf bi translated">我们期望有一个<code class="fe ki kj kk kl b">Array</code>，但是收到一个<code class="fe ki kj kk kl b">null</code></h2><pre class="ly lz ma mb gt ng kl nh ni aw nj bi"><span id="dffb" class="mu kn in kl b gy nk nl l nm nn">{<br/>  "anArray": null<br/>}</span></pre><p id="7c94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下，我们要访问<code class="fe ki kj kk kl b">anArray</code>的<code class="fe ki kj kk kl b">length</code>，会发生什么？</p><p id="daf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们会得到<code class="fe ki kj kk kl b">Uncaught TypeError: Cannot read property ‘length’ of null</code></p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="70d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些意外的API响应背后有许多原因:</p><ul class=""><li id="4223" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh nt nu nv nw bi translated">后端代码中的一个错误</li><li id="73a6" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">数据库中存储了错误的数据</li><li id="1b59" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">后端做出的更改没有通知前端</li><li id="d979" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">等等</li></ul><p id="467b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，我不认为我们能消除它们，因为我们不能仅仅抱着“没有人为错误”的信念——再说一次，“东西会坏掉”:)</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="01a5" class="mu kn in bd ko mv mw dn ks mx my dp kw jv mz na la jz nb nc le kd nd ne li nf bi translated"><strong class="ak">引入类型脚本/流并不能解决整个问题</strong></h2><p id="6526" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">当然，我们有TypeScript/Flow来执行静态类型检查，但这只是针对编译时，而不是运行时。也就是说，即使我们显式地输入了从API接收的数据，我们仍然会遇到类型问题，因为拥有类型定义不会影响运行时行为——我们输入为<code class="fe ki kj kk kl b">number</code>的<code class="fe ki kj kk kl b">string</code>仍然是<code class="fe ki kj kk kl b">string</code>，我们输入为<code class="fe ki kj kk kl b">Array</code>的<code class="fe ki kj kk kl b">null</code>(或者非空值)仍然是<code class="fe ki kj kk kl b">null</code> —没有什么可以真正阻止它们发生。</p><p id="645a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然在TypeScript/Flow中定义可选类型可能会提醒我们在代码中进行空检查(老实说，我更喜欢尽可能提供有意义的默认值，而不是将某些内容保留为<code class="fe ki kj kk kl b">null</code>或<code class="fe ki kj kk kl b">undefined</code>)，但这并不能解决所有潜在的情况——我们仍然有一些误报(例如<code class="fe ki kj kk kl b">number</code>对<code class="fe ki kj kk kl b">string</code>)。</p><p id="3aef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那我们该怎么办？我们应该到处写类型检查/强制转换代码吗？嗯，这是一个解决方案，但是可能会有许多重复，我们很容易忘记检查/更改10个地方中的1个。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="3863" class="mu kn in bd ko mv mw dn ks mx my dp kw jv mz na la jz nb nc le kd nd ne li nf bi translated">终极解决方案:解析和转换API响应数据</h2><p id="b185" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在开发原生移动应用程序(Obj-C/Swift、Java/Kotlin)时，解析API响应数据并将其转换为模型对象是非常常见的——很少看到移动项目只是使用API返回的数据。</p><p id="f793" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为可能有两个主要原因:</p><ol class=""><li id="0204" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh oc nu nv nw bi translated">JSON(或JavaScript对象)并不是这些编程语言本身支持的数据类型</li><li id="4ce7" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh oc nu nv nw bi translated">在移动应用上没有运行时类型安全的成本比web高得多——发布周期长得多，崩溃的感觉真的很糟糕</li></ol><p id="5ba6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在基于JavaScript的web项目中，即使JSON是本机支持的，发布周期也可以短得多，只要我们关心运行时类型安全，我们也应该这样做。</p><p id="03c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的建议是<strong class="jm io"> <em class="lt">在内部和外部</em>之间建立一个门:让我们解析和转换从API接收的数据，在将它们提供给系统的其他部分之前，使它们真正是类型安全的，包括在运行时。</strong></p><p id="cc2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，如果我们想要某种数据类型，在试图从其他地方访问它之前，让我们确保我们确实拥有它。一种可能的方法是使用<code class="fe ki kj kk kl b">lodash</code>提供的转换函数:</p><pre class="ly lz ma mb gt ng kl nh ni aw nj bi"><span id="445c" class="mu kn in kl b gy nk nl l nm nn">import get from "lodash/get";<br/>import toInteger from "lodash/toInteger";<br/>import toString from "lodash/toString";</span><span id="a5c3" class="mu kn in kl b gy od nl l nm nn">const parseData = (json: any): IData =&gt; {<br/>  return {<br/>    id: toInteger(get(json, "id")),<br/>    name: toString(get(json, "name"))<br/>  }<br/>}</span></pre><h1 id="c0d2" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">加分点:R <strong class="ak"> eshaping数据的灵活性</strong></h1><p id="b73a" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">来自后端的响应负载可能并不总是我们在前端想要的:</p><ul class=""><li id="bcb4" class="no np in jm b jn jo jr js jv nq jz nr kd ns kh nt nu nv nw bi translated">它可能使用不同的命名约定:<code class="fe ki kj kk kl b">a_snake_case_variable</code>与<code class="fe ki kj kk kl b">aCamelCaseVariable</code></li><li id="3cd8" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">它可能缺少我们进行数据规范化所必需的信息:有效负载中可能省略了关系键/ id</li><li id="15e9" class="no np in jm b jn nx jr ny jv nz jz oa kd ob kh nt nu nv nw bi translated">同一类型实体的数据可能以不同的形状从不同的API端点返回</li></ul><p id="6a9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过添加一个解析和转换层，我们可以减轻上面列出的所有问题，并且知道在访问数据时我们所拥有的正是我们希望从API响应中得到的。</p><h1 id="e193" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">概述</h1><p id="5b2f" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在前端解析和转换API响应数据是必要的，因为这有助于我们确保数据在运行时可以安全使用，并且数据的形状正是我们想要的。</p><p id="2150" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lt">更多内容尽在</em><a class="ae lp" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lt">plain English . io</em></a></p></div></div>    
</body>
</html>