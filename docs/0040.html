<html>
<head>
<title>NPM-packages in ts-modules format</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ts模块格式的NPM包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/npm-packages-in-ts-modules-format-7f64aa87591?source=collection_archive---------14-----------------------#2021-01-03">https://javascript.plainenglish.io/npm-packages-in-ts-modules-format-7f64aa87591?source=collection_archive---------14-----------------------#2021-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cc17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我注意到一个趋势，我们大多数人沿着某个“标准”的路径创建私有的NPM包:一个<code class="fe ki kj kk kl b">index</code>文件，它包含一个模块的所有内部的重新导出(整个层次结构依次类推)，ES5-cjs模块(或<code class="fe ki kj kk kl b">asset.min.js</code>)以及发布后输出中的<code class="fe ki kj kk kl b">d.ts</code>。但是，如果我说什么可以做得更好呢？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/0d5a932e4bb48f187e5b452cb7c5d957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EPcdXwBktKrYnZf2F4ueg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Legacy NPM-package`s master file (module`s entry point)</figcaption></figure><p id="35c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，我们使用Rollup构建NPM包，因为它不像Webpack那样向包中添加垃圾代码。但对我个人来说，Rollup非常慢，因为组件/实体越多，处理它们的时间就越长，甚至看起来不像是线性依赖。虽然我通过它得到了ES5-cjs模块，它们已经能够在css模块中使用，但是这个解决方案仍然有许多缺点:</p><ol class=""><li id="b194" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated">当添加实体和组件时，模块的冷构建会非线性地变慢(我现在有超过100个实体和组件)</li><li id="bfdb" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">增量构建也不令人鼓舞</li><li id="3dd8" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">当连接cjs规范中的NPM包时，树抖动不起作用——因此，包的大小不受控制——这里您需要更改规范，但这并不总是可能的</li><li id="8431" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">许多使用NPM包的工具并没有简化工作，而是增加了特殊性，特别是对于新开发人员</li><li id="00ca" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">如果一个已配置的webpack已经存在于主项目中(并且dll可以被实现用于优化)，为什么我们(我强调，<strong class="jm io">为我们自己</strong>)需要收集一些东西，用不同的方言编译，这在意识形态上是不可理解的</li><li id="c3c0" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">精简的jsDoc NPM包类型已经震撼了所有人。在开发自己的应用程序时，我们为什么要查看自己模块的缩短版<code class="fe ki kj kk kl b">d.ts</code>?就像我们在轮子里放棍子一样…</li></ol><p id="2d29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我突然想到，我们为什么需要这些？为什么要把事情复杂化？为什么我们需要在ES5 + <code class="fe ki kj kk kl b">d.ts</code>中编译一些东西，建立构建系统，保持两个项目总是打开的(main + NPM用于实现分析)，而我们所有的项目都是用TypeScript编写的，并通过一个已经配置好的webpack构建，这些NPM包的消费者<strong class="jm io">只是我们自己</strong>。如你所知，这个演讲纯粹是关于私人NPM包，但最后我会给出一个银弹，如何让开发者的生活更轻松，并取悦外部消费者。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lq"><img src="../Images/2eaaae580a1e805bd249f92fd301c696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l61-dvB_1iUpn2hG"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@trebron?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Norbert Kundrak</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ls lt lu"><p id="abce" class="jk jl lv jm b jn jo jp jq jr js jt ju lw jw jx jy lx ka kb kc ly ke kf kg kh ig bi translated">NPM包标准只不过是公众意见，聚集在一起看10-50个npmjs包，并根据我们自己对美的想法在它们中找到共同的格式。</p></blockquote></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h2 id="b1a7" class="mg mh in bd mi mj mk dn ml mm mn dp mo jv mp mq mr jz ms mt mu kd mv mw mx my bi translated">批判性思维的结果</h2><p id="28f4" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">我的想法很简单，那就是<strong class="jm io"> NPM包是一个普通的云存储</strong>，就像DropBox一样，我们可以在里面做任何我们想做的事情，当然，唯一的事情就是<code class="fe ki kj kk kl b">package.json</code>存在。我想——既然我们在任何地方都用打字稿写作，那么我的NPM软件包的公开版本也可以在TS上。它看起来像原始的ts代码，在发布之前通过typescript编译器和eslint进行了验证。我称之为<strong class="jm io"> ts模块</strong>。</p><p id="bb9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工作原理:</p><ul class=""><li id="b0e0" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh ne li lj lk bi translated">在NPM包中，我们像以前一样工作在通常的类型+ less + css-modules + esLint +任何你想要的技术上</li><li id="03b9" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">用一个简单的tsc命令构建一个NPM包，但是<strong class="jm io">不要使用<code class="fe ki kj kk kl b">tsconfig.json</code> <code class="fe ki kj kk kl b">noEmit: true</code>中的特殊指令发出它</strong></li><li id="2744" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">编译成功后(为我们进行类型检查)，将所需的源代码复制到一个文件夹中，这个文件夹将在以后发布，姑且称之为<code class="fe ki kj kk kl b">public</code></li><li id="447e" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">使用<a class="ae lr" href="https://www.npmjs.com/package/tsc-watch" rel="noopener ugc nofollow" target="_blank"> tsc-watch </a>，我们为增量构建创建一个可观察对象，并在它成功时挂起复制源代码的命令</li><li id="3eb5" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">在主应用程序中，我们直接访问NPM包模块，就像这个<code class="fe ki kj kk kl b">@scope-name/package-name/components/inputs/input</code>，因为<code class="fe ki kj kk kl b">d.ts</code>文件不见了+我们正在使用本地TS</li><li id="09aa" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">在Webpack设置中的样式加载器规则的指导下，文件与其余的源文件一起被复制，并被收集到主应用程序端的css模块中。</li><li id="7227" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">NPM包是和主应用程序一起构建的，最重要的是——根据它的规则(css模块、块等的命名)。)</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/795ab043d1cd8439807aef5803b41317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUNBrgOnmZBpYi0XnwvQxg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">package.json + tsconfig.json for ts-modules system</figcaption></figure><p id="0ad1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在Rollup上移除了构建器，稍微调整了一下<code class="fe ki kj kk kl b">tsc</code>，这样<strong class="jm io">就不会发出</strong>构建，并且还挂起了复制源代码的钩子，得到了以下结果:</p><ol class=""><li id="10b3" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated">易用性NPM包。所有团队成员都理解唯一的<code class="fe ki kj kk kl b">tsc</code>命令，该命令生成节点复制<code class="fe ki kj kk kl b"><a class="ae lr" href="https://www.npmjs.com/package/copy" rel="noopener ugc nofollow" target="_blank">copy</a></code></li><li id="4551" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">NPM软件包的冷构建从6分钟减少到1.5分钟，增量构建从20秒减少到2秒(与汇总相比)</li><li id="ed17" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">主应用程序包的构建增加了20秒。我强调，正如我前面所说的，您可以分解程序集并连接dll组件，并提交构建的资产来保存结果</li><li id="f8ba" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">当连接NPM包和ts模块时，最终包的大小已经减小，因为主webpack中的树摇动开始工作(应用程序的大小已经减小了1.5MB)。只是在我的情况下，早期的Rollup是给ES5-cjs模块。</li><li id="7cad" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated">NPM包的本地开发不再让开发者害怕，因为从改变包中的代码到webpack-dev-server更新页面只需要10-15秒(在此期间，会发生两次增量构建:首先在NPM，然后在主应用程序)。以前，这个操作需要30到60秒。</li><li id="7112" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh lh li lj lk bi translated"><strong class="jm io">重要！</strong>现在，指向我的包的节点(<code class="fe ki kj kk kl b">node_modules/@scope-name/…</code>)的命令<code class="fe ki kj kk kl b">cmd + click</code>不仅显示了我的函数/类/组件的压缩jsDoc，就像使用<code class="fe ki kj kk kl b">d.ts</code>一样，还显示了完整的实现，因为它现在是一个完整的文件，您可以在其中立即分析实体的所有细节。</li></ol><p id="c3c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将补充最后一点，因为这是一个非常令人痛苦的话题，当你结合你自己的NPM包开发你的项目，当你从节点模块进入实体时，你得不到你的问题的答案，然后你再一次打开第二个项目，用这个NPM包的实现进行一些“深入”的分析——这一切都非常令人困惑。现在，这个动作不再相关，因为源代码位于节点模块中，并且对于此时此地的感知是尽可能清晰的。</p><blockquote class="ls lt lu"><p id="7f56" class="jk jl lv jm b jn jo jp jq jr js jt ju lw jw jx jy lx ka kb kc ly ke kf kg kh ig bi translated">为您的应用和团队创建方便的系统！你不应该追逐想象中的普遍性，这(根据经验)你在短期内不会实现。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/273a6beb03d1f859118ed265b6325e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B_jIqcKPBdBt1agY"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Priscilla Du Preez</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="a2cb" class="mg mh in bd mi mj mk dn ml mm mn dp mo jv mp mq mr jz ms mt mu kd mv mw mx my bi translated">一些实现细节</h2><ul class=""><li id="8b6c" class="lc ld in jm b jn mz jr na jv nh jz ni kd nj kh ne li lj lk bi translated">我从<code class="fe ki kj kk kl b">package.json</code>中删除了<code class="fe ki kj kk kl b">main</code>和<code class="fe ki kj kk kl b">types</code>指令，因为我们不再有索引文件，所有的调用都是“直接的”</li><li id="a5d3" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">在源文件中，索引文件也被删除</li><li id="544a" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">在NPM包的<code class="fe ki kj kk kl b">tsconfig.json</code>中，你必须指定<code class="fe ki kj kk kl b">includes</code>(不是<code class="fe ki kj kk kl b">files</code>)指令指向带有我们ts代码的文件夹。TypeScript编译器将理解您需要处理该文件夹中的每个文件，并将按顺序开始编译它们</li><li id="d476" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">把已发布的NPM包中使用的所有东西都移到了<code class="fe ki kj kk kl b">peerDependencies</code>(等待npm7，谁知道，他会明白的:)</li><li id="3599" class="lc ld in jm b jn ll jr lm jv ln jz lo kd lp kh ne li lj lk bi translated">在主应用程序的<code class="fe ki kj kk kl b">tsconfig.json</code>中，我们需要添加带有NPM包路径的<code class="fe ki kj kk kl b">path</code>指令，这样编译器就可以解析包的路径。这是因为在使用<strong class="jm io"> ts-modules </strong>时，没有带有声明空间<code class="fe ki kj kk kl b">declare module’ @name...’</code>的<code class="fe ki kj kk kl b">index</code>文件+在<code class="fe ki kj kk kl b">package.json</code>中没有对它的引用。虽然这个d.ts文件可以手动创建…</li></ul></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h2 id="a591" class="mg mh in bd mi mj mk dn ml mm mn dp mo jv mp mq mr jz ms mt mu kd mv mw mx my bi translated">特别焦虑者的退路</h2><p id="5a39" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">作为后备，我们需要修改NPM包的组件，并添加带有<code class="fe ki kj kk kl b">name.min.js</code>的<code class="fe ki kj kk kl b">asset</code>文件夹(到<code class="fe ki kj kk kl b">public</code>)或带有已编译模块的<code class="fe ki kj kk kl b">es5/es6</code>文件夹。而且……我们的<strong class="jm io"> ts模块</strong>在<code class="fe ki kj kk kl b">public/ts</code>中。换句话说，我们将发布两个文件夹<code class="fe ki kj kk kl b">src</code>和<code class="fe ki kj kk kl b">dist</code>。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="bef7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的文章中，我将继续讨论NPM在大型项目中的能力(<a class="ae lr" href="https://podumaihorosho.medium.com/composing-of-private-npm-packages-in-the-microfrontend-systems-86249c8075dd?source=your_stories_page-------------------------------------" rel="noopener">分解、工具</a>、<a class="ae lr" href="https://podumaihorosho.medium.com/npm-i18n-internationalization-25da8201b3b8" rel="noopener"> i18n </a>等)。)</p></div></div>    
</body>
</html>