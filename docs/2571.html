<html>
<head>
<title>Learning TypeScript: Concept Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习类型脚本:概念概述</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-typescript-concept-overview-1d9cf7429dd1?source=collection_archive---------1-----------------------#2021-05-27">https://javascript.plainenglish.io/learning-typescript-concept-overview-1d9cf7429dd1?source=collection_archive---------1-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9f19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">在Rust之后，TypeScript在</em> <a class="ae kj" href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> Stack Overflow的2020年开发者调查</em> </a> <em class="ki">中排名第二。我决定加入炒作。</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/9144aa66346c7923ed4c5ce947100990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXofLt4bZ7JEThATnyhP4A.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo from <a class="ae kj" href="https://serokell.io/blog/why-typescript" rel="noopener ugc nofollow" target="_blank">https://serokell.io/blog/why-typescript</a></figcaption></figure><h2 id="0ed9" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">TypeScript的简单内容和原因</h2><p id="698b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">TypeScript由微软开发，于2012年发布，旨在解决JavaScript在构建大规模应用程序时的各种缺点，即JavaScript无法像严格语言那样检查和通知开发人员某个代码区域何时会破坏其他区域。作为一种静态脚本语言，TypeScript为Javascript增加了力量，因为它会检查你的代码中的错误，类似于一种更严格的编程语言。</p><p id="ee34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<em class="ki">类型系统，</em>其中<em class="ki"> </em>描述了正在使用的变量的数据类型，TypeScript是JavaScript的超集，这意味着它由JavaScript的特性组成，并且还提供额外的特性。这种类型的系统将帮助我们找到潜在的错误。</p><p id="dd67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript的一些附加功能和特征包括:</p><ul class=""><li id="8926" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">支持函数的可选参数</li><li id="f8d8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">包含<strong class="jm io"> <em class="ki">接口</em> </strong>在代码中定义契约</li><li id="846b" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">IDE工具 — TS将在错误的代码下加下划线</li><li id="598c" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">重构工具</strong>——因为TypeScript理解代码中的引用和符号，所以在一个地方更改变量名会在其他地方更改它</li><li id="f315" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">称为面向对象编程语言，而Javascript是支持面向对象编程的脚本语言</li></ul><p id="770b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段摘自<a class="ae kj" href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html#static-type-checking" rel="noopener ugc nofollow" target="_blank">打字手册</a>的摘录很好地总结了这一点:</p><blockquote class="mm"><p id="13fc" class="mn mo in bd mp mq mr ms mt mu mv kh dk translated">静态类型系统描述了当我们运行程序时，我们的价值观的形状和行为。像TypeScript这样的类型检查器使用这些信息，并告诉我们什么时候事情可能会出错。</p></blockquote><h2 id="034d" class="la lb in bd lc ld mx dn lf lg my dp li jv mz lk ll jz na ln lo kd nb lq lr ls bi translated">如何使用TypeScript</h2><p id="24ab" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">基于每个项目安装TypeScript:</p><p id="9eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nc nd ne nf b">npm install typescript --save-dev</code></p><p id="8c0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全局安装(以便TypeScript在所有项目中都可用):</p><p id="aa97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nc nd ne nf b">npm install -g typescript</code></p><p id="87c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript以扩展名<code class="fe nc nd ne nf b">.ts</code>写入文件。这些文件中的所有代码都通过TypeScript<strong class="jm io"/><a class="ae kj" href="https://en.wikipedia.org/wiki/Source-to-source_compiler" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">trans compiler</strong></a>(它将源代码作为输入，并以相同或不同的编程语言生成等效的源代码)运行。接下来，如果成功，transcompiler将输出文件的Javascript版本。</p><p id="4ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用transcompiler，请在命令行中运行<code class="fe nc nd ne nf b">tsc [filename]</code>。这个命令将运行代码，指出代码转换器在命令行中发现的任何错误，如果没有错误，将在同一个目录中创建一个等效的<code class="fe nc nd ne nf b">.js</code>文件。</p><p id="146b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们先举一个例子:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="964f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行<code class="fe nc nd ne nf b">tsc example1.ts</code>会导致以下错误:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ni"><img src="../Images/0273ee19882393834d76ef1e57346ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Brns0coDKx7BU0iMoX3hjg.png"/></div></div></figure><p id="732e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当创建变量并将其赋给特定值时，Typescript可以推断其数据类型。这里，<code class="fe nc nd ne nf b">firstName</code>是一个字符串——当我们运行这个文件时，我们看到Typescript不允许我们将一个变量重新分配给不同的数据类型，即从字符串到数字。这个例子演示了Typescript的一个关键特性，<strong class="jm io"> <em class="ki">类型推断</em> </strong>:在整个程序中，Typescript希望变量的数据类型与声明时赋给它的值的类型相匹配。</p><h2 id="b305" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">当打字稿不能推断时</h2><p id="8fc9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">然而，并不是所有的类型都很容易被TypeScript推断出来，例如当一个变量在没有被赋予初始值的情况下被声明时。在这些情况下，TypeScript将变量视为类型<code class="fe nc nd ne nf b">any</code>。</p><p id="d23b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这些变量被重新分配给不同的类型，TypeScript将不会抛出任何错误。</p><h2 id="eb5c" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">类型注释</h2><p id="e72f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果我们想定义一个变量，但没有给它赋值，但又要确保它只被赋予特定类型的值，那该怎么办呢？在这种情况下，我们可以利用<strong class="jm io"> <em class="ki">类型注释</em></strong>/类型声明在变量名之后，就像这样:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ff62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，通过将冒号<code class="fe nc nd ne nf b">:</code>附加到<code class="fe nc nd ne nf b">example</code>，我们将变量声明为一种没有初始值的字符串类型。然后，可以将该变量重新赋给任何字符串类型的值。</p><p id="460b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果我们试图将<code class="fe nc nd ne nf b">example</code>定义为字符串以外的任何东西，TypeScript将警告我们该变量不可赋给该类型。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/030cd09cc8d3fe83c1fc8e0b877aa92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*MBOcDdZgUvzCXyvP5WS8Ww.png"/></div></figure><p id="f7ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当TS代码被编译成JS时，注释被自动移除。</p><h1 id="709f" class="nk lb in bd lc nl nm nn lf no np nq li nr ns nt ll nu nv nw lo nx ny nz lr oa bi translated">定义类型</h1><p id="e51b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">有两种语法，<strong class="jm io">接口、</strong>和<strong class="jm io">类型别名</strong>，用于构建允许我们在类型注释之外编写类型的类型，<strong class="jm io"> </strong>用于当我们希望不止一次地使用同一个类型并通过单个名称引用它时。<strong class="jm io">接口</strong>和<strong class="jm io">类型别名</strong>可以在不同用例的程序中一起使用。</p><h2 id="973c" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">接口声明</h2><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="106d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当处理对象时，使用一个<strong class="jm io">接口</strong>允许我们显式地描述该对象的<em class="ki">形状</em>(它由什么组成)，然后通过在变量声明后面加上<code class="fe nc nd ne nf b">: TypeName</code>来声明JS对象匹配该接口的形状。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2484" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果您指定的常数与界面的形状不一致(参考。代码在左边)，TypeScript会注意到这一点并抛出一个警告:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ob"><img src="../Images/ec01a976d629ccdef2ea204a34c58325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVdmUwlV0whluk20E3TBww.png"/></div></div></figure><p id="395a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于TypeScript是建立在JavaScript及其对类/面向对象编程的支持之上的，所以我们也可以对类使用接口声明。</p><h2 id="4332" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">键入别名</h2><p id="9263" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">类型别名的语法类似于接口的语法:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7071" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">唯一真正的区别是在花括号前需要一个<code class="fe nc nd ne nf b">=</code>。类型别名和接口非常相似，但是，<strong class="jm io">声明合并</strong>不能扩展到类型别名。当在类型别名和接口之间进行选择时，还有一些额外的考虑要记住，但是一般来说，TypeScript <a class="ae kj" href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" rel="noopener ugc nofollow" target="_blank"> handbook </a>声明:</p><blockquote class="oc od oe"><p id="d2ed" class="jk jl ki jm b jn jo jp jq jr js jt ju of jw jx jy og ka kb kc oh ke kf kg kh ig bi translated">你应该喜欢<code class="fe nc nd ne nf b">interface</code>。当您需要特定功能时，使用<code class="fe nc nd ne nf b">type</code>。</p></blockquote><h2 id="c7ac" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">什么是声明合并？</h2><p id="2ac0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">仅适用于接口，<strong class="jm io">声明合并</strong>发生在两个或两个以上接口同名并合并为一个的情况下。举个例子:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2abf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，当我们使用<code class="fe nc nd ne nf b">Artist</code>接口时，我们将可以访问这两个属性。</p><h2 id="8b58" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">TS中的可用类型</h2><p id="545f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">TypeScript中的类型类别包括<strong class="jm io">内置</strong>、<strong class="jm io">自定义</strong>以及<strong class="jm io">任意</strong>(类型的超集，将退出类型检查)。</p><p id="a94c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">原始/内置类型:</em></p><ul class=""><li id="2943" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">线</li><li id="4173" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">数字</li><li id="29a1" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">布尔型</li><li id="4b0e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">空</li><li id="a86d" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">不明确的</li><li id="972c" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">void —用于不返回值的函数中</li></ul><p id="1dc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">用户自定义类型:</em></p><ul class=""><li id="2ffe" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><strong class="jm io">数组</strong>:根据组成数组的类型，在TS中称为<code class="fe nc nd ne nf b">type[]</code>，即<code class="fe nc nd ne nf b">number[]</code>表示数字数组</li><li id="1b68" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> Tuple </strong>:不同(未知)类型的数组，即<code class="fe nc nd ne nf b">[string, number]</code>。<strong class="jm io"> <em class="ki">只能由类型别名声明(不是接口)</em> </strong></li><li id="9f88" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">枚举</strong> —一组命名的常量</li><li id="8170" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">界面</strong></li><li id="cdeb" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">类</strong></li></ul></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h2 id="2e20" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">主要要点</h2><p id="f404" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">有一些主要的概念我还没有涉及到，包括联合和泛型，如何给接口和类型添加属性，等等。但到目前为止，学习TypeScript的结构化类型规则令人惊讶地加深了我对JavaScript的特性、用途和局限性的理解。我学得越多，就开始明白为什么开发人员喜欢这种语言。</p><p id="8e66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae kj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">plain English . io</em></a></p></div></div>    
</body>
</html>