<html>
<head>
<title>useToggleSet: Custom React Hook for Toggling Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">useToggleSet:用于切换元素的自定义React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hook-usetoggleset-7e84649c7b50?source=collection_archive---------16-----------------------#2021-04-14">https://javascript.plainenglish.io/react-hook-usetoggleset-7e84649c7b50?source=collection_archive---------16-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c02ecc63f61a7153e5e7284fb27a13c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MjXMrpr5sEGSXtgU"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@m_k_nd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mukund Nair</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="655b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开和关闭一组元素是现代web服务的常见部分。一个用例是在搜索时选择要过滤的属性，另一个用例是选择应该包含在请求中的项目。</p><p id="acbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此编写逻辑通常很简单，但是反复编写有点麻烦。最近我在一个项目中遇到了这个问题，我想分享一下如何使用一个可重用的钩子来一劳永逸地解决这个问题。</p><p id="fe95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，这篇文章是React独有的，因为它需要hook API。</p><h2 id="ec5f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">冰淇淋店示例</h2><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/e3918aae0e69eb72b318d8a583d0856d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5flmTa_SkslC1zYu"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lamaroscu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lama Roscu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b112" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将用一家冰淇淋店作为例子来说明我们所写的逻辑。我们假设用户可以选择任意数量的口味来制作一个冰淇淋。</p><p id="e6ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用一组薯片来表示，每一片都有“香草”、“巧克力”和其他熟悉的冰淇淋口味的名字。</p><p id="82a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，用户可以随心所欲地选择和取消选择每种口味。在底部，我们将向用户展示一整套活跃的味道。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="414b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经用完成的钩子实现了这一点。继续看一看，测试一下逻辑，然后让我们看看实现的细节。</p><h2 id="a19f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">hooks/useToggleSet.ts</h2><p id="1896" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">我们将创建一个钩子，它使用React默认的<code class="fe md me mf mg b">useState</code>钩子，因为我们知道这在跟踪状态和用新数据更新状态方面已经很健壮了。</p><p id="9f83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> TypeScript: </strong>我们希望跟踪类型，所以我们将它作为类型<code class="fe md me mf mg b">T</code>的通用函数，这将是我们的钩子将要处理的元素的类型。</p><p id="e805" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将接受类型为<code class="fe md me mf mg b">T</code>的<code class="fe md me mf mg b">initialSet</code>，这是我们的初始活动集。请注意，我们不接受代表整个可能元素集的任何参数。我们也可以这样做，但是特别是如果使用TypeScript，泛型类型<code class="fe md me mf mg b">T</code>的限制对于大多数用例应该是足够的。</p><p id="75da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe md me mf mg b">useState</code>，我们定义了<code class="fe md me mf mg b">activeSet</code>，代表当前选择的元素，以及函数<code class="fe md me mf mg b">setActiveSet</code>，将这个选择更改为任何其他的任意集合。</p><p id="d7e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将方法<code class="fe md me mf mg b">toggleElement</code>定义为一种打开和关闭类型<code class="fe md me mf mg b">T</code>的任何给定元素的方式。方法相当简单:如果元素已经在我们的活动元素列表中，我们就删除它。如果没有，我们包括它。</p><p id="5601" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们将<code class="fe md me mf mg b">activeSet</code>和<code class="fe md me mf mg b">toggleElement</code>函数作为双元素长度数组返回，以努力与React hooks语法保持一致。我们返回数组<code class="fe md me mf mg b">as const</code>来表明我们的钩子初始化将只返回这两个变量，按照特定的顺序。这使得TypeScript能够正确识别<code class="fe md me mf mg b">activeSet</code>和<code class="fe md me mf mg b">toggleElement</code>的类型，而不管它们在使用我们的钩子的组件中的命名。</p><h2 id="9c1d" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">源代码:</h2><pre class="ls lt lu lv gt mh mg mi mj aw mk bi"><span id="f37f" class="ky kz in mg b gy ml mm l mn mo">import { useState } from "react";</span><span id="02e1" class="ky kz in mg b gy mp mm l mn mo">function useToggleSet&lt;T&gt;(initSet?: T[]) {</span><span id="a9c2" class="ky kz in mg b gy mp mm l mn mo">  const [activeSet, setActiveSet] = useState(initSet || ([] as T[]));</span><span id="be8f" class="ky kz in mg b gy mp mm l mn mo">  const toggleElement = (element: T) =&gt; {</span><span id="0c0c" class="ky kz in mg b gy mp mm l mn mo">    if (activeSet.includes(element)) {</span><span id="44df" class="ky kz in mg b gy mp mm l mn mo">      setActiveSet(activeSet.filter(el =&gt; el !== element));</span><span id="2f91" class="ky kz in mg b gy mp mm l mn mo">    } else {</span><span id="7793" class="ky kz in mg b gy mp mm l mn mo">      setActiveSet(activeSet.concat(element));</span><span id="4b80" class="ky kz in mg b gy mp mm l mn mo">    }</span><span id="6ff9" class="ky kz in mg b gy mp mm l mn mo">  };</span><span id="6ebd" class="ky kz in mg b gy mp mm l mn mo">  return [activeSet, toggleElement] as const;</span><span id="7b7b" class="ky kz in mg b gy mp mm l mn mo">}</span><span id="f729" class="ky kz in mg b gy mp mm l mn mo">export default useToggleSet;</span></pre><h2 id="993d" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">考虑</h2><p id="4931" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">非常简单，嗯？</p><p id="938d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以目前的形式，这应该可以完美地用于原语；对象不太好。允许对象的最好方法可能是采用第二个参数来确定相等性。另一种方式可以是在所有传入元素上运行的序列化函数。在我目前的用例中，我不需要这样做，所以我没有费心去实现它，尽管如果有人要求，我可能会去做。</p><p id="937e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就这样了！一个实现自定义React钩子的超级简单的方法，允许我们轻松地打开和关闭一组元素。因为这实际上只是useState的更新功能的包装，所以没什么大不了的！尽情享受，自由使用！</p><p id="e62a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mq">plain English . io</em></a></p></div></div>    
</body>
</html>