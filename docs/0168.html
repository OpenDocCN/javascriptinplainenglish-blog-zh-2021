<html>
<head>
<title>Refactoring Promise Chains w/Async-Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构带有异步等待的承诺链</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/refactoring-promise-chains-w-async-await-d126c7fac3a8?source=collection_archive---------2-----------------------#2021-01-10">https://javascript.plainenglish.io/refactoring-promise-chains-w-async-await-d126c7fac3a8?source=collection_archive---------2-----------------------#2021-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="4631" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在我永无止境的重构和精炼代码的旅程中，我最近的努力是在<code class="fe km kn ko kp b">async-await</code>的帮助下编写更干净、更易读的代码</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/3f43f78fa29d1d03803fa6cc10f29512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlZuyMISHKZIgp0psATqxw.jpeg"/></div></figure><p id="e4fb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">直到最近，我只在编写React代码的环境中使用JavaScript &amp; <code class="fe km kn ko kp b">Promises</code>。至于异步代码和<code class="fe km kn ko kp b">Promises</code>,我仅有的用例是编写对API的<code class="fe km kn ko kp b">fetch()</code>调用。它通常看起来像这样:</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="1395" class="lf lg in kp b gy lh li l lj lk">function getUsers(){<br/>   fetch('https://some-url-here.com/')<br/>   .then(resp =&gt; resp.json()<br/>   .then(data =&gt; someFunctionToUseReturnedData(data))<br/>   .catch(err =&gt; console.log(err))<br/>}</span></pre><p id="b7b2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">熟悉上面代码的人都知道，JavaScript的fetch API利用了<code class="fe km kn ko kp b">Promises</code> &amp;，通过将后续的<code class="fe km kn ko kp b">Promises</code>链接在一起，实现了异步功能。调用<code class="fe km kn ko kp b">fetch()</code>会返回一个<code class="fe km kn ko kp b">Promise</code>，任何后续的<code class="fe km kn ko kp b">.then()</code>或<code class="fe km kn ko kp b">.catch()</code>调用也是如此，然后每个调用都必须被处理。如果您需要快速复习，下面显示了<code class="fe km kn ko kp b">Promise</code>的“生命周期”以供参考:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/de1af4b48302af2983453fcffcadaab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mBlni5vsYZE2wFzfVv8EA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Promise lifecycle</figcaption></figure><p id="2c03" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">像这样一个简单的API调用很容易阅读和理解，但是一旦你的逻辑和用例变得越来越复杂，“可读性”因素就很容易远离你了。当我开始使用Node/Express/MongoDB作为我的后端API的堆栈时，情况确实如此。在MongoDB中处理复杂的集合和文档以及处理它们的关联，控制器函数中的链接<code class="fe km kn ko kp b">Promises</code>经常很快变得混乱和不可读。</p><p id="a8c1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">所以我决定最终利用<code class="fe km kn ko kp b">async-await</code>关键字，并重构我所有的现有代码，以便更同步地读取。让我们从上面那个简单的API获取调用开始，然后我将进入一些更详细的细节和另一个用例。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="9f90" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">首先，每个函数必须立即声明为异步的:</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="ae08" class="lf lg in kp b gy lh li l lj lk"><strong class="kp io"><em class="jp">async</em></strong> function getUsers(){<br/>   ...<br/>}</span></pre><p id="c8ae" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">这声明了零个或多个异步<code class="fe km kn ko kp b">await</code>表达式将出现在函数的上下文中。接下来，为了利用错误处理，我们将不再使用<code class="fe km kn ko kp b">.catch()</code>，因此我们可以将函数的内部代码包装在<code class="fe km kn ko kp b">try/catch</code>块中。</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="cae8" class="lf lg in kp b gy lh li l lj lk"><strong class="kp io"><em class="jp">async</em></strong> function getUsers(){<br/>   try{<br/>       ...<br/>   } catch(error){<br/>       console.log(error)<br/>   } <br/>}</span></pre><p id="0ce0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">接下来，我们可以通过使用<code class="fe km kn ko kp b">await</code>关键字来重构<code class="fe km kn ko kp b">Promise</code>链的<code class="fe km kn ko kp b">.then()</code>块。这里要理解的最大一点就是<code class="fe km kn ko kp b">await</code>关键词是阻塞。它阻止其余代码的执行，直到“幕后”发生的基于<code class="fe km kn ko kp b">Promise</code>的功能完成。所以记住这一点，一定要厌倦在一个异步函数中使用多少个<code class="fe km kn ko kp b">await</code>关键字。通常情况下，不仅仅是当一个<code class="fe km kn ko kp b">await</code>表达式的返回结果依赖于前一个表达式时，才需要使用多个<code class="fe km kn ko kp b">awaits</code>。通常，如果在一个<code class="fe km kn ko kp b">async</code>函数中有许多<code class="fe km kn ko kp b">awaits</code>，这可以被抽象成更小的<code class="fe km kn ko kp b">async</code>函数，这些函数可能会并行运行，因此可以加速代码的执行。</p><p id="beaa" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">现在是我们小代码的最后一个变化:</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="f5de" class="lf lg in kp b gy lh li l lj lk"><strong class="kp io"><em class="jp">async</em></strong> function getUsers(){<br/>   try{<br/>       const resp = <strong class="kp io"><em class="jp">await</em></strong> fetch('https://some-url-here.com/');<br/>       const data = <strong class="kp io"><em class="jp">await</em></strong> resp.json();<br/>       someFunctionToUseReturnedData(data);<br/>   } catch(error){<br/>       console.log(error)<br/>   } <br/>}</span></pre><p id="1c2f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">我们现在拥有了和以前完全一样的功能，但是没有使用链式承诺，并且以一种更简洁、同步的方式编写，不熟悉您的代码的人更容易理解。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="1b0c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">为了快速展示如何在后端Node.js环境中使用它，我将包括一个<code class="fe km kn ko kp b">Promise</code>链<code class="fe km kn ko kp b">(req/res)</code> &amp;的例子，然后是一个使用<code class="fe km kn ko kp b">async-await</code>关键字的重构版本</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="6865" class="lf lg in kp b gy lh li l lj lk">const Post = require('../models/post')<br/>const express = require('express')<br/>const router = express.Router();</span><span id="152e" class="lf lg in kp b gy mb li l lj lk">...</span><span id="711b" class="lf lg in kp b gy mb li l lj lk">router.get('/post/:id', (req, res, next) =&gt; {  <br/>   Post.findById(req.params.id)   <br/>      .then(post =&gt; {    <br/>         if (!post){    <br/>            const error = new Error('Could not find post');        <br/>            error.statusCode = 404;  <br/>            throw error;   <br/>         } else {    <br/>            res.status(200).json({      <br/>               post: post    <br/>            });   <br/>         }  <br/>      });   <br/>      .catch(error =&gt; {   <br/>         if (!error.statusCode){     <br/>            error.statusCode = 500;   <br/>         }    <br/>         next(error);  <br/>      })<br/>})</span></pre><p id="bb46" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">这里我们有一个<code class="fe km kn ko kp b">Promise</code>链来从数据库中获取一篇文章，或者以json格式发送回这篇文章，或者发送回一个错误，描述这篇文章无法找到，或者有一个服务器错误。现在让我们继续使用<code class="fe km kn ko kp b">async-await</code>关键字重写它</p><pre class="kr ks kt ku gt lb kp lc ld aw le bi"><span id="7ce6" class="lf lg in kp b gy lh li l lj lk">router.get('/post/:id', <strong class="kp io"><em class="jp">async</em></strong> (req, res, next) =&gt; {<br/>   try {<br/>      const post = <strong class="kp io"><em class="jp">await</em></strong> Post.findById(req.params.id)<br/>      if (!post){<br/>         const err = new Error('Could not find post');<br/>         err.statusCode = 404;<br/>         throw err;<br/>      } else {<br/>         res.status(200).json({<br/>            post: post<br/>         }) <br/>      }<br/>   } catch (error) {<br/>      if (!error.statusCode) error.statusCode = 500;<br/>      next(error);<br/>   }<br/>})</span></pre><p id="5f2f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">代码的行为和以前一样，但是没有了<code class="fe km kn ko kp b">Promise</code>链接，并且通过使用<code class="fe km kn ko kp b">async-await</code>它变得更加可读。简单的<code class="fe km kn ko kp b">await</code>表达式使得编写的代码更加同步。</p><p id="5cb5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">重构远离承诺链有助于提高可读性，尤其是在处理大型且不断增长的应用程序时。如果你想对async-await、Promises或Fetch API做更多的研究，下面是文档的链接。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="65c6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><em class="jp">【1】:异步函数文档(</em><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/async _ Function</a>)</p><p id="b14f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><em class="jp">【2】:Promise Docs(</em><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Global _ Objects/Promise</a>)</p><p id="1fe2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><em class="jp"> [3]:取API文档(</em><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"/>)</p></div></div>    
</body>
</html>