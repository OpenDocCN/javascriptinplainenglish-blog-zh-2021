<html>
<head>
<title>9 Best Practices to Know Before Creating Your Next Restful System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在创建下一个Restful系统之前要知道的9个最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-best-practices-to-know-before-creating-your-next-restful-system-e5226a2a6df9?source=collection_archive---------6-----------------------#2021-05-14">https://javascript.plainenglish.io/9-best-practices-to-know-before-creating-your-next-restful-system-e5226a2a6df9?source=collection_archive---------6-----------------------#2021-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0bc2ba9f9cb441ffec2c20a252c649bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIKLeDkfJBYugKiD5OSBhg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@sincerelymedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sincerely Media</a> on <a class="ae ja" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="76fe" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">REST架构是为Web服务创建交互式API的最常见的架构。REST是由Roy Fielding在2000年首次提出的。20年后，REST API几乎被所有企业使用。</p><p id="5bb7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">REST架构没有为API开发提供任何指南或标准。所有Restful API只需要遵循Roy Fielding创建的6个约束。你们大多数人都知道这6个约束:客户机-服务器架构、可缓存性、无状态性、分层系统、统一接口和按需编码。</p><p id="8b44" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于设计Rest API没有具体的指导原则，我们必须非常仔细地设计Rest API，这样在未来，我们就不会有任何与安全性、性能或易用性相关的问题。</p><p id="a5c3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自从REST问世20年以来，许多人都写过关于设计REST APIs的最佳实践。本文将着眼于创建rest API的9个最重要的实践。</p><h1 id="f406" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1)在Rest端点中总是用名词代替动词</h1><p id="2fc8" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在休息，动词已经出现在URI。我们应该始终避免在REST API的URI中引入动词。当您调用rest端点时，总是必须用请求定义HTTP方法。常见的HTTP方法如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c4d8" class="mk kz jd mg b gy ml mm l mn mo">POST: Create a new data in server<br/>GET: Retrieve data from server<br/>PUT: Update resource data in server<br/>PATCH:Update partial resource data in server<br/>DELETE: Delete data from server</span></pre><p id="79ed" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，这些HTTP方法已经在URI中引入了动词，所以引入另一个动词没有意义。以端点在博客服务中创建帖子为例。我们可以创建后URIs像下面两个端点。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="df2c" class="mk kz jd mg b gy ml mm l mn mo"><a class="ae ja" href="http://localhost:8081/v1/createnewblog" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/v1/createnewblog</a><br/><a class="ae ja" href="http://localhost:8081/v1/createnewblog" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/v1/</a>blogs</span></pre><p id="a789" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们调用这个POST方法，所以我们已经知道我们正在创建一个博客，在URL中添加“createnewblog”没有任何帮助。另外在URL中添加一个动词只会让用户感到困惑。假设如果我们选择在endpoint中添加“createnewblog”，那么endpoint将通过什么来检索blog，会是“<a class="ae ja" href="http://localhost:8081/v1/createnewblog" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/v1/get blog</a>”吗？如果我们不使用动词，这将非常容易，如果我们需要检索产品，我们可以使用URL http://localhost:8081/v1/blogs/{ blog Id }上的GET方法</p><h1 id="8c09" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2)端点上的逻辑嵌套是优选的，但不是强制的</h1><p id="c47a" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我在很多地方读到过，当您为rest设计端点时，总是建议您应该将包含相关信息的资源分组。这基本上意味着，如果某个对象包含另一个对象，它应该反映在URL中。</p><p id="393e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，每个博客都可以有评论。因此，检索特定博客端点的评论就像。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b2b8" class="mk kz jd mg b gy ml mm l mn mo">http://localhost:8081/v1/blogs/1/comments/</span></pre><p id="75f8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能还必须检索用户所做的评论，因此，您必须创建另一个URI。这是URI逻辑嵌套的问题之一，你必须创建一个冗余的URI来获得一个注释列表。嵌套的URI也会变得很长，比如你想让所有员工都在XYZ公司和ABC部门工作。URI对于这个请求会是这样的:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ed2e" class="mk kz jd mg b gy ml mm l mn mo">http://localhost:8081/v1/companies/XYZ/departments/ABC/employees</span></pre><p id="f6ea" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，当您的数据是严格分层的，嵌套不太深，并且关系不经常改变时，嵌套URI是首选。在其他情况下，在URI并不强制使用嵌套。你可以在URI <a class="ae ja" href="https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Sub-and-Nested-Resources/" rel="noopener ugc nofollow" target="_blank">这里</a>检查使用嵌套资源的利弊，并做出相应的选择。</p><h1 id="daca" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3)优雅地处理错误并返回标准错误代码</h1><p id="836e" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">优雅地处理错误非常重要。如果您收到错误的请求，那么整个服务就会停止，这真的没有意义。服务器应该总是抛出正确的错误，这样用户就可以知道什么是问题。所有Rest APIs都应该返回正确的HTTP响应代码，比如状态代码4**是为客户端错误保留的，5**是为服务器错误保留的。一些常见的rest代码如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a435" class="mk kz jd mg b gy ml mm l mn mo">400(Bad Request): It indicates something is wrong with request.<br/>401(Unauthorized): It indicates user is not able to authenticate.<br/>403(Forbidden): It indicates user don't have permission to access resource.<br/>404(Not Found): It indicates unable to found resource.<br/>500(Internal Server Error):<br/>502(Bad Gateway):<br/>503(Service Unavailable):</span></pre><p id="e552" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">错误处理不应该仅限于正确的HTTP代码。在错误响应中，错误的正确描述也应该与状态代码一起给出。例如，在下面的响应中，通过查看错误响应，我们可以确定我们没有在请求中传递客户id。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5464" class="mk kz jd mg b gy ml mm l mn mo">{<br/>     "error": {<br/>         "timeStamp": <!-- -->"18-07-2017 06:49:25"<br/>         "message": "Mandatory Parameter Customer Id is missing from      Request.",      <br/>         "status": "400",<br/>         "code": 0001<br/>     } <br/>}</span></pre><p id="8e00" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还可以在错误响应中添加一些其他信息，如脸书在其错误响应中也发送跟踪id。每个人都应该注意的一点是，对于一个组织内的所有REST API，所有的错误响应都应该是相同的。</p><h1 id="1a6b" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4)允许过滤、排序和分页</h1><p id="ad9e" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">有时候，您的REST API会有大量数据需要发送来响应。例如，一个用户可能想获得某个特定主题的所有博客。这样的博客可能有数百万个。如果您将在一次响应中返回整个列表，这可能会产生很多问题—例如，您可能会遇到内存不足的异常。支持分页总是必须的。用户也可能只需要访问所有博客的某个子集。喜欢用户只想访问一个月内创建的职位。在这种情况下，过滤会有所帮助</p><p id="48ea" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">过滤和分页都有助于我们提高API的性能。用户可能还需要根据特定的字段对响应进行排序，因此也应该支持排序。</p><h1 id="ebb3" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5)永远不要用纯文本回复</h1><p id="33f5" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">虽然不是REST强加的，但是大部分时候JSON是和Rest齐头并进的。响应JSON格式的请求而不是普通文本总是明智的。然而，仅仅在JSON中发送响应并不是您必须做的唯一事情。您还需要提供一个Content-Type头来响应值application/JSON。如果您愿意，也可以使用其他格式的响应，比如XML，但是XML响应并没有被广泛使用，因为它需要额外的处理。</p><h1 id="95ea" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">6)永远不要损害终端的安全性</h1><p id="c981" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">客户端和服务器之间的所有通信都应该受到保护。始终尝试为您的服务器启用TLS，因为它将保护传输中的数据。有了现代的库，启用SSL是非常容易的。</p><p id="9d92" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还需要启用适当的基于角色的访问控制。毕竟，没有人会喜欢他/她的信息被其他用户访问。您应该始终给予用户执行所需操作的最低权限。例如，如果某种类型的用户只能搜索资源，那么应该只授予调用搜索API所需的权限。还应该记住，在URL中发送任何敏感数据都是一个大忌。所以你永远不应该设计一个在URI接受密码的REST API。</p><h1 id="ef60" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">7)尽量采用OpenAPI规范</h1><p id="4831" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">根据OpenAPI规范的官方定义文档:</p><blockquote class="mp mq mr"><p id="9c99" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">OpenAPI规范(OAS)为RESTful APIs定义了一个标准的、与语言无关的接口，允许人类和计算机在不访问源代码、文档或通过网络流量检查的情况下发现和理解服务的功能。正确定义后，消费者可以用最少的实现逻辑理解远程服务并与之交互。</p></blockquote><p id="8fc1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在OpenAPI而不是实现API中，首先，在开发开始之前，合同文档就已经设计好并达成一致。这份合同大部分是用YAML文件写的，我们有各种工具，比如swagger editor，可以让你轻松编辑和阅读YAML的内容。甚至您的API的所有消费者都可以使用该契约生成一个客户端工具包，而不需要额外的信息。</p><p id="6bad" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OpenAPI附带了很多工具，这些工具不仅可以帮助你设计API，还可以在API的整个生命周期中提供帮助。你可以在这里了解更多关于OpenAPI规范<a class="ae ja" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="1669" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">8)哈特奥斯是你的朋友</h1><p id="1976" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">HATEOAS表示超文本是应用程序状态的引擎。这里的超文本指的是任何包含视频、音频、图像和文本等其他媒体链接的内容。在REST的上下文中，HATEOAS意味着作为响应，我们将链接到其他资源。仅以Github API为例，下面是1个示例响应。作为回应，您可以看到不同资源有许多URIs。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a4c5" class="mk kz jd mg b gy ml mm l mn mo">{<br/>   "pull_request": {<br/>     "patch_url": null,<br/>     "html_url": null,<br/>     "diff_url": null<br/>   },<br/>   "created_at": "2012-11-14T15:25:33Z",<br/>   "comments": 0,<br/>   "milestone": null,<br/>   "title": "New logo",<br/>   "body": "We should have one",<br/>   "user": {<br/>     "login": "pengwynn",<br/>     "gravatar_id": "7e19cd5486b5d6dc1ef90e671ba52ae0",<br/>     "avatar_url": "<a class="ae ja" href="https://secure.gravatar.com/avatar/7e19cd5486b5d6dc1ef90e671ba52ae0?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png" rel="noopener ugc nofollow" target="_blank">https://secure.gravatar.com/avatar/7e19cd5486b5d6dc1ef90e671ba52ae0?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png</a>",<br/>     "id": 865,<br/>     "url": "<a class="ae ja" href="https://api.github.com/users/pengwynn" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/pengwynn</a>"<br/>   },<br/>   "closed_at": null,<br/>   "updated_at": "2012-11-14T15:25:33Z",<br/>   "number": 17,<br/>   "closed_by": null,<br/>   "html_url": "<a class="ae ja" href="https://github.com/pengwynn/api-sandbox/issues/17" rel="noopener ugc nofollow" target="_blank">https://github.com/pengwynn/api-sandbox/issues/17</a>",<br/>   "labels": [<br/>     {<br/>       "color": "ededed",<br/>       "name": "design",<br/>       "url": "<a class="ae ja" href="https://api.github.com/repos/pengwynn/api-sandbox/labels/design" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/pengwynn/api-sandbox/labels/design</a>"<br/>     }<br/>   ],<br/>   "id": 8356941,<br/>   "assignee": null,<br/>   "state": "open",<br/>   "url": "<a class="ae ja" href="https://api.github.com/repos/pengwynn/api-sandbox/issues/17" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/pengwynn/api-sandbox/issues/17</a>"<br/> }</span></pre><p id="b846" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些链接帮助我们的API的消费者进一步探索API的资源。就像如果你需要用户的头像，你真的不需要去文档。它的URI已经出现在响应中，您只需要使用那个URI并获取图像。</p><h1 id="a410" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">9)版本控制</h1><p id="9f93" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">每当您必须对请求或响应结构进行更改时，总有可能会破坏某些客户的利益。在这种情况下，版本控制可能是救命稻草。请求和响应中的所有更改都应该创建为API的单独版本。您的API的所有消费者可以逐渐转移到您的API的较新版本。版本化是一种比强迫所有消费者同时使用新版本API更好的方法。</p><p id="8b23" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多方法可以实现版本，最流行的方法是在端点本身维护版本。例如，在下面的端点V1是你的API的版本。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="678a" class="mk kz jd mg b gy ml mm l mn mo"><a class="ae ja" href="http://localhost:8081/v1/createnewblog" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/v1/</a>blogs/1/comments/</span></pre><p id="e051" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们在REST API的端点中维护版本时，这会使HATEOAS实现变得复杂，因为作为响应，您必须为所有资源添加一个版本。版本也可以在查询字符串中传递，甚至可以通过创建一个新的Rest API自定义头来传递。同样，这两种方法也会受到影响，因为它们会使HATEOAS的实现变得复杂。</p><p id="58ad" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更友好的一种方法是在Accept头中传递版本信息，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5402" class="mk kz jd mg b gy ml mm l mn mo">GET <a class="ae ja" href="https://localhost:8081/blogs/3" rel="noopener ugc nofollow" target="_blank">https://localhost:8081/blogs/3</a> HTTP/1.1 <br/>Accept: application/vnd.medium.v1+json</span></pre><p id="e48c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们告诉服务器客户端需要我们API的v1，并且响应应该是JSON格式的。服务器将尽力满足这些要求并提供响应。</p><p id="e407" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在为您的组织选择正确的版本化方法时，您还应该考虑缓存。借助URI和查询字符串进行版本控制比其他两种方法更加缓存友好。对于自定义标头和客户标头，您可能需要编写额外的代码来实现缓存。</p><h1 id="19a5" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">结论</strong></h1><p id="f6f8" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Rest API乍看起来非常简单，但是设计完美的Rest API可能非常具有挑战性。设计一个Rest API有很多东西。强烈建议您在第一次设计API时花费时间和精力，以便在将来重新设计API时花费更少的时间。</p><p id="7978" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有任何疑问，请随时评论这篇文章。</p><h1 id="a9ed" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><div class="im in gp gr io mw"><a href="https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd je gy z fp nb fr fs nc fu fw jc bi translated">REST API设计的最佳实践——堆栈溢出博客</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">了解如何设计REST APIs，使其易于任何人理解，面向未来，安全且快速，因为它们服务于数据…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">stackoverflow.blog</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk iu mw"/></div></div></a></div><div class="im in gp gr io mw"><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd je gy z fp nb fr fs nc fu fw jc bi translated">API设计指南——云应用的最佳实践</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">大多数现代web应用程序公开了客户端可以用来与应用程序交互的API。一个设计良好的web API…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">docs.microsoft.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk iu mw"/></div></div></a></div><div class="im in gp gr io mw"><a href="https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Sub-and-Nested-Resources/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd je gy z fp nb fr fs nc fu fw jc bi translated">子资源和嵌套资源的REST API设计最佳实践</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">当我们开始设计一个API时，会出现很多问题，尤其是如果我们想创建一个REST API并遵循REST…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.moesif.com</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk iu mw"/></div></div></a></div><div class="im in gp gr io mw"><a href="https://medium.com/hashmapinc/rest-good-practices-for-api-design-881439796dc9" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd je gy z fp nb fr fs nc fu fw jc bi translated">REST:API设计的良好实践</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">设计您的REST API，以便它能被使用</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk iu mw"/></div></div></a></div><p id="334d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">更多内容尽在</em><a class="ae ja" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>