<html>
<head>
<title>Manage Dynamic and Custom Subdomains in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中管理动态和自定义子域</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/manage-dynamic-and-custom-subdomains-in-react-31154559694?source=collection_archive---------6-----------------------#2021-08-24">https://javascript.plainenglish.io/manage-dynamic-and-custom-subdomains-in-react-31154559694?source=collection_archive---------6-----------------------#2021-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/af2e76e9111c50c286a0ba81834ae621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1DB8m3n0OPxMi8Wy"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Duzij</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="66ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像hashnode.com<a class="ae jz" href="http://hashnode.com" rel="noopener ugc nofollow" target="_blank">这样的网站如何给每个用户一个单独的自定义域名？比如</a><a class="ae jz" href="https://parth2412.hashnode.dev/" rel="noopener ugc nofollow" target="_blank">https://parth 2412 . hash node . dev</a>。这个问题一直让我眼花缭乱。他们做这件事的方式就像魔术一样。或者至少我是这么想的。本文指导您在react应用程序中管理动态和自定义子域。</p><p id="6a94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将构建一个简单而简约的React应用程序，其中每个用户都将拥有一个基于其用户名的自定义子域，进入该子域将显示用户的个人资料，其中将包括用户的年龄、姓名和爱好。转到主域名会显示用户所有子域的链接。</p><p id="2e68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果用户的用户名为<em class="ky"> john </em>，年龄为<em class="ky"> 15 </em>，爱好为<em class="ky">足球和板球，</em>那么转到url <code class="fe kz la lb lc b">john.domain.com</code>将显示用户“john”的姓名(“john”)、年龄(15)和爱好(足球和板球)，其中<code class="fe kz la lb lc b">domain.com</code>被假定为我们应用程序的主要域。</p><p id="1a33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用户的数据将是虚拟数据，而不是来自数据库。</p><h1 id="bc95" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是子域？</h1><blockquote class="mb mc md"><p id="c82c" class="ka kb ky kc b kd ke kf kg kh ki kj kk me km kn ko mf kq kr ks mg ku kv kw kx ig bi translated"><em class="in">子域是主域名的附加项。本质上，一个子域是你的网站的一个独立的部分，在同一个主域名下运行。</em></p><p id="f621" class="ka kb ky kc b kd ke kf kg kh ki kj kk me km kn ko mf kq kr ks mg ku kv kw kx ig bi translated"><em class="in">您的主域名可能是“</em><a class="ae jz" href="http://bestwebdesigner.com" rel="noopener ugc nofollow" target="_blank"><em class="in">”bestwebdesigner.com</em></a><em class="in">，“而您可以向该域名添加一个子域，名为“</em><a class="ae jz" href="http://blog.bestwebdesigner.com" rel="noopener ugc nofollow" target="_blank"><em class="in">【blog.bestwebdesigner.com】</em></a><em class="in">”</em></p><p id="3507" class="ka kb ky kc b kd ke kf kg kh ki kj kk me km kn ko mf kq kr ks mg ku kv kw kx ig bi translated">子域给你创建一个全新网站的自由，同时仍然使用相同的域名。另外，你通常可以为你拥有的每个域名创建无限数量的子域名。</p></blockquote><p id="a873" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">来源:<a class="ae jz" href="https://www.hostgator.com/blog/whats-a-subdomain/" rel="noopener ugc nofollow" target="_blank">https://www.hostgator.com/blog/whats-a-subdomain/</a></p><p id="f394" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击<a class="ae jz" href="https://www.hostgator.com/blog/whats-a-subdomain/" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p><h1 id="4eb0" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">先决条件</h1><ul class=""><li id="2d70" class="mh mi in kc b kd mj kh mk kl ml kp mm kt mn kx mo mp mq mr bi translated">React基础知识(挂钩和功能组件)</li><li id="02c9" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">JavaScript基础(窗口对象和数组函数)</li><li id="c81f" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx mo mp mq mr bi translated">关于域和子域的基本知识</li></ul><p id="142f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先创建一个React应用程序。</p><pre class="mx my mz na gt nb lc nc nd aw ne bi"><span id="5d3a" class="nf le in lc b gy ng nh l ni nj">npx create-react-app dynamic-subdomains</span><span id="322b" class="nf le in lc b gy nk nh l ni nj">cd dynamic-subdomains</span></pre><p id="e04b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以随意命名您的应用程序。</p><h1 id="e272" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">你如何在本地主机上使用子域？</h1><p id="cb2c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">我认为在本地主机上使用子域需要相当多的配置。但是我大错特错了。例如，如果您的react应用程序运行在<a class="ae jz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> localhost:3000 </a>上，那么转到URL <code class="fe kz la lb lc b">john.localhost:3000</code>或<code class="fe kz la lb lc b">jane.localhost:3000</code>或任何其他子域仍会显示您的react应用程序。不需要配置。</p><h1 id="069a" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何在React中根据子域显示不同的内容？</h1><p id="cc57" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">下面的代码是我们如何使用<strong class="kc io">纯JavaScript从完整域访问子域。</strong></p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/2ac86e9d2cb0f784a6100df3812865cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8o3IhcLU663doVEN"/></div></div></figure><p id="a842" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看这里发生了什么</p><ol class=""><li id="8698" class="mh mi in kc b kd ke kh ki kl np kp nq kt nr kx ns mp mq mr bi translated">我们使用<code class="fe kz la lb lc b">window.location.host</code>获得应用程序的完整域名(只有域名，而不是完整的URL)。</li><li id="1fae" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">假设网址是<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/dear-developer-this-is-how-you-center-a-div-e526e7cfcc9d">https://JavaScript . plain English . io/dear-developer-this-is-how-you-center-a-div-e 526 e 7 cfcc 9d</a>那么主机将是<code class="fe kz la lb lc b">javascript.plainenglish.io</code></li><li id="8ab1" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">我们将域分割成一个数组，只要我们找到一个<code class="fe kz la lb lc b">.</code>。得到的数组将是<code class="fe kz la lb lc b">["javascript", "plainenglish" , "io"]</code></li><li id="0d73" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">如果主域是<strong class="kc io">而不是localhost </strong>，我们删除获得的数组的最后2个元素。最后一个元素是域的后缀，如。组织，。com，。网，。io等。获得的数组的倒数第二个元素将是应用程序的主域。</li><li id="9385" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">在示例中，数组的最后一个元素是后缀<code class="fe kz la lb lc b">io</code>。倒数第二个元素是主域<code class="fe kz la lb lc b">plainenglish</code>。因此，我们只剩下数组<code class="fe kz la lb lc b">["javascript"]</code></li><li id="2f8b" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">如果数组有0个元素，那么就没有子域。如果不是，子域是数组的第一个元素。因此子域是<code class="fe kz la lb lc b">javascript</code></li></ol><p id="1cdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个主要领域为<code class="fe kz la lb lc b">localhost</code>的开发示例</p><ol class=""><li id="69a2" class="mh mi in kc b kd ke kh ki kl np kp nq kt nr kx ns mp mq mr bi translated">假设主机(全域)是<code class="fe kz la lb lc b">sub.localhost:3000</code></li><li id="5e84" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">在我们找到一个<code class="fe kz la lb lc b">.</code>的地方分割域后，我们得到数组<code class="fe kz la lb lc b">["sub", "localhost:3000"]</code>。</li><li id="3f55" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">由于主域是localhost，这意味着该域没有诸如。所以我们只是从数组的末尾移除了1个元素，而不是2个。因此，我们只剩下数组<code class="fe kz la lb lc b">["sub"]</code></li><li id="13a1" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">如果数组有0个元素，那么就没有子域。如果不是，子域是数组的第一个元素。因此子域为<code class="fe kz la lb lc b">sub</code></li></ol><h1 id="3df1" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">注意</h1><p id="1728" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">子域也可以嵌套在许多级别下，即可以有多个子域，如<a class="ae jz" href="http://a.b.c.d.example.com" rel="noopener ugc nofollow" target="_blank">a.b.c.d.example.com</a>。但是本文将只关注处理一个级别的子域。</p><p id="6ffb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到我们的react应用程序，我们现在将看到上面的代码应该如何以react格式编写。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/b87457539bea77acb3cd525571a01c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W2kj6brO7gjNwU6R"/></div></div></figure><p id="8a09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生了同样的事情，但是我们不是在变量中存储子域，而是在React状态下存储子域，我们还在useEffect回调中提取子域。</p><p id="b381" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们为用户添加虚拟数据。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/ad9def1a2d1195a39c6498d134bd3a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pqYb90tv07eoN34o"/></div></div></figure><p id="5e06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们有一组用户。</p><p id="b826" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个用户都有一个唯一的用户名、年龄和爱好列表。</p><p id="4d07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以当我们转到网址<code class="fe kz la lb lc b">john.localhost:3000</code>时，会显示用户“约翰”的姓名、年龄和爱好。</p><p id="3804" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，URL <code class="fe kz la lb lc b">jane.localhost:3000</code>将显示用户“简”的姓名、年龄和爱好。</p><p id="099b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在这个应用程序中，每个用户将被分配一个子域(这将等于他们的用户名)，进入该子域将显示用户的姓名，年龄和爱好</p><p id="ddec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来也是最后一部分真的很简单。我们只需使用存储在状态中的<code class="fe kz la lb lc b">subdomain</code>值来显示适当的内容。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/515c33da9475e2f3254424dee2545798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4FT8kdbnBvGBmgUK"/></div></div></figure><p id="bef4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这么简单。</p><p id="64c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们获取<code class="fe kz la lb lc b">subdomain</code>，并使用它来查找其<code class="fe kz la lb lc b">username</code>与<code class="fe kz la lb lc b">subdomain</code>相同的用户，并将该用户存储在<code class="fe kz la lb lc b">requestedUser</code>变量中。</p><p id="9375" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有用户名与子域相同的用户，那么我们显示文本<em class="ky">未找到</em>。否则我们显示用户的姓名、年龄和爱好。</p><p id="657f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是它的样子(我使用端口3001，因为端口3000已经被使用)。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/473aa6d19904f8f7a6102ba0a8fcad6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wmfoToE0t-FCFSUw"/></div></div></figure><p id="3bbc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是当找不到请求的用户时网站的外观</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/9bc13855c5f3e13f0e272b6cfa8845a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j4GmSP2FvI_Jha3d"/></div></div></figure><p id="18a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们更进一步，让它没有子域，也就是说，当浏览网站的用户在我们的主域上时，我们会显示一个到所有用户子域的链接。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/8621076a466fe1a211a853bab6825bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MELQ6qlJB-z1uq9f"/></div></div></figure><p id="0684" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事情是这样的:</p><ol class=""><li id="cb5d" class="mh mi in kc b kd ke kh ki kl np kp nq kt nr kx ns mp mq mr bi translated">我们检查是否有子域。</li><li id="1adb" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">如果是，则显示被请求用户的数据</li><li id="1a23" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">如果没有，则显示所有用户子域的链接列表</li></ol><p id="88e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是它在主域上的样子。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/c89fe39b5721701a47ae07dea705edf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vR2DazqVVHMHucfD"/></div></div></figure><h1 id="119a" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">接下来</h1><p id="6bf4" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">如何在Next.js应用中处理动态子域？</p><h1 id="cb3c" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为生产配置子域</h1><p id="6094" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">大多数主机提供商允许配置动态子域。通常动态子域名在购买域名时是免费的。</p><ol class=""><li id="f784" class="mh mi in kc b kd ke kh ki kl np kp nq kt nr kx ns mp mq mr bi translated">韦尔塞尔:<a class="ae jz" href="https://vercel.com/blog/wildcard-domains" rel="noopener ugc nofollow" target="_blank">https://vercel.com/blog/wildcard-domains</a></li><li id="86a4" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">netlify:<a class="ae jz" href="https://docs.netlify.com/domains-https/custom-domains/multiple-domains/#branch-subdomains" rel="noopener ugc nofollow" target="_blank">https://docs . netlify . com/domains-https/custom-domains/multiple-domains/# branch-sub domains</a></li><li id="0e2e" class="mh mi in kc b kd ms kh mt kl mu kp mv kt mw kx ns mp mq mr bi translated">谷歌云:<a class="ae jz" href="https://cloud.google.com/appengine/docs/flexible/go/mapping-custom-domains#wildcards" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/app engine/docs/flexible/go/mapping-custom-domains #通配符</a></li></ol><p id="ed21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Github回购:【github.com/Parth-2412/Dynamic-Subdomains T4】</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="512e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">原发布于</em><a class="ae jz" href="https://parth2412.hashnode.dev/manage-dynamic-and-custom-subdomains-in-react" rel="noopener ugc nofollow" target="_blank"><em class="ky">https://parth 2412 . hash node . dev</em></a><em class="ky">。</em></p><p id="b327" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">更多内容看</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>