<html>
<head>
<title>Common Sorting Algorithms and their Complexities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见排序算法及其复杂性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/common-sorting-algorithms-and-their-complexities-f82b776c987?source=collection_archive---------22-----------------------#2021-06-14">https://javascript.plainenglish.io/common-sorting-algorithms-and-their-complexities-f82b776c987?source=collection_archive---------22-----------------------#2021-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ae7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对于需要排序算法复习的人</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/20d4982152e4cd60042fc4dbc14501f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NDu0pcePuRP6uhUO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ralexnder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Chumak</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="86c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，我们经常需要能够以有效的方式对数据进行排序。在本文中，我将向您介绍一些常见的高级排序算法及其时间复杂性。对于每一个，我都将包含一个简单的对数字数组进行排序的例子。</p><h1 id="3623" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">选择排序</h1><p id="7c3b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们从一个更简单的开始，选择排序。选择排序是一种在同一个数组中维护两个子数组的排序算法。其中一个数组是已经排序的数组，另一个是未排序的数组。下面是我们的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="81bd" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [9, 10, 5, 3, 0, 2, 7];</span></pre><p id="673d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，整个数组被认为是“未排序数组”在第一遍中，我们遍历整个数组并找到最小值。在这种情况下，它是0。我们取0并将其添加到排序后的数组中。现在，数组看起来像这样:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c99c" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [0, 10, 5, 3, 9, 2, 7];</span></pre><p id="832c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以把上面的看作两个数组。一个是带有[0]的已排序数组，另一个是带有[10，5，3，8，2，7]的剩余未排序数组。</p><p id="18d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们遍历，将2移到未排序数组的开头，与9交换。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7581" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [0, 2, 5, 3, 9, 10, 7];</span></pre><p id="cab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果继续下去，一旦我们遍历了未排序数组中的每个条目，最终整个数组都会被排序。</p><h2 id="b973" class="mu lt iq bd lu mz na dn ly nb nc dp mc lf nd ne me lj nf ng mg ln nh ni mi nj bi translated">时间复杂度</h2><p id="3668" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这需要两个循环。一种是跟踪我们在数组中的位置(也就是数组中已排序和未排序部分之间的边界)。另一个循环遍历数组的其余部分，查找最小元素。对于两个嵌套循环，该排序算法的时间复杂度是O(n)。</p><h1 id="1b53" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">冒泡排序</h1><p id="c0b9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">冒泡排序是另一种简单的方法，但效率不是很高。在冒泡排序算法中，通过交换无序的相邻元素，多次反复迭代数组。最终，最终的数组将被排序。让我们再次使用上面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c1c0" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [9, 10, 5, 3, 0, 2, 7];</span></pre><p id="40eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一遍中，遍历数组并交换任意两个相邻的无序元素。这是第一次传递的样子，它交换了几个元素，直到10到达最后:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1cdf" class="mu lt iq mq b gy mv mw l mx my">// PASS 1<br/>const unsortedArray = [9, 5, 10, 3, 0, 2, 7]; // swap 10 &amp; 5<br/>const unsortedArray = [9, 5, 3, 10, 0, 2, 7]; // swap 10 &amp; 3<br/>const unsortedArray = [9, 5, 3, 0, 10, 2, 7]; // swap 10 &amp; 0<br/>const unsortedArray = [9, 5, 3, 0, 2, 10, 7]; // swap 10 &amp; 2<br/>const unsortedArray = [9, 5, 3, 0, 2, 7, 10]; // swap 10 &amp; 7</span></pre><p id="b703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过几次交换后，数组中最大的数字10现在被移到了末尾。所以我们离结果更近了，但是目前为止。在下一次通过后，9将被移动到更靠近末端的位置。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b22a" class="mu lt iq mq b gy mv mw l mx my">// PASS 2<br/>const unsortedArray = [5, 3, 0, 2, 7, 9, 10];</span><span id="aeed" class="mu lt iq mq b gy nk mw l mx my">// PASS 3<br/>const unsortedArray = [3, 0, 2, 5, 7, 9, 10];</span><span id="1273" class="mu lt iq mq b gy nk mw l mx my">// PASS 4<br/>const unsortedArray = [0, 2, 3, 5, 7, 9, 10];</span></pre><p id="2be7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组现在已经排序了，尽管它仍然会经历7次顶级循环，除非您实现一个检查来查看数组是否已经排序。在最坏的情况下，将在所有7次传递中进行交换。</p><h2 id="9bbe" class="mu lt iq bd lu mz na dn ly nb nc dp mc lf nd ne me lj nf ng mg ln nh ni mi nj bi translated">时间复杂度</h2><p id="cf9b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这里的算法将总是运行O(n ),不管数组是否排序。你可以做一些检查来稍微改善这一点。</p><h1 id="b3fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">插入排序</h1><p id="6db3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">插入排序是一种算法，在这种算法中，你一个接一个地遍历数组，将每个数字移动到它后面相应的排序数组中的位置。以我们的阵列为例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5eb8" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [9, 10, 5, 3, 0, 2, 7];</span></pre><p id="2638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们迭代每个数字。当我们检查9和10时，从9 &gt; 10开始什么也没发生。然而，当我们到达5时，我们将9和10移动到右边的一个位置，为在正确的位置添加5创造空间:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8878" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [5, 9, 10, 3, 0, 2, 7];</span></pre><p id="9620" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法类似于选择排序，因为数组的左边是“排序数组”您只需不断地获取条目，并通过移动其余的条目，将它们插入到排序后的数组中的正确位置。</p><h2 id="08bc" class="mu lt iq bd lu mz na dn ly nb nc dp mc lf nd ne me lj nf ng mg ln nh ni mi nj bi translated">时间复杂度</h2><p id="95d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是嵌套循环的另一个例子。遍历一次，然后遍历排序后的数组，找到正确的位置，并在必要时移动元素。</p><h1 id="b8d9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">合并排序</h1><p id="df75" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">合并排序是一种递归排序算法。它使用分而治之的方法，将问题分解成更小的部分。您将数组分成两部分，对每一部分调用合并排序算法，然后在最后将它们组合起来。这是一个图表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/111d73fd1da6cba70dfb297ec214771f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0yGUZOdR0GMlNl1qLnUEg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/overview-of-merge-sort" rel="noopener ugc nofollow" target="_blank">https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/overview-of-merge-sort</a></figcaption></figure><p id="d8c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，数组被分成几部分，直到不能再分，数组长度为1。此时，merge()算法开始以正确的顺序合并它们，直到您再次拥有完整的数组。</p><h2 id="eedc" class="mu lt iq bd lu mz na dn ly nb nc dp mc lf nd ne me lj nf ng mg ln nh ni mi nj bi translated">时间复杂度</h2><p id="12da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">归并排序的时间复杂度为O(n log n)。每个问题被分解成两个子问题，直到达到一个，然后在合并过程中再次组合。</p><h1 id="824f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JavaScript的方式</h1><p id="ae45" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我真的很懒，所以这是我在大多数场景下首选的排序方式。在JavaScript中，你可以使用<a class="ae kv" href="https://www.w3schools.com/jsref/jsref_sort.asp" rel="noopener ugc nofollow" target="_blank">。sort()函数</a>，传入一个a-b函数参数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="08e5" class="mu lt iq mq b gy mv mw l mx my">const unsortedArray = [5, 9, 10, 3, 0, 2, 7];</span><span id="4c6d" class="mu lt iq mq b gy nk mw l mx my">unsortedArray.sort(function(a, b){return a-b});</span><span id="f262" class="mu lt iq mq b gy nk mw l mx my">console.log(unsortedArray); // [0,2,3,5,7,9,10]</span></pre><p id="746c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我对常用排序算法的概述。希望你喜欢这篇文章！</p><p id="b427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T5】plain English . ioT7】</a></p></div></div>    
</body>
</html>