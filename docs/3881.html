<html>
<head>
<title>Unsubscribe a Subscription with Angular in 5 ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过5种方式取消订阅Angular</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-5-ways-to-unsubscribe-a-subscription-a29259b66b04?source=collection_archive---------5-----------------------#2021-08-04">https://javascript.plainenglish.io/angular-5-ways-to-unsubscribe-a-subscription-a29259b66b04?source=collection_archive---------5-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2208" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">取消订阅</h2><div class=""/><p id="25b7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这篇文章中，我们将探索5种不同的方法来取消Angular的可观察订阅</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/a96a01b6d5a2f805b73514ee2abb7ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6h0v1aO_EGzUwTS8HRn5w.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">unsubscribing an subscription in Angular</figcaption></figure><p id="ac78" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">什么是有角的可观测值？<br/> </strong>可观察的是希望观察并采取行动的事物。Angular使用观察者模式，这意味着—可观察对象被注册，其他对象观察它们(在Angular中使用subscribe方法),并在可观察对象以某种方式受到作用时采取行动。<br/>可观察到的东西与承诺相似，但可观察到的东西和承诺之间还是有一些区别的。可观察的在事件发生后继续观察。我们可以在运行时取消观察。而承诺是不能取消的，因为我们只执行承诺一次。<br/>要使用observable，我们必须从名为<strong class="jy ja">反应式扩展(RxJS)的第三方库中导入它。</strong></p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="5839" class="lp lq iq ll b gy lr ls l lt lu">import { Observable } from 'rxjs/Observable';</span></pre><p id="f61c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">为什么我们需要取消订阅一个可观察的？<br/> </strong>正如我们所知，可观测量是事件，它拥有一些内存，我们需要在订阅发出值后从系统中释放这些内存。<br/>一个可观察的订阅有一个<strong class="jy ja"> unsubscribe() </strong>函数来释放资源/内存或者取消可观察的执行。</p><p id="81ab" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">以下是在Angular中订阅的4种不同方式</p><p id="2069" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">方法1:通过使用Unsubscribe方法<br/> </strong> Angular已经公开了一个生命周期钩子<strong class="jy ja"> ngOnDestroy()，</strong>，它在组件被销毁之前被调用。我们可以通过调用<strong class="jy ja"> unsubscribe() </strong>方法，用<strong class="jy ja"> ngOnDestroy() </strong>生命钩子来清理订阅。请查看下面的例子:</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="c1a1" class="lp lq iq ll b gy lr ls l lt lu">import { Component,OnInit,OnDestroy } from ‘<a class="ae lv" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import {Subscription} from ‘rxjs’;</span><span id="8826" class="lp lq iq ll b gy lw ls l lt lu"><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> selector: ‘app-root’,<br/> templateUrl: ‘./app.component.html’,<br/> styleUrls: [‘./app.component.scss’]<br/>})<br/>export class AppComponent implements OnInit, OnDestroy {<br/> $subscription: Subscription <br/> ngOnInit () {<br/> var observable = Rx.Observable.interval(1000);<br/> this.$subscription = observable.subscribe(x =&gt; console.log(x));<br/> }<br/> ngOnDestroy() {<br/> this.$subscription.unsubscribe()<br/> }<br/>}</span></pre><p id="ac3b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在上面的例子中，如果你看到我们已经创建了<strong class="jy ja"> $subscription </strong>对象，并且在<strong class="jy ja"> ngOnDestroy()中调用了<strong class="jy ja"> unsubscribe() </strong>方法。</strong>如果您有多个订阅，那么您必须在<strong class="jy ja"> ngOnDestroy()中调用unsubscribe()方法两次。</strong>请看下面的例子:</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="2953" class="lp lq iq ll b gy lr ls l lt lu">import { Component,OnInit,OnDestroy } from ‘<a class="ae lv" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import {Subscription} from ‘rxjs’;<br/><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> selector: ‘app-root’,<br/> templateUrl: ‘./app.component.html’,<br/> styleUrls: [‘./app.component.scss’]<br/>})<br/>export class AppComponent implements OnInit, OnDestroy {<br/> $subscriptionOne: Subscription<br/> $subscriptionTwo Subscription <br/> ngOnInit () {<br/> var observable = Rx.Observable.interval(1000);<br/> this.$subscriptionOne = observable.subscribe(x =&gt; console.log(x));<br/> this.$subscriptionTwo = observable.subscribe(x =&gt; console.log(x));<br/> }<br/> ngOnDestroy() {<br/> this.$subscriptionOne.unsubscribe();<br/> this.$subscriptionTwo.unsubscribe();<br/> }<br/>}</span></pre><p id="2da6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以将所有的订阅聚集在一个数组中，然后逐个取消订阅()。请参见下面的例子:</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="bd15" class="lp lq iq ll b gy lr ls l lt lu"><br/>import { Component,OnInit,OnDestroy } from ‘<a class="ae lv" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import {Subscription} from ‘rxjs’;<br/><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> selector: ‘app-root’,<br/> templateUrl: ‘./app.component.html’,<br/> styleUrls: [‘./app.component.scss’]<br/>})<br/>export class AppComponent implements OnInit, OnDestroy {<br/> $subscriptionOne: Subscription;<br/> $subscriptionTwo Subscription;<br/> $subscriptions: Subscription[] = [] <br/> ngOnInit () {<br/> var observable = Rx.Observable.interval(1000);<br/> this.$subscriptionOne = observable.subscribe(x =&gt; console.log(x));<br/> this.$subscriptionTwo = observable.subscribe(x =&gt; console.log(x));<br/> this.subscriptions.push(this.$subscriptionOne)<br/> this.subscriptions.push(this.$subscriptionTwo)<br/> }<br/> ngOnDestroy() {<br/> this.subscriptions.forEach((subscription) =&gt; subscription.unsubscribe())<br/> }<br/>}</span></pre><p id="0885" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在上面的例子中，我们有多个订阅()。我们将它们存储在一个subscription()数组中，并在ngOndestroy()中逐个取消订阅()，如上例所示。<br/> RxJs Observables subscribe()方法返回RxJs的订阅类型的对象。<br/>该订购代表可任意使用的资源。我们可以使用subscription()的add()方法将它们分组。add() <br/>方法会将一个子订阅附加到当前订阅。当您取消订阅()某个订阅时，它的所有子代都将被取消订阅。</p><p id="eb90" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">方法2:通过使用异步</strong> '|' <strong class="jy ja">管道<br/></strong><strong class="jy ja">aysnc</strong>管道是一个不纯的管道，它从它发出的可观察或承诺返回最新的值。当发出新值时，异步管道标记要检查的组件。当组件被破坏时，异步管道也取消订阅。请参见下面的例子:</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="9591" class="lp lq iq ll b gy lr ls l lt lu">import { Component,OnInit,OnDestroy } from ‘<a class="ae lv" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>’;<br/>import {Subscription} from ‘rxjs’;<br/><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> selector: ‘app-root’,<br/> styleUrls: [‘./app.component.scss’]<br/> template: `<br/> &lt;div&gt;<br/> Interval: {{observable$ | async}}<br/> &lt;/div&gt;<br/> `<br/>})<br/>export class AppComponent implements OnInit {<br/> observable$<br/> ngOnInit () {<br/> this.observable$ = Rx.Observable.interval(1000);<br/> }<br/>}</span></pre><p id="42a7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">方法3:通过使用RxJs take*运算符<br/> </strong>我们可以使用RxJs <strong class="jy ja"> take* </strong>族运算符来取消订阅()angular项目中的一个subscriptons。以下是我们可以用来取消订阅RxJs订阅的take*系列运算符:</p><ol class=""><li id="4138" class="lx ly iq jy b jz ka kd ke kh lz kl ma kp mb kt mc md me mf bi translated"><strong class="jy ja">取(n)运算符:</strong></li></ol><p id="1fba" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">取(n)个操作符执行'<strong class="jy ja"> n </strong>'次源订阅排放。take(n)运算符将在我们传递1时生效，它将只执行一个源订阅发射并取消订阅。</p><p id="91b9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在下面的例子中，我们将1传递给了take(n)操作符，它将只执行一次源订阅，并在执行后取消订阅。</p><p id="ce7e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">一旦发出第一个值，订阅将被取消订阅，即使在app-component被销毁后，订阅也不会被销毁。所以建议用<strong class="jy ja">ngOnDestory()</strong>life hooks退订订阅。</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="4bb7" class="lp lq iq ll b gy lr ls l lt lu"><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.scss']<br/>    <br/>})<br/>export class AppComponent implements OnInit {<br/>    subscription$<br/>    ngOnInit () {<br/>        var observable$ = Rx.Observable.interval(1000);<br/>        this.subscription$ = observable$.pipe(take(1)).<br/>        subscribe(x =&gt; console.log(x))<br/>     }<br/>}</span></pre><p id="ef18" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">方法4:通过使用自定义装饰器</strong></p><p id="9894" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以创建一个自定义装饰器来自动取消订阅Angular应用程序。请看下面的例子，我写了<strong class="jy ja"> ngUnsub() </strong>自定义指令来取消订阅Angular应用程序。它保存<strong class="jy ja"> ngonDestroy() </strong>并将其添加到类中。当一个类将要销毁时，它将扫描订阅。如果存在任何订阅，它将销毁所有订阅。</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="7dc7" class="lp lq iq ll b gy lr ls l lt lu">function ngUnsub() {<br/>    return function(constructor) {<br/>        const _autoUnsub = constructor.prototype.ngOnDestroy<br/>        constructor.prototype.ngOnDestroy = function() {<br/>            for(const prop in this) {<br/>                const ngprop = this[prop]<br/>                if(typeof ngprop.subscribe === "function") {<br/>                    ngprop.unsubscribe()<br/>                }<br/>            }<br/>            _autoUnsub.apply()<br/>        }<br/>    }<br/>}</span><span id="7d7e" class="lp lq iq ll b gy lw ls l lt lu"><a class="ae lv" href="http://twitter.com/ngUnsub" rel="noopener ugc nofollow" target="_blank">@ngUnsub</a>()<br/><a class="ae lv" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.scss']<br/>})<br/>export class AppComponent implements OnInit {<br/>    observable$<br/>    ngOnInit () {<br/>        this.observable = Rx.Observable.interval(1000);<br/>        this.observable$.pipe(first())<br/>        .subscribe(x =&gt; console.log(x));<br/>    }<br/>}</span></pre><p id="c19c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">方法5:通过使用TS lint <br/> </strong>我们可以通过向TS lint添加一个自定义规则来清理订阅，如果ngOnDestroy() lifehooks没有添加到组件中，我们会警告用户。</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="4c5d" class="lp lq iq ll b gy lr ls l lt lu">// ngOnDestroyRule.ts</span><span id="da30" class="lp lq iq ll b gy lw ls l lt lu">import * as Lint from "tslint"</span><span id="3969" class="lp lq iq ll b gy lw ls l lt lu">import * as ts from "typescript"</span><span id="b515" class="lp lq iq ll b gy lw ls l lt lu">import * as tsutils from "tsutils"</span><span id="b3d0" class="lp lq iq ll b gy lw ls l lt lu">export class Rule extends Lint.Rules.AbstractRule {</span><span id="96db" class="lp lq iq ll b gy lw ls l lt lu">public static metadata: Lint.IRuleMetadata = {</span><span id="e678" class="lp lq iq ll b gy lw ls l lt lu">ruleName: "ng-on-destroy",</span><span id="6d8c" class="lp lq iq ll b gy lw ls l lt lu">description: "Give Warning ngOnDestory hook on a ts classes",</span><span id="509f" class="lp lq iq ll b gy lw ls l lt lu">optionsDescription: "ngOnDestroy",</span><span id="f079" class="lp lq iq ll b gy lw ls l lt lu">options: null,</span><span id="b5a0" class="lp lq iq ll b gy lw ls l lt lu">type: "style",</span><span id="8b67" class="lp lq iq ll b gy lw ls l lt lu">typescriptOnly: false</span><span id="17d8" class="lp lq iq ll b gy lw ls l lt lu">}</span><span id="3564" class="lp lq iq ll b gy lw ls l lt lu">public static WARNING_STRING = "ngOnDestroy should be present in a ts class";</span><span id="ecfd" class="lp lq iq ll b gy lw ls l lt lu">public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {</span><span id="1d0b" class="lp lq iq ll b gy lw ls l lt lu">return this.applyWithWalker(new NgOnDestroyWalker(sourceFile, Rule.metadata.ruleName, void this.getOptions()))</span><span id="9e43" class="lp lq iq ll b gy lw ls l lt lu">}</span><span id="b627" class="lp lq iq ll b gy lw ls l lt lu">}</span><span id="52e6" class="lp lq iq ll b gy lw ls l lt lu">class NgOnDestroyWalker extends Lint.AbstractWalker {</span><span id="52dd" class="lp lq iq ll b gy lw ls l lt lu">visitClassDeclaration(node: ts.ClassDeclaration) {</span><span id="8492" class="lp lq iq ll b gy lw ls l lt lu">this.validateMethods(node)</span><span id="f7c6" class="lp lq iq ll b gy lw ls l lt lu">}</span><span id="5489" class="lp lq iq ll b gy lw ls l lt lu">validateMethods(node: ts.ClassDeclaration) {</span><span id="a07b" class="lp lq iq ll b gy lw ls l lt lu">const methodNames = node.members.filter(ts.isMethodDeclaration).map(m =&gt; m.name!.getText());</span><span id="b2e6" class="lp lq iq ll b gy lw ls l lt lu">const ngOnDestroyArr = methodNames.filter(methodName =&gt; methodName === "ngOnDestroy")</span><span id="3108" class="lp lq iq ll b gy lw ls l lt lu">if (ngOnDestroyArr.length === 0)</span><span id="8524" class="lp lq iq ll b gy lw ls l lt lu">this.addFailureAtNode(node.name, Rule.WARNING_STRING);</span><span id="147a" class="lp lq iq ll b gy lw ls l lt lu">}</span><span id="1e3e" class="lp lq iq ll b gy lw ls l lt lu">}</span></pre><p id="5322" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在上面的例子中，我们已经创建了一个定制的tslint规则，如果Angular中的组件/指令/管道中没有ngOnDestroy()生命挂钩，它将抛出一个异常。<br/>如果我们有一个角度组件类，并且不存在ngOnDestroy() lifehooks，那么将抛出below lint错误。</p><pre class="kv kw kx ky gt lk ll lm ln aw lo bi"><span id="c49d" class="lp lq iq ll b gy lr ls l lt lu">$ ng lint<br/>Error at app.component.ts 12: ngOnDestroy should be present in a ts class</span></pre><p id="6efc" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> <em class="mg">在本文中，我们讨论了在Angular应用中取消订阅的不同方式，以及如何在订阅执行后释放内存。</em> </strong></p><p id="4a21" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> <em class="mg">亲爱的读者，感谢您的支持和您宝贵的时间。我希望这是有用的，并有助于发现角度应用的基础。如果你喜欢这篇文章并在评论中留下你的想法，请鼓掌。</em> </strong></p><p id="7ffd" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> <em class="mg">请关注我并成为会员上</em> </strong> <a class="ae lv" href="https://medium.com/@technicadil_001/membership" rel="noopener"> <strong class="jy ja"> <em class="mg">中</em> </strong> </a> <strong class="jy ja"> <em class="mg">获取更多文章。干杯！</em>T13】</strong></p><p id="0e2a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><em class="mg">更多内容看</em> <a class="ae lv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> <em class="mg">说白了就是</em> </strong> </a> <em class="mg">。报名参加我们的</em> <a class="ae lv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> <em class="mg">免费周报</em> </strong> </a> <em class="mg">。关注我们</em> <a class="ae lv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> <em class="mg">推特</em> </strong> </a>，<a class="ae lv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jy ja"><em class="mg">LinkedIn</em></strong></a><em class="mg">，</em><a class="ae lv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jy ja"><em class="mg">YouTube</em></strong></a><em class="mg">，</em><a class="ae lv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><em class="mg">不和</em>  </a> <strong class="jy ja"> <em class="mg">。</em> </strong></p><p id="7cd9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> <em class="mg">有兴趣缩放你的软件启动</em> </strong> <em class="mg">？检查出</em> <a class="ae lv" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> <em class="mg">电路</em> </strong> </a> <em class="mg">。</em></p></div></div>    
</body>
</html>