<html>
<head>
<title>JavaScript on Steroids?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类固醇上的JavaScript？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-on-steroids-c96c57a33acc?source=collection_archive---------14-----------------------#2021-05-08">https://javascript.plainenglish.io/javascript-on-steroids-c96c57a33acc?source=collection_archive---------14-----------------------#2021-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/03ed9e77c7f13f27534a2fa600bddbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Pdjizwr_UTRGPuyhmIFOA.jpeg"/></div></div></figure><p id="3c90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重载您的本地JavaScript对象，以获得更好的可重用性和更干净的代码。</p><p id="c9c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">问题空间</strong></p><p id="34a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自从ES6推出以来，很多新的JavaScript方法出现了，比如map、reduce、find。这些都是代码的函数助手，使您可以轻松地操作和使用Javascript数据结构。</p><p id="ef99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们作为JavaScript开发人员的日常生活中，我们仍然一遍又一遍地编写相同的东西，这就是像Lodash这样的库发挥作用的地方。但是当人们争论为什么React的包大小是145KB而Angular的包大小是2.4MB时，真的需要这些吗？洛达什是一个令人印象深刻的图书馆，没有什么可以带走的。</p><p id="861d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我的解决方案</strong></p><p id="72d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用我们已经知道的东西来扩展JavaScript对象是一个可行的选择。ES6也提供了类，这只是语法上的糖，但是来自OOP背景会让你理解得更好，尽管JavaScript仍然有很多奇怪的地方。</p><p id="dd04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的日常工作中，我经常需要找到数组中某个元素的唯一出现。我需要检查一个元素是否存在于一个数组中，我觉得这是正常工作流的一部分，没有任何异常。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="da2c" class="lc ld in ky b gy le lf l lg lh">class PowerArray  extends Array {<br/> <br/>  checkIfExist(value){<br/>   return !!this.find(val=&gt;val==value)<br/>  }<br/>  unique(){<br/>    console.log(this)<br/>    return new PowerArray(...new Set(this))<br/>  }<br/>  sum(){<br/>   return this.reduce((val,acc)=&gt;val+acc,0)<br/>  }<br/>}</span><span id="8bc1" class="lc ld in ky b gy li lf l lg lh">const array=new PowerArray()<br/></span></pre><p id="488f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个实现中，您拥有一个数组本身提供的所有函数，以及添加的3个不同的方法。</p><p id="0e4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以像使用普通数组一样使用这个新数组，并将我们的方法与本机方法链接在一起。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1116" class="lc ld in ky b gy le lf l lg lh">array.push(1)<br/>array.push(2)<br/>array.push(2)<br/>console.log(array.unique().sum())//3<br/>console.log(array.sum())//5<br/>console.log(array.checkIfExist(7))//false</span></pre><p id="b3f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谈到另一个重要的数据结构，它在JavaScript世界中被大量使用——对象。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="cfb7" class="lc ld in ky b gy le lf l lg lh">class PowerObject extends Object{<br/>  getKeys(){<br/>   return Object.keys(this)<br/>  }<br/>  getValues(){<br/>    return Object.values(this)<br/>  }<br/>  prettyPrint(){<br/>    console.group('Object...')<br/>    console.log('Object Values',this)<br/>    console.groupEnd()<br/>  }<br/>  deepClone(){<br/>    const temp=JSON.stringify(this);<br/>    return Object.assign(new PowerObject(),JSON.parse(temp))<br/>  }<br/>}</span></pre><p id="d2a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里也使用了相同的概念，并且我们能够通过这段代码将3个更有用的方法附加到我们的应用程序中。</p><p id="2809" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于对象的克隆，我们经常使用扩展操作符</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1363" class="lc ld in ky b gy le lf l lg lh">const a = {...b}//works only with first level keys, shallow copy</span></pre><p id="c0c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种实现工作得非常好，除非你在b中有嵌套对象，当许多初学者希望这也能用于嵌套对象时，他们很难找到问题。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1649" class="lc ld in ky b gy le lf l lg lh">const myObject = new PowerObject();<br/>myObject['a']=5;<br/>myObject['b']={'m':'5'};<br/>const normalObject={...myObject}</span><span id="b37e" class="lc ld in ky b gy li lf l lg lh">normalObject.a=7;<br/>normalObject.b.m=6;</span><span id="b33a" class="lc ld in ky b gy li lf l lg lh">console.log(myObject)<br/>//a: 5 , b:{m:6} so the value of m is changed despite using the //spread operator</span></pre><p id="a053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">修复:</strong></p><p id="f902" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是如何工作的？当您将一个对象转换为字符串并解析回该对象时，它通过将它转换为通过值传递且不可变的原始类型来中断对初始对象的引用，这与通过引用传递的对象不同。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2ea0" class="lc ld in ky b gy le lf l lg lh">const normalObject = myObject.deepClone()//this will make a deep copy<br/>console.log(normalObject)<br/>normalObject.a = 7<br/>normalObject.b.m = 6<br/>myObject.prettyPrint()// the original object intact //YEAHHH<br/></span></pre><p id="473b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，其他方法也更加语法化，使您的工作更加整洁，代码更具可读性。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7da6" class="lc ld in ky b gy le lf l lg lh">myObject.getKeys() //["a", "b"]<br/>myObject.getValues() //[5, {…}]</span></pre><p id="24a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">于是，我们来到了文章的结尾。关键要点是什么？总是试图让你的代码库对你自己和你的同事来说更容易；过度工程在编程中是真实存在的，所以尽量避免。您可以通过创建自己的方法来巩固您的理解，并使您的代码尽可能地去耦合。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="6f88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">亲提示:</strong></p><p id="aa5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以将该类添加到条目文件或任何脚本文件中的window对象中，这样它们就可以在整个项目中使用，而无需到处导入。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="38da" class="lc ld in ky b gy le lf l lg lh">window.PowerClass=PowerClass </span></pre><p id="4707" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">避免使用与原生JavaScript中的函数或方法相同的名称。这对你可能弊大于利。</p><p id="6123" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">敬请关注更多内容。和平！</p><p id="ef8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lq">更多内容尽在</em><a class="ae lr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lq">plain English . io</em></a></p></div></div>    
</body>
</html>