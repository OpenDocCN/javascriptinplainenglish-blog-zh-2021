<html>
<head>
<title>How to compose NPM Packages for Microfrontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为微前端编写NPM包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/composing-of-private-npm-packages-in-the-microfrontend-systems-86249c8075dd?source=collection_archive---------1-----------------------#2021-01-10">https://javascript.plainenglish.io/composing-of-private-npm-packages-in-the-microfrontend-systems-86249c8075dd?source=collection_archive---------1-----------------------#2021-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="08a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在以前的文章中，我描述了如何以<a class="ae ki" href="https://podumaihorosho.medium.com/npm-packages-in-ts-modules-format-7f64aa87591" rel="noopener"> ts-modules </a>格式发布NPM包，并在整个系统中使用<a class="ae ki" href="https://podumaihorosho.medium.com/npm-i18n-internationalization-25da8201b3b8" rel="noopener">统一国际化</a>。今天，我将分享关于哪些其他NPM包在微前端中有用以及如何管理它们的信息，以及在大型系统中开发私有NPM包的细微差别。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2d8349764166241b351c53a29327c9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BDtyioNt957vFXhi"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@xavi_cabrera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Xavi Cabrera</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3aef" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM套餐的级别</h2><p id="9dc3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在全球范围内，我根据抽象级别对NPM包进行分类。从最抽象、稳定的，到更多变的，越来越接近系统的业务领域。通常，三个级别就足够了:</p><ol class=""><li id="dfd2" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated"><strong class="jm io">具有基本定义的级别</strong>。例如，DOM的实用程序、一组css变量、Webpack/esLint的配置以及整个系统的文档。这个级别的包尽可能的独立，通常根本不需要依赖。</li><li id="4714" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated"><strong class="jm io">常见业务实体级别</strong>。例如，用于GoogleAnalytics的实用程序，一组用于microfrontends的常量，一些用于授权/文件/错误处理的业务实用程序。</li><li id="abfe" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated"><strong class="jm io">成熟业务模块的级别</strong>。例如，组件库、客户端授权模块或反馈模块。也就是说，这是一个特定的成品特性，可以完全集成到任何微前端中，但其本身不是微前端。</li></ol><p id="c422" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，<strong class="jm io">只允许从一般到特定</strong>的导入，因此将遵守<strong class="jm io"> ADP </strong>原则。对了，我推荐在这里用<a class="ae ki" href="https://medium.com/@andrewMacmurray/package-principles-850d89da5e5b" rel="noopener">的建包原则来看</a>。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="0b91" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM的责任范围-包</h2><p id="5abf" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">具体来说，我根据<strong class="jm io"> CRP </strong>和<strong class="jm io"> CCP </strong>原则来划分NPM包:我将业务所有权置于技术亲和力之上。比如utilities:可以全部收藏在一个<code class="fe ms mt mu mv b">utils</code>包里，也可以分成<code class="fe ms mt mu mv b">utils-users</code>、<code class="fe ms mt mu mv b">utils-documents</code>等。好处是，当<code class="fe ms mt mu mv b">users</code>实用程序改变时，我们不会触及其余的实用程序——实用程序的发布周期将是独立的。</p><p id="53c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">有时</strong>需要从最新版本的NPM软件包中导入一个更新的特性，但是当这个软件包发布时，不仅这个特性发生了变化，而且其他十个相邻的特性也发生了变化。11个实体没有时间进行调整，因为只对业务计划进行了一次修订。发生这种情况的原因是，在设计NPM系统时，数据冗余的起始点确定不正确。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="fe4c" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM包装的命名</h2><p id="fd94" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">包名中的第一件事是<strong class="jm io">作用域</strong>。它通常相当于系统缩写。它需要支持节点的语义和对它们的调用(导入)。</p><p id="8f40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，NPM在发布时只允许一层嵌套。也就是:<code class="fe ms mt mu mv b">@scope-name/level1/package-name1</code>和<code class="fe ms mt mu mv b">@scope-name/level1/package-name2</code>——是同一个名为<code class="fe ms mt mu mv b">level1</code>的包。</p><p id="96df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了实现语义分层，我使用了<strong class="jm io">烤肉串盒</strong> : <code class="fe ms mt mu mv b">@scope-name/1-docs</code>或<code class="fe ms mt mu mv b">@scope-name/1-esLint</code>，或<code class="fe ms mt mu mv b">@scope-name/2-utils-amount</code>。数字名称，可以根据您的判断更改为更有意义的名称。</p><p id="0dd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果在第一层，有几个实用程序包，那么我们这样命名它们:<code class="fe ms mt mu mv b">@scope-name/1-utils<strong class="jm io">-amount</strong></code>、<code class="fe ms mt mu mv b">@scope-name/1-utils<strong class="jm io">-account</strong></code>、<code class="fe ms mt mu mv b">@scope-name/1-utils<strong class="jm io">-user</strong></code>。从而在节点树(<code class="fe ms mt mu mv b">node_modules</code>)中，它们彼此相邻。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mw"><img src="../Images/c19f29006b4238be1ab49962ef9e1ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufvANs-zfDqG5p9t"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3391" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM包的依赖性</h2><blockquote class="mx my mz"><p id="7da8" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">它<!-- -->禁止创建NPM包的循环依赖，如果你不能没有它们，那么最好复制部分功能。</p></blockquote><p id="5bb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们上<code class="fe ms mt mu mv b">peerDependencies</code>。但是首先，您需要从<code class="fe ms mt mu mv b">dependencies</code>中移除所有相关的私有NPM包，然后在<code class="fe ms mt mu mv b">devDependencies</code>和<code class="fe ms mt mu mv b">peerDependencies</code>中复制它们。这是必要的，首先是为了NPM制度内部的一致性。其次，为了“减轻”最终的js文件，因为没有人希望在他们的包中存储同一个包的两个版本。</p><blockquote class="mx my mz"><p id="e28d" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">当然，您不应该盲目地从<code class="fe ms mt mu mv b">dependencies</code>中删除所有依赖项。这个过程需要单独分析。但是现在，我先不说了。</p></blockquote><p id="9a6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过一个固定的主要版本来描述我们的NPM软件包的所有版本，例如:<code class="fe ms mt mu mv b">@scope-name/1-utils-dom: “2.x”</code>，因为我们不想遍历所有的NPM软件包并手动提升这些“无害的”版本。但是为了保持版本的一致性，我们必须使用SEMVER。</p><blockquote class="mx my mz"><p id="e20c" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">在进行了数百次采访后，我注意到，只有少数人知道<code class="fe ms mt mu mv b">dependencies</code>和<code class="fe ms mt mu mv b">devDependencies</code>的区别。通常大家只记得语义成分。</p><p id="2c7e" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated"><strong class="jm io">首先</strong>，只有当涉及到将在NPM发布的NPM包时，这种差异才会显现出来。那些不使用他们自己的NPM包并将他们的<code class="fe ms mt mu mv b">index.js</code>嵌入到HTML页面中的人，是的，可以将他们自己限制在这些指令的语义差异上。<strong class="jm io">其次</strong>，如果发布的包有<code class="fe ms mt mu mv b">dependencies</code>，那么在安装父包时，来自该指令的依赖项也会被安装，这将导致包重复和数据不一致。</p><p id="b360" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">因此，我们将依赖项转移到<code class="fe ms mt mu mv b">peerDependencies</code>，以便从外部系统中提取它们。</p></blockquote></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="8222" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">语义版本控制</h2><p id="d179" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">考虑<code class="fe ms mt mu mv b">@scope-name/1-utils: “A.B.C”</code>模块，其中:</p><p id="450f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> C </strong> —是“幕后”的补丁或修订版，不影响功能，也不需要在“母”系统中进行调整。</p><p id="cc4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> B </strong> —是次要版本，仅意味着添加新功能，或者，例如，扩展当前常量或接口。与补丁一样，它不会影响外部系统，也不需要对自身进行调整。</p><p id="5c9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> A </strong> —是一个主要版本，它对外部系统进行了<strong class="jm io">突破性的改变</strong>，并要求其适应新版本。</p><p id="907d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前我说过我们只冻结主版本，这意味着<code class="fe ms mt mu mv b">npm i</code>会把这些包更新到最新的次版本。通常，主要版本是在整个系统中集中提出的(由大多数团队提出，而不是单独提出)，例如，当系统被重新设计时。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="2670" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">微前端NPM封装的组成</h2><p id="a29f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在上一篇文章中，我谈到了使用私有NPM包的想法，就像云中的常规目录一样。现在这个想法将特别具有启发性，因为我们将不得不公布诸如:<code class="fe ms mt mu mv b">.less</code>、<code class="fe ms mt mu mv b">.svg</code>、<code class="fe ms mt mu mv b">.ts/x</code>、<code class="fe ms mt mu mv b">.png</code>、<code class="fe ms mt mu mv b">.json</code>、<code class="fe ms mt mu mv b">.md</code>等来源。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/6574260b9492fc3f986a161d32fb7a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T5tTlwMXFwJxH84m"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="377e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第一级:</h2><ol class=""><li id="bbab" class="lx ly in jm b jn ls jr lt jv nf jz ng kd nh kh mc md me mf bi translated">对于系统文件- <code class="fe ms mt mu mv b">@scope-name/1-docs</code>。好的做法是在项目本身中记录项目，而不是在维基中的某个地方。你也应该把<strong class="jm io"> style-guid </strong>放到这个包里。</li><li id="fd2d" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">用于开发工具- <code class="fe ms mt mu mv b">@scope-name/1-tools</code>。这里是配置文件<code class="fe ms mt mu mv b">.tsconfig</code>、<code class="fe ms mt mu mv b">.npmrc</code>、<code class="fe ms mt mu mv b">.browserslist</code>、esLint规则、用于测试的酶设置，也可能是Webpack配置的一部分。</li><li id="685e" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">对于音译和普通文本- <code class="fe ms mt mu mv b">@scope-name/1-translations</code>。所有通用的国际化系统都以<strong class="jm io"> ts-constants </strong>的形式出现。<a class="ae ki" href="https://podumaihorosho.medium.com/npm-i18n-internationalization-25da8201b3b8" rel="noopener">我的上一篇文章</a>就是专门写这个包的。</li><li id="2507" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">对于全局样式- <code class="fe ms mt mu mv b">@scope-name/1-styles</code>。这个包包含了所有的全局变量(颜色，大小，缩进)和通用的系统样式。该包被发布为<code class="fe ms mt mu mv b">.less</code>文件。</li><li id="4ab2" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">对于图标和图像- <code class="fe ms mt mu mv b">@scope-name/1-graphics</code>。这里收集了系统的所有通用图形:<code class="fe ms mt mu mv b">.svg</code>、<code class="fe ms mt mu mv b">.png</code>等。顺便说一下，通过类比，您可以通过为字体创建一个单独的包来处理字体。</li><li id="1a7b" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">常用工具- <code class="fe ms mt mu mv b">@scope-name/1-utils</code></li><li id="843a" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">DOM树实用程序- <code class="fe ms mt mu mv b">@scope-name/1-utils-dom</code></li><li id="4986" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">base64转换实用程序- <code class="fe ms mt mu mv b">@scope-name/1-utils-base64</code></li><li id="ca2e" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">文件实用程序- <code class="fe ms mt mu mv b">@scope-nam/1-utils-files</code></li><li id="74a6" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">等等…</li></ol><h2 id="2531" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第二级:</h2><ol class=""><li id="dd29" class="lx ly in jm b jn ls jr lt jv nf jz ng kd nh kh mc md me mf bi translated">分析功能- <code class="fe ms mt mu mv b">@scope-name/2-analytics</code>。这包含了谷歌分析的所有助手功能</li><li id="7ada" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">【产品】常量- <code class="fe ms mt mu mv b">@scope-name/2-consts-products</code></li><li id="c5e2" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">【单据】常量- <code class="fe ms mt mu mv b">@scope-name/2-consts-documents</code></li><li id="9de2" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">运行时错误处理实用程序- <code class="fe ms mt mu mv b">@scope-name/2-logger</code></li><li id="35eb" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">商业公用事业- <code class="fe ms mt mu mv b">@scope-name/2-utils</code></li><li id="2dba" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">等等…</li></ol><h2 id="13df" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">第三级:</h2><ol class=""><li id="7d5b" class="lx ly in jm b jn ls jr lt jv nf jz ng kd nh kh mc md me mf bi translated">组件库- <code class="fe ms mt mu mv b">@scope-name/3-components</code></li><li id="a16b" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">用户授权模块- <code class="fe ms mt mu mv b">@scope-name/3-authorise</code></li><li id="79b9" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">评级模块- <code class="fe ms mt mu mv b">@scope-name/3-rating</code></li><li id="7a36" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">等等…</li></ol></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="fad0" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM的基础设施设置-包</h2><p id="88e6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我将只讨论设置和devops的一些方面:</p><ul class=""><li id="da9b" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh ni md me mf bi translated">所有私有的NPM包必须在Bitbucket (或其他地方)合并成一个单独的项目，这样开发者就可以看到整个画面。</li><li id="91ae" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">主应用程序和每个微前端也应该在自己的项目中。因为通常每个这样的项目都有后台存储库和基础设施。记住NPM包的划分，根据它们的责任区域，有存储库——同样的方式。</li><li id="91ee" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">对于每个NPM包，你需要通过<strong class="jm io"> Jenkins </strong>(或类似的)创建一个组装和发布的作业，或者最好在<code class="fe ms mt mu mv b">master</code>分支挂一个合并PR的钩子，这样作业就可以自己开始了。</li><li id="a413" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">对于NPM封装，大多数情况下一个<code class="fe ms mt mu mv b">master</code>分支就足够了。但是有些情况下，开发者想要“非法地”改变一个已经发布的版本，而不影响当前的版本。为此，您可以使用<strong class="jm io">版本键</strong> : <code class="fe ms mt mu mv b">@scope-name/1-utils: “3.4.0<strong class="jm io">-release-2021–03–29</strong>”</code>，而当前版本为<code class="fe ms mt mu mv b">“4.0.0”</code>。这种情况下，除了<code class="fe ms mt mu mv b">master</code>分支，还会有<code class="fe ms mt mu mv b">release-2021–03–29</code>。</li><li id="7574" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">每个包的发布脚本必须从构建/类型检查开始，并运行linters和测试。</li><li id="3fd3" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">发布的凭证必须存储在<strong class="jm io"> Jenkins </strong>基础设施的上下文中，例如，该基础设施在自己的作业中修改项目根目录中的<code class="fe ms mt mu mv b">.npmrc</code>文件，在那里添加具有正确值的<code class="fe ms mt mu mv b">_auth</code>指令。这个参数的值通常是这样的:<code class="fe ms mt mu mv b">base64 ([login]: [pass])</code>。</li><li id="84b9" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh ni md me mf bi translated">带有NPM包的存储库中的所有提交应该看起来像这样:<code class="fe ms mt mu mv b">@scope-name/package-name@4.1.0 — a brief description of the update</code>，维护这样一个存储库的实践表明，这是很方便的。</li></ul></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="5d54" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">NPM系统的社会组成部分</h2><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nj"><img src="../Images/8832e6cecd0871f900b271cf074f64ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BaS3P6a5199gB5l8"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@vladhilitanu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vlad Hilitanu</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们看了很多微前端中NPM包形成和支持的原则和规则，但是我们没有触及最重要的因素，是的，<strong class="jm io">人的因素</strong>。</p><p id="416f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对大型NPM系统的支持很大一部分用于社会部分。我将试着告诉你主要的方面:</p><h2 id="1b66" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">专业知识和责任</h2><p id="0ac2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">理想情况下，创建一个<strong class="jm io">核心团队</strong>，全职处理NPM软件包，并在顶层负责系统中的所有软件包。分配本地职责也是一个好的实践，例如，专门为系统组件库创建一个团队。</p><p id="5a4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当遵循这些指令时，<strong class="jm io"> devops </strong>在<strong class="jm io"> Bitbucket </strong>中实现了一个插件，该插件自动将标签放入pull请求中，该请求只有在标签组的成员批准后才能显示为绿色。</p><p id="1319" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果一个新的开发人员进入项目并输入PR，例如，<code class="fe ms mt mu mv b">@scope-name/2-consts-documents</code>，他将看到对于合并，他需要来自以下组的批准:<code class="fe ms mt mu mv b">core_team</code>、<code class="fe ms mt mu mv b">bussiness_expert_team</code>、<code class="fe ms mt mu mv b">expert_team</code>。也就是说，首先，他将收到团队中一位专家的批准，然后是一位业务级专家的批准(第二位，我们在本文开始时谈到过)，最后是NPM系统主要专家的最终批准。</p><p id="c62b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，代码库仍然受到可靠的保护，审查将由负责可修改模块的人员进行。在实践中，我发现如果一个专家同时审查几个他不熟悉的不同上下文的项目，他就变成了一个“聪明的过客”,这并不能提高拉请求的效率。</p><h2 id="7419" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">通知和维护发布</h2><p id="a6c2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当提交对NPM包的变更时，开发者必须创建一个描述当前变更的<code class="fe ms mt mu mv b">.md</code>文件。要让它出现在公版里，像as: <code class="fe ms mt mu mv b">@scope-name/2-consts-documents/docs/release-notes/4.x.x/4.4.5.md</code>。和这个操作必须重复在每一个NPM包与每一个变化。</p><p id="b06d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个NPM软件包的主要发布之前，负责这个变更的团队必须提前通知公司的所有员工(软件开发部门)他们的意图。通过公司电子邮件或在一些普通的聊天中群发邮件效果很好。</p><p id="36e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，在主要版本发布后，该团队应该向每个人发送一份摘要发布说明，甚至可以是演示文稿，最重要的是，从以前的版本到新版本的预定逐步过渡。如果他们也在故事点中提供自己的评估，那就更好了。毕竟，系统中有很多微前端，每个微前端的产品负责人在阅读邮件列表时，应该了解即将到来的过渡的劳动力成本。</p><p id="3408" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但例如，对于次要版本和补丁，一个开发人员可能不会引起这样的公众注意，而只是通知其他开发人员(不是所有员工)他们的更改。正规的一般开发者聊天就很好的做了这个工作。</p><blockquote class="mx my mz"><p id="d56d" class="jk jl na jm b jn jo jp jq jr js jt ju nb jw jx jy nc ka kb kc nd ke kf kg kh ig bi translated">当一个新的开发人员入职时，他只需要去<code class="fe ms mt mu mv b">@scope-name/1-docs</code>库为他学习一个新系统的所有规则、原则和基础。</p></blockquote></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="83da" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">来自作者</h2><p id="0668" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这篇文章对我来说非常重要，因为它组织了多年来收集的大量经验。我想触及所有的话题，同时不去探究次要的细节。感谢您花时间和精力阅读它。</p><p id="1f67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">附言</strong>在下一篇文章中，我将告诉你如何使用<strong class="jm io"> System.js </strong>创建一个微前端，最重要的是，我将告诉你如何逐步实现一个微前端，拥有一个大型遗留单项目。</p><p id="5fbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我经常在文章中提到“大型项目/系统”这个词。在这里，我指的是200-300万个文件+80-150个团队的代码库。</p><p id="bbe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要从字面上理解收到的信息，试着理解主要的思想/情感，并根据你的要求进行调整。就我个人而言，我总是试图首先在情感层面上感受信息，然后才将其转化为有形的世界，所以我怀疑，我呈现的信息也是如此。</p></div></div>    
</body>
</html>