<html>
<head>
<title>How React Components Pass Data Between Each Other Using Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件如何使用Props在彼此之间传递数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-react-components-pass-data-between-each-other-using-props-26aea3ceabc4?source=collection_archive---------5-----------------------#2021-05-13">https://javascript.plainenglish.io/how-react-components-pass-data-between-each-other-using-props-26aea3ceabc4?source=collection_archive---------5-----------------------#2021-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/622d70cd245b95eddad46a5ae474a323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rPgoP8jZjIBT0rCn"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f6fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章是为中级反应学习者准备的。React中有很多值得讨论的地方，但我们的重点是在组件之间传递数据。在React中，传递数据是最重要的主题之一，因为React通过组件工作。基本上，组件就像React应用程序的子集。</p><p id="a9ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们将涵盖:</p><ol class=""><li id="b95b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">成分</li><li id="ee2b" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">传递数据</li></ol></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h2 id="e62d" class="lt lu in bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated"><strong class="ak"> 1。组件</strong></h2><p id="40b7" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">你周围有成千上万的例子来知道一个组件到底是什么。如果你想开发一个高级或复杂的web应用程序，那么了解组件对你来说尤其重要。</p><p id="f058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，组件有助于将复杂的部分分解成简单的部分。它的意思是<strong class="kc io"> <em class="mr">将小的解决方案分解或分割成组件形式，然后将它们全部合并成一个单一的输出</em> </strong>。让我们看看如何将组件合并成一个输出。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/633d647e61cff8375fbb9d71c1de0ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*iQ_0YNdBwHOAb6kqnMTc_w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example of components</figcaption></figure><p id="a725" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是理解组件最简单的例子之一。这些就是吊扇的<strong class="kc io"> <em class="mr">零件或部件</em> </strong>命名为<strong class="kc io"> <em class="mr">“底板、吊杆、壳盖、电机、叶片、拉线开关”。这些都是微小的部件，它们的工作和形状各不相同。但是它们之间有一点是共同的，即它们通过单个输出彼此连接，在这种情况下是空气。同样的概念也适用于React、Angular和Vue.js。</em></strong></p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h2 id="edfd" class="lt lu in bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated">2.传递数据</h2><p id="dd53" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">在上图中，我们看到每个组件都有自己的形状和功能，并且它们相互之间也在传递电流。如果一个组件无法工作，那么其他组件可能会停止工作。但是所有这些都完全依赖于架构结构，即每个组件是依赖于另一个还是独立的。</p><p id="532a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在风扇的例子中，我们的一些组件是相关的，一些是独立的。<strong class="kc io">基板</strong>是根(主)部件，负责将电力传递给其他部件，<strong class="kc io">电机</strong>部件完全依赖于<strong class="kc io">基板</strong>部件。如果基板通了电，只有电机才能运转——否则不行。</p><p id="2abf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在从技术上来说，<strong class="kc io"> <em class="mr"> React组件可以有不同的逻辑和UI。</em> </strong>在<strong class="kc io"> <em class="mr">道具组件之间传递数据只有一种方式。</em> </strong>如果你熟悉<strong class="kc io"> <em class="mr"> React上下文API，</em> </strong>这是React中组件间传递数据的另一种方式，但这种方式也是通过<strong class="kc io"> <em class="mr">道具</em> </strong>传递数据。</p><p id="34b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在传递数据之前，我们必须知道如何在组件内部存储数据。<strong class="kc io"> <em class="mr">存储React组件数据的方式只有一种，即状态。</em> </strong>所以，我已经说了，这篇文章是给中级学习者看的。我希望你知道确切的状态是什么，但为了快速演示，<strong class="kc io"> <em class="mr">状态是React虚拟DOM的一部分；没有状态，React组件不能改变UI。</em> </strong>如果你不熟悉状态，那么在阅读本文之前，先去熟悉一下<a class="ae jz" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="mr">状态</em></strong></a><strong class="kc io"><em class="mr"/></strong>。</p><p id="ed09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mr">所以，要在组件中存储数据，状态是必需的。但是对于在组件之间传递数据来说，就要用到道具了。</em> </strong></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4b4994ac56dc1b57ae1f908558931dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*MKgZrsjcD_WEhuSU6keWdA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">BasePlate Component</figcaption></figure><p id="81ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是简单的反应功能组件。<strong class="kc io"> <em class="mr">你可以看到这个组件里有两个东西——一个是名为Motor的进口模块组件；第二个是名为电的道具，其值为真。</em> </strong></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8a21ed47c82dc1bc3d780e4dd1509bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*FPxJUaf4w_gyIitPEA9gvA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Motor Component</figcaption></figure><p id="e083" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是Motor.js组件。<strong class="kc io"> <em class="mr">这里可以看到我们只是在用三元运算符验证props值——不管它的值是真还是假。</em> </strong>如果<code class="fe mz na nb nc b">props.electricity</code>为<code class="fe mz na nb nc b">true</code>，则执行第一串；如果没有，那么将执行第二个。</p><p id="9c85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们知道，道具是不可变的(不可改变的)。我们不能直接修改它们，但是有一些方法可以改变它们。然而，我们不会在本文中涉及它。</p><p id="7f74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住，我们的文章主题是通过组件传递数据，所以我们的重点是传递数据。</p><p id="a9d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所知，React使用单向数据绑定方法，这使得React很快。整个数据将在根组件中可用，根组件将把数据传递给其他组件。<strong class="kc io"> <em class="mr">如果我们要将底板数据传递给电机组件，那么底板组件应该导入电机组件。而且导入后必须用道具通过它传递数据。</em> </strong></p><p id="ba93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，<code class="fe mz na nb nc b">BasePlate</code>组件成为了<code class="fe mz na nb nc b">Motor</code>组件的父组件，因为<code class="fe mz na nb nc b">Motor</code>被导入(追加)到了<code class="fe mz na nb nc b">BasePlate</code>组件中。现在，底板组件已经通过了一个名为<code class="fe mz na nb nc b">electricity</code>的道具，其值为<code class="fe mz na nb nc b">true</code>。输出看起来像这样:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2c0163e3288ca57447d55f4190d68b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Ldb5s3Flo6dg5o3YvJgmvA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The Output</figcaption></figure><p id="df86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我将名为<code class="fe mz na nb nc b">electricity</code>的道具的值改为<code class="fe mz na nb nc b">false</code>:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8a59d3049a69c48c157129163a527889.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*3hmYrAlB148Uwm6jwYDAfQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">BasePlate Component and prop named electricity = false</figcaption></figure><p id="9d2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么输出将如下所示:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9361c907e313392d22dc66085f651b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*F_TlMj1SJeAWW75k-t12eg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Motor Component prop named electricity is now false</figcaption></figure><p id="5861" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于<code class="fe mz na nb nc b">props</code>，您可以看到改变一个组件内部的值如何改变另一个组件的行为。</p><p id="17de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的一点是——我们只是将一个道具表单<code class="fe mz na nb nc b">BasePlate</code>传递给了<code class="fe mz na nb nc b">Motor</code>组件。但是，如果我们必须将数据从子(马达)传递到父(基板)会怎样呢？然后，我们必须在props中传递方法/函数，这些方法将从它们的参数中获取值。见<code class="fe mz na nb nc b">BasePlate</code>修改版。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0c9e1f0cc8f8fca652a48a75590bf1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*WoUMNm8FJ0fp7PhbBOZ2PQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd ng">Modified BasePlate Component</strong></figcaption></figure><p id="6859" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个<code class="fe mz na nb nc b">BasePlate</code>的修改版本中，我们刚刚增加了两件事——一个是名为<code class="fe mz na nb nc b">generateElectricity</code>的方法或函数；第二件事是一个名为<code class="fe mz na nb nc b">data</code>的状态。最后，我们已经通过了<code class="fe mz na nb nc b">generateElectricity</code>方法作为马达的道具。</p><p id="0ad8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还对<code class="fe mz na nb nc b">Motor</code>组件进行了一项更改:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6ca4bb233f94a1a1390795c3957dc59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*IuVL4CudFzuzi4Jj-ANPRA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Modified Motor Component</figcaption></figure><p id="c7df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们刚刚给JSX添加了一个按钮标签，并附加了一个<code class="fe mz na nb nc b">onClick</code>事件，我们通过在点击事件期间传递电机数据来调用该方法。现在输出将是:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/cc296c6a00275aa4744c00ce0bd62211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jL7-3bA6zOTiXsfUDeFOw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">New output</figcaption></figure><p id="3f20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，默认情况下<code class="fe mz na nb nc b">props.electricity</code>等于<code class="fe mz na nb nc b">false</code>。这就是为什么“没有发现电！”消息正在呈现。但是如果我们单击按钮，那么将调用<code class="fe mz na nb nc b">generateElectricity</code>方法，并且<code class="fe mz na nb nc b">amount</code>状态将作为参数传递给<code class="fe mz na nb nc b">generateElectricity</code>函数，并且在该函数内部:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/feee03d76dfb099012943f6ab4301bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*JmaFQ23lhcKn3El8dZ9g9Q.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">generateElectricity function</figcaption></figure><p id="a5f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">amount</code>参数将保存<code class="fe mz na nb nc b">Motor.js</code>状态的数据，在本例中命名为<code class="fe mz na nb nc b">money</code>。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0353444328c1b412a434ffcf3c508b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*tTJWAZIVqLBsVaF_iQbwJw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">onClick function</figcaption></figure><p id="7d85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">货币参数来自<code class="fe mz na nb nc b">Motor</code>组件状态。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/90baf1fe1004271d7a8a9660a3eef9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*E-41ysfASiAmRhKU-8I2mA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Motor component’s state</figcaption></figure><p id="9961" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们讨论了两件事:</p><ol class=""><li id="7a51" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">如何将数据从父传递到子</li><li id="3c81" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如何将数据从子代传递到父代</li></ol><p id="ce1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两种方法都使用道具来传递数据。</p><blockquote class="nm nn no"><p id="34d0" class="ka kb mr kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated">正如您已经注意到的，数据是从父代传递到子代和从子代传递到父代的。</p></blockquote><p id="2284" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mr">这两种方法只有一个区别，那就是回调函数。我希望你知道回调函数。</em>T24】</strong></p><p id="d832" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">&lt;button onClick={() =&gt; props.generateElectricity(money)}&gt;Request for electricity&lt;/button&gt;</code></p><p id="5113" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面一行代码有一个按钮，里面有一个<strong class="kc io"><em class="mr">【On Click】</em></strong>事件，这个事件有一个回调函数，</p><p id="5117" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">() =&gt; props.generateElectricity(money)</code></p><p id="5660" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上一行有两个函数——一个只是调用函数(实际上是一个<em class="mr">箭头函数)；</em>第二个函数是<code class="fe mz na nb nc b">generateElectricity(money)</code>，该函数来自名为<code class="fe mz na nb nc b">BasePlate</code>的父组件。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h2 id="71be" class="lt lu in bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated">最后的想法</h2><p id="0b82" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">父组件只使用道具来传递数据，而子组件使用回调函数。由于回调，我们可以将数据从子代发送到父代。谢谢你的阅读。</p><p id="93cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎任何建议！</p><p id="43fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mr">更内容于</em> <a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">通俗易懂</em></a></p></div></div>    
</body>
</html>