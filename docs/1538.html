<html>
<head>
<title>A Beginner’s Guide to Recoil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后座力初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-to-know-recoil-initializing-and-maintaining-react-application-state-with-asynchronous-c5c3eb114c39?source=collection_archive---------2-----------------------#2021-04-02">https://javascript.plainenglish.io/getting-to-know-recoil-initializing-and-maintaining-react-application-state-with-asynchronous-c5c3eb114c39?source=collection_archive---------2-----------------------#2021-04-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/a5ea27d1591e9059d7181bdf2ee1cedb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZuyTCsv84gs0MeoeF0OIA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">(The forest for the trees)</figcaption></figure><div class=""/><div class=""><h2 id="cdeb" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用异步数据初始化和维护React应用程序状态</h2></div><h1 id="8091" class="kr ks jc bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">背景</h1><p id="4d9a" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">自从2020年5月<a class="ae mf" href="https://youtu.be/_ISAA_Jt9kI" rel="noopener ugc nofollow" target="_blank">推出</a>以来，与<a class="ae mf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>以及更成熟的UI不可知库(如<a class="ae mf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae mf" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>)相比，<a class="ae mf" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> ReactJS </a>应用中的<a class="ae mf" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>作为应用状态管理的替代方法已经有了大量的报道。</p><p id="8390" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">最近，<a class="ae mf" href="https://demandstar.com/" rel="noopener ugc nofollow" target="_blank"> DemandStar </a>的工程团队开始在我们的一些ReactJS / <a class="ae mf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>应用中实现反冲作为Redux的替代。</p><p id="4ba8" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">激励我们团队进行反冲实验的一些因素包括整体性能、与功能组件的兼容性(特别是使用<a class="ae mf" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React hooks </a>)、减少状态管理样板代码和支持<a class="ae mf" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">代码分割</a>——这并不意味着Redux不提供这些好处；然而，赞成和反对采用后坐力的论点已经在 <a class="ae mf" href="https://medium.com/better-programming/recoil-a-new-state-management-library-moving-beyond-redux-and-the-context-api-63794c11b3a5" rel="noopener">和</a> <a class="ae mf" href="https://dev.to/chandan/recoil-vs-redux-the-ultimate-react-state-management-face-off-35b" rel="noopener ugc nofollow" target="_blank">其他地方</a>详细 <a class="ae mf" href="https://blog.logrocket.com/refactoring-redux-app-to-use-recoil/" rel="noopener ugc nofollow" target="_blank">探讨过了。因此，与其在这里重复利弊，我们将直接进入我们的例子。</a></p><h1 id="291a" class="kr ks jc bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">要求</h1><h2 id="606f" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">为了实现功能对等，我们的主要要求有两个方面:</h2><ol class=""><li id="e7ba" class="mx my jc ll b lm ln lp lq ls mz lw na ma nb me nc nd ne nf bi translated">我们需要用服务调用返回的数据初始化应用程序状态。</li><li id="c785" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">我们的应用程序状态需要与后端保持同步。</li></ol></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h1 id="abc8" class="kr ks jc bd kt ku ns kw kx ky nt la lb ki nu kj ld kl nv km lf ko nw kp lh li bi translated">示例应用程序:基本用户列表</h1><h2 id="1470" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated"><strong class="ak">在我们开始编码之前</strong></h2><ul class=""><li id="5c8e" class="mx my jc ll b lm ln lp lq ls mz lw na ma nb me nx nd ne nf bi translated">为了快速设置我们的开发环境(无论是在本地机器上还是通过在线IDE，如<a class="ae mf" href="https://codesandbox.io" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>)，我们将依赖<a class="ae mf" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> create-react-app和附加的TypeScript模板</a>。</li><li id="013d" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nx nd ne nf bi translated">本例还假设对<a class="ae mf" href="https://recoiljs.org/docs/introduction/getting-started/" rel="noopener ugc nofollow" target="_blank">设置和实施反冲</a>有基本的了解。</li></ul><h2 id="2477" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">技术堆栈</h2><p id="99c3" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">我们的用户列表应用程序由以下元素组成(您可以在这里查看GitHub存储库<a class="ae mf" href="https://github.com/fauteuil/recoil-react-async-example" rel="noopener ugc nofollow" target="_blank"/>):</p><ul class=""><li id="f11a" class="mx my jc ll b lm mg lp mh ls ny lw nz ma oa me nx nd ne nf bi translated"><a class="ae mf" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">创建-反应-应用</strong> </a> <strong class="ll jd"> — </strong>基本设置</li><li id="b6a7" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nx nd ne nf bi translated"><strong class="ll jd">打字稿— </strong>打字安全</li><li id="1f5c" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nx nd ne nf bi translated"><a class="ae mf" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd">Axios</strong></a><strong class="ll jd">—</strong>服务请求库</li><li id="7ebb" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nx nd ne nf bi translated"><strong class="ll jd"> API调用</strong><a class="ae mf" href="https://reqres.in/api/users" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd">https://reqres.in/api/users</strong></a>—异步“用户”数据(补充请求输入和<strong class="ll jd"> </strong> <a class="ae mf" href="https://en.wikipedia.org/wiki/Arrested_Development" rel="noopener ugc nofollow" target="_blank">发展受阻</a>)</li></ul><h2 id="2a38" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">声明类型</h2><p id="1299" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">因为我们使用的是TypeScript，所以如果我们从类型定义开始，我们就能充分利用类型安全。这些将涵盖我们的数据从服务请求到反冲状态和反应组件的形态。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="cd43" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">配置服务呼叫</h2><p id="2ea3" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">接下来，让我们确保示例服务调用正常工作。</p><p id="bb81" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">我们配置的URL实际上是一个函数，其目的是随机切换一个查询参数(在本例中是页码)。当然，这并不重要，但它的目的只是为了展示我们调用API的反冲<code class="fe oh oi oj ok b">selector</code>，每当它的依赖项发生变化时，它都会发出一个新的请求——下面会详细介绍。<br/>因此，我们在模仿不断变化的后端数据，这样，随着API被连续调用，我们将会周期性地看到不同的数据集。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="153c" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">然后，我们将设置Axios调用来发出实际的API请求(我们也可以使用JavaScript <code class="fe oh oi oj ok b"><a class="ae mf" href="https://javascript.info/fetch" rel="noopener ugc nofollow" target="_blank">fetch()</a></code>函数或其他替代函数，但是Axios适合我们团队当前的堆栈)。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="3143" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">用我们的API调用初始化反冲状态</h2><p id="45ad" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">我们希望用服务请求的结果来初始化我们的应用程序状态:这将满足我们上述的第一个功能需求。</p><p id="08cf" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">因此，我们将设置一个反冲<code class="fe oh oi oj ok b">selector()</code>函数，并从其内部<code class="fe oh oi oj ok b">get()</code>函数返回API调用的响应。<br/>一个<code class="fe oh oi oj ok b">selector</code> <a class="ae mf" href="https://recoiljs.org/docs/api-reference/core/selector" rel="noopener ugc nofollow" target="_blank">可选地接受</a>一个<code class="fe oh oi oj ok b">get()</code>和<code class="fe oh oi oj ok b">set()</code>函数，但是出于这个例子的目的，我们将通过省略setter来保持我们的函数是只读的。</p><p id="4747" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">接下来，我们将定义反冲<code class="fe oh oi oj ok b">atom()</code>函数<code class="fe oh oi oj ok b">userListState</code>，React组件代码将实际使用它。<br/>这个<code class="fe oh oi oj ok b">atom</code>将使用我们之前定义为<em class="ol">的<code class="fe oh oi oj ok b">allUsersState</code> <code class="fe oh oi oj ok b">selector</code>作为它的</em>默认值，从而创建一个依赖项，以便在发生更改时通知任何订阅的组件。</p><p id="ae8e" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">他们在一起:</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="b499" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">更新反冲状态以重新查询API有效负载</h2><p id="b7e5" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">为了完成我们的反冲状态，我们将通过添加一个final <code class="fe oh oi oj ok b">atom()</code>并在<code class="fe oh oi oj ok b">allUsersState</code> <code class="fe oh oi oj ok b">selector</code>的<code class="fe oh oi oj ok b">get</code>函数中使用它作为依赖项来完成我们的第二个目标——保持应用程序状态与服务请求的结果同步。</p><p id="8c1e" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">采用这种方法的原因是，每当它的一个依赖关系发生变化时，就会调用<code class="fe oh oi oj ok b">get()</code>函数。<br/>在我们的示例中，我们将在React list组件上设置一个<code class="fe oh oi oj ok b">onClick</code>处理程序(见下文),然后在每次单击不同的项目时更新一个<code class="fe oh oi oj ok b">selectedUserEmailState</code>。</p><p id="525b" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">这里是完整的，更新的<code class="fe oh oi oj ok b">state.ts</code>。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="c5dc" class="ml ks jc bd kt mm mn dn kx mo mp dp lb ls mq mr ld lw ms mt lf ma mu mv lh mw bi translated">将所有这些放在一起:创建我们的React组件</h2><p id="97e3" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">现在我们已经有了我们的类型、服务调用和反冲状态逻辑，我们将把它们放在一起构建一个简单的React应用程序，它将与所有这些进行交互并显示它们。</p><p id="f5c0" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">根据最佳实践，我们将使用<a class="ae mf" href="https://scotch.io/courses/5-essential-react-concepts-to-know-before-learning-redux/presentational-and-container-component-pattern-in-react" rel="noopener ugc nofollow" target="_blank">表示组件/容器组件</a>模式，并将我们的<code class="fe oh oi oj ok b">UserList</code>设置为容器组件。<br/>这是我们将利用反冲<code class="fe oh oi oj ok b"><a class="ae mf" href="https://recoiljs.org/docs/api-reference/core/Loadable/" rel="noopener ugc nofollow" target="_blank">Loadable</a></code>对象的地方，它允许我们访问反冲<code class="fe oh oi oj ok b">atom</code>或<code class="fe oh oi oj ok b">selector</code>的当前状态。我们用来完成这项工作的钩子是<code class="fe oh oi oj ok b"><a class="ae mf" href="https://recoiljs.org/docs/api-reference/core/useRecoilStateLoadable/" rel="noopener ugc nofollow" target="_blank">useRecoilStateLoadable()</a></code>。<br/>我们将把来自<code class="fe oh oi oj ok b">userListState</code>原子的反冲状态数据作为属性传递给视图组件。我们还将设置<code class="fe oh oi oj ok b">onClick</code>处理程序<code class="fe oh oi oj ok b">handleUserClick</code>，并将其传递下去。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0665" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">最后，我们将创建我们的表示或视图组件<code class="fe oh oi oj ok b">UserListView</code>，这是一个仅用于显示的功能组件。在这里，我们接收状态和点击处理程序作为属性，并在状态发生变化时显示结果。</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="f940" class="kr ks jc bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">结论</h1><p id="c029" class="pw-post-body-paragraph lj lk jc ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me ig bi translated">这应该就结束了。这是一个简化的实现，但是我希望这篇文章提供了一些已经存在的好的反冲资源的合理汇编。</p><p id="da94" class="pw-post-body-paragraph lj lk jc ll b lm mg kd lo lp mh kg lr ls mi lu lv lw mj ly lz ma mk mc md me ig bi translated">这是已完成示例的嵌入式视图:</p><figure class="ob oc od oe gt ip"><div class="bz fp l di"><div class="om og l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">The sample User List app on codesandbox.io</figcaption></figure><h1 id="63eb" class="kr ks jc bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">链接</h1><ul class=""><li id="fdb6" class="mx my jc ll b lm ln lp lq ls mz lw na ma nb me nx nd ne nf bi translated">这是完成的例子，托管在<a class="ae mf" href="https://codesandbox.io/s/recoil-react-async-example-b6men" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>上。</li><li id="063d" class="mx my jc ll b lm ng lp nh ls ni lw nj ma nk me nx nd ne nf bi translated">这里是GitHub上的来源。</li></ul></div></div>    
</body>
</html>