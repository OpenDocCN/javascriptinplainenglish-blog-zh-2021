<html>
<head>
<title>3 Ways to Compare JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较JavaScript对象的3种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-ways-to-compare-javascript-objects-fc9e95543385?source=collection_archive---------5-----------------------#2021-09-02">https://javascript.plainenglish.io/3-ways-to-compare-javascript-objects-fc9e95543385?source=collection_archive---------5-----------------------#2021-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="04ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文讨论了比较JavaScript对象的简单方法，并阐述了这些方法的优缺点。</p><p id="007c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们开始吧。</p><p id="8818" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript中，对象是一个<em class="ki"> </em> <a class="ae kj" href="https://www.javascripttutorial.net/javascript-primitive-vs-reference-values/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">引用类型</em></strong></a><strong class="jm io"><em class="ki"/></strong>(相比整数，字符串是<em class="ki">原语</em>类型)。两个不同的对象永远不会相等，即使它们具有相同的属性。如果比较两个具有相同值和键的对象，将产生<code class="fe kk kl km kn b">false</code>。只有将同一个对象引用与其自身进行比较才会产生true。</p><p id="4065" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们需要想出一个解决方案，让我们可以轻松地比较对象。让我们讨论这样做的三种方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6d5fd8e8e6964a17bd10baaec5181019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MSApytX62CvhZqYU5xINQ.png"/></div></div></figure><h1 id="e6df" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1)使用JSON.stringify()</h1><p id="5384" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这是比较对象的简单方法。JSON。字符串化你的对象，并把它们作为字符串进行比较。这对<em class="ki">嵌套数组</em>非常有效。</p><p id="f2bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑两个相同的物体。</p><pre class="kp kq kr ks gt md kn me mf aw mg bi"><span id="a6d6" class="mh lb in kn b gy mi mj l mk ml">const a = {zero: 0, one: 1}<br/>const b= {zero: 0, one: 1}</span></pre><p id="54c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kk kl km kn b">a===b</code>会给出<code class="fe kk kl km kn b">false</code>，但是当你把它转换成字符串并检查时，它会把这个值作为原始类型进行比较。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mm"><img src="../Images/e5dfcc1c665197d1efad411f6d5f515d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SI62lBKoLDRzkqcEKCgy9w.png"/></div></div></figure><p id="5684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">限制:</strong></p><p id="832e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这种方法有其自身的局限性。</p><ol class=""><li id="0207" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">属性的顺序应该是相同的。否则它将抛出一个错误。考虑下面的例子。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/f4e1795ac59e0e43b86441425b281f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7TpXoekKWSTgikUn-yZag.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Limitations of using JSON.stringify method</figcaption></figure><p id="96f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.并非所有类型都可以在JSON中表示。<code class="fe kk kl km kn b">JSON.stringify()</code>函数将日期转换为字符串，并忽略值为<code class="fe kk kl km kn b">undefined</code>的键。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/6e121b036b6c2a4e19e0cefc4e18cde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4PJHaiYvMopl_1h8j2f2g.png"/></div></div></figure><h1 id="2820" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2)使用对象方法条目、排序和字符串(ES6方式)</h1><p id="e2cc" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这是使用ES6方式比较两个JavaScript对象的方法之一。我们在这里使用ES6对象方法提取对象属性作为数组，对它们进行排序并将其转换为字符串，然后进行比较。这消除了我们在使用<code class="fe kk kl km kn b">JSON.Stringify()</code>方法时的一些限制，但是这种方法不适用于嵌套数组。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/18d8d4b108e1ce396cdbcedc05d6abbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCmJ64EOa1YWfnCgRWsGrQ.png"/></div></div></figure><p id="1ad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使对象处于相同的顺序，它也能很好地工作。这是JSON.stringify的局限性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/33b2fec01eec601771dad4c92711e71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xwCGd3CHd4Dfdrr6BqeIw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">This method compares the objects irrespective of the orders of properties in the two objects</figcaption></figure><p id="13ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">限制:</strong></p><p id="2d65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法对嵌套对象不太适用，因为它不会检查内部嵌套的属性。</p><p id="b785" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑这个例子。它应该抛出<code class="fe kk kl km kn b">false </code>，但是它却抛出了<code class="fe kk kl km kn b">true</code>。因为值<code class="fe kk kl km kn b">dal</code>在两个对象中有不同的键，所以这个对象不能相同。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ne"><img src="../Images/62108ec479c8c4b18df4d83040e3c1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLJj5s0PIRZukPdPRlN6KQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Limitations of ES6 way</figcaption></figure><h1 id="30ae" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3)使用Lodash方法:</h1><p id="8fe6" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们可以使用lodash <code class="fe kk kl km kn b"><a class="ae kj" href="https://lodash.com/docs/4.17.15#isEqual" rel="noopener ugc nofollow" target="_blank">isEqual()</a></code>函数来比较两个对象。这种方法处理各种各样的情况，是比较两个对象的最复杂的方法。</p><p id="4345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里  <strong class="jm io">了解更多洛达什<a class="ae kj" href="https://www.educative.io/edpresso/what-is-lodash" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">。</strong></a></strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/c9550657bae6876360c97407b7380871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVldkE0dVLHhqldkVhsNIA.png"/></div></div></figure><h2 id="a208" class="mh lb in bd lc ng nh dn lg ni nj dp lk jv nk nl lo jz nm nn ls kd no np lw nq bi translated">结论:</h2><p id="7ff8" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">总结一下。我列举了一些我最近学到的方法。如果你知道任何其他比较JavaScript对象的方法或者我上面列出的方法的限制，请在下面评论。谢谢你。</p><p id="45df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae kj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>