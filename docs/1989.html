<html>
<head>
<title>Node.js | Inspecting an Apollo.js Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js |检查Apollo.js服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-inspecting-an-apollo-js-server-7e0b1e86b401?source=collection_archive---------17-----------------------#2021-04-25">https://javascript.plainenglish.io/node-js-inspecting-an-apollo-js-server-7e0b1e86b401?source=collection_archive---------17-----------------------#2021-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4dd7a0ba5de7c008681f95c8ecfa8d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qplgZ-UoXcgEt3WY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@raouldroog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Raoul Droog</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aaf6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要继续操作，运行本文末尾的文件，打开浏览器，转到服务器注销的URL。GraphQL playground将自动提供给你的浏览器。</p><p id="84ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的代码中，我们使用ApolloServer构造函数实例化了一个Apollo.js服务器。构造函数将选项对象作为参数，用于配置服务器。请参考以下链接，查看所有可能的选项和配置。</p><p id="52cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">API参考:<br/><a class="ae jz" href="https://www.apollographql.com/docs/apollo-server/api/apollo-server/" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/Apollo-server/API/Apollo-server/</a></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9531" class="lh li in ld b gy lj lk l ll lm">const { ApolloServer, gql } = require(`apollo-server`);</span><span id="2ff5" class="lh li in ld b gy ln lk l ll lm">const mockData = `qux`;</span><span id="0540" class="lh li in ld b gy ln lk l ll lm">new ApolloServer({<br/>  typeDefs,<br/>  resolvers,<br/>  context({ req, res }) {<br/>    return { mockData, req, res };<br/>  },<br/>})</span></pre><p id="d834" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，您可以看到我们只关心三个选项:typeDefs、resolvers和context。TypeDefs表示服务器的GraphQL模式。解析器是映射到模式的函数。响应由解析器的解析器函数生成，这些函数按照typeDefs定义的顺序执行。</p><p id="ab17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Context返回一个对象，该对象作为变量传递给每个解析器函数的context参数。</p><p id="7974" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用模式定义语言来创建我们的类型定义。当我们创建我们的模式时，我们创建了一个供服务器遵循的映射。该映射导致一系列解析器功能执行。</p><p id="25a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有三种特殊的类型，它们也是对应于三种可能的客户端操作的入口点:查询、变异和订阅。你可以把这些类型看作旅程的开始。和它们的子对象作为旅程的下一步。</p><p id="5a27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模式定义语言有两种类型:基本类型和对象类型。基本类型表示单个值，而对象类型是具有字段的类型。嵌套的对象类型表示子对象和父对象之间的关系。父项的解析函数总是在子项的解析函数之前执行，依此类推。嵌套最多的对象类型将对应于最后一次执行的解析器函数。</p><p id="2231" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的示例代码中，Query是入口点，我们可以预期查询解析器对象有两个函数bar和foo。foo的解析函数返回baz的父对象，foo没有父对象。foo查询的解析器执行将通过在查询对象上搜索与foo匹配的属性开始，如果查询要求baz属性，则下一个要执行的解析器函数将在名为Foo的对象上执行，并且该函数将存在于名为baz的属性上。根据baz的类型定义，baz，Baz函数将返回一个具有名为qux的单个属性的对象，该属性保存一个字符串值。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="aa2f" class="lh li in ld b gy lj lk l ll lm">const typeDefs = gql`<br/>type Query {<br/>  bar: String!<br/>  foo(id: Int!): Foo!<br/>}</span><span id="aae4" class="lh li in ld b gy ln lk l ll lm">type Foo {<br/>  id: Int!<br/>  baz: Baz!<br/>}</span><span id="e1ca" class="lh li in ld b gy ln lk l ll lm">type Baz {<br/>  qux: String<br/>}<br/>`;</span><span id="91ae" class="lh li in ld b gy ln lk l ll lm">// The Resolver Object:</span><span id="c594" class="lh li in ld b gy ln lk l ll lm">const resolvers = {<br/> Query: {<br/>   foo: (parent, args, context, info) =&gt; {<br/>     return { id: args.id };<br/>   },<br/>   bar: () =&gt; `bar`,<br/> },<br/> Foo: {<br/>   baz: (parent, args, context, info) =&gt; {<br/>     return { qux: context.mockData };<br/>   },<br/> },<br/>};</span></pre><p id="28f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解析器对象是对象的集合。每个顶级对象对应于一个操作类型或一个对象类型。</p><p id="238b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码表示查询类型的客户端操作。</p><p id="b480" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在GraphQL playground中运行这个查询。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c6b8" class="lh li in ld b gy lj lk l ll lm">query {<br/>  bar<br/>}</span></pre><p id="0789" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与客户端操作匹配的操作类型的名称将是服务器在解析器对象上查找解析器函数的第一个位置。接下来，它将查看客户端操作的最顶层字段bar，并使用该名称bar来查找解析器。</p><p id="b471" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦解析器bar被执行并且解析器返回了返回值‘bar ’,服务器将发送回下面的JSON有效负载。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0bd0" class="lh li in ld b gy lj lk l ll lm">{<br/>  “data”: {<br/>    “bar”: “bar”<br/>  }<br/>}</span></pre><p id="0a30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于查询和Foo的模式定义语言(SDL ):</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ff18" class="lh li in ld b gy lj lk l ll lm">type Query {<br/>  bar: String!<br/>  foo(id: Int!): Foo!<br/>}</span><span id="e87c" class="lh li in ld b gy ln lk l ll lm">type Foo {<br/>  id: Int!<br/>  baz: Baz!<br/>}</span></pre><p id="892f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在GraphQL Playground中运行下面的查询。</p><p id="e387" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">foo的查询类型的客户端操作:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b107" class="lh li in ld b gy lj lk l ll lm">query {<br/>  foo(id: 1) {<br/>    id<br/>    baz {<br/>      qux<br/>    }<br/>  }<br/>}</span></pre><p id="c72e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看Query的类型定义，foo字段需要一个参数。我们通过向上面代码中括号内的id字段传递一个整数参数来查询foo。</p><p id="2185" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类型查询中foo字段的定义类型是什么？是福！感叹号意味着它是一个必需的返回值，因此在resolver对象中，我们必须再次遍历，首先是操作名查询对象，然后是名为foo的属性，以找到解析器。</p><p id="0d21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">foo属性解析器函数通过访问foo解析器函数的args参数，将作为参数传递的id作为响应的值返回。服务器仍然没有找到对象类型为baz的类型为Foo，Baz的第二个数据字段。检索baz字段，并传递Baz类型的数据。服务器在解析器对象的最顶端字段中查找父对象的名称。</p><p id="483b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，服务器找到与Foo类型匹配的Foo属性。服务器识别出Foo对象持有对应于Foo类型属性上的对象类型的解析器。服务器在Foo对象上找到baz解析器，并执行该函数。baz解析器到达上下文对象，为qux返回任意模拟数据。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0ad0" class="lh li in ld b gy lj lk l ll lm">const resolvers = {<br/>  Query: {<br/>    foo: (parent, args, context, info) =&gt; {<br/>      return { id: args.id };<br/>    },<br/>    bar: () =&gt; `bar`,<br/>  },<br/>  Foo: {<br/>   baz: (parent, args, context, info) =&gt; {<br/>     return { qux: context.mockData };<br/>   },<br/>  },<br/>};</span></pre><p id="f4f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，Apollo Server将聚合数据，并将这个JSON有效负载发送回客户机:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cb92" class="lh li in ld b gy lj lk l ll lm">{<br/>  “data”: {<br/>    “foo”: {<br/>      “id”: 1,<br/>      “baz”: {<br/>        “qux”: “qux”<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在服务器实例化期间，使用context选项将mockData传递给ApolloServer。如下图所示。</p><p id="1829" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上下文选项显示为传递给每个解析器函数的上下文参数的对象属性。上下文对象还可以用于与req、res等对象进行交互，这些对象对应于底层的HTTP请求响应对象。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f2a3" class="lh li in ld b gy lj lk l ll lm">const { ApolloServer, gql } = require(`apollo-server`);</span><span id="c11c" class="lh li in ld b gy ln lk l ll lm">const mockData = `qux`;</span><span id="5ed7" class="lh li in ld b gy ln lk l ll lm">new ApolloServer({<br/> typeDefs,<br/> resolvers,<br/> context({ req, res }) {<br/>   return { mockData, req, res };<br/> },<br/>})</span></pre><p id="a352" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有关解析器参数的更多信息，请点击此<a class="ae jz" href="https://www.apollographql.com/docs/apollo-server/data/resolvers/#resolver-arguments" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="603e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们没有使用的两个参数是info和parent参数。父参数是保存父解析器的返回值的地方。它不需要用在子节点的返回值中。子节点和父节点的返回值将被自动聚合到一个匹配相应字段的JSON有效负载响应中。父对象可用于其他目的，例如构建数据库查询。向info参数传递一个表示执行状态的参数，该参数描述了当前的解析器执行以及之前和即将执行的解析器执行。</p><p id="a8f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器的完整代码如下所示。</p><p id="51bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按顺序运行以下两个命令。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="04d8" class="lh li in ld b gy lj lk l ll lm">npm init -y<br/>npm i -S apollo-server graphql</span></pre><p id="1f35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">👇🏻(运行该文件)</p><p id="517a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lo lp lq ld b">node server.js</code></p><p id="c5a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">server.js👇🏻</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c1e5" class="lh li in ld b gy lj lk l ll lm">const { ApolloServer, gql } = require(`apollo-server`);</span><span id="a307" class="lh li in ld b gy ln lk l ll lm">const typeDefs = gql`<br/> type Query {<br/> bar: String!<br/> foo(id: Int!): Foo!<br/> }</span><span id="ec0d" class="lh li in ld b gy ln lk l ll lm">type Foo {<br/> id: Int!<br/> baz: Baz!<br/> }</span><span id="991d" class="lh li in ld b gy ln lk l ll lm">type Baz {<br/> qux: String<br/> }<br/>`;</span><span id="3a88" class="lh li in ld b gy ln lk l ll lm">const mockData = `qux`;</span><span id="8f37" class="lh li in ld b gy ln lk l ll lm">const resolvers = {<br/>  Query: {<br/>    foo: (parent, args, context, info) =&gt; {<br/>      return { id: args.id };<br/>    },<br/>    bar: () =&gt; `bar`,<br/>  },<br/>  Foo: {<br/>    baz: (parent, args, context, info) =&gt; {<br/>      return { qux: context.mockData };<br/>    },<br/>  },<br/>};</span><span id="d7fc" class="lh li in ld b gy ln lk l ll lm">new ApolloServer({<br/>  typeDefs,<br/>  resolvers,<br/>  context({ req, res }) {<br/>    return { mockData, req, res };<br/>  },<br/>})<br/>.listen()<br/>.then(({ url }) =&gt; console.log(url));</span></pre><p id="fc08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢！</p><p id="92b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lr">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lr">plain English . io</em></a></p></div></div>    
</body>
</html>