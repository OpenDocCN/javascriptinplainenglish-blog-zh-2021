<html>
<head>
<title>LeetCode Algorithm Series: Merge Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:合并排序数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca?source=collection_archive---------7-----------------------#2021-06-15">https://javascript.plainenglish.io/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca?source=collection_archive---------7-----------------------#2021-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8d9ea4913a07ed8252d92af3500cdf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3lpKNSVQ3vj1bSRo"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@tma?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tianyi Ma</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4580" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">又见面了！我带着另一个算法问题和解决方案回来了。我写的第一个问题是检查数组是否包含重复项。你可以在这里查看:<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复</a>。只是提醒一下，我正在使用JavaScript解决代码。</p><p id="889e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题也来源于Leetcode轻松收集的顶级面试问题。所以在<strong class="kc io">合并排序后的数组:</strong></p><blockquote class="ky kz la"><p id="cfdc" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">给你两个整数数组<code class="fe lf lg lh li b">nums1</code>和<code class="fe lf lg lh li b">nums2</code>，按<strong class="kc io">非降序排序</strong>，两个整数<code class="fe lf lg lh li b">m</code>和<code class="fe lf lg lh li b">n</code>，分别代表<code class="fe lf lg lh li b">nums1</code>和<code class="fe lf lg lh li b">nums2</code>中元素的个数。</p><p id="84be" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">将</strong> <code class="fe lf lg lh li b">nums1</code>和<code class="fe lf lg lh li b">nums2</code>合并成一个按<strong class="kc io">非降序排序的数组</strong>。</p><p id="640b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">最终排序后的数组不应该被函数返回，而是被<em class="in">存储在数组</em> <code class="fe lf lg lh li b">nums1</code>里面。为了适应这种情况，<code class="fe lf lg lh li b">nums1</code>的长度为<code class="fe lf lg lh li b">m + n</code>，其中第一个<code class="fe lf lg lh li b">m</code>元素表示应该合并的元素，最后一个<code class="fe lf lg lh li b">n</code>元素被设置为<code class="fe lf lg lh li b">0</code>并应该被忽略。<code class="fe lf lg lh li b">nums2</code>的长度为<code class="fe lf lg lh li b">n</code>。</p></blockquote><p id="e5fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d1ac" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br/><strong class="li io">Output:</strong> [1,2,2,3,5,6]<br/><strong class="li io">Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].<br/>The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span></pre><p id="25b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本质上，我有两个数组，已经从最小到最大排序。我需要通过替换第一个数组中的最后几个零，将<code class="fe lf lg lh li b"><em class="lb">nums2</em></code>合并到我的<code class="fe lf lg lh li b"><em class="lb">nums1</em></code>数组中。给我的是<strong class="kc io"> m </strong>和<strong class="kc io"> n </strong>，它们是每个数组中的位数。这实际上是非常重要的，因为您可能会遇到这样的测试案例，在该案例中，您需要保留数组开头的零！这可能会改变您合并阵列的方式。</p><p id="8d20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将这个问题分解成几个步骤:</p><ol class=""><li id="e5ae" class="lx ly in kc b kd ke kh ki kl lz kp ma kt mb kx mc md me mf bi translated">我需要将两个数组组合在一起，用<code class="fe lf lg lh li b"><em class="lb">nums2</em></code> <strong class="kc io"> </strong>数组中的数字替换<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <strong class="kc io"> </strong>数组中的零。</li><li id="95db" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">合并后，我需要对<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <strong class="kc io"> </strong>数组进行排序。</li></ol><h1 id="8d28" class="ml ls in bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">合并数组</h1><p id="ec04" class="pw-post-body-paragraph ka kb in kc b kd ni kf kg kh nj kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">最初，我认为如果遍历<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <strong class="kc io"> </strong>数组，我可以用<code class="fe lf lg lh li b"><em class="lb">nums2</em></code> <em class="lb"> </em>数组中相应的值来替换零</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="88a2" class="lr ls in li b gy lt lu l lv lw">const len = m + n<br/>for (let i = 0; i &lt; len; i++) {<br/>  if (nums1[i] === 0) {<br/>    nums1[i] = nums2[i-n]<br/>  }<br/>}</span></pre><p id="f89a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，还记得我在上面提到的我需要保留带有零的测试用例吗？上面的代码会产生包含<code class="fe lf lg lh li b"><em class="lb">undefined</em></code> <em class="lb"> </em>值的<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <em class="lb"> </em>数组。</p><p id="c039" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我改变了合并数组的方式。由于我被赋予了m和n的值，我实际上可以用它们来删除我在T21<code class="fe lf lg lh li b"><em class="lb">nums1</em></code>中不需要的零。使用<strong class="kc io"> splice() </strong>方法，该方法接受一个从哪个索引开始拼接的参数，我<strong class="kc io">破坏性地</strong>改变了我的<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <em class="lb"> </em>数组。然后我用一个循环的<strong class="kc io">将我的<code class="fe lf lg lh li b"><em class="lb">nums2</em></code> <em class="lb"> </em>值推送到我的<code class="fe lf lg lh li b"><em class="lb">nums1</em></code> <em class="lb"> </em>数组中。</strong></p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="f1a2" class="lr ls in li b gy lt lu l lv lw">// nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br/>const len = m + n<br/>nums1.splice(len-n)</span><span id="7ea6" class="lr ls in li b gy nn lu l lv lw">for (let i = 0; i &lt; n; i++) {<br/>  nums1.push(nums2[i])<br/>}<br/>// nums1 = [1,2,3,2,5,6]</span></pre><p id="e01c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我已经成功地将我的数组合并到<code class="fe lf lg lh li b">nums1</code><em class="lb"/>中，我需要将它们按非降序排序。</p><h1 id="e787" class="ml ls in bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">对数组排序</h1><p id="98d3" class="pw-post-body-paragraph ka kb in kc b kd ni kf kg kh nj kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">是的，你总是可以使用JavaScript自带的<strong class="kc io"> sort()方法</strong>，但是算法的要点是不用它就能解决问题。另外，排序的时间复杂度是O(n log(n))。然而，我们可以在O(n)时间复杂度内解决这个问题，这样更快。</p><p id="1b5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我该如何对它们进行排序呢？我知道我需要遍历数组，然后比较两个数字。我最初的设计:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="3428" class="lr ls in li b gy lt lu l lv lw">for (let j = 1; j &lt; len; j++) {<br/>  if (nums1[j-1] &amp;&amp; nums1[j] &lt; nums1[j-1]) {<br/>    let tmp = nums1[j-1]<br/>    nums1[j-1] = nums1[j]<br/>    nums1[j] = tmp<br/>    j = j-2<br/>  }<br/>}</span></pre><p id="35a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我遍历数组——注意，我从索引1开始，而不是从0开始——并检查数字是否小于它前面的数字。如果是，那我就改变他们的价值观。我使用一个临时变量，所以在改变它们的时候不会丢失值。现在，请注意我还没有提到的两件事。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="f11d" class="lr ls in li b gy lt lu l lv lw">1. nums1[j-1]<br/>2. j = j-2</span></pre><p id="ac2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从第2点开始，我实现它来改变我在循环中的位置，否则<strong class="kc io"> j </strong>每次只会增加1。如果我没有它，就会发生这样的事情:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="508c" class="lr ls in li b gy lt lu l lv lw">[1,3,2,1,4,5]<br/>// run my code<br/>// result<br/>[1,3,1,2,4,5]</span></pre><p id="1ea8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没整理好！因为我再也没有检查那个数字是大于还是小于上一个数字。所以你可能会问，为什么不直接做j=j-1呢？这就是我想要的，但是由于循环，它会自动增加1，所以我用-2来抵消增加的值。</p><p id="0d65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，第一点，为什么会在那里？想象一下当你做了一个转换后j = 0。当程序检查j-1时，它不存在，因为我已经在数组的零索引处了。如果在它之前没有可以比较的东西，我可以直接移动到数组中的下一个元素。然而，我需要多走一步，因为我仍然会遇到一个错误。你能猜到吗？在JavaScript中，0的真值是多少？是假的！因此，如果<code class="fe lf lg lh li b">nums1[j-1]</code> = 0，我的if语句将为假，它将进入下一次迭代，这是一个问题，如果<code class="fe lf lg lh li b">nums1[j]</code>等于负数，因为然后我需要他们切换。</p><p id="ed14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，如果<code class="fe lf lg lh li b">nums1[j-1]</code> = 0，改变我的代码，它看起来像这样:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="faff" class="lr ls in li b gy lt lu l lv lw">for (let j = 1; j &lt; len; j++) {<br/>  if (nums1[j-1] || nums1[j-1] === 0) {<br/>    if (nums1[j] &lt; nums1[j-1]) {<br/>      let tmp = nums1[j-1]<br/>      nums1[j-1] = nums1[j]<br/>      nums1[j] = tmp<br/>      j = j-2<br/>    }<br/>  }<br/>}</span></pre><p id="5ae7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们开始工作了！完整的代码如下所示:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="6b94" class="lr ls in li b gy lt lu l lv lw">var merge = function(nums1, m, nums2, n) {<br/>  const len = m + n<br/>  nums1.splice(len-n)</span><span id="276b" class="lr ls in li b gy nn lu l lv lw">  for (let i = 0; i &lt; n; i++) {<br/>    nums1.push(nums2[i])<br/>  }<br/>    <br/>  for (let j = 1; j &lt; len; j++) {<br/>    if (nums1[j-1] || nums1[j-1] === 0) {<br/>      if (nums1[j] &lt; nums1[j-1]) {<br/>        let tmp = nums1[j-1]<br/>        nums1[j-1] = nums1[j]<br/>        nums1[j] = tmp<br/>        j = j-2<br/>      }<br/>    }<br/>  }<br/>  return nums1<br/>};</span></pre><p id="083c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很有效！解决了！时间复杂度是O(n ),因为我对循环运行2个<strong class="kc io">,但是它们没有嵌套，所以技术上是O(2n ),但是我们只需要考虑主导项。当我在Leetcode上运行这个时，运行时间是<strong class="kc io"> 64ms </strong>，这比提交的<strong class="kc io"> 99.74% </strong>要好(是的，我超级抽)。</strong></p><p id="160e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我很想知道我的代码是否可以进一步改进，或者你是如何解决这个算法的！</p><p id="1fc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在解决这个问题上有任何困难，我希望这能帮助你，并在未来寻找更多的Leetcode解决方案！</p><p id="35b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Leetcode系列:</p><blockquote class="ky kz la"><p id="a1b5" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a>3<br/>。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a> <br/> 8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a> <br/> 9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="aefb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lb">plain English . io</em></a></p></div></div>    
</body>
</html>