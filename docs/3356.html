<html>
<head>
<title>Object Destructuring in JavaScript — A Comprehensive Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的对象析构——初学者综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-destructuring-in-javascript-a-comprehensive-beginners-guide-b4a873d47ef1?source=collection_archive---------6-----------------------#2021-07-08">https://javascript.plainenglish.io/object-destructuring-in-javascript-a-comprehensive-beginners-guide-b4a873d47ef1?source=collection_archive---------6-----------------------#2021-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4e56" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何析构对象、嵌套对象、函数参数、重命名变量、设置默认值——以一步一步初学者友好的方式用例子解释。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f5074dc0a1e1a125acbd9003698dcea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdVThFlDsfA0itBkVV0M-w.png"/></div></div></figure><p id="f4d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我的上一篇文章中，我们研究了在JavaScript中析构如何处理数组。你可以在这里查看:</p><div class="lk ll gp gr lm ln"><a rel="noopener  ugc nofollow" target="_blank" href="/array-destructuring-in-javascript-a-comprehensive-beginners-guide-77a710166ca9"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">JavaScript中的数组析构:初学者综合指南</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">一步一步全面指导初学者用JavaScript解构数组。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb km ln"/></div></div></a></div><p id="727b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再次重申几个重要的概念，根据官方MDN <a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">文档</a>，析构赋值语法<em class="md">“是一个JavaScript表达式，可以将数组中的值或对象中的属性解包到不同的变量中。”</em></p><p id="9876" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这一次，我们将讨论如何使用对象在JavaScript中执行<strong class="kq io">析构。</strong></p><blockquote class="me mf mg"><p id="1f95" class="ko kp md kq b kr ks jo kt ku kv jr kw mh ky kz la mi lc ld le mj lg lh li lj ig bi translated"><strong class="kq io">注意:</strong>这将是一篇很长的文章，因为它既是对新手的对象析构的介绍，也是对那些已经熟悉这个概念的人的一些关键析构特性的提醒。</p><p id="a0d8" class="ko kp md kq b kr ks jo kt ku kv jr kw mh ky kz la mi lc ld le mj lg lh li lj ig bi translated">对于后者，如果你不想复习基础知识，你可以根据副标题跳到任何与你相关的部分。</p></blockquote><p id="3478" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于对象，析构的基本概念是相同的。就像数组一样，我们析构一个对象来将一个复杂的数据结构(在这个特殊的例子中是一个对象)分解成一个更小更简单的数据结构，比如一个变量。</p><p id="6dad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在处理API调用时，对象析构确实是一个救命稻草，因为它让我们用更少的代码处理API获取的数据。至此，让我们深入了解对象析构在JavaScript中是如何工作的。</p><h2 id="434c" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">使用属性名</strong>检索属性</h2><p id="9b32" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">假设我们有以下对象。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="c381" class="mk ml in nj b gy nn no l np nq">const myInfo = {name: “Soumadri”, job: “Editor”, hobby: “Reading”};</span></pre><p id="40c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们检索属性的传统技术如下所示:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="42a5" class="mk ml in nj b gy nn no l np nq">const myName = myInfo.name;</span><span id="b5e1" class="mk ml in nj b gy nr no l np nq">const myJob = myInfo.job;</span><span id="bbc5" class="mk ml in nj b gy nr no l np nq">const myHobby = myInfo.hobby;</span><span id="124c" class="mk ml in nj b gy nr no l np nq">console.log(myName, myJob, myHobby);</span></pre><p id="2510" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将为我们提供以下输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8eb2fc233ed9b275f456ff2a3ff5467d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*sUNtPMwB4aLfGRDY"/></div></figure><p id="a9b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们看看如何使用析构来做同样的事情。</p><p id="94fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了析构对象，我们使用花括号<code class="fe nt nu nv nj b">{}</code>。我们所要做的就是提供与我们希望从对象中提取的属性名称完全匹配的变量名。让我们来看看如何为我上面提到的对象实现这一点。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="8d53" class="mk ml in nj b gy nn no l np nq">const {name, job, hobby} = myInfo;</span></pre><p id="01ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们把花括号放在赋值操作符的左边。与数组一样，当JavaScript看到这一点时，它会知道必须执行一个析构赋值。</p><p id="eff2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在右边，我们放置物体的名称。注意，左边的变量名(姓名、工作、爱好)与<code class="fe nt nu nv nj b">myInfo</code>对象中的属性名完全匹配。现在，我们可以检查结果。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="7202" class="mk ml in nj b gy nn no l np nq">console.log(name, job, hobby);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9888beb3d56b73d96d16b4135b6fcc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/0*FpgUIe_rdE62Me8Q"/></div></figure><p id="7c4e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，我们用少得多的代码就能得到同样的结果。</p><p id="4425" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请记住，与数组不同，对象中项目(或属性)的顺序并不重要。因此，我们不需要手动跳过元素。例如，我们可以这样做:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="6eeb" class="mk ml in nj b gy nn no l np nq">const {name, hobby, job} = myInfo;</span></pre><p id="8cd6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将得到以下结果(变量检索与变量名相同的相应属性。因此，虽然“爱好”和“工作”在结果中的位置互换了，但它们的值保持不变):</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b4ef31497af11caea8834edf432257ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*aBBqGdSUCiDsc4I7"/></div></figure><p id="8600" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们想跳过一个属性(比如说‘job’)，我们只需这样做:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="68af" class="mk ml in nj b gy nn no l np nq">const {name, hobby} = myInfo;</span><span id="6fd8" class="mk ml in nj b gy nr no l np nq">console.log(name, hobby);</span></pre><p id="bc1d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们有了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0450ea4b66a8839cce645aa3574cc459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*kgU3t67Gf6wobPaU"/></div></figure><p id="7d44" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，所有这些只是为了证明属性的检索依赖于变量名及其对应的键，而不依赖于属性在对象中的位置。</p><h2 id="6b2c" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated">重命名变量时检索属性</h2><p id="c644" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">在前面的场景中，我们使用与对象中的属性同名的变量来检索属性。但是，如果我们想将对象数据存储在不同的变量名中呢？让我们看看我们能做些什么。</p><p id="e8b4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了引用对象中的属性，我们仍然必须使用它的原始名称。但是，我们可以修改存储获得的数据的变量的名称。这可以如下所示完成。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="9440" class="mk ml in nj b gy nn no l np nq">const {name: myName, job:myJob, hobby: myHobby} = myInfo;</span></pre><p id="4957" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们仍然在左侧使用原来的变量名，但是我们在它们旁边添加了一个冒号，然后提供了我们想要存储数据的新变量的名称。</p><p id="33ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，<code class="fe nt nu nv nj b">myInfo.name</code>是通过‘name’引用的，但是它的相应值(‘Soumadri’)存储在<code class="fe nt nu nv nj b">myName</code>变量中。其他两个属性和变量也是一样的。让我们检查输出:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="2d84" class="mk ml in nj b gy nn no l np nq">console.log(myName, myJob, myHobby);</span></pre><p id="0fd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，我们得到了同样的结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6ef169b7748baf0410fa641300e4df1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*kMj4Kt17dD4y5KVV"/></div></figure><h2 id="b9d7" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">检索没有变量声明的属性</strong></h2><p id="cabd" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">我们还可以在声明变量的同时检索属性，我们将检索到的值分别存储在这些变量中。让我们看看如何做到这一点。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="6487" class="mk ml in nj b gy nn no l np nq">let name, job, hobby;</span><span id="7859" class="mk ml in nj b gy nr no l np nq">({ name, job, hobby } = myInfo);</span><span id="306e" class="mk ml in nj b gy nr no l np nq">console.log(name, job, hobby);</span></pre><p id="bb7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，我们得到了以下输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4cc38452f6cc7fb99ce7639eb95b1393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*thMxKu6x1Iei74Qj"/></div></figure><p id="62de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为变量' name '，' job '和' hobby '已经在析构执行之前声明了，所以我们在赋值语句周围使用括号<code class="fe nt nu nv nj b">()</code>来确保操作完成。</p><p id="7d2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果没有括号，该语句将不再有效。例如，这可能不是有效的语法:</p><p id="f141" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe nt nu nv nj b">{ name, job, hobby } = myInfo;</code></p><p id="18f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并且会导致一个错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/26a57822417b5d606ca441b4bad15a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/0*F58v2RXXUlZWwas4"/></div></figure><p id="f470" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的下一个例子中，我们将看到JavaScript为什么认为这是无效的语法。</p><h2 id="5c8b" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">析构对象时变异变量</strong></h2><p id="b411" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">假设我们有两个值如下的变量。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="1d73" class="mk ml in nj b gy nn no l np nq">let x = 10;</span><span id="7249" class="mk ml in nj b gy nr no l np nq">let y = 20;</span></pre><p id="61a1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们有一个具有以下属性的对象。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="4da6" class="mk ml in nj b gy nn no l np nq">let obj = {x: 100, y: 200, z: 300};</span></pre><p id="e8cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们想用对象obj中属性x和y的值替换前面声明的变量(x和y)的值。</p><p id="2295" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们不能做这样的事情:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="d66c" class="mk ml in nj b gy nn no l np nq">const {x, y} = obj;</span></pre><p id="a1b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者这个:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="b2f8" class="mk ml in nj b gy nn no l np nq">let {x, y} = obj;</span></pre><p id="82fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是因为我们之前已经声明了变量a和b，我们不希望新的变量有相同的名字；我们想替换那些变量中的值。</p><p id="9c64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们这样做呢？在这种情况下，我们不再创建新的变量x和y。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="ded8" class="mk ml in nj b gy nn no l np nq">{x, y} = obj;</span></pre><p id="49ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们保存它，我们会得到一个语法错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/75ed5a33e3f86ba56ef83a2694ea2ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*YS6P9TznZ6MjXcVS"/></div></figure><p id="1120" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您没记错的话，这与我们在上一节末尾看到的错误是一样的。JavaScript为什么会抛出这个错误？</p><p id="50a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是因为当我们像上面那样用花括号开始一行代码时(没有变量声明)，JavaScript需要一个代码块。由于我们不能像上面尝试的那样给代码块赋值，JavaScript抛出错误“意外的标记' = '”。</p><p id="e18d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么解决方法是什么呢？为了解决这个问题，这是我们做出的改变。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="40d7" class="mk ml in nj b gy nn no l np nq">({x, y} = obj);</span></pre><p id="0d4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没错，再一次，就像前面的部分一样，我们将整行代码放在括号中。</p><p id="efef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们尝试将x和y的值打印到控制台:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="be2e" class="mk ml in nj b gy nn no l np nq">console.log(x,y);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a59feaf306f6f506b2d7f13dc02e3410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*odStwbK3NLRu0hux"/></div></figure><p id="ef05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们有了。我们已经成功地覆盖了x和y的值(改变它们)。</p><h2 id="bd19" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">默认值</strong></h2><p id="19b1" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">当处理从API调用接收的第三方数据时，如果我们最终试图读取对象上不存在的属性，拥有默认值会非常有用。在深入研究这个问题之前，让我先回顾一下我上一篇文章中的库对象。我们将对库对象执行剩余的操作。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="3e68" class="mk ml in nj b gy nn no l np nq">const library = {</span><span id="e9e6" class="mk ml in nj b gy nr no l np nq">name: “Soumadri’s Fiction Book Shelf”,</span><span id="d994" class="mk ml in nj b gy nr no l np nq">location: ‘1234 Fiction Palace, Calcutta, India’,</span><span id="4d26" class="mk ml in nj b gy nr no l np nq">genres: [‘Mystery’, ‘Horror’, ‘Fantasy’, ‘Sci-Fi’, ‘Literary Fiction’, ‘Historical Fiction’],</span><span id="435c" class="mk ml in nj b gy nr no l np nq">titles: [‘The Inugami Clan’, ‘The Three Coffins’, ‘In Search of Lost Time’, ‘Sandman’, ‘The Left Hand of Darkness’, ‘The Complete Works of H.P. Lovecraft’, ‘Do Androids Dream of Electric Sheep?’, ‘In the Woods’, ‘In a Glass Darkly’, ‘Fingersmith’],</span><span id="deed" class="mk ml in nj b gy nr no l np nq">authors: [‘Neil Gaiman’, ‘Ursula Le Guin’, ‘Sheridan Le Fanu’, ‘H.P. Lovecraft’, ‘Marcel Proust’, ‘Tana French’, ‘John Dickson Carr’, ‘Seishi Yokomizo’, ‘Philip K. Dick’, ‘Sarah Waters’],</span><span id="b90d" class="mk ml in nj b gy nr no l np nq">};</span></pre><p id="2418" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你是一个初学者，并且这个对象看起来让你害怕，让我简单介绍一下每个属性。</p><ul class=""><li id="e347" class="oc od in kq b kr ks ku kv kx oe lb of lf og lj oh oi oj ok bi translated"><strong class="kq io">名称:</strong>我的个人书架/图书馆的名称。</li><li id="44cc" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io">地址:</strong>图书馆的地址。</li><li id="4652" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io">流派:</strong>存储图书馆中所有书籍流派的数组。</li><li id="16e3" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io"> titles: </strong>存储图书馆中所有书籍名称的数组。</li><li id="916d" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io"> authors: </strong>一个数组，存储图书馆中所有作者的名字。</li></ul><p id="2416" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在假设这个对象是我们从一个API调用中收到的数据，而我们实际上不知道该对象的现有属性是什么(为了这节课，让我们假设一下)。</p><p id="20ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在将看到默认值在现实世界的应用程序中可以派上用场。</p><p id="1ead" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，由于我不知道对象上存在什么属性，如果我尝试检索一个属性，比如说<code class="fe nt nu nv nj b">library.openingHours</code>:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="5980" class="mk ml in nj b gy nn no l np nq">console.log(library.openingHours);</span></pre><p id="8b5d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">结果我会变得不明确。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7c058493fcc0e0427b71980951308bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*yTUvQ8IaufjN9YT2"/></div></figure><p id="dada" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">默认值可以作为一种变通方法。如果我们不确定对象上是否存在某个属性，我们可以给它一个默认值，如果在对象上找不到该属性，将使用该默认值。如果对象上存在该属性，默认值将被该属性的实际现有值覆盖。</p><p id="5729" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看看实际情况。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="de5b" class="mk ml in nj b gy nn no l np nq">const { openingHours = “Unknown”, titles = [] } = library;</span></pre><p id="a01f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经将openingHours设置为默认的字符串值<code class="fe nt nu nv nj b">“Unknown”</code>。默认情况下，我们将标题设置为空数组<code class="fe nt nu nv nj b">[]</code>。现在让我们看看当我们试图打印结果时会发生什么。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="13fb" class="mk ml in nj b gy nn no l np nq">console.log(openingHours);</span><span id="a420" class="mk ml in nj b gy nr no l np nq">console.log(titles);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/2790cedc95792ff1174048c4c853ae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*g6U48V8azw2x8yVb"/></div></div></figure><p id="33f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，我们得到了我们所期待的。因为属性<code class="fe nt nu nv nj b">openingHours</code>在库对象上不存在，所以它保持我们赋予它的默认值(字符串<code class="fe nt nu nv nj b">“Unknown”</code>)。由于<code class="fe nt nu nv nj b">title</code>确实作为库对象上的一个属性存在，它的默认值(一个空数组<code class="fe nt nu nv nj b">[]</code>)被库对象上属性的实际值覆盖。</p><p id="a796" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再次重申这里的要点，当我们没有像这里这样的硬编码数据时，默认值特别有用。当硬编码数据不存在时，我们不知道对象上存在什么属性。在这种情况下，默认值就派上了用场。</p><h2 id="c51a" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">嵌套对象析构</strong></h2><p id="0afa" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">首先，我们将通过添加另一个属性来稍微修改我们的库对象。下面是我们的新库对象的外观:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="ebdb" class="mk ml in nj b gy nn no l np nq">const library = {</span><span id="dd4c" class="mk ml in nj b gy nr no l np nq">name: “Soumadri’s Fiction Book Shelf”,</span><span id="4858" class="mk ml in nj b gy nr no l np nq">location: ‘1234 Fiction Palace, Calcutta, India’,</span><span id="6903" class="mk ml in nj b gy nr no l np nq">genres: [‘Mystery’, ‘Horror’, ‘Fantasy’, ‘Sci-Fi’, ‘Literary Fiction’, ‘Historical Fiction’],</span><span id="c0df" class="mk ml in nj b gy nr no l np nq">titles: [‘The Inugami Clan’, ‘The Three Coffins’, ‘In Search of Lost Time’, ‘Sandman’, ‘The Left Hand of Darkness’, ‘The Complete Works of H.P. Lovecraft’, ‘Do Androids Dream of Electric Sheep?’, ‘In the Woods’, ‘In a Glass Darkly’, ‘Fingersmith’],</span><span id="c0d2" class="mk ml in nj b gy nr no l np nq">authors: [‘Neil Gaiman’, ‘Ursula Le Guin’, ‘Sheridan Le Fanu’, ‘H.P. Lovecraft’, ‘Marcel Proust’, ‘Tana French’, ‘John Dickson Carr’, ‘Seishi Yokomizo’, ‘Philip K. Dick’, ‘Sarah Waters’],</span><span id="b7ff" class="mk ml in nj b gy nr no l np nq">timings: {</span><span id="e53b" class="mk ml in nj b gy nr no l np nq"> mon: {</span><span id="a6fd" class="mk ml in nj b gy nr no l np nq">  open: 10,</span><span id="6b26" class="mk ml in nj b gy nr no l np nq">  close: 21,</span><span id="0b01" class="mk ml in nj b gy nr no l np nq"> },</span><span id="effc" class="mk ml in nj b gy nr no l np nq"> tue: {</span><span id="846c" class="mk ml in nj b gy nr no l np nq">  open: 10,</span><span id="ae26" class="mk ml in nj b gy nr no l np nq">  close: 21,</span><span id="7717" class="mk ml in nj b gy nr no l np nq"> },</span><span id="dae1" class="mk ml in nj b gy nr no l np nq"> sat: {</span><span id="d4ac" class="mk ml in nj b gy nr no l np nq">  open: 10,</span><span id="001b" class="mk ml in nj b gy nr no l np nq">  close: 16,</span><span id="30ca" class="mk ml in nj b gy nr no l np nq"> },</span><span id="a629" class="mk ml in nj b gy nr no l np nq"> },</span><span id="1ad5" class="mk ml in nj b gy nr no l np nq">};</span></pre><p id="4123" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看我们在这里做了什么。在我们现有的库对象中，我添加了另一个名为“timings”的属性，它的值是objects ('mon '，' tue '，' sat ')，objects本身是保存其他键值对的对象(例如，<code class="fe nt nu nv nj b">open: 10, close: 21</code>)。</p><p id="f075" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们检索属性“timings”的值。这就是我们要做的。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="6c7b" class="mk ml in nj b gy nn no l np nq">const {timings} = library;</span></pre><p id="6bf9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看看结果:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="17ae" class="mk ml in nj b gy nn no l np nq">console.log(timings);</span></pre><p id="26af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们开始吧。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2b7ceb56e75f012c2ee256a59c304bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*CYWb8kQU7Zqmhuw3"/></div></figure><p id="3ccf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，现在我们已经有了“计时”，让我们试着从中检索“sat”。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="aeca" class="mk ml in nj b gy nn no l np nq">const {sat} = timings;</span></pre><p id="61ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在来看看结果。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="58ce" class="mk ml in nj b gy nn no l np nq">console.log(sat);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/dff0b26059e9da69860ee65af2096d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*rbALKZgmjPAIKfmn"/></div></figure><p id="b780" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，这是预期的结果。</p><p id="d9ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是在这里，我们得到的是一个对象，而我们想要的是两个变量的值——一个叫做‘open ’,另一个叫做‘close’——在两个独立的变量中。当然，我们可以进一步析构“sat”来检索属性，但这需要太多行代码。有没有更容易、更快、更短的解决方案？嗯，是的。这是我们能做的，多亏了解构。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="ae39" class="mk ml in nj b gy nn no l np nq">const {sat: {open, close}} = timings;</span></pre><p id="30c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个嵌套对象析构的例子。首先，我们析构计时以检索“sat”，然后，如果我们在“sat”旁边放置一个冒号(<code class="fe nt nu nv nj b">:</code>)，并再次开始花括号(<code class="fe nt nu nv nj b">{}</code>)，我们可以检索“sat”中存在的属性。</p><p id="ded9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看结果。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="1b15" class="mk ml in nj b gy nn no l np nq">console.log(open, close);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/64f2ce6eb0254d5edc596607de6843db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*HOj2GenZTrM1CKo3"/></div></figure><p id="3c06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事实上，我们在控制台中分别存储和打印了“打开”和“关闭”的值。</p><h2 id="8071" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated"><strong class="ak">从作为函数参数传递的对象中检索属性(实际应用)</strong></h2><p id="e168" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">现在让我们来看一个析构的实际应用。首先，我们将再次修改库对象。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="4e8a" class="mk ml in nj b gy nn no l np nq">const library = {</span><span id="d8ec" class="mk ml in nj b gy nr no l np nq">name: “Soumadri’s Fiction Book Shelf”,</span><span id="9754" class="mk ml in nj b gy nr no l np nq">location: ‘1234 Fiction Palace, Calcutta, India’,</span><span id="5e5f" class="mk ml in nj b gy nr no l np nq">genres: [‘Mystery’, ‘Horror’, ‘Fantasy’, ‘Sci-Fi’, ‘Literary Fiction’, ‘Historical Fiction’],</span><span id="71bb" class="mk ml in nj b gy nr no l np nq">titles: [‘The Inugami Clan’, ‘The Three Coffins’, ‘In Search of Lost Time’, ‘Sandman’, ‘The Left Hand of Darkness’, ‘The Complete Works of H.P. Lovecraft’, ‘Do Androids Dream of Electric Sheep?’, ‘In the Woods’, ‘In a Glass Darkly’, ‘Fingersmith’],</span><span id="c4b2" class="mk ml in nj b gy nr no l np nq">authors: [‘Neil Gaiman’, ‘Ursula Le Guin’, ‘Sheridan Le Fanu’, ‘H.P. Lovecraft’, ‘Marcel Proust’, ‘Tana French’, ‘John Dickson Carr’, ‘Seishi Yokomizo’, ‘Philip K. Dick’, ‘Sarah Waters’],</span><span id="9f40" class="mk ml in nj b gy nr no l np nq">timings: {</span><span id="d3ac" class="mk ml in nj b gy nr no l np nq">mon: {</span><span id="0e2b" class="mk ml in nj b gy nr no l np nq">open: 10,</span><span id="6877" class="mk ml in nj b gy nr no l np nq">close: 21,</span><span id="2c25" class="mk ml in nj b gy nr no l np nq">},</span><span id="6601" class="mk ml in nj b gy nr no l np nq">tue: {</span><span id="fe41" class="mk ml in nj b gy nr no l np nq">open: 10,</span><span id="f9eb" class="mk ml in nj b gy nr no l np nq">close: 21,</span><span id="4e57" class="mk ml in nj b gy nr no l np nq">},</span><span id="7fb6" class="mk ml in nj b gy nr no l np nq">sat: {</span><span id="4976" class="mk ml in nj b gy nr no l np nq">open: 10,</span><span id="32f6" class="mk ml in nj b gy nr no l np nq">close: 16,</span><span id="059c" class="mk ml in nj b gy nr no l np nq">},</span><span id="48e2" class="mk ml in nj b gy nr no l np nq">},</span><span id="be01" class="mk ml in nj b gy nr no l np nq">lendBook: function (obj) {</span><span id="651a" class="mk ml in nj b gy nr no l np nq"> console.log(obj);</span><span id="cb96" class="mk ml in nj b gy nr no l np nq">},</span><span id="3718" class="mk ml in nj b gy nr no l np nq">};</span></pre><p id="f706" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如您所见，我添加了一个函数<code class="fe nt nu nv nj b">lendBook()</code>，它接受一个对象(<code class="fe nt nu nv nj b">obj</code>)作为参数。目前，我们只是将整个对象打印到控制台。</p><p id="40ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，这背后的基本原理。</p><p id="953b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，一个函数可以有很多参数，尤其是在现实世界的应用程序中。如果你尝试使用这个函数，很难知道参数的顺序。因此，我们可以选择不手动定义参数；相反，我们只是将一个对象作为参数传递给函数。然后，这个函数会立即析构这个对象。</p><p id="7b3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们尝试通过调用函数来实现这一点。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="906b" class="mk ml in nj b gy nn no l np nq">library.lendBook({</span><span id="d4cc" class="mk ml in nj b gy nr no l np nq">memberName: ‘Soumadri Banerjee’,</span><span id="f24a" class="mk ml in nj b gy nr no l np nq">authorIndex: 2,</span><span id="1258" class="mk ml in nj b gy nr no l np nq">titleIndex: 4,</span><span id="3e96" class="mk ml in nj b gy nr no l np nq">date: ‘8th July, 2021’,</span><span id="9efa" class="mk ml in nj b gy nr no l np nq">});</span></pre><p id="8dde" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是对我们传递给函数调用的对象的每个属性的简短解释。</p><ul class=""><li id="749b" class="oc od in kq b kr ks ku kv kx oe lb of lf og lj oh oi oj ok bi translated"><strong class="kq io"> memberName </strong>:借书的图书馆成员的名字。</li><li id="b54e" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io"> authorIndex: </strong>对应于图书作者在library.authors数组中的名字的索引位置。</li><li id="96d1" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io"> titleIndex: </strong>在library.titles数组中对应书名的索引位置。</li><li id="f2c7" class="oc od in kq b kr ol ku om kx on lb oo lf op lj oh oi oj ok bi translated"><strong class="kq io">日期:</strong>图书被借阅的日期。</li></ul><p id="fbd6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们查看浏览器的结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ccca239b42b84d3602244a791592aead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*5wpOhOKUixihVqAG"/></div></figure><p id="940a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">虽然这很好，但我前面提到过，我们希望函数立即将对象作为参数进行析构——也就是说，我们希望在函数参数中立即执行析构(检索属性值)。</p><p id="bb64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以这样做。</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="c2a6" class="mk ml in nj b gy nn no l np nq">lendBook: function ({ authorIndex, titleIndex, date, memberName }) {</span><span id="eb61" class="mk ml in nj b gy nr no l np nq">console.log(</span><span id="7714" class="mk ml in nj b gy nr no l np nq">`The book ${this.titles[titleIndex]} by ${this.authors[authorIndex]} was borrowed by ${memberName} on ${date}.`</span><span id="5c74" class="mk ml in nj b gy nr no l np nq">);</span><span id="90e8" class="mk ml in nj b gy nr no l np nq">},</span><span id="fe1e" class="mk ml in nj b gy nr no l np nq">};</span></pre><p id="f360" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们通过在花括号(<code class="fe nt nu nv nj b">{}</code>)内的函数参数中使用完全相同的四个属性名(authorIndex、titleIndex、date、memberName)来析构函数调用中发送的对象——这些属性名与我们之前在函数调用期间传递的obj对象中的属性名相同。</p><p id="b933" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们把这些值存储在不同的变量中。</p><p id="d523" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了打印到控制台，我简单地使用了一个模板文本(如果您不熟悉模板文本，可以随意使用常规字符串)来打印一个语句，该语句使用了参数中提供给我们的所有数据。结果看起来像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ee0d12bf1ee58ea2b20b7dcca6da91e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*e3FKKVvmUmB9FztL"/></div></figure><p id="b761" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里强调这样一个事实是很重要的:在函数调用过程中，我们只向函数传递了一个对象。<strong class="kq io">我们没有通过四个论证。</strong> <strong class="kq io">我们通过析构在函数参数中将属性作为单独的变量进行检索。</strong></p><p id="6bc3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一个需要注意的要点是，在函数参数中进行析构时，我们不必遵循任何特定的顺序。例如，<code class="fe nt nu nv nj b"> memberName</code>在最后被析构，这与我们传递给函数的obj对象中的属性顺序不同。我们只需要确保使用与属性名完全相同的名称来析构和检索变量。</p><p id="a6ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以通过实现我们之前所学的来进一步改进这一点:<strong class="kq io">默认值</strong>。</p><p id="1024" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们将函数更改如下:</p><pre class="kd ke kf kg gt ni nj nk nl aw nm bi"><span id="16b3" class="mk ml in nj b gy nn no l np nq">lendBook: function ({</span><span id="ae4f" class="mk ml in nj b gy nr no l np nq">authorIndex = 0,</span><span id="d82d" class="mk ml in nj b gy nr no l np nq">titleIndex = 3,</span><span id="1933" class="mk ml in nj b gy nr no l np nq">date,</span><span id="aa10" class="mk ml in nj b gy nr no l np nq">memberName,</span><span id="83c7" class="mk ml in nj b gy nr no l np nq">returnDate = ‘1 month’,</span><span id="2996" class="mk ml in nj b gy nr no l np nq">}) {</span><span id="00d7" class="mk ml in nj b gy nr no l np nq">console.log(</span><span id="8d83" class="mk ml in nj b gy nr no l np nq">`The book ${this.titles[titleIndex]} by ${this.authors[authorIndex]} was borrowed by ${memberName} on ${date}. Please return it within ${returnDate}.`</span><span id="46f4" class="mk ml in nj b gy nr no l np nq">);</span><span id="491c" class="mk ml in nj b gy nr no l np nq">}</span></pre><p id="63ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在这里所做的是，如果属性<code class="fe nt nu nv nj b">authorIndex</code>和<code class="fe nt nu nv nj b">titleIndex</code>在对象上不存在，那么它们被分别设置为0和3。并且在<code class="fe nt nu nv nj b">returnDate</code>不作为属性存在的情况下，它被设置为字符串“1个月”。</p><p id="ee06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于我们之前进行的函数调用，我们已经分别为<code class="fe nt nu nv nj b">authorIndex</code>和<code class="fe nt nu nv nj b">titleIndex</code> (4和2)提供了索引值。而且没有叫<code class="fe nt nu nv nj b">returnDate</code>的属性。那么，如果我们现在调用<code class="fe nt nu nv nj b">library.lendBook()</code>函数，你能猜到结果会是什么吗？试试看。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7da9609a74811bd08754effe61885fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*Fyu7VPOadNGxAX_O"/></div></figure><p id="a865" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没错；正如我前面提到的，我们为<code class="fe nt nu nv nj b">authorIndex</code>和<code class="fe nt nu nv nj b">titleIndex</code> (0和3)设置的默认值在函数调用期间分别被4(‘马赛尔·普鲁斯特’)和2(‘搜索丢失的时间’)覆盖。而且由于没有<code class="fe nt nu nv nj b">returnDate</code>这样的属性，所以它的值被设置为默认值“1个月”。</p><p id="258a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，这是一个非常基本的例子，有相当多的逻辑缺陷(一个明显的缺陷是没有验证来确保所选的书确实是我们所选的作者写的)，但这意味着向您展示析构是如何工作的，并提供了一个实际的例子，说明它可能会派上用场。</p><p id="5e67" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请随意修改这些概念，尝试我们在本文中学到的一切，甚至可以改进和微调我提供的示例。</p><h2 id="b199" class="mk ml in bd mm mn mo dn mp mq mr dp ms kx mt mu mv lb mw mx my lf mz na nb nc bi translated">结论</h2><p id="1028" class="pw-post-body-paragraph ko kp in kq b kr nd jo kt ku ne jr kw kx nf kz la lb ng ld le lf nh lh li lj ig bi translated">就这样，祝贺你这篇非常长的文章结束了。正如我在上一篇文章中所做的那样，我想感谢乔纳斯·施梅德曼和他的精彩Udemy <a class="ae mc" href="https://www.udemy.com/course/the-complete-javascript-course/" rel="noopener ugc nofollow" target="_blank">课程</a>让我对这些主题有了清晰的理解。</p><p id="9d53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我希望你喜欢阅读这篇文章，并证明它是有益的。如果您有任何疑问或意见，请随时留言。</p><p id="34a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">享受你的一天，祝你愉快，再见。</p><p id="b3fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="md">更多内容看</em><a class="ae mc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="md">plain English . io</em></strong></a></p></div></div>    
</body>
</html>