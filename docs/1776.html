<html>
<head>
<title>50 Questions to Master the JavaScript Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript编码面试的50个问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/50-questions-to-master-the-javascript-coding-interview-639d2ac12630?source=collection_archive---------2-----------------------#2021-04-15">https://javascript.plainenglish.io/50-questions-to-master-the-javascript-coding-interview-639d2ac12630?source=collection_archive---------2-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4aaf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript编码面试问题:第1部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/792a041f1ba0cefab283fffadaa7e3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0l6BM_iFLdvCEB7WJJ0IwA.png"/></div></div></figure><h2 id="fe98" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 1。以下哪个先打印？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/e7b8f78a2e9b55d0ee91ffb363cf96cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoAmHW24It3JrS4XX8bssA.png"/></div></div></figure><ul class=""><li id="17b0" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">第二种情况是答案<em class="md">(打印queueMicroTask更好)</em>，因为来自<em class="md"> queueMicroTask </em>的任务在<strong class="lq ir">调用栈</strong>为空之后，调用<strong class="lq ir">事件循环</strong>之前被调用，而在<strong class="lq ir">设置超时</strong>的情况下，任务是<strong class="lq ir">事件队列</strong>的一部分。</li></ul><h2 id="5179" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 2。控制台输出会是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/c4afd089d48332af399b918cb5bc154e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*louOUlukf5cIdwNq9owpQQ.png"/></div></div></figure><ul class=""><li id="77fc" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">控制台输出将是<strong class="lq ir"> 10 </strong>，因为类似于<em class="md">对象</em>当原语被传递给一个函数时，只传递它们的值，而不是对内存位置的实际引用。这就是为什么更改只影响函数的<strong class="lq ir">范围</strong>内的参数。</li></ul><h2 id="5e57" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 3。控制台输出会是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cc28ee24e2d551fee06ddd2c01f0fcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-FQ2D7RsTZCqoG7CUr-AdA.png"/></div></figure><ul class=""><li id="0da7" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">在这种情况下，控制台上会抛出一个<strong class="lq ir">错误</strong>，因为我们两次定义了同一个变量。然而，如果我们使用<strong class="lq ir"> var、</strong>定义相同的变量，控制台将返回50 <strong class="lq ir">。</strong>同样，当用<strong class="lq ir"> const定义变量时，我们会得到同样的错误。</strong></li></ul><h2 id="5fea" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 4。<em class="mg">line 1</em>&amp;<em class="mg">line 2</em>的控制台输出会是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/431a1f3d811c35fdaf2764201a88cd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDZC69rtO0Sp244Q7q-eJQ.png"/></div></div></figure><ul class=""><li id="a54d" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">在第1行中，我们有两个相互比较的对象，它们都是唯一的，因此它会在控制台上记录<strong class="lq ir"> False </strong>。</li><li id="7338" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">在<strong class="lq ir"> Line2 </strong>中，我们使用了<strong class="lq ir"> === </strong>操作符来检查两个字符串原语，而不是字符串对象，因此我们得到了<strong class="lq ir"> True </strong>。</li></ul><h2 id="ebe6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 5。控制台输出会是什么，为什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/aa132252789d6aae043f97f2eb9d59d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DoWSTjvaVInKcL85x-s1w.png"/></div></div></figure><ul class=""><li id="7ad1" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">与前一个问题类似，我们比较了两个不同的对象。在这种情况下，只有一个唯一的<strong class="lq ir">对象</strong>，带有两个常量<strong class="lq ir"> x </strong>和<strong class="lq ir"> y </strong>，指向内存中唯一的<strong class="lq ir">对象</strong>，并在控制台上返回<strong class="lq ir"> True </strong>。</li></ul><h2 id="2b8f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 6。JavaScript中的<em class="mg">数组</em>是对象还是原语？</strong></h2><ul class=""><li id="a6da" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">在JavaScript中，我们处理的大多数东西都是对象，类似地，数组也是JavaScript中特殊类型的对象，它们拥有其他对象所没有的属性。</li></ul><h2 id="3f28" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 7。下面这个函数的返回类型是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/958dc79a85fa0d00eb94fe03c0fba941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxWO1uK3FE9rgikm5fHOKg.png"/></div></div></figure><ul class=""><li id="080b" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">答案是<strong class="lq ir"> B </strong>，因为异步函数在JavaScript <strong class="lq ir">中返回<strong class="lq ir">承诺</strong>。</strong></li></ul><h2 id="480f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">8.await关键字阻塞应用程序中所有JavaScript代码的执行，直到等待的承诺被返回？</h2><ul class=""><li id="713a" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">答案是<strong class="lq ir">False</strong>,<strong class="lq ir">await</strong>关键字只会阻止包含<em class="md"> await </em>关键字的特定函数内的代码执行。</li></ul><h2 id="ac14" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 9。下面打印的是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/262e16fde577fe64091ae0394af5b27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_vYx9BmjchILfgaind1kQ.png"/></div></div></figure><ul class=""><li id="a19b" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">然而JavaScript中的函数是对象，<strong class="lq ir"> typeof </strong> name将打印<strong class="lq ir">函数</strong>。</li></ul><h2 id="0210" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 10。以下是打印'<em class="mg">用户名</em>'的有效语法？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/84f87faa9186a885950555a6b2429dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DriTgyY2BxJOSTqPyvcMIg.png"/></div></div></figure><ul class=""><li id="da0e" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">下面的语法是有效的，因为我们正在将一个<strong class="lq ir"> <em class="md">异步函数</em> </strong>的返回值传递给一个<strong class="lq ir">回调</strong>。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="fa63" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">11。哪一个不是的<em class="mg">类型和</em>的<em class="mg">实例的区别？</em></h2><ul class=""><li id="0736" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated"><strong class="lq ir"> <em class="md"> typeof </em> </strong>返回类型，而<strong class="lq ir"> <em class="md"> instanceof </em> </strong>返回布尔值。</li><li id="1563" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated"><strong class="lq ir"><em class="md"/></strong>的实例需要TypeScript，<strong class="lq ir"><em class="md"/></strong>的类型不需要。</li><li id="f6fc" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated"><strong class="lq ir"> <em class="md"> typeof </em> </strong>取右边的变量名，<strong class="lq ir"> <em class="md"> instanceof </em> </strong>取左边和右边的值代替。</li></ul><p id="92a1" class="pw-post-body-paragraph nd ne iq lq b lr ls jr nf lt lu ju ng la nh ni nj le nk nl nm li nn no np ly ij bi translated">答案是<strong class="lq ir"> B </strong>，因为它们都不需要TypeScript，而且都是JavaScript自带的。</p><h2 id="2b18" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 12。当所有的<em class="mg">承诺</em>都兑现时，下列哪一项解决？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4fb5cb56073c06171eac3fda6caf7416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*vlD6FP3OprlTWRiZr9R82A.png"/></div></figure><ul class=""><li id="9e44" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">答案是C，<strong class="lq ir"> Promise.all() </strong>在要求我们等待执行，直到所有的承诺都解决了的时候，还是相当有用的。</li></ul><h2 id="fc30" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 13。控制台输出会是什么，为什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c03ee28c18183f54f651a9874482a43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*Z5a-8Oe5nUpugzVEQkb92A.png"/></div></figure><ul class=""><li id="b48b" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">在这种情况下，我们有了与&amp; <strong class="lq ir"> &amp; </strong>运算符完全不同的<strong class="lq ir"> &amp; </strong>运算符。<strong class="lq ir"> &amp; </strong>是一个按位运算符，当我们比较<strong class="lq ir"> 11和3 </strong>时，对于<strong class="lq ir"> 1011 </strong>和<strong class="lq ir"> 0011 </strong>在二进制中是一样的。因此，只有都为1的位保持为1，返回的输出为<strong class="lq ir"> 0011 </strong>，这是<strong class="lq ir"> 3、</strong>的二进制表示，因此3记录在控制台上。</li></ul><h2 id="f3fb" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 14。对象的价值是什么。[[原型]]？</strong></h2><ul class=""><li id="efe9" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">目标</li><li id="aaf8" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">空</li><li id="df41" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi">{}</li></ul><p id="8ec2" class="pw-post-body-paragraph nd ne iq lq b lr ls jr nf lt lu ju ng la nh ni nj le nk nl nm li nn no np ly ij bi translated">答案是<strong class="lq ir"> null </strong>，作为<strong class="lq ir">对象的默认值。[[Prototype]]  </strong>为<strong class="lq ir"> null </strong>，在控制台上会返回undefined。该对象位于原型链的顶端，当browse查找被访问属性的值时，它将遍历原型链，直到找到该值，或者直到不再有原型要遍历。</p><h2 id="e944" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">15。无效合并运算符是做什么的？</h2><ul class=""><li id="06e8" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">当左边的操作数为空或未定义时，它返回右边的操作数。</li></ul><h2 id="1426" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 16。getElementsByTagName是JavaScript函数？</strong></h2><ul class=""><li id="ab5a" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不，<em class="md"> getElementsByTagName </em>是一个<strong class="lq ir"> Web API </strong>函数，就像普通的JS函数一样可用。</li></ul><h2 id="a10c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 17。当我们在JavaScript中使用事件委托时。</strong></h2><ul class=""><li id="bcf2" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">例如，当我们必须监听页面加载期间可能不存在的事件时，我们可以使用<em class="md">事件委托</em>，并在父元素上提供一个事件处理程序并查看<strong class="lq ir"> event.target. </strong>然而，如今现代前端框架和库使得这变得不那么必要了。</li></ul><h2 id="afcc" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">18。以下哪一项不是内置的JS错误类型？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3f7dd796a93eca6d13a7a3740d35c9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*0k53KEgVL33L22hzBz7vtA.png"/></div></figure><ul class=""><li id="3055" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">答案是<strong class="lq ir"> E. </strong></li></ul><h2 id="22d8" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 19。以下哪一项不是有效的承诺方法？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/21ea7cf044f7bc06cffb45bb47985efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*T0j7NNKgAn9SLrmqrT_VDw.png"/></div></figure><ul class=""><li id="a0cf" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">答案是a。</li></ul><h2 id="b637" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">20。我们可以在字符串创建后修改它吗？</h2><ul class=""><li id="3a8a" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不会，因为<strong class="lq ir">字符串</strong>在<em class="md"> JavaScript </em>中是不可变的，指向一个字符串的变量可以赋给另一个字符串。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="7af7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">21。promise链中的嵌套catch可以捕获promise链中更高层的错误吗？</h2><ul class=""><li id="0854" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不，嵌套是一种控制结构，用于限制catch语句的范围。简而言之，嵌套的catch只捕捉其作用域及其以下的错误，而不捕捉嵌套作用域之外的更高层次的错误。</li></ul><h2 id="3e5d" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">22。控制台输出会是什么，为什么？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/d5456e14808178de661a8edd7eb593eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mH_eLCF6ha2AdC86imGzig.png"/></div></div></figure><ul class=""><li id="3f62" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">即使<strong class="lq ir"> mymap.get({}) </strong>是有效的语法，它也会在控制台上返回undefined。因为set中的对象和get中的对象是内存中两个不同的空对象，因此getter不返回值。</li></ul><h2 id="39de" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 23。控制台输出会是什么，为什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/1fd73aadc332253e53dcd72bde6b5d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Seb82y5ZUxC7_GD9T892zw.png"/></div></div></figure><ul class=""><li id="9923" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">控制台输出将是<strong class="lq ir"> map{'a' = &gt; 2，' b' = &gt; 2，' c' = &gt; 1}，</strong>，这意味着第二个Map中所有相同的键将覆盖第一个Map中的键。</li></ul><h2 id="67b8" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">二十四。括号符号可以像点符号一样链接吗？</strong></h2><ul class=""><li id="62c2" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">是的，<strong class="lq ir"> obj.prop1.prop2 </strong>和<strong class="lq ir"> obj['prop1']['prop2'] </strong>是等价的。</li></ul><h2 id="ed3c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 25。什么类型的属性出现在for…in循环中？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/208f6a28a22387b3c5cc38a966d392d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHPW9zwW0Lq8xY7Uz9xDzg.png"/></div></div></figure><ul class=""><li id="3c65" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">答案是<strong class="lq ir"> B，可枚举属性。</strong></li></ul><h2 id="9519" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 26。下面打印的是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/3283231568ff2168b50cdf1c6b82c0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6e0JtdJNNieF29NIgLPnKw.png"/></div></div></figure><ul class=""><li id="5763" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">控制台输出将是<strong class="lq ir"><em class="md">【Mohit】</em></strong><em class="md">，</em>因为内部函数可以访问外部作用域中声明的变量。</li></ul><h2 id="2312" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 27。函数引用自身进行递归的三种方式是什么？</strong></h2><ul class=""><li id="7600" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated"><strong class="lq ir">函数名</strong>，一个<strong class="lq ir">作用域内</strong>变量，使用<a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">参数引用函数&amp;。</strong></a></li></ul><h2 id="de8a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 28。JavaScript支持重载吗？</strong></h2><ul class=""><li id="e6c9" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不，<strong class="lq ir"> <em class="md"> JavaScript </em> </strong>本身不支持重载，但是<strong class="lq ir"> <em class="md"> TypeScript </em> </strong>支持。但是，在JavaScript中，当没有将所有可能的参数传递给函数时，可以通过让函数返回不同的输出来执行重载。</li></ul><h2 id="d4ca" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 29。return语句在数组的forEach循环中做什么？</strong></h2><ul class=""><li id="8720" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">它不返回任何东西，如果你需要从循环中返回值，千万不要使用forEach循环。</li></ul><h2 id="3d8c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">三十岁。<em class="mg"> RegExp </em>没有任何属性。对吗？</h2><ul class=""><li id="b312" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不，<strong class="lq ir"> RegExp </strong>有很多属性比如<strong class="lq ir">。标志</strong>和<strong class="lq ir"> .global. </strong></li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="1c9c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">三十一。控制台输出会是什么？</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/eb3cf26834972be4b6908882bde018c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djXos-nuZ5WgIGlpHpXJVQ.png"/></div></div></figure><ul class=""><li id="e0cd" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">控制台输出将是<strong class="lq ir"> 10 </strong>和<strong class="lq ir"> 5 </strong>，因为该函数在承诺中没有<strong class="lq ir"><em class="md"/></strong>异步，承诺同步解析<strong class="lq ir"><em class="md"/></strong>。</li></ul><h2 id="3b8b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">32.哪个函数在浏览器下一次重画显示之前执行指定的代码块？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/9e0e9aaccc86c59249d57ff6ad58c014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yowjFn8dHSVzvwFLj_2MMA.png"/></div></div></figure><ul class=""><li id="4812" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">requestAnimationFrame()。</li></ul><h2 id="995c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">33.为什么在导入模块时使用别名？</h2><ul class=""><li id="e7fc" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">大多数情况下，我们处理简单的导入，使用默认的命名约定，除此之外，有时我们不得不处理更长的导入，其名称不能正确表达代码的功能。在这种情况下，使用别名很有帮助。</li></ul><h2 id="e585" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">34.使用reducer函数从一组数字中找出最小值。</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/a4a426f869f7d178207cd77d095e86f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqlV00kYzyE9xA-y8TxqNQ.png"/></div></div></figure><h2 id="53fc" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">35.JavaScript中的子程序是什么？</h2><ul class=""><li id="50b6" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">子例程是在主例程中遇到的函数，然后保存到对象中，以备后用。<strong class="lq ir"> <em class="md">例如</em> </strong>执行范围(<strong class="lq ir">变量、</strong>等)与子程序一起存储。</li></ul><h2 id="99c0" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">36.我们可以使用eventHandlers剪切和复制来阻止用户将内容从浏览器复制到剪贴板吗？</h2><ul class=""><li id="1d44" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">是的，这些事件处理程序是<strong class="lq ir"> <em class="md"> Web API </em> </strong>的一部分。</li></ul><h2 id="e88c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">37.创建新对象的三种可能方式是什么？</h2><ul class=""><li id="d89d" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated"><strong class="lq ir">new Object()</strong>&amp;<strong class="lq ir">Object . create()</strong>和<strong class="lq ir"> literal notation </strong>，这里我们这样定义对象——(<strong class="lq ir">const obj = { a:2 }</strong>)。</li></ul><h2 id="8958" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">38.控制台输出会是什么，为什么？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/8a68f506f1ccc8003be22b0808dd5fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ORNg0hShJYFqSgadM979ew.png"/></div></figure><ul class=""><li id="2b0a" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated"><strong class="lq ir"> a </strong>被分配给一个对象，<strong class="lq ir"> b </strong>使用spread运算符被分配给<strong class="lq ir"> a </strong>，这意味着<strong class="lq ir"> a </strong>和<strong class="lq ir"> b </strong>在技术上是相同的。</li><li id="7c48" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated"><strong class="lq ir"> c </strong>只是一个空对象。</li><li id="19c1" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">使用<strong class="lq ir"> Object.assign()，c现在被赋值</strong>到<strong class="lq ir"> a，</strong>之后，我们将<strong class="lq ir"> a </strong>中<strong class="lq ir"> x </strong>的值改为<strong class="lq ir"> 2。</strong></li><li id="0fea" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">控制台输出将是<strong class="lq ir"> 2，1，1 </strong>。</li></ul><h2 id="4582" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">39.Object.freeze()是做什么的？</h2><ul class=""><li id="20ce" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">它阻止添加新属性。</li><li id="0202" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">它防止改变对象的原型。</li><li id="3816" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">它防止更改属性值。</li><li id="96bc" class="lo lp iq lq b lr mi lt mj la mk le ml li mm ly lz ma mb mc bi translated">它防止更改属性的可写性。</li></ul><h2 id="dd00" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">40.event.target与event.currentTarget有何不同？</h2><ul class=""><li id="30be" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated"><em class="md"> event.currentTarget </em>随着事件冒泡而变化，而<em class="md"> event.target </em>保持不变。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="1b69" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">41.数组sort()方法的默认排序是什么？</h2><ul class=""><li id="bc67" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">按字符值从最小到最大。</li></ul><h2 id="fc3a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">42.什么是竞争条件？</h2><ul class=""><li id="4bdb" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">当两个线程或者<strong class="lq ir"> <em class="md">异步</em> </strong>进程为了更新某个共享状态，必须完成自身，否则就会出现bug或者不想要的结果。</li></ul><h2 id="4939" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">43.JavaScript中的class关键字是做什么的？</h2><ul class=""><li id="0362" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">只是语法糖让JavaScript更加<strong class="lq ir"><em class="md"/></strong>面向对象，即使使用了<strong class="lq ir"> <em class="md"> class </em> </strong>关键字，JavaScript依然使用原型继承。</li></ul><h2 id="a5d0" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">44.queueMicrotask队列中的任务以后进先出的方式执行。这是真的吗？</h2><ul class=""><li id="e184" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">不，任务按先进先出的顺序执行。</li></ul><h2 id="cb4a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">45.什么是影子DOM API？</h2><ul class=""><li id="66a7" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated"><em class="md"> Shadow DOM API </em>提供了一种将隐藏的独立DOM附加到一个元素上的方法，该元素不能通过通常的<strong class="lq ir"> JS DOM </strong>操作API来访问。它提供了<strong class="lq ir"> Web组件</strong>的封装。</li></ul><h2 id="e68f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">46.哪种方法用于将阴影DOM树附加到指定元素并返回对其阴影根的引用？</h2><ul class=""><li id="91b9" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">Element.attachShadow()。</li></ul><h2 id="b914" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">47.控制台输出会是什么，为什么？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2526fa08e2a2eea1a6c96fd67bd53a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qqVbF8qCXZLa0LVuaQyhQ.png"/></div></div></figure><ul class=""><li id="e56e" class="lo lp iq lq b lr ls lt lu la lv le lw li lx ly lz ma mb mc bi translated">它返回<strong class="lq ir"> h，</strong>，因为在JavaScript中数组是从零开始的，因此<strong class="lq ir"> arr[2][1] </strong>将访问外部数组的第3个元素和内部数组的第2个元素，这给出了值<strong class="lq ir"> "h" </strong>。</li></ul><h2 id="fe8f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">48.window.localStorage和window.sessionStorage有什么区别？</h2><ul class=""><li id="0a19" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">它们都将<strong class="lq ir">键/值</strong>对存储在web浏览器中，但是<strong class="lq ir">会话存储</strong>会在浏览器关闭后删除。</li></ul><h2 id="082b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">49.的！运算符返回一个布尔值。这是真的吗？</h2><ul class=""><li id="c94b" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">是的，例如在一个<strong class="lq ir"> <em class="md"> if语句中</em> </strong>需要在求值中返回一个布尔值，比如<strong class="lq ir"> if(a！== b) </strong>。</li></ul><h2 id="26ce" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">50.JavaScript中哪个ES6函数返回新数组？</h2><ul class=""><li id="9aee" class="lo lp iq lq b lr mo lt mp la mq le mr li ms ly lz ma mb mc bi translated">map() &amp; filter()。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt oa"><a href="https://mohit19.medium.com/55-questions-to-master-the-javascript-coding-interview-ba49f7b2065a" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">掌握JavaScript编码面试的55个问题</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">JavaScript编码面试问题:第2部分</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">mohit19.medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div><div class="op oq gp gr or oa"><a rel="noopener  ugc nofollow" target="_blank" href="/6-front-end-optimization-techniques-for-web-applications-6bcde2c42905"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">Web应用程序的6种前端优化技术</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">构建极快的Web应用程序</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oj l"><div class="os l ol om on oj oo kp oa"/></div></div></a></div><div class="op oq gp gr or oa"><a rel="noopener  ugc nofollow" target="_blank" href="/7-concepts-of-object-oriented-javascript-you-need-to-know-5634363f6fdc"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">你需要知道的面向对象JavaScript的7个概念</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">像专业人士一样使用JavaScript</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oj l"><div class="ot l ol om on oj oo kp oa"/></div></div></a></div><div class="op oq gp gr or oa"><a rel="noopener  ugc nofollow" target="_blank" href="/4-concepts-you-shouldnt-miss-while-learning-javascript-2906d2571f1e"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">学习JavaScript时不应错过的4个概念</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">刷新基本的ES6 JavaScript概念</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oj l"><div class="ou l ol om on oj oo kp oa"/></div></div></a></div><div class="op oq gp gr or oa"><a rel="noopener  ugc nofollow" target="_blank" href="/9-programming-principles-every-software-developer-should-know-9fffe3c5258"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">每个软件开发人员都应该知道的9条编程原则</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">很好地了解干净代码的编程原则</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oj l"><div class="ov l ol om on oj oo kp oa"/></div></div></a></div></div></div>    
</body>
</html>