# Angular 符合 RxJS — RxJS 运算符(第 3 部分)

> 原文：<https://javascript.plainenglish.io/angular-meets-rxjs-rxjs-operators-e64caa5f72e7?source=collection_archive---------13----------------------->

![](img/fe5d336aa384f653ae7d59010bdd1e82.png)

Photo by [Erik Mclean](https://unsplash.com/@introspectivedsgn?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 介绍

这篇文章属于名为“ **Angular meets RxJS** ”的系列文章，在这篇文章中，我尽我所能在“Angular”上下文中使用“RxJS”来解释反应式编程。

# 目录

[基本概念](/angular-meets-rxjs-basic-concepts-f178d8fe0e02)
[RxJS 科目](/angular-meets-rxjs-rxjs-subjects-32cac1b2c8d3)
[RxJS 运算符(第 1 部分)](/angular-meets-rxjs-rxjs-operators-part-1-9e9751a9373e)
[RxJS 运算符(第 2 部分)](/angular-meets-rxjs-rxjs-operators-60d8b2140d20)
RxJS 运算符(第 3 部分)
[“take until”和“async”管道](https://ssougnez.medium.com/angular-meets-rxjs-takeuntil-and-the-async-pipe-4d9c6e3d5c2d)
[高阶可观察量](https://ssougnez.medium.com/angular-meets-rxjs-higher-order-observables-632e560ce2d0)
[错误处理](https://ssougnez.medium.com/angular-meets-rxjs-error-handling-8fad48721e49)
RxJS 调度器(即将推出)

# 在上一篇文章中…

…我们看到了一些流行且有用的“RxJS”运算符。在本文中，我们将继续这条道路，在这里，我将介绍一些其他非常有趣的操作符。再说一次，如果你觉得我忘记了一个重要的或不清楚的，请在评论中告诉我，我会改进这篇文章。

# 勇气

![](img/2ecc445203bc16e2ce534c05bb720414.png)

“pluck”操作符类似于“map”操作符的轻量级版本。您可以使用它来选择发射值的属性。例如，您可以执行以下操作来选择值的长度属性。

在这个例子中，我们为每个发出的值发出“length”属性的值。

![](img/48ebb06951440b4830a3a7dd7a9f8147.png)

请注意，您可以通过向运算符传递多个属性名来遍历嵌套属性。例如:

此示例将产生值“2”和“未定义”,因为“obj2”中不存在属性“bar”。

![](img/6bc82035eeba20fa30af0c4b2475313f.png)

此示例的大理石图如下:

![](img/9a6a1d5f9c00fbdb93e1142aad9c5a78.png)

# 开始于

![](img/2e77a7bd9c891f7ea4e95ccc7fdd45c7.png)

“startWith”运算符可用于在源可观测值的第一个值之前发出一个值。当您订阅一个在订阅时不发出值的可观察对象时，这非常有用，这样，您可以在处理由源可观察对象本身发出的值之前发出一个默认值。

在这个例子中，在“startWith”操作符发出值“0”之后，源可观察对象发出从“1”到“10”的值。

![](img/c060f5e5ff7fa2961934ba3bfb26235e.png)

请注意，您并不局限于一个值，您可以在参数中将任意多个值传递给操作符。

大理石图如下:

![](img/e60e2665a3ebea14987055eda64c93b9.png)

# 耽搁

![](img/779d7eb31e3eaab644774c14e4bd4c1c.png)

您可以使用“延迟”操作符延迟数值发射:

在这种情况下，“范围”的第一个值会延迟一秒钟发出。

![](img/4f085c295dc46890f1a31108fb4e5663.png)

这个操作符在“角度”上下文中可能非常有趣，可以等待执行变化检测循环。您可能对这些情况很熟悉，在这些情况下，您希望在视图刷新后更新值**。大多数时间，您使用持续时间为“0”的“setTimeout”来延迟事件循环执行后的代码执行。您可以通过使用值为“0”的“延迟”运算符来实现同样的目的。**

该示例的大理石图如下:

![](img/5487eca034259a06d6d36e17ed333809.png)

# bufferCount

“bufferCount”运算符在将某些值作为数组发出之前对其进行缓冲。例如:

上面的代码缓冲发出的值，当缓冲区大小达到“2”时，发出一个包含缓冲值的数组。

![](img/82e2c1dec8afe297bb6bf92b6f3386d3.png)

您也可以将另一个参数传递给该运算符，以便在缓冲区启动时使用。例如，您可以说您想按“3”缓冲值，但您想让缓冲区的开始每“2”个值出现一次:

在这种情况下，您会得到由可观察的输出发出的三个值的数组。但是，正如您在“2”上定义的“startBufferEvery”参数，缓冲区将每两个值启动一次。

因此，第一个缓冲区从“0”开始，包含三个值:“1”、“2”和“3”。当您将第二个参数“bufferCount”定义为“2”时，下一个缓冲区不会从“4”开始，而是从“3”开始。实际上，该参数指示“bufferCount”每两个值启动一次缓冲区，所以在“1”和“2”之后，所以在“3”处。等等，等等…

![](img/4ee3414fc12492cd3c3b4d696c2e6a3b.png)

我个人很难想象这种情况会有用，但知道它的存在是件好事。

第一个示例的大理石图如下:

![](img/a6fa4625148d660317a3e413fadc30df.png)

# 扫描

![](img/9f74b62b0d584fb29804d5573cc4a2a5.png)

“扫描”操作符会随时间减少发射值。没有例子很难解释清楚，所以让我们看看下面的例子:

上面的代码为发出的每个值应用了 reducer(第一个参数)。“acc”是我们所说的“累加器”,“value”是发出的值。让我们把它分成几个步骤，让它变得清晰明了。

*   发出第一个值(“1”)。
*   执行减法器，并将发射值与累加器的当前值相加。由于在当前值之前没有发出任何值，所以使用种子值(“0”)作为累加器的值，因此发出的值是“0”+“1”，因此是“1”。
*   发出下一个值(“2”)。
*   执行减法器，并将发射值与累加器的当前值相加。由于一个值已经发出，累加器的值是输出可观察到的先前发出的值(“1”)，因此发出的值是“2”+“1”，所以是“3”。
*   发出下一个值(“3”)。
*   累加器值现在是“3”(因为这是输出可观测值发出的最后一个值)，因此下一个发出的值是“3”+“3”，所以是“6”。
*   如此等等…

![](img/59a971151339a8ce177a55a6b3741fec.png)

“种子”(第二个参数)不是强制的，但是，我的建议是总是定义它以避免奇怪的结果。

这个例子的大理石图是:

![](img/c8630ad0b22dcd96e74ea27f4a5bd4dd.png)

# 减少

![](img/ab7f82c2ee68b8dce6028ef440988b52.png)

“reduce”操作符的行为与“scan”操作符完全一样，只是它只在源观察完成时发出最终值。

这段代码的执行与“scan”操作符的执行完全相同，但是，当源观察完成时，只发出最后一个值。这意味着如果你使用一个永无止境的源可观测值(例如使用“区间”)，你将永远得不到这个值。上面代码的结果是:

![](img/024272987c904c31b5e953b68c436c60.png)

该示例的大理石图如下:

![](img/a56e6abaae6ae977e5803a519e6244cc.png)

# 去抖时间

![](img/6014452779b9dfa79abb410e43dcaa55.png)

该运算符不会发出由源可观察对象发出的值，直到某个时间段没有值发出为止。这通常是您希望在组件中使用的操作符，例如“提前键入”,在这种情况下，您触发 HTTP 调用来搜索用户在 input 元素中键入的内容。为此，您希望避免为输入中键入的每个字符调用 REST API。“去抖时间”可以帮助你，因为它会等待一段时间，没有任何发射值通过之前发射最后一个值。

让我们再举一个例子，您想要在页面上发出光标位置，但是只有当它停止移动 100 毫秒时(为了避免接收太多的值)。

从下面的结果可以看出，只有当光标停止移动超过 100 毫秒时，控制台才会记录光标的移动。

![](img/bc4584b9bd3b0a296ff97d3ef1ee5978.png)

所以基本上，当一个值“A”被可观测源发出时，“去抖动时间”操作符启动一个定时器。当发出值“B”时，操作符将把经过的毫秒数与参数中传递的值进行比较。如果前者低于后者，则值“A”被丢弃，计时器被重置。只有当经过的毫秒数大于 parameter 中指定的值时，输出可观察值才会发出该值。

我不会提供一个大理石图，因为我发现当它们涉及操作者处理时间时，它们有点令人困惑，但是，不要犹豫，可以在谷歌上找到一些。

# 采样时间

![](img/28a9cea57b32b11e3ae1a406da010f3e.png)

“sampleTime”操作符只是每隔“X”毫秒检查一次自上次检查以来是否有值被发出，如果有，就发出它。看看下面的例子:

在这个例子中,“sampleTime”操作符每秒检查一次源可观察对象自上次检查以来是否发出了一个值。第一次检查在一秒钟后完成，此时，源可观察对象已经发出两个值:“0”和“1”，因此“1”由输出可观察对象发出。然后，在总共 1.4 秒后，源可观察对象发出值“2”，因此当“sampleTime”操作符在两秒后(总共)检查自上次检查以来是否发出了新值时，它找到“2”并发出它。现在，在“2”发出 100 毫秒后，源可观测物发出“3”，然后，在“4”发出 700 毫秒后。换句话说，值“4”在总共 2.8 秒后发出，因此当“sampleTime”在总共三秒后执行第三次检查时，它发出的是值“4”而不是“3”。

![](img/159191f24011d61112f8a3bb164c7f74.png)

我不会提供一个大理石图，因为我发现当它们涉及操作者处理时间时，它们有点令人困惑，但是，不要犹豫，可以在谷歌上找到一些。

# 缓冲时间

“bufferTime”操作符的行为类似于“sampleTime”操作符，但它发出所有发出的值，而不是最后一个值。让我们举一个和上面一样的例子，把“sampleTime”换成“bufferTime”。

使用此运算符，结果如下:

![](img/ce53605406964b11e858d8a96750361b.png)

基本上，这个解释与“sampleTime”的解释完全相同，只是“bufferTime”不是只发出最后一个值，而是发出一个包含所有发出值的数组。

*我不会提供一个大理石图，因为我发现当他们涉及到运营商处理时间时有点混乱，但是，不要犹豫，看看谷歌上找到一些。*

# 节流时间

![](img/ded3f77d362962f12dfec96452adff1e.png)

“throttleTime”操作符发出值，然后在指定的时间内忽略后面的值。例如:

在这个例子中，源可观察对象从发出值“0”开始，这个值由“throttleTime”操作符转发给输出可观察对象。然后，操作符开始忽略一秒钟的值，因此它不会转发 700 ms 后由源可观测物发出的值“1”。但是，它会在总共 1.4 秒后发出值“2”。一旦发出一个值，忽略期就再次开始，这就是为什么值“3”没有被转发到输出可观察值。

![](img/52eb3b883a10c8fa4ffbffb5a6c08e2d.png)

*我不会提供一个大理石图，因为我发现当他们涉及到运营商处理时间时有点混乱，但是，不要犹豫，看看谷歌上找到一些。*

# 审计时间

![](img/c13802570fddbe1fa1860ae248126973.png)

“auditTime”与“throttleTime”非常相似，只是它不是在忽略期开始时发出第一个发出的值，而是在忽略期结束时发出最近的值。让我们通过将“throttleTime”替换为“auditTime”来更新前面的代码。

源 observable 从立即发出“0”开始，这开始了一秒钟的时间，在此期间“auditTime”不转发发出的值。当值“1”在 700 ms 后发出时，该周期仍在继续，当该周期结束时，300 ms 后，“auditTime”转发可观察源最近发出的值:“1”。只要源可观测对象发出新的值，这个过程就重复进行。

![](img/ece237eeb9d148594bc70df0b7dbb673.png)

我不会提供一个大理石图，因为我发现当它们涉及操作者处理时间时，它们有点令人困惑，但是，不要犹豫，可以在谷歌上找到一些。

# 最后的想法

在前三篇文章中(算上这篇文章)，我们学习了如何使用许多“RxJS”操作符，尽管还有许多其他操作符我们没有看到，但我们看到的这些操作符应该允许您通过管道连接它们来创建一些非常好的观察对象。

下一篇文章将关注另一个操作符:“takeUntil”，展示如何在“Angular”上下文中使用这个操作符来大大减少调用“unsubscribe”方法来释放资源的次数。

然后，我们将讨论一些更复杂的运算符，用于返回可观测量并管理它们的订阅。

[![](img/6d60b235fcc46a4bd696b90e886419ee.png)](https://www.buymeacoffee.com/ssougnez)