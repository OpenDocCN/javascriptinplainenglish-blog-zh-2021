<html>
<head>
<title>LeetCode Algorithm Series: Height Checker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode算法系列:高度检查器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leetcode-algorithm-series-height-checker-2cb703879529?source=collection_archive---------10-----------------------#2021-07-02">https://javascript.plainenglish.io/leetcode-algorithm-series-height-checker-2cb703879529?source=collection_archive---------10-----------------------#2021-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fb1534e03bad34ccc98946bf2eb2c898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohRnf8u6WIttSucTzbE8Sw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c66f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你好！欢迎回到另一个算法问题。这个问题实际上是建立在我之前写的算法的经验之上的。你可以在这里查看:<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca">合并排序数组</a>。</p><p id="d3cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题来自于LeetCode的《数据结构导论:数组101》。因此在<strong class="kc io">高度检查器中:</strong></p><blockquote class="ky kz la"><p id="12f2" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">一所学校正试图给所有学生拍一张年度照片。学生们被要求站成一排，按照身高的降序排列。让这个顺序由整数数组<code class="fe lf lg lh li b">expected</code>表示，其中<code class="fe lf lg lh li b">expected[i]</code>是排队的<code class="fe lf lg lh li b">ith</code>学生的预期高度。</p><p id="9505" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">给你一个整数数组<code class="fe lf lg lh li b">heights</code>，表示学生所在的<strong class="kc io">当前订单</strong>。每个<code class="fe lf lg lh li b">heights[i]</code>是队列中<code class="fe lf lg lh li b">ith</code>学生的身高(<strong class="kc io">0-索引</strong>)。</p><p id="acb7" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">返回<em class="in">中的</em> <strong class="kc io"> <em class="in">编号索引</em> </strong> <em class="in">其中</em> <code class="fe lf lg lh li b">heights[i] != expected[i]</code>。</p></blockquote><p id="cbd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="7497" class="lr ls in li b gy lt lu l lv lw"><strong class="li io">Input:</strong> heights = [1,1,4,2,1,3]<br/><strong class="li io">Output:</strong> 3<br/><strong class="li io">Explanation:</strong> <br/>heights:  [1,1,4,2,1,3]<br/>expected: [1,1,1,2,3,4]<br/>Indices 2, 4, and 5 do not match.</span></pre><p id="7448" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分解这个问题，我们有一个没有排序的高度数组。如果我们有一个高度的排序数组，我们希望将该数组与原始数组进行比较，看看有多少索引不匹配，并返回相应的数量。</p><p id="0a5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以对我来说，这分为两个主要步骤。</p><ol class=""><li id="1552" class="lx ly in kc b kd ke kh ki kl lz kp ma kt mb kx mc md me mf bi translated">我需要创建一个新的高度排序数组</li><li id="3e83" class="lx ly in kc b kd mg kh mh kl mi kp mj kt mk kx mc md me mf bi translated">我会遍历数组，将每个值相互比较，以计算差异。</li></ol><h1 id="3314" class="ml ls in bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">第一步。创建一个排序数组</h1><p id="4c04" class="pw-post-body-paragraph ka kb in kc b kd ni kf kg kh nj kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">为了创建一个排序的数组，我需要依靠我用来解决我之前的算法问题的技巧。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="8554" class="lr ls in li b gy lt lu l lv lw">let count = 0;<br/>let expected = [...heights]</span><span id="4837" class="lr ls in li b gy nn lu l lv lw">for (let i = 1; i &lt; expected.length; i++) {<br/>        if (expected[i-1] &amp;&amp; expected[i] &lt; expected[i-1]) {<br/>            let tmp = expected[i-1]<br/>            expected[i-1] = expected[i]<br/>            expected[i] = tmp<br/>            i -= 2<br/>        }<br/>    }</span></pre><p id="ceaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我设置了一个计数，它将是我返回的值，也是我将在步骤2中处理的内容。然后，我创建了一个名为<strong class="kc io">预期为</strong>的新数组，这样我就可以保持原来的数组不变。注意<strong class="kc io">展开操作器</strong>的使用。您还可以使用<strong class="kc io"> slice()方法</strong>来创建数组的副本。</p><blockquote class="ky kz la"><p id="916b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">为什么不直接设置期望等于高度数组？</p></blockquote><p id="7ceb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中的数组在技术上是对象，而变量是对象的引用，而不是对象本身。因此，如果我只是设置<strong class="kc io">预期</strong>等于<strong class="kc io">高度</strong>数组，两个变量都引用同一个对象<em class="lb">。这意味着我对其中一个变量所做的任何改变都会影响到另一个变量。</em></p><h1 id="dc72" class="ml ls in bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">第二步。比较数组并计数</h1><p id="b307" class="pw-post-body-paragraph ka kb in kc b kd ni kf kg kh nj kj kk kl nk kn ko kp nl kr ks kt nm kv kw kx ig bi translated">现在我们有了一个排序后的数组，我们需要做的就是将两个数组相互比较。因为我们现在长度是相同的，我们可以用数组长度创建一个for循环，或者你可以在代码的前面创建一个变量来保存数组的长度。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="4302" class="lr ls in li b gy lt lu l lv lw">for (let j = 0; j &lt; heights.length; j++) {<br/>        if (heights[j] !== expected[j]) {<br/>            count += 1<br/>        }<br/>    }<br/>    <br/>    return count</span></pre><p id="2418" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，只需记住我们希望知道数组中当前索引<strong class="kc io">处的元素与数组间的</strong>不匹配的时间。然后我们只需在每次为真时将count变量加1(你也可以使用<strong class="kc io"> ++ </strong>快捷键)。</p><p id="ee30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是它的全部内容，非常简单明了！这是处理数组、循环和排序的好习惯。这样做的时间复杂度将是O(n ),因为我正在为循环运行2个<strong class="kc io">。</strong>在LeetCode上运行这个，运行时间是72 <strong class="kc io"> ms </strong>，比提交的<strong class="kc io"> 91.30% </strong>要好。</p><p id="31e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一如既往，我很想知道我的代码是否可以进一步改进，或者你是如何解决这个算法的！</p><p id="bffb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请关注未来更多的LeetCode解决方案！</p><p id="5a54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LeetCode系列:</p><blockquote class="ky kz la"><p id="6cc2" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">1.<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/leetcodes-series-contains-duplicate-644f3f8a3291">包含重复的</a> <br/> 2。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-merge-sorted-array-3ec101aa3cca" rel="noopener">合并排序后的数组</a> <br/> 3。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-height-checker-2cb703879529" rel="noopener">高度检查器</a> <br/> 4。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-palindrome-3cd94c4b00cc" rel="noopener">有效回文</a> <br/> 5。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-happy-number-1bdea90dde7" rel="noopener">快乐数字</a> <br/> 6。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-longest-common-prefix-fc40ba439ed7" rel="noopener">最长常用前缀</a> <br/> 7。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-climbing-stairs-c308255dcb9e" rel="noopener">爬楼梯</a>T30】8。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-valid-parentheses-3a379f9dceb7" rel="noopener">有效括号</a>T33】9。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-pascals-triangle-253856454598" rel="noopener">帕斯卡三角形</a> <br/> 10。<a class="ae jz" href="https://kdshah6593.medium.com/leetcode-algorithm-series-maximum-subarray-776252f61ea0" rel="noopener">最大子阵列</a></p></blockquote><p id="e3ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lb">plain English . io</em></strong></a></p></div></div>    
</body>
</html>