<html>
<head>
<title>Canvas Animation inside React Components with requestAnimationFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有requestAnimationFrame的React组件内的画布动画</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/canvas-animation-inside-react-components-with-requestanimationframe-c5d594afc1b?source=collection_archive---------0-----------------------#2021-01-06">https://javascript.plainenglish.io/canvas-animation-inside-react-components-with-requestanimationframe-c5d594afc1b?source=collection_archive---------0-----------------------#2021-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8927c012d4da23a483bae636ce7b8d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtZ46KrCXjStn6hAEAavtw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@eiskonen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hans Eiskonen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6e46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的相关源代码可以在<a class="ae kc" href="https://gitlab.com/gvanderput/react-canvas-component" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> GitLab </strong> </a>上找到🙂</p><h2 id="ab95" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">介绍</h2><p id="2fef" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你熟悉<strong class="kf ir"> HTML画布元素</strong>，你就会知道制作动画相对容易。我们向DOM添加一个canvas元素，并借助于<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">requestAnimationFrame</strong></a>递归调用一个渲染函数。render函数操纵画布的上下文，可以添加形状、图像、文本等。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="334d" class="lb lc iq me b gy mi mj l mk ml">const ctx = canvas.getContext('2d');</span></pre><p id="857d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据你使用的浏览器和渲染函数的重量，它每秒执行60次。</p><p id="9da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">但是，如果您想在React组件中制作这样的动画，该怎么办呢？</strong></p><p id="c1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这带来了一些挑战。我们当然不想每秒60次重新渲染React组件。让我们来看看解决方案。</p><h2 id="6c07" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">画布组件</h2><p id="cd3a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将创建一个单独的(功能性的)React组件，它使用三个<a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef钩子</a>来帮助我们实现目标。</p><p id="0f64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从基础开始:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bc69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第7行，我们将<em class="mo"> canvasRef </em>传递给画布元素。这是<strong class="kf ir"> useRef </strong>的常见用例，但不是<em class="mo"> only </em>用例，我们很快就会发现。</p><p id="5c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这样做，我们将能够在我们的DOM 中访问对<em class="mo">canvas元素的引用，以便我们稍后能够访问它的2D绘图上下文。</em></p><p id="c233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是什么是useRef钩子，它做什么？</p><p id="ea34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经熟悉useRef钩子，可以跳过下一段。</p><h2 id="1c48" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">useRef</h2><p id="1ad3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">根据reactjs.org上的文档:</p><blockquote class="mp mq mr"><p id="41d5" class="kd ke mo kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">useRef返回一个可变的Ref对象。当前属性被初始化为传递的参数(initialValue)。返回的对象将在组件的整个生存期内保持不变。</p></blockquote><p id="1b8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此对useRef的调用将返回一个<em class="mo">可变对象</em>。这意味着我们可以改变。没有意外行为或副作用的当前属性。事实上，我们可以<strong class="kf ir">改变那个值</strong>，它将<strong class="kf ir">不会导致我们组件的重新提交</strong>。文件中的另一段引文:</p><blockquote class="mp mq mr"><p id="0759" class="kd ke mo kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">请记住，useRef不会在内容发生变化时通知您。变异了。当前属性不会导致重新呈现。</p></blockquote><p id="3925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某种程度上，这就像一个<strong class="kf ir">规则<em class="mo">让</em>变量</strong>。但是T4有一个很大的不同。每当我们的组件<em class="mo">由于其他外部因素</em>重新呈现时，useRef调用返回的值总是对同一个对象的引用(因此是值):</p><blockquote class="mp mq mr"><p id="f81d" class="kd ke mo kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">useRef()和自己创建一个{current: …}对象的唯一区别是useRef会在每次渲染时给你相同的Ref对象。</p></blockquote><p id="7f11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧。因此，通过使用useRef，我们可以:</p><ul class=""><li id="a5b1" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">将值存储在对象中</li><li id="33f6" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">我们可以在任何时候操作该值，而不会导致组件的重新呈现</li><li id="51dd" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">在每个重新呈现器上访问相同值</li></ul><p id="b391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说到画布动画，听起来对我很有用🙂让我们找出答案。</p><h2 id="daaa" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">开始播放动画</h2><p id="506a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们通过开始动画循环来更新我们的组件:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ded1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第17行，我们调用useEffect，通过传递一个空数组作为第二个参数，它将表现得像一个老式的<strong class="kf ir"><em class="mo">componentdidmount</em></strong>方法。作为第一个参数传递的函数将只执行一次:在我们的Canvas组件被React添加到DOM之后。</p><p id="898f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们开始制作动画的时间:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2042" class="lb lc iq me b gy mi mj l mk ml">requestAnimationFrame(tick);</span></pre><p id="a2e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当浏览器准备就绪时，这将简单地调用第11行定义的tick函数(关于requestAnimationFrame的具体行为的更多信息可以在<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> MDN </a>找到)。实际上，它会立即调用tick函数。</p><blockquote class="mp mq mr"><p id="f8e6" class="kd ke mo kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated"><em class="iq">“滴答”是在动画</em>的一帧中执行的逻辑的常用术语。</p></blockquote><p id="b167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="mo"> tick </em>中，我们渲染我们的帧(第13行),并再次递归调用tick函数(第14行)。现在忽略第12行的突破检查。</p><h2 id="02a7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">渲染框架</h2><p id="6eaf" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">renderFrame的内容是隐藏的(故意的)。关于<strong class="kf ir">渲染细节</strong>，我请参考GitLab上的<a class="ae kc" href="https://gitlab.com/gvanderput/react-canvas-component" rel="noopener ugc nofollow" target="_blank">库</a>，因为我相信它与本文无关。简而言之，它所做的就是更新我在演示中制作的球的某些属性，然后在画布上绘制这个球。</p><p id="0f3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然有一件事很重要。我制作的球是有属性的(比如它的位置和速度)。这些属性存储在一个名为“球”的对象中。因为我们希望在重新呈现器之间保持这些属性，<em class="mo">并且因为我们希望能够在不导致React组件</em>重新呈现的情况下操作这些值，所以我们将球对象存储在我们之前描述的<strong class="kf ir"> ref容器</strong>中:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="72d0" class="lb lc iq me b gy mi mj l mk ml">const ballRef = useRef({ x: 50, y: 50, vx: 3.9, ... });</span></pre><p id="37c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，我们再次访问球值:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="74e7" class="lb lc iq me b gy mi mj l mk ml">const ball = ballRef.current;<br/>// ball.x === 50</span></pre><p id="ae95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你感兴趣的话，可以看看Canvas.jsx里面的函数<em class="mo"> updateBall </em>和文件<em class="mo"> frameRenderer.js </em>。</p><h2 id="7889" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">碎片帐集</h2><p id="2049" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们的动画正在运行，并且表现良好。但是，如果我们的React组件(Canvas组件)从DOM中移除了，会怎么样呢？如果是<strong class="kf ir"> <em class="mo">卸装</em> </strong>呢？动画逻辑(tick函数的执行)将继续运行。</p><p id="aff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须自己清理。</p><p id="454f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，我前面提到的tick函数中第12行的中断已经阻止了动画在组件卸载后继续运行:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8289" class="lb lc iq me b gy mi mj l mk ml">if (!canvasRef.current) return;</span></pre><p id="81af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的原因是，当组件被卸载时，我们将丢失画布引用(它的值将变成<strong class="kf ir"> <em class="mo"> null </em> </strong>)。</p><p id="38fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们<strong class="kf ir">无论如何都应该进行一次适当的专门清理</strong>,原因有二:</p><ul class=""><li id="59a3" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">这是个好习惯。默认情况下，垃圾收集和<strong class="kf ir">防止内存泄漏</strong>应该是开发人员必备技能的一部分。</li><li id="327c" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">当使用CRA和捆绑的<em class="mo">热重新加载</em>(例如，执行“纱线运行启动”时启动的开发环境)时，无论何时组件被“热重新加载”，都会启动一个新的动画循环，这将导致我们的动画以n倍的速度运行…</li></ul><p id="68c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们更新我们的组件(删除不相关的代码):</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="95fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们启动了一个名为<strong class="kf ir"> requestIdRef </strong>的新ref对象(第5行)。每当我们调用requestAnimationFrame时，我们都将返回值传递给这个ref对象。返回值是所谓的请求ID，这意味着它是通过调用它而启动的帧的标识符。</p><p id="e4b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以随时使用这个ID来取消我们的动画。正如我们提到的，我们希望在从DOM中卸载组件时这样做。</p><p id="94e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用钩子，在函数式React组件内部，我们可以通过在函数内部返回一个回调来实现这一点，该回调作为第一个参数传递给我们的useEffect钩子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e776" class="lb lc iq me b gy mi mj l mk ml">return () =&gt; {<br/>  cancelAnimationFrame(requestIdRef.current);<br/>};</span></pre><p id="8773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参见上面要点中的第14行。</p><h2 id="ea80" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="a242" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">暂时就这样吧！通过采取这些简单的步骤，您可以在React组件中启动一个动画，并确保它不会出现意外的行为，是高性能的，并在完成后进行清理。</p><p id="296f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢HTML画布，并希望通过写这篇小文章来传播这份爱。</p><blockquote class="mp mq mr"><p id="9f49" class="kd ke mo kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">如果你已经分享了那份爱:请留意全新的 <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Houdini" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="iq"> CSS胡迪尼</em> </strong> </a> <em class="iq">。它将允许你把你的画布知识转移到CSS的世界，并创建你自己的“CSS渲染函数”。极其强大的API，也是web开发未来的一部分，但这是另一天的主题😉</em></p></blockquote><p id="9936" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">杰拉德·范德普特</p></div></div>    
</body>
</html>