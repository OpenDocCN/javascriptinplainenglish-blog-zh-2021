<html>
<head>
<title>5 Simple Tips to Reduce your Docker Image Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩小Docker图片尺寸的5个简单技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-simple-tips-to-reduce-your-docker-image-size-9c562792af88?source=collection_archive---------13-----------------------#2021-01-04">https://javascript.plainenglish.io/5-simple-tips-to-reduce-your-docker-image-size-9c562792af88?source=collection_archive---------13-----------------------#2021-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="43cf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用基于阿尔卑斯山的图像不是唯一的方法！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dc1cdd633ccb7a6e594bc266842d2b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kGZtqVjQOwNlRPDE"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@finalhugh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kinsey</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在流了很多汗(可能还有眼泪)之后，您终于完成了web应用程序的构建。现在是时候向世界展示你出色的工作了，把它装在容器里并部署到某个地方。</p><p id="68bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“容易。我将只写一个简单的Docker文件，它使用来自<a class="ae ks" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的基本<code class="fe lp lq lr ls b">node:&lt;version&gt;</code>映像，”你对自己说。您只需这样做，构建Docker映像，并在本地测试您的web应用程序——一切看起来都很棒！但是当你决定检查Docker图像的大小时，你会发现它…大约有<strong class="kv io">千兆字节</strong>！尺寸必须是可缩小的，对吗？毕竟，您的独立应用程序大小只是其中的一小部分。</p><p id="b357" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“啊，没问题。我将使用来自<a class="ae ks" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的小得多的基础<code class="fe lp lq lr ls b">node:&lt;version&gt;-alpine</code>图像来代替。虽然这样做在大多数情况下会让你走很长一段路，但也有潜在的不兼容性和缺点。正如我们将在后面的章节中讨论的那样，基于Alpine的图像与C语言的另一个标准库打包在一起，这可能会导致意想不到的行为，特别是当您的应用程序处理预编译的二进制文件时。稍后您还将了解到，如果您担心生产中的容器安全性，还可以考虑其他紧凑的基本映像。</p><p id="e119" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将探索一些技巧和窍门来紧凑和安全地封装web应用程序。</p><h1 id="776b" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">创建应用程序</h1><p id="f759" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">出于演示目的，让我们首先使用<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建一个基本的React应用程序:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="ca5a" class="mu lu in ls b gy mv mw l mx my"><strong class="ls io">npx</strong> create-react-app docker-image-size<br/><strong class="ls io">cd</strong> docker-image-size/<br/><strong class="ls io">npm</strong> start</span></pre><p id="f91f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">转到<a class="ae ks" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，您应该会看到您的工作应用程序:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/a20e305a255852d3c5c5cb8a5a2a51d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dtRRQ6sipA5TB67UQ7sAQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of the stock application from <a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">create-react-app</a>. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><h1 id="c89e" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">基线:普通基础图像</h1><p id="fab6" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在应用程序根目录(<code class="fe lp lq lr ls b">docker-image-size</code>目录)中，创建一个以官方标准<a class="ae ks" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Node.js Docker image </a>开始的<code class="fe lp lq lr ls b">Dockerfile</code>，并执行设置和启动React应用程序的标准步骤:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="ce7e" class="mu lu in ls b gy mv mw l mx my"><strong class="ls io">FROM</strong> node:14<br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> package.json package-lock.json ./<br/><strong class="ls io">RUN</strong> npm install<br/><strong class="ls io">COPY</strong> . ./<br/><strong class="ls io">EXPOSE</strong> 3000<br/><strong class="ls io">CMD</strong> ["npm", "start"]</span></pre><p id="34fa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式构建图像(标记为<code class="fe lp lq lr ls b">baseline</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="9206" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build </strong>-t react-app:<strong class="ls io">baseline </strong>.</span></pre><p id="2657" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并且可以选择通过构建容器并导航到<a class="ae ks" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>来检查应用程序是否工作:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="6f06" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">run</strong> --<strong class="ls io">rm</strong> -it -p 3000:3000 react-app:<strong class="ls io">baseline</strong></span></pre><p id="f122" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了！让我们通过以下方式检查图像大小:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="e5a2" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/c73bdb375496c86a158b2f7a7934046a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7J-uBR7Iz2KVLBruwPneg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="90fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">果然图像挺大:<strong class="kv io"> 1.36GB </strong>！幸运的是，我们只能从这里开始改进。</p><h1 id="85df" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">1.使用排除不重要的文件。dockerignore</h1><p id="9116" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">请注意docker文件中的行<code class="fe lp lq lr ls b"><strong class="kv io">COPY</strong> . ./</code>。该命令指示我们的本地项目根目录(<code class="fe lp lq lr ls b">docker-image-size</code>)中的所有内容都应该复制到Docker映像的工作目录中。前面的Docker命令<code class="fe lp lq lr ls b"><strong class="kv io">RUN</strong> npm install</code>将项目依赖项安装到映像中的<code class="fe lp lq lr ls b">node_modules</code>目录<em class="nb">中。回想一下，在开发期间，你会有<em class="nb">你自己的</em>T4的本地副本。将其复制到映像中是多余的，也是不必要的。在本地项目目录中，还有一些应用程序不需要的额外文件，比如<code class="fe lp lq lr ls b">Dockerfile</code>本身、<code class="fe lp lq lr ls b">README.md</code>，构建工件等等。</em></p><p id="4bbb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过向本地项目根目录添加一个<code class="fe lp lq lr ls b">.dockerignore</code>文件，可以很容易地排除文件和目录:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="ca70" class="mu lu in ls b gy mv mw l mx my"># Things we should exclude from the Docker Image<br/>Dockerfile<br/>.dockerignore<br/>.gitignore<br/>README.md<br/>build<br/>node_modules</span></pre><p id="b227" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你熟悉的话，它与一个<code class="fe lp lq lr ls b">.gitignore</code>文件非常相似，你可以在这里阅读更多关于它的内容。一般来说，包含一个<code class="fe lp lq lr ls b">.dockerignore</code>文件不仅仅是为了最小化图像大小，也是为了防止秘密文件和源代码的意外暴露。</p><p id="dd7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，通过以下方式构建映像(标记为<code class="fe lp lq lr ls b">dockerignore</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="be91" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build</strong> -t react-app:<strong class="ls io">dockerignore</strong> .</span></pre><p id="1623" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并通过以下方式检查图像尺寸:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="290f" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/15dc8fa5fd9b6f2373b159be31cbd9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UY8PyTHP_9vZwLCAGkNPnw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="f3dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">进步！我们已经将图像大小从之前的1.36GB减少到了1.19GB。但是我们肯定能做得更好？实际应用仍然只占该规模的一小部分…</p><h1 id="5bc7" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">2.用Alpine变小</h1><p id="19c5" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">如果应用程序相对较小，但是Docker映像最终占用了1.19GB的空间，那么是什么用完了应用程序之外的所有空间呢？</p><p id="ac21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Docker文件中的<code class="fe lp lq lr ls b"><strong class="kv io">FROM</strong> node:14</code>行指定从<a class="ae ks" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中提取事实上的<code class="fe lp lq lr ls b">node</code>版本14基础映像。这个映像在一个成熟的操作系统(Debian)上运行Node.js、<code class="fe lp lq lr ls b">npm</code>、<code class="fe lp lq lr ls b">yarn</code>和其他二进制文件。这非常臃肿，占了我们的Docker图像大小的很大一部分。幸运的是，Node.js Docker团队还提供了<code class="fe lp lq lr ls b">node:&lt;version&gt;-alpine</code>图片，这些图片基于流行的<a class="ae ks" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine Linux项目</a>。尽管Alpine Linux仍然是一个成熟的操作系统，但它比大多数操作系统都要小得多。</p><p id="02ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是有一个小问题:Alpine Linux使用了C语言的最小替代标准库<code class="fe lp lq lr ls b"><a class="ae ks" href="http://musl-libc.org/" rel="noopener ugc nofollow" target="_blank">muslc</a></code>，而不是大多数其他发行版如Ubuntu和Debian使用的更常见的<code class="fe lp lq lr ls b">glibc</code>。这意味着您可能会遇到Alpine和预编译二进制文件(如Node.js C++扩展)之间的意外行为或不兼容，如果您的应用程序需要它们的话。<a class="ae ks" href="https://github.com/grpc/grpc/issues/8528" rel="noopener ugc nofollow" target="_blank">这里的</a>和<a class="ae ks" href="https://github.com/grpc/grpc/issues/6126" rel="noopener ugc nofollow" target="_blank">这里的</a>是一些真实世界的例子。然而，正如Docker Hub 上所说，“大多数软件都没有这个问题，所以这个变种通常是一个非常安全的选择。”不管Alpine是否适合你，一定要看看技巧4，它讨论了另一种“Distroless”图像。</p><p id="e91e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用基于Alpine的图像，替换Dockerfile文件中的<code class="fe lp lq lr ls b"><strong class="kv io">FROM</strong> node:14</code>到<code class="fe lp lq lr ls b"><strong class="kv io">FROM</strong> node:14-alpine</code>:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="49ab" class="mu lu in ls b gy mv mw l mx my"><strong class="ls io">FROM</strong> node:14-alpine<br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> package.json package-lock.json ./<br/><strong class="ls io">RUN</strong> npm install<br/><strong class="ls io">COPY</strong> . ./<br/><strong class="ls io">EXPOSE</strong> 3000<br/><strong class="ls io">CMD</strong> ["npm", "start"]</span></pre><p id="d93c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，通过以下方式构建映像(标记为<code class="fe lp lq lr ls b">alpine</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="4b17" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build</strong> -t react-app:<strong class="ls io">alpine</strong> .</span></pre><p id="8002" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并通过以下方式检查图像尺寸:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="28de" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/418e22b4b766e588dfc1288654dbfef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4d7K1N70Cf1gdO2viet5Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="9348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好多了！我们已经将图像大小从之前的1.19GB减小到了<strong class="kv io"> 362MB </strong>！这是一个巨大的胜利，但我们可以做得更好。</p><h1 id="cdef" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">3.通过多阶段构建变得更小</h1><p id="b86e" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">到目前为止，我们的docker文件已经被编写得好像我们正在进行React开发一样。在生产中，我们将使用<code class="fe lp lq lr ls b">npm run build</code>构建应用的优化版本，这将在<code class="fe lp lq lr ls b">build</code>目录中生成最终的自包含应用(另请参见<a class="ae ks" href="https://create-react-app.dev/docs/production-build" rel="noopener ugc nofollow" target="_blank"> create-react-app文档</a>)。因此，在生产中，只有<code class="fe lp lq lr ls b">build</code>目录的内容是必要的；<code class="fe lp lq lr ls b">node_modules</code>下的源代码和依赖项应该从映像中排除。</p><p id="34a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Docker的<a class="ae ks" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>允许您在docker文件中使用多个<code class="fe lp lq lr ls b">FROM</code>语句指定多个构建阶段，并选择性地将工件从一个阶段复制到另一个阶段。这样，您可以构建只包含最低限度的最终图像。</p><p id="f235" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要看到这一点，请将您的docker文件修改为:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="48a7" class="mu lu in ls b gy mv mw l mx my"># Stage 1 (named "builder"): Production React Build<br/><strong class="ls io">FROM</strong> node:14-alpine AS builder<br/><br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> package.json package-lock.json ./<br/><strong class="ls io">RUN</strong> npm install<br/><br/><strong class="ls io">COPY</strong> . ./<br/><strong class="ls io">RUN</strong> npm run build<br/><br/># Stage 2: Start fresh, install a static server,<br/># and copy just the build artifacts from the previous stage.<br/><strong class="ls io">FROM</strong> node:14-alpine<br/><br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">RUN</strong> npm install -g serve<br/><strong class="ls io">COPY</strong> --from=builder /app/build ./build<br/><br/><strong class="ls io">EXPOSE</strong> 5000<br/><strong class="ls io">CMD</strong> ["serve", "-s", "build", "-l", "5000"]</span></pre><p id="12de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面指定了多阶段构建:</p><ol class=""><li id="6154" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">阶段1执行React应用程序的生产构建。它从基于Alpine的<code class="fe lp lq lr ls b">node</code>映像开始，安装应用程序依赖项，并运行<code class="fe lp lq lr ls b">npm run build</code>来生成<code class="fe lp lq lr ls b">build</code>目录。</li><li id="2d29" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">阶段2从一个新的基于Alpine的<code class="fe lp lq lr ls b">node</code>映像开始，并从阶段1复制<em class="nb">和</em>目录(不包括<code class="fe lp lq lr ls b">node_modules</code>、源代码等)。).它还根据文档<a class="ae ks" href="https://create-react-app.dev/docs/deployment" rel="noopener ugc nofollow" target="_blank">安装了一个静态服务器</a>在端口5000监听应用程序。</li></ol><p id="3936" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式构建图像(标记为<code class="fe lp lq lr ls b">alpine-multistage</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="d7b5" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build</strong> -t react-app:<strong class="ls io">alpine-multistage</strong> .</span></pre><p id="230f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可选地，通过运行容器，然后导航到<a class="ae ks" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>，检查应用程序是否工作:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="ba3d" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">run</strong> --<strong class="ls io">rm</strong> -it -p 5000:5000 react-app:<strong class="ls io">alpine-multistage</strong></span></pre><p id="190e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式检查图像尺寸:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="1a68" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/72a7910a6658804c4417635c27f8a3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMCw7SaarCpSIqSll-FDwg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="2452" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">利润！我们已经将图像大小从之前的362MB减少到了<strong class="kv io"> 123MB </strong>(我们开始时是1.36GB)！对于大多数用例来说，这可能就足够了。</p><h1 id="0d6b" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">4.试试Distroless而不是Alpine</h1><p id="14eb" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">虽然紧凑，但基于Alpine的映像仍然包含一个成熟的操作系统。理论上，我们的应用程序只需要Node.js及其依赖项就可以运行，因此一个更小的映像应该是可能的。</p><p id="9675" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谷歌工程师有同样的想法，并提出了“Distroless”图像。显示他们的<a class="ae ks" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">项目页面</a>:</p><blockquote class="ns nt nu"><p id="cb94" class="kt ku nb kv b kw kx jo ky kz la jr lb nv ld le lf nw lh li lj nx ll lm ln lo ig bi translated">“发行版”映像只包含您的应用程序及其运行时依赖项。它们不包含包管理器、shells或任何其他您期望在标准Linux发行版中找到的程序。</p></blockquote><p id="068e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它们提供了几种图像风格，特别是提供Node.js的<a class="ae ks" href="https://github.com/GoogleContainerTools/distroless/blob/master/nodejs/README.md" rel="noopener ugc nofollow" target="_blank">。与基于Alpine的图像相比,“Distroless”图像:</a></p><ol class=""><li id="6b33" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">基于Debian，使用<a class="ae ks" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank"> bazel </a>工具构建，因此完全兼容<code class="fe lp lq lr ls b">glibc</code>。</li><li id="9735" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">可以说更安全，因为它的极简主义和没有外壳。这意味着成功访问您的容器的攻击者在没有shell访问的情况下将无法造成同样大的损害。在生产中，你不需要外壳。如果您想要调试，您应该依赖于适当的日志记录和监控。</li><li id="4326" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">通常比基于阿尔卑斯山的图像更瘦，或者差不多一样瘦。</li></ol><p id="f5bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要看到这一点，首先通过在项目根目录下添加一个包含以下内容的<code class="fe lp lq lr ls b">server.js</code>文件来添加一个简单的<a class="ae ks" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>后端:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="d035" class="mu lu in ls b gy mv mw l mx my"><strong class="ls io">const</strong> express = <strong class="ls io">require</strong>('express');<br/><strong class="ls io">const</strong> path = <strong class="ls io">require</strong>('path');<br/><strong class="ls io">const</strong> app = express();<br/>app.<strong class="ls io">use</strong>(express.static(path.join(__dirname, 'build')));<br/><br/>app.get('/', <strong class="ls io">function</strong> (req, res) {<br/>  res.sendFile(path.join(__dirname, 'build', 'index.html'));<br/>});<br/><br/>app.listen(5000);</span></pre><p id="fd64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这实现了两件事:</p><ol class=""><li id="e572" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">模拟一个更真实的场景，您有一个使用Node.js后端和React前端的全栈应用程序。Node.js后端可能需要依赖于<code class="fe lp lq lr ls b">glibc</code>的依赖项，这就是为什么您使用“Distroless”映像而不是Alpine。在我们的例子中，Express后端所做的只是充当一个监听端口5000的静态服务器。</li><li id="209c" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">“Distroless”节点映像包含Node.js，几乎没有其他内容(没有<code class="fe lp lq lr ls b">npm</code>、<code class="fe lp lq lr ls b">yarn</code>等)。).有了<code class="fe lp lq lr ls b">server.js</code>，我们可以简单地执行<code class="fe lp lq lr ls b">node server.js</code>来启动应用程序。</li></ol><p id="8a52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后修改Dockerfile文件:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="9656" class="mu lu in ls b gy mv mw l mx my"># Stage 1 (named "builder"): Production React Build<br/><strong class="ls io">FROM</strong> node:14 AS builder<br/><br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> package.json package-lock.json ./<br/><strong class="ls io">RUN</strong> npm install<br/><br/><strong class="ls io">COPY</strong> . ./<br/><strong class="ls io">RUN</strong> npm run build<br/><br/># Stage 2 (named "final"): Produce final app<br/># by bundling Express backend with React frontend<br/><strong class="ls io">FROM</strong> node:14 AS final<br/><br/><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">RUN</strong> npm install express<br/><br/><strong class="ls io">COPY</strong> ./server.js /app<br/><strong class="ls io">COPY</strong> --from=builder /app/build /app/build<br/><br/># Stage 3: Copy the app from "final" stage<br/># to the minimal and secure distroless image<br/><strong class="ls io">FROM</strong> gcr.io/distroless/nodejs:14<br/><br/><strong class="ls io">COPY</strong> --from=final ./app ./app<br/><strong class="ls io">WORKDIR</strong> /app<br/><br/><strong class="ls io">CMD</strong> ["server.js"]</span></pre><p id="ef85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面指定了多阶段构建:</p><ol class=""><li id="e90c" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">阶段1使用一个节点映像来构建React应用程序静态文件。</li><li id="98f8" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">阶段2安装Express，将我们的本地副本<code class="fe lp lq lr ls b">server.js</code>复制到映像，并且只复制包含前一阶段的React应用程序的<code class="fe lp lq lr ls b">build</code>目录。</li><li id="7f4a" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">阶段3将来自阶段2的最终应用程序(Express dependency，<code class="fe lp lq lr ls b">server.js</code>和<code class="fe lp lq lr ls b">build</code>目录)复制到最小且安全的“distroles”<code class="fe lp lq lr ls b">node</code>映像。</li></ol><p id="e4a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式构建映像(标记为<code class="fe lp lq lr ls b">distroless-multistage</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="e12a" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build</strong> -t react-app:<strong class="ls io">distroless-multistage</strong> .</span></pre><p id="7bc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并通过运行容器，然后导航到<a class="ae ks" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>，检查应用程序是否工作。</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="8075" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">run</strong> --<strong class="ls io">rm</strong> -it -p 5000:5000 react-app:<strong class="ls io">distroless-multistage</strong></span></pre><p id="ca54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式检查图像尺寸:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="0725" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/e9ca5762ba790fccffeeb85bcdbfdd8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4LaDDD1SuMCkey_Fm06kA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="4ade" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还不错！得到的映像大小是<strong class="kv io"> 121MB </strong>，这不仅(稍微)比基于Alpine的映像(123MB)小，而且为您提供了更好的安全性和与用<code class="fe lp lq lr ls b">glibc</code>预编译的包的完全兼容性。缺点是由于缺少shell，调试和开发可能会更加痛苦，所以最好是在准备投入生产时才切换到“Distroless”。</p><h1 id="d383" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">5.只提供静态文件？请改用Nginx。</h1><p id="058e" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在我们之前的所有技巧中，最终的Docker映像有一个Node.js依赖项，用于服务或后端。如果您正在部署一个纯静态的React应用程序，您只需要一个强大的轻量级web服务器，比如<a class="ae ks" href="https://nginx.org/en/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>来服务静态文件。因此，在这种情况下，我们实际上可以摆脱庞大的Node.js依赖关系，节省更多的空间:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="7f2a" class="mu lu in ls b gy mv mw l mx my"># Stage 1 (named "builder"): Production React Build<br/><strong class="ls io">FROM</strong> node:14-alpine AS builder</span><span id="5735" class="mu lu in ls b gy ny mw l mx my"><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> package.json package-lock.json ./<br/><strong class="ls io">RUN</strong> npm install</span><span id="b161" class="mu lu in ls b gy ny mw l mx my"><strong class="ls io">COPY</strong> . ./<br/><strong class="ls io">RUN</strong> npm run build</span><span id="b637" class="mu lu in ls b gy ny mw l mx my"># Stage 2: Start fresh, use Nginx as webserver,<br/># and copy just the build artifacts from the previous stage.<br/><strong class="ls io">FROM</strong> nginx:alpine</span><span id="2895" class="mu lu in ls b gy ny mw l mx my"><strong class="ls io">WORKDIR</strong> /app<br/><strong class="ls io">COPY</strong> --from=builder /app/build /usr/share/nginx/html</span><span id="a094" class="mu lu in ls b gy ny mw l mx my"># Run nginx with global directives and daemon off<br/><strong class="ls io">CMD</strong> ["nginx", "-g", "daemon off;"]</span></pre><p id="4177" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的Dockerfile文件指定了一个多阶段构建:</p><ol class=""><li id="4a12" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">阶段1使用一个节点映像来构建React应用程序静态文件。</li><li id="7a72" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">第二阶段从一个基于<a class="ae ks" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank"> Alpine的Nginx映像</a>开始，复制第一阶段构建的静态文件，并启动一个Nginx web服务器来服务静态文件。</li></ol><p id="b4bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样，通过以下方式构建图像(标记为<code class="fe lp lq lr ls b">nginx-multistage</code>):</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="dbbd" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">build</strong> -t react-app:<strong class="ls io">nginx-multistage</strong> .</span></pre><p id="8519" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还可以通过运行容器，然后导航到<a class="ae ks" href="http://localhost:80" rel="noopener ugc nofollow" target="_blank"> http://localhost:80 </a>来检查应用程序是否正常工作:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="dc97" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">run</strong> --<strong class="ls io">rm</strong> -it -p 80:80 react-app:<strong class="ls io">nginx-multistage</strong></span></pre><p id="4c1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过以下方式检查图像尺寸:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="154e" class="mu lu in ls b gy mv mw l mx my">docker <strong class="ls io">images</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/4f826009757d8a0ff54b6ebbbc462abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E10Sbqo1ql8frFrpIQvstQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of docker images output. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="9b30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太棒了。得到的图像大小只有<strong class="kv io"> 22.8MB </strong>！</p><h1 id="1837" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><p id="f5c7" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">概括地说，执行每个提示后的图像尺寸为:</p><ol class=""><li id="3d57" class="nd ne in kv b kw kx kz la lc nf lg ng lk nh lo ni nj nk nl bi translated">香草底座图像:<strong class="kv io"> 1.36GB </strong></li><li id="df3a" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">增加<code class="fe lp lq lr ls b">.dockerignore</code> : <strong class="kv io"> 1.19GB </strong></li><li id="c3bd" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">使用阿尔卑斯图片:<strong class="kv io"> 362MB </strong></li><li id="ff28" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">使用Alpine映像的多阶段构建:<strong class="kv io"> 123MB </strong></li><li id="da00" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">使用无分布映像的多阶段构建:<strong class="kv io"> 121MB </strong></li><li id="9544" class="nd ne in kv b kw nm kz nn lc no lg np lk nq lo ni nj nk nl bi translated">使用Nginx的多阶段构建:<strong class="kv io"> 22.8MB </strong></li></ol><p id="fcae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总之，总是包括一个<code class="fe lp lq lr ls b">.dockerignore</code>文件。普通节点映像非常适合开发和测试，但是对于部署来说太大了。</p><p id="d47e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您正在部署一个纯静态的React应用程序，那么采用最终利用Nginx Alpine映像的多阶段构建是一个非常好的选择，并且提供了最小的大小。</p><p id="0977" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您的最终映像需要Node.js，您想要一个用于调试的shell，并且您不关心<code class="fe lp lq lr ls b">muslc</code>的不兼容性，那么基于Alpine的<code class="fe lp lq lr ls b">node</code>映像可能适合您。</p><p id="0982" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您在生产环境中运行，关注安全性，并且需要<code class="fe lp lq lr ls b">glibc</code>兼容性，那么也许使用“无发行版”映像更合适。</p><p id="3fb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望这对你有启发和帮助。编码快乐！</p></div></div>    
</body>
</html>