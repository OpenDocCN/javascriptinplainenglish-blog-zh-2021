<html>
<head>
<title>Vue.js State Management with Vuex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vuex进行Vue.js状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-js-state-management-with-vuex-3a87e1ae83c2?source=collection_archive---------7-----------------------#2021-03-12">https://javascript.plainenglish.io/vue-js-state-management-with-vuex-3a87e1ae83c2?source=collection_archive---------7-----------------------#2021-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9eb5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在这篇文章中，我们将学习使用Vuex在Vue JS中进行状态管理的概念，然后我将带你看一个使用它的真实例子。</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/2c7e332e2e33e90195e70052743aebc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9H6N8KnK6bzubOrLswANjg.png"/></div></div></figure><h1 id="d5ac" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">介绍</h1><p id="9e98" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">在不断变化的开发技术环境中，开发人员经常发现自己被大量需要掌握的技术弄得不知所措。在学习了基本的Vue JS并使用它构建了一些web应用程序之后，开发人员觉得有必要学习状态管理只是时间问题。在了解了组件、状态、道具等之后，一开始可能会有点吓人。，现在你需要学习另一个神秘的概念…不要担心在这篇文章中我会试着给你一个温和的介绍这个新概念。</p><h1 id="b369" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">Vuex是什么？</h1><p id="d0a1" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated"><em class="md"> Vuex是一个状态管理模式和库，它是应用程序中所有组件的集中存储。</em>在简单的Vue JS应用程序中，我们只有很少的组件可以非常简单地管理状态，我们可能只有一个父组件，从这个父组件我们将道具传递给它的子组件。我们还可以通过发出事件将数据从子组件向上传递到父组件。</p><p id="4538" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">然而，随着您的web应用程序的增长和组件数量的增加，您会发现许多组件将需要共享相同的数据，您的组件将变得更加嵌套，以至于您需要传递许多层深度的props。想象一下，如果你需要将道具传递给一个8层深的组件…你需要将道具从一个组件传递到另一个组件。这将导致一个不可维护的混乱，或者更简单地说，一场噩梦！</p><p id="0b90" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">幸运的是，Vuex允许我们创建一个集中的存储，其中包含我们的应用程序需要的全局状态，并将其暴露给我们的所有组件，因此我们可以以简单和可预测的方式访问和修改它。事实上，它和Vue JS一样简单易用，使用起来也很方便。</p><h1 id="0a9b" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">Vuex概念</h1><p id="5b17" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated"><strong class="lj io">存储<br/></strong><em class="md">存储</em>是一个保存应用程序状态的容器。Vuex存储是反应性的，这意味着当组件从它那里检索状态时，存储状态的变化将在使用它的组件中得到反映和更新。</p><p id="62c5" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> State <br/> </strong> State是包含应用程序所有全局状态的对象。与单个组件的本地状态不同，这是项目中任何组件都将使用的状态。</p><p id="bff0" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> getters <br/> </strong>当我们需要从状态中计算特定数据时，我们会使用Getters，在todo应用程序中，我们会有<code class="fe mj mk ml mm b">completedTodos</code> <em class="md"> </em>和<em class="md"> </em> <code class="fe mj mk ml mm b">uncompletedTodos</code> <em class="md"> </em> getters，因此使用Getters我们可以从状态中过滤并获取我们需要的数据，我们可以对它们执行计算等。为了简单起见，你可以把<em class="md"> getters </em>看作是Vue JS中的<em class="md">计算的</em>属性。</p><p id="97fb" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">突变<br/> </strong>在Vuex中，不能直接<em class="md">突变</em>(改变状态)状态，只能通过提交<em class="md">突变</em>来实现。突变是同步的，因此它们不能用于处理异步任务。</p><p id="dfd0" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">动作<br/> </strong>动作不同于突变，因为它们是异步的，因此它们适用于获取数据和处理其他异步操作。然而，动作不能直接改变状态，它们应该只提交改变。调用一个动作的动作(见我在那里做的)叫做<em class="md">调度</em>一个动作。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi mn"><img src="../Images/a29b38b6ca5b5f2612a0ffc79c2cd98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIoNyRO6s_52W68Y-0usJw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">The Vuex flow taken from the official docs</figcaption></figure><p id="b265" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在上图中，您可以看到Vuex流的可视化表示。这张图片完美地概括了我们迄今为止所学到的东西。让我们再消化一次。<br/>状态在Vue组件中呈现。我们可以从我们的组件调度动作，反过来动作可以提交突变，然后突变状态。如此循环往复。</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="a359" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> <em class="md">我们如何访问组件中的商店？</em> </strong></p><p id="d5df" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">一旦我们定义了我们的Vuex存储并将其包含在Vue实例中(您将在下一节中看到如何实现)，我们就可以在任何组件中将它作为一个属性轻松地使用:<br/> <strong class="lj io"> this。$store <br/> </strong> -访问状态:<code class="fe mj mk ml mm b">this.$store.state.counter</code> <strong class="lj io"> <br/> </strong> -调度一个动作:<code class="fe mj mk ml mm b">this.$store.dispatch(‘increment’)</code> <br/> -提交一个突变:<em class="md"> </em> <code class="fe mj mk ml mm b">this.$store.commit(‘increment’)</code> <br/> -访问一个getter示例:<code class="fe mj mk ml mm b">this.$store.getters.completedTodos</code></p><p id="ccdb" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">不要让那个奇怪的美元符号吓到你，<code class="fe mj mk ml mm b">$store</code>只是一个简单的属性，可以在我们的应用程序中的任何地方访问。</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h2 id="3277" class="mz kq in bd kr na nb dn kv nc nd dp kz lq ne nf lb lu ng nh ld ly ni nj lf nk bi translated"><strong class="ak">如何安装Vuex？</strong></h2><p id="471e" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">要安装Vuex，你首先需要有一个Vue JS app，如果你没有先在你的终端里创建一个Vue JS app:<br/><code class="fe mj mk ml mm b">vue create exampleapp</code></p><p id="eed7" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">完成后，您可以将光盘放入您的新应用文件夹:<br/> <code class="fe mj mk ml mm b">cd exampleapp</code></p><p id="410b" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">然后就可以安装Vuex:<br/>T9】</p><h1 id="3435" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">购物车web应用程序——一个真实的例子</h1><h2 id="8d0c" class="mz kq in bd kr na nb dn kv nc nd dp kz lq ne nf lb lu ng nh ld ly ni nj lf nk bi translated"><strong class="ak">先决条件</strong></h2><p id="fa13" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">为了遵循这一节，我希望你:<br/> -对Vue.js <br/>有很好的了解-了解ES6，因为我将在这个示例应用程序中大量使用ES6功能</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="d278" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">现在我们知道了基础知识，我们可以开始使用我们的示例应用程序了。在这一节中，我将采取不同的方法，引导您完成这个相当简单的项目的代码，而不是一步一步地指导您，我将尽可能清晰地解释它。乍一看，这似乎有悖常理，但主要思想是熟悉Vuex的工作方式和外观，所以到最后，您应该觉得已经准备好使用Vuex实现任何项目了。完整的代码将被上传到Github，你会在文章的最后找到链接，如果你不能理解的话可以查看。</p><p id="a73f" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">购物车将具有通常的功能，您有一个产品列表，您可以将它们添加到购物车。购物车商品出现在可以切换的侧边栏中。您可以查看购物车中有多少物品以及总价。如果你愿意，你可以预先查看netlify上的示例，这样你就可以看到它是如何工作的，<a class="ae nl" href="https://shopping-cart-vuex.netlify.app" rel="noopener ugc nofollow" target="_blank"> <em class="md">点击这里查看</em> </a> <em class="md">。</em></p><p id="4d4c" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">让我们开始吧，示例应用程序文件夹结构如下所示:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5a8644ba09d1a51833f7302f90a894dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*rLzm73aWA0AGmFY5w-3iiA.png"/></div></figure><p id="3a44" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> store.js </strong></p><p id="9dbc" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">首先，我们将检查<em class="md"> store.js </em>文件中的代码，这是Vuex魔法发生的地方，在我们有了store之后，从任何组件引用/使用它将变得很简单。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d677" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在上面的代码中，你可以看到一个基本的Vuex商店。这段代码相当简单明了。我们已经导入了vue和vuex，我们已经告诉vue使用vuex，将商店初始化为一个对象。我们还可以看到状态、getters、突变和动作作为属性存在于存储中，它们现在是空的。最后，我们传递store对象来导出Vuex存储。</p><p id="f192" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">现在，显然我们需要为存储提供状态、getters等。我们的应用程序将会消耗。我们从州开始:</p><p id="b670" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">状态</strong></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2e81" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">我们的状态非常简单，在<code class="fe mj mk ml mm b">products</code>中，我们将产品数据存储为一个数组。产品将被存储为一个对象数组，该数组来自一个包含一些虚拟产品数据的<em class="md"> products.json </em>文件。您可以在这里查看带有产品数据<a class="ae nl" href="https://github.com/floriand99/shopping-cart/blob/main/src/products.json" rel="noopener ugc nofollow" target="_blank">的文件。<br/> <code class="fe mj mk ml mm b">cartItems</code> <em class="md"> </em>将只包含购物车中的产品，而<code class="fe mj mk ml mm b">showCart</code>是一个布尔值，因为它将用于显示或隐藏购物车中的商品，这些商品将显示在侧栏中，单击即可切换。</a></p><p id="4fc3" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">突变</strong></p><p id="edaa" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">自然，这是我们应用程序的大部分逻辑发生的地方，因为突变负责改变状态。</p><p id="72f2" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">突变是接收一个<code class="fe mj mk ml mm b">state</code>参数和一个可选的<code class="fe mj mk ml mm b">payload</code> <em class="md">的函数。</em>所以在大多数情况下，你会看到第二个参数叫做<code class="fe mj mk ml mm b">payload</code> <em class="md">，</em>相反，我喜欢将有效载荷作为一个对象传递给变异函数，这样我就可以从对象中析构它，从而通过它的内容来引用它，这种方式对我来说似乎更有语义。请记住，有效载荷将从我们的组件中传递，稍后当我们提交它们的变体时，您会看到这一点…</p><p id="b2d6" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">这是一些突变:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8cf5" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在<code class="fe mj mk ml mm b">setProducts</code> <em class="md"> </em>变异中，我们将接收到的<code class="fe mj mk ml mm b">products</code>有效载荷分配给我们状态中的<code class="fe mj mk ml mm b">products</code>数组。</p><p id="a393" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><code class="fe mj mk ml mm b">toggleCart</code>没有接收到有效载荷，它简单地将<code class="fe mj mk ml mm b">showCart</code>设置为其自身的倒数<em class="md">。</em></p><p id="c01b" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><code class="fe mj mk ml mm b">addToCart</code>接受需要添加到购物车的产品，然后我们简单地使用产品id在<code class="fe mj mk ml mm b">cartItems</code>中找到元素，并检查它是否存在于<code class="fe mj mk ml mm b">cartItems</code> <em class="md"> </em>数组中。如果它不存在，我们将产品添加到<code class="fe mj mk ml mm b">cartItems</code>并添加一个<code class="fe mj mk ml mm b">numOfItems</code>属性，默认为1。如果产品已经存在于<code class="fe mj mk ml mm b">cartItems</code> <em class="md"> </em>中，我们只需增加<code class="fe mj mk ml mm b">numOfItems</code> <em class="md">。</em>我们需要这样做，如果用户添加了相同产品的1个以上的项目，它不会显示多次，而是我们会显示它的数量。</p><p id="74eb" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><code class="fe mj mk ml mm b">removeFromCart</code>接受<code class="fe mj mk ml mm b">productId</code>作为有效载荷。我们使用id在<code class="fe mj mk ml mm b">cartItems</code> <em class="md"> </em>中找到产品，如果它在购物车中有多个商品，我们减少产品<em class="md">的<code class="fe mj mk ml mm b">numOfItems </code>，如果它只有一个商品，我们从<code class="fe mj mk ml mm b">cartItems</code>中完全删除该产品。</em></p><p id="a4a3" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">吸气剂</strong></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3ab8" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">有两个getters，顾名思义，将用于返回或获取购物车中商品的数量以及所有商品的总价。getters接受状态作为参数，我们使用析构来获得我们需要的东西<code class="fe mj mk ml mm b">cartItems</code>。我已经使用reduce数组方法计算了购物车中所有商品的<code class="fe mj mk ml mm b">count</code>和<code class="fe mj mk ml mm b">totalPrice</code>。如果您不能理解reduce方法，我还提供了注释代码，它使用一个简单的for循环来实现相同的功能。</p><p id="2164" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">我们不会使用动作，因为这个应用程序不会有任何异步代码，突变很简单，所以我们应该可以直接从我们的组件提交突变。</p><h1 id="7591" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">消耗国家</h1><p id="712c" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">现在我们有了商店，我们如何将它插入到我们的Vue应用程序中呢？它应该在main.js文件中完成:</p><p id="ca22" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> main.js </strong></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="807e" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">导入商店并将其传递给Vue实例，就是这样。万岁！现在，商店对我们应用程序中的所有组件都可用。现在我们可以转到我们的组件，看看这个商店的运行情况…</p><p id="ec6d" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> App.vue </strong></p><p id="cef7" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">这是我们的应用程序的根组件，作为其他组件的包装器。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c311" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">在脚本标签的顶部，我们已经从<em class="md"> products.json </em>导入了产品数据，在<code class="fe mj mk ml mm b">created</code>方法中，我们提交了<code class="fe mj mk ml mm b">setProducts</code> <em class="md"> </em>变异，并将从<em class="md"> products.json </em>获得的产品数据作为第二个参数传递给它。</p><p id="9c06" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><em class="md">注意:在下面的组件中，我已经包含了bootstrap(这样示例应用看起来就不会难看了)，所以如果看起来有很多代码，那么大部分都是bootstrap类。我们的重点将是Vuex零件，我将指导您完成！</em></p><p id="deec" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> Main.vue </strong></p><p id="3f48" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">该组件显示产品列表，每个产品都有一个<em class="md">添加到购物车</em>按钮。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="409c" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><em class="md">第4行</em> —我们迭代商店状态中的产品<br/> <em class="md">第16行</em> —在v-for循环中，我们有一个添加到购物车按钮，单击该按钮会提交变异，我们会将当前产品传递给它。其他一切都是标准的Vue JS程序，我们显示产品名称、等级等。</p><p id="ac1e" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> CartButton.vue </strong></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="50e7" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">这个组件只是一个按钮，用来切换购物车侧边栏。它还在第6行使用了<code class="fe mj mk ml mm b">count</code> getter，显示购物车中有多少商品。</p><p id="ab9f" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io"> Cart.js </strong></p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ef31" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><em class="md">第4行</em> —我们检查购物车侧边栏是否应该显示<br/> <em class="md">第6行</em> —这是一个关闭按钮，如果单击，购物车侧边栏将被切换(隐藏)<br/> <em class="md">第10行</em> —我们检查是否有任何购物车项目<br/> <em class="md">第11行</em> —我们循环遍历购物车项目<br/> <em class="md">第17行</em> —是一个移除按钮，当它被单击时，我们提交<code class="fe mj mk ml mm b">removeFromCart</code>变异并传递当前的</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="79d9" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">现在你知道了！我们已经了解了Vuex的状态管理概念，并回顾了一个真实世界的例子，现在您应该可以轻松地创建Vuex商店，并从您的Vue应用程序中的组件访问它。我希望你喜欢这篇文章！如果你对这篇文章有任何问题，请提出来，我会尽快回答。</p><p id="960d" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated">到github的链接:<a class="ae nl" href="https://github.com/floriand99/shopping-cart" rel="noopener ugc nofollow" target="_blank">https://github.com/floriand99/shopping-cart</a></p><p id="0e5f" class="pw-post-body-paragraph lh li in lj b lk me jo lm ln mf jr lp lq mg ls lt lu mh lw lx ly mi ma mb mc ig bi translated"><strong class="lj io">作业:</strong> <em class="md">克隆或分叉GitHub上的项目。然后在购物车物品侧边栏上添加一个“清除所有物品”按钮，当单击该按钮时，所有物品都应该从侧边栏中清除，添加必要的变异来这样做。</em></p></div></div>    
</body>
</html>