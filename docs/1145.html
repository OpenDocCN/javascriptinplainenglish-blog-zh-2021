<html>
<head>
<title>Create an Express-like Framework in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Next.js中创建一个类似Express的框架</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/express-like-framework-in-next-js-27a884a0264d?source=collection_archive---------7-----------------------#2021-03-10">https://javascript.plainenglish.io/express-like-framework-in-next-js-27a884a0264d?source=collection_archive---------7-----------------------#2021-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/345ad969a0db60f79e2cfb9e843e7add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acfsKMRrZSpogDM_FKEAUQ.jpeg"/></div></div></figure><div class=""/><p id="118a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将演示如何在Next.js中构建类似Express的API，而不需要部署Express服务器，只需做一些调整。</p><p id="1d86" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在寻找Express框架的好处，但对您的应用程序保持无服务器状态感到满意，这可能是您的一个选择。</p><h1 id="8b21" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用Next.js的注意事项</h1><p id="79bb" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我从Next.js开始了我的旅程，因为它使React的服务器端呈现变得简单明了。它允许我在页面加载之前轻松地选择要呈现的内容，并且有一个pages文件夹用于直观的路由。我还发现了<a class="ae lw" href="https://blog.newrelic.com/engineering/what-is-serverless-architecture/" rel="noopener ugc nofollow" target="_blank">无服务器的其他好处</a>,比如易于部署，更注重产品开发而不是管理服务器。</p><blockquote class="lx ly lz"><p id="9365" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated"><em class="iy">以后想看这个故事吗？</em> <a class="ae lw" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank"> <em class="iy">保存在日记本上。</em> </a></p></blockquote><p id="f7d3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着你这边的工作更少，但控制也更少。阅读Vercel平台的限制<a class="ae lw" href="https://vercel.com/docs/platform/limits#" rel="noopener ugc nofollow" target="_blank">以了解它是否适合您的应用程序是很有用的，注意在没有企业计划的情况下，有1000个并发请求的限制</a><a class="ae lw" href="https://vercel.com/docs/platform/limits#" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7f5d" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Next.js的API vs Expresss</h1><p id="9761" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我主要关心的是如何设计我的API。对于<a class="ae lw" href="https://vercel.com/docs/serverless-functions/introduction" rel="noopener ugc nofollow" target="_blank">无服务器函数</a>，理想的模式是让每个路由在pages/api目录中的单个文件中提供单个函数(例如<strong class="jx iz"> GET '/api/user/:id' </strong>)。</p><p id="acb0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我正在从一个快速环境中迁移，并享受将功能留给控制器的逻辑流程。我的应用程序有一个定制的身份验证流，所以像<strong class="jx iz"> /api/login/ </strong>这样的端点太大了，很难限制在一个函数中。更不用说我想重用其中的一些功能，所以将这个逻辑存储在隔离的端点对我来说没有意义。</p><p id="14e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题变成了:</p><h1 id="abe1" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我可以简单地将Express与Next.js一起使用吗？</h1><p id="a878" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">是的，但不是没有一些权衡。</p><p id="e6ac" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一种选择是设置一个定制服务器，但是这首先就否定了使用Next.js的一些理由，因为您不能在Vercel上部署，并且您不再是无服务器的。然而，对于许多应用程序来说，这是正确的选择，尤其是那些受益于管理自己的服务器的大型应用程序。</p><p id="0275" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个选择是<a class="ae lw" href="https://vercel.com/guides/using-express-with-vercel" rel="noopener ugc nofollow" target="_blank">在无服务器功能</a>内使用Express。Vercel建议这只是一种迁移你的应用程序的方法，本质上是将你自己从一个专用的服务器中分离出来。个人觉得在无服务器环境下运行Express有点傻。这也意味着您在对每个请求执行完整的服务器实现，这违反了无服务器功能服务于一个目的的模式。但我并不是说这对你没用。</p><p id="655f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我决定留在Next.js的缓冲区内，并尝试在不使用Express的情况下从Express的框架中获得我想要的好处。</p><h1 id="6b3e" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我遇到的问题</h1><p id="a65f" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我在我的应用程序中设置了一个控制器目录，在那里我导出了无数的函数，并从我的无服务器函数中像调用中间件一样调用它们。</p><p id="7ecf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，在Next.js中这样做很麻烦，因为它缺少一个Next()函数，Express使用这个函数来<strong class="jx iz">转义</strong>中间件链和<strong class="jx iz">绕过</strong>其余的功能。</p><p id="2ae7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从本质上说，不能访问next()意味着我不能轻易摆脱中间件。</p><h1 id="a14f" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">不要做什么:</h1><p id="67a8" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在本例中，我们有一个端点，它在发送用户数据之前等待令牌的验证。如果中间件功能告诉我们没有通过验证，我们需要处理这个响应，避免执行下一个中间件功能。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="366b" class="mn ku iy mj b gy mo mp l mq mr"><strong class="mj iz">/api/authenticateUser</strong></span><span id="dbff" class="mn ku iy mj b gy ms mp l mq mr">import authController from 'controllers/authController';</span><span id="b3c4" class="mn ku iy mj b gy ms mp l mq mr">export default async (req, res) =&gt; {</span><span id="244e" class="mn ku iy mj b gy ms mp l mq mr">try {</span><span id="eece" class="mn ku iy mj b gy ms mp l mq mr"><strong class="mj iz">  // Controller sends back a boolean "verified" and "userId"</strong><br/>  const result = await authController.verifyToken(req, res);<br/>  if (result.verified === false) {<br/>    return res.json({ error: 'Not authenticated'})<br/>  };</span><span id="5eee" class="mn ku iy mj b gy ms mp l mq mr">  const payload = { userId: result.userId };</span><span id="a45e" class="mn ku iy mj b gy ms mp l mq mr"><strong class="mj iz">  // Fetch user data by userId. Returns username<br/></strong>  const data = await authController.header(req, res, payload);<br/>  const { username } = data;</span><span id="5a2f" class="mn ku iy mj b gy ms mp l mq mr">  return res.json({ username });</span><span id="dcd7" class="mn ku iy mj b gy ms mp l mq mr">} catch(e) {<br/>  return res.status(500).send(e.message);<br/>}};</span></pre><p id="277a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，这看起来一点也不像我们在Express中习惯的干净的中间件链。我必须将类似{ verified: true }的信息传递回“waiting”函数，以便处理异常。</p><p id="1e0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在express中，我们只需在控制器内部返回类似next(err)或RES . JSON({ error:' custom error ' })<strong class="jx iz">，</strong>的内容，如果我们没有命中next()语句，就不会继续。这里，如果我们从控制器调用res.json()，它将从函数中返回，但不会一起结束响应。</p><p id="ebf9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还要注意，没有res.locals对象在它们之间传递数据是多么笨拙。我们必须将数据打包到有效载荷中，并将每个控制器调用的结果解包。</p><h1 id="9669" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">解决方案是:</h1><p id="679e" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">(解释如下)</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6200" class="mn ku iy mj b gy mo mp l mq mr">import wrapper from ‘utils/wrapper’;<br/>import authController from ‘controllers/authController’;</span><span id="d399" class="mn ku iy mj b gy ms mp l mq mr">const handler = async (req, res, middlewareChain) =&gt; {</span><span id="c244" class="mn ku iy mj b gy ms mp l mq mr">  await middlewareChain<br/>  (<br/>    authController.verifyToken,<br/>    authController.getUserId,  <br/>  )<br/>  .then(result =&gt; { if (!result) return; })<br/>  .catch(e =&gt; { res.status(500).send(e.message); })</span><span id="215e" class="mn ku iy mj b gy ms mp l mq mr">  return res.json({<br/>    username: res.locals.username<br/>  });</span><span id="6b29" class="mn ku iy mj b gy ms mp l mq mr">};</span><span id="1228" class="mn ku iy mj b gy ms mp l mq mr">export default wrapper(handler);</span></pre><p id="7a6a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果不向您展示我在顶部导入的包装函数，这并不能解释太多。请注意，我们不是导出函数，而是传递函数的包装器。</p><h2 id="fb8a" class="mn ku iy bd kv mt mu dn kz mv mw dp ld kg mx my lh kk mz na ll ko nb nc lp nd bi translated">包装材料:</h2><p id="4bf5" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">包装函数允许我们使用修改过的res和req函数来执行函数，以及将任何其他函数添加到我们的参数中(比如middlewareChain)。</p><p id="b760" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">包装文件如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ae12" class="mn ku iy mj b gy mo mp l mq mr"><strong class="mj iz">utils/wrapper</strong></span><span id="9a99" class="mn ku iy mj b gy ms mp l mq mr">const wrapper = handler =&gt; {</span><span id="0363" class="mn ku iy mj b gy ms mp l mq mr">return (req, res, middlewareChain) =&gt; {<br/>   <br/>    <strong class="mj iz">/* res.locals object */<br/>    </strong>res.locals = {};</span><span id="02bc" class="mn ku iy mj b gy ms mp l mq mr"><strong class="mj iz">    /* middlewareChain function */<br/>    </strong>middlewareChain = async (...funcs) =&gt; {<br/>      let finished = true;<br/>      for (const func of funcs) {<br/>        await func(req, res)<br/>        if (res.finished) {<br/>          finished = false;<br/>          break;<br/>        };<br/>      };<br/>    return next;<br/>    };</span><span id="34b9" class="mn ku iy mj b gy ms mp l mq mr">  return handler(req, res, middlewareChain);<br/>  };<br/>};</span><span id="5242" class="mn ku iy mj b gy ms mp l mq mr">module.exports = wrapper;</span></pre><p id="deeb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，您将看到我们可以像使用Express一样声明和使用<strong class="jx iz"> res.locals </strong>。这使得我们可以轻松地在函数之间传递数据。</p><p id="614d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至于<strong class="jx iz"> middlewareChain </strong>函数，它将所有控制器函数作为参数。对于每个函数，我们等待响应并检查我们是否调用了res.json()或res.send()。我们通过利用res对象固有的<strong class="jx iz"> res.finished </strong>属性来检查这一点。当您调用res.json()或res.send()时，它的值会从true变为false。(这通常是为了确保我们不会设置两次响应)。</p><p id="ebc4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我想早点退出我的控制器函数，可以调用<strong class="jx iz"> return res.json({data}) </strong>。我的middlewareChain将捕捉到我想返回一个响应并跳出循环。除了调用<strong class="jx iz"> break </strong>之外，我们还将一个<strong class="jx iz"> finished </strong>变量设置为false，使得middlewareChain的返回值为布尔值。我们在<strong class="jx iz">中处理这个响应。然后()</strong>，说如果它求值为false，返回。</p><p id="92a6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，打破控制器功能的另一种方式是抛出一个错误，但是这并不适合每种情况。</p><h2 id="bec0" class="mn ku iy bd kv mt mu dn kz mv mw dp ld kg mx my lh kk mz na ll ko nb nc lp nd bi translated">使用包装器还可以做其他事情:</h2><p id="375f" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在我的应用程序中，我还将错误处理和cookie处理函数(<strong class="jx iz"> res.cookie </strong>)放在了响应对象上，这是我强烈推荐的。我在这里写了一篇关于<a class="ae lw" href="https://justinjaeger.medium.com/next-js-using-cookies-in-getserversideprops-89c03a216b0b" rel="noopener">以类似快递的方式处理cookies的文章</a>。</p><p id="16f3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要点是，您可以将任何类型函数或对象附加到req和res上，这使您的生活更轻松，或者去掉重复的代码。</p><h1 id="6918" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后</h1><p id="c872" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这种策略可以帮助您保持类似Express的工作流，而不需要创建定制的服务器<strong class="jx iz">和</strong>,也不需要牺牲使用可以停止“中间件”链的控制器的能力。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="49e6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">📝把这个故事保存在<a class="ae lw" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank">杂志</a>上。</p></div></div>    
</body>
</html>