<html>
<head>
<title>JavaScript Algorithm Practice: Count the Possible Ascending Subarrays of Size Three</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法练习:计算大小为三的可能的升序子数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/js-algorithm-practice-count-the-possible-ascending-subarrays-of-three-721fe036c86b?source=collection_archive---------24-----------------------#2021-06-08">https://javascript.plainenglish.io/js-algorithm-practice-count-the-possible-ascending-subarrays-of-three-721fe036c86b?source=collection_archive---------24-----------------------#2021-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3d86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如何找到大小为三的可能升序子数组的数量</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/6e005799e6e07646b8a0c8fc26766776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*6hKogGLXrvN54f21.gif"/></div></figure><p id="25e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最近参加了一个金融服务行业软件工程机会的在线评估，被一个反演算法难住了。我最终能够让大部分测试用例通过，但是那些没有通过的最终超时了。</p><p id="3aba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后退一步，重新考虑这个问题，评估我的代码，思考另一个可能的解决方案，我能够节省大量的时间，并让所有的测试用例通过。</p><p id="7af4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将通过一个<em class="ki">类似的</em>问题，一个简单的解决方案，然后是一个最优的解决方案。</p><h1 id="b2fa" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">这个问题</h1><p id="bffc" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">给定一个整数数组，<strong class="jm io"> <em class="ki"> arr </em> </strong>，三个元素<strong class="jm io"><em class="ki">arr</em></strong><strong class="jm io"><em class="ki">I</em></strong>，<strong class="jm io"><em class="ki">arr</em></strong><strong class="jm io"><em class="ki">j</em></strong>， 和<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">k</em></strong>]组成大小为三的升序子阵列，其中<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>]&lt;<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">j</em></strong>&lt;<strong class="jm io"><em class="ki">arr</em></strong></p><p id="94e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据数组的当前顺序，找出大小为三的可能升序子数组的数量。</p><h2 id="e7a8" class="lu ks in bd kt lv lw dn kx lx ly dp lb jv lz ma lf jz mb mc lj kd md me ln mf bi translated">示例:</h2><p id="1395" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">输入:[1，2，5，8] <br/>输出:4 <br/>大小为三的四个可能的升序子数组分别是[1，2，5]，[1，2，8]，[1，5，8]和[2，5，8]。</p><p id="7a1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入:[2，6，7，-1，8，-4，10] <br/>输出:11 <br/>大小为三的十一个可能的升序子数组是[2，6，7]，[2，6，8]，[2，7，8]，[2，7，10]，[2，7，10]，[2，8，10]，[6，7，8，10]，[6，7，10]，[6，8，10]，[7，8，10]</p><h1 id="8e10" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">简单溶体</h1><p id="c58e" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">想到的第一个想法就是对<strong class="jm io"> <em class="ki"> i </em> </strong>、<strong class="jm io"> <em class="ki"> j </em> </strong>、<strong class="jm io"> <em class="ki"> k </em> </strong>的所有可能值进行循环。并检查条件，其中<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>]&lt;<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">j</em></strong>&lt;<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">k</em></strong>和where<strong class="jm io"><em class="ki">I</em></strong>&lt;</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5133" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这个解决方案最终会得到正确的答案，但是如果我们分析时间复杂度，我们会意识到由于三个嵌套的<code class="fe mi mj mk ml b">for</code>循环，这个函数在立方时间或<strong class="jm io"> O(n ) </strong>中计算。</p><p id="677c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理较小规模的阵列时，该解决方案在获得答案方面应该没有任何问题。然而，当给定的数组包含几十个甚至几百个元素时，这种解决方案将花费很长时间，并且很可能会超时。</p><h1 id="f2f3" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最优解</h1><p id="d8f1" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">如果我们从以前的解决方案中提取框架，并考虑如何降低时间复杂度，首先想到的是消除一个嵌套的<code class="fe mi mj mk ml b">for</code>循环。</p><p id="f895" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们把每一个元素<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>]看作一个上升子阵列的中间元素，我们可以找到所有小于<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>的数，它们的索引也小于<strong class="jm io"> <em class="ki"> i </em> </strong>。然后我们可以用同样的方法找到所有大于<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>]并且其索引大于<strong class="jm io"> <em class="ki"> i </em> </strong>的数字。</p><p id="61d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们对<strong class="jm io"> <em class="ki"> i </em> </strong>左侧的所有较小元素和<strong class="jm io"> <em class="ki"> i </em> </strong>右侧的所有较大元素进行了计数，我们就可以将它们相乘，以找到子数组的所有可能组合，其中中间的元素是<strong class="jm io"><em class="ki">arr</em></strong>[<strong class="jm io"><em class="ki">I</em></strong>]，并将其添加到计数中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="22c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然在初始循环中有两个<code class="fe mi mj mk ml b">for</code>循环，但是它们会分开计算。那些特定的代码行在线性时间或<strong class="jm io"> O(n) </strong>中计算。当在初始循环中计算它们的时间复杂度时，这两个循环将各自在二次时间或<strong class="jm io"> O(n ) </strong>中计算。</p><p id="e423" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过让代码在二次时间进行计算，我们根据<strong class="jm io"> <em class="ki"> arr </em> </strong>输入的长度显著减少了计算时间。</p><h1 id="593e" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">外卖食品</h1><p id="b519" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">从来没有一个正确的方法可以找到一个算法的解。然而，总有更快的方法。</p><p id="11bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下次你面对一个算法时，试着用你所知道的去解决它。无论是使用内置的方法还是蛮力，都要努力得到一个正确的解决方案。一旦你有了解决方案，后退一步，问问自己这是不是得到答案的最佳方式。如果是，太神奇了。然而，如果你觉得可能有更好的方法，那么很可能有。</p><p id="fa2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像你一直应该做的那样，你的代码应该工作得更聪明而不是更困难。</p><p id="9259" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容请看</em><a class="ae mm" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">plain English . io</em></a></p></div></div>    
</body>
</html>