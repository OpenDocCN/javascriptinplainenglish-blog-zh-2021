<html>
<head>
<title>Express Middlewares Are Easier Than You Think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快递中间件比你想象的要简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/express-middlewares-are-easier-than-you-think-b0ddcbb358cc?source=collection_archive---------9-----------------------#2021-02-19">https://javascript.plainenglish.io/express-middlewares-are-easier-than-you-think-b0ddcbb358cc?source=collection_archive---------9-----------------------#2021-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/37db20c08b393de14860c6b4bf3a7552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dZSD3JImKTawU9nJo96zg.jpeg"/></div></div></figure><p id="b686" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我从上一个<a class="ae kt" href="https://js.plainenglish.io/javascript-promises-easier-than-you-can-imagine-cfb18b1f35bc" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">博客</em> </strong> </a>中得到正面反馈后，我决定开始另一个博客，在那里我将一个复杂的概念分解，并将其同化为人类大脑熟悉的东西。毕竟，这就是我的工作，让不同背景的<a class="kv kw ep" href="https://medium.com/u/9a3929b3623?source=post_page-----b0ddcbb358cc--------------------------------" rel="noopener" target="_blank"><strong class="jx io"><em class="ku">RBK</em></strong></a>学生成为全栈开发者。</p><p id="d29e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我们来看看中间件。当处理从客户端到服务器端的请求时，它们被广泛使用。它们只是一些函数，将请求作为一个参数，对其进行一些处理，然后将其传递给下一个中间件。相信我，这听起来很简单。然而，为了让这个概念在你的头脑中持续存在，我要给你一个具体的例子。</p><h1 id="cb09" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">汽车制造中的中间件</h1><p id="01b9" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Elon_Musk" rel="noopener ugc nofollow" target="_blank">特斯拉和SpaceX的创始人埃隆马斯克</a>，地球上最富有的个人智人，将他的汽车制造公司特斯拉的生产线描述为<a class="ae kt" href="https://observer.com/2019/02/elon-musk-tesla-production-hell-podcast-interview/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku">生产地狱</em> </strong> </a>。这是任何汽车制造商面临的最大挑战。这让我很好的想起了服务器端开发:一个非常<strong class="jx io"> <em class="ku">关键的</em></strong><strong class="jx io"><em class="ku">微妙的</em> </strong>和<strong class="jx io"> <em class="ku">不可见的</em></strong>web开发的一部分。</p><p id="066f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我认为如果Elon Musk有一个web开发机构，他也会对服务器端的请求处理说同样的话。如果你仔细看看，你会发现这是一样的。</p><p id="1da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器接收请求，处理它，并产生响应。汽车制造商收到原材料，用它们做东西，然后送回最终产品。汽车制造商有不同的机器执行不同的任务。服务器也是如此。它有独立的中间件，每个中间件执行一个独特的任务。</p><p id="8650" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时候，你不需要把汽车作为一个整体来生产。相反，你只想生产轮胎。那样的话，你会<strong class="jx io">用</strong>一台或两台机器代替。服务器也是一样，你可以为每个单独的请求插入任意多的中间件。</p><h1 id="fba0" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">使用现有的中间件</strong></h1><p id="f02e" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">现在让我们看看中间件最简单的例子。为此，我创建了这个server.js文件，并在其中导入了express和body-parser。<a class="ae kt" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>是NodeJS最流行的web框架。它允许我们跳过许多样板代码，转而关注我们的业务逻辑。Express for Node就像jQuery for vanilla JavaScript。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6998" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们将使用Body-parser，它是一个中间件，允许我们访问我们正在处理的请求的主体。首先，我们需要通过运行以下命令从npm注册表本地安装它:</p><pre class="ma mb mc md gt mg mh mi mj aw mk bi"><span id="2e6b" class="ml ky in mh b gy mm mn l mo mp">npm i body-parser</span></pre><p id="7665" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们需要通过require导入它，就像我们在第5行中做的那样。现在，我们将使用这台机器来处理所有传入的请求。在第12行，我们调用了内置方法use，并为它提供了主体解析器中间件。现在，任何传入的请求都将通过这台机器，因此我们可以访问所有传入请求的主体。</p><h1 id="7e1e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建我们自己的中间件</h1><p id="1d80" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">让我们创建我们的第一个中间件。我们先从一些小而非常有用的东西开始:<strong class="jx io"> <em class="ku"> Loggify。</em> </strong>该中间件将把任何即将到来的请求(获取、发布、删除、上传、..)以及它将在哪个港口到达。正如我们前面所说的，中间件只是一个函数，它有三个主要参数:</p><ul class=""><li id="8cec" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">正在处理的请求，或者我们正在处理的材料</li><li id="6fd9" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">如果我们要发送回响应或最终产品，我们可以使用的响应对象</li><li id="51d1" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">一旦我们的中间件完成了它的工作，并准备好将请求(材料)传递给下一个中间件(机器)，我们可以调用的下一个方法</li></ul><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a077" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，这个函数loggify会在第2行将请求方法和URL记录到控制台。一旦完成，它将把请求传递给生产线上的下一台机器。现在，让我们使用我们的机器。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ba2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们在上一节中拥有的同一个文件。除了，现在，我们从第5行导出的单独文件中导入了中间件loggify。与我们在app.use()中使用body-parse的方式相同，我们使用loggify函数作为参数再次调用它。现在，任何传入的请求都将通过loggify机器，该机器将通知我们，例如，在端点<em class="ku"> /users上有一个传入的<em class="ku"> Get </em>请求。</em></p><p id="f613" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们可以为特定的路径使用中间件。为此，我们只需要以这种方式向app.use()传递一个额外的参数:</p><pre class="ma mb mc md gt mg mh mi mj aw mk bi"><span id="30f6" class="ml ky in mh b gy mm mn l mo mp">app.use('/users', loggify)</span></pre><h1 id="4c51" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="f486" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">中间件是我们希望为web服务器上即将到来的请求调用的函数。但是不用为每个请求处理程序重写它们，我们只需定义它们，并在Express的app.use()方法中使用它们。你可以在类似<a class="ae kt" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ku"/></strong></a>或<a class="ae kt" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ku"> npm </em> </strong> </a>的注册表中找到其他开发者已经编写的数千个，你可以自由地导入和使用。</p><p id="ed6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我第一次接触中间件时，我花了很长时间去理解它们是什么以及如何使用它们。所以，如果还是很混乱的话，是很正常的。你可以继续和他们一起玩！您现在可以创建您的第一个中间件，在您的应用程序中使用它，甚至可以在npm注册表中发布它并邀请您的朋友使用它！</p></div></div>    
</body>
</html>