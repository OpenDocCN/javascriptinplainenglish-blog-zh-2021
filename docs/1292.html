<html>
<head>
<title>Minimum and Maximum Constraints for Date and Time Pickers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日期和时间选取器的最小和最大约束</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/minimum-and-maximum-constraints-for-date-and-time-pickers-9305f12ea745?source=collection_archive---------1-----------------------#2021-03-18">https://javascript.plainenglish.io/minimum-and-maximum-constraints-for-date-and-time-pickers-9305f12ea745?source=collection_archive---------1-----------------------#2021-03-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/93656dba3db271bfac9a93c42ebc6e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mm4kR1FYyRoLW5S-UvcBOw.jpeg"/></div></div></figure><p id="56e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数式React/JavaScript中的一个简单练习，举例说明了日期选择器的一个常见用例。</p><p id="dc1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下文中，我将引用广泛使用的react-datepicker组件，尽管我要考虑的问题可以应用于任何提供类似功能的日期选择器。</p><h1 id="d624" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题是</h1><p id="70bc" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">React-datepicker组件提供了两个属性来约束日期的选择:minDate和maxDate。</p><p id="a3e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置minDate属性时，不能选择前几天，并且禁止浏览前几个月。同样的事情发生在与maxDate相反的方向。</p><p id="3f66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果启用时间选取器部分并指定包含最小时间的minDate，预期行为将是在时间选取器中也具有相同类型的约束:不应启用对minDate时间之前的时间的选择。</p><p id="bab8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实并非如此:仍然可以选择最小时间之前的时间。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/d20a0c4085f421f9042897b19010cb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDuzhFALqMMh8IxHpAxlag.png"/></div></div></figure><p id="f951" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了约束时间的选择，该组件提供了两个附加属性:minTime和maxTime。他们的操作受以下规则的约束:</p><ul class=""><li id="0950" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">两者都必须设置为生效。例如，要禁用08:30 AM之前的时间选择，必须将minTime设置为08:30AM，将maxTime设置为11:59PM</li><li id="8749" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">指定后，无论选择哪一天，都将应用约束。因此，要正确应用它们，这两个属性必须与当前选定的日期相关。</li></ul><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/29b11579f34723b01fc20ddf2284f6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtkLdfsLs05h_Fc3xJSPGg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Static constraint of time does not work because it is applied to all dates</figcaption></figure><p id="518d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在几种情况下，上述规则是有用的。例如，在设置会议的日期和时间时，选择的时间不能超过工作时间。</p><p id="fedf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该组件提供了启用/禁用时间选择的其他可能性。它们允许实现更复杂的用例，但是下面我将只考虑一个简单的场景，在这个场景中，只有当所选日期等于minDate或maxDate时，我们才需要约束时间的选择。</p><h1 id="b2f8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">日平等</h1><p id="22a8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们需要比较两个日期(及其时间),以检查它们是否指的是同一天。</p><p id="931e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过检索自参考日期(1970年1月1日00:00:00)以来经过的毫秒数，可以非常快速地检查日期是否相等:</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="0c44" class="mz ku in mv b gy na nb l nc nd">date1.getTime() === date2.getTime()</span></pre><p id="1e81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于天数相等，算法变得稍微复杂一些，涉及日期的三个组成部分之间的相等性测试:</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="cbbd" class="mz ku in mv b gy na nb l nc nd">date1.getFullYear() === date2.getFullYear()<br/> &amp;&amp; date1.getMonth() === date2.getMonth()<br/> &amp;&amp; date1.getDate() === date2.getDate()</span></pre><p id="aec3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，有一种更好的方法，只需要进行一次比较。</p><p id="bdcf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它包括计算自参考日期以来经过的天数:只需将毫秒数除以一天的毫秒数(86400000)并取发言(不是trunc，我将在后面解释)。</p><p id="da14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个小的复杂问题:getTime返回UTC时区中的毫秒数。要获得日期所在时区的天数，我们需要将时区偏移量(以毫秒为单位)添加到UTC毫秒数中。</p><p id="70c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数getTimezoneOffset返回逆变换(即从日期时区到UTC)的偏移(以分钟为单位):格林威治以东的时区的偏移为负值。<br/>所以实际上我们要减去偏移乘以60000。</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="fe99" class="mz ku in mv b gy na nb l nc nd">const daysFromRefDate = (date) =&gt; <br/>  date &amp;&amp;<br/>    Math.floor(<br/>      (date.getTime() - date.getTimezoneOffset() * 60000) / 86400000<br/>    )</span></pre><p id="4b02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个相对复杂的函数能比之前的三个比较链更有效吗？确实如此，因为JavaScript将日期存储为毫秒，并且前面的每个get函数都必须执行类似的计算。<br/>该功能在单个日期运行，可以使用useMemo挂钩方便地记忆。</p><p id="4b61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要检查两个日期是否与同一天相关，只需比较经过的天数即可:</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="ab24" class="mz ku in mv b gy na nb l nc nd">daysFromRefDate(date1) === daysFromRefDate(date2)</span></pre><h2 id="fd0d" class="mz ku in bd kv ne nf dn kz ng nh dp ld kg ni nj lh kk nk nl ll ko nm nn lp no bi translated">登月后的日子</h2><p id="c212" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为什么daysFromRefDate函数使用floor而不是trunc？因为floor总是返回最接近的左整数:floor(-0.01) == -1，而trunc(-0.01)= 0。<br/>当我们处理参考日期(1/1/1970)之前的日期时，这一点很重要:对于它们，getTime函数返回负值。<br/>这样，函数总是给出正确的结果。</p><p id="f57a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两个日期之间经过的天数始终是自参考日期以来经过的天数的差值。</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="739a" class="mz ku in mv b gy na nb l nc nd">moonLanding = new Date('July 20, 69 00:20:18 GMT+00:00')<br/>daysSinceMoonLanding = daysFromRefDate(new Date()) -<br/>  daysFromRefDate(moonLanding)</span></pre><h1 id="996d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">计算约束</h1><p id="6193" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在我们的使用案例中，minTime和maxTime对有三种不同的设置(在这些设置中，只有日期的时间部分才有意义):</p><ul class=""><li id="012f" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">所选日期的日期必须等于minDate的日期:minTime必须设置为minDate的时间，而maxTime必须等于11:59 PM</li></ul><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="46dd" class="mz ku in mv b gy na nb l nc nd">minTime = minDate<br/>maxTime = new Date().setHours(23, 59, 0, 0)</span></pre><ul class=""><li id="0c02" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">所选日期的日期必须等于最大日期的日期:最大时间必须设置为最大日期的时间，而最小时间必须等于上午12:00</li></ul><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="d8cf" class="mz ku in mv b gy na nb l nc nd">minTime = new Date().setHours(0, 0, 0, 0)<br/>maxTime = maxDate</span></pre><ul class=""><li id="59ee" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">所选日期中介于minDate和maxDate之间的日期:minTime和max Time都应设置为空。</li></ul><h1 id="2f97" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">撰写日期和时间选取器包装</h1><p id="310c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们拥有构建日期选取器组件的所有基础，该组件能够正确地约束最小和最大日期的时间。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="289e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">filterTime的替代实现</h1><p id="8d4b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">reaction-date picker组件还提供了另一种约束时间选择的方法:可以将时间筛选函数传递给该组件。</p><p id="6ea4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次呈现组件时都会调用filter函数，因此与以前的解决方案相比效率更低，因为以前的解决方案仅在selDate更改时计算selDays。</p><p id="9791" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数本身很有趣，因为它是一个自定义挂钩的示例:一个在内部使用React的挂钩的函数。</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>