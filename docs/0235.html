<html>
<head>
<title>How to Manage Scope While Chaining Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在链接数组方法时管理范围</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-manage-scope-while-chaining-array-methods-3ccbd54d00e8?source=collection_archive---------17-----------------------#2021-01-13">https://javascript.plainenglish.io/how-to-manage-scope-while-chaining-array-methods-3ccbd54d00e8?source=collection_archive---------17-----------------------#2021-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/84985677db6b2a2e7ac2a9af2fc1da69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dIM1OZqxtHqdC80s"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@daniel_von_appen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel von Appen</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4aff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数式编程是一个很深的主题，它有一些非常复杂的数学基础。幸运的是，您不必理解所有这些，就能从代码中使用函数技术中获益。您可能已经使用了一些——像map和filter这样的数组方法起源于函数式编程，但是它们也在许多非函数式语言中实现。</p><p id="9d51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，学习更多关于函数式编程的知识可以帮助你充分利用这些特性。我最近看了一本很有帮助的JS函数式编程指南，我强烈推荐它。它比我在这里能谈论的要多得多，但是我想分享我从中获得的一个技巧。这最终是一种非常简单的技术，但是它非常有用，并且说明了函数式编程中一些更深层次的概念。</p><p id="e143" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先说它帮助解决的问题。假设您通过将map和filter方法链接在一起，对一个数组执行一些数据转换。举一个简单的(有点武断的)例子，假设给你一个数字数组，你必须(1)将它们加倍，(2)删除所有大于3的结果数字，以及(3)将所有剩余的数字减5。您可以使用映射和过滤来实现这一点，如下所示:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="cbc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止没有什么太棘手的，但是现在您得到了一个进一步的要求:获取结果数字，对于每个数字，返回它和它在输入数组中对应的原始数字之间的差。例如，由于2被映射到4，通过过滤器保存，然后映射到-1，我们应该返回一个包含-3(即-1减去2)的数组。</p><p id="5333" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的问题是知道哪些数字相互对应。当您到达链的末端时，原始数字已经超出了范围。我们需要的是某种方法来跟踪链中每个数字的来源，以便我们最终可以执行所需的计算。</p><p id="643d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一种强力解决方案:只需将原始值作为参数传递给链中的每个回调函数，这样就可以在需要时访问该值:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="a05c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用了模式匹配来尽可能地使它优雅，但是它仍然是相当难看的代码。好的函数应该只有一个职责，但是这些函数有两个职责:执行计算和保存数据。</p><p id="25f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何做得更好。这里的关键是<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap" rel="noopener ugc nofollow" target="_blank"> flatMap </a>方法，这是JavaScript的一个相对较新的特性。flatMap方法只是一种方便地映射数组，然后展平结果数组的方法。它需要一个返回数组的回调。它将回调应用于初始数组的每个元素，并从所有返回的数组中收集所有元素，将它们返回到单个数组中。</p><p id="e468" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在理论上有点复杂，所以让我们看一个例子。以下是如何获取一个数字数组，并得到这些数字的所有平方根的数组:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="41db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回调函数接受一个数字(例如4)并返回该数字的正负根的数组(例如[2，-2])。因为flatMap变平了，所以我们最终将所有这些根对放在一个数组中。</p><p id="088c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，我们准备好用更干净的方法来解决之前的问题了。每当你有一个数组的值，你想保存为以后的计算，这里是你可以做的:(1)平面映射这些值，(2)对于每个值，映射到一个单一数组只包含该值(如1得到映射到[1])，和(3)执行完全相同的映射和过滤器，如前所述，在这个数组。当您这样做时，您将拥有范围内的原始值，随时可以使用:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="5e20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果将此代码与初始代码进行比较，您会发现第7–9行与之前的第5–7行完全相同。但是因为所有这些映射和过滤器现在都发生在flatMap的回调函数的范围内，所以原始值总是可用的——这就是我们如何在第10行引用它，而不必通过每个其他回调函数来处理它。</p><p id="4a56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能不会立即明显地给出正确的结果，但令人惊讶的是它确实有效。我鼓励你画出数据转换来证明给你自己看——这是我能够完全消化正在发生的事情的唯一方法。</p><p id="1eff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不可否认，这项技术有点奇怪。令人惊讶的是，我们在技术上没有必要的情况下使用2D数组。但这也是该技术如此有趣的部分原因:它表明，有时处理1D数据数组的最简单方法是将其转换为2D数组，对该数组执行操作，然后将其展平回1D数组。知道了这种可能性，您就有了一个强大的工具来编写转换数据数组的函数代码。</p></div></div>    
</body>
</html>