<html>
<head>
<title>Call Native Functions from JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从JavaScript调用本机函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/call-native-functions-from-javascript-c0fa6e03ee90?source=collection_archive---------4-----------------------#2021-09-10">https://javascript.plainenglish.io/call-native-functions-from-javascript-c0fa6e03ee90?source=collection_archive---------4-----------------------#2021-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f6c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> WasmEdge支持JavaScript调用共享库中的本地函数</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f14da83f3b5e4d28b5bab5b517b7aea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXOPlGPPMzILyUU8yAoBpg.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@carlgonz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Carlos Gonzalez</a> on <a class="ae kz" href="https://unsplash.com/s/photos/c-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e2de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我之前的文章中，我解释了<a class="ae kz" href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/" rel="noopener ugc nofollow" target="_blank">为什么以及如何在WebAssembly沙箱</a>中运行JavaScript程序。我还讨论了<a class="ae kz" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">如何使用Rust </a>为WasmEdge创建定制的JavaScript APIs。</p><p id="723c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，为了完全访问底层系统的操作系统和硬件特性，我们有时需要为基于C的本地函数创建JavaScript APIs。也就是说，当JavaScript程序调用预定义的函数时，WasmEdge会将其传递给OS上的原生共享库来执行。</p><p id="ab1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将向您展示如何做到这一点。我们将创建以下两个组件。</p><ul class=""><li id="898d" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated">自定义构建的WasmEdge运行时，允许WebAssembly函数调用外部本机函数。</li><li id="ed24" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">一个定制的QuickJS解释器，它解析JavaScript中的函数调用，并将外部函数调用传递给WebAssembly，web assembly再将它们传递给本机函数调用。</li></ul><p id="79eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了跟进，您需要从Github中<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/fork" rel="noopener ugc nofollow" target="_blank">派生</a>或克隆<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/" rel="noopener ugc nofollow" target="_blank"> wasmedge-quickjs库</a>。该示例位于该存储库的<code class="fe lo lp lq lr b"><a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/host_function/" rel="noopener ugc nofollow" target="_blank">examples/host_function</a></code>文件夹中。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="d590" class="lw lx in lr b gy ly lz l ma mb">$ git clone <a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/" rel="noopener ugc nofollow" target="_blank">https://github.com/second-state/wasmedge-quickjs/</a></span></pre><h1 id="3d6f" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将基于C的函数嵌入WasmEdge</h1><p id="0e83" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">首先，我们将向Wasmedge运行时添加一个基于C的函数，以便我们的JavaScript程序稍后可以调用它。我们使用WasmEdge C API创建一个<code class="fe lo lp lq lr b">HostInc</code>函数，然后将其注册为<code class="fe lo lp lq lr b">host_inc</code>。</p><p id="3378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lo lp lq lr b"><a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/host_function/wasmedge_c/demo_wasmedge.c" rel="noopener ugc nofollow" target="_blank">wasmedge_c/demo_wasmedge.c</a></code>文件包含主机函数的完整源代码及其在WasmEdge中的注册。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="ea1d" class="lw lx in lr b gy ly lz l ma mb">#include &lt;stdio.h&gt;<br/>#include "wasmedge.h"</span><span id="5df4" class="lw lx in lr b gy ne lz l ma mb">WasmEdge_Result HostInc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt, const WasmEdge_Value *In, WasmEdge_Value *Out) {<br/>  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);<br/>  printf("Runtime(c)=&gt; host_inc call : %d\n",Val1 + 1);<br/>  Out[0] = WasmEdge_ValueGenI32(Val1 + 1);<br/>  return WasmEdge_Result_Success;<br/>}</span><span id="f29d" class="lw lx in lr b gy ne lz l ma mb">// mapping dirs<br/>char* dirs = ".:..\0";<br/>  <br/>int main(int Argc, const char* Argv[]) {<br/>  /* Create the configure context and add the WASI support. */<br/>  /* This step is not necessary unless you need WASI support. */<br/>  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();<br/>  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);<br/>  /* The configure and store context to the VM creation can be NULL. */<br/>  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);<br/>  WasmEdge_ImportObjectContext *WasiObject = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);<br/>  WasmEdge_ImportObjectInitWASI(WasiObject,Argv+1,Argc-1,NULL,0,&amp;dirs,1,NULL,0);<br/>  <br/>  /* Create the import object. */<br/>  WasmEdge_String ExportName = WasmEdge_StringCreateByCString("extern");<br/>  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName, NULL);<br/>  enum WasmEdge_ValType ParamList[1] = { WasmEdge_ValType_I32 };<br/>  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };<br/>  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 1, ReturnList, 1);<br/>  WasmEdge_HostFunctionContext *HostFunc = WasmEdge_HostFunctionCreate(HostFType, HostInc, 0);<br/>  WasmEdge_FunctionTypeDelete(HostFType);<br/>  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString("host_inc");<br/>  WasmEdge_ImportObjectAddHostFunction(ImpObj, HostFuncName, HostFunc);<br/>  WasmEdge_StringDelete(HostFuncName);<br/>  <br/>  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);<br/>  <br/>  /* The parameters and returns arrays. */<br/>  WasmEdge_Value Params[0];<br/>  WasmEdge_Value Returns[0];<br/>  /* Function name. */<br/>  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("_start");<br/>  /* Run the WASM function from file. */<br/>  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 0, Returns, 0);<br/>  <br/>  if (WasmEdge_ResultOK(Res)) {<br/>    printf("\nRuntime(c)=&gt; OK\n");<br/>  } else {<br/>    printf("\nRuntime(c)=&gt; Error message: %s\n", WasmEdge_ResultGetMessage(Res));<br/>  }<br/>  <br/>  /* Resources deallocations. */<br/>  WasmEdge_VMDelete(VMCxt);<br/>  WasmEdge_ConfigureDelete(ConfCxt);<br/>  WasmEdge_StringDelete(FuncName);<br/>  return 0;<br/>}</span></pre><p id="1fc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用标准的C编译器(如GCC)来编译C源代码。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="8208" class="lw lx in lr b gy ly lz l ma mb">#build custom webassembly Runtime<br/>$ cd wasmedge_c</span><span id="665a" class="lw lx in lr b gy ne lz l ma mb">#build a custom Runtime<br/>wasmedge_c/$ gcc demo_wasmedge.c -lwasmedge_c -o demo_wasmedge</span></pre><p id="8575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编译器为包含宿主函数的WasmEdge运行时的定制版本生成一个二进制可执行文件<code class="fe lo lp lq lr b">demo_wasmedge</code>。</p><h1 id="b45f" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">创建一个Rust程序，将函数绑定到JavaScript</h1><p id="4920" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">接下来，我们需要在Rust中创建一个定制的JavaScript解释器。它解释对<code class="fe lo lp lq lr b">host_inc</code>的JavaScript调用，并通过定制的WasmEdge运行时(<code class="fe lo lp lq lr b">demo_wasmedge</code>)将调用定向到本机C函数。<a class="ae kz" href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/host_function/src/main.rs" rel="noopener ugc nofollow" target="_blank"> src/main.rs </a>文件包含注册外部函数的完整Rust源代码。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="9de7" class="lw lx in lr b gy ly lz l ma mb">mod host_extern {<br/>    use quickjs_rs_wasi::{Context, JsValue};</span><span id="05eb" class="lw lx in lr b gy ne lz l ma mb">    #[link(wasm_import_module = "extern")]<br/>    extern "C" {<br/>        pub fn host_inc(v: i32) -&gt; i32;<br/>    }</span><span id="bc86" class="lw lx in lr b gy ne lz l ma mb">    pub struct HostIncFn;<br/>    impl quickjs_rs_wasi::JsFn for HostIncFn {<br/>        fn call(ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {<br/>            if let Some(JsValue::Int(i)) = argv.get(0) {<br/>                unsafe {<br/>                    let r = host_inc(*i);<br/>                    r.into()<br/>                }<br/>            } else {<br/>                ctx.throw_type_error("'v' is not a int").into()<br/>            }<br/>        }<br/>    }<br/>}</span><span id="85b2" class="lw lx in lr b gy ne lz l ma mb">use quickjs_rs_wasi::*;</span><span id="b426" class="lw lx in lr b gy ne lz l ma mb">fn main() {<br/>    let mut ctx = Context::new();<br/>    let f = ctx.new_function::&lt;host_extern::HostIncFn&gt;("host_inc");<br/>    ctx.get_global().set("host_inc", f.into());<br/>    <br/>    // Run the embedded JavaScript<br/>    ctx.eval_global_str("print('js=&gt; host_inc(2)=',host_inc(2))");<br/>}</span></pre><p id="1bd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rust程序创建一个定制的QuickJS解释器，然后执行一个JavaScript程序，该程序又调用注册在WasmEdge运行时中的基于C的本地函数。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="b7b4" class="lw lx in lr b gy ly lz l ma mb">$ cargo build --target wasm32-wasi --release</span></pre><p id="cad6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带有嵌入式JavaScript程序的定制QuickJS解释器可在<code class="fe lo lp lq lr b">target/wasm32-wasi/release/host_function.wasm</code>获得。</p><h1 id="97da" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">调用JavaScript函数</h1><p id="a854" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">嵌入式JavaScript程序调用<code class="fe lo lp lq lr b">host_inc()</code>函数。JavaScript解释器(<code class="fe lo lp lq lr b">host_function.wasm</code>的Rust程序)将这个调用路由到WebAssembly <code class="fe lo lp lq lr b">host_inc()</code>调用。定制的WasmEdge运行时(<code class="fe lo lp lq lr b">demo_wasmedge</code>的C程序)将WebAssembly调用路由到本地C函数。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="9104" class="lw lx in lr b gy ly lz l ma mb">print('js=&gt; host_inc(2)=',host_inc(2))</span></pre><blockquote class="nf ng nh"><p id="9939" class="jk jl ki jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated"><em class="in">当然，你也可以编写一个通用的Rust程序，从文件中读取JavaScript。</em></p></blockquote><p id="2bc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要运行这个JavaScript，您需要在我们定制的WasmEdge运行时中使用我们定制的QuickJS解释器。解释器和运行时都支持<code class="fe lo lp lq lr b">host_inc</code>本地函数调用。</p><pre class="kk kl km kn gt ls lr lt lu aw lv bi"><span id="42c2" class="lw lx in lr b gy ly lz l ma mb">$ cd wasmedge_c<br/>$ export LD_LIBRARY_PATH=.<br/>$ ./demo_wasmedge --dir .:. ../target/wasm32-wasi/release/host_function.wasm<br/>js=&gt; host_inc(2)= 3</span></pre><h1 id="af86" class="mc lx in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">下一步是什么</h1><p id="ed8a" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">通过一个简单的例子，我展示了如何将基于C的原生函数转换成JavaScript API。您可以使用相同的方法向JavaScript添加许多本地API。很兴奋看到你想出的东西！</p><p id="75cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本系列文章:</p><ul class=""><li id="6ac6" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/" rel="noopener ugc nofollow" target="_blank">使用WasmEdge在WebAssembly中运行JavaScript</a></li><li id="9d61" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/embed-javascript-in-rust/" rel="noopener ugc nofollow" target="_blank">将JavaScript整合到Rust应用中</a></li><li id="1755" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/embed-rust-in-javascript/" rel="noopener ugc nofollow" target="_blank">使用Rust创建高性能JavaScript API</a></li><li id="7079" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae kz" href="https://www.secondstate.io/articles/call-native-functions-from-javascript/" rel="noopener ugc nofollow" target="_blank">从JavaScript调用本地函数</a></li></ul><p id="b0a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云原生WebAssembly中的JavaScript仍然是下一代云和边缘计算基础设施中的新兴领域。我们才刚刚开始！如果您感兴趣，请加入我们的<a class="ae kz" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> WasmEdge项目</a>(或者通过提出功能请求问题告诉我们您想要什么)。</p><p id="b814" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">更多内容尽在</em><a class="ae kz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">plain English . io</em></strong></a></p></div></div>    
</body>
</html>