<html>
<head>
<title>How to Start Typescript and Node.js AWS Function with Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用无服务器启动Typescript和Node.js AWS函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-start-typescript-node-aws-function-with-serverlessjs-ef4b55910127?source=collection_archive---------2-----------------------#2021-04-25">https://javascript.plainenglish.io/how-to-start-typescript-node-aws-function-with-serverlessjs-ef4b55910127?source=collection_archive---------2-----------------------#2021-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8bfdba5f69032cf1c57b2168f6b5fe6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVrWd-MmDaHIL2cgBth70Q.png"/></div></div></figure><p id="978b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将讨论使用无服务器和TypeScript启动项目。本文需要关于AWS无服务器架构、无服务器框架和TypeScript的基础知识。</p><p id="eb0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用最新稳定版的Serverless (2.35.0)来构建一个“简单”的Serverless项目——一个带有AWS Lambda函数和API网关的REST API。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="1705" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">要求</h1><ul class=""><li id="d43f" class="ly lz in jx b jy ma kc mb kg mc kk md ko me ks mf mg mh mi bi translated"><a class="ae mj" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> (14.x版本)</li><li id="38c2" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><a class="ae mj" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a></li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="09fc" class="my lb in mu b gy mz na l nb nc">$ mkdir ts-jest-serverless<br/>$ cd ts-jest-serverless<br/>$ npm install serverless --no-save</span></pre><p id="9024" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe nd ne nf mu b">--no-save</code>选项安装无服务器软件包，以避免创建<code class="fe nd ne nf mu b">package.json</code>文件。在下一部分中，我们将使用一个模板来启动项目。</p><h1 id="9d30" class="la lb in bd lc ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx bi translated">打字稿模板</h1><p id="1f57" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated">当我们想用TypeScript构建项目时，这是一种初始化项目的简单方法。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="d7ed" class="my lb in mu b gy mz na l nb nc">$ npx serverless create --template aws-nodejs-typescript<br/>$ npm install</span></pre><p id="8e65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了一些配置文件:</p><ul class=""><li id="7b00" class="ly lz in jx b jy jz kc kd kg no kk np ko nq ks mf mg mh mi bi translated"><code class="fe nd ne nf mu b">serverless.ts</code> —无服务器配置</li><li id="e276" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><code class="fe nd ne nf mu b">tsconfig.paths.json</code>和<code class="fe nd ne nf mu b">tsconfig.json</code> —打字稿配置</li><li id="818f" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><code class="fe nd ne nf mu b">webpack.config.js</code> —网络包配置</li></ul><p id="ae0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且我们还有一个简单的函数——<code class="fe nd ne nf mu b">hello</code>函数。</p><p id="fc26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如有必要，让我们更新<code class="fe nd ne nf mu b">package.json</code>和<code class="fe nd ne nf mu b">serverless.ts</code>文件中的项目信息。</p><p id="2b25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数定义的“强类型”。如您所见，<code class="fe nd ne nf mu b">hello</code>函数定义被导出为没有类型的对象，我们不能在这里使用Typescript建议和类型检查特性。让我们将<code class="fe nd ne nf mu b">AWSFunction</code>导出为<code class="fe nd ne nf mu b">src/libs/lambda.ts</code>中的通用类型</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7dc1" class="my lb in mu b gy mz na l nb nc">import middy from "<a class="ae mj" href="http://twitter.com/middy/core" rel="noopener ugc nofollow" target="_blank">@middy/core</a>"<br/>import middyJsonBodyParser from "<a class="ae mj" href="http://twitter.com/middy/http-json-body-parser" rel="noopener ugc nofollow" target="_blank">@middy/http-json-body-parser</a>"<br/>import type { AWS } from "<a class="ae mj" href="http://twitter.com/serverless/typescript" rel="noopener ugc nofollow" target="_blank">@serverless/typescript</a>";</span><span id="0e1c" class="my lb in mu b gy nr na l nb nc">export const middyfy = (handler) =&gt; {<br/>  return middy(handler).use(middyJsonBodyParser())<br/>}</span><span id="9649" class="my lb in mu b gy nr na l nb nc">// AWSFunction type<br/>export type AWSFunction = AWS['functions'][0];</span></pre><p id="511b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，将<code class="fe nd ne nf mu b">hello</code>函数定义转换为<code class="fe nd ne nf mu b">AWSFunction</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a8cc" class="my lb in mu b gy mz na l nb nc">import schema from './schema';<br/>import { handlerPath } from '<a class="ae mj" href="http://twitter.com/libs/handlerResolver" rel="noopener ugc nofollow" target="_blank">@libs/handlerResolver</a>';<br/>import { AWSFunction } from '<a class="ae mj" href="http://twitter.com/libs/lambda" rel="noopener ugc nofollow" target="_blank">@libs/lambda</a>';</span><span id="9bb9" class="my lb in mu b gy nr na l nb nc">export default {<br/>  handler: `${handlerPath(__dirname)}/handler.main`,<br/>  events: [<br/>    {<br/>      http: {<br/>        method: 'post',<br/>        path: 'hello',<br/>        request: {<br/>          schema: {<br/>            'application/json': schema<br/>          }<br/>        }<br/>      }<br/>    }<br/>  ]<br/>} as AWSFunction;</span></pre><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/e5b6ecd47bb2bec2dd083f66a80733b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaQXZ-rTFocUer360s7VCw.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Code suggestion with VSCode</figcaption></figure><p id="5eb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试构建项目:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a877" class="my lb in mu b gy mz na l nb nc">npx sls package</span></pre><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/51e5bd7491849fea6b71168c5193fdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCuYEcEDHHHPbvc376GR8Q.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Serverless warnings</figcaption></figure><p id="c76a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试修复警告:</p><ul class=""><li id="75a7" class="ly lz in jx b jy jz kc kd kg no kk np ko nq ks mf mg mh mi bi translated">使用<code class="fe nd ne nf mu b">events.http.request.schemas</code>代替<code class="fe nd ne nf mu b">src/functions/hello.index.ts</code>中的<code class="fe nd ne nf mu b">…schema</code></li><li id="cf41" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated">禁用<code class="fe nd ne nf mu b">CLI_OPTIONS_SCHEMA</code>警告(等待<code class="fe nd ne nf mu b">serverless-webpack</code>插件更新)。更新<code class="fe nd ne nf mu b">serverless.ts</code></li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f5db" class="my lb in mu b gy mz na l nb nc">...<br/>  disabledDeprecations: [<br/>    'CLI_OPTIONS_SCHEMA',<br/>  ],<br/>  frameworkVersion: '2',<br/>  custom: {<br/>...</span></pre><p id="c7d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以构建没有警告的项目了。</p><h1 id="eeee" class="la lb in bd lc ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx bi translated">无服务器离线插件</h1><blockquote class="ny nz oa"><p id="8363" class="jv jw ob jx b jy jz ka kb kc kd ke kf oc kh ki kj od kl km kn oe kp kq kr ks ig bi translated"><a class="ae mj" href="https://www.npmjs.com/package/serverless-offline" rel="noopener ugc nofollow" target="_blank">这个无服务器</a>插件在你的本地机器上模拟<a class="ae mj" href="https://aws.amazon.com/lambda" rel="noopener ugc nofollow" target="_blank"> AWS λ </a>和<a class="ae mj" href="https://aws.amazon.com/api-gateway" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>，以加快你的开发周期。</p></blockquote><p id="9fc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这个插件，我们可以通过HTTP请求在本地端轻松触发lambda函数。包括lambda函数是否与API网关集成。</p><p id="ce8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装插件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b607" class="my lb in mu b gy mz na l nb nc">$ npm install serverless-offline -D</span></pre><p id="b49c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">启用插件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3a20" class="my lb in mu b gy mz na l nb nc">// update plugin list in serverless.ts file</span><span id="d972" class="my lb in mu b gy nr na l nb nc">...<br/>  plugins: [<br/>    'serverless-webpack',<br/>    'serverless-offline',<br/>  ],<br/>...</span></pre><p id="77f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建脱机脚本:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c472" class="my lb in mu b gy mz na l nb nc">// create a new npm script in package.json file</span><span id="c8f2" class="my lb in mu b gy nr na l nb nc">...<br/>"scripts": {<br/>    "offline": "sls offline --noPrependStageInUrl"<br/>},</span></pre><p id="4dcf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务“离线”服务器:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="116e" class="my lb in mu b gy mz na l nb nc">$ npm run offline</span></pre><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/9b6bc26ebddf8782d2951e7861708afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7A7nqrEJSdGUxbkaM3yvDg.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">The local server is started</figcaption></figure><p id="219f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试使用请求正文调用<code class="fe nd ne nf mu b">GET /hello</code> API:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0f84" class="my lb in mu b gy mz na l nb nc">$ curl --location --request POST 'localhost:3000/hello' \<br/>       --header 'Content-Type: application/json' \<br/>       --data-raw '{ "name": "hoangdv" }'</span></pre><p id="aafe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">登录本地服务器终端将如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="53f8" class="my lb in mu b gy mz na l nb nc">offline: POST /hello (λ: hello)<br/>offline: (λ: hello) RequestId: cknx634oo0008q0pmdlynfvyl  Duration: 21.81 ms  Billed Duration: 22 ms</span></pre><p id="4e67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用预设选项时，会启用监看模式。这意味着当你更新<strong class="jx io">入口点</strong>文件(函数文件)或<strong class="jx io">其相关的</strong>文件时，本地服务器会自动“刷新”更新新的变化。</p><p id="1634" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以在调试模式下运行脱机服务器。程序文件为<code class="fe nd ne nf mu b">./node_modules/.bin/serverless</code>。</p><p id="d890" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果使用的是VSCode，让我们点击<code class="fe nd ne nf mu b">command + shift + p</code>(打开命令选项板)，然后输入<code class="fe nd ne nf mu b">Debug npm Script</code>，点击enter(如果有多个npm脚本，请选择<code class="fe nd ne nf mu b">offline</code>脚本)。</p><p id="fedc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置断点结束调用API终结点:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/5b6ef40cd2166701778881cb78aec1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnWMBuB33hT8G4xkTXoEzA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">Debug with breakpoint</figcaption></figure><h1 id="4ca5" class="la lb in bd lc ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx bi translated">APIGatewayProxy响应中间件</h1><p id="080b" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated">在<code class="fe nd ne nf mu b">hello</code>函数句柄文件中，我们使用<code class="fe nd ne nf mu b">formatJSONResponse</code>函数创建API Gateway集成代理响应。该函数总是返回一个响应对象，其状态代码为200，让我们对其进行更新，使其更有用。</p><p id="5baf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使<code class="fe nd ne nf mu b">statusCode</code>成为参数，以200为默认值:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0b8b" class="my lb in mu b gy mz na l nb nc">import type { APIGatewayProxyEvent, Handler } from "aws-lambda"<br/>import type { FromSchema } from "json-schema-to-ts";</span><span id="8e82" class="my lb in mu b gy nr na l nb nc">type ValidatedAPIGatewayProxyEvent&lt;S&gt; = Omit&lt;APIGatewayProxyEvent, 'body'&gt; &amp; { body: FromSchema&lt;S&gt; }<br/>export type ValidatedEventAPIGatewayProxyEvent&lt;S&gt; = Handler&lt;ValidatedAPIGatewayProxyEvent&lt;S&gt;, any&gt;</span><span id="e3d0" class="my lb in mu b gy nr na l nb nc">export const formatJSONResponse = (response: Record&lt;string, unknown&gt;, statusCode: number = 200) =&gt; {<br/>  return {<br/>    statusCode,<br/>    body: JSON.stringify(response),<br/>  }<br/>}</span></pre><p id="bc7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在每个函数处理程序中，我们必须记住调用<code class="fe nd ne nf mu b">formatJSONResponse</code>函数，这不是一个好主意。</p><p id="246a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，你还必须通过<code class="fe nd ne nf mu b">try/catch</code>来处理函数处理程序内部的错误，如果我们有一个错误处理程序来处理所有的函数错误会更好。</p><p id="7fe6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的模板使用<a class="ae mj" href="https://www.npmjs.com/package/middy" rel="noopener ugc nofollow" target="_blank">middle</a>来应用中间件模式，这样我们就可以很容易地解决上述问题。</p><p id="98e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在<code class="fe nd ne nf mu b">src/libs/middleware.ts</code>中创建<code class="fe nd ne nf mu b">apiGatewayResponseMiddleware</code>中间件工厂</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2c7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nd ne nf mu b">after</code>和<code class="fe nd ne nf mu b">onError</code>是中间件语法。我们也使用<code class="fe nd ne nf mu b">async/await</code>语法，这样就不需要提供中间件的<code class="fe nd ne nf mu b">next</code>功能。</p><ul class=""><li id="fcba" class="ly lz in jx b jy jz kc kd kg no kk np ko nq ks mf mg mh mi bi translated"><code class="fe nd ne nf mu b">after</code>:检查响应是一个HTTP请求，并且该请求尚未格式化，然后将其格式化为API网关响应。</li><li id="dd07" class="ly lz in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><code class="fe nd ne nf mu b">onError</code>:错误情况处理。默认状态码是500，如果错误是一个<code class="fe nd ne nf mu b">AppError</code>状态码将被设置为错误的状态码。</li></ul><p id="efbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nd ne nf mu b">AppError</code>类:<code class="fe nd ne nf mu b">src/libs/appError.ts</code></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b3b8" class="my lb in mu b gy mz na l nb nc">export class AppError extends Error {<br/>  statusCode: number;</span><span id="e9c4" class="my lb in mu b gy nr na l nb nc">constructor(message: string = '', statusCode: number = 400) {<br/>    super(message);<br/>    this.statusCode = statusCode;<br/>  }<br/>}</span></pre><p id="bdf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">向我们的middy注册新的中间件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c647" class="my lb in mu b gy mz na l nb nc">// src/libs/lambda.ts<br/>import middy from '<a class="ae mj" href="http://twitter.com/middy/core" rel="noopener ugc nofollow" target="_blank">@middy/core</a>';<br/>import type { AWS } from '<a class="ae mj" href="http://twitter.com/serverless/typescript" rel="noopener ugc nofollow" target="_blank">@serverless/typescript</a>';<br/>import middyJsonBodyParser from '<a class="ae mj" href="http://twitter.com/middy/http-json-body-parser" rel="noopener ugc nofollow" target="_blank">@middy/http-json-body-parser</a>';<br/>import { Handler } from 'aws-lambda';</span><span id="a61d" class="my lb in mu b gy nr na l nb nc">import { apiGatewayResponseMiddleware } from './middleware';</span><span id="12d6" class="my lb in mu b gy nr na l nb nc">export const middyfy = (handler: Handler) =&gt; {<br/>  return middy(handler)<br/>    .use(middyJsonBodyParser())<br/>    .use(apiGatewayResponseMiddleware({ enableErrorLogger: process.env.IS_OFFLINE === 'true' }));<br/>}</span><span id="acca" class="my lb in mu b gy nr na l nb nc">export type AWSFunction = AWS['functions'][0];</span></pre><p id="68e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从现在开始，在函数处理程序中，我们可以不调用format函数而返回一个结果:</p><p id="db6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nd ne nf mu b">src/function/hello/handler.ts</code></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2cd0" class="my lb in mu b gy mz na l nb nc">...<br/>const hello: ValidatedEventAPIGatewayProxyEvent&lt;typeof schema&gt; = async (event) =&gt; {<br/>  return {<br/>    message: `Hello ${event.body.name}, welcome to the exciting Serverless world!`,<br/>    event,<br/>  };<br/>}<br/>...</span></pre><p id="84fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的逻辑代码中，只要在出错时抛出一个错误，这个错误就会被我们的中间件捕获:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ecb3" class="my lb in mu b gy mz na l nb nc">throw new AppError('User not found', 404);</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="6555" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用Jest进行单元测试</h1><p id="5571" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated">这部分向您展示了如何在我们的项目中使用<a class="ae mj" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>以及如何为函数处理函数编写单元测试。</p><p id="56b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装Jest:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5111" class="my lb in mu b gy mz na l nb nc">$ npm install jest ts-jest @types/jest -D</span></pre><p id="c0bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jest配置:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b494" class="my lb in mu b gy mz na l nb nc">// jest.config.js<br/>const { pathsToModuleNameMapper } = require('ts-jest/utils');<br/>const { compilerOptions } = require('./tsconfig.paths.json');</span><span id="1710" class="my lb in mu b gy nr na l nb nc">module.exports = {<br/>  roots: [<br/>    '&lt;rootDir&gt;'<br/>  ],<br/>  testMatch: [<br/>    '**/__tests__/**/*.+(ts|tsx|js)',<br/>    '**/?(*.)+(spec|test).+(ts|tsx|js)'<br/>  ],<br/>  transform: {<br/>    '^.+\\.(ts|tsx)$': 'ts-jest'<br/>  },<br/>  collectCoverageFrom: [<br/>    '**/*.{js,jsx,ts,tsx}',<br/>    '!**/*.d.ts',<br/>    '!**/node_modules/**',<br/>    '!.serverless/**',<br/>    '!.webpack/**',<br/>  ],<br/>  moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths, { prefix: '&lt;rootDir&gt;/' }),<br/>  globals: {<br/>    'ts-jest': {<br/>      tsconfig: 'tsconfig.json',<br/>    },<br/>  },<br/>}</span></pre><p id="2e19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">启用<code class="fe nd ne nf mu b">tsconfig.json</code>中的<code class="fe nd ne nf mu b">esModuleInterop</code>选项。</p><p id="95fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe nd ne nf mu b">package.json</code>中创建测试脚本:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4530" class="my lb in mu b gy mz na l nb nc">...<br/>"scripts": {<br/>  "offline": "sls offline --noPrependStageInUrl",<br/>  "test": "jest",<br/>}<br/>...</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="02c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们的handler函数在导出之前是被<code class="fe nd ne nf mu b">middyfy</code>函数包装的。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="750b" class="my lb in mu b gy mz na l nb nc">export const main = middyfy(hello);</span></pre><p id="dd42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们必须在导入处理函数之前模仿<code class="fe nd ne nf mu b">middyfy</code>。</p><p id="08e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nd ne nf mu b">src/functions/hello/handler.spec.ts</code></p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="90af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们模仿<code class="fe nd ne nf mu b">middyfy</code>函数只返回处理函数。然后使用<code class="fe nd ne nf mu b">import</code> api导入处理函数。现在我们可以很容易地测试处理函数的结果。</p><p id="e982" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行测试脚本:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8e00" class="my lb in mu b gy mz na l nb nc">$ npm run test</span></pre><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/cb859820ee5d4cb9534c044dfc6c3e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgQVMlv6V2oRangh9gSncw.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk">The test result</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="ffad" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="0e87" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated">我希望你喜欢这篇文章，并从中获得一些有用的东西。现在，您可以使用TypeScript开始您的无服务器项目了。</p><p id="a2c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文使用的源代码发表在<a class="ae mj" href="https://github.com/codetheworld-io/ts-jest-serverless" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="a820" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读！</p><p id="820d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae mj" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ob">更多内容尽在plainenglish.io </em> </a></p></div></div>    
</body>
</html>