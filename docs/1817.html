<html>
<head>
<title>How to have Better NPM Scripts with Scripty</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Scripty制作更好的NPM剧本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-have-better-npm-scripts-with-scripty-491aaa4f3acb?source=collection_archive---------21-----------------------#2021-04-16">https://javascript.plainenglish.io/how-to-have-better-npm-scripts-with-scripty-491aaa4f3acb?source=collection_archive---------21-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e8e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">减轻npm脚本复杂性的快速npm包。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a7b7441d2529392afbbf44b67df7f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mW3FGRwUNYjtSC3m"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@walkator?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Walkator</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="71c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名JavaScript开发人员(无论是后端还是前端)，我们经常依靠<code class="fe ls lt lu lv b">npm scripts</code>来自动化一些常见的任务，比如启动服务器、构建项目，甚至在某些脚本之前或之后执行任务，比如<code class="fe ls lt lu lv b">postbuild</code>、<code class="fe ls lt lu lv b">prebuild</code>等等。</p><p id="6b48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当这些命令像<code class="fe ls lt lu lv b">node index.js</code>一样简单时，在我们的<strong class="ky ir"> package.json </strong>中让它们成为一行根本不是问题。当我们需要一个扩展的命令、添加环境变量和连接命令时，真正的问题就开始了:</p><p id="bd6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(示例摘自<a class="ae kv" href="https://github.com/mui-org/material-ui/blob/830c18ba71af19bc0370f1eeb902f9f605144a5d/package.json" rel="noopener ugc nofollow" target="_blank"> Material UI package.json </a>)</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d718" class="ma mb iq lv b gy mc md l me mf">{<br/>    "scripts": {<br/>      "proptypes": "cross-env BABEL_ENV=development babel-node --extensions \".tsx,.ts,.js\" ./scripts/generateProptypes.ts",<br/>      "deduplicate": "node scripts/deduplicate.js",<br/>      "benchmark:browser": "yarn workspace benchmark browser",<br/>      "build:codesandbox": "lerna run --parallel --scope \"@material-ui/*\" build",<br/>      "release:version": "lerna version --exact --no-changelog --no-push --no-git-tag-version",<br/>      "release:build": "lerna run --parallel --scope \"@material-ui/*\" build",<br/>      "release:changelog": "node scripts/releaseChangelog",<br/>      "release:publish": "lerna publish from-package --dist-tag next --contents build",<br/>      "release:publish:dry-run": "lerna publish from-package --dist-tag next --contents build --registry=\"http://localhost:4873/\"",<br/>      "release:tag": "node scripts/releaseTag",<br/>      "docs:api": "rimraf ./docs/pages/api-docs &amp;&amp; yarn docs:api:build",<br/>      "docs:api:build": "cross-env BABEL_ENV=development __NEXT_EXPORT_TRAILING_SLASH=true babel-node --extensions \".tsx,.ts,.js\" ./docs/scripts/buildApi.ts  ./docs/pages/api-docs ./packages/material-ui-unstyled/src ./packages/material-ui/src ./packages/material-ui-lab/src --apiPagesManifestPath ./docs/src/pagesApi.js",<br/>      "docs:build": "yarn workspace docs build",<br/>      "docs:build-sw": "yarn workspace docs build-sw",<br/>      "docs:build-color-preview": "babel-node scripts/buildColorTypes",<br/>      "docs:deploy": "yarn workspace docs deploy",<br/>      "docs:dev": "yarn workspace docs dev",<br/>      "docs:export": "yarn workspace docs export",<br/>      "docs:icons": "yarn workspace docs icons",<br/>      "docs:size-why": "cross-env DOCS_STATS_ENABLED=true yarn docs:build",<br/>      "docs:start": "yarn workspace docs start",<br/>      //.....<br/>    }<br/>}</span></pre><p id="d35a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我告诉你可以将这些命令提取到一个单独的文件中，并有一个像这样的<code class="fe ls lt lu lv b">scripts</code>配置，会怎么样呢:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b26a" class="ma mb iq lv b gy mc md l me mf">{<br/>    "scripts": {<br/>      "proptypes": "scripty",<br/>      "deduplicate": "scripty",<br/>      "benchmark:browser": "scripty",<br/>      "build:codesandbox": "scripty",<br/>      "release:version": "scripty",<br/>      "release:build": "scripty",<br/>      "release:changelog": "scripty",<br/>      "release:publish": "scripty",<br/>      "release:publish:dry-run": "scripty",<br/>      "release:tag": "scripty",<br/>      "docs:api": "scripty",<br/>      "docs:api:build": "scripty",<br/>      "docs:build": "scripty",<br/>      "docs:build-sw": "scripty",<br/>      "docs:build-color-preview": "scripty",<br/>      "docs:deploy": "scripty",<br/>      "docs:dev": "scripty",<br/>      "docs:export": "scripty",<br/>      "docs:icons": "scripty",<br/>      "docs:size-why": "scripty",<br/>      "docs:start": "scripty",<br/>    }<br/>   //.....<br/>}</span></pre><h2 id="a6ce" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">剧本</h2><p id="be3b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Scripty是一个npm包，它使我们能够拥有运行<code class="fe ls lt lu lv b">npm scripts</code>的可执行文件。</p><p id="a8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个想法是将这些巨大的脚本行视为代码，并保持我们的<strong class="ky ir"> package.json </strong>简洁明了。</p><p id="a940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有这个:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3cfb" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "lint": "eslint . --cache --report-unused-disable-directives --ext .js,.ts,.tsx --max-warnings 0"<br/>  }<br/>}</span></pre><p id="b659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用scripty，它将看起来像这样:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="07bf" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "lint": "scripty"<br/>  }<br/>}</span></pre><h2 id="74bd" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">幕后的魔力</h2><p id="106d" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当然，我们刚刚删除的命令需要在某个地方。为了简单起见，scripty做了一个<code class="fe ls lt lu lv b">&lt;npm-script-nam&gt;:&lt;executable-file-name&gt;</code>的配对。</p><p id="9dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，如果我们有一个名为<code class="fe ls lt lu lv b">lint</code>的npm脚本，我们需要一个名为<code class="fe ls lt lu lv b">lint</code>、<code class="fe ls lt lu lv b">lint.sh</code>或<code class="fe ls lt lu lv b">lint.js</code>的可执行文件。</p><p id="d59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认文件夹在根级别总是一个名为<code class="fe ls lt lu lv b">scripts</code>的文件夹。因此，为了解决前面的迁移，我们将在<code class="fe ls lt lu lv b">scripts</code>文件夹下创建一个名为<code class="fe ls lt lu lv b">lint.sh</code>的文件，如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3a82" class="ma mb iq lv b gy mc md l me mf">#!/usr/bin/env bash</span><span id="db78" class="ma mb iq lv b gy nc md l me mf">yarn eslint . --cache --report-unused-disable-directives --ext .js,.ts,.tsx --max-warnings 0</span></pre><h2 id="cec6" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">可执行Bash或。射流研究…</h2><p id="0a33" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Scripty只能处理可执行的bash或JavaScript可执行文件。</p><p id="eb1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要拥有其中之一，该文件需要:</p><ol class=""><li id="33b1" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">将shebang放在文件的顶部(例如<code class="fe ls lt lu lv b">#!/bin/bash</code>或<code class="fe ls lt lu lv b">#!/bin/node</code>)；</li><li id="bd99" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">有执行权限(而<code class="fe ls lt lu lv b">ls -la</code>需要有<code class="fe ls lt lu lv b">x</code>标志)；</li></ol><blockquote class="nr ns nt"><p id="bbb7" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">快速提示，如果您在UNIX环境中，您可以通过运行命令<code class="fe ls lt lu lv b">chmod u+x &lt;file-path&gt;</code>快速授予该权限。</p></blockquote><p id="f649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，文件扩展名不是必需的。你可以写一个<code class="fe ls lt lu lv b">test.sh</code>、<code class="fe ls lt lu lv b">test.js</code>或者只写<code class="fe ls lt lu lv b">test</code>。定义语法高亮和执行的将是我之前提到的shebang指令之一。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1381" class="ma mb iq lv b gy mc md l me mf">#!/bin/node</span><span id="2884" class="ma mb iq lv b gy nc md l me mf">const fs = require('fs');</span><span id="adbe" class="ma mb iq lv b gy nc md l me mf">fs.copyFileSync('static/base.css', 'dist/base.css');<br/>// ...</span><span id="e786" class="ma mb iq lv b gy nc md l me mf">#!/usr/bin/env bash</span><span id="8159" class="ma mb iq lv b gy nc md l me mf">NODE_ENV=production</span><span id="3a7e" class="ma mb iq lv b gy nc md l me mf">yarn nest build</span></pre><blockquote class="nr ns nt"><p id="5c4c" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated"><em class="iq">对于JS可执行文件，请记住它将由</em> <code class="fe ls lt lu lv b"><em class="iq">node</em></code> <em class="iq">执行，并且您不能使用无效的js-node(例如</em> <code class="fe ls lt lu lv b"><em class="iq">import</em></code> <em class="iq">)语法。</em></p></blockquote><h2 id="6e63" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">定量</h2><p id="2b9a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们经常遇到的另一个需求是运行大量相关的脚本。假设我们有很多<code class="fe ls lt lu lv b">test</code>脚本，我们想运行所有的脚本，比如<code class="fe ls lt lu lv b">test:*</code>:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ef7a" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "test:unit": "jest",<br/>    "test:e2e": "cypress run --ci",<br/>    "test": "npm-run-all test:*",<br/>  }<br/>}</span></pre><p id="15ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用scripty，我们可以创建一个名为<code class="fe ls lt lu lv b">test</code>的子文件夹，并在那里声明这两种类型的测试:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="90e7" class="ma mb iq lv b gy mc md l me mf">.<br/>├── package.json<br/>├── scripts<br/>│   └── test<br/>│       ├── e2e<br/>│       └── unit<br/>└── yarn.lock</span></pre><p id="eebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些带有指令的文件，您可以将package.json更改为:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4238" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "test:unit": "scripty",<br/>    "test:e2e": "scripty",<br/>    "test": "scripty",<br/>  }<br/>}</span></pre><blockquote class="nr ns nt"><p id="1531" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated"><em class="iq">注意，对于这种情况，只有</em> <code class="fe ls lt lu lv b"><em class="iq">test</em></code> <em class="iq">脚本就足够了。我们将只保留</em> <code class="fe ls lt lu lv b"><em class="iq">test:unit</em></code> <em class="iq">和</em> <code class="fe ls lt lu lv b"><em class="iq">test:e2e</em></code> <em class="iq">，以防我们想要单独运行这些命令中的一个。</em></p></blockquote><p id="2ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你运行<code class="fe ls lt lu lv b">test</code>时，scripty会知道你有一个名为<code class="fe ls lt lu lv b">test</code>的文件夹，里面有很多脚本，它会运行所有的脚本。</p><p id="f287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，这是一个并发调用，您不应该依赖于执行顺序。</p><h2 id="9f38" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">控制配料顺序</h2><p id="b882" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您需要它们按照一定的顺序执行，使用与之前相同的package.json，您需要做的就是在我们的<code class="fe ls lt lu lv b">scripts/test</code>文件夹中，创建一个名为<code class="fe ls lt lu lv b">index</code>的脚本，它将负责按照我们想要的顺序执行其他脚本:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2d43" class="ma mb iq lv b gy mc md l me mf">.<br/>├── package.json<br/>├── scripts<br/>│   └── test<br/>│       ├── index<br/>│       ├── integration<br/>│       └── unit<br/>└── yarn.lock</span><span id="9257" class="ma mb iq lv b gy nc md l me mf">#!/bin/bash</span><span id="6ebe" class="ma mb iq lv b gy nc md l me mf">scripts/test/unit<br/>scripts/test/integration</span></pre><blockquote class="nr ns nt"><p id="9cc5" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">请记住，当前的工作目录(CWD)将总是它被执行的地方，在这个例子中是我们的根文件夹。</p></blockquote><h2 id="b508" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">平行手表</h2><p id="b455" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">另一个常见的场景是，当我们需要运行某些脚本时，这些脚本会留在<code class="fe ls lt lu lv b">watch mode</code>中；换句话说，锁定一个分区并一直监听文件的变化，这样它就可以执行某些操作。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="bb18" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "watch:css": "sass src/scss/main.scss public/css/main.css -s compressed",<br/>    "watch:js": "webpack --config webpack.config.js --watch --mode=development",<br/>  }<br/>}</span></pre><p id="02a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启动这两个命令的方法是打开两个选项卡，并在一个选项卡中运行每个命令。但那很乏味。如果我们能有一个终端标签，同时运行所有的<code class="fe ls lt lu lv b">watch</code>会怎么样？</p><p id="d198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用scripty做到这一点，我们所要做的就是在脚本中创建一个名为<code class="fe ls lt lu lv b">watch</code>的文件夹，就像我们之前为<code class="fe ls lt lu lv b">test</code>所做的一样。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="59c1" class="ma mb iq lv b gy mc md l me mf">.<br/>├── package.json<br/>├── scripts<br/>│   └── watch<br/>│       ├── css<br/>│       └── js<br/>└── yarn.lock</span></pre><p id="9974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，除了将<code class="fe ls lt lu lv b">scripty</code>传递给我们的npm脚本，我们还必须用<code class="fe ls lt lu lv b">true</code>指定一个名为<code class="fe ls lt lu lv b">SCRIPTY_PARALELL</code>的环境变量:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c433" class="ma mb iq lv b gy mc md l me mf">{<br/>  "scripts": {<br/>    "watch": "SCRIPTY_PARALLEL=true scripty"<br/>  }<br/>}</span></pre><p id="2cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在两者都将继续运行。</p><h2 id="ff9c" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">警告</h2><p id="7981" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这里最大的警告是针对Windows用户的。</p><p id="931a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是他们中的一员，或者你维护着一个可以在Windows机器上运行的项目，你将需要一些特殊的处理，我建议你看看有这些说明的<a class="ae kv" href="https://www.npmjs.com/package/scripty#windows-support" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="9f43" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">结论</h2><p id="fea5" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Scripty允许我们将npm脚本视为代码，拥有一个包含执行某些任务的所有指令的文件。</p><p id="6fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还简化了回滚不正确的脚本指令的能力，并提供了一个很好的独立的git历史。</p><p id="f2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<strong class="ky ir">要有创意！</strong></p><h2 id="50ed" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">参考</h2><ul class=""><li id="1606" class="nd ne iq ky b kz mx lc my lf ny lj nz ln oa lr ob nj nk nl bi translated"><a class="ae kv" href="https://frontendmasters.com/courses/monorepos/" rel="noopener ugc nofollow" target="_blank">前端主机— JS和TS Monorepo </a></li><li id="90ab" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ob nj nk nl bi translated"><a class="ae kv" href="https://www.npmjs.com/package/scripty" rel="noopener ugc nofollow" target="_blank">剧本</a></li><li id="e691" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ob nj nk nl bi translated"><a class="ae kv" href="https://github.com/mui-org/material-ui/blob/830c18ba71af19bc0370f1eeb902f9f605144a5d/package.json" rel="noopener ugc nofollow" target="_blank"> MaterialUI Package.json </a></li><li id="419f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ob nj nk nl bi translated"><a class="ae kv" href="https://github.com/raulfdm/raulmelo-studio" rel="noopener ugc nofollow" target="_blank">我的Monorepo使用Scripty </a></li><li id="7c94" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ob nj nk nl bi translated"><a class="ae kv" href="https://www.npmjs.com/package/npm-run-all" rel="noopener ugc nofollow" target="_blank">打包NPM-运行-全部</a></li></ul><p id="9c4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nu">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nu">plain English . io</em></a></p></div></div>    
</body>
</html>