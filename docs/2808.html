<html>
<head>
<title>How to Get All Non-Unique Values in a JavaScript Array?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获取一个JavaScript数组中所有非唯一的值？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-all-non-unique-values-in-a-javascript-array-6e98365f54be?source=collection_archive---------12-----------------------#2021-06-08">https://javascript.plainenglish.io/how-to-get-all-non-unique-values-in-a-javascript-array-6e98365f54be?source=collection_archive---------12-----------------------#2021-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb9dd8ec62ef5e52452fe2fe8f37bc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oRTi7K-q3fig3EK3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andy_brunner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andy Brunner</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f7f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们可能希望从一个JavaScript数组中获得所有重复的值。</p><p id="6ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究获取JavaScript数组中所有非唯一值的方法。</p><h1 id="facf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组.原型.过滤器</h1><p id="b1d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用JavaScript数组的<code class="fe me mf mg mh b">filter</code>方法返回满足给定条件的数组。</p><p id="0445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个回调，该回调返回我们希望每个返回项具有的条件。</p><p id="4bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将此与在回调中调用<code class="fe me mf mg mh b">indexOf</code>方法结合起来，以检查该项目是否是项目的第一个实例。</p><p id="1f21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们在调用<code class="fe me mf mg mh b">filter</code>的数组上调用<code class="fe me mf mg mh b">indexOf</code>，这可以从回调的第三个参数中获得。</p><p id="2a77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以检查返回的索引是否与被迭代的项所在的索引相同。</p><p id="b0e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70ad" class="mq lc iq mh b gy mr ms l mt mu">const duplicates = [1, 2, 2, 4, 3, 4].filter((e, index, arr) =&gt; arr.indexOf(e) !== index)<br/>console.log(duplicates)</span></pre><p id="1605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用带有<code class="fe me mf mg mh b">e</code>、<code class="fe me mf mg mh b">index</code>和<code class="fe me mf mg mh b">arr</code>参数的回调函数调用<code class="fe me mf mg mh b">filter</code>。</p><p id="6f8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">e</code>是被迭代的项目。</p><p id="4226" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index</code>是项目<code class="fe me mf mg mh b">e</code>的索引。</p><p id="ddb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">arr</code>是正在调用<code class="fe me mf mg mh b">filter</code>的数组。</p><p id="f08d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用参数<code class="fe me mf mg mh b">e</code>调用<code class="fe me mf mg mh b">arr</code>上的<code class="fe me mf mg mh b">indexOf</code>来返回<code class="fe me mf mg mh b">arr</code>中第一个<code class="fe me mf mg mh b">e</code>实例的索引。</p><p id="3869" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它与<code class="fe me mf mg mh b">index</code>不同，那么我们知道它不是一个值的第一个实例。</p><p id="d915" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe me mf mg mh b">duplicates</code>是<code class="fe me mf mg mh b">[2, 4]</code>，因为它们在数组中是重复的。</p><h1 id="e683" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">清点物品</h1><p id="a157" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建自己的对象来设置计数，从而对数组中的项目进行计数。</p><p id="13df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56f0" class="mq lc iq mh b gy mr ms l mt mu">const obj = [1, 2, 2, 4, 3, 4]<br/>  .map((val) =&gt; {<br/>    return {<br/>      count: 1,<br/>      val<br/>    }<br/>  })<br/>  .reduce((a, b) =&gt; {<br/>    a[b.val] = (a[b.val] || 0) + b.count<br/>    return a<br/>  }, {})</span><span id="9df0" class="mq lc iq mh b gy mv ms l mt mu">const duplicates = Object.entries(obj)<br/>  .filter(([, val]) =&gt; {<br/>    return val &gt; 1<br/>  })<br/>  .map(([key]) =&gt; +key)<br/>console.log(duplicates)</span></pre><p id="7a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">map</code>将每个条目映射到一个对象，其中<code class="fe me mf mg mh b">count</code>设置为1，<code class="fe me mf mg mh b">val</code>设置为数组项值。</p><p id="8769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">reduce</code>用每一项的计数创建一个对象，每一项都是键。</p><p id="4506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将来自<code class="fe me mf mg mh b">a[b.val]</code>的计数分配给<code class="fe me mf mg mh b">(a[b.val] || 0) + b.count</code>来实现这一点。</p><p id="4244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">b.count</code>有了新的计数。</p><p id="1b21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回<code class="fe me mf mg mh b">a</code>，它记录了目前为止所有的计数。</p><p id="45aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个空对象，所以我们在最后创建一个对象。</p><p id="3348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为了得到重复的值，我们得到所有值大于1的键。</p><p id="2e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们在<code class="fe me mf mg mh b">obj</code>上调用<code class="fe me mf mg mh b">Object.entries</code>。</p><p id="207a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用回调函数调用<code class="fe me mf mg mh b">filter</code>来返回任何<code class="fe me mf mg mh b">val</code>大于1的条目。</p><p id="4c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">val</code>是对象属性值。</p><p id="cae8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">map</code>从键值对数组中获取<code class="fe me mf mg mh b">key</code>。</p><p id="9d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到了与上一个例子相同的结果。</p><h1 id="bfec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1e08" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用各种数组和对象方法从数组中获取重复值。</p><p id="f565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mw">plain English . io</em></a></p></div></div>    
</body>
</html>