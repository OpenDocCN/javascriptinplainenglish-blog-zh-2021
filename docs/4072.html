<html>
<head>
<title>The Algo Alcove: Group Anagrams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Algo壁龛:分组字谜</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-algo-alcove-group-anagrams-7b2ae5a7f5fc?source=collection_archive---------20-----------------------#2021-08-13">https://javascript.plainenglish.io/the-algo-alcove-group-anagrams-7b2ae5a7f5fc?source=collection_archive---------20-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9a183d481b87538459d8db7e35b0ba58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UGYwO9R06INxMd_N"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@tot87?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Piotr Łaskawski</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4dda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎回到Algo Alcove，这是一个可以把脚抬起来、喝一杯啤酒(必须到达鲍尔默峰)并准备好投入算法的时髦地方。</p><p id="ce1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我们将学习“小组字谜”。这是<a class="ae jz" href="https://leetcode.com/problems/group-anagrams/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>上的一个中等问题，解决方案相当巧妙。</p><p id="8ce9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本着增长和透明的精神，我想先给你们看一张我的原始解决方案的截图。我自己在计时，所以我知道它不会被优化，但我想向您展示一个未经优化和优化的解决方案是多么的不同。</p><h1 id="cb2a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这个问题</h1><blockquote class="lw lx ly"><p id="c6da" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">给定一个字符串数组<code class="fe md me mf mg b">strs</code>，将字谜组合在一起<strong class="kc io">。可以在<strong class="kc io">任意顺序</strong>返回答案。</strong></p><p id="83fa" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated"><strong class="kc io">变位词</strong>是通过重新排列不同单词或短语的字母形成的单词或短语，通常使用所有原始字母一次。</p></blockquote><h2 id="8903" class="mh kz in bd la mi mj dn le mk ml dp li kl mm mn lm kp mo mp lq kt mq mr lu ms bi translated">例子</h2><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="5c7a" class="mh kz in mg b gy nb nc l nd ne"><strong class="mg io">Input:</strong> strs = ["eat","tea","tan","ate","nat","bat"]<br/><strong class="mg io">Output:</strong> [["bat"],["nat","tan"],["ate","eat","tea"]]</span></pre><p id="d255" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我给你看看我的初步解决方案。请不要取笑我！</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/8db191e0fa415a5748f803cecee85836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpkv32wDnq5LElmNqwX24Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">That’s some hefty code!</figcaption></figure><p id="a374" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到我做的第一件事是定义一个帮助函数来检查任何两个单词是否是彼此的变位词。我通过创建一个<strong class="kc io">散列图</strong>并计算<strong class="kc io"> string1中的所有字母来做到这一点。</strong>然后，我循环遍历<strong class="kc io"> string2 </strong>，将这些字母与我在哈希映射中的计数进行比较。</p><p id="13d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是解决一个简单问题的常用方法，也就是<em class="lz">创建一个函数来判断两个单词是否是彼此的变位词。</em></p><p id="0924" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在那之后，我创建了一个名为<strong class="kc io">的结构，使用</strong>来跟踪所有添加到我的<strong class="kc io"> finalResult </strong>数组中的单词的索引号。然后，我遍历每个单词(如果它不存在于<strong class="kc io"> used </strong>对象中),并使用我的<strong class="kc io"> isAnagram() </strong>辅助函数将它与数组中的所有其他单词进行核对。</p><p id="ed8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果它们是字谜，我会将它们全部推入一个名为<strong class="kc io"> semiResult </strong>的子数组，在循环迭代结束时，我将<strong class="kc io"> semiResult </strong>推入<strong class="kc io"> finalResult。</strong>最后，所有的变位词分组(或者孤独的、未分组的单词)都将在<strong class="kc io"> finalResult </strong>数组中，我可以返回它。</p><p id="e037" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">听起来工作量很大！而且它第二次循环用的是O(n)时间，调皮捣蛋！更不用说，如果不匹配，你必须多次检查同一个单词的变位词。非常低效。</p><p id="982b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经看到了看待事物的幼稚方式，让我们试着找出一个更好的解决方案。</p><h1 id="a14e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优化解决方案</h1><p id="2a03" class="pw-post-body-paragraph ka kb in kc b kd ng kf kg kh nh kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ig bi translated">想出最佳解决方案的第一个技巧源于一个关于字谜的简单事实:当按字母顺序排序时，所有的单词看起来都一样。</p><p id="fc1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想一想:<code class="fe md me mf mg b">['ate', 'eat', 'tea']</code>都是字谜，但是按字母顺序放进去就成了<code class="fe md me mf mg b">['aet', 'aet', 'aet']</code>。这样比较起来就容易多了！</p><p id="b66b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，让我们从我们最喜欢的部分开始:变量声明！</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="03aa" class="mh kz in mg b gy nb nc l nd ne">const groupAnagrams = (strs) =&gt; {<br/>    const anagrams = {};<br/>    <br/>    for (let i = 0; i &lt; strs.length; i++) {<br/>        const singleString = strs[i];<br/>        const sortedString = [...singleString].sort().join('');</span><span id="bfc7" class="mh kz in mg b gy nl nc l nd ne">.........................................</span></pre><p id="dc31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们初始化一个<strong class="kc io">字谜</strong>对象来保存我们排序后的字符串<code class="fe md me mf mg b">['aet', 'aet', 'aet']</code>。然后我们循环遍历字符串数组<strong class="kc io">输入</strong>并使用<code class="fe md me mf mg b">strs[i]</code>拉出单个字符串。下一行看起来有点奇怪，但让我们一条一条地看。</p><p id="e064" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe md me mf mg b">[...singleString]</code>正在使用<strong class="kc io">扩展操作符</strong>，这是一种<strong class="kc io"> ES6 </strong>语法，允许我们打开可迭代对象(如数组或字符串)并将其他数据放入其中。它把<code class="fe md me mf mg b">'eat'</code>变成了<code class="fe md me mf mg b">['e', 'a', 't']</code>。</p><p id="3dc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<strong class="kc io"> singleString </strong>已经被声明并具有一个字符串的值，我们可以声明另一个数组并将<strong class="kc io"> array.push() </strong>我们的<strong class="kc io"> singleString </strong>放入其中。但是这种方式看起来更干净，占用内存更少。</p><p id="b019" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们使用<strong class="kc io"> Array.sort() </strong>方法对数组中的字母进行排序。最后，我们<strong class="kc io">。join() </strong>将它们连接在一起，将它们变回一个单独的字符串(从技术上来说，我们不必这样做，因为数组可以是对象中的键，但是按照哈希的工作方式，我相信这将花费相同的时间)。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="4588" class="mh kz in mg b gy nb nc l nd ne">...............................................</span><span id="add8" class="mh kz in mg b gy nl nc l nd ne">        if (!anagrams[sortedString]) anagrams[sortedString] = [];</span><span id="13b6" class="mh kz in mg b gy nl nc l nd ne">        anagrams[sorted].push(singleString)<br/>    }</span><span id="688d" class="mh kz in mg b gy nl nc l nd ne">    return Object.values(anagrams);</span><span id="0a91" class="mh kz in mg b gy nl nc l nd ne">}</span></pre><p id="c4fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们检查对象中的键(所有键都是排序后的字符串，因为它们对于每个变位词都是相同的)是否存在。如果没有，我们就把这个值作为一个空数组。然后，我们将原始的<strong class="kc io">单字符串</strong>放入我们创建的数组中。</p><p id="f287" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们返回<code class="fe md me mf mg b">Object.values(anagrams)</code>，这是一个为我们对象中的所有<strong class="kc io">值</strong>创建数组的方法，而不是键。这将使我们的数组看起来像我们的成品<code class="fe md me mf mg b">[[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</code></p><p id="5767" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是完整的代码:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/34b9ed7cf469bcbb87eefe07b82294e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKrvCPiVI1IPIiRY3REwCg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Much cleaner!</figcaption></figure><p id="6ef0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天到此为止。我希望这能让你明白，解决一个问题往往不止一种方法。有时候，回顾你的代码并找到优化它的方法会很有帮助。其他时候，它有助于从一个新的角度看问题，看看你能从问题或给出的输入中获得什么普遍真理。</p><p id="458b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢您的阅读。像往常一样，如果你喜欢这篇文章，请留下评论或赞。下次在海湾见！</p><p id="4b57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lz">更多内容看</em><a class="ae jz" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lz">plain English . io</em></strong></a></p></div></div>    
</body>
</html>