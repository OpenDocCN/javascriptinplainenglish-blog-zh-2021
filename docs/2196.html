<html>
<head>
<title>Everything One Can Ask You About JavaScript Arrow Functions in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于2021年的JavaScript Arrow函数，你能问的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-one-can-ask-you-about-arrow-functions-in-2021-51d54621279?source=collection_archive---------7-----------------------#2021-05-08">https://javascript.plainenglish.io/everything-one-can-ask-you-about-arrow-functions-in-2021-51d54621279?source=collection_archive---------7-----------------------#2021-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4535853d720c08c1742c1faf4f684f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M3-hCmFzxUCHXi7f"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eecd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你最近是否被术语“箭头函数”弄得措手不及？</p><p id="2673" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者说，你知道它的存在，但当讨论到它的本质时，你发现自己被遗忘了？</p><p id="9a7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你的答案是“去过那里，做过那个！”那你就登陆了正确的页面，我的朋友！️🚀</p><p id="60bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们，世界的开发者，总是渴望了解更多。但与此同时，我们也缺乏耐心去无休止地翻页，去彻底了解一些东西。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/682efb4a90ba7e8ee1c765390a35b885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jvviuC9jwcuTUBTy4sE1w.jpeg"/></div></figure><p id="1800" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名初露头角的学者，我确实发现自己被夹在成千上万的书签之间，并被不确定的重定向所困扰。有时，它甚至会削弱寻找更多的欲望。因此，我决定考虑克林特·伊斯特伍德几十年前给我们的一条建议——“有时，如果你想看到更好的变化，你必须把事情掌握在自己手中”。</p><p id="67b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我采纳了他的建议，整理了我从各种渠道和采访经历中收集的所有信息，因为我们必须纵容好奇心，而不是削弱它！ </p><p id="d6a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事不宜迟，这就是了！一个关于箭头函数的A-Z！对于那些对此一无所知的人和那些好奇想知道它的一切的人(做好长时间阅读的准备，一个人不能从A跳到Z而跳过中间的字母。所以系好安全带，走完这26步！😉).</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="5e47" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">从非常明显的问题开始:什么是箭头函数？</h1><p id="4dfa" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">箭头函数是Javascript ES6中引入的众多概念之一。ES6中引入的一些其他概念包括:</p><ul class=""><li id="5ef7" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx mt mu mv mw bi translated"><strong class="kc io"> <em class="ld">块范围的变量(Let和Const) </em> </strong></li><li id="d7a3" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io"> <em class="ld">字符串插值</em> </strong></li><li id="1135" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io"> <em class="ld">解构</em> </strong></li><li id="3b03" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io"> <em class="ld">散歇符</em> </strong></li><li id="4021" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw bi translated"><strong class="kc io"> <em class="ld">默认参数</em> </strong></li></ul><p id="7035" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">这样的例子还可以持续一段时间……</em> </strong></p><p id="b729" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将会在下面的内容中发现一些这样的概念。不过，我保证你再也不用跳页了！我抓住你了。</p><p id="f263" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们设计一个箭头函数的紧凑定义，涵盖它的所有方面(基本上只有两个方面，因为Javascript坚信简单🤟).</p><blockquote class="nc"><p id="3e67" class="nd ne in bd nf ng nh ni nj nk nl kx dk translated">“箭头函数是常规函数的语法糖，因为它允许我们为函数声明编写简短的语法。arrow函数和我们以前的pal常规函数的区别在于，arrow函数中的“this”上下文“总是”引用其词法父级的“this”上下文(它不能被代码世界中的任何其他力量改变)。”</p></blockquote><p id="906b" class="pw-post-body-paragraph ka kb in kc b kd nm kf kg kh nn kj kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">箭头函数通常也被称为<strong class="kc io">胖函数或λ函数</strong>。所以，当有人向你抛出这两个术语时，不要翻转，因为这只是测试你对箭头函数的理解有多深。</p><h1 id="ed80" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated">为什么胖，为什么是Lambda？</h1><p id="4b4c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">它从语法中使用的粗箭头(= &gt;)继承了名称“fat”。</p><p id="bf23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它继承了名称“Lambda ”,因为Lambda functions是一个通用术语，在许多编程语言中用来表示提供简单语法的函数，或者可以写成匿名函数(没有名称)。箭头函数的工作原理类似，因此得名。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="1f98" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">是时候玩“发现差异”了😁</h1><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="d704" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">//Arrow function<br/>const greenArrow = () =&gt; {<br/> return “Hey, I am an arrow function”;<br/>}</strong></span><span id="6c63" class="ob lm in nx b gy og od l oe of"><strong class="nx io">//Regular function<br/>const deathStroke = function (){<br/> return “Hey, I am a regular function”;<br/>}</strong></span></pre><p id="d7aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你发现了吗？当然，你做到了！如您所见，上述两种语法之间唯一的细微差别是:</p><p id="1fe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oh oi oj nx b"><strong class="kc io">“function ()” </strong>replaced by “<strong class="kc io">() =&gt;”</strong></code></p><p id="1fef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很简单，对吧？</p><p id="63d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的两个例子中，我们可以看到arrow函数是如何独立于“function”关键字来定义函数的，因此语法很短。但是，如果它只是从表达式中删除一个关键字，这难道不是一个被高估的概念吗？正如你已经猜到的，它还有更多！</p><h1 id="27e0" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated">越短越好！</h1><p id="46c1" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">箭头函数带来的好处是我们可以让它变得更短！但是！</p><p id="0894" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">仅当一个参数传递给函数，且函数在其返回块</em> </strong>中包含一条语句时。</p><p id="d4d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有或者有一个以上的参数被传递，那么它们必须用圆括号()括起来。类似地，如果函数块中没有或有一个以上的return语句，它们必须用花括号{}括起来。</p><h2 id="8c0b" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated">较短语法的不同组合</h2><p id="d679" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="kc io"> <em class="ld"> 1。最短语法—一个return语句和一个参数。</em>T11】</strong></p><p id="5f1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的片段:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="8c26" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = (shoot) =&gt; {<br/> return shoot * 100;<br/>}</strong></span></pre><p id="82c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，它是“返回”一个表达式，而不是在块中执行任何其他单行操作，比如<code class="fe oh oi oj nx b">console.log</code>。我们稍后也会谈到这一点。</p><p id="6f4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设计简短的语法，去掉return关键字和任何你能找到的括号👀。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="0030" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = shoot =&gt; shoot * 100;</strong></span></pre><p id="7f17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很美，不是吗？这是常规函数永远无法实现的。无意冒犯，老朋友！😛</p><p id="7870" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">特例</em> </strong> <em class="ld"> : </em> <strong class="kc io"> <em class="ld">如果返回值是一个对象，我们可以直接去掉return关键字，但是必须将返回的块用圆括号()括起来。</em> </strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="41ff" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = () =&gt; {<br/> return {shot: "bullseye"};<br/>}</strong></span></pre><p id="69e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">将被写成— </em></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="3d26" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = () =&gt; ({shot: “bullseye”});</strong></span></pre><p id="cb55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">2<em class="ld">2。短语法-函数块中的一个参数和一条语句(不返回)。</em> </strong></p><p id="3a2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的片段:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="9905" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = (shoot) =&gt; {<br/> console.log(`Hey, I shot deathstroke ${shoot} times`);<br/>}</strong></span></pre><p id="f032" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">将被写成— </em></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="b742" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = shoot =&gt; console.log(`Hey, I shot deathstroke ${shoot} times`);</strong></span></pre><p id="9040" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将再次省略表达式中的所有括号，但我们必须写出完整的<code class="fe oh oi oj nx b"><strong class="kc io">console.log()</strong></code>语句，因为只有<code class="fe oh oi oj nx b"><strong class="kc io">return</strong></code>在其不存在时拥有存在的能力。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="0632" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">NOTE : In case you are confused by the </strong><strong class="nx io">` `</strong><strong class="nx io"> backticks I have used to enclose the statement inside </strong><strong class="nx io">console.log</strong><strong class="nx io"> instead of the </strong><strong class="nx io">“ ” double quotes </strong><strong class="nx io">that we are quite familiar with, then here is the answer you are looking for - </strong></span><span id="79c5" class="ob lm in nx b gy og od l oe of"><strong class="nx io">` ` does string interpolation! Yes, one of the many other concepts introduced in ES6. String interpolation is helpful for evaluating a statement containing one or more placeholders which are replaced by their corresponding values in the final output. </strong></span></pre><p id="c287" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld"> 3。短语法-功能块中的一个参数和多个语句。</em>T12】</strong></p><p id="dcec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的片段:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="ce92" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = (shoot) =&gt; {<br/>  console.log(`Hey, I shot deathstroke ${shoot} times`);<br/>  console.log("And guess what? He didn't even flinch!");<br/>}</strong></span></pre><p id="30a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">将被写成— </em></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="1077" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = shoot =&gt; {<br/>  console.log(`Hey, I shot deathstroke ${shoot} times`);<br/>  console.log("And guess what? He didn't even flinch!");<br/>}</strong></span></pre><p id="3022" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">去掉了参数周围的括号，因为我们接收的是一个参数，但是我们现在必须用花括号将返回的代码块中的多行代码括起来。</p><p id="e93a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld"> 4。短语法—功能块中有多个参数和一条语句。</em> </strong></p><p id="ae64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的片段:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="808a" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = (people, computers) =&gt; {<br/> return `${people} keep secrets, ${computers} do not.`;<br/>}</strong></span></pre><p id="668e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">将被写成— </em></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="02a2" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = (people, computers) =&gt; `${people} keep secrets, ${computers} do not.`;<br/></strong></span></pre><p id="a677" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">保留了多个参数周围的括号，并从包含单个return语句的功能块中省略了括号和return语句。</p><p id="d37d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你很清楚我们如何创建更短的arrow/fat/lambda函数语法。现在，让我们转到更面向逻辑的方面，这是箭头函数中<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>的行为。</p><p id="9501" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不太确定什么是<code class="fe oh oi oj nx b">this</code>上下文，请不要惊慌。我掩护你！如果很清楚<code class="fe oh oi oj nx b">this</code>的背景，跳过下一节。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="674c" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">《本纪</strong> <code class="fe oh oi oj nx b"><strong class="ak">" </strong></code> <strong class="ak">上下文</strong></h1><p id="afee" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><code class="fe oh oi oj nx b">this</code>指对象内部的上下文。并且当使用一个没有附加到任何用户定义对象的<code class="fe oh oi oj nx b">this</code>时，浏览器会自动将其附加到窗口对象。(浏览器，终极救星！).</p><p id="d281" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过几个例子来更好地理解它。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="0dd8" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gryffindor = {<br/>  founder : "Godric Gryffindor",<br/>  houseGhost : "Nearly-Headless-Nick",<br/>  madeUpFacts : function () {<br/>    return `Once upon a time, ${this.founder} hung out with  ${this.houseGhost}!`      <br/>   }<br/>};</strong></span><span id="53b9" class="ob lm in nx b gy og od l oe of"><strong class="nx io">gryffindor.madeUpFacts();</strong></span></pre><p id="1ba4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，对象<code class="fe oh oi oj nx b"><strong class="kc io">gryffindor</strong></code> <strong class="kc io"> </strong>中定义的所有属性都属于对象的<strong class="kc io">上下文</strong>。</p><p id="2230" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oh oi oj nx b"><strong class="kc io">founder</strong></code>、<code class="fe oh oi oj nx b"><strong class="kc io">houseGhost </strong></code>、<code class="fe oh oi oj nx b"><strong class="kc io">madeUpFacts </strong></code>属于<code class="fe oh oi oj nx b"><strong class="kc io">gryffindor.</strong></code> <strong class="kc io"> </strong>对象的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文，函数内部的<code class="fe oh oi oj nx b"><strong class="kc io">this</strong></code> <strong class="kc io"> </strong>上下文由调用函数的对象<strong class="kc io">决定。</strong>既然如此，我们就在<code class="fe oh oi oj nx b"><strong class="kc io">gryffindor</strong></code> <strong class="kc io">上调用<strong class="kc io"> </strong> <code class="fe oh oi oj nx b"><strong class="kc io">madeUpFacts</strong></code> <strong class="kc io"> </strong>，</strong>里面的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文<strong class="kc io"/><strong class="kc io"/>就是<strong class="kc io"> </strong> <code class="fe oh oi oj nx b"><strong class="kc io">gryffindor</strong></code> <strong class="kc io">的上下文。</strong></p><p id="32e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更清楚，让我们看另一个例子:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="f2ac" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">function potterHead () {<br/>  this.potterFanatic = true;<br/>  this.beatsGreenArrow = "It's complicated!";<br/>}</strong></span><span id="9c97" class="ob lm in nx b gy og od l oe of"><strong class="nx io">potterHead();<br/>console.log(this.potterFanatic); //prints true<br/>console.log(this.beatsGreenArrow); //prints It's complicated!</strong></span></pre><p id="ce91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你拿到了吗？<code class="fe oh oi oj nx b"><strong class="kc io">potterHead </strong></code>在窗口对象上被调用。因此，变量<code class="fe oh oi oj nx b"><strong class="kc io">potterFanatic</strong> </code>和<code class="fe oh oi oj nx b"><strong class="kc io">beatsGreenArrow </strong></code>被附加到窗口对象的上下文中。</p><p id="8cdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，不要徘徊太多。<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文只是指一个对象的上下文。不多不少。</p><p id="9a7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，对象的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文可以很容易地传递，但只能用<strong class="kc io">常规函数</strong>。</p><h1 id="c093" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated">将“天选之物”附加到常规函数的两种方法</h1><p id="7352" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="kc io"> <em class="ld"> 1。一个常规函数总是拾取用于调用常规函数</em> </strong>的对象的  <code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code> <strong class="kc io"> <em class="ld">上下文。</em></strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="f891" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gryffindor = {<br/>  founder : "Godric Gryffindor",<br/>  houseGhost : "Nearly-Headless-Nick",<br/>  madeUpFacts : function () {<br/>    return `Once upon a time, ${this.founder} hung out with  ${this.houseGhost}!`      <br/>   }<br/>};</strong></span><span id="88d6" class="ob lm in nx b gy og od l oe of"><strong class="nx io">gryffindor.madeUpFacts();</strong></span></pre><p id="52a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑我们在上一节看到的同一个例子。向上滚动阅读解释。</p><h2 id="b55a" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak">后续问题:</strong></h2><blockquote class="ov ow ox"><p id="fea0" class="ka kb ld kc b kd ke kf kg kh ki kj kk oy km kn ko oz kq kr ks pa ku kv kw kx ig bi translated">但是如果，<code class="fe oh oi oj nx b"><strong class="kc io">madeUpFacts </strong></code>不是<code class="fe oh oi oj nx b"><strong class="kc io">gryffindor </strong></code>的属性，我们仍然想访问<code class="fe oh oi oj nx b"><strong class="kc io"><em class="in">madeUpFacts</em></strong></code>中<code class="fe oh oi oj nx b"><strong class="kc io"><em class="in">gryffindor </em></strong></code>的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文，该怎么办呢？</p></blockquote><p id="688e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">②<em class="ld">。我们还可以通过调用/应用/绑定将</em> </strong> <code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code> <strong class="kc io"> <em class="ld">上下文附加到常规函数上。让我们调整前面的代码片段来达到同样的效果。</em>T24】</strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="b822" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gryffindor = {<br/>  founder : "Godric Gryffindor",<br/>  houseGhost : "Nearly-Headless-Nick",<br/>};<br/>const madeUpFacts = function () {<br/>    return `Once upon a time, ${this.founder} hung out with  ${this.houseGhost}!`      <br/>};</strong></span><span id="0e11" class="ob lm in nx b gy og od l oe of"><strong class="nx io">madeUpFacts.call(gryffindor);</strong></span></pre><p id="ef4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用<code class="fe oh oi oj nx b"><strong class="kc io">call/apply/bind</strong></code>将对象的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文附加到不是对象属性的函数上。传递给<code class="fe oh oi oj nx b"><strong class="kc io">call/apply/bind</strong></code>的第一个参数是我们想要分配给常规函数的新的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文。</p><p id="25c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe oh oi oj nx b"><strong class="kc io">Call/Apply/Bind</strong></code>除了对<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文的依附之外，在其他方面都做了不同的工作。</p><p id="471c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是为了让您对常规函数的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>如何工作有一个大致的了解。现在是我们进入箭头函数如何处理<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文的好时机。</p><h1 id="0fb6" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated"><strong class="ak">箭头功能和“this”上下文的关系</strong></h1><p id="f8ce" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">我们现在非常清楚如何将任何<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文附加到常规函数上。</p><blockquote class="ov ow ox"><p id="6375" class="ka kb ld kc b kd ke kf kg kh ki kj kk oy km kn ko oz kq kr ks pa ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">但是，我们可以对箭头函数做同样的事情吗？</em> </strong></p></blockquote><p id="5671" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不，从来没有！</p><blockquote class="ov ow ox"><p id="6a0a" class="ka kb ld kc b kd ke kf kg kh ki kj kk oy km kn ko oz kq kr ks pa ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">那么，箭头函数里面的</em> </strong> <code class="fe oh oi oj nx b"><strong class="kc io"><em class="in">this </em></strong></code> <strong class="kc io"> <em class="in">上下文会是什么呢？</em> </strong></p></blockquote><p id="5fd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这才是你需要掌握的诀窍！所有关于箭头函数的输出型问题都围绕着对这个概念的理解。所以，仔细看！</p><blockquote class="nc"><p id="c544" class="nd ne in bd nf ng nh ni nj nk nl kx dk translated">arrow函数的"<code class="fe oh oi oj nx b"><strong class="ak">this” </strong></code>上下文总是指其词法父级的" this "上下文。还有…</p></blockquote><figure class="pb pc pd pe pf jo"><div class="bz fp l di"><div class="pg ph l"/></div></figure><blockquote class="nc"><p id="8303" class="nd ne in bd nf ng pi pj pk pl pm kx dk translated">arrow函数的词法父类要么是封装它的函数(如果有的话)，要么是窗口对象！不多不少。</p></blockquote><p id="9ba7" class="pw-post-body-paragraph ka kb in kc b kd nm kf kg kh nn kj kk kl no kn ko kp np kr ks kt nq kv kw kx ig bi translated">如果你对以上两种说法有一个水晶般清晰的理解，你就可以解决任何涉及到箭头函数的情况。虽然，如果你还没有做到，看看下面的例子，你会做到的！😊</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="098e" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">基于输出的箭头功能问题</strong></h1><h1 id="78f2" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi">1.</h1><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="ba4d" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const justiceLeague = {<br/>  superVillain: "Darkseid",<br/>  firstEdition : function () {<br/>      return `Who is ${this.superVillain}? Wasn't SteppenWolf the villain in Justice League?`;<br/>  }, <br/>  secondEdition : () =&gt; {<br/>         return `Sad that you haven't watched the Snyder Cut yet because ${this.superVillain} is the GOAT!`;<br/> }<br/>};<br/>justiceLeague.firstEdition();<br/>justiceLeague.secondEdition();</strong></span></pre><p id="067b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出— </strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="23f8" class="ob lm in nx b gy oc od l oe of">Who is Darkseid? Wasn't SteppenWolf the villain in Justice League?</span><span id="fff7" class="ob lm in nx b gy og od l oe of">Sad that you haven't watched the Snyder Cut yet because <strong class="nx io">undefined </strong>is the GOAT!</span></pre><p id="b79b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，就像正义联盟的第一次切割一样，达克赛德再次拒绝露面。😯</p><p id="f252" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">那么，为什么是未定义的呢？</strong></p><p id="f6d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再次提醒自己:</p><p id="a8e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">“当一个箭头函数被定义为一个对象的属性时，它的词法作用域不是这个对象，而是它所包装的函数或者窗口对象。”</em>T19】</strong></p><p id="a7b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，函数的词法范围:<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition </strong></code>是<code class="fe oh oi oj nx b"><strong class="kc io">window </strong></code>对象，因为它没有被另一个函数包装。并且窗口对象没有为其定义的<code class="fe oh oi oj nx b"><strong class="kc io">superVillain</strong> </code>属性。因此，未定义的值。对其调用arrow函数的对象没有任何影响。</p><p id="3aa3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而函数<code class="fe oh oi oj nx b"><strong class="kc io">firstEdition</strong></code> <strong class="kc io">，</strong>是一个常规函数，它获取调用它的对象<code class="fe oh oi oj nx b"><strong class="kc io">justiceLeague </strong></code>的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文，并因此在返回语句中返回<code class="fe oh oi oj nx b"><strong class="kc io">this.superVillain</strong></code>的正确值。</p><h2 id="3ef7" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak">跟进问题:</strong></h2><p id="4d03" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">现在解决上述情况。从箭头函数返回<code class="fe oh oi oj nx b"><strong class="kc io">this.superVillain</strong></code>的正确值，而不是<code class="fe oh oi oj nx b"><strong class="kc io">undefined</strong></code>。</p><p id="c136" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">又陷入困境了？不要想太多。箭头函数很简单，记住，它只基于两个原则。</p><p id="3f69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需应用<strong class="kc io">将<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文附加到箭头函数的</strong>方式。</p><p id="bbfc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用你选择的词法父类包装它！T29】</p><p id="64d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不确定怎么做？让我们来了解一下！</p><h1 id="2964" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi">2.</h1><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="7f99" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const justiceLeague = {<br/>  superVillain: "Darkseid",<br/>  firstEdition : function () {<br/>   return `Who is ${this.superVillain}? Wasn't SteppenWolf the   villain in Justice League?`;<br/>  }, <br/>  secondEdition : function () {<br/>    return function = () =&gt; {<br/>       return `Sad that you haven't watched the Snyder Cut yet because ${this.superVillain} is the GOAT!`;<br/>     }<br/>  }<br/>};<br/>justiceLeague.firstEdition();<br/>justiceLeague.secondEdition()();</strong></span></pre><p id="9b4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出— </strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="93db" class="ob lm in nx b gy oc od l oe of">Who is Darkseid? Wasn't SteppenWolf the villain in Justice League?</span><span id="ab76" class="ob lm in nx b gy og od l oe of">Sad that you haven't watched the Snyder Cut yet because Darkseid is the GOAT!</span></pre><p id="ba03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道谁是有史以来最大的恶棍了！🤭</p><p id="5a4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我做了什么来弥补？正如我之前所说的，只是围绕箭头函数的一个新的词法父类。</p><p id="8f6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们一步一步来看:</p><p id="fac3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将函数<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition </strong></code>更改为一个常规函数，现在它可以接受我们希望它接受的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文，并用这个常规函数包装箭头函数。包装意味着从常规函数内部返回箭头函数。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="0872" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">justiceLeague.secondEdition()</strong></span></pre><p id="b1d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<code class="fe oh oi oj nx b"><strong class="kc io">justiceLeague </strong></code>的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文附加到<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition </strong></code>上，因为<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition </strong></code>现在是常规函数。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="9459" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">justiceLeague.secondEdition()();</strong></span></pre><p id="e049" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition </strong></code>调用返回的函数，即箭头函数。arrow函数消耗其词法父级的<code class="fe oh oi oj nx b"><strong class="kc io">this</strong></code>上下文，该父级是一个函数(<code class="fe oh oi oj nx b"><strong class="kc io">secondEdition</strong></code> <strong class="kc io"> </strong>)。</p><p id="32bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">“因此，将</em> </strong> <code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code> <strong class="kc io"> <em class="ld">上下文附加到箭头函数的唯一方法是用一个可以接受您想要的任何</em> </strong> <code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code> <strong class="kc io"> <em class="ld">上下文的常规函数来包装它。”</em> </strong></p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="9bba" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">你认为你什么都知道，但你真的知道吗？</h1><p id="8c7c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">你准备好看看我们对箭头函数的理解中的一些漏洞了吗？</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="pn ph l"/></div></figure><h1 id="f3c7" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated"><strong class="ak">漏洞-1:</strong></h1><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="15c5" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const hero = "Green Arrow";<br/>const ultimate = () =&gt; {<br/> console.log(`Who is the ultimate hero? ${this.hero}!`);<br/>};<br/>ultimate();</strong></span></pre><p id="8004" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你认为上面的输出应该是什么？</p><p id="1a15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">箭头函数<code class="fe oh oi oj nx b"><strong class="kc io">ultimate</strong></code>的词汇父项是窗口对象，我们在窗口的上下文中定义了一个名为<code class="fe oh oi oj nx b"><strong class="kc io">hero</strong></code>的变量。所以，它应该返回:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="e54f" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">Who is the ultimate hero? Green Arrow!</strong></span></pre><p id="0a97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们运行这段代码并检查输出。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="f5bf" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">Who is the ultimate hero? undefined!</strong></span></pre><p id="af06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上是我收到的输出。太奇怪了！不要太多，如果你知道接下来会发生什么——</p><p id="6ae8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">所有块范围的变量(const和let变量)从不依附于</em> </strong> <code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code> <strong class="kc io"> <em class="ld">上下文的“窗口”。</em> </strong></p><p id="46a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，这段代码也将返回一个未定义的。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="c710" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const hero = "Green Arrow";<br/>console.log(this.hero); //returns undefined</strong></span></pre><h2 id="86e3" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated">后续问题:</h2><p id="b006" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="kc io">您如何解决上述问题？</strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="2ab8" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">var hero = "Green Arrow";<br/>const ultimate = () =&gt; {<br/> console.log(`Who is the ultimate hero? ${this.hero}!`);<br/>};<br/>ultimate();</strong></span></pre><p id="778b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">返回— </em></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="ecfb" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">Who is the ultimate hero? Green Arrow!</strong></span></pre><p id="a8b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外——</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="b872" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">var hero = "Green Arrow";<br/>console.log(this.hero); //returns Green Arrow</strong></span></pre><p id="d2ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">故事的寓意——如果您打算稍后使用</em></strong><code class="fe oh oi oj nx b"><strong class="kc io"><em class="ld">this </em></strong></code><strong class="kc io"><em class="ld"/></strong><em class="ld">来访问它，请不要在窗口的作用域中使用块作用域变量。</em></p><h1 id="f674" class="ll lm in bd ln lo nr lq lr ls ns lu lv lw nt ly lz ma nu mc md me nv mg mh mi bi translated"><strong class="ak">漏洞二:</strong></h1><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="927a" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">deathStroke();<br/>greenArrow();<br/>var greenArrow = () =&gt; {<br/>   return "I want peace and no war!";<br/>};<br/>function deathStroke() {<br/>   return "I want peace too but that comes after war!"<br/>};</strong></span></pre><p id="18f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面代码的输出应该是什么？</p><p id="ad49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过提升的概念，所有的<code class="fe oh oi oj nx b"><strong class="kc io">var</strong></code>类型变量和函数声明都被提升到作用域的顶部。所以它应该执行这两个函数。</p><p id="6fb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是你还记得吊装到底是怎么工作的吗？</p><p id="d070" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当一个变量被提升到一个作用域的顶部时，只有声明被提升到顶部并被赋予一个值<code class="fe oh oi oj nx b"><strong class="kc io">undefined.</strong></code> <strong class="kc io"> </strong>当程序到达它被写入的行<strong class="kc io">时，用户定义的赋值发生。</strong></p><p id="7a0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在后台进行提升后，我们的代码将如下所示:</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="ae47" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">var greenArrow = undefined;<br/>function deathStroke() {<br/>   return "I want peace too but that comes after war!"<br/>};<br/>deathStroke();<br/>greenArrow();<br/>greenArrow = () =&gt; {<br/>   return "I want peace and no war!";<br/>};</strong></span></pre><p id="6810" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">寓意——箭头功能不能悬挂。就像我们自己的块范围变量一样。</em>T29】</strong></p><p id="e59c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当被问及上述程序的输出时，只要它试图调用还没有被定义为该程序的函数的<code class="fe oh oi oj nx b"><strong class="kc io">greenArrow()</strong></code>，它就会在第1行抛出一个错误。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="09c8" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">关于箭头函数的主观题</strong></h1><h2 id="4749" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 1。为什么不能用带箭头的函数调用/应用/绑定？</strong></h2><p id="90df" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><code class="fe oh oi oj nx b"><strong class="kc io">Call/apply/bind</strong></code>用于将新的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文绑定到一个函数，而箭头函数严格遵循基于其词法父元素提取<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文的规则。</p><p id="4a57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">跟进问题:</strong></p><p id="2a98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如果用箭头函数写一个</strong> <code class="fe oh oi oj nx b"><strong class="kc io">call/apply/bind</strong></code> <strong class="kc io">会怎么样？它会抛出错误吗？</strong></p><p id="2d58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不会。它执行语句时没有任何错误。只是它没有将新的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文绑定到arrow函数，arrow函数仍然基于它的词法父元素维护<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文。</p><h2 id="38fb" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 2。我们能把参数绑定到一个箭头函数吗？</strong></h2><p id="d914" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">箭头函数肯定没有自己的参数对象。arguments对象允许常规函数接受动态参数。</p><p id="b2c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，在箭头函数中也有一个接受动态参数的变通方法！</p><p id="4141" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ES6中引入的传播和休息算子。</p><p id="920b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld">展开运算符:将集合的内容展开为用逗号分隔的值。</em> </strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="0ee0" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">var a = [1, 2, 3];<br/>console.log(...a); // prints 1, 2, 3</strong></span></pre><p id="1852" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ld"> Rest运算符:将逗号分隔的值组合成一个集合。</em> </strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="c12e" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">function a(...args) {<br/> console.log(args); //prints [1, 2, 3]<br/>}<br/>a(1, 2, 3);</strong></span></pre><p id="2c5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个运算符都用(…)表示，即三个点。Javascript不希望你把它处理得太多，它会尝试自己处理大部分事情！🤩</p><p id="78d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">例:</strong></p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="b4de" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gameOfThrones = () =&gt; {<br/>  return `The song of ${arguments[0]} and ${arguments[1]}`;<br/>};</strong></span><span id="04bf" class="ob lm in nx b gy og od l oe of"><strong class="nx io">console.log(gameOfThrones("ice", "fire"));</strong></span></pre><p id="9834" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码会抛出一个错误，因为<code class="fe oh oi oj nx b"><strong class="kc io">gameOfThrones</strong></code> <strong class="kc io"> </strong>这个箭头函数没有参数对象。因此，代码将在第2行抛出一个引用错误。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="e5f2" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gameOfThrones = (...args) =&gt; {<br/>   const values = [...args];<br/>   return `The song of ${values[0]} and ${values[1]}`;<br/>};</strong></span><span id="6e65" class="ob lm in nx b gy og od l oe of"><strong class="nx io">console.log(gameOfThrones("ice", "fire"));</strong></span><span id="5664" class="ob lm in nx b gy og od l oe of"><strong class="nx io">const gameOfThrones = (...args) =&gt; {<br/>  const values = [...args];<br/>  return `The ${values[0]} of ${values[1]} and ${values[2]}`;<br/>};</strong></span><span id="36b6" class="ob lm in nx b gy og od l oe of"><strong class="nx io">console.log(gameOfThrones("song", "ice", "fire"));</strong></span></pre><p id="07b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上两个例子解释了如何使用<code class="fe oh oi oj nx b"><strong class="kc io"> spread and rest operators</strong></code>将动态参数传递给arrow函数。</p><p id="0047" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您也可以使用<code class="fe oh oi oj nx b"><strong class="kc io">call/apply/bind</strong></code>和<code class="fe oh oi oj nx b"><strong class="kc io">spread and rest operators</strong></code>向arrow函数动态发送参数，即使<code class="fe oh oi oj nx b"><strong class="kc io">call/apply/bind</strong></code>不能用于向arrow函数附加新的<code class="fe oh oi oj nx b"><strong class="kc io">this</strong></code>上下文。查看下面的示例，了解如何操作。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="c6c3" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const gameOfThrones = (...args) =&gt; {<br/>  const values = [...args];<br/>  return `The ${values[0]} of ${values[1]} and ${values[2]}`;<br/>};</strong></span><span id="465d" class="ob lm in nx b gy og od l oe of"><strong class="nx io">gameOfThrones.apply(this, ["song", "ice", "fire"]);<br/>gameOfThrones.call(this, "song", "ice", "fire");</strong></span></pre><h2 id="6e4a" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 3 .我们可以使用arrow函数作为构造函数还是使用带有arrow函数的新运算符？</strong></h2><p id="fef2" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">不，我们不能。构造函数应该有一个内置的<code class="fe oh oi oj nx b"><strong class="kc io">[[Construct]]</strong></code>函数和一个附加的原型。<code class="fe oh oi oj nx b"><strong class="kc io">[[Construct]]</strong></code>函数接受在创建函数的新实例时传递的参数，原型对象允许您修改/添加函数的属性。然而，箭头功能既没有<code class="fe oh oi oj nx b"><strong class="kc io">[[Construct]]</strong></code>功能，也没有附带原型。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="f4e2" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const annabelle = (claps, haunts) =&gt; {<br/>    this.claps = claps || true;<br/>    this.haunts = haunts ||true;<br/>};<br/>anabelle.prototype.forgets = false; //Throws an error.</strong></span></pre><p id="f955" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您试图将新属性绑定到arrow函数的原型时，上面这段代码将抛出一个错误，因为arrow函数没有原型。错误说明无法设置<code class="fe oh oi oj nx b"><strong class="kc io">undefined</strong></code>的<code class="fe oh oi oj nx b"><strong class="kc io">forgets</strong></code>属性。</p><h2 id="a43b" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak">随访问题- </strong></h2><p id="af5c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="kc io">基于以上的理解，你能区分正则函数和箭头函数吗？</strong></p><p id="0366" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，您可以通过检查函数中的“原型”属性来区分常规函数和箭头函数。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="4f82" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">annabelle.hasOwnProperty(“prototype”); //returns false</strong></span></pre><h2 id="687b" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 4。箭头函数可以用作生成器函数吗？</strong></h2><p id="8e1c" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">不。箭头函数不支持yield语句，这就是为什么我们不能将它们用作生成器函数。此外，没有可用于创建生成器箭头函数的语法。虽然，有几个关于向箭头函数添加生成器功能的提议，我们可能很快就会看到。所以，敬请期待！</p><h2 id="5897" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 5。下面代码的输出会是什么？</strong></h2><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="9cb3" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const greenArrow = () <br/>  =&gt; {<br/>   return "I want peace and no war!";<br/> };</strong></span></pre><p id="e6eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码将抛出一个语法错误，因为箭头函数不能在其参数和箭头之间包含换行符。但是，如果返回值没有左括号，可以通过在左花括号或箭头后添加一个换行符来解决这个问题</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="7e54" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">//valid</strong><br/><strong class="nx io">const greenArrow = () =&gt; {<br/>   return "I want peace and no war!";<br/> };</strong></span><span id="5b27" class="ob lm in nx b gy og od l oe of"><strong class="nx io">//valid<br/>const greenArrow = () =&gt; <br/>   console.log("I want peace and no war!");<br/> </strong></span></pre><h2 id="99e9" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 6。为什么arrow函数声明会在下面的代码片段中抛出语法错误？</strong></h2><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="45de" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">let callback;<br/>callback = callback || function() {}; // ok<br/>callback = callback || () =&gt; {}; //throws syntax error</strong></span></pre><p id="8d9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为，尽管arrow函数中的arrow不是操作符，但arrow函数有特殊的解析规则，与常规函数相比，这些规则与操作符优先级的交互方式不同。因此，表达式会混淆||和= &gt;符号，从而导致错误。</p><h2 id="5531" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated">后续问题-</h2><p id="1104" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="kc io">这种情况可以解决吗？当然可以。</strong></p><p id="e3ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过在()中包含箭头函数声明，从而定义整个表达式优先于||操作符，来避免||和= &gt;之间的交互混淆。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="444b" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">let callback;<br/>callback = callback || function() {}; // ok<br/>callback = callback || (() =&gt; {}); //ok</strong></span></pre><h2 id="b459" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 7。基于对上面问题的理解，下面代码的输出会是什么？</strong></h2><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="eb24" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const winner = “Green Arrow”;<br/>function greenArrow() {<br/>  console.log(“I want peace and no war!”);<br/>}<br/>const deathStroke = () =&gt; {<br/>  console.log(“I want peace too but that comes after war!”);<br/>}</strong></span><span id="59be" class="ob lm in nx b gy og od l oe of"><strong class="nx io">const callback1 = winner || greenArrow(); // returns Green Arrow<br/>const callback2 = winner || deathStroke(); //returns Green Arrow</strong></span><span id="746c" class="ob lm in nx b gy og od l oe of"><strong class="nx io">const callback3 = greenArrow() || winner; // returns I want peace and no war!<br/>const callback4 = deathStroke() || winner; //returns I want peace too but that comes after war!</strong></span></pre><p id="de30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果箭头函数声明与另一个运算符内联编写，将会导致错误。也就是说，如果粗箭头(= &gt;)和操作符都是内联的，并且箭头声明不是一个单独的单元(用()括起来),就会出现混淆，导致语法错误。</p><h2 id="bd2c" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 8。为什么是箭头函数？它们的目的是什么？</strong></h2><p id="a602" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">既然我们已经读了这么多关于箭头函数的内容，你难道不知道这项发明的源头是哪一种特殊的需要吗？</p><p id="b905" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有人问你这个问题，显然不是期待听到一个箭头函数的定义。他们想要更多！所以你给他们更多！</p><p id="b332" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1.箭头函数可用于反复应用于项目列表的函数。这归因于arrow函数的高度直观性，因为它紧密绑定到其词法父对象的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="7130" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">const justiceLeague = ["SUPERMAN", "BATMAN", "FLASH", "GREENARROW", "WONDERWOMAN", "AQUAMAN"];</strong></span><span id="7333" class="ob lm in nx b gy og od l oe of"><strong class="nx io">const appearedMoreThanOnce = justiceLeague.filter(hero =&gt; hero !== "GREENARROW");</strong></span></pre><p id="c879" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的<code class="fe oh oi oj nx b"><strong class="kc io">filter </strong></code>函数中，外部常规函数(过滤器)在列表<code class="fe oh oi oj nx b"><strong class="kc io">justiceLeague</strong></code>上被调用。内部箭头功能与其外部常规功能<code class="fe oh oi oj nx b"><strong class="kc io">filter</strong></code>紧密耦合。由于这个原因，内部箭头函数非常容易地在<code class="fe oh oi oj nx b"><strong class="kc io">justiceLeague</strong></code>列表的条目上不断迭代，因为它不会对它所指的<code class="fe oh oi oj nx b"><strong class="kc io">this</strong></code>上下文产生混淆。</p><p id="2f7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.当处理异步代码时，使用箭头函数是非常理想的。让我们考虑下面的例子来理解这句话。</p><pre class="kz la lb lc gt nw nx ny nz aw oa bi"><span id="eb0e" class="ob lm in nx b gy oc od l oe of"><strong class="nx io">this.greenArrow.then((shoots) =&gt; {<br/> this.deathStroke(shoots);<br/>});</strong></span></pre><p id="0bf1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们有一个常规函数<code class="fe oh oi oj nx b"><strong class="kc io">greenArrow </strong></code>，它在<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>被调用——引用窗口对象。因此，常规函数的<code class="fe oh oi oj nx b"><strong class="kc io">.then</strong></code>处理程序中的回调函数现在被绑定到正确的<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文，并将在整个异步操作中保持绑定。</p><h2 id="a862" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated"><strong class="ak"> 9。何时不使用箭头功能？</strong></h2><p id="0661" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">这个我们已经讲过了，还是再来重温一下吧。</p><ol class=""><li id="64a2" class="mo mp in kc b kd ke kh ki kl mq kp mr kt ms kx po mu mv mw bi translated">当试图创建构造函数时。</li><li id="970d" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx po mu mv mw bi translated">当试图创建一个生成器函数时。</li><li id="6fdb" class="mo mp in kc b kd mx kh my kl mz kp na kt nb kx po mu mv mw bi translated">当创建深度调用链或嵌套函数时(深度超过一级)。如果处理不当，有时会很难维护“这个”上下文。</li></ol></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><h1 id="9c21" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">总结</strong></h1><p id="1de9" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">恭喜你！你有深入学习所需的耐心。跟上它，坐下来，观察它如何带你去不同的地方。😊</p><p id="0ed3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，我希望我没有冒犯任何超级英雄/哈利波特迷。本文中返回的语句和使用的函数名纯属虚构，是作者想象的产物。任何与真人、活人或死人、真实事件的相似之处纯属巧合。😆</p><h2 id="d19f" class="ob lm in bd ln ok ol dn lr om on dp lv kl oo op lz kp oq or md kt os ot mh ou bi translated">那么告诉我——是箭头函数更好还是常规函数更好？</h2><p id="35ea" class="pw-post-body-paragraph ka kb in kc b kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">没有更好的了。这两种功能都有自己的使用案例和用途。当将常规函数作为对象属性附加时，创建生成器函数，或者访问函数中的外部<code class="fe oh oi oj nx b"><strong class="kc io">this</strong></code>上下文时，应该使用常规函数。</p><p id="60f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，当您希望保持函数中<code class="fe oh oi oj nx b"><strong class="kc io">this </strong></code>上下文的神圣性，并且不希望它受到妨碍时，应该使用箭头函数，我们上面已经讨论过这种情况。</p><blockquote class="nc"><p id="f110" class="nd ne in bd nf ng nh ni nj nk nl kx dk translated">“愿最好的功能被选中！开始编码吧！”</p></blockquote><figure class="pb pc pd pe pf jo"><div class="bz fp l di"><div class="pp ph l"/></div></figure><p id="0d8f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ld">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ld">plain English . io</em></a></p></div></div>    
</body>
</html>