<html>
<head>
<title>Serverless Functions in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中的无服务器函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/serverless-function-in-next-js-3cd0d22ab983?source=collection_archive---------2-----------------------#2021-03-24">https://javascript.plainenglish.io/serverless-function-in-next-js-3cd0d22ab983?source=collection_archive---------2-----------------------#2021-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">详细了解Next.js的无服务器功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d22ae9ee2a5d7cdc7a278f58e13a080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEIjRj-29hSJsPiTap-MlA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Serverless Function banner image designed by me</figcaption></figure><p id="e71b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">js是一个可靠的react框架，带有许多内置功能，如服务器端渲染、SEO优化、动态路由等。我已经写过一篇关于构建可靠的Next.js架构的文章。此外，为了创建我们的无服务器功能，我使用了我在解释Next.js架构时已经创建的同一个存储库。</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/nerd-for-tech/building-solid-next-js-architecture-a8c6702dc67d" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">构建可靠的下一代JS架构</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">为react应用程序构建可靠的Next JS架构。</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi kp lu"/></div></div></a></div><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="c6da" class="mo mp iq mk b gy mq mr l ms mt"><strong class="mk ir">Repository =&gt; </strong><a class="ae mu" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/NextJSArchitecture" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/MaterialUIInstallationWithNextJS</a></span></pre><h1 id="10bd" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated"><strong class="ak">无服务器功能</strong></h1><p id="a057" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">顾名思义，它们是JavaScript函数，帮助发出HTTP请求并发送响应。无服务器功能带来了用户认证、表单提交等好处。</p><h1 id="e19e" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">执行</h1><p id="ea60" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">每个无服务器函数都是一个JavaScript函数，有两个参数，一个写为“req”的请求和一个写为“res”的响应。如果你熟悉Node JS的Express框架，那么你可以像在<strong class="kx ir">控制器</strong>中定义一个简单的API一样模仿它。接受请求并在服务器上返回响应，但不在任何服务器上托管的函数基本上是一个无服务器函数。</p><p id="f25a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.js为编写无服务器函数提供了内置支持。在pages目录中，您必须创建一个名为“api”的文件夹。该文件夹包含文件，每个文件名都是无服务器功能的端点。例如，我们的文件夹结构如下所示-</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="e7ff" class="mo mp iq mk b gy mq mr l ms mt">-pages<br/> -api<br/>  -- getUsers.js  </span></pre><p id="2093" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的“<strong class="kx ir"><em class="nr">getUser</em></strong><em class="nr">”</em>将成为我们的无服务器函数的端点，认为你的无服务器函数本身就是一个API。它将接受一个请求对象并返回一个响应，所以在我们的无服务器功能中，我们可以连接我们的数据库，我们可以进行用户验证，表单提交等等。默认情况下，每个无服务器函数都需要导出，并且必须从每个无服务器函数返回一个响应，否则服务器将陷入未处理的承诺拒绝，这意味着没有来自服务器的响应，函数将无限期地继续执行。</p><h2 id="a60d" class="mo mp iq bd mw ns nt dn na nu nv dp ne le nw nx ng li ny nz ni lm oa ob nk oc bi translated"><strong class="ak">编写我们的基本无服务器功能</strong></h2><p id="8412" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">我正在使用一个来自JSON占位符的示例GET API，并将尝试使用我们的无服务器函数获取这些数据。我将添加从这个示例API获取单个用户数据，如果基于一个“键”进行过滤，则该单个用户数据，该键将从无服务器函数的请求对象的查询参数中获取。</p><p id="7112" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这听起来可能很难，但执行起来非常简单，以此为例。我们的API端点应该是这样的。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="6776" class="mo mp iq mk b gy mq mr l ms mt"><strong class="mk ir">API =&gt; </strong><a class="ae mu" href="http://localhost:3000/api/getSingleUser?id=1" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">https://www.localhost:3000/api/getSingleUser?id=1 </strong></a></span></pre><p id="a3f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据API，我们的无服务器函数应该有一个文件名，这里的API名称是“<strong class="kx ir"> getSingleUser </strong>”。接下来，我们有一个端点查询参数，即<strong class="kx ir">“id”</strong>。使用这两个理解值，我们将编写我们的第一个无服务器函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/57bd8c1a15983bd8db4290327d03b6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U2w9lEZDnmCn1GORfJSZQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our First Serverless Function</figcaption></figure><p id="76a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在附图中，左侧面板是文件夹结构，右侧面板由一个简单的函数组成，该函数将文本作为响应返回。</p><blockquote class="oe of og"><p id="0f2a" class="kv kw nr kx b ky kz jr la lb lc ju ld oh lf lg lh oi lj lk ll oj ln lo lp lq ij bi translated">请不要将文件夹“api”的名称更改为其他名称。</p></blockquote><p id="7ab0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了在本地服务器上查看无服务器功能的响应，请在google chrome上访问以下端点。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="a3c1" class="mo mp iq mk b gy mq mr l ms mt"><strong class="mk ir">API =&gt; </strong><a class="ae mu" href="http://localhost:3000/api/getSingleUser?id=1" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">https://www.localhost:3000/api/getSingleUser?id=1</strong></a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/0232f927bab55a1b55d49a10736bab96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENnjvXP1C-_iI9uJPwYrJQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Serverless function on our localhost</figcaption></figure></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="d26c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用示例GET API获取用户列表。我们将使用的API如下所示-</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="729d" class="mo mp iq mk b gy mq mr l ms mt"><strong class="mk ir">Sample GET API =&gt; </strong><a class="ae mu" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a></span></pre><p id="2f78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的议程是获取所有用户的列表，然后使用我们的<strong class="kx ir">“id”</strong>作为查询参数，然后从一组用户中过滤出一个用户，并返回该用户以响应我们的无服务器函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/e39db6737b1f41a9a5d190b629d7de2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ld5UT273NIb3bNLL7sjaA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">singleUser.js</figcaption></figure><p id="9c54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用<a class="ot ou ep" href="https://medium.com/u/5e0bd5d0161a?source=post_page-----3cd0d22ab983--------------------------------" rel="noopener" target="_blank"> Axios </a>从示例GET API中获取所有用户的列表。然后使用我们的<strong class="kx ir">“id”</strong>作为过滤参数过滤单个用户，从请求对象的查询中获取单个用户，并响应我们的无服务器函数发送该数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/8772bec3f459d1ad8a78201d380b18ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WohLHdHTxR5pJJzeJUlUQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Response object from first Serverless Function</figcaption></figure><p id="ab2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您可以将此端点视为单个API，我们可以在任何组件的前端使用此端点来获取单个用户的数据。<br/>在任何组件中，我们只需要使用axios或fetch方法发出API请求，并传递单个“<strong class="kx ir">id”</strong>作为查询，axios请求方法中的响应对象就是您在localhost上的上图中看到的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/e30f6cb4a5acee05da38bf841332a302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeuxuolr8CY6lPP7S4Wu9w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Index.js</figcaption></figure><p id="8541" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的根应用程序的App组件使用我们的无服务器函数获取单个用户数据。在这里，我们可以选择直接将API端点中的id给axios，或者我们也可以有一个动态端点。</p><p id="4500" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="nr">注意</em> </strong> <em class="nr">:我们只是使用“</em><strong class="kx ir"><em class="nr">/api/single user”</em></strong><em class="nr">作为API端点，</em><strong class="kx ir"><em class="nr"/></strong><em class="nr">next . js内置自动检测这个无服务器函数已经托管的当前域名。</em></p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/d76a613acd21653648bf06ab0b1440f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsTEPaSgGeQrpSjgFwuwLQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Localhost console in Chrome Inspect</figcaption></figure><h1 id="cdc7" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">最终产品</h1><p id="b592" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">我添加了一个输入，从客户端获取用户id。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/bb49f17dddf9c191c37b5f822ca16f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asf1oAxO8IIkvvV-E6nECw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">User data with user id as 1</figcaption></figure><h1 id="624d" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">结论</h1><p id="5c75" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">在使用端点而不将它们部署在独立服务器上的情况下，无服务器功能非常有用。联系我们的形式，用户认证都可以使用这些功能。我已经使用了一个无服务器的功能来访问Twitter的npm包的前端使用Twitter的API。<br/>无服务器功能的其他好处是您不需要处理CORS策略，因为我们从一台服务器向另一台服务器发出API请求。</p><p id="c926" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">直到，下一次，有一个美好的一天，人们。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="f4d2" class="mo mp iq mk b gy mq mr l ms mt"><strong class="mk ir">Code Sample =&gt; </strong><a class="ae mu" href="https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/ServerlessFunction" rel="noopener ugc nofollow" target="_blank">https://github.com/shreyvijayvargiya/iHateReadingLogs/tree/main/TechLogs/ServerlessFunction</a></span></pre></div></div>    
</body>
</html>