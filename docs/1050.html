<html>
<head>
<title>How Closures Work in JavaScript: A Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中闭包如何工作:指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/closures-in-javascript-37182198dc20?source=collection_archive---------5-----------------------#2021-03-05">https://javascript.plainenglish.io/closures-in-javascript-37182198dc20?source=collection_archive---------5-----------------------#2021-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7040" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">词法范围、范围链、优点和缺点</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/178e836f873dd92f89731fa3f5211abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ6KGdWrdNDIacOftkcIMA.png"/></div></div></figure><blockquote class="ko"><p id="c892" class="kp kq in bd kr ks kt ku kv kw kx ky dk translated">一个<strong class="ak">闭包</strong>是一个函数的组合，该函数被捆绑在一起(被封闭)并引用其周围的状态(即<strong class="ak">词法环境</strong>)。</p></blockquote><p id="f805" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt ky ig bi translated">换句话说，闭包让你从内部函数访问外部函数的作用域。在JavaScript中，闭包是在每次创建函数时创建的。</p><h1 id="3615" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">词法范围</h1><p id="e6da" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">考虑下面的示例代码:</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="e3b6" class="mw lv in ms b gy mx my l mz na">function outer() {<br/>    var a = 5;<br/>    function inner(){<br/>        console.log(a);<br/>    }<br/>    inner();<br/>}</span><span id="273c" class="mw lv in ms b gy nb my l mz na">outer(); //5</span></pre><p id="fe0a" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这里，<code class="fe nh ni nj ms b">outer()</code>创建了一个名为<code class="fe nh ni nj ms b">a</code>的局部变量和一个名为<code class="fe nh ni nj ms b">inner()</code>的函数。<code class="fe nh ni nj ms b">inner()</code>函数是定义在<code class="fe nh ni nj ms b">outer()</code>内部的内部函数，并且只在<code class="fe nh ni nj ms b">outer()</code>函数体内可用。注意<code class="fe nh ni nj ms b">inner()</code>函数没有自己的局部变量。但是，由于内部函数可以访问外部函数的变量，<code class="fe nh ni nj ms b">inner()</code>可以访问父函数<code class="fe nh ni nj ms b">outer()</code>中声明的变量<code class="fe nh ni nj ms b">a</code>。</p><p id="324f" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">注意，<code class="fe nh ni nj ms b">inner()</code>函数中的<code class="fe nh ni nj ms b">console</code>语句成功地显示了<code class="fe nh ni nj ms b">a</code>变量的值，该值是在其父函数中声明的。这是一个<em class="nk">词法</em> <em class="nk">作用域</em>的例子，描述了当函数嵌套时解析器如何解析变量名。单词<em class="nk">词法</em>指的是词法作用域使用变量在源代码中声明的位置来确定该变量在哪里可用。嵌套函数可以访问在其外部作用域中声明的变量。</p><p id="521f" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">基本上在这里，<code class="fe nh ni nj ms b">inner()</code>是和它的词法环境<code class="fe nh ni nj ms b">outer()</code>捆绑在一起的。第一，<code class="fe nh ni nj ms b">inner()</code>将检查其局部范围；如果它没有找到<code class="fe nh ni nj ms b">a</code>，它将转到父词法。所以在<code class="fe nh ni nj ms b">inner()</code>内部，它与outer词法范围内的变量形成了一个闭包，即<code class="fe nh ni nj ms b">inner()</code>被绑定到了<code class="fe nh ni nj ms b">outer</code>的变量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/c25759158c9d1e22b1ca320c6358c4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqtEigIKTc2B2GZbYf26rA.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/3af4c384f30964b20092f0b31db91162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgJDPOW-e39V-ZzTl2F2gA.png"/></div></div></figure><ul class=""><li id="5bad" class="nn no in lb b lc nc lf nd li np lm nq lq nr ky ns nt nu nv bi translated">当函数从另一个函数返回时，它们仍然保持它们的词法范围，也就是说，它们记得它们实际出现的位置。</li></ul><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="1a37" class="mw lv in ms b gy mx my l mz na">function outer() {<br/>    var a = 5;<br/>    function inner(){<br/>        console.log(a);<br/>    }<br/>    return inner;<br/>}</span><span id="f8cc" class="mw lv in ms b gy nb my l mz na">var x = outer();<br/>x(); //5</span><span id="0532" class="mw lv in ms b gy nb my l mz na">outer()() //5</span></pre><p id="4dea" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">然而在这里，<code class="fe nh ni nj ms b">outer</code>不再存在了。然而，<code class="fe nh ni nj ms b">inner()</code>记住了它的词法范围，也就是说，当我们返回<code class="fe nh ni nj ms b">inner()</code>时，不仅返回了函数代码，还返回了闭包(函数和词法范围)。</p><ul class=""><li id="4202" class="nn no in lb b lc nc lf nd li np lm nq lq nr ky ns nt nu nv bi translated">闭包的一个重要特征是它在多次调用之间保持外部变量的状态。内部函数不包含变量的单独副本，它只保留外部变量的引用。</li></ul><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="30e9" class="mw lv in ms b gy mx my l mz na">function outer() {<br/>    var a = 5;<br/>    function inner(){<br/>        console.log(a);<br/>    }<br/>    a = 100;<br/>    return inner;<br/>}<br/>var x= outer();<br/>x(); //100</span></pre><p id="6ba8" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这里<code class="fe nh ni nj ms b">inner()</code>也将伴随着它的词法范围而来，也就是说<code class="fe nh ni nj ms b">a</code>将不会引用值，而是引用它的引用。</p><ul class=""><li id="050b" class="nn no in lb b lc nc lf nd li np lm nq lq nr ky ns nt nu nv bi translated">如果我们将局部变量声明改为<code class="fe nh ni nj ms b">let</code>，如果我们在<code class="fe nh ni nj ms b">outer()</code>中传递一个额外的参数<code class="fe nh ni nj ms b">b</code>，在这两种情况下，内部函数仍然形成一个闭包。因为<code class="fe nh ni nj ms b">b</code>也是内部功能的外部环境的一部分。</li></ul><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="56d4" class="mw lv in ms b gy mx my l mz na">function outer(b) {<br/>    function inner(){<br/>        console.log(a,b);<br/>    }<br/>    let a = 50;<br/>    return inner;<br/>}<br/>var x= outer('Hello');<br/>x(); //50 "Hello"</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="219f" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">闭包作用域链</h1><p id="7c54" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">每个闭包有三个作用域:</p><ul class=""><li id="41d4" class="nn no in lb b lc nc lf nd li np lm nq lq nr ky ns nt nu nv bi translated">本地范围(自己的范围)</li><li id="2d49" class="nn no in lb b lc ny lf nz li oa lm ob lq oc ky ns nt nu nv bi translated">外部功能范围</li><li id="200c" class="nn no in lb b lc ny lf nz li oa lm ob lq oc ky ns nt nu nv bi translated">全球范围</li></ul><p id="e4cd" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">为了进行演示，请考虑以下示例代码:</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="a56a" class="mw lv in ms b gy mx my l mz na">// global scope<br/>var e = 10;<br/>function sum(a){<br/>  return function(b){<br/>    return function(c){<br/>      // outer functions scope<br/>      return function(d){<br/>        // local scope<br/>        return a + b + c + d + e;<br/>      }<br/>    }<br/>  }<br/>}<br/><br/>console.log(sum(1)(2)(3)(4)); // log 20</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/8224b156bcb2437258d2c1611761c86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCaZ4gt5ie70g_dITtQ1OA.png"/></div></div></figure><ul class=""><li id="9f8b" class="nn no in lb b lc nc lf nd li np lm nq lq nr ky ns nt nu nv bi translated">现在，如果我们有一个名称冲突的全局变量，即相同的变量名<code class="fe nh ni nj ms b">a</code>出现在全局变量和外部函数中。那么在这种情况下，将返回inner <code class="fe nh ni nj ms b">a</code>或其他函数作用域<code class="fe nh ni nj ms b">a</code>的值。而全局<code class="fe nh ni nj ms b">a</code>是全局范围内全新的变量。所以这两个<code class="fe nh ni nj ms b">a</code>变量是完全不同的。这里的<code class="fe nh ni nj ms b">a</code>是存在于外部环境中的，如果它不存在那么它就会全局<code class="fe nh ni nj ms b">a</code>。</li></ul><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="7698" class="mw lv in ms b gy mx my l mz na">var a = 10;<br/>function sum(){<br/>  var a = 1;<br/>  return function(b){<br/>    return function(c){<br/>        return a + b + c;<br/>    }<br/>  }<br/>}</span><span id="e11b" class="mw lv in ms b gy nb my l mz na">console.log(sum()(2)(3)); <br/>//6 (1+2+3)</span><span id="b017" class="mw lv in ms b gy nb my l mz na">var a = 10;<br/>function sum(){<br/>  //var a = 1;<br/>  return function(b){<br/>    return function(c){<br/>        return a + b + c;<br/>    }<br/>  }<br/>}<br/>console.log(sum()(2)(3));<br/>//15 (10+2+3)</span></pre><h1 id="a420" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">闭包的优点</h1><h2 id="a596" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 1)使用私有变量和方法</strong></h2><p id="f62e" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">Java之类的语言提供了将方法声明为私有的能力，这意味着它们只能被同一个类中的其他方法调用。JavaScript没有提供这样做的本地方式，但是可以使用闭包来模拟私有变量和方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="cb49" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 2)数据隐藏和封装</strong></h2><p id="95b3" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">闭包通过创建私有变量使数据隐藏成为可能，也就是说，其他函数或代码片段将无法访问特定的数据。我们可以说我们可以封装数据，这样程序的其他部分就不能访问它。让我们借助一个例子来理解这一点:</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="f566" class="mw lv in ms b gy mx my l mz na">function counter(){<br/>    let count = 0;<br/>    <br/>    return function incrementCounter(){<br/>      count++;<br/>      console.log(count);<br/>    }<br/>}</span><span id="4b12" class="mw lv in ms b gy nb my l mz na">console.log(count); // Uncaught ReferenceError: count is not defined</span><span id="92ed" class="mw lv in ms b gy nb my l mz na">var counter1 = counter();<br/>counter1(); //1<br/>counter1(); //2</span><span id="4c13" class="mw lv in ms b gy nb my l mz na">var counter2 = counter();<br/>counter2(); //1<br/>counter2(); //2<br/>counter2(); //3</span></pre><p id="5f9a" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这里，<code class="fe nh ni nj ms b">count</code>变量是私有的或隐藏的，在计数器函数之外是不可访问的。<code class="fe nh ni nj ms b">counter1</code>和<code class="fe nh ni nj ms b">counter2</code>完全是不同范围的变量。</p><p id="09fc" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">现在，如果我们想添加递减计数器，那么好的和可伸缩的方法是创建函数构造函数。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="8d08" class="mw lv in ms b gy mx my l mz na">function Counter(){<br/>    let count = 0;<br/>    <br/>    this.incrementCounter = function(){<br/>      count++;<br/>      console.log(count);<br/>    }<br/>    this.decrementCounter  = function(){<br/>      count--;<br/>      console.log(count);<br/>    }<br/>}</span><span id="69ab" class="mw lv in ms b gy nb my l mz na">var counter1 = new Counter(); </span><span id="2a1a" class="mw lv in ms b gy nb my l mz na">counter1.incrementCounter(); //1<br/>counter1.incrementCounter(); //2</span><span id="a016" class="mw lv in ms b gy nb my l mz na">counter1.decrementCounter(); //1</span></pre><h2 id="ee45" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 3)功能匹配</strong></h2><p id="a316" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">闭包使得JavaScript中的currying成为可能。Currying是一种使用函数的高级技术。Currying是一种函数转换，它将一个函数从可调用的as <code class="fe nh ni nj ms b">f(a, b, c)</code>转换成可调用的as <code class="fe nh ni nj ms b">f(a)(b)(c)</code>。当你把一个有多个参数的函数分解成一系列只有一个参数的函数。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="764a" class="mw lv in ms b gy mx my l mz na">function add (a, b) {<br/>  return a + b;<br/>}</span><span id="926c" class="mw lv in ms b gy nb my l mz na">add(3, 4); // returns 7</span></pre><p id="4c8d" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这个函数有两个参数，a和b，并返回它们的和。我们现在将搜索这个函数:</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="b164" class="mw lv in ms b gy mx my l mz na">function add (a) {<br/>  return function (b) {<br/>    return a + b;<br/>  }<br/>}</span></pre><p id="3baf" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这是一个接受一个参数a的函数，返回一个接受另一个参数b的函数，这个函数返回它的和。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="6b08" class="mw lv in ms b gy mx my l mz na">add(3)(4); //7<br/>var add3 = add(3);<br/>add3(4);  //7</span></pre><p id="976f" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">第一条语句返回7，类似于add(3，4)语句。第二条语句定义了一个名为add3的新函数，它将把3添加到它的参数中。这就是一些人所说的终结。第三条语句使用add3运算将3加到4，结果还是7。</p><p id="6b13" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">更多细节请参考— <a class="ae op" href="https://ayushv.medium.com/javascript-currying-comprehensive-guide-e69c47497309" rel="noopener"> <strong class="lb io"> JavaScript Currying:综合指南</strong> </a></p><h2 id="928c" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 4)函数工厂</strong></h2><p id="1549" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">闭包的一个强大用途是使用外部函数作为工厂来创建以某种方式相关的函数。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="d2a9" class="mw lv in ms b gy mx my l mz na">function Job(title) {<br/>    return function(prefix) {<br/>        return prefix + ' ' + title;<br/>    };<br/>}</span><span id="c7c6" class="mw lv in ms b gy nb my l mz na">var sales = Job('Salesman');<br/>var manager = Job('Manager');</span><span id="d978" class="mw lv in ms b gy nb my l mz na">alert(sales('Top'));  // Top Salesman<br/>alert(manager('Assistant to the Regional')); // Assistant to the Regional Manager<br/>alert(manager('Regional')); // Regional Manager</span></pre><p id="1c6e" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">使用闭包作为函数工厂是保持JavaScript干爽的好方法。五行强大的代码允许我们创建任意数量的具有相似但独特目的的函数。</p><h2 id="b39b" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 5)仅运行一次功能</strong></h2><p id="5869" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">函数通过形成一个闭包来记住函数已经运行了多少次。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="da2e" class="mw lv in ms b gy mx my l mz na">var something = (function() {<br/>    var executed = false;<br/>    return function() {<br/>        if (!executed) {<br/>            executed = true;<br/>            console.log("do something");<br/>        }<br/>    };<br/>})();</span><span id="703f" class="mw lv in ms b gy nb my l mz na">something(); // "do something" happens<br/>something(); // nothing happens</span></pre><h2 id="64e8" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 6)设置超时</strong></h2><p id="4c89" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated"><strong class="lb io"> </strong>是一个<strong class="lb io"> </strong>方法，在指定的毫秒数后调用一个函数或计算一个表达式。</p><pre class="kd ke kf kg gt mr ms mt mu aw mv bi"><span id="3b80" class="mw lv in ms b gy mx my l mz na">function x(){<br/>   var i = 1;<br/>   setTimeout(function(){<br/>       console.log(i)<br/>   },3000)<br/>   console.log(“After setTimeout”)<br/>}</span><span id="a4eb" class="mw lv in ms b gy nb my l mz na">x();<br/>//After setTimeout<br/>// 1 (after 3 sec)</span></pre><p id="8a94" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">这里，setTimeout中的函数形成了一个闭包。所以这个函数记住了对“我”的引用。所以无论这个函数去哪里，它都会带着“I”的值。setTimeout获取一个回调函数，并将其存储在某个地方，然后为其附加一个计时器。一旦计时器超时，它将获取函数并将其放入当前调用堆栈，然后运行它。</p><h2 id="84bb" class="mw lv in bd lw oe of dn ma og oh dp me li oi oj mg lm ok ol mi lq om on mk oo bi translated"><strong class="ak"> 7)记忆化</strong></h2><p id="d1f8" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">记忆化是使长递归/迭代函数运行得更快的编程实践。这里也使用了闭包。下面是一个基本<code class="fe nh ni nj ms b">memoize</code>函数的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8837" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">8)闭包也用于在异步世界、迭代器和模块设计模式中维护状态。</p><h1 id="30b2" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated"><strong class="ak">关闭的弊端</strong></h1><ul class=""><li id="d304" class="nn no in lb b lc mm lf mn li oq lm or lq os ky ns nt nu nv bi translated">闭包防止函数内部的变量被内存释放，也就是说，只要闭包是活动的，内存就不能被垃圾收集。这些变量会占用内存，消耗大量内存，可能导致<strong class="lb io">内存泄漏。</strong>这个问题的解决方案是在不使用局部变量时及时删除所有不必要的局部变量，即设置闭包为空。</li><li id="38f8" class="nn no in lb b lc ny lf nz li oa lm ob lq oc ky ns nt nu nv bi translated">在函数中创建函数会导致内存重复，并导致应用程序的<strong class="lb io">变慢。这个问题的解决方案是只在需要隐私的时候使用闭包。否则，使用模块模式创建具有共享方法的新对象。</strong></li></ul><h1 id="9fd9" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">结论</h1><p id="e803" class="pw-post-body-paragraph kz la in lb b lc mm jo le lf mn jr lh li mo lk ll lm mp lo lp lq mq ls lt ky ig bi translated">希望这能让您对JavaScript中的闭包概念感觉更舒服一些。</p><p id="b624" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated">感谢您的阅读:)</p><p id="3b5f" class="pw-post-body-paragraph kz la in lb b lc nc jo le lf nd jr lh li ne lk ll lm nf lo lp lq ng ls lt ky ig bi translated"><em class="nk">更多内容尽在</em><a class="ae op" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nk">plain English . io</em></a></p></div></div>    
</body>
</html>