<html>
<head>
<title>How to Get the Name of a JavaScript Object’s Type?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获取一个JavaScript对象的类型名？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-get-the-name-of-a-javascript-objects-type-5b75cf1444db?source=collection_archive---------3-----------------------#2021-09-26">https://javascript.plainenglish.io/how-to-get-the-name-of-a-javascript-objects-type-5b75cf1444db?source=collection_archive---------3-----------------------#2021-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72b6939f7077c7c90b480609de46d4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d2ZmBN-UYg9AJoJJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Mossholder</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7fa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取创建对象的构造函数的名字是我们有时不得不做的事情。</p><p id="9255" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何获取创建JavaScript对象的构造函数的名称。</p><h1 id="70a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数属性</h1><p id="d5f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用对象的<code class="fe me mf mg mh b">constructor</code>属性来获取创建它的构造函数。</p><p id="8876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c60" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>console.log(arr.constructor === Array);</span></pre><p id="3871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志记录<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">arr</code>是用<code class="fe me mf mg mh b">Array</code>构造函数创建的。</p><p id="c1c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也可以用于我们自己创建的构造函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0d05" class="mq lc iq mh b gy mr ms l mt mu">class A {}<br/>const a = new A()<br/>console.log(a.constructor === A);</span></pre><p id="dbdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台日志也会记录<code class="fe me mf mg mh b">true</code>。</p><h1 id="d68b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">遗产</h1><p id="5980" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们从一个子类创建一个对象，那么我们可以检查一个从当前子类创建的对象。</p><p id="d4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e9c4" class="mq lc iq mh b gy mr ms l mt mu">class A {}<br/>class B extends A {}<br/>const b = new B()<br/>console.log(b.constructor === B);</span></pre><p id="98f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志也会记录<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">b</code>是从<code class="fe me mf mg mh b">B</code>构造函数创建的。</p><p id="36d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">constructor</code>拥有<code class="fe me mf mg mh b">name</code>属性来获取字符串形式的构造函数名。</p><p id="af76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd77" class="mq lc iq mh b gy mr ms l mt mu">class A {}<br/>const a = new A()<br/>console.log(a.constructor.name === 'A');</span></pre><p id="e493" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与构造函数的名称进行比较。</p><h1 id="9be7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运算符的实例</h1><p id="3d1f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符还让我们检查一个对象是否是从构造函数中创建的。</p><p id="fe3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a6a9" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>console.log(arr instanceof Array);</span></pre><p id="5732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么控制台日志应该记录<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">arr</code>是一个数组。</p><p id="6478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，<code class="fe me mf mg mh b">Array.isArray</code>在检查变量是否为数组时更可靠，因为它适用于所有帧。</p><p id="ff07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6359" class="mq lc iq mh b gy mr ms l mt mu">class A {}<br/>const a = new A()<br/>console.log(a instanceof A);</span></pre><p id="2dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查<code class="fe me mf mg mh b">a</code>是否是<code class="fe me mf mg mh b">A</code>的实例。</p><p id="45c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>也适用于子类。</p><p id="4769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8c38" class="mq lc iq mh b gy mr ms l mt mu">class A {}<br/>class B extends A {}<br/>const b = new B()<br/>console.log(b instanceof B);</span></pre><p id="c850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且会记录<code class="fe me mf mg mh b">true</code>。</p><h1 id="48d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d274" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">instanceof</code>操作符和<code class="fe me mf mg mh b">constructor</code>属性来检查一个对象是否是从给定的构造函数中创建的。</p><p id="3a47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">更多内容请看</em><a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>