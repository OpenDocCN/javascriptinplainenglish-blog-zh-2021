<html>
<head>
<title>Double Your Income as a JavaScript/TypeScript Developer Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在，作为一名JavaScript/TypeScript开发人员，您的收入将翻倍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/double-your-income-as-a-javascript-typescript-developer-today-933d6fc5337e?source=collection_archive---------0-----------------------#2021-11-17">https://javascript.plainenglish.io/double-your-income-as-a-javascript-typescript-developer-today-933d6fc5337e?source=collection_archive---------0-----------------------#2021-11-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5615ecc1f06988fbfbe0aeade8b20983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00MueRD-Dv3jbVE1YHBsUA.png"/></div></div></figure><h1 id="b7b1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">最好的开发人员得到的报酬比一般人多</h1><p id="035c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你是一个靠写JavaScript/TypeScript代码挣钱的职业开发者，那么这篇文章将向你展示如何让你的收入翻倍。</p><p id="58aa" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这个想法很简单:最好的开发人员比一般的开发人员获得更多的报酬。要做到最好，你需要快速交付没有错误的复杂质量特性，并教会其他同事如何做。</p><p id="c73b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你可以随时关闭这篇文章，但请听我说完:</p><ul class=""><li id="69bd" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">如果你能在一天内完成整个脸书，你就是开发者之神。企业会乞求你为他们工作。你将击败竞争对手，变得异常富有</li><li id="5db2" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如果你能在100年内完成一个完整的脸书——你是一个平庸的开发者。你需要说服企业雇佣你。你的薪水很一般</li></ul><p id="d381" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">今天你可以做一个重要的选择:你想变得更快，还是更喜欢保持缓慢？</p><p id="b97a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在本文中，我将向您展示如何比其他90%的开发人员变得更快，并获得双倍的高薪。</p><p id="f936" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在过去的15年里，我一直从事软件开发和团队领导的工作。从低级的<em class="mk"> XOR EAX，EAX </em>到<em class="mk"> monadic ( &gt; &gt; =) </em>，我都和多种语言合作过。从OOP到FP。有<a class="ae ml" href="https://www.youtube.com/watch?v=Tn6-PIqc4UM" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae ml" href="https://www.youtube.com/watch?v=eIQh02xuVw4" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>、<a class="ae ml" href="https://www.youtube.com/watch?v=W_VV2Fx32_Y" rel="noopener ugc nofollow" target="_blank"> Serverless </a>、<a class="ae ml" href="https://www.youtube.com/watch?v=Gjnup-PuquQ" rel="noopener ugc nofollow" target="_blank"> Docker </a>、CI/CD、<a class="ae ml" href="https://www.youtube.com/watch?v=tomUWcQ0P3k" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae ml" href="https://www.youtube.com/watch?v=kdvVwGrV7ec" rel="noopener ugc nofollow" target="_blank"> Solidity </a>等等，应有尽有。</p><p id="e8a1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">甚至现在我还在用<a class="ae ml" href="https://copilot.github.com/" rel="noopener ugc nofollow" target="_blank"> Github Copilot </a>在Webstorm的60%机械键盘上用VIM布局写这篇文章(写的不好但是js写的让人毛骨悚然)。</p><p id="62b8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我想说的是，15年来，我看到并尝试了很多东西。经过15年的努力，你会开始发现为什么人们努力写代码，为什么他们效率如此之低，速度如此之慢。</p><p id="4fec" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">今天我想免费教你如何变得比90%的开发者更优秀。这篇文章只写给关心钱的职业开发者。如果你是一个初学者，如果你为了乐趣或者作为一种爱好而编程，你可以跳过这篇文章，因为你没有理由这么快。</p><p id="30cd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">简单的想法:<br/>优质快速的特点交付→击败竞争对手→从大企业获得更多资金。</p><p id="3670" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">准备好了吗？让我告诉你如何成为最好的。</p><h1 id="7029" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">要成为最好的，你需要快。为了更快，你需要避免过度设计。</h1><blockquote class="mm mn mo"><p id="47d3" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">过度工程化是聪明人的病。你越聪明，你就越能自掘坟墓。</p></blockquote><p id="52e0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">我想对你的工作做一个大胆的声明。</strong>你的代码至少有一半是过度工程化的，没有为你的终端客户提供任何价值。它消耗了你一半的时间和一半的资源，却没有为你的最终客户创造任何价值。</p><p id="2036" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你对我所说的不感兴趣，你可以关闭这篇文章。没什么丢人的。但是如果你留下来，你会从新的角度看到你的代码。</p><p id="81f1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">过度工程化是聪明人的病。普通人会写一个大的不可读的函数，它被定位在一个文件中。但是你，我的朋友，可以创建成千上万的结构化混乱的文件。文件、控制器、适配器、类型、函数、配置、管道、容器、数据库、模式、层、接口，等等。</p><p id="88d3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我打赌你会说:<em class="mk">没门，阿列克谢，我不是工程过度！我将一切分离，以支持未来的扩展业务需求。我需要这个强大复杂的工具，因为我预计下个月/年/十年将有100万用户。</em></p><p id="80b4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">是的，可以这样。但是你真的想知道吗？</p><p id="e816" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我处在你的位置。我过度设计了很多。我知道那种感觉。<strong class="kv io">感觉自己做的是对的</strong>。</p><p id="168a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您的过度工程化来自于解决您当前需求中尚不存在的未来问题。您今天试图解决未来的可伸缩性/可扩展性问题。您尝试在业务开展之前预测未来的业务需求。</p><p id="65cc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你生活在对未来的恐惧中。您担心未来的项目变更会彻底破坏某些东西。你试图不惜一切代价避免未来的伤害。讽刺的是你在挖自己的坟墓。</p><p id="3898" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您使用复杂而强大的工具来完成简单的工作。这些工具让你感到高效、聪明和安全，因为你写了很多复杂的代码，但它们让你慢下来，并告诉你营销谎言。</p><p id="d077" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">缓慢的功能交付→平庸的职业生涯→平庸的薪酬。这是大多数人走的平庸之路。你想知道不同的路径吗？</p><p id="4efa" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">过度工程的来源主要有两种:</p><ol class=""><li id="11fc" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">过度使用的良好实践。棘手的是好的实践确实有用。他们为项目提供价值。但是你过度使用了它们</li><li id="60a0" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">对你的工作来说太复杂的工具。<br/>棘手的是复杂的工具确实有用。他们确实为项目提供了价值。但不是为了你的项目。复杂的工具有很大的代码/学习成本，但它们非常小众</li></ol><p id="fe78" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">几个过度使用的良好实践会让你慢下来的例子:</p><ul class=""><li id="bf6e" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">干燥原理</li><li id="e5e3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">坚实的原则</li><li id="0e81" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">依赖注入</li><li id="8675" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">类型安全</li><li id="58ac" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">函数式编程</li><li id="ed74" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">面向对象的程序设计(Object Oriented Programming)</li><li id="387e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">测试</li><li id="0013" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">提取抽象概念</li><li id="edc6" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">将代码分割成更小的部分函数/类/组件/文件</li></ul><p id="b1b3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">几个过度使用的工具让你慢下来的例子:</p><ul class=""><li id="bea4" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">以打字打的文件</li><li id="d164" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">类似红杉/猫鼬的ORM</li><li id="5304" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">GraphQL</li><li id="a9e6" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">MongoDB</li><li id="b015" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">Redux</li><li id="46d6" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">Knex之类的查询构建器</li><li id="d3d8" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">库伯内特斯</li><li id="a5e7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">玩笑</li><li id="3eb3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">将（行星）地球化（以适合人类居住）</li><li id="f5c4" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">反应钩形/成形</li><li id="0f08" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">总体上对受控输入做出反应</li><li id="56d0" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">无服务器环境</li><li id="5554" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">授权/身份验证的自定义实现</li><li id="3367" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">微服务架构</li></ul><p id="d848" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你现在应该感到个人受到了冒犯，因为我列举了你使用的几种工具和你喜欢的几种做法。这是完全正常的反应。深呼吸，慢慢呼出。<strong class="kv io">我会给你看一些能让你比其他90%的开发者更优秀的东西</strong>，值得你付出情感上的痛苦。</p><p id="4a7f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">棘手的部分是复杂的工具和良好的实践确实有用。他们确实为项目提供了价值。但是它们带来了90%的开发人员倾向于忽略的过度工程成本。</p><p id="81e3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我将向您展示如何减少代码中的过度工程。这将最终使你的代码小10倍。</p><p id="b434" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">更少的代码→更快的特性交付→更多的钱。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0eef63e5528632d766c187973c9893e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*CJVDG8IecpOoDGde-AqTmQ.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Our enemy is over-engineering.</figcaption></figure><h1 id="2bb6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是过度工程化？</h1><blockquote class="mm mn mo"><p id="dbf8" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">三年前，我想在互联网上发表一篇文章，所以我和GraphQL以及<a class="ae ml" href="https://www.youtube.com/watch?v=GuvAMcsoreI" rel="noopener ugc nofollow" target="_blank">盖茨比</a>一起写了一个博客来发表这篇文章。花了一个月。</p></blockquote><p id="384b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在我们消灭过度工程之前，我们需要理解什么是过度工程。过度工程是您编写的代码，但它现在并没有为您的最终客户提供任何价值。通常，当开发人员编写这样的代码时，他们会告诉自己:</p><ul class=""><li id="3f1b" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">如果我将这段代码添加到我的项目中，我会使它更具可读性</li><li id="b323" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我会让我的项目更容易维护</li><li id="da08" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">更具可扩展性</li><li id="223b" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">更易测试</li></ul><p id="6590" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们想要所有这些东西，然而，它们都是有代价的:许许多多的代码、文件、层、配置，当然还有<em class="mk">学习</em>。</p><p id="8130" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">过度工程对开发人员的思想开了一个玩笑。它承诺在遥远的未来给你巨大的价值，但却要求你现在就为之付出代价。它告诉你一个甜蜜的谎言:当然这段代码现在对你的客户没有任何作用，但是相信我，从长远来看，它会节省时间，你是一个非常聪明的开发者。</p><p id="005e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我会给你看一个超工程的例子。通过研究这个例子，你将开始看到你的代码中过度工程化的模式。如果你知道过度工程是什么样子，你就会避免把它添加到你的代码中。更少的代码→更快的特性交付→更多的钱。</p><h1 id="989a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">过度工程的可怕例子</h1><p id="ade8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">你不需要到处寻找一个令人敬畏的过度工程的例子。我在GitHub上花了大约30分钟，发现了这么漂亮的10/10样本。我对代码质量感到惊讶。</p><p id="620e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这个项目有4个主要的贡献者，他们来自剑桥，例如，一个非常顶尖的地方。这些人都是受过良好教育的专业人士。有请，有请https://github.com/libero/reviewer-submission<a class="ae ml" href="https://github.com/libero/reviewer-submission" rel="noopener ugc nofollow" target="_blank"/></p><p id="e107" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">堆栈:</p><ul class=""><li id="865a" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">以打字打的文件</li><li id="d154" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">表达</li><li id="9a71" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">阿波罗图表</li><li id="d1ad" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">Knex用于构建Postgres SQL</li><li id="4e55" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">模式验证的Joi</li><li id="02ee" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">开玩笑的测试</li></ul><p id="ceb2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它将与您的个人堆栈不同，但所有的过度工程概念都适用于任何工具和代码。</p><p id="1660" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们感兴趣的是:</p><ul class=""><li id="bb74" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">代码有很多很多层，为最终用户提供低价值，例如，过度工程化</li><li id="74f4" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">开发人员是专业的，组织良好</li><li id="4186" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">开发人员对好的实践有一种极端生硬的决心</li></ul><p id="8ddb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将查看后端代码。我们将从代码中抽取1个特征/故事，看看它是如何工作的。我将向您展示为什么这段代码提供的价值很低，以及它如何欺骗人们认为它是有用的。</p><p id="5db7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我将向您展示如何用少40倍的代码实现<strong class="kv io">同样的最终用户价值。更少的代码→更快的特性交付→更多的钱。很简单。我们走吧！</strong></p><h1 id="fd92" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">简单的功能:用户可以请求他的表单提交</h1><p id="bc81" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">假设Postgres中有一个表，它存储了一些表单提交。用户可以提交表单，表格存储表单。该企业要求创建一个web服务，允许用户获取表单提交。听起来很简单:</p><ul class=""><li id="b54b" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">验证用户身份</li><li id="82a3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">运行选择查询以获取他的表单提交</li><li id="6fab" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">然后通过互联网以JSON的形式返回结果</li></ul><p id="2630" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">非常简单，最重要的是非常普遍的模式。90%的web应用都是这样。</p><p id="4e16" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">制作这样一个功能有多难？让我们给企业留下深刻印象，让这个功能<strong class="kv io">变得非常非常快</strong>。你可以在一个小时之内制作一个非常酷的应用程序:</p><ul class=""><li id="fd05" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">作为web服务器，我们将使用Node+ <a class="ae ml" href="https://youtu.be/-MTSQjw5DrM?t=214" rel="noopener ugc nofollow" target="_blank"> Express </a></li><li id="be08" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们将创建一个简单的HTTP get端点</li><li id="37d8" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">对于auth，我们将使用OIDC。这个东西允许授权给一些权威。你还记得“用谷歌/脸书登录”按钮吗？即将发生</li><li id="df13" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们将使用<a class="ae ml" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">https://auth0.com</a>作为我们的主要OIDC权威，它是免费的，并提供了一个不错的用户界面</li><li id="ed97" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我在这里免费创建了一个Postgres数据库<a class="ae ml" href="https://elephantsql.com" rel="noopener ugc nofollow" target="_blank">https://elephantsql.com</a></li></ul><p id="095a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">整个申请在<a class="ae ml" href="https://gist.github.com/aleksejkozin/5acc75f4a7a1ddd3d236ba870e1b075e" rel="noopener ugc nofollow" target="_blank">单个文件</a>中。您可以复制并粘贴这40行，并通过将它们作为<code class="fe nc nd ne nf b">nodemon app.js</code>运行并打开<a class="ae ml" href="http://localhost:3000/submissions" rel="noopener ugc nofollow" target="_blank">来摆弄它们。请不要删除数据库，因为其他人会想玩桌子。</a></p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/23ad762af20845d600f7adf1ffe83e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6ipMQMi5TISNnlT6qOxpQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">90% of web applications structured like this</figcaption></figure><p id="f2d2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">90%的web应用程序都是这样的:HTTP请求→ Auth → SQL →返回JSON。业务价值本身就在app.get()中，就像10行一样，其他的东西都是库初始化的样板。</p><p id="53dc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在编程中，对程序的简单程度有严格的限制。我能想到的简化这个功能的唯一方法是使用<a class="ae ml" href="https://www.google.com/forms/about/" rel="noopener ugc nofollow" target="_blank">谷歌表格</a>。但是<strong class="kv io">没有限制你可以让一个程序</strong>有多复杂。有限的优势——无尽的劣势。</p><p id="c574" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们测试软件复杂性的物理极限。</p><h1 id="5a6a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">过度设计:用户可以请求他的表单提交</h1><p id="dcdb" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们看看剑桥的人们是如何做到的:</p><p id="2b49" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将通过初始化GraphQL Apollo服务器来预热。GraphQL就像REST一样，有很多好处。阿波罗服务器就像快车。</p><p id="954b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">GraphQL做了一些非常棒的事情:</p><ul class=""><li id="96c6" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">它允许客户端通过仅发送部分数据来节省流量，并通过一次请求多个端点来节省时间</li><li id="1394" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">它还为第三方用户提供我们API的文档</li><li id="30fa" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">它还将传输模式应用于我们的数据。这样，我们的域将与我们向最终用户发送数据的方式<strong class="kv io">分离</strong>。所以我们可以改变我们的域名而不影响我们的客户</li></ul><p id="44ed" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们初始化阿波罗GraphQL服务器:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/5889dc716819e2341d615c6324b96639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opXVKLiXcEF2eijjEYLcwg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Initializing Apollo with security and complexity checks</figcaption></figure><p id="00d0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">你可以说有点罗嗦</strong>，但事实并非如此。GraphQL的问题在于，客户端可能会以无限的复杂性编写请求。我们不希望我们的客户端编写无限深度的查询，这将花费无限的时间和CPU来执行。因此，在我们执行查询之前，我们需要验证它不会破坏我们的后端，或者这将是一个愚蠢的安全漏洞。这可以通过阿波罗插件来完成。</p><p id="a777" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">GraphQL最重要的部分是模式。这个想法与SQL或Joi域模式相同:您定义了一些形状，模式引擎将验证该形状是否正确。数字就是数字，日期就是日期，字符串就是字符串。GraphQL模式也将作为我们的API的文档:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/19c98283af59a3cdef851237e26ced1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qV53EfPio4D-OBxcoJOSgQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Our API consists of a query that returns an array of Submissions</figcaption></figure><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/93b7b7dea6874211427e2fe81b738d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvHX_ppewB36Jl_nkrFH4Q.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">The transport GraphQL submission schema</figcaption></figure><p id="ff61" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如您所见，我们定义了<strong class="kv io"> getSubmissions查询。</strong>非常简单的查询。它以数组的形式返回所有提交的内容。提交模式也由其他模式组成，我不包括它们，以免让你不知所措。</p><p id="8493" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在最酷的部分开始了。是时候开始编写我们的解决方案了。解析器是什么——只是从我们的客户端接收请求并返回数据的函数。标准应用层。</p><p id="6581" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将定义<strong class="kv io"> getSubmissions查询解析器</strong>。它将验证客户端，获取他的用户id并调用DashboardService。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/afa10caa0da2ccd285f12feca9a1d7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f81HHX7AqXWwJ0bF3q6Wfw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">getSubmissions query resolver</figcaption></figure><p id="2025" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在我们要去某个地方，看看接下来会发生什么。</p><p id="c579" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> DashboardService </strong>是与客户端仪表板相关的所有服务的瘦包装器，例如SubmissionService和PermissionService。它调用<strong class="kv io">submission service . findbyuserid()。</strong></p><p id="8df0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">DashboardServic做了一件多么有趣的事情，它将域模式转换为数据传输模式。这是因为我们的域与GraphQL是解耦的。这样我们可以在不改变API的情况下改变域，这在将来可能是有益的。这是单一责任原则的精髓:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/eea6ce51d9ee2e96539f109a66252824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gy7xOR_nOhV9RbsdUqVThg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">The DashboardService groups dashboard related features together and convert them from the domain to the transport model</figcaption></figure><p id="cc36" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们测试一下我们的dashboard服务。用测试覆盖您的代码是最佳实践:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/2fe52c8df2b2660523e20de4c679b061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl_dRhTa8Jv0Ttq7fgLsNA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Testing the DashboardService with Jest</figcaption></figure><p id="c816" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">DashboardService调用<strong class="kv io">submission service . findbyuserid()</strong>。</p><p id="3ab7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是事情开始升温的地方。</p><p id="378b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们有几个与提交记录相关的特性，所以让我们将它们打包成一个<strong class="kv io"> SubmissionService </strong>。SubmissionService的作用:它使用Knex、Mail、S3或DataRepository等基本服务来处理提交操作。很简单。有查找全部/删除/提交等。</p><p id="630e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们希望<strong class="kv io">将</strong>我们的业务逻辑与代码的其他部分分离，这样我们的业务逻辑就存在于SubmissionService之类的服务中。这样，如果我们改变我们的业务逻辑实现，我们将不需要改变业务逻辑消费者。最好的情况是。有时你会改变所有的层，但我们暂时忽略它。</p><p id="5727" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将把Knex(和其他基础设施服务)作为依赖项注入SubmissionService。这样我们就可以在测试过程中改变它们。这样我们就可以对有副作用的服务进行单元测试。相当方便的技术。我个人喜欢依赖注入。</p><p id="a452" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将在SubmissionService中创建一个<strong class="kv io"> findByUserID() </strong>方法。但是我们现在还不能执行Postgres SELECT，这是很愚蠢的。SubmissionService只是一个控制器。它使用其他服务来完成它的工作。它与我们如何在数据库中存储数据的实现细节无关。</p><p id="d159" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这就是单一责任原则的全部内容。SubmissionService将向执行SQL繁重任务的<strong class="kv io"> submissionRepository </strong>发送命令。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/21ac6265a2266157d1901f06a721e0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GedW12_iJzgDeWmcPAGOjw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">SubmissionService consumes other dependencies and decouples business logic from other parts of our code</figcaption></figure><p id="6856" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代码太多了。休息时间！你可以选择伸展一下或者喝一杯水。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/179a5ee436a84bec8e6ac52cb92ed6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfGhKbovxZCT1FgeE6bCuA.jpeg"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">It is break time</figcaption></figure><blockquote class="mm mn mo"><p id="49ce" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">过度工程化是聪明人的病。你越聪明，你就越能自掘坟墓。</p></blockquote><p id="e049" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们回顾一下我们所做的事情:</p><ul class=""><li id="5f0f" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">一个用户想要请求他所有的表单提交</li><li id="a488" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">用户向我们的Apollo服务器发送一个GraphQL请求</li><li id="f2f5" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们验证请求将消耗合理数量的CPU和资源，并将其传递给解析器</li><li id="8e07" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在getSubmissions查询解析器中，我们对用户进行身份验证，并使用user-id调用DashboardService</li><li id="4e52" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">DashboardService负责所有仪表板服务从域到传输模式的转换。它还调用SubmissionsService</li><li id="5027" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们已经在DashboardService上应用了单元测试</li><li id="233e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">SubmissionsService是一个将多个服务缝合在一起的控制器。它用具体的数据存储实现调用submissionRepository</li></ul><p id="5a52" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们得到了应用程序的核心，最重要的部分就在我们面前。</p><p id="ab69" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们现在可以实现一个具体的数据库提交仓库。我们将使用Knex。如果您不熟悉Knex——它是一个SQL查询构建器。它允许你不用写SQL就能写SQL。我们为什么要用它？你会经常问自己这个问题。</p><p id="5430" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们不喜欢Knex API tho。我们想改变它。因此，我们将把Knew包装成一个定制的<strong class="kv io"> KnexAdapter </strong>。很常见的技术。默认库的API并不总是方便使用，这就是为什么我们可以将它们包装到我们方便的适配器中。此外，如果Knex会改变它的API，我们就不需要去修改Knex调用的代码库(手工劳动)，我们只需要在一个地方修改一个适配器:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/435e088fec956e7a290d8d58f6386f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRtLQXY2qr4XAqSzuK9I-w.jpeg"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">We do not like Knex API, so we create an adapter</figcaption></figure><p id="db90" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们编写一个Knex查询，它将为我们完成构建SQL查询的繁重工作:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/a5c323a02f322639860ba41e680a7b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUZUDS0zL8vBCOIMqq14Tg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">KnexAdapter will produce SQL, and we will parse results to the domain model</figcaption></figure><p id="593e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果您没有花时间学习Knex API，这是Knex将要构建的SQL:</p><pre class="mu mv mw mx gt nr nf ns nt aw nu bi"><span id="36e7" class="nv jw in nf b gy nw nx l ny nz">SELECT ... our columns ... FROM manuscript<br/>WHERE created_by = $user_id<br/>ORDER BY updated DESC</span></pre><p id="78de" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">执行查询后，我们将提交数据从DB加载到内存中。然而，我们还不能把它发送给最终客户，那将是愚蠢的。我们需要对结果应用<strong class="kv io"> entryToModel() </strong>。</p><p id="07e2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我很激动！在这里，事情会上升一个档次。</p><p id="92fd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">entryToModel()包含我们的域数据模式。它将数据的DB表示转换为数据的领域表示。这允许我们将我们的领域从我们存储数据的方式中分离出来，并应用一些很酷的转换、验证、数据规范化、数据清理等(我们还没有这样做，但也许我们将来会需要它)。非常常见和强大的技术:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/9d2de99e5f9a9a471967aeb99f1dd0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GiBCi5eo8y9548lNMxQb-Q.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Converts data from the Postgres model to the domain model</figcaption></figure><p id="b791" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里你可以看到我们正在调用一个额外的<strong class="kv io">提交类</strong>。问题是，它保存了我们如何在域中存储提交的可重用逻辑。我们在项目中经常用到这个类。将可重用的代码提取到一个类中是一种很好的做法:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/2655640036ce50d4704a14e8d79e3f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKW6-sY15U4bY0KIGYjZIg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Our domain model of submission part 1</figcaption></figure><p id="1119" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">提交类的另一个截图，我无法将代码放入其中:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/f3ab5a78ed3af07aa400fa8345c80cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUYQpJNxIwuJYr5-FfH5Ng.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Our domain model of submission part 2</figcaption></figure><p id="8917" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">正如您从Submission类中看到的，我们可以安全地调用我们的<strong class="kv io">域数据模式</strong>。我们将使用Joi实现该模式。</p><p id="de06" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Joi所做的是验证所有数据的形状和格式是否正确——日期就是日期，数字就是数字，等等。通过这种方式，我们可以将从数据库外部源接收的“未知”类型脚本转换为具体的类型脚本类型，并保证不会有任何错误。</p><blockquote class="mm mn mo"><p id="edc5" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">个人觉得Joi没那么欢乐。它与TS有冲突，不能改变数据。所以我花了一个月的时间做自己的方案。完全过度工程化。但这超出了我们今天的讨论范围。</p></blockquote><p id="afc3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">模式被递归调用:disclosureSchema、authorSchema、manuscriptDetailsSchema等。它们用于验证嵌套对象。为了不让代码淹没您，我就不介绍其他内容了:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/76f22e886555945548595413a6e60561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVzsNtwKqyZ5o3GNyhl8Gw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Joi schema that validates our domain model</figcaption></figure><p id="67e5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">就是这样！我们的专题/故事:“用户可以请求提交表单”完成了！</p><p id="9296" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们回顾一下我们所做的事情:</p><ul class=""><li id="9d6f" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">一个用户想要请求他所有的表单提交</li><li id="5d74" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">用户向我们的Apollo服务器发送一个GraphQL请求</li><li id="c711" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们验证请求将消耗合理数量的CPU和资源，并将其传递给解析器</li><li id="daba" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在getSubmissions查询解析器中，我们对用户进行身份验证，并使用user-id调用DashboardService</li><li id="2300" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">DashboardService负责所有仪表板服务从域到传输模式的转换。它还调用SubmissionsService</li><li id="6e17" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们已经在DashboardService上应用了单元测试</li><li id="02d2" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">SubmissionsService是一个将多个服务缝合在一起的控制器。它用具体的数据存储实现调用submissionRepository</li><li id="17ba" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">存储库使用KnexAdapter以更方便的方式调用Knex</li><li id="be6e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">Knex构建一个SQL查询并从Postgres请求数据</li><li id="f8fc" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们对来自Postgres的数据应用领域模式并返回模式。领域模式由3层组成:entryToModel、提交类和Joi模式</li><li id="e6dc" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在DashboardService中，我们将域模式转换为数据传输模式</li><li id="d4fc" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们将数据传输模式从解析器返回给最终用户</li></ul><p id="4e0a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">用户→Gql→Apollo→dashboard service→Submission service→Knex adapter→Knex→postress QL模式→提交类→ Joi → Gql →用户</p><p id="bda7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代码是干净的。上面写满了测试。遵循最佳实践。打字安全。可扩展。可维护。</p><p id="b7d6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然而你觉得有些不对劲。“用户可以请求提交表单”怎么可能需要500行代码、一周的工作和4个非常昂贵的剑桥专家一个月的学习工具？</p><p id="cac3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这个功能花了这么多时间和精力去开发，我们从中得到了什么？</p><h1 id="cb4d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">这段代码真的那么没用吗？</h1><blockquote class="mm mn mo"><p id="5bea" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">是的，没用。</p></blockquote><p id="b30e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">直觉上，问题很明显:对于这个简单的特性来说，代码有点太多了。然而，这个代码做了一些事情，它没有死。它运行一些计算，移动数据，创建一些结构，一些文件，等等。它似乎在做一些有用的事情，但我们不确定具体是什么。真的那么没用吗？感觉给了一些价值。</p><p id="de53" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果我们看一看，我们项目中的大多数过度工程来自:</p><ol class=""><li id="d2c6" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">模式/模型</li><li id="320a" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">GraphQL</li><li id="cf0d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">多个薄层:适配器/服务/控制器</li></ol><p id="0ee5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们逐一检查它们，并尝试找出它们的价值。也许我们的客户真的需要这些复杂性。也许时间没有浪费。快速高质量的特性交付是成功的关键。</p><h2 id="84f5" class="nv jw in bd jx oe of dn kb og oh dp kf le oi oj kj li ok ol kn lm om on kr oo bi translated">为什么我们需要模式/模型？</h2><p id="c335" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">定义模型背后的主要思想是:</p><ol class=""><li id="9cb1" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">您可以将一部分代码与另一部分代码隔离/分离。在我们的程序中，数据流是这样的:客户端 GraphQL 域Joi模型 Postgres。<br/>如果我们想改变Postgres，我们不需要改变Client，因为我们只需要更新Domain和Postgres之间的2个转换函数。</li><li id="65ad" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">您可以在层之间应用额外的转换/验证。</li></ol><p id="06a5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">想象我们正在打造一个脸书。我们想存储用户的个人资料。我们希望我们的用户能在屏幕上看到他们的个人资料。我们有一个叫“阿列克谢”的用户，他的密码是“上帝”。</p><p id="c501" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先，我们希望将用户存储在像数据库这样的持久存储中。第二，我们想用漂亮的html+css在前端展示它。在我们的例子中，“用户阿列克谢”的相同想法有几种模型/表示:</p><ul class=""><li id="833e" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">我们数据库里的一条记录。该表有一个形状数据库【创建表用户】(名称文本，密码文本)<br/> <code class="fe nc nd ne nf b">name | password<br/>Aleksey | god</code></li><li id="7e59" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">一堆HTML标签在屏幕上呈现出美丽的用户档案<br/> <code class="fe nc nd ne nf b">&lt;h1&gt;User Profile&lt;/h1&gt;<br/>&lt;p&gt;Hi, my name is &lt;b&gt;Aleksey&lt;/b&gt;&lt;/p&gt;</code></li></ul><p id="39e9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">请注意:当我们从数据库模型转换到HTML模型时，我们需要过滤掉密码。这是模型之间转换的基本类型。这个行业中非常流行的例子。</p><p id="faa9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">去耦和转换是很酷的功能，但是它们也有成本:</p><ul class=""><li id="706a" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">我们需要定义我们的模型/模式</li><li id="497a" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们需要定义转换函数</li><li id="2e6c" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">一些逻辑将在模型之间复制，因为它们看起来通常是相同的</li></ul><p id="e606" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在我们的“用户可以请求他的表单提交”中，我们有3个模式:</p><p id="e303" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">A) <strong class="kv io"> GraphQL模式</strong>。这是我们数据的传输表示</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/93b7b7dea6874211427e2fe81b738d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvHX_ppewB36Jl_nkrFH4Q.png"/></div></div></figure><p id="d195" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">b)具有<strong class="kv io"> Joi </strong>的域模式</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/ccd34f83cfc306d80c66b1755782645c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9Zt8jXN63nFzy7qFHmzlQ.png"/></div></div></figure><p id="648d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">c)和<strong class="kv io">后置格赖斯模式</strong>。这是我们数据的存储表示。我无法访问他们的Postgres模式，但我能够恢复它</p><pre class="mu mv mw mx gt nr nf ns nt aw nu bi"><span id="ddee" class="nv jw in nf b gy nw nx l ny nz">CREATE TABLE submissions<br/>(<br/>    id                               serial<br/>        CONSTRAINT submissions_pkey<br/>            PRIMARY KEY,<br/>    created                          date,<br/>    updated                          date,<br/>    created_by                       text,<br/>    status                           text,<br/>    last_step_visited                text,<br/>    meta                             entrymeta,<br/>    cover_letter                     text,<br/>    previously_discussed             text,<br/>    previously_submitted             text[],<br/>    cosubmission                     text[],<br/>    opposed_senior_editors_reason    text,<br/>    opposed_reviewing_editors_reason text,<br/>    submitter_signature              text,<br/>    disclosure_consent               boolean,<br/>    opposed_reviewers_reason         text<br/>);</span></pre><p id="862c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">看，它们都非常相似。没有发生什么事情。它们有不同的实现细节，比如，一个使用GraphQL，另一个使用Joi，另一个是Postgres。但归根结底，这是一回事。现在有一个问题:</p><ul class=""><li id="32b1" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">为了创建一个模式，你需要键入很多:GraphQL、Joi、Postgres——你用不同的方言一遍又一遍地定义同一件事</li><li id="08a8" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">要在模式之间传输数据，需要编写转换1到1函数</li></ul><p id="d412" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代价是巨大的。这一切有什么意义呢？</p><p id="2e43" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">开发人员希望，如果我们将来需要改变Postgres模型，我们只需要改变Postgres和Joi之间的转换函数。</p><p id="86ac" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这就是为什么开发人员把代码放在那里。他们预计Postgres会改变，他们认为如果他们有一些额外的层，更新程序会更容易。</p><p id="7836" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我想做一个大胆的声明:他们试图让生活变得更简单，却让生活变得困难了10倍。</p><p id="9231" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Postgres可以与我们的API耦合，因为它本质上是一对一的转换。如果Postgres将更新shape，那么他们将有99%的机会更新所有其他模型/模式/转换/服务。基本上，任何Postgres的改变都会给他们带来大量的工作。</p><p id="c10f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">具有讽刺意味的是，他们给自己制造了他们想避免的问题。</p><h2 id="d8ef" class="nv jw in bd jx oe of dn kb og oh dp kf le oi oj kj li ok ol kn lm om on kr oo bi translated">我们为什么需要GraphQL？</h2><p id="2a28" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">GraphQL代价很大:</p><ul class=""><li id="f4d0" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">你(以及这个项目中你之后的所有人)将需要学习一门新的语言</li><li id="f648" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您需要编写模式</li><li id="6e6d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您需要学习如何使用复杂的Apollo服务器(身份验证、查询复杂性分析、分页期间的合并状态等)</li><li id="3ae7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您需要将数据从GraphQL转换到Domain，然后再转换回来</li></ul><p id="f5c1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为什么人们愿意支付这个费用？有几个好处:</p><ul class=""><li id="99c8" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">客户端可以决定请求什么数据。这样可以节省流量</li><li id="d076" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">客户端可以一次请求多个端点。这可以节省加载时间</li><li id="758a" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您已经为第三方消费者提供了现成的文档</li></ul><p id="a020" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这些都是很酷的功能！但是，在以下情况下，它们是相关的:</p><ul class=""><li id="897e" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">有很多很多的客户端请求大量的数据，请求量非常大</li><li id="8863" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您提供了对API的第三方访问，并且您需要同步文档</li></ul><p id="b11b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我想做一个大胆的声明:当你是一个Shopify或Instagram时，这是相关的，但当你为剑桥提供表格时，就不那么相关了。规模不在，成本和过度工程在。</p><h2 id="7801" class="nv jw in bd jx oe of dn kb og oh dp kf le oi oj kj li ok ol kn lm om on kr oo bi translated">为什么我们需要适配器/服务/控制器？</h2><p id="b64d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">适配器主要用于两件事:</p><ol class=""><li id="5542" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">如果你不喜欢第三方API/库的形状，你可以包装它。您可以提供附加要素，或者只是更改现有要素的形状。比如，我不希望API抛出异常，所以我把它的所有方法都包装在try/catch中，如果出错就返回false。</li><li id="0778" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">您希望保护自己免受第三方API更新的影响，这将导致代码中的更改传播。<br/>假设你需要在node发送一封邮件。你会怎么做？你会调用一些像AWS SES API这样的第三方库。但是如果AWS SES要改API呢？那么您将需要更改使用这个API的代码。这可能需要大量的工作。<br/>因此，您很聪明，您引入了包装AWS SES的个人邮件服务邮件API，并在您的代码中使用您的邮件服务。这样，如果AWS SES将更新他们的API，你只需要更新邮件服务就可以了。</li></ol><p id="1f06" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">听起来很有用。但是，你将需要付出过度工程化的代价。很容易以一个无用的服务/适配器结束。他们有很多样板代码，但是产生一对一的API转换。查看完美的例子:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/5c9d07f72ec8bf784c0fcfe8b968daeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ag5T6B6w44_UYUDtyx3dbw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">A thin 1 to 1 service that consumes code but produces no value</figcaption></figure><p id="3d93" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">控制器主要用于调用服务和适配器，并存储一些域业务逻辑。</p><p id="43b5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">控制器背后的想法是一样的:解耦。您可以更新业务逻辑实现，而无需更新逻辑的使用者。但是，你将需要付出过度工程化的代价。很容易以无用的控制器告终。</p><h1 id="24b2" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">但是当你把应用程序变小的时候，你失去了一些功能！</h1><blockquote class="mm mn mo"><p id="adb8" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">没有丢失任何有价值的东西。</p></blockquote><p id="ad19" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你可以争辩说小应用程序失去了一些有用的功能，你将是正确的。但是这个应用程序获得的只是一点点的复杂性。我们可以在一小时内造好这个东西。对某些人来说。然而，我们的最终用户会很高兴收到他们提交的表单。</p><p id="fd72" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">再次看看我们的小应用程序:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/035953e55dba3bf3926aad3f6d83603b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AswG3HnvzoqTgJogvE02A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">10 lines of the essence of web development</figcaption></figure><p id="b622" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">好处是显而易见的:极小的代码和快速的开发，超级容易更新这些代码。但是让我们回顾一下我们失去了哪些功能:</p><ul class=""><li id="c01e" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">没有模式和模型。我们存储数据的方式与我们将数据传输给最终用户的方式紧密相关。如果我们改变我们的Postgres模式，我们将影响我们所有的用户。我们应该通过创建模式和模型来解决这个问题吗？<strong class="kv io">否。</strong>实施成本无法弥补收益。如果Posrgree发生变化，我们可以在几分钟内手动更改我们的客户端。</li><li id="ed17" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有适配器。我们直接调用所有第三方服务。这意味着，如果服务将改变它们的API，我们将需要在多个地方改变我们的代码(在我们所有的特性中)。我们应该通过创建适配器来解决这个问题吗？<strong class="kv io">没有</strong>如果有人会更新pool.query() API，我们很乐意手动更改这些，这需要几分钟。</li><li id="cb1f" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有适配器。这意味着我们不能用我们的定制逻辑扩展第三方服务。我们应该创建适配器吗？<strong class="kv io">不</strong>我们对当前的API实现很满意。</li><li id="7399" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有控制器。我们的业务逻辑与我们存储和传输数据的方式紧密相关。也许我们应该只提取一个控制器？<strong class="kv io">否</strong>。商业逻辑现在是如此微小。</li><li id="769b" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有打字稿。我们已经失去了类型安全。现在我们可以在重构过程中意外地得到空指针引用。要不要加TypeScript？现在没什么事情发生。当代码变得更加复杂时，我们可以添加TypeScript。</li><li id="5800" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有GraphQL。这意味着我们的客户不能选择他们想要请求的数据，可能会收到比他们需要的更多的数据。我们应该使用GraphQL吗？<strong class="kv io">不</strong>天哪，这个剑桥表单API的客户大概有1000个。如果他们收到全部数据，企业就不会缺钱。如果将来数据传输过多会成为问题，我们会添加GraphQL，但显然不是现在。</li><li id="e566" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有GraphQL。这意味着没有API文档。API文档应该使用GraphQL吗？<strong class="kv io">没有</strong>就叫吧，看JSON来什么。在这个API上总共有4个开发者，他们可以以管理员身份打开Postgres并看到那里的模式，因为我们的PG模式就是API模式。太酷了！</li><li id="c376" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">没有测试。这意味着在重构过程中，我们可能会破坏某些东西。我们应该测试我们的查询吗？<strong class="kv io">不</strong>这只是一个基本的选择，没有复杂的逻辑在进行。即使我们打破了没有人会死的东西，它不是一架飞机或医疗软件。但是我希望您展示如何测试SQL查询，如果它们变得很大的话。文末查一下。</li></ul><p id="a168" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">基本上，我们将代码大小减少了40倍，并且几乎没有损失最终用户需要的任何功能。真的有这么简单吗？</p><p id="6389" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在剑桥人制作1个功能的时候，你可以提供10个功能。这些功能都是经过测试的高质量产品。记住高质量的功能=更多的钱。</p><h1 id="ab83" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">开发者过度工程化的原因</h1><p id="6b45" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为什么剑桥的人会成功呢？他们超级聪明，有顶级文凭为证。然而，他们制造了这种过度工程化的混乱。</p><p id="af4f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">开发人员过度设计是因为:</p><ol class=""><li id="1f43" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">他们希望解决今天没有的未来问题。想猜猜未来</li><li id="9889" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">他们想到处玩，找点乐子，感觉自己很聪明</li><li id="62f9" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">他们的同龄人使用这些工具，所以他们模仿他们的同龄人</li></ol><p id="39d2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们回顾一下。如果我们看一看，我们项目中的大多数过度工程来自:</p><ol class=""><li id="ec8d" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq ms mc md me bi translated">模式/模型。在这里，我们希望将我们的域/传输层/数据库相互分离。如果一个将要改变，那么改变传播将在层边界停止。我们还期望特性中的数据在层之间被大量转换。</li><li id="b2f5" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">GraphQL。在这里，我们希望为我们的客户端提供一个更具可伸缩性的API，它可以在过多的调用中请求过多的数据。我们还希望我们的潜在第三方用户的文档。</li><li id="3d0d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq ms mc md me bi translated">适配器/服务/控制器。在这里，我们希望保护自己免受潜在的代码更改传播的影响。我们还希望有一个点来扩展第三方API的附加功能。</li></ol><p id="6935" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有一个共同的主题。所有这些过度工程的共同主题是什么？</p><ul class=""><li id="d722" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">工具和实践是有益的</li><li id="c1a3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">工具和实践非常抽象，推理起来非常复杂。这造成了混乱</li><li id="857c" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们现在付出了巨大的代价</li><li id="5746" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">但是我们现在没有价值</li><li id="a169" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">但是我们被承诺未来的价值</li></ul><p id="9614" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">基本上，我们需要在墙上钉一颗钉子，为了这项工作，我们雇了一台手提钻推土机，团队有三个人:工程师、项目经理和司机。我们这些人也需要住宿，所以租了房子。房子需要打扫，所以我们雇了一名清洁工。这些人都需要吃饭，所以我们租了一个厨房。现在，所有这些人都需要从他们的家到他们的工作，所以我们租了一辆车。这辆车需要保养，所以我们……这太复杂了。</p><p id="3d53" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们过度设计了。过度工程的几个编程例子:</p><ul class=""><li id="a111" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">我的客户现在没有性能问题，但也许将来会有。因此，让我用接下来的两个月来学习和实现GraphQL</li><li id="f8a4" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">GraphQL允许我的1客户每月请求提交一次表单。GraphQL从不让我做。非常酷和可靠的工具。我会说服我遇到的所有其他开发人员使用它！</li><li id="c05b" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我的业务逻辑只有5行，但是它使用的API可能会改变，我需要重写它。因此，让我将业务逻辑封装到控制器中。并将API封装到适配器中，因为我可能想要扩展它们</li><li id="4464" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我现在在构建动态SQL查询方面没有问题，我在SQL性能方面也没有任何问题，但是我听说这个ORM工具可以节省我很多时间。我没时间学SQL。所以让我花两个月的时间来学习这个ORM</li><li id="909f" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我需要做一个静态的web表单。所以让我们在前端使用React和Redux。因为，你知道，在未来我可能有100MB的动态状态和10000个依赖于状态的组件</li></ul><h1 id="6486" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何做到最好</h1><blockquote class="mm mn mo"><p id="78f3" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">成为最好的秘诀是对复杂说不的意志力。</p></blockquote><p id="20af" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">更少的代码→更快的特性交付→更多的钱。</p><p id="6e6c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">无论代价如何，我们总是需要使用最佳实践吗？在遇到性能问题之前，我们还需要这些工具的附加功能吗？这是90%的开发者说是的地方。你需要说不。你需要拒绝构建复杂的应用程序。</p><p id="b90d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">应用程序是活的有机体。它们随着时间而进化。如果你从一个小的解决方案开始，你可以投入最少的资源，然后看看效果如何。</p><ul class=""><li id="bf03" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">如果您在某个时候遇到低性能问题，您总是可以添加更复杂的工具来解决性能问题</li><li id="4cea" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如果你遇到一个变化，不要害怕做一些体力劳动，它最多需要30分钟</li></ul><p id="b838" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是如果你试图预先解决所有的可伸缩性问题，你最终会得到一个毫无意义的应用程序。“一个用户可以请求他的表单提交”需要500行代码，以及4个非常昂贵的剑桥专家数周的工作。</p><p id="bfa6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在开发过程中，我们应该专注于用高质量的代码和低成本为我们的客户快速交付价值。</p><h1 id="af29" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何避免过度工程化</h1><blockquote class="mm mn mo"><p id="90a9" class="kt ku mk kv b kw lr ky kz la ls lc ld mp lt lg lh mq lu lk ll mr lv lo lp lq ig bi translated">将您的应用程序发展成一个离开的有机体。从尽可能小的物理规模开始，然后随着业务需求的增长而增长。</p></blockquote><p id="4c9c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我展示一个我们应用程序发展的例子。我们从本质出发:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/035953e55dba3bf3926aad3f6d83603b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0AswG3HnvzoqTgJogvE02A.png"/></div></div></figure><p id="1193" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">想象一下，我们的剑桥表格业务正在增长。业务需求发生了变化，应用程序如下所示:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oq"><img src="../Images/f8590ed9952678e1383ca0c61f136cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nic0AC1kD0AgejtpPPTOHw.png"/></div></div></figure><p id="8af3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里的问题是，我们的业务逻辑变得相当复杂。</p><ul class=""><li id="2df8" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">我们知道，业务正在增长，未来的需求也会发生变化</li><li id="2084" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">我们知道，需求的更新意味着复杂SQL查询的更新</li></ul><p id="bcdb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在这种情况下，我们将受益于子查询提取和自动化测试。</p><p id="51ff" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果没有自动化测试，在每次SQL重构之后，我们将需要手动验证我们的复杂SQL查询是否按预期工作。您知道查询很容易变成:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/ccdbed39e705b25813c82df744454cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyZqZ499-xcCM8DSCCzwiA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk"><strong class="bd os">BIG</strong></figcaption></figure><p id="fa99" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们测试我们的大查询。</p><p id="133f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将把SQL提取到一个变量中，这样我们就可以在测试和端点中使用它。</p><p id="b044" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将在这里使用一个很酷的技巧。我们将在一个事务中运行每个测试，并在之后回滚它。这将允许我们在临时数据库上运行查询，并且不修改其状态。</p><p id="19ff" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将只测试1条快乐之路。</p><p id="0691" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在运行我们的业务逻辑之前，我们将截断提交表并在那里插入测试数据。这样，我们可以确保在干净的桌面上运行我们的测试。</p><p id="631b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行我们的查询后，我们将验证它的输出。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/82ba78f11f1b0dfde68104576044b710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OtYZdzDvWAIJcewEZ-SKA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">How to test SQL queries</figcaption></figure><p id="9cb6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">正如您所看到的，我们的应用程序的复杂性大大增加了。但是我们从这个复杂性高峰中获得了很多价值。我们不需要在每次查询更新后手工测试复杂的业务逻辑规则。太酷了！</p><p id="d4a2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，假设我们的业务正在增长，现在我们添加了一个包含大量业务逻辑的复杂函数someBusinessLogic()。这个函数还会给你发送一封邮件，因为当有人调用你的函数时，你想得到通知。</p><p id="b00c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因为逻辑很复杂，所以你要为它写一个测试。然而，您的逻辑有一个令人讨厌的副作用:每次CI/CD运行您的测试，您都会收到一封电子邮件。您希望只接收来自客户的电子邮件，而不是来自测试管道的电子邮件。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/47e7964c15e846aa1a471586a4a3e6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrAobStUDB4XnOWaeZ7L5A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Our test produces a nasty side effect</figcaption></figure><p id="4828" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当您想要在包含副作用的服务之外测试您的业务逻辑时，您需要使用某种形式的依赖注入。Jest提供了依赖注入工具。您可以在模拟测试期间交换导入的JS模块。</p><p id="91fb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">使用Jest，您可以在测试期间在mock上交换sendEmailService()。这样你就不会收到讨厌的电子邮件通知，但你仍然可以测试你复杂的业务逻辑:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ou"><img src="../Images/358baedca152ec5c152cfbf7532285f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVGFAr-st67kAJ6IuPJoEw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Using jest to swap side effect services to mock during tests</figcaption></figure><p id="4c59" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Jest模拟依赖注入比向构造函数传递额外的变量要简单得多:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/884c92d7bc9092228e9fa7a303e863f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4QL8xACtdYu4ReTvxcQ1g.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Constructor that consumes dependencies</figcaption></figure><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ov"><img src="../Images/7aa3eeb49cf1028dee67082d56c49daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUAqTn0tWEH93CGwuqGMTw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Drilling services as params produce boilerplate</figcaption></figure><p id="b99b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">样板构造函数注入消耗的量是很大的:</p><ul class=""><li id="0a65" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">构造函数定义</li><li id="dd5b" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">有时类型定义</li><li id="5401" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">您将需要在层次结构的顶层创建服务，并深入研究它们</li><li id="2842" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">参数钻取和附加定义将创建大量样板文件</li></ul><p id="081d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有人可能会说:<em class="mk">哦，我在这个任务中使用了依赖注入框架，它为我节省了很多样板文件。</em></p><p id="2ae5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">只是用笑话嘲弄，是一句台词。您的项目中不需要更多的工具，并且您已经使用了Jest。工具比需要的多=过度设计。</p><p id="2be7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这就是避免过度设计的方法:</p><ul class=""><li id="8419" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">随着业务需求的增长发展您的应用程序</li><li id="9759" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">从物理上尽可能小的地方开始</li><li id="8d35" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">随着业务需求的增长，根据需要添加良好的实践和工具</li><li id="6c02" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">例如，当逻辑太难手工测试时，添加测试</li><li id="8a3a" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">或者，当您想在有副作用的服务之外单独测试您的业务逻辑时，添加jest mocks</li></ul><h1 id="6fc0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论:作为一名JS/TS开发人员，今天你的收入将免费翻倍</h1><p id="cf46" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">要让你的收入翻倍，你需要让你的功能开发速度翻倍。要让你的速度翻倍，你需要在相同质量下写更少的代码。要编写更少的代码，您需要避免过度工程化:</p><ul class=""><li id="8c86" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">当构建功能时，从物理上尽可能小的地方开始，拒绝使用工具，尝试遇到性能瓶颈。您的目标是以最小的复杂性快速交付价值。这样你的代码将是可扩展的/可支持的/可维护的</li><li id="e877" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">一点体力劳动比自动化和代码编写要好。如果你能在1小时的手工工作中解决问题，就不要自动化</li><li id="a2b7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">不要试图今天就解决未来的潜在问题，要关注现在的问题。解决未来会很有诱惑力，但是你应该拒绝</li><li id="2ec2" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">代码复制90%的时候比抽象提取要好。避免不惜一切代价创建函数、类、层、文件。只有当你厌倦了一遍又一遍地输入同样的东西时，才是时候创建一个抽象概念了</li><li id="efcc" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">程序应该逐步进化。你不是从GraphQL或Redux开始的，而是进化成它</li><li id="c995" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">不要总是使用好的实践。只在非常有益的情况下使用它们。例如，不要对每一个边缘情况进行自动化测试，这将需要数千行代码。仅在1个快乐的复杂用户路径上应用它们</li><li id="c360" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">不要一直使用大型工具。只在非常有益的情况下使用它们。只有遇到性能瓶颈时，才使用附加工具</li></ul><p id="330e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">仅此而已。通过这种方式，你将比90%的竞争对手更快地交付特性。</p></div><div class="ab cl ow ox hr oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ig ih ii ij ik"><p id="9f24" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">感谢各位的阅读，这是一个相当不错的旅程。如有问题，欢迎在评论区或cirnotoss@gmail.com联系我</p></div><div class="ab cl ow ox hr oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ig ih ii ij ik"><p id="d7ef" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><em class="mk">更多内容看</em><a class="ae ml" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="mk">plain English . io</em></strong></a></p></div></div>    
</body>
</html>