<html>
<head>
<title>Web Scraping with Cheerio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cheerio进行网页抓取</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-scraping-with-cheerio-d4061e703411?source=collection_archive---------13-----------------------#2021-07-28">https://javascript.plainenglish.io/web-scraping-with-cheerio-d4061e703411?source=collection_archive---------13-----------------------#2021-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6afd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Cheero介绍——一种流行的节点web解析器。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/9a88051bf33d6bb8a85921f2a8686014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*a5LSgOq26Tt0TX4BDcfzoQ.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Bowl of Cheerios Photo By <a class="ae ko" href="https://unsplash.com/@john_matychuk" rel="noopener ugc nofollow" target="_blank">John Matychuk</a> on <a class="ae ko" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ef6e" class="kp kq in bd kr ks kt ku kv kw kx ky kz jt la ju lb jw lc jx ld jz le ka lf lg bi translated">介绍</h1><p id="5e3e" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">最近我一直在开发一个API来提供棒球统计数据，因为我还没有找到一个免费的有深度统计数据的API。在这个过程中，我一直在学习许多新技能，我想谈谈<a class="ae ko" href="https://www.npmjs.com/package/cheerio" rel="noopener ugc nofollow" target="_blank"> cheerio </a>，这是一个流行的抓取和解析web内容的节点包。首先，将<a class="ae ko" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank"> node-fetch </a>和cheerio添加到package.json中，并将它们导入JavaScript文件。</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="cda2" class="mi kq in me b gy mj mk l ml mm">import cheerio from cheerio<br/>import fetch from node-fetch</span></pre><p id="ed6d" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated">顺便提一下，您会注意到我导入了这些文件，而不是需要它们。可以通过将<code class="fe ms mt mu me b">"type": "module"</code>添加到package.json文件中来实现这一点。我这样做的原因有两个:一方面，我认为ES6语法看起来更干净，与你在许多前端框架中看到的一致，另一方面，它允许你在代码的顶层使用<code class="fe ms mt mu me b">await</code>关键字。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="bb8c" class="kp kq in bd kr ks nc ku kv kw nd ky kz jt ne ju lb jw nf jx ld jz ng ka lf lg bi translated">抓取维基百科</h1><p id="68d1" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">在本教程中，我们将创建一个scraper来获取所有美国总统的列表。我们将从<a class="ae ko" href="https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States" rel="noopener ugc nofollow" target="_blank">维基百科</a>中抓取。前往该页面并查看页面源代码。搜索“乔治·华盛顿”的出处。您会发现页面上出现了13次，并注意到在第12次出现时有一个总统列表，每个总统都有一个带有href属性的“a”标记，它遵循相同的基本格式:“/wiki/Presidency _ of _ first name _ last name”。这对于抓取来说非常理想，因为我们可以抓取所有的‘a’标签，并过滤掉那些href属性与格式不匹配的标签。为此，首先我们定义一个异步函数，然后使用cheerio加载并解析我们的网站:</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="6167" class="mi kq in me b gy mj mk l ml mm">// Keep scrape function dynamic by adding url and query parameter<br/>const scrape = async (url, query) =&gt; {<br/>  // First we fetch from our url <br/>  const website = await fetch(url)<br/>    .then(res =&gt; res.text())<br/>  <br/>  // next we load the website with cheerio<br/>  const $ = cheerio.load(website)</span><span id="c714" class="mi kq in me b gy nh mk l ml mm">  // Then we can grab our a tags<br/>  let queryRes = $(query).toArray()</span><span id="5421" class="mi kq in me b gy nh mk l ml mm">  return queryRes<br/>}</span><span id="33ef" class="mi kq in me b gy nh mk l ml mm">// parse wiki page<br/>const parsePresidents = async () =&gt; {<br/>  const query = 'a'<br/>  const url =   "<a class="ae ko" href="https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States</a>"  </span><span id="d174" class="mi kq in me b gy nh mk l ml mm">  // Grab our collection of a tags returned by scrape<br/>  let aTags = await scrape(url, query)</span><span id="f911" class="mi kq in me b gy nh mk l ml mm">  // Finally we can filter our a tags<br/>  aTags = aTags.filter(<br/>    a =&gt; <br/>      a.attribs.href?.match(/Presidenc[a-z]*_of/)<br/>  )</span><span id="83c8" class="mi kq in me b gy nh mk l ml mm">  ...<br/></span></pre><p id="1513" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated">你可能想知道为什么我们定义一个常数为<code class="fe ms mt mu me b">$</code>。实际上，您如何命名您的常量并不重要，但是在cheerio的文档中，他们使用了<code class="fe ms mt mu me b">$</code>，所以这也是标准的做法。Cheerio是jQuery的子集，所以这就是它的来源。您还会注意到我们在过滤‘a’标签时使用的正则表达式。当我写这篇文章的时候，这对我来说有点“迷惑”,但是如果你花一分钟回到页面源代码，你会注意到对于格罗弗·克利夫兰，href实际上读的是“Presidencies _ of”而不是“Presidency”。他连任两届总统。因此，你看到的<code class="fe ms mt mu me b">[a-z]*</code>将匹配任何字母任意次。您也可以使用<code class="fe ms mt mu me b">.*</code>来匹配<a class="ae ko" href="https://www.w3schools.com/jsref/jsref_regexp_dot.asp" rel="noopener ugc nofollow" target="_blank">中的任何字符</a>或<code class="fe ms mt mu me b">\w*</code>来匹配<a class="ae ko" href="https://www.w3schools.com/jsref/jsref_regexp_wordchar.asp" rel="noopener ugc nofollow" target="_blank">中的任何单词字符</a>，但是在这种情况下，更具体一些也无妨。</p><p id="5683" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated">接下来，我们需要将我们收集的“a”标签映射到总统的名字。如果您还记得，href属性的格式是“Presidency _ of _ first name _ last name”。因此，我们可以在每个下划线处拆分href，在“of”之后分割结果数组，并在空格上连接这些元素:</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="e6dc" class="mi kq in me b gy mj mk l ml mm">  ...</span><span id="666f" class="mi kq in me b gy nh mk l ml mm">  let presidents = aTags.map(<br/>    a =&gt;<br/>      // Some of the presidents have middle initials<br/>      a.attribs.href // 'Presidency_of_James_K._Polk'<br/>      .split('_') // ['Presidency', 'of', 'James', 'K.', 'Polk']<br/>      .slice(2)   // ['James', 'K.', 'Polk']<br/>      .join(' ')  // 'James K. Polk'<br/>  )</span><span id="7b7a" class="mi kq in me b gy nh mk l ml mm">  ...</span></pre><p id="549e" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated">我们现在有一个所有总统名字的数组。唯一的问题是，如果你运行这个程序并查看总统名单，他们都是重复的。这是因为对于每一位总统来说，实际上有两个“a”标签符合我们的标准。这没有问题，我们可以通过唯一性来过滤总统数组:</p><pre class="kd ke kf kg gt md me mf mg aw mh bi"><span id="8170" class="mi kq in me b gy mj mk l ml mm">  ...<br/>  <br/>  presidents = presidents.filter(<br/>    (ele, i, array) =&gt; <br/>      array.indexOf(ele) === i<br/>  )</span><span id="aaaf" class="mi kq in me b gy nh mk l ml mm">  return presidents<br/>}</span></pre><p id="9903" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated">如果您对此感到陌生，让我快速解释一下这是怎么回事。对于数组中的每个元素，我们查看元素本身、它在数组中的索引以及数组本身。当我们调用<code class="fe ms mt mu me b">array.indexOf(ele)</code>时，它返回数组中匹配我们的元素的第一个索引，因此对于重复的元素，表达式<code class="fe ms mt mu me b">array.indexOf(ele) === i</code>将返回false，它们将被过滤掉。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="e318" class="kp kq in bd kr ks nc ku kv kw nd ky kz jt ne ju lb jw nf jx ld jz ng ka lf lg bi translated">结论</h1><p id="01e2" class="pw-post-body-paragraph lh li in lj b lk ll jo lm ln lo jr lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">Cheerio是抓取和解析网站的优秀工具，但有一个主要缺点:它不加载外部资源或执行JavaScript。所以对于依靠JavaScript来呈现数据的网站，你需要使用一个无头的chromium包，比如<a class="ae ko" href="https://www.npmjs.com/package/puppeteer/v/1.11.0-next.1547527073587" rel="noopener ugc nofollow" target="_blank">木偶师</a>，来模仿用户行为。我将很快写一篇关于木偶师的文章，但现在，我希望你喜欢这篇文章，并发现它很有帮助。</p><p id="27bd" class="pw-post-body-paragraph lh li in lj b lk mn jo lm ln mo jr lp lq mp ls lt lu mq lw lx ly mr ma mb mc ig bi translated"><em class="ni">更多内容尽在</em><a class="ae ko" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lj io"><em class="ni">plain English . io</em></strong></a></p></div></div>    
</body>
</html>