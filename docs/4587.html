<html>
<head>
<title>React Native Optimisation: A Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本机优化:指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-optimisation-part-i-c85e4935f4cb?source=collection_archive---------10-----------------------#2021-09-13">https://javascript.plainenglish.io/react-native-optimisation-part-i-c85e4935f4cb?source=collection_archive---------10-----------------------#2021-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4cd71d48d2f376a51b515bfbd5447199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t3nQlO2xbmxcsYqs"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="983a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据 <a class="ae jz" href="https://www.akamai.com/us/en/multimedia/documents/report/akamai-state-of-online-retail-performance-2017-holiday.pdf" rel="noopener ugc nofollow" target="_blank"> Akamai的报告</a>，移动加载时间延迟一秒钟<strong class="kc io">就可以将转换率降低20%</strong></p><p id="d14c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是第一部分，我们将讨论反应式优化的几个主题，下一部分我们将讨论如何使用本机端、CI、OTA等来改进优化和部署。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="d529" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">不正确的状态更新导致额外的渲染周期/或设备太慢</strong></h1><p id="ab15" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">React Native负责为您呈现应用程序。您的工作是定义您需要的所有组件，并用这些更小的构建块组成最终的界面。在这种方法中，您无法控制应用程序渲染生命周期。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0498e66f5c8ff4559420533717cd5d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*OGtpCC7YeN4-N8KG8308bQ.gif"/></div></figure><p id="002a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大多数性能问题是由于错误或不必要的全局或局部状态更新造成的。它对性能、UI闪烁和FPS下降有负面影响。</p><ol class=""><li id="5643" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated"><strong class="kc io">错误使用了使用状态挂钩</strong></li></ol><pre class="mj mk ml mm gt mw mx my mz aw na bi"><span id="9699" class="nb lg in mx b gy nc nd l ne nf">const [data,setData] = useState(processData());</span></pre><p id="c397" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我看到了这种类型的代码片段，开发人员不是传递一些init数据，而是传递处理一些数据的方法，这可能需要一毫秒或一秒，这取决于复杂性。这不是一个好主意，这会使你的屏幕延迟打开。</p><p id="7224" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最好使用生命周期“useEffect”。</p><p id="3aa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="kc io">慢速设备的问题</strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9708" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码在大多数情况下运行良好，但是当由于RN异步的性质而打字太快时，它在慢速设备中产生了问题，因为这是一个双向操作React处理信息并通过调用setState相应地更新它的状态。接下来，典型的受控组件将其JavaScript值与本机组件值同步。</p><p id="3445" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法不错，但如果设备资源有限，并且由于内存不足，它开始闪烁，就不好了。同步问题的解决方案之一是从TextInput中完全删除value prop。因此，数据只会单向流动，从本机流向JavaScript端。</p><p id="5bb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，正如<a class="ae jz" href="https://twitter.com/nparashuram" rel="noopener ugc nofollow" target="_blank"> @nparashuram </a>在他的YouTube视频(这是了解React原生性能的一个很好的资源)中所指出的，<a class="ae jz" href="https://www.youtube.com/watch?v=83ffAY-CmL4&amp;t=1483s" rel="noopener ugc nofollow" target="_blank">在某些情况下，仅仅这种解决方法是不够的</a>。RN团队也在研究这个问题。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b6e4" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">对某些布局使用专用组件</strong></h1><p id="48c4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在原始组件之上，用一组为特定目的而设计和优化的高阶组件来反应原生船只。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/f28e2a8279eb84e969caeb3977020b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*sb99lRPiDOa6i3FY7cwHBg.gif"/></div></figure><p id="11b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不知道它们或者不在所有地方使用它们可能会影响应用程序的性能，特别是当您用真实的生产数据填充状态时</p><p id="8b50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些开发人员使用滚动视图，然后基于数组大小使用映射视图，但这不是一个好主意，如果我们有一些专用组件，那么我们为什么要尝试这样做。</p><p id="7ed6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们有很多不同大小的数据时，有时甚至一个平面列表也很慢，在这种情况下，我们需要返回固定高度(参见下面的代码片段)。</p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9709" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">选择外部库之前要小心</strong></h1><p id="4069" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">问题是大多数开发人员在挑选库时没有检查里面有什么！只为一个方法，选择整个大的库。</p><p id="70bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开发人员会发现很难从支持相同用例的多个库中进行选择。如何使用正确的JavaScript库帮助您提高应用程序的速度和性能。当选择一个用于下一个项目时，他们通常会研究告诉他们库是否健康和维护良好的指标，例如Github stars、发行数量、贡献者和PRs。</p><p id="71d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是不正确的，因为移动开发的基础是不同的，我们需要寻找资产的大小、位置、库的大小和支持特性的数量、设备支持等。</p><pre class="mj mk ml mm gt mw mx my mz aw na bi"><span id="6010" class="nb lg in mx b gy nc nd l ne nf">import moment from ‘moment’<br/>const date = moment(“12-25-1995”, “MM-DD-YYYY”);</span></pre><p id="d83d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在许多项目中看到这种类型的任务开发使用的时刻，完全是67kb大小的文件。</p><p id="1c0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用day.js(只有2Kb ),它要小得多，并且只提供我们需要的功能</p><pre class="mj mk ml mm gt mw mx my mz aw na bi"><span id="8555" class="nb lg in mx b gy nc nd l ne nf">import dayjs from ‘dayjs’<br/>const date = dayjs(“12-25-1995”, “MM-DD-YYYY”);</span></pre><p id="b7e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有其他选择，最好的经验是检查是否可以导入库的一小部分。</p><p id="d54d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">好处是“您的应用加载速度更快，这一点至关重要”</strong></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="58ec" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">永远记得使用移动平台专用的库</strong></h1><p id="d503" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">问题是你使用的网络库没有为移动优化。未优化的库会导致电池耗尽，并降低应用程序的速度。操作系统可能会限制您的应用程序功能。</p><p id="3100" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们以Firebase为例，它提供了适用于web、android和Ios的SDK。您可以运行它的web版本，不会有什么大问题:</p><pre class="mj mk ml mm gt mw mx my mz aw na bi"><span id="9802" class="nb lg in mx b gy nc nd l ne nf">import database from ‘firebase/database’;<br/>database()<br/> .ref(‘/users/123’)<br/> .on(‘value’, snapshot =&gt; {<br/> console.log(‘User data: ‘, snapshot.val());<br/> });</span></pre><p id="4ae4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子很好地说明了这一点，它不能给你和手机一样的性能。</p><p id="bfd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个特定的例子中，最好使用专用的Firebase库，它在专用的本地SDK上提供一个薄层，并提供与任何其他本地应用程序相同的性能和稳定性。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="dec9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读react-native优化的第一部分，我在一些实际项目中看到了所有这些要点大多数开发人员由于任何原因都会犯这种类型的错误，但这会导致性能或闪烁问题。</p><p id="2b2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一部分，包括</p><ol class=""><li id="bca3" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">用脚蹼调试。</li><li id="bfb4" class="mn mo in kc b kd ni kh nj kl nk kp nl kt nm kx ms mt mu mv bi translated">使用herms进行android优化。</li><li id="43f3" class="mn mo in kc b kd ni kh nj kl nk kp nl kt nm kx ms mt mu mv bi translated">优化android的梯度设置。</li><li id="f0df" class="mn mo in kc b kd ni kh nj kl nk kp nl kt nm kx ms mt mu mv bi translated">OTA和CI/CD。</li></ol><div class="nn no gp gr np nq"><a href="https://github.com/prabhat1707" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">prabhat1707 -概述</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">霍尼韦尔的SDE 2 | Android | React Native | tensor flow Block或Report从ncapdevi/FragNav An Android分叉…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jt nq"/></div></div></a></div><p id="e71d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="of">更多内容看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="of">plain English . io</em></strong></a></p></div></div>    
</body>
</html>