<html>
<head>
<title>Handle Refresh Tokens with Axios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Axios处理刷新令牌</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handle-refresh-token-with-axios-1e0f45e9afa?source=collection_archive---------1-----------------------#2021-12-30">https://javascript.plainenglish.io/handle-refresh-token-with-axios-1e0f45e9afa?source=collection_archive---------1-----------------------#2021-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="888e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用Axios处理刷新令牌的指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/79fa2ed0c3bedd139e8f2399da441ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LvYSPT7yrRLs1og5"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@shawn99lee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Shawn Lee</a> on <a class="ae ks" href="https://unsplash.com/s/photos/old-fashioned?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8bde" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">刷新访问令牌并不是一个新话题，我们有许多关于它的文章。爱情也是一样，它也不是一个新话题。但是作曲家仍然日复一日地创作新的爱情歌曲。这就是为什么我写了一篇关于如何用Axios刷新令牌的小文章。</p><h1 id="0254" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">概述此案例</h1><p id="3e6a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在编码之前，我们需要了解当前的任务和目标。在一个流行的系统中，为了在多个服务之间进行通信，我们需要一个“密钥”来确保安全性。在本文中，我将把这个密钥称为令牌。该令牌通常在规定的时间后过期。过了这个时刻，这个令牌就不能访问任何东西了。客户端必须获得新令牌才能继续使用其他服务。我们有许多自动获取新令牌的解决方案。其中之一是为客户省一个刷新令牌。当访问令牌过期时，我们可以向身份验证服务发送刷新令牌，以获得新的访问令牌(和刷新令牌)。下面我为这个概念做了一张简单的照片:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mm"><img src="../Images/5f8c8a799d32e5b7172aa0bf208cd221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*EAsyTeZuaa6iwRwWCveR5A.png"/></div></div></figure><p id="27cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这张照片，我们可以通过一些步骤来定义处理请求的基础。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/3842880c12ce4151d3c1ad10649ccea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*98pvvcyTe0OaI2HXfl77tA.png"/></div></figure><p id="27af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的照片中，我们需要采取一些措施来确保当当前的访问令牌过期时，我们可以获得一个新的访问令牌。使用新访问令牌在先前请求失败的地方继续。在本文中，我将在Axios的前端应用这个概念。</p><h1 id="82db" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">制作用于测试的服务器</h1><p id="747a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了准备在本文中使用Axios，我们需要花一点时间来制作一个示例API。这个API将帮助我们的测试更加容易。我们有两个API。一个用于访问资源，一个用于刷新令牌。使用API来访问资源，如果我们在头中调用这个错误的访问令牌，它将响应一个状态代码为401的错误。关于第二个API，那个API只是用一个新的访问令牌来响应我们(来访问第一个API)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/84e27fdd8d4426732f6b72e35aa34854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*gu7dl953mUhqW8gUSDJkUQ.png"/></div></figure><p id="7223" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我会用<a class="ae ks" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>来制作这个API，你可以用任何其他语言或者方式来制作这个API。按照上面给出的要求做两个API就行了。回到API，因为我用的是Express，所以我们需要先安装这个包。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="9341" class="mu lq in mq b gy mv mw l mx my">yarn add express</span></pre><p id="9bf6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下一步，我们只需要创建文件<strong class="kv io"> server.js </strong>。在这个文件中，我们将制作一个简单的API服务器来支持我们的测试。这个内容会这样。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6865" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要启动这个服务器，我们只需要运行<strong class="kv io">节点server.js </strong>。为了确定这个API，我将通过调用一些请求对它进行一个简单的测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3157aefad73fe94e6fbf140be2d51617.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*apHE0HLhApQfLcbN_NZ1Og.png"/></div></figure><p id="c2cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经调用了这个API的一些请求，它工作得很好。除了CURL，还可以用Postman或者其他任何工具来检查。现在，我们可以从现在开始用Axios编写代码了。</p><h1 id="e806" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用Axios处理过期令牌</h1><p id="9516" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在写第一行之前，我们需要安装Axios。只需一个简单的命令就可以安装这个包。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="7b6d" class="mu lq in mq b gy mv mw l mx my">yarn add axios</span></pre><p id="eb42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安装这个包之后，我将创建一个文件<strong class="kv io"> client.js </strong>。在这个文件中，我们将举例说明如何使用Axios处理过期的令牌。首先，我们需要创建一个Axios实例，并为其配置一些默认设置(baseURL，header…)，然后创建一个函数，用我们创建的这个实例向API发出请求。这是我在这一步的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5500" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个文件中，我用从Axios创建的方法<strong class="kv io">创建了一个Axios实例。在函数<strong class="kv io">请求</strong>中，我们将使用<strong class="kv io"> axios_instance </strong>调用API访问请求，并记录来自API的状态代码和数据。现在，我将使用命令<strong class="kv io"> node client.js </strong>运行这个文件。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/cfc68e8c0f659474b9107bbdef486aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*4NZwY5yLJ9LIWeMNx46LEg.png"/></div></figure><p id="3ae8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它抛出一个错误！因为我们还没有在这个请求的头中设置访问令牌。我们可以在函数请求中设置它。但我认为这不是一个好方法，因为我们需要在每个函数中编写相同的内容(如果我们需要在未来制作一个新功能)。为了支持这种情况，Axios提供了一个很棒的方法，即<strong class="kv io">拦截器</strong>，它帮助我们拦截请求和响应。我将在我们的客户端文件中再添加一个变量is <strong class="kv io"> access_token </strong>，并将该变量的值传递给头部。我们只是在函数请求上面添加了这段代码。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="7d0e" class="mu lq in mq b gy mv mw l mx my">let access_token = 'good';</span><span id="cf44" class="mu lq in mq b gy nd mw l mx my">axios_instance.interceptors.request.use((config) =&gt; {<br/>    config.headers['access_token'] = access_token;<br/>    return config;<br/>});</span></pre><p id="6295" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再打一次。这就是结果。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ff53d7b51646ffbbd39ad42ac715dff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*pYF_4cZ1mHwkcqQ-biJTQQ.png"/></div></figure><p id="fd25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">成功了！但这不是本文的主要任务。这就是为什么我将把<strong class="kv io"> access_token </strong>的默认值修改为“坏”，而我们的工作就是让它变得“好”。为此，我们需要处理来自API的案例401。我拍了一张照片，上面是我们将要处理的步骤。现在，我们只需要使用方法<strong class="kv io">拦截器的</strong>响应来处理它。下面是处理它的图表和代码。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/3842880c12ce4151d3c1ad10649ccea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*98pvvcyTe0OaI2HXfl77tA.png"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bf5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，如果响应是一个错误，我们需要一些步骤来处理它。</p><ul class=""><li id="ca75" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">第一步是从在<strong class="kv io">配置</strong>中输入的请求中获取<strong class="kv io">配置</strong>。在下一步中，我们需要检查来自服务器的状态代码。如果状态代码是401，我们将调用API“/refresh”请求来获取新的access_token (good)。我让函数<strong class="kv io"> refresh_token </strong>来做这件事。这个函数将返回<strong class="kv io"> Axios.get(…) </strong>。我们只需要在Axios拦截器内部调用它。</li><li id="dea4" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">之后，我们只需要从API传递一个新值给变量<strong class="kv io"> access_token </strong>。</li><li id="271e" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">在最后一步中，我们只需要返回一个新的Axios实例，带有之前请求的配置。对于其他情况，我们通过return<strong class="kv io">promise . reject(error)</strong>来处理，它会像其他错误一样抛出那个错误。</li></ul><p id="8511" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们可以再次尝试调用回调代码。下面是我得到的结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8b06fbaf39413bb662ab5d5d2034e180.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*WFCMM3FSNOXFQz_RK82mdA.png"/></div></figure><p id="7a86" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，在我们刷新了访问令牌之后，我们的请求成功了。这是用Axios处理过期令牌的基本方法。这里全是我们在<strong class="kv io"> client.js </strong>里做的东西。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2e63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但这只是一个基本的代码。我们还需要处理一些糟糕的案例。在下一部分，我们将一起处理它。</p><h1 id="7c30" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">优化一些不好的案例</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4f2a717d4352be532b12ee7407255765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aQ5RSnYGk-7K750h"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@simmerdownjpg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jackson Simmer</a> on <a class="ae ks" href="https://unsplash.com/s/photos/broken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="991c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在真实的案例中，我知道我们会处理很多不好的案例。在这里，我只写了两个糟糕的例子，分别是无限循环和处理多个刷新API的调用。</p><h2 id="d0c0" class="mu lq in bd lr nu nv dn lv nw nx dp lz lc ny nz mb lg oa ob md lk oc od mf oe bi translated"><strong class="ak">无限循环</strong></h2><p id="a89a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在当前代码中，我们假设我们的代码(客户机和服务器)总是运行良好。我们调用API，我们得到错误401，我们调用服务器来获得一个新的访问令牌，我们使用这个访问令牌来调用请求，它成功了！但是…当我们调用刷新令牌时，除了返回新的刷新令牌API之外，还继续给我们一个错误401。发生了什么事？我将像这样用状态401稍微修改刷新API。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="d0cf" class="mu lq in mq b gy mv mw l mx my">app.get('/refresh', (req, res) =&gt; {<br/>    res.status(401);<br/>    res.json({<br/>        access_token: 'good',<br/>        refresh_token: 'refresh'<br/>    })<br/>});</span></pre><p id="1969" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看我们从<strong class="kv io"> client.js </strong>得到了什么</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2d6db65570a01a7ca45bee3e2e3cd00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*KVMx5-Fr65-7C-Ju0mdvGA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Boom!</figcaption></figure><p id="45d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我说的无限循环问题。要解决这个问题，我们只需要为请求配置添加一个标志。当我们得到状态代码为401的错误时，除了当前条件之外，我还需要为检查重试标志添加一个条件。如果这个标志不在配置中，我们将为配置设置这个标志，并继续调用刷新令牌API。以下是编辑后的自定义拦截器:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ec0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我用新代码得到的结果。不再有无限循环了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/46995eb942a4d493ebfb2095f273ea08.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*23mt477qLV8sCE3k-Qba2Q.png"/></div></figure><p id="7332" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">同时有多个令牌过期的请求</strong></p><p id="11a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在解决了无限循环的问题之后，我们现在要处理另一个麻烦— <strong class="kv io">同时有多个请求</strong>。这是什么？当我们用一个过期的令牌同时调用多个请求时，就会出现这个问题。它将发出多个刷新令牌请求。我们可以多次调用函数<strong class="kv io">请求</strong>，看看我得到了什么。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/002c1a00edca1f8d946527436abbe688.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*X-MM1K43WAOFOtZpTA1brQ.png"/></div></figure><p id="4196" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这确实是一个大问题，因为我们在这个案子上至少有三个问题:</p><ul class=""><li id="2de0" class="nf ng in kv b kw kx kz la lc nh lg ni lk nj lo nk nl nm nn bi translated">第一个问题是性能，在正常情况下，我们只需要一个请求来刷新一个新令牌，之后的请求可以使用这个新令牌。但是在这种情况下，我们调用许多请求来做同样的事情。</li><li id="7d87" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">第二个问题是同步数据。对刷新令牌之类的特殊事情调用相同的请求会产生一些关于同步数据的问题。因为在应用程序中，除了更新数据之外，我们还可以做其他事情(调度一些事件……)</li><li id="acbf" class="nf ng in kv b kw no kz np lc nq lg nr lk ns lo nk nl nm nn bi translated">第三个问题是导致我们的应用程序崩溃的重要问题之一。在实际项目中，每个刷新令牌认证一次刷新访问令牌服务。如果我们同时有许多刷新令牌的请求。服务器只处理一个第一请求。其余的请求将失败，因为每个刷新令牌服务器只处理一次。它将使所有其他请求失败。这些东西可能会让我们的应用程序抛出一些错误(无法提交数据，获取数据……)。或者更糟的是，如果我们的应用程序不能获得新的令牌，即使我们获得了令牌，我们也可能会强迫用户注销！</li></ul><p id="a6fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于这个问题，我们有很多解决方案。在这篇文章中，我只是建议一个简单的方法。这将创建一个请求刷新令牌的变量。当我们需要一个刷新令牌时，除了直接调用Axios请求之外，我们只需要检查这个变量。如果这个变量为空，我们将调用函数<strong class="kv io"> refresh_token </strong>并为这个变量分配<strong class="kv io"> Axios.get </strong>。如果这个变量不为空，我们只需要等待它获得一个访问令牌。之后，我们只需要再做一步就是将这个变量设置为null。让我们看看下面这段代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="454f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在第1行，我添加了一个新变量<strong class="kv io"> refreshing_token </strong>，默认值为<strong class="kv io"> null。<em class="oi"> </em> </strong>从第10行到第12行，我用三个新行替换了“let res = await refresh_token()”。在第10行，我检查了<strong class="kv io"> refreshing_token </strong>的值，如果它的值为<strong class="kv io"> null </strong>，我将为它分配函数refresh_token。在下一行，我们只是在等待结果。之后，我们可以在第12行将这个变量的值设置为空值。这是我应用这个改动后得到的结果。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/c25f6e7a422e1be33501358d9cdd2128.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*2MRHinPEel1y8VtBVqfLpA.png"/></div></div></figure><p id="2291" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只有一个获取新访问令牌的请求，并且所有请求都使用新令牌成功。</p><p id="a677" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是<strong class="kv io"> client.js的完整代码:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="983e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="1ed3" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在本文中，我们了解了如何使用Axios处理刷新令牌。与此同时，一些糟糕情况的解决方案(比如无限循环和同时多个请求)。希望这篇文章对你有帮助。如果你有其他的解决方法和其他不好的案例，请告诉我。你可以在他们的文档中了解更多关于Axios的信息</p><div class="ok ol gp gr om on"><a href="https://axios-http.com/docs/interceptors" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">截击机</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">您可以在请求或响应被then或catch处理之前拦截它们。如果您需要移除拦截器…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">axios-http.com</p></div></div></div></a></div><p id="8a44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我的Github中的全部源代码。</p><div class="ok ol gp gr om on"><a href="https://github.com/tasynguyen3894/refresh_token_with_axios" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">GitHub-tasynguyen 3894/refresh _ token _ with _ axios</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">通过在GitHub上创建帐户，为tasynguyen 3894/refresh _ token _ with _ axios开发做出贡献。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb km on"/></div></div></a></div><p id="250c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2f76556718088cd98af10f809b9732a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UI8S9R9mKrs9Mrzu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@xnnxxmx?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Annie</a> on <a class="ae ks" href="https://unsplash.com/s/photos/jorney-new-year?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0bff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过<a class="ae ks" href="https://www.linkedin.com/in/thaisangnguyen3894/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>或<a class="ae ks" href="https://twitter.com/tasyit" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系</p></div><div class="ab cl pc pd hr pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ig ih ii ij ik"><p id="1424" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="oi">更多内容看</em> <a class="ae ks" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">说白了. io </em> </a> <em class="oi">。报名参加我们的</em> <a class="ae ks" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="oi">免费每周简讯</em> </a> <em class="oi">。在我们的</em> <a class="ae ks" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="oi">社区</em> </a> <em class="oi">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>