<html>
<head>
<title>Building a JavaScript Library for the Web with esbuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用esbuild为Web构建JavaScript库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/esbuild-library-6ec5fdb26e2c?source=collection_archive---------6-----------------------#2021-09-06">https://javascript.plainenglish.io/esbuild-library-6ec5fdb26e2c?source=collection_archive---------6-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3b79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最快的捆扎机之一</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2ea7716015ff48f861d19f5ab542e3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyvPVxnROC3FeU34lE4VBg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Credits: <a class="ae kv" href="https://github.com/evanw/esbuild" rel="noopener ugc nofollow" target="_blank">GitHub</a></figcaption></figure><p id="0a38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都喜欢JavaScript库。而且有时候，我们想自己写一个库。为什么？要捆绑通用代码，我们需要解决一个问题。下面是如何使用esbuild，一个速度极快的JavaScript bundler来做这件事。</p><p id="ca1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，有三种方式为浏览器捆绑库:</p><ol class=""><li id="4854" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">“老派”方式，用典型的脚本标签捆绑加载我们的JavaScript，并从脚本中访问所需的变量。</li><li id="5fea" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用bundler来构建应用程序，这消耗了我们的库捆绑包:像create-react-app、webpack或parcel，我们可以在其中编写导入语句，然后代码被捆绑并生成HTML模板。这个HTML模板主要使用方式1。所以它使用典型的脚本标记。</li><li id="9ad6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更现代也更危险的方法:在浏览器中使用JavaScript模块。由于脚本标签的<code class="fe mg mh mi mj b">type="module"</code>属性，我们可以在浏览器中直接使用导入语法。然而，这种方式并不被所有的浏览器所支持。</li></ol><p id="beb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到了一些事情:实际上，在捆绑我们的库代码时，方式2和方式3是相同的。由于使用<code class="fe mg mh mi mj b">export</code> <code class="fe mg mh mi mj b">import</code>语法没问题，我们在捆绑代码中进行单次或多次导出——多亏了JS web模块，我们甚至可以在浏览器中使用它。</p><p id="a34f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p><p id="5627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的小“库”的代码，导出一个函数和一个类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用esbuild进行捆绑，我们首先需要将它安装在我们的项目中:</p><p id="83a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">npm install esbuild</code></p><p id="bd37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，直接在我们的项目中，而不是在全球范围内。然后，我们可以运行esbuild来捆绑我们的文件。为此，我建议在package.json中创建一个脚本:</p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="5dd3" class="mq mr iq mj b gy ms mt l mu mv">"build": "./node_modules/.bin/esbuild index.js --outfile=bundle.js"</span></pre><p id="3fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以运行<code class="fe mg mh mi mj b">npm run build</code>或<code class="fe mg mh mi mj b">yarn run build</code>——两者都应该产生一个bundle.js。现在，bundle.js包含我们刚刚编写的相同代码——原因是，我们没有传递任何bundle选项。</p><p id="5e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们提供所需的选项，这样我们就可以导入一个最小化的库，它应该可以在每个浏览器中运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用目标选项，我们可以指定目标——在我们的例子中，是现代浏览器。我们选择的格式是ESM格式，代表ES模块。我们得到的包现在很小，导出了我们想要公开的函数和类。由于我们捆绑了ES模块语法，我们现在可以像这样导入和使用我们的库代码:</p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="98a9" class="mq mr iq mj b gy ms mt l mu mv"><em class="mw">import</em> { doubleNumber, Calculator } <em class="mw">from '</em>./bundle.js'</span><span id="a782" class="mq mr iq mj b gy mx mt l mu mv">console.log(doubleNumber(2)) // 4</span><span id="429f" class="mq mr iq mj b gy mx mt l mu mv">const calc = new Calculator(0)<br/>calc.add(10)</span><span id="c6a6" class="mq mr iq mj b gy mx mt l mu mv">console.log(calc.getNumber()) // 10</span></pre><p id="7c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现代web开发中，这是最常见的方式。我们可以在发布前捆绑的项目中轻松使用import-statement——我使用的create-react-app、Vue CLI、webpack或package。</p><h2 id="a1ee" class="mq mr iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">在浏览器中使用导入语法</h2><p id="4611" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">我们刚刚创建的库包也可以直接在浏览器中使用——这要归功于<code class="fe mg mh mi mj b">type="module"</code>属性。这里有一个小设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="991d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，代码运行。然而，目前并不是所有的浏览器都可以使用<code class="fe mg mh mi mj b">type="module"</code>。如果我们想要100%安全，最好只使用script标签来加载JavaScript文件。问题是:我们刚刚创建的包不能这样工作。当您使用普通的脚本标签在浏览器中加载<code class="fe mg mh mi mj b">bundle.js</code>时，您会看到一个错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/01516cd7cd7858013e1f1e161e966774.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*3IUVI200vGwl5efFZwKXIQ.png"/></div></figure><p id="43cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为老派的案例做一个包裹。我们需要改变的是esbuild的格式选项。除了值<code class="fe mg mh mi mj b">esm</code>，还有<code class="fe mg mh mi mj b">iife</code>可用，代表“立即调用的函数表达式”。</p><p id="3aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将我们的库代码捆绑到这样一个函数会产生这样一个代码:</p><pre class="kg kh ki kj gt mm mj mn mo aw mp bi"><span id="8a3a" class="mq mr iq mj b gy ms mt l mu mv">(() =&gt; {<br/>  // our code<br/>})(); </span></pre><p id="e477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题:我们在库中定义的类和函数将只在这个函数的范围内可用。没有办法从外面接近它。为了避免这个问题，我们可以将整个函数保存为一个全局可用的变量。我们用<code class="fe mg mh mi mj b">--global-name</code>选项来做这件事。</p><p id="6994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是运行它的整个脚本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a5f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为全局变量，我选择了<code class="fe mg mh mi mj b">lib</code>。如您所见，我们通过这个变量访问函数和类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="00d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个自调用函数的好处是什么呢？因为我们确定了函数和类(以及其他所有东西)的范围，所以在全局范围内不可能有任何与其他变量的冲突。</p><p id="d885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p><p id="cafa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>