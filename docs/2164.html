<html>
<head>
<title>Top 10 Mistakes to Avoid When Using React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React时要避免的10大错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-10-mistakes-to-avoid-when-using-react-1796711ad2a0?source=collection_archive---------1-----------------------#2021-05-07">https://javascript.plainenglish.io/top-10-mistakes-to-avoid-when-using-react-1796711ad2a0?source=collection_archive---------1-----------------------#2021-05-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f65bdb6e444ae8f44b4795c33b35f85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WtTJX6B5L6vHyT6RSh2VA.png"/></div></div></figure><p id="ccbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React已经迅速成为科技界最受欢迎的前端框架，被脸书、网飞、Airbnb等大型科技公司所使用。React开发者需求量很大，而且需求还在持续增长。</p><p id="8080" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我们将探讨React开发人员会犯的10大错误，以及如何纠正它们。</p><p id="99ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们将介绍</strong>:</p><ul class=""><li id="3d4b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">没有创建足够的组件</li><li id="ddc8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">直接修改状态</li><li id="fd7a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">传递道具时，将数字作为字符串传递</li><li id="bedb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">不在列表组件上使用键</li><li id="2d8e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">忘记了setState是异步的</li><li id="b44b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">过多使用Redux</li><li id="6658" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">创建和使用God组件</li><li id="c9d6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">不遵循React文件夹结构</li><li id="3afb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">将道具作为字符串(而不是数字)发送</li><li id="8859" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">忘记以大写字母开始组件名称</li><li id="759d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">接下来学什么</li></ul><h1 id="016e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.没有创建足够的组件</h1><p id="7a28" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">React开发人员犯的一个常见错误是他们没有创建足够的组件。使用React，您可以创建执行许多任务的大型组件，但是最好保持小型组件，一个组件对应一个功能。它不仅<strong class="jx io">节省了您的时间，而且它还帮助您调试</strong>，因为您知道哪些组件与可能出现的任何错误相关联。</p><p id="7bbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看一个<code class="fe mk ml mm mn b">TodoList</code>组件的例子:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3f9f" class="mw li in mn b gy mx my l mz na">// ./components/TodoList.js<br/><br/>import React from 'react';<br/><br/>import { useTodoList } from '../hooks/useTodoList';<br/>import { useQuery } from '../hooks/useQuery';<br/>import TodoItem from './TodoItem';<br/>import NewTodo from './NewTodo';<br/><br/>const TodoList = () =&gt; {<br/>  const { getQuery, setQuery } = useQuery();<br/>  const todos = useTodoList();<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ul&gt;<br/>        {todos.map(({ id, title, completed }) =&gt; (<br/>          &lt;TodoItem key={id} id={id} title={title} completed={completed} /&gt;<br/>        ))}<br/>        &lt;NewTodo /&gt;<br/>      &lt;/ul&gt;<br/>      &lt;div&gt;<br/>        Highlight Query for incomplete items:<br/>        &lt;input value={getQuery()} onChange={e =&gt; setQuery(e.target.value)} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default TodoList;</span></pre><h1 id="3df4" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.直接修改状态</h1><p id="c238" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">在React中，<strong class="jx io">状态应该是不可变的</strong>。如果直接修改状态，会导致难以修复的性能问题。</p><p id="e466" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个例子:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="b206" class="mw li in mn b gy mx my l mz na">const modifyPetsList = (element, id) =&gt; {<br/>  petsList[id].checked = element.target.checked;<br/>  setPetsList(petsList);<br/>};</span></pre><p id="69d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您希望根据复选框的状态更新数组中对象的选中键，但是有一个问题。React无法观察和触发重新渲染，因为对象正在使用相同的引用进行更改。</p><p id="b755" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决这个问题，你可以使用<code class="fe mk ml mm mn b">setState()</code>方法或者<code class="fe mk ml mm mn b">useState()</code>钩子。这两种方法都将确保React确认您的更改，并正确地重新呈现您的DOM。</p><p id="d7e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们重写前面的例子，使用<code class="fe mk ml mm mn b">useState()</code>方法。</p><blockquote class="nb nc nd"><p id="6605" class="jv jw ne jx b jy jz ka kb kc kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">注意</em> </strong> <em class="in">:你也可以使用</em> <code class="fe mk ml mm mn b"><em class="in">map()</em></code> <em class="in">和</em> <code class="fe mk ml mm mn b"><em class="in">spread syntax</em></code> <em class="in">来避免其他状态值的突变。</em></p></blockquote><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="08f0" class="mw li in mn b gy mx my l mz na">const modifyPetsList = (element, id) =&gt; {<br/>  const { checked } = element.target;<br/>  setpetsList((pets) =&gt; {<br/>    return pets.map((pet, index) =&gt; {<br/>      if (id === index) {<br/>        pet = { ...pet, checked };<br/>      }<br/>      return pet;<br/>    });<br/>  });<br/>};</span></pre><h1 id="7e0c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.传递道具时，将数字作为字符串传递</h1><p id="608f" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated"><strong class="jx io">在React程序中，当传递props时，将一个数字作为字符串传递会导致问题</strong>。</p><p id="18cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从一个例子开始:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4db7" class="mw li in mn b gy mx my l mz na">class Arrival extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;h1&gt;<br/>        Hi! You arrived {this.props.position === 1 ? "first!" : "last!"} .<br/>      &lt;/h1&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="6088" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，组件期望位置是一个属性，并声明位置应该是一个数字。因为您正在进行严格的比较，所以任何不是数字或不完全等于1的东西都会触发第二个表达式并打印“last！”。</p><p id="ceb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要解决这个问题，您应该像这样在输入周围插入花括号:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1228" class="mw li in mn b gy mx my l mz na">const element = &lt;Arrival position={1} /&gt;;</span></pre><h1 id="2846" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4.没有在列表组件上使用<code class="fe mk ml mm mn b">key</code></h1><p id="6c99" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">假设您需要呈现一个项目列表，您的代码如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1187" class="mw li in mn b gy mx my l mz na">const lists = ['cat', 'dog', 'fish’];<br/><br/>render() {<br/>  return (<br/>    &lt;ul&gt;<br/>      {lists.map(listNo =&gt;<br/>        &lt;li&gt;{listNo}&lt;/li&gt;)}<br/>    &lt;/ul&gt;<br/>  );<br/>}</span></pre><p id="d400" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在使用一个较小的应用程序，这可能行得通。但是在处理大型列表时，当您想要修改或删除列表中的某个项目时，会遇到呈现问题。</p><p id="1067" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> React跟踪文档对象模型(DOM)上的所有列表元素</strong>。如果没有这个记录，React不会知道您的列表中发生了什么变化。</p><p id="f1f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，<strong class="jx io">您需要为所有列表元素添加键</strong>。键给每个元素一个惟一的标识，这有助于React确定哪些项目被添加、删除、修改等。</p><p id="aca7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是如何做到这一点:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fb5c" class="mw li in mn b gy mx my l mz na">&lt;ul&gt;<br/>  {lists.map(listNo =&gt;<br/>    &lt;li key={listNo}&gt;{listNo}&lt;/li&gt;)}<br/>&lt;/ul&gt;</span></pre><h1 id="e6b7" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">5.忘记了setState是异步的</h1><p id="7e6d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">很容易忘记React中的状态是异步的。即使是最有经验的React开发人员也会忘记这一点。</p><p id="390c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步意味着<strong class="jx io">你所做的任何修改都不会立即生效</strong>(可能会在下一次渲染时生效)。<strong class="jx io"> React自动批量更新调用</strong>以提高性能。如果在设置状态值后立即访问它，可能不会得到最准确的结果。</p><p id="1ae6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个例子:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3663" class="mw li in mn b gy mx my l mz na">handlePetsUpdate = (petCount) =&gt; {<br/>  this.setState({ petCount });<br/>  this.props.callback(this.state.petCount); // Old value<br/>};</span></pre><p id="19fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过给<code class="fe mk ml mm mn b">setState()</code>一个可选的第二个参数来解决这个问题，它将作为一个回调函数。在您用您的更改更新状态之后，回调函数将被调用。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="cc7e" class="mw li in mn b gy mx my l mz na">handlePetsUpdate = (petCount) =&gt; {<br/>  this.setState({ petCount }, () =&gt; {<br/>    this.props.callback(this.state.petCount); // Updated value<br/>  });<br/>};</span></pre><blockquote class="nb nc nd"><p id="216e" class="jv jw ne jx b jy jz ka kb kc kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">注</em> </strong> <em class="in">:对于</em> <code class="fe mk ml mm mn b"><em class="in">useState()</em></code> <em class="in">也是如此，只不过他们没有类似于</em> <code class="fe mk ml mm mn b"><em class="in">setState()</em></code> <em class="in">的回调自变量。相反，你可以使用</em> <code class="fe mk ml mm mn b"><em class="in">useEffect()</em></code> <em class="in">钩子来得到同样的结果。</em></p></blockquote><h1 id="2bd2" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">6.过多使用Redux</h1><p id="25c7" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">对于更大的React应用程序，许多开发人员使用Redux来管理全局状态。虽然Redux很有用，但你不需要用它来管理你的应用程序的每一个状态。</p><p id="d695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您的应用程序没有任何需要交换信息的并行级组件，则无需向项目添加额外的库。当您使用一个表单组件并希望在每次访问check按钮时检查它的状态时，建议使用本地状态方法或Redux上的<code class="fe mk ml mm mn b">useState</code>。</p><h1 id="f63e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">7.创建和使用God组件</h1><p id="6ea9" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated"><strong class="jx io"> God组件是单片的，不可重复使用</strong>。在React中，它们被称为“反模式”。你不应该把所有的UI元素都塞进一个组件来构建一个完整的页面。相反，你应该花时间勾勒出你的应用程序中不同的相互关联的部分，并把它们组成自己的组件。当您以这种方式分离组件时，应用程序的所有部分都更容易维护，并在需要时进行重组。</p><h1 id="ff94" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">8.不遵循ReactJS文件夹结构</h1><p id="de67" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">您创建的项目不仅仅是为了当前的开发。它们将来很可能需要维护或操作。<strong class="jx io">在考虑项目的未来可能性时，文件夹结构非常重要</strong>。</p><p id="25bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看ReactJS社区遵循的标准文件夹结构:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/744321734f2238ea8cb672c1386e5c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxyLeUYp2vMhq0Jf6vISuA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Standard React JS Folder Structure</figcaption></figure><p id="dbdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当导航到任何现有项目时，为容器、资产和组件提供单独的位置是很有用的。遵循命名约定也有助于提高可读性和组织性。这有助于您轻松识别项目中编写的任何代码的用途。</p><h1 id="c378" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">9.将道具作为字符串(而不是数字)发送</h1><p id="b4d8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">有编写大量HTML经验的React开发人员发现编写这样的代码很自然:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7df0" class="mw li in mn b gy mx my l mz na">&lt;MyComponent value=”4” /&gt;</span></pre><p id="7c77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个值属性实际上将作为字符串发送给MyComponent。如果您确实需要它作为一个数字，您可以通过使用类似于<code class="fe mk ml mm mn b">parseInt()</code>的函数或者插入花括号而不是引号来解决这个问题。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="f3aa" class="mw li in mn b gy mx my l mz na">&lt;MyComponent value={4} /&gt;</span></pre><h1 id="9afa" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">10.忘记以大写字母开始组件名称</h1><p id="544e" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">忘记以大写字母开始组件名称是一个很容易犯的小错误。<strong class="jx io">在JSX，以小写字母开头的组件编译成HTML元素</strong>。</p><p id="e7a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设你写了这样的东西:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="b2af" class="mw li in mn b gy mx my l mz na">class demoComponentName extends React.Component {<br/>}</span></pre><p id="daa2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将导致一个错误，告诉您如果您打算呈现React组件，您需要以大写字母开始它的名称。</p><p id="5d90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个错误有一个简单的解决方法，就是以大写字母开始组件名称，如下所示:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="07f9" class="mw li in mn b gy mx my l mz na">class DemoComponentName extends React.Component {<br/>}</span></pre><h1 id="cf88" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">接下来学什么</h1><p id="d9d4" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">既然我们已经探讨了React开发人员会犯的十大错误，是时候开始使用React并应用您今天在这里学到的技能了。React开发人员需求量很大，所以将React加入你的技能是明智的职业投资。</p><p id="50b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一些推荐的概念:</p><ul class=""><li id="4cb9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">React中的库</li><li id="80fd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在React中初始化Firebase</li><li id="821b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">React中全局状态的应用程序开发</li><li id="c009" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">等等。</li></ul><p id="ff55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ne">快乐学习！</em></p><p id="1062" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ne">更多内容请看</em><a class="ae nn" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="ne">plain English . io</em></a></p></div></div>    
</body>
</html>